{
  "version_": [],
  "__version__": [],
  "__all__": [],
  "get_data": [
    "dataset",
    "folder",
    "save_copy",
    "profile",
    "verbose",
    "address"
  ],
  "_EXPERIMENT_CLASS": [],
  "_CURRENT_EXPERIMENT_EXCEPTION": [],
  "_CURRENT_EXPERIMENT_DECORATOR_DICT": [],
  "setup": [
    "data",
    "data_func",
    "index",
    "ordinal_features",
    "numeric_features",
    "categorical_features",
    "date_features",
    "text_features",
    "ignore_features",
    "keep_features",
    "preprocess",
    "create_date_columns",
    "imputation_type",
    "numeric_imputation",
    "categorical_imputation",
    "text_features_method",
    "max_encoding_ohe",
    "encoding_method",
    "rare_to_value",
    "rare_value",
    "polynomial_features",
    "polynomial_degree",
    "low_variance_threshold",
    "group_features",
    "drop_groups",
    "remove_multicollinearity",
    "multicollinearity_threshold",
    "bin_numeric_features",
    "remove_outliers",
    "outliers_method",
    "outliers_threshold",
    "transformation",
    "transformation_method",
    "normalize",
    "normalize_method",
    "pca",
    "pca_method",
    "pca_components",
    "custom_pipeline",
    "custom_pipeline_position",
    "n_jobs",
    "use_gpu",
    "html",
    "session_id",
    "system_log",
    "log_experiment",
    "experiment_name",
    "experiment_custom_tags",
    "log_plots",
    "log_profile",
    "log_data",
    "verbose",
    "memory",
    "profile",
    "profile_kwargs"
  ],
  "create_model": [
    "model",
    "fraction",
    "verbose",
    "fit_kwargs",
    "experiment_custom_tags"
  ],
  "assign_model": [
    "model",
    "transformation",
    "score",
    "verbose"
  ],
  "plot_model": [
    "model",
    "plot",
    "feature",
    "label",
    "scale",
    "save",
    "display_format"
  ],
  "evaluate_model": [
    "model",
    "feature",
    "fit_kwargs"
  ],
  "predict_model": [
    "model",
    "data"
  ],
  "deploy_model": [
    "model",
    "model_name",
    "authentication",
    "platform"
  ],
  "save_model": [
    "model",
    "model_name",
    "model_only",
    "verbose"
  ],
  "load_model": [
    "model_name",
    "platform",
    "authentication",
    "verbose"
  ],
  "pull": [
    "pop"
  ],
  "models": [
    "internal",
    "raise_errors"
  ],
  "get_logs": [
    "experiment_name",
    "save"
  ],
  "get_config": [
    "variable"
  ],
  "set_config": [
    "variable",
    "value"
  ],
  "save_experiment": [
    "path_or_file"
  ],
  "load_experiment": [
    "path_or_file",
    "data",
    "data_func",
    "preprocess_data"
  ],
  "set_current_experiment": [
    "experiment"
  ],
  "get_current_experiment": [],
  "LOGGER": [],
  "AnomalyExperiment": {
    "__init__": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "ml_usecase"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "feature_name",
      "label",
      "verbose",
      "display_format"
    ]
  },
  "BaseContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "args"
    ],
    "get_class_name": [
      "self"
    ],
    "get_package_name": [
      "self"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "get_all_containers": [
    "container_globals",
    "experiment",
    "type_var",
    "raise_errors"
  ],
  "MetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "args",
      "display_name",
      "greater_is_better",
      "is_custom"
    ],
    "score_func": [
      "self",
      "value"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "AnomalyMetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "target",
      "args",
      "display_name",
      "greater_is_better",
      "needs_ground_truth",
      "is_custom"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "get_all_metric_containers": [
    "globals_dict",
    "raise_errors"
  ],
  "TimeSeriesMetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "target",
      "args",
      "display_name",
      "greater_is_better",
      "is_custom"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "_smape_loss": [
    "y_true",
    "y_pred"
  ],
  "mape": [
    "y_true",
    "y_pred"
  ],
  "mase": [
    "y_true",
    "y_pred",
    "y_train",
    "sp"
  ],
  "rmsse": [
    "y_true",
    "y_pred",
    "y_train",
    "sp"
  ],
  "coverage": [
    "y_true",
    "y_pred",
    "lower",
    "upper"
  ],
  "_check_series": [
    "y"
  ],
  "_set_y_as_series": [
    "y"
  ],
  "MASEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "RMSSEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "MAEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "RMSEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "MAPEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "SMAPEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "R2MetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "CovProbMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "ClassificationMetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "target",
      "args",
      "display_name",
      "greater_is_better",
      "is_multiclass",
      "is_custom"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "AccuracyMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "ROCAUCMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "RecallMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "PrecisionMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "F1MetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "KappaMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "MCCMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "ClusterMetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "target",
      "args",
      "display_name",
      "greater_is_better",
      "needs_ground_truth",
      "is_custom"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "SilhouetteMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "CHSMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "DBMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "HSMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "ARIMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "CSMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "RegressionMetricContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "score_func",
      "scorer",
      "target",
      "args",
      "display_name",
      "greater_is_better",
      "is_custom"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "MSEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "RMSLEMetricContainer": {
    "__init__": [
      "self",
      "globals_dict"
    ]
  },
  "_DEFAULT_N_ANOMALYS": [],
  "AnomalyContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "eq_function",
      "args",
      "is_special",
      "tune_grid",
      "tune_distribution",
      "tune_args",
      "is_gpu_enabled"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "ABODAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "CBLOFAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "COFAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "IForestAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "HBOSAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "KNNAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LOFAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "OCSVMAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "PCAAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "MCDAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SODAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SOSAnomalyContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "get_all_model_containers": [
    "experiment",
    "raise_errors"
  ],
  "get_container_default_engines": [],
  "TimeSeriesContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "is_turbo",
      "eq_function",
      "args",
      "is_special",
      "tune_grid",
      "tune_distribution",
      "tune_args",
      "is_gpu_enabled",
      "tunable"
    ],
    "get_dict": [
      "self",
      "internal"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "NaiveContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "GrandMeansContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "SeasonalNaiveContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "PolyTrendContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "ArimaContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AutoArimaContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "ExponentialSmoothingContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "ETSContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "ThetaContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "STLFContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "CrostonContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "BATSContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "TBATSContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "ProphetContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "CdsDtContainer": {
    "active": [],
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "id": [
      "self"
    ],
    "name": [
      "self"
    ],
    "return_regressor_class": [
      "self"
    ],
    "_set_regressor_args": [
      "self"
    ],
    "_set_args": [
      "self"
    ]
  },
  "LinearCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "ElasticNetCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "RidgeCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "LassoCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "LassoLarsCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "BayesianRidgeCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "HuberCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "OrthogonalMatchingPursuitCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "KNeighborsCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "DecisionTreeCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "RandomForestCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "ExtraTreesCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "GradientBoostingCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "AdaBoostCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "XGBCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_regressor_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "LGBMCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "return_regressor_class": [
      "self"
    ],
    "_set_regressor_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "CatBoostCdsDtContainer": {
    "id": [],
    "name": [],
    "active": [],
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "return_regressor_class": [
      "self"
    ],
    "_set_regressor_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ],
    "_set_tune_distributions": [
      "self"
    ]
  },
  "BaseCdsDtForecaster": {
    "model_type": [],
    "_tags": [],
    "__init__": [
      "self",
      "regressor",
      "sp",
      "deseasonal_model",
      "degree",
      "window_length",
      "fe_target_rr"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ]
  },
  "EnsembleTimeSeriesContainer": {
    "model_type": [],
    "__init__": [
      "self",
      "experiment"
    ],
    "_set_args": [
      "self"
    ],
    "_set_tune_grid": [
      "self"
    ]
  },
  "ModelContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "eq_function",
      "args",
      "is_special"
    ],
    "is_estimator_equal": [
      "self",
      "estimator"
    ],
    "get_dict": [
      "self",
      "internal"
    ],
    "_set_engine": [
      "self",
      "id",
      "experiment",
      "severity"
    ],
    "_set_engine_related_vars": [
      "self",
      "id",
      "all_allowed_engines",
      "experiment"
    ]
  },
  "leftover_parameters_to_categorical_distributions": [
    "tune_grid",
    "tune_distributions"
  ],
  "ClassifierContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "is_turbo",
      "eq_function",
      "args",
      "is_special",
      "tune_grid",
      "tune_distribution",
      "tune_args",
      "shap",
      "is_gpu_enabled",
      "is_boosting_supported",
      "is_soft_voting_supported",
      "tunable"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "LogisticRegressionClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "KNeighborsClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "GaussianNBClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "DecisionTreeClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SGDClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SVCClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "GaussianProcessClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "MLPClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RidgeClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RandomForestClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "QuadraticDiscriminantAnalysisContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AdaBoostClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "GradientBoostingClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LinearDiscriminantAnalysisContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "ExtraTreesClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "XGBClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LGBMClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "CatBoostClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "DummyClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "BaggingClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "StackingClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "VotingClassifierContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "CalibratedClassifierCVContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "_DEFAULT_N_CLUSTERS": [],
  "ClusterContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "eq_function",
      "args",
      "is_special",
      "tune_grid",
      "tune_distribution",
      "tune_args",
      "is_gpu_enabled"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "KMeansClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AffinityPropagationClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "MeanShiftClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SpectralClusteringClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AgglomerativeClusteringClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "DBSCANClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "OPTICSClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "BirchClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "KModesClusterContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RegressorContainer": {
    "__init__": [
      "self",
      "id",
      "name",
      "class_def",
      "is_turbo",
      "eq_function",
      "args",
      "is_special",
      "tune_grid",
      "tune_distribution",
      "tune_args",
      "shap",
      "is_gpu_enabled",
      "tunable"
    ],
    "get_dict": [
      "self",
      "internal"
    ]
  },
  "LinearRegressionContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LassoRegressionContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RidgeRegressionContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "ElasticNetContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LarsContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LassoLarsContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "OrthogonalMatchingPursuitContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "BayesianRidgeContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AutomaticRelevanceDeterminationContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "PassiveAggressiveRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RANSACRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "TheilSenRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "HuberRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "KernelRidgeContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "SVRContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "KNeighborsRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "DecisionTreeRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "RandomForestRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "ExtraTreesRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "AdaBoostRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "GradientBoostingRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "MLPRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "XGBRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "LGBMRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "CatBoostRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "DummyRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "BaggingRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "StackingRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "VotingRegressorContainer": {
    "__init__": [
      "self",
      "experiment"
    ]
  },
  "_fit_failed_message_warning": [],
  "get_pos_label": [
    "globals_dict"
  ],
  "_get_response_method": [
    "response_method",
    "needs_threshold",
    "needs_proba"
  ],
  "EncodedDecodedLabelsScoreFunc": {
    "__init__": [
      "self",
      "score_func",
      "labels"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "EncodedDecodedLabelsReplaceScoreFunc": {
    "__init__": [
      "self",
      "score_func",
      "labels"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "BinaryMulticlassScoreFunc": {
    "__init__": [
      "self",
      "score_func",
      "kwargs_if_binary",
      "response_method"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "ScorerWithErrorScore": {
    "__init__": [
      "self",
      "score_func",
      "sign",
      "kwargs",
      "error_score",
      "response_method"
    ],
    "_score": [
      "self",
      "method_caller",
      "estimator",
      "X",
      "y_true",
      "sample_weight"
    ],
    "_factory_args": [
      "self"
    ]
  },
  "make_scorer_with_error_score": [
    "score_func"
  ],
  "Distribution": {
    "__init__": [
      "self"
    ],
    "get_base": [
      "self"
    ],
    "get_skopt": [
      "self"
    ],
    "get_optuna": [
      "self"
    ],
    "get_hyperopt": [
      "self",
      "label"
    ],
    "get_CS": [
      "self",
      "label"
    ],
    "get_tune": [
      "self"
    ]
  },
  "UniformDistribution": {
    "__init__": [
      "self",
      "lower",
      "upper",
      "log"
    ],
    "get_base": [
      "self"
    ],
    "get_skopt": [
      "self"
    ],
    "get_optuna": [
      "self"
    ],
    "get_hyperopt": [
      "self",
      "label"
    ],
    "get_CS": [
      "self",
      "label"
    ],
    "get_tune": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "IntUniformDistribution": {
    "__init__": [
      "self",
      "lower",
      "upper",
      "log"
    ],
    "get_base": [
      "self"
    ],
    "get_skopt": [
      "self"
    ],
    "get_optuna": [
      "self"
    ],
    "get_hyperopt": [
      "self",
      "label"
    ],
    "get_CS": [
      "self",
      "label"
    ],
    "get_tune": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "DiscreteUniformDistribution": {
    "__init__": [
      "self",
      "lower",
      "upper",
      "q"
    ],
    "get_base": [
      "self"
    ],
    "get_skopt": [
      "self"
    ],
    "get_optuna": [
      "self"
    ],
    "get_hyperopt": [
      "self",
      "label"
    ],
    "get_CS": [
      "self",
      "label"
    ],
    "get_tune": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "CategoricalDistribution": {
    "__init__": [
      "self",
      "values"
    ],
    "get_base": [
      "self"
    ],
    "get_skopt": [
      "self"
    ],
    "get_optuna": [
      "self"
    ],
    "get_hyperopt": [
      "self",
      "label"
    ],
    "get_CS": [
      "self",
      "label"
    ],
    "get_tune": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "get_base_distributions": [
    "distributions"
  ],
  "get_skopt_distributions": [
    "distributions"
  ],
  "get_optuna_distributions": [
    "distributions"
  ],
  "get_hyperopt_distributions": [
    "distributions"
  ],
  "get_CS_distributions": [
    "distributions"
  ],
  "get_tune_distributions": [
    "distributions"
  ],
  "get_min_max": [
    "o"
  ],
  "get_dbscan": [],
  "get_kmeans": [],
  "get_svc_classifier": [],
  "get_ridge_classifier": [],
  "get_random_forest_classifier": [],
  "get_random_forest_regressor": [],
  "INVERSE_ONLY": [],
  "_copy_estimator_state": [
    "source",
    "target"
  ],
  "_final_estimator_has": [
    "attr"
  ],
  "_fit_one": [
    "transformer",
    "X",
    "y",
    "message",
    "params"
  ],
  "_transform_one": [
    "transformer",
    "X",
    "y"
  ],
  "_inverse_transform_one": [
    "transformer",
    "y"
  ],
  "_fit_transform_one": [
    "transformer",
    "X",
    "y",
    "message",
    "params"
  ],
  "_full_transform": [
    "pipeline",
    "X",
    "y"
  ],
  "_noop_transform": [
    "pipeline",
    "X",
    "y"
  ],
  "Pipeline": {
    "__init__": [
      "self",
      "steps"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "_pycaret_versions": [
      "self"
    ],
    "feature_names_in_": [
      "self"
    ],
    "memory": [
      "self",
      "value"
    ],
    "_memory_full_transform": [
      "self"
    ],
    "_iter": [
      "self",
      "with_final",
      "filter_passthrough",
      "filter_train_only",
      "reverse"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "routed_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y",
      "filter_train_only"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_clear_final_estimator_fit_vars": [
      "self",
      "all"
    ],
    "get_sklearn_pipeline": [
      "self"
    ],
    "replace_final_estimator": [
      "self",
      "new_final_estimator",
      "name"
    ],
    "set_params": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ]
  },
  "TimeSeriesPipeline": {
    "_get_fit_params": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "fh"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "fit_resample": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "estimator_pipeline": {
    "__init__": [
      "self",
      "pipeline",
      "estimator"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "pipeline_predict_inverse_only": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "add_estimator_to_pipeline": [
    "pipeline",
    "estimator",
    "name"
  ],
  "merge_pipelines": [
    "pipeline_to_merge_to",
    "pipeline_to_be_merged"
  ],
  "get_pipeline_estimator_label": [
    "pipeline"
  ],
  "get_pipeline_fit_kwargs": [
    "pipeline",
    "fit_kwargs"
  ],
  "LoggerWriter": {
    "__init__": [
      "self",
      "writer"
    ],
    "write": [
      "self",
      "message"
    ],
    "flush": [
      "self"
    ]
  },
  "redirect_output": {
    "__init__": [
      "self",
      "logger"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "DummyLogger": {
    "debug": [],
    "info": [],
    "warning": [],
    "warn": [],
    "error": [],
    "exception": [],
    "critical": [],
    "log": []
  },
  "get_logger": [],
  "create_logger": [
    "log"
  ],
  "_warnings_showwarning": [],
  "_showwarning": [
    "message",
    "category",
    "filename",
    "lineno",
    "file",
    "line"
  ],
  "captureWarnings": [
    "capture"
  ],
  "PowerTransformedTargetRegressor": {
    "__init__": [
      "self",
      "regressor"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "CustomProbabilityThresholdClassifier": {
    "__init__": [
      "self",
      "classifier"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "get_estimator_from_meta_estimator": [
    "estimator"
  ],
  "DEFAULT_MIN_TIME_TO_CACHE": [],
  "DEFAULT_BYTES_LIMIT": [],
  "DEFAULT_CALLS_BETWEEN_REDUCE": [],
  "_FileWriteToHash": {
    "closed": [],
    "__init__": [
      "self",
      "hash"
    ],
    "write": [
      "self",
      "bytes"
    ]
  },
  "FastHasher": {
    "__init__": [
      "self",
      "hash_name",
      "protocol"
    ],
    "hash": [
      "self",
      "obj",
      "return_digest"
    ],
    "save_global": [
      "self",
      "obj",
      "name",
      "pack"
    ],
    "dispatch": []
  },
  "FastNumpyHasher": {
    "__init__": [
      "self",
      "hash_name",
      "coerce_mmap",
      "protocol"
    ],
    "_make_array_contiguous_if_needed": [
      "self",
      "arr"
    ],
    "_get_coerced_mmap_class": [
      "self",
      "arr"
    ],
    "_get_numpy_metadata_tuple": [
      "self",
      "arr"
    ],
    "save": [
      "self",
      "obj"
    ]
  },
  "FastPandasHasher": {
    "__init__": [
      "self",
      "hash_name",
      "coerce_mmap",
      "protocol"
    ],
    "save": [
      "self",
      "obj"
    ]
  },
  "fast_hash": [
    "obj",
    "hash_name",
    "coerce_mmap",
    "protocol"
  ],
  "FastMemorizedFunc": {
    "__init__": [
      "self"
    ],
    "_get_argument_hash": [
      "self"
    ],
    "call": [
      "self"
    ],
    "_cached_call": [
      "self",
      "args",
      "kwargs",
      "shelving"
    ],
    "call_and_shelve": [
      "self"
    ]
  },
  "FastMemory": {
    "__init__": [
      "self"
    ],
    "reduce_size": [
      "self"
    ],
    "cache": [
      "self",
      "func",
      "ignore",
      "verbose",
      "mmap_mode"
    ],
    "__del__": [
      "self"
    ]
  },
  "get_memory": [
    "memory"
  ],
  "Pickler": {
    "__init__": [
      "self",
      "file",
      "protocol"
    ]
  },
  "_create_bucket_gcp": [
    "project_name",
    "bucket_name"
  ],
  "_upload_blob_gcp": [
    "project_name",
    "bucket_name",
    "source_file_name",
    "destination_blob_name"
  ],
  "_download_blob_gcp": [
    "project_name",
    "bucket_name",
    "source_blob_name",
    "destination_file_name"
  ],
  "_create_container_azure": [
    "container_name"
  ],
  "_upload_blob_azure": [
    "container_name",
    "source_file_name",
    "destination_blob_name"
  ],
  "_download_blob_azure": [
    "container_name",
    "source_blob_name",
    "destination_file_name"
  ],
  "is_sklearn_pipeline": [
    "object"
  ],
  "is_sklearn_cv_generator": [
    "object"
  ],
  "is_fitted": [
    "estimator"
  ],
  "fit_if_not_fitted": {
    "__init__": [
      "self",
      "estimator",
      "X_train",
      "y_train",
      "groups"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "supports_partial_fit": [
    "estimator",
    "params"
  ],
  "TunableMixin": {
    "get_base_sklearn_type": [
      "self"
    ],
    "get_base_sklearn_params": [
      "self"
    ],
    "get_base_sklearn_object": [
      "self"
    ]
  },
  "TunableMLPClassifier": {
    "__init__": [
      "self",
      "hidden_layer_sizes",
      "activation"
    ],
    "_hidden_layer_size_kwargs_to_hidden_layer_sizes": [
      "self",
      "kwargs"
    ],
    "_hidden_layer_sizes_to_hidden_layer_size_kwargs": [
      "self"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "TunableMLPRegressor": {
    "__init__": [
      "self",
      "hidden_layer_sizes",
      "activation"
    ],
    "_hidden_layer_size_kwargs_to_hidden_layer_sizes": [
      "self",
      "kwargs"
    ],
    "_hidden_layer_sizes_to_hidden_layer_size_kwargs": [
      "self"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "TunableVotingClassifier": {
    "__init__": [
      "self",
      "estimators"
    ],
    "_weight_kwargs_to_weights": [
      "self",
      "kwargs",
      "estimators"
    ],
    "_weights_to_weight_kwargs": [
      "self"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "TunableVotingRegressor": {
    "__init__": [
      "self",
      "estimators"
    ],
    "_weight_kwargs_to_weights": [
      "self",
      "kwargs",
      "estimators"
    ],
    "_weights_to_weight_kwargs": [
      "self"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "convert_to_fp64": [
    "X"
  ],
  "CBLOFForceToDouble": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "_mp_sample_without_replacement": [
    "n_population",
    "n_samples",
    "method",
    "random_state"
  ],
  "_mp_ParameterGrid_getitem": [
    "self",
    "ind"
  ],
  "MultimetricScorerPatched": {
    "_use_cache": [
      "self",
      "estimator"
    ]
  },
  "fit_and_score": [],
  "score": [
    "f"
  ],
  "is_estimator": [
    "model"
  ],
  "get_model_name": [
    "model"
  ],
  "_summary_stats": [
    "data",
    "data_name",
    "data_kwargs"
  ],
  "_is_gaussian": [
    "data",
    "data_name",
    "alpha",
    "verbose",
    "data_kwargs"
  ],
  "logger": [],
  "run_test": [
    "data",
    "test",
    "data_name",
    "alpha",
    "data_kwargs"
  ],
  "_test_all": [
    "data",
    "data_name",
    "alpha",
    "data_kwargs"
  ],
  "_is_stationary": [
    "data",
    "data_name",
    "alpha",
    "data_kwargs"
  ],
  "_is_stationary_adf": [
    "data",
    "data_name",
    "alpha",
    "verbose",
    "data_kwargs"
  ],
  "_is_stationary_kpss": [
    "data",
    "data_name",
    "alpha",
    "verbose",
    "data_kwargs"
  ],
  "_is_white_noise": [
    "data",
    "data_name",
    "lags",
    "alpha",
    "verbose",
    "data_kwargs"
  ],
  "is_trending": [],
  "is_seasonal": [],
  "recommend_lowercase_d": [
    "data"
  ],
  "recommend_uppercase_d": [
    "data",
    "sp"
  ],
  "recommend_seasonal_period": [],
  "_format_test_results": [
    "result",
    "test",
    "test_name"
  ],
  "__author__": [],
  "msg1": [],
  "msg2": [],
  "_get_plot": [
    "plot",
    "fig_defaults",
    "data",
    "data_label",
    "X",
    "X_labels",
    "cv",
    "model_results",
    "model_labels",
    "return_pred_int",
    "data_kwargs",
    "fig_kwargs"
  ],
  "plot_series": [
    "y",
    "y_label",
    "fig_defaults",
    "X",
    "X_labels",
    "hoverinfo",
    "fig_kwargs"
  ],
  "plot_cv": [
    "data",
    "cv",
    "fig_defaults",
    "fig_kwargs"
  ],
  "plot_xacf": [
    "data",
    "plot",
    "fig_defaults",
    "data_label",
    "model_labels",
    "data_kwargs",
    "fig_kwargs"
  ],
  "plot_model_results": [
    "original_data",
    "model_results",
    "model_labels",
    "plot",
    "fig_defaults",
    "hoverinfo",
    "fig_kwargs"
  ],
  "plot_diagnostics": [
    "data",
    "fig_defaults",
    "data_label",
    "model_labels",
    "hoverinfo",
    "fig_kwargs"
  ],
  "plot_predictions_with_confidence": [
    "data",
    "predictions",
    "fig_defaults",
    "model_labels",
    "data_kwargs",
    "fig_kwargs"
  ],
  "plot_time_series_decomposition": [
    "data",
    "plot",
    "fig_defaults",
    "data_kwargs",
    "data_label",
    "model_labels",
    "fig_kwargs"
  ],
  "plot_time_series_differences": [
    "data",
    "fig_defaults",
    "data_label",
    "model_labels",
    "hoverinfo",
    "data_kwargs",
    "fig_kwargs"
  ],
  "plot_frequency_components": [
    "data",
    "plot",
    "fig_defaults",
    "data_label",
    "model_labels",
    "hoverinfo",
    "fig_kwargs"
  ],
  "plot_ccf": [
    "y",
    "y_label",
    "fig_defaults",
    "X",
    "X_labels",
    "fig_kwargs"
  ],
  "QQPlotWidget": {
    "__init__": [
      "self",
      "predicted",
      "expected",
      "featuresize",
      "split_origin"
    ],
    "__get_qq": [
      "standardized_residuals"
    ],
    "__qq_plot": [
      "self",
      "standardized_residuals",
      "split_origin"
    ],
    "update_values": [
      "self",
      "predicted",
      "expected",
      "featuresize",
      "split_origin"
    ]
  },
  "ScaleLocationWidget": {
    "__init__": [
      "self",
      "predictions",
      "sqrt_abs_standardized_residuals",
      "split_origin"
    ],
    "__scale_location_plot": [
      "fitted",
      "sqrt_abs_standardized_residuals",
      "split_origin"
    ],
    "update_values": [
      "self",
      "predicted",
      "sqrt_abs_standardized_residuals",
      "split_origin"
    ]
  },
  "CooksDistanceWidget": {
    "__init__": [
      "self",
      "model_leverage",
      "cooks_distances",
      "standardized_residuals",
      "n_model_params",
      "split_origin"
    ],
    "__cooks_distance_plot": [
      "model_leverage",
      "cooks_distances",
      "standardized_residuals",
      "n_model_params",
      "split_origin"
    ],
    "update_values": [
      "self",
      "model_leverage",
      "cooks_distances",
      "standardized_residuals",
      "n_model_params",
      "split_origin"
    ]
  },
  "TukeyAnscombeWidget": {
    "__init__": [
      "self",
      "predictions",
      "residuals",
      "split_origin"
    ],
    "__tukey_anscombe_plot": [
      "predictions",
      "residuals",
      "split_origin"
    ],
    "update_values": [
      "self",
      "predictions",
      "residuals",
      "split_origin"
    ]
  },
  "InteractiveResidualsPlot": {
    "__init__": [
      "self",
      "model",
      "x",
      "y",
      "x_test",
      "y_test",
      "display"
    ],
    "show": [
      "self"
    ],
    "get_html": [
      "self"
    ],
    "write_html": [
      "self",
      "plot_filename"
    ],
    "__create_resplots": [
      "self",
      "model",
      "x",
      "y",
      "x_test",
      "y_test"
    ]
  },
  "leverage_statistic": [
    "x"
  ],
  "calculate_standardized_residual": [
    "predicted",
    "expected",
    "featuresize"
  ],
  "cooks_distance": [
    "standardized_residuals",
    "leverage_statistic",
    "n_model_params"
  ],
  "MatplotlibDefaultDPI": {
    "__init__": [
      "self",
      "base_dpi",
      "scale_to_set"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "show_yellowbrick_in_streamlit": [
    "visualizer",
    "outpath",
    "clear_figure"
  ],
  "show_yellowbrick_plot": [
    "visualizer",
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "name",
    "handle_train",
    "handle_test",
    "scale",
    "save",
    "fit_kwargs",
    "display_format"
  ],
  "PlotReturnType": [],
  "ALLOWED_PLOT_DATA_TYPES": [],
  "MULTIPLE_PLOT_TYPES_ALLOWED_AT_ONCE": [],
  "time_series_subplot": [
    "fig",
    "data",
    "row",
    "col",
    "hoverinfo"
  ],
  "corr_subplot": [
    "fig",
    "data",
    "row",
    "col",
    "name",
    "plot",
    "nlags"
  ],
  "_add_corr_stems_subplot": [
    "fig",
    "corr_values",
    "lags",
    "name",
    "row",
    "col"
  ],
  "_add_corr_bounds_subplot": [
    "fig",
    "lower",
    "upper",
    "row",
    "col"
  ],
  "qq_subplot": [
    "fig",
    "data",
    "row",
    "col",
    "name"
  ],
  "dist_subplot": [
    "fig",
    "data",
    "row",
    "col"
  ],
  "decomp_subplot": [
    "fig",
    "data",
    "col",
    "plot",
    "classical_decomp_type",
    "period"
  ],
  "return_frequency_components": [
    "data",
    "type"
  ],
  "_return_periodogram": [
    "data"
  ],
  "_return_fft": [
    "data"
  ],
  "frequency_components_subplot": [
    "fig",
    "data",
    "row",
    "col",
    "hoverinfo",
    "plot",
    "name"
  ],
  "plot_original_with_overlays": [
    "original_data",
    "overlay_data",
    "title",
    "fig_defaults",
    "hoverinfo",
    "fig_kwargs"
  ],
  "_update_fig_dimensions": [
    "fig",
    "fig_kwargs",
    "fig_defaults"
  ],
  "_get_subplot_rows_cols": [
    "num_subplots",
    "rows",
    "cols"
  ],
  "_resolve_hoverinfo": [
    "hoverinfo",
    "threshold",
    "data",
    "X"
  ],
  "_resolve_renderer": [
    "renderer",
    "threshold",
    "data",
    "X"
  ],
  "_get_data_types_to_plot": [
    "plot",
    "data_types_requested"
  ],
  "_reformat_dataframes_for_plots": [
    "data",
    "labels_suffix"
  ],
  "_clean_model_results_labels": [
    "model_results",
    "model_labels"
  ],
  "_plot_fig_update": [
    "fig",
    "title",
    "fig_defaults",
    "fig_kwargs",
    "show_legend"
  ],
  "TimeSeriesExperiment": {
    "__init__": [
      "self"
    ]
  },
  "_TSSupervisedExperiment": {
    "X": [
      "self"
    ],
    "dataset_transformed": [
      "self"
    ],
    "X_train_transformed": [
      "self"
    ],
    "train_transformed": [
      "self"
    ],
    "X_transformed": [
      "self"
    ],
    "X_train": [
      "self"
    ],
    "X_test": [
      "self"
    ],
    "test": [
      "self"
    ],
    "test_transformed": [
      "self"
    ],
    "y_transformed": [
      "self"
    ],
    "X_test_transformed": [
      "self"
    ],
    "y_train_transformed": [
      "self"
    ],
    "y_test_transformed": [
      "self"
    ],
    "_create_model_get_train_X_y": [
      "self",
      "X_train",
      "y_train"
    ]
  },
  "_TabularExperiment": {
    "__init__": [
      "self"
    ],
    "_pack_for_remote": [
      "self"
    ],
    "_get_setup_display": [
      "self"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "_get_groups": [
      "self",
      "groups",
      "data",
      "fold_groups"
    ],
    "_get_cv_splitter": [
      "self",
      "fold",
      "ml_usecase"
    ],
    "_is_unsupervised": [
      "self"
    ],
    "_get_model_id": [
      "self",
      "e",
      "models"
    ],
    "_get_metric_by_name_or_id": [
      "self",
      "name_or_id",
      "metrics"
    ],
    "_get_model_name": [
      "self",
      "e",
      "deep",
      "models"
    ],
    "_log_model": [
      "self",
      "model",
      "model_results",
      "score_dict",
      "source",
      "runtime",
      "model_fit_time",
      "pipeline",
      "log_holdout",
      "log_plots",
      "tune_cv_results",
      "URI",
      "experiment_custom_tags",
      "display"
    ],
    "_profile": [
      "self",
      "profile",
      "profile_kwargs"
    ],
    "_validate_log_experiment": [
      "self",
      "obj"
    ],
    "_convert_log_experiment": [
      "self",
      "log_experiment"
    ],
    "_initialize_setup": [
      "self",
      "n_jobs",
      "use_gpu",
      "html",
      "session_id",
      "system_log",
      "log_experiment",
      "experiment_name",
      "memory",
      "verbose"
    ],
    "plot_model_check_display_format_": [
      "display_format"
    ],
    "_plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "feature_name",
      "label",
      "verbose",
      "system",
      "display",
      "display_format"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "feature_name",
      "label",
      "verbose",
      "display_format"
    ],
    "evaluate_model": [
      "self",
      "estimator",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "feature_name",
      "groups"
    ],
    "predict_model": [
      "self"
    ],
    "finalize_model": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "models": [
      "self",
      "type",
      "internal",
      "raise_errors"
    ],
    "deploy_model": [
      "self",
      "model",
      "model_name",
      "authentication",
      "platform"
    ],
    "save_model": [
      "self",
      "model",
      "model_name",
      "model_only",
      "verbose"
    ],
    "load_model": [
      "self",
      "model_name",
      "platform",
      "authentication",
      "verbose"
    ],
    "convert_model": [
      "estimator",
      "language"
    ],
    "create_api": [
      "self",
      "estimator",
      "api_name",
      "host",
      "port"
    ],
    "create_docker": [
      "self",
      "api_name",
      "base_image",
      "expose_port"
    ],
    "_set_all_models": [
      "self"
    ],
    "get_allowed_engines": [
      "self",
      "estimator"
    ],
    "get_engine": [
      "self",
      "estimator"
    ],
    "_set_engine": [
      "self",
      "estimator",
      "engine",
      "severity"
    ],
    "_set_exp_model_engines": [
      "self",
      "container_default_engines",
      "engine"
    ],
    "_set_all_metrics": [
      "self"
    ]
  },
  "_PyCaretExperiment": {
    "_attributes_to_not_save": [],
    "__init__": [
      "self"
    ],
    "_pack_for_remote": [
      "self"
    ],
    "_unpack_at_remote": [
      "self",
      "data"
    ],
    "_register_setup_params": [
      "self",
      "params"
    ],
    "_property_keys": [
      "self"
    ],
    "gpu_n_jobs_param": [
      "self"
    ],
    "variables": [
      "self"
    ],
    "is_multiclass": [
      "self"
    ],
    "variable_and_property_keys": [
      "self"
    ],
    "_check_environment": [
      "self"
    ],
    "setup": [
      "self"
    ],
    "_check_setup_ran": [
      "self"
    ],
    "deploy_model": [
      "self",
      "model",
      "model_name",
      "authentication",
      "platform"
    ],
    "save_model": [
      "self",
      "model",
      "model_name",
      "model_only",
      "verbose"
    ],
    "load_model": [
      "self",
      "model_name",
      "platform",
      "authentication",
      "verbose"
    ],
    "get_logs": [
      "self",
      "experiment_name",
      "save"
    ],
    "get_config": [
      "self",
      "variable"
    ],
    "set_config": [
      "self",
      "variable",
      "value"
    ],
    "__getstate__": [
      "self"
    ],
    "_load_experiment": [
      "cls",
      "path_or_file",
      "cloudpickle_kwargs",
      "preprocess_data"
    ],
    "load_experiment": [
      "cls",
      "path_or_file",
      "data",
      "data_func",
      "preprocess_data"
    ],
    "save_experiment": [
      "self",
      "path_or_file"
    ],
    "pull": [
      "self",
      "pop"
    ],
    "dataset": [
      "self"
    ],
    "X": [
      "self"
    ],
    "dataset_transformed": [
      "self"
    ],
    "X_train": [
      "self"
    ],
    "train": [
      "self"
    ],
    "X_train_transformed": [
      "self"
    ],
    "train_transformed": [
      "self"
    ],
    "X_transformed": [
      "self"
    ]
  },
  "_SupervisedExperiment": {
    "_create_app_predict_kwargs": [],
    "__init__": [
      "self"
    ],
    "_calculate_metrics": [
      "self",
      "y_test",
      "pred",
      "pred_prob",
      "weights"
    ],
    "_is_unsupervised": [
      "self"
    ],
    "_get_final_model_from_pipeline": [
      "self",
      "pipeline",
      "check_is_fitted"
    ],
    "_choose_better": [
      "self",
      "models_and_results",
      "compare_dimension",
      "fold",
      "fit_kwargs",
      "groups",
      "display"
    ],
    "_get_cv_n_folds": [
      "self",
      "fold",
      "X",
      "y",
      "groups"
    ],
    "_set_up_logging": [
      "self",
      "runtime",
      "log_data",
      "log_profile",
      "experiment_custom_tags"
    ],
    "_parallel_compare_models": [
      "self",
      "parallel",
      "caller_params",
      "turbo"
    ],
    "_get_greater_is_worse_columns": [
      "self"
    ],
    "_highlight_models": [
      "self",
      "master_display_"
    ],
    "_process_sort": [
      "self",
      "sort"
    ],
    "compare_models": [
      "self",
      "include",
      "exclude",
      "fold",
      "round",
      "cross_validation",
      "sort",
      "n_select",
      "budget_time",
      "turbo",
      "errors",
      "fit_kwargs",
      "groups",
      "experiment_custom_tags",
      "probability_threshold",
      "verbose",
      "parallel",
      "caller_params"
    ],
    "_create_model_without_cv": [
      "self",
      "model",
      "data_X",
      "data_y",
      "fit_kwargs",
      "round",
      "predict",
      "system",
      "display",
      "model_only",
      "return_train_score"
    ],
    "_create_model_with_cv": [
      "self",
      "model",
      "data_X",
      "data_y",
      "fit_kwargs",
      "round",
      "cv",
      "groups",
      "metrics",
      "refit",
      "system",
      "display",
      "error_score",
      "return_train_score"
    ],
    "_get_return_train_score_columns_for_display": [
      "self",
      "return_train_score"
    ],
    "_get_return_train_score_indices_for_logging": [
      "self",
      "return_train_score"
    ],
    "_highlight_and_round_model_results": [
      "self",
      "model_results",
      "return_train_score",
      "round"
    ],
    "_create_model_get_train_X_y": [
      "self",
      "X_train",
      "y_train"
    ],
    "_create_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "cross_validation",
      "predict",
      "fit_kwargs",
      "groups",
      "refit",
      "probability_threshold",
      "experiment_custom_tags",
      "verbose",
      "system",
      "add_to_model_list",
      "X_train_data",
      "y_train_data",
      "metrics",
      "display",
      "model_only",
      "return_train_score",
      "error_score"
    ],
    "create_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "cross_validation",
      "predict",
      "fit_kwargs",
      "groups",
      "refit",
      "probability_threshold",
      "experiment_custom_tags",
      "verbose",
      "return_train_score"
    ],
    "tune_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "n_iter",
      "custom_grid",
      "optimize",
      "custom_scorer",
      "search_library",
      "search_algorithm",
      "early_stopping",
      "early_stopping_max_iters",
      "choose_better",
      "fit_kwargs",
      "groups",
      "return_tuner",
      "verbose",
      "tuner_verbose",
      "return_train_score"
    ],
    "ensemble_model": [
      "self",
      "estimator",
      "method",
      "fold",
      "n_estimators",
      "round",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "blend_models": [
      "self",
      "estimator_list",
      "fold",
      "round",
      "choose_better",
      "optimize",
      "method",
      "weights",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "stack_models": [
      "self",
      "estimator_list",
      "meta_model",
      "meta_model_fold",
      "fold",
      "round",
      "method",
      "restack",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "interpret_model": [
      "self",
      "estimator",
      "plot",
      "feature",
      "observation",
      "use_train_data",
      "X_new_sample",
      "y_new_sample",
      "save"
    ],
    "models": [
      "self",
      "type",
      "internal",
      "raise_errors"
    ],
    "get_metrics": [
      "self",
      "reset",
      "include_custom",
      "raise_errors"
    ],
    "add_metric": [
      "self",
      "id",
      "name",
      "score_func",
      "target",
      "greater_is_better",
      "multiclass"
    ],
    "remove_metric": [
      "self",
      "name_or_id"
    ],
    "finalize_model": [
      "self",
      "estimator",
      "fit_kwargs",
      "groups",
      "model_only",
      "experiment_custom_tags"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "probability_threshold",
      "encoded_labels",
      "raw_score",
      "round",
      "verbose",
      "ml_usecase",
      "preprocess"
    ],
    "get_leaderboard": [
      "self",
      "finalize_models",
      "model_only",
      "fit_kwargs",
      "groups",
      "verbose"
    ],
    "check_fairness": [
      "self",
      "estimator",
      "sensitive_features",
      "plot_kwargs"
    ],
    "automl": [
      "self",
      "optimize",
      "use_holdout",
      "turbo",
      "return_train_score"
    ],
    "create_app": [
      "self",
      "estimator",
      "app_kwargs"
    ],
    "dashboard": [
      "self",
      "estimator",
      "display_format",
      "dashboard_kwargs",
      "run_kwargs"
    ],
    "check_drift": [
      "self",
      "reference_data",
      "current_data",
      "target",
      "numeric_features",
      "categorical_features",
      "date_features",
      "filename"
    ],
    "load_experiment": [
      "cls",
      "path_or_file",
      "data",
      "data_func",
      "test_data",
      "preprocess_data"
    ],
    "X": [
      "self"
    ],
    "dataset_transformed": [
      "self"
    ],
    "X_train_transformed": [
      "self"
    ],
    "train_transformed": [
      "self"
    ],
    "X_transformed": [
      "self"
    ],
    "y": [
      "self"
    ],
    "X_train": [
      "self"
    ],
    "X_test": [
      "self"
    ],
    "train": [
      "self"
    ],
    "test": [
      "self"
    ],
    "y_train": [
      "self"
    ],
    "y_test": [
      "self"
    ],
    "test_transformed": [
      "self"
    ],
    "y_transformed": [
      "self"
    ],
    "X_test_transformed": [
      "self"
    ],
    "y_train_transformed": [
      "self"
    ],
    "y_test_transformed": [
      "self"
    ]
  },
  "_NonTSSupervisedExperiment": {
    "__init__": [
      "self"
    ],
    "test": [
      "self"
    ],
    "X": [
      "self"
    ],
    "X_train": [
      "self"
    ],
    "X_test": [
      "self"
    ],
    "dataset_transformed": [
      "self"
    ],
    "train_transformed": [
      "self"
    ],
    "test_transformed": [
      "self"
    ],
    "X_transformed": [
      "self"
    ],
    "y_transformed": [
      "self"
    ],
    "X_train_transformed": [
      "self"
    ],
    "y_train_transformed": [
      "self"
    ],
    "X_test_transformed": [
      "self"
    ],
    "y_test_transformed": [
      "self"
    ],
    "_create_model_get_train_X_y": [
      "self",
      "X_train",
      "y_train"
    ]
  },
  "_UnsupervisedExperiment": {
    "__init__": [
      "self"
    ],
    "_calculate_metrics": [
      "self",
      "X",
      "labels",
      "ground_truth",
      "ml_usecase"
    ],
    "_is_unsupervised": [
      "self"
    ],
    "_set_up_logging": [
      "self",
      "runtime",
      "log_data",
      "log_profile",
      "experiment_custom_tags"
    ],
    "setup": [
      "self",
      "data",
      "data_func",
      "index",
      "ordinal_features",
      "numeric_features",
      "categorical_features",
      "date_features",
      "text_features",
      "ignore_features",
      "keep_features",
      "preprocess",
      "create_date_columns",
      "imputation_type",
      "numeric_imputation",
      "categorical_imputation",
      "text_features_method",
      "max_encoding_ohe",
      "encoding_method",
      "rare_to_value",
      "rare_value",
      "polynomial_features",
      "polynomial_degree",
      "low_variance_threshold",
      "group_features",
      "drop_groups",
      "remove_multicollinearity",
      "multicollinearity_threshold",
      "bin_numeric_features",
      "remove_outliers",
      "outliers_method",
      "outliers_threshold",
      "transformation",
      "transformation_method",
      "normalize",
      "normalize_method",
      "pca",
      "pca_method",
      "pca_components",
      "custom_pipeline",
      "custom_pipeline_position",
      "n_jobs",
      "use_gpu",
      "html",
      "session_id",
      "system_log",
      "log_experiment",
      "experiment_name",
      "experiment_custom_tags",
      "log_plots",
      "log_profile",
      "log_data",
      "verbose",
      "memory",
      "profile",
      "profile_kwargs",
      "engines"
    ],
    "assign_model": [
      "self",
      "model",
      "transformation",
      "score",
      "verbose"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "ml_usecase"
    ],
    "_create_model": [
      "self",
      "estimator",
      "num_clusters",
      "fraction",
      "ground_truth",
      "round",
      "fit_kwargs",
      "experiment_custom_tags",
      "verbose",
      "system",
      "add_to_model_list",
      "raise_num_clusters",
      "X_data",
      "display"
    ],
    "create_model": [
      "self",
      "estimator",
      "num_clusters",
      "fraction",
      "ground_truth",
      "round",
      "fit_kwargs",
      "experiment_custom_tags",
      "engine",
      "verbose"
    ],
    "evaluate_model": [
      "self",
      "estimator",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "feature_name",
      "groups"
    ]
  },
  "TransformerWrapper": {
    "__init__": [
      "self",
      "transformer",
      "include",
      "exclude"
    ],
    "feature_names_in_": [
      "self"
    ],
    "_name_cols": [
      "self",
      "array",
      "df"
    ],
    "_reorder_cols": [
      "self",
      "df",
      "original_df"
    ],
    "_prepare_df": [
      "self",
      "X",
      "out"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TransformerWrapperWithInverse": {
    "inverse_transform": [
      "self",
      "y"
    ]
  },
  "CleanColumnNames": {
    "__init__": [
      "self",
      "match"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ExtractDateTimeFeatures": {
    "__init__": [
      "self",
      "features"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "DropImputer": {
    "__init__": [
      "self",
      "columns"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "EmbedTextFeatures": {
    "__init__": [
      "self",
      "method",
      "kwargs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "RareCategoryGrouping": {
    "__init__": [
      "self",
      "rare_to_value",
      "value"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "GroupFeatures": {
    "__init__": [
      "self",
      "group_features",
      "drop_groups"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "RemoveMulticollinearity": {
    "__init__": [
      "self",
      "threshold"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "RemoveOutliers": {
    "__init__": [
      "self",
      "method",
      "threshold",
      "n_jobs",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "FixImbalancer": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TargetTransformer": {
    "__init__": [
      "self",
      "estimator",
      "enforce_2d"
    ],
    "_enforce_2d_on_y": [
      "self",
      "y"
    ],
    "fit": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ],
    "fit_transform": [
      "self",
      "y"
    ]
  },
  "Preprocessor": {
    "_prepare_dataset": [
      "self",
      "X",
      "y"
    ],
    "_set_index": [
      "self",
      "df"
    ],
    "_prepare_train_test": [
      "self",
      "train_size",
      "test_data",
      "data_split_stratify",
      "data_split_shuffle"
    ],
    "_prepare_column_types": [
      "self",
      "ordinal_features",
      "numeric_features",
      "categorical_features",
      "date_features",
      "text_features",
      "ignore_features",
      "keep_features"
    ],
    "_prepare_folds": [
      "self",
      "fold_strategy",
      "fold",
      "fold_shuffle",
      "fold_groups",
      "data_split_shuffle"
    ],
    "_clean_column_names": [
      "self"
    ],
    "_encode_target_column": [
      "self"
    ],
    "_target_transformation": [
      "self",
      "transformation_method"
    ],
    "_date_feature_engineering": [
      "self",
      "create_date_columns"
    ],
    "_simple_imputation": [
      "self",
      "numeric_imputation",
      "categorical_imputation"
    ],
    "_iterative_imputation": [
      "self",
      "iterative_imputation_iters",
      "numeric_iterative_imputer",
      "categorical_iterative_imputer"
    ],
    "_text_embedding": [
      "self",
      "text_features_method"
    ],
    "_encoding": [
      "self",
      "max_encoding_ohe",
      "encoding_method",
      "rare_to_value",
      "rare_value"
    ],
    "_polynomial_features": [
      "self",
      "polynomial_degree"
    ],
    "_low_variance": [
      "self",
      "low_variance_threshold"
    ],
    "_group_features": [
      "self",
      "group_features",
      "drop_groups"
    ],
    "_remove_multicollinearity": [
      "self",
      "multicollinearity_threshold"
    ],
    "_bin_numerical_features": [
      "self",
      "bin_numeric_features"
    ],
    "_remove_outliers": [
      "self",
      "outliers_method",
      "outliers_threshold"
    ],
    "_balance": [
      "self",
      "fix_imbalance_method",
      "session_id"
    ],
    "_transformation": [
      "self",
      "transformation_method"
    ],
    "_normalization": [
      "self",
      "normalize_method"
    ],
    "_pca": [
      "self",
      "pca_method",
      "pca_components"
    ],
    "_feature_selection": [
      "self",
      "feature_selection_method",
      "feature_selection_estimator",
      "n_features_to_select"
    ],
    "_add_custom_pipeline": [
      "self",
      "custom_pipeline",
      "custom_pipeline_position"
    ]
  },
  "prepare_estimator_for_categoricals": [
    "estimator",
    "categorical_indices"
  ],
  "_inverse_map_pd": [
    "Xt",
    "mappings",
    "feature_name_in",
    "index"
  ],
  "IterativeImputer": {
    "__init__": [
      "self",
      "num_estimator",
      "cat_estimator"
    ],
    "_initial_imputation": [
      "self",
      "X",
      "in_fit"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_impute_one_feature": [
      "self",
      "X_filled",
      "mask_missing_values",
      "feat_idx",
      "neighbor_feat_idx",
      "estimator",
      "fit_mode"
    ]
  },
  "TransformedTargetRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "TransformedTargetClassifier": {
    "__init__": [
      "self",
      "classifier"
    ],
    "_fit_transformer": [
      "self",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_more_tags": [
      "self"
    ],
    "n_features_in_": [
      "self"
    ]
  },
  "TargetTransformerMixin": {
    "estimator": [
      "self"
    ],
    "_carry_over_estimator_fit_vars": [
      "self",
      "fitted_estimator",
      "ignore"
    ],
    "_clear_estimator_fit_vars": [
      "self",
      "fitted_estimator",
      "all"
    ]
  },
  "TSForecastingPreprocessor": {
    "_imputation": [
      "self",
      "numeric_imputation_target",
      "numeric_imputation_exogenous",
      "exogenous_present"
    ],
    "_add_imputation_steps": [
      "self",
      "numeric_imputation",
      "target"
    ],
    "_transformation": [
      "self",
      "transform_target",
      "transform_exogenous",
      "exogenous_present"
    ],
    "_add_transformation_steps": [
      "self",
      "transform",
      "target"
    ],
    "_scaling": [
      "self",
      "scale_target",
      "scale_exogenous",
      "exogenous_present"
    ],
    "_add_scaling_steps": [
      "self",
      "scale",
      "target"
    ],
    "_feature_engineering": [
      "self",
      "fe_exogenous",
      "exogenous_present"
    ],
    "_add_feat_eng_steps": [
      "self",
      "fe_exogenous",
      "target"
    ]
  },
  "COLAB_ENABLED": [],
  "EMPTY_HTML": [],
  "EMPTY": [],
  "_enable_matplotlib_inline": [],
  "_enable_colab": [],
  "_is_in_jupyter_notebook": [],
  "DisplayBackend": {
    "display": [
      "self",
      "obj"
    ],
    "clear_display": [
      "self"
    ],
    "clear_output": [
      "self"
    ]
  },
  "SilentBackend": {
    "display": [
      "self",
      "obj"
    ],
    "clear_display": [
      "self"
    ],
    "clear_output": [
      "self"
    ]
  },
  "CLIBackend": {
    "display": [
      "self",
      "obj"
    ],
    "clear_display": [
      "self"
    ],
    "clear_output": [
      "self"
    ],
    "_handle_input": [
      "self",
      "obj"
    ]
  },
  "JupyterBackend": {
    "_empty_content": [],
    "__init__": [
      "self"
    ],
    "display": [
      "self",
      "obj"
    ],
    "_display": [
      "self",
      "obj"
    ],
    "clear_display": [
      "self"
    ],
    "clear_output": [
      "self"
    ],
    "_handle_input": [
      "self",
      "obj"
    ]
  },
  "ColabBackend": {
    "__init__": [
      "self"
    ]
  },
  "DatabricksBackend": {
    "_empty_content": [],
    "display": [
      "self",
      "obj"
    ],
    "_handle_input": [
      "self",
      "obj"
    ]
  },
  "detect_backend": [
    "backend"
  ],
  "ProgressBarBackend": {
    "__init__": [
      "self",
      "value",
      "min",
      "max",
      "description",
      "backend"
    ],
    "open": [
      "self"
    ],
    "step": [
      "self",
      "value"
    ],
    "close": [
      "self"
    ],
    "__del__": [
      "self"
    ]
  },
  "CLIProgressBarBackend": {
    "open": [
      "self"
    ]
  },
  "CustomDisplayNotebookTqdm": {
    "__init__": [
      "self"
    ],
    "display": [
      "self",
      "msg",
      "pos",
      "close",
      "bar_style",
      "check_delay"
    ],
    "close": [
      "self"
    ]
  },
  "JupyterProgressBarBackend": {
    "open": [
      "self"
    ]
  },
  "ProgressBarDisplay": {
    "__init__": [
      "self",
      "value",
      "min",
      "max",
      "description"
    ],
    "display": [
      "self"
    ],
    "step": [
      "self",
      "value"
    ],
    "close": [
      "self"
    ]
  },
  "CommonDisplay": {
    "display_progress": [
      "self"
    ],
    "move_progress": [
      "self",
      "value"
    ],
    "update_monitor": [
      "self",
      "row_idx",
      "message"
    ],
    "display": [
      "self",
      "df"
    ],
    "clear_output": [
      "self"
    ],
    "close": [
      "self"
    ],
    "can_update_text": [
      "self"
    ],
    "can_update_rich": [
      "self"
    ],
    "can_display": [
      "self"
    ],
    "__init__": [
      "self",
      "verbose",
      "html_param",
      "progress_args",
      "monitor_rows"
    ]
  },
  "DummyDisplay": {
    "__init__": [
      "self"
    ],
    "can_display": [
      "self"
    ]
  },
  "DisplayComponent": {
    "__init__": [
      "self"
    ],
    "backend": [
      "self",
      "val"
    ],
    "close": [
      "self"
    ]
  },
  "MonitorDisplay": {
    "__init__": [
      "self",
      "monitor_rows"
    ],
    "display": [
      "self",
      "clear"
    ],
    "update": [
      "self",
      "row_idx",
      "message"
    ]
  },
  "ParallelBackend": {
    "__init__": [
      "self"
    ],
    "attach": [
      "self",
      "instance"
    ],
    "remote_setup": [
      "self"
    ],
    "compare_models": [
      "self",
      "instance",
      "params"
    ]
  },
  "required_deps": [],
  "optional_deps": [],
  "_get_sys_info": [],
  "_get_deps_info": [
    "optional",
    "logger"
  ],
  "show_versions": [
    "optional",
    "logger"
  ],
  "coerce_period_to_datetime_index": [
    "data",
    "freq",
    "inplace"
  ],
  "coerce_datetime_to_period_index": [
    "data",
    "freq",
    "inplace"
  ],
  "version": [],
  "__getattr__": [
    "name"
  ],
  "MLUsecase": {
    "CLASSIFICATION": [],
    "REGRESSION": [],
    "CLUSTERING": [],
    "ANOMALY": [],
    "TIME_SERIES": []
  },
  "get_ml_task": [
    "y"
  ],
  "highlight_setup": [
    "column"
  ],
  "get_classification_task": [
    "y"
  ],
  "to_df": [
    "data",
    "index",
    "columns",
    "dtypes"
  ],
  "to_series": [
    "data",
    "index",
    "name"
  ],
  "check_features_exist": [
    "features",
    "X"
  ],
  "id_or_display_name": [
    "metric",
    "input_ml_usecase",
    "target_ml_usecase"
  ],
  "variable_return": [
    "X",
    "y"
  ],
  "save_config": [
    "file_name",
    "globals_d"
  ],
  "load_config": [
    "file_name",
    "globals_d"
  ],
  "color_df": [
    "df",
    "color",
    "names",
    "axis"
  ],
  "get_model_id": [
    "e",
    "all_models"
  ],
  "is_special_model": [
    "e",
    "all_models"
  ],
  "get_class_name": [
    "class_var"
  ],
  "get_package_name": [
    "class_var"
  ],
  "param_grid_to_lists": [
    "param_grid"
  ],
  "np_list_arange": [
    "start",
    "stop",
    "step",
    "inclusive"
  ],
  "calculate_unsupervised_metrics": [
    "metrics",
    "X",
    "labels",
    "ground_truth",
    "score_dict"
  ],
  "_calculate_unsupervised_metric": [
    "container",
    "score_func",
    "display_name",
    "X",
    "labels",
    "ground_truth"
  ],
  "get_function_params": [
    "function"
  ],
  "calculate_metrics": [
    "metrics",
    "y_test",
    "pred",
    "pred_proba",
    "score_dict",
    "weights"
  ],
  "_calculate_metric": [
    "container",
    "score_func",
    "display_name",
    "y_test",
    "pred_",
    "pred_proba",
    "weights"
  ],
  "normalize_custom_transformers": [
    "transformers"
  ],
  "_check_custom_transformer": [
    "transformer"
  ],
  "get_cv_splitter": [
    "fold",
    "default",
    "seed",
    "shuffle",
    "int_default"
  ],
  "get_cv_n_folds": [
    "fold",
    "default",
    "X",
    "y",
    "groups"
  ],
  "set_n_jobs": {
    "__init__": [
      "self",
      "model",
      "n_jobs"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "true_warm_start": {
    "__init__": [
      "self",
      "model"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "nullcontext": {
    "__init__": [
      "self",
      "enter_result"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "get_groups": [
    "groups",
    "X_train",
    "default"
  ],
  "get_all_object_vars_and_properties": [
    "object"
  ],
  "is_fit_var": [
    "key"
  ],
  "can_early_stop": [
    "estimator",
    "consider_partial_fit",
    "consider_warm_start",
    "consider_xgboost",
    "params"
  ],
  "infer_ml_usecase": [
    "y"
  ],
  "get_columns_to_stratify_by": [
    "X",
    "y",
    "stratify"
  ],
  "check_if_global_is_not_none": [
    "globals_d",
    "global_names"
  ],
  "df_shrink_dtypes": [
    "df",
    "skip",
    "obj2cat",
    "int2uint"
  ],
  "get_label_encoder": [
    "pipeline"
  ],
  "mlflow_remove_bad_chars": [
    "string"
  ],
  "deep_clone": [
    "estimator"
  ],
  "check_metric": [
    "actual",
    "prediction",
    "metric",
    "round",
    "train"
  ],
  "_get_metrics_dict": [
    "metrics_dict"
  ],
  "enable_colab": [],
  "get_system_logs": [],
  "_coerce_empty_dataframe_to_none": [
    "data"
  ],
  "_resolve_dict_keys": [
    "dict_",
    "key",
    "defaults"
  ],
  "get_allowed_engines": [
    "estimator",
    "all_allowed_engines"
  ],
  "LazyExperimentMapping": {
    "__init__": [
      "self",
      "experiment"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "INSTALLED_MODULES": [],
  "_try_import_and_get_module_version": [
    "modname"
  ],
  "get_installed_modules": [],
  "_get_module_version": [
    "modname"
  ],
  "get_module_version": [
    "modname"
  ],
  "is_module_installed": [
    "modname"
  ],
  "_check_soft_dependencies": [
    "package",
    "severity",
    "extra",
    "install_name"
  ],
  "SEQUENCE": [],
  "SEQUENCE_LIKE": [],
  "DATAFRAME_LIKE": [],
  "TARGET_LIKE": [],
  "LABEL_COLUMN": [],
  "SCORE_COLUMN": [],
  "_reconcile_order_and_lags": [
    "order_list",
    "lags_list"
  ],
  "_get_diffs": [
    "data",
    "lags_list"
  ],
  "get_diffs": [
    "data",
    "order_list",
    "lags_list"
  ],
  "_get_diff_name_list": [
    "data",
    "data_name",
    "data_kwargs"
  ],
  "get_sp_from_str": [
    "str_freq"
  ],
  "auto_detect_sp": [
    "y",
    "verbose",
    "plot"
  ],
  "remove_harmonics_from_sp": [
    "significant_sps",
    "harmonic_order_method"
  ],
  "clean_time_index": [
    "data",
    "freq",
    "index_col"
  ],
  "SeasonalPeriod": {
    "B": [],
    "D": [],
    "W": [],
    "M": [],
    "Q": [],
    "A": [],
    "Y": [],
    "H": [],
    "T": [],
    "min": [],
    "S": []
  },
  "TSModelTypes": {
    "BASELINE": [],
    "CLASSICAL": [],
    "LINEAR": [],
    "NEIGHBORS": [],
    "TREE": []
  },
  "TSExogenousPresent": {
    "YES": [],
    "NO": []
  },
  "TSApproachTypes": {
    "UNI": [],
    "MULTI": []
  },
  "TSAllowedPlotDataTypes": {
    "ORIGINAL": [],
    "TRANSFORMED": [],
    "IMPUTED": []
  },
  "MissingDataError": {},
  "_disable_pred_int_enforcement": [
    "forecaster",
    "enforce_pi"
  ],
  "_disable_exogenous_enforcement": [
    "forecaster",
    "enforce_exogenous",
    "exp_has_exogenous"
  ],
  "_check_enforcements": [
    "forecaster",
    "experiment"
  ],
  "DummyForecaster": {
    "_tags": [],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ]
  },
  "PyCaretForecastingHorizonTypes": [],
  "_check_and_clean_coverage": [
    "coverage"
  ],
  "get_predictions_with_intervals": [
    "forecaster",
    "alpha",
    "coverage",
    "X",
    "fh",
    "merge",
    "round"
  ],
  "update_additional_scorer_kwargs": [
    "initial_kwargs",
    "y_train",
    "lower",
    "upper"
  ],
  "_add_model_to_pipeline": [
    "pipeline",
    "model"
  ],
  "_transformations_present_X": [
    "pipeline"
  ],
  "_transformations_present_y": [
    "pipeline"
  ],
  "_are_pipeline_tansformations_empty": [
    "pipeline"
  ],
  "_get_imputed_data": [
    "pipeline",
    "y",
    "X"
  ],
  "_get_pipeline_estimator_label": [
    "pipeline"
  ],
  "_pipeline_transform": [
    "pipeline",
    "y",
    "X"
  ],
  "get_folds": [
    "cv",
    "y"
  ],
  "_fit_and_score": [
    "pipeline",
    "y",
    "X",
    "scoring",
    "train",
    "test",
    "parameters",
    "fit_params",
    "return_train_score",
    "alpha",
    "coverage",
    "error_score"
  ],
  "cross_validate": [
    "pipeline",
    "y",
    "X",
    "cv",
    "scoring",
    "fit_params",
    "n_jobs",
    "return_train_score",
    "alpha",
    "coverage",
    "error_score",
    "verbose"
  ],
  "BaseGridSearch": {
    "__init__": [
      "self",
      "pipeline",
      "cv",
      "alpha",
      "coverage",
      "n_jobs",
      "pre_dispatch",
      "refit",
      "refit_metric",
      "scoring",
      "verbose",
      "error_score",
      "return_train_score"
    ],
    "fit": [
      "self",
      "y",
      "X",
      "additional_scorer_kwargs"
    ],
    "_format_results": [
      "candidate_params",
      "scorers",
      "out",
      "n_splits"
    ]
  },
  "ForecastingGridSearchCV": {
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "alpha",
      "coverage",
      "param_grid",
      "scoring",
      "n_jobs",
      "refit",
      "refit_metric",
      "verbose",
      "pre_dispatch",
      "error_score",
      "return_train_score"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ]
  },
  "ForecastingRandomizedSearchCV": {
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "alpha",
      "coverage",
      "param_distributions",
      "n_iter",
      "scoring",
      "n_jobs",
      "refit",
      "refit_metric",
      "verbose",
      "random_state",
      "pre_dispatch",
      "error_score",
      "return_train_score"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ]
  },
  "get_engine": [
    "estimator"
  ],
  "get_metrics": [
    "reset",
    "include_custom",
    "raise_errors"
  ],
  "add_metric": [
    "id",
    "name",
    "score_func",
    "target",
    "greater_is_better",
    "multiclass"
  ],
  "remove_metric": [
    "name_or_id"
  ],
  "ClusteringExperiment": {
    "__init__": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "ml_usecase"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "feature_name",
      "label",
      "verbose",
      "display_format"
    ],
    "get_metrics": [
      "self",
      "reset",
      "include_custom",
      "raise_errors"
    ],
    "add_metric": [
      "self",
      "id",
      "name",
      "score_func",
      "greater_is_better",
      "needs_ground_truth"
    ],
    "remove_metric": [
      "self",
      "name_or_id"
    ]
  },
  "compare_models": [
    "include",
    "exclude",
    "fold",
    "round",
    "cross_validation",
    "sort",
    "n_select",
    "budget_time",
    "turbo",
    "errors",
    "fit_kwargs",
    "groups",
    "experiment_custom_tags",
    "probability_threshold",
    "engine",
    "verbose",
    "parallel"
  ],
  "tune_model": [
    "estimator",
    "fold",
    "round",
    "n_iter",
    "custom_grid",
    "optimize",
    "custom_scorer",
    "search_library",
    "search_algorithm",
    "early_stopping",
    "early_stopping_max_iters",
    "choose_better",
    "fit_kwargs",
    "groups",
    "return_tuner",
    "verbose",
    "tuner_verbose",
    "return_train_score"
  ],
  "ensemble_model": [
    "estimator",
    "method",
    "fold",
    "n_estimators",
    "round",
    "choose_better",
    "optimize",
    "fit_kwargs",
    "groups",
    "probability_threshold",
    "verbose",
    "return_train_score"
  ],
  "blend_models": [
    "estimator_list",
    "fold",
    "round",
    "choose_better",
    "optimize",
    "method",
    "weights",
    "fit_kwargs",
    "groups",
    "probability_threshold",
    "verbose",
    "return_train_score"
  ],
  "stack_models": [
    "estimator_list",
    "meta_model",
    "meta_model_fold",
    "fold",
    "round",
    "method",
    "restack",
    "choose_better",
    "optimize",
    "fit_kwargs",
    "groups",
    "probability_threshold",
    "verbose",
    "return_train_score"
  ],
  "interpret_model": [
    "estimator",
    "plot",
    "feature",
    "observation",
    "use_train_data",
    "X_new_sample",
    "y_new_sample",
    "save"
  ],
  "calibrate_model": [
    "estimator",
    "method",
    "calibrate_fold",
    "fold",
    "round",
    "fit_kwargs",
    "groups",
    "verbose",
    "return_train_score"
  ],
  "optimize_threshold": [
    "estimator",
    "optimize",
    "return_data",
    "plot_kwargs",
    "verbose"
  ],
  "finalize_model": [
    "estimator",
    "fit_kwargs",
    "groups",
    "model_only",
    "experiment_custom_tags"
  ],
  "automl": [
    "optimize",
    "use_holdout",
    "turbo",
    "return_train_score"
  ],
  "get_leaderboard": [
    "finalize_models",
    "model_only",
    "fit_kwargs",
    "groups",
    "verbose"
  ],
  "dashboard": [
    "estimator",
    "display_format",
    "dashboard_kwargs",
    "run_kwargs"
  ],
  "convert_model": [
    "estimator",
    "language"
  ],
  "check_fairness": [
    "estimator",
    "sensitive_features",
    "plot_kwargs"
  ],
  "create_api": [
    "estimator",
    "api_name",
    "host",
    "port"
  ],
  "create_docker": [
    "api_name",
    "base_image",
    "expose_port"
  ],
  "create_app": [
    "estimator",
    "app_kwargs"
  ],
  "check_drift": [
    "reference_data",
    "current_data",
    "target",
    "numeric_features",
    "categorical_features",
    "date_features",
    "filename"
  ],
  "ClassificationExperiment": {
    "_create_app_predict_kwargs": [],
    "__init__": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "is_multiclass": [
      "self"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "setup": [
      "self",
      "data",
      "data_func",
      "target",
      "index",
      "train_size",
      "test_data",
      "ordinal_features",
      "numeric_features",
      "categorical_features",
      "date_features",
      "text_features",
      "ignore_features",
      "keep_features",
      "preprocess",
      "create_date_columns",
      "imputation_type",
      "numeric_imputation",
      "categorical_imputation",
      "iterative_imputation_iters",
      "numeric_iterative_imputer",
      "categorical_iterative_imputer",
      "text_features_method",
      "max_encoding_ohe",
      "encoding_method",
      "rare_to_value",
      "rare_value",
      "polynomial_features",
      "polynomial_degree",
      "low_variance_threshold",
      "group_features",
      "drop_groups",
      "remove_multicollinearity",
      "multicollinearity_threshold",
      "bin_numeric_features",
      "remove_outliers",
      "outliers_method",
      "outliers_threshold",
      "fix_imbalance",
      "fix_imbalance_method",
      "transformation",
      "transformation_method",
      "normalize",
      "normalize_method",
      "pca",
      "pca_method",
      "pca_components",
      "feature_selection",
      "feature_selection_method",
      "feature_selection_estimator",
      "n_features_to_select",
      "custom_pipeline",
      "custom_pipeline_position",
      "data_split_shuffle",
      "data_split_stratify",
      "fold_strategy",
      "fold",
      "fold_shuffle",
      "fold_groups",
      "n_jobs",
      "use_gpu",
      "html",
      "session_id",
      "system_log",
      "log_experiment",
      "experiment_name",
      "experiment_custom_tags",
      "log_plots",
      "log_profile",
      "log_data",
      "engine",
      "verbose",
      "memory",
      "profile",
      "profile_kwargs"
    ],
    "compare_models": [
      "self",
      "include",
      "exclude",
      "fold",
      "round",
      "cross_validation",
      "sort",
      "n_select",
      "budget_time",
      "turbo",
      "errors",
      "fit_kwargs",
      "groups",
      "experiment_custom_tags",
      "probability_threshold",
      "engine",
      "verbose",
      "parallel"
    ],
    "create_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "cross_validation",
      "fit_kwargs",
      "groups",
      "experiment_custom_tags",
      "probability_threshold",
      "engine",
      "verbose",
      "return_train_score"
    ],
    "tune_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "n_iter",
      "custom_grid",
      "optimize",
      "custom_scorer",
      "search_library",
      "search_algorithm",
      "early_stopping",
      "early_stopping_max_iters",
      "choose_better",
      "fit_kwargs",
      "groups",
      "return_tuner",
      "verbose",
      "tuner_verbose",
      "return_train_score"
    ],
    "ensemble_model": [
      "self",
      "estimator",
      "method",
      "fold",
      "n_estimators",
      "round",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "blend_models": [
      "self",
      "estimator_list",
      "fold",
      "round",
      "choose_better",
      "optimize",
      "method",
      "weights",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "stack_models": [
      "self",
      "estimator_list",
      "meta_model",
      "meta_model_fold",
      "fold",
      "round",
      "method",
      "restack",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "probability_threshold",
      "verbose",
      "return_train_score"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "verbose",
      "display_format"
    ],
    "evaluate_model": [
      "self",
      "estimator",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups"
    ],
    "interpret_model": [
      "self",
      "estimator",
      "plot",
      "feature",
      "observation",
      "use_train_data",
      "X_new_sample",
      "y_new_sample",
      "save"
    ],
    "calibrate_model": [
      "self",
      "estimator",
      "method",
      "calibrate_fold",
      "fold",
      "round",
      "fit_kwargs",
      "groups",
      "verbose",
      "return_train_score"
    ],
    "optimize_threshold": [
      "self",
      "estimator",
      "optimize",
      "return_data",
      "plot_kwargs",
      "verbose"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "probability_threshold",
      "encoded_labels",
      "raw_score",
      "round",
      "verbose"
    ],
    "finalize_model": [
      "self",
      "estimator",
      "fit_kwargs",
      "groups",
      "model_only",
      "experiment_custom_tags"
    ],
    "deploy_model": [
      "self",
      "model",
      "model_name",
      "authentication",
      "platform"
    ],
    "save_model": [
      "self",
      "model",
      "model_name",
      "model_only",
      "verbose"
    ],
    "load_model": [
      "self",
      "model_name",
      "platform",
      "authentication",
      "verbose"
    ],
    "automl": [
      "self",
      "optimize",
      "use_holdout",
      "turbo",
      "return_train_score"
    ],
    "models": [
      "self",
      "type",
      "internal",
      "raise_errors"
    ],
    "get_metrics": [
      "self",
      "reset",
      "include_custom",
      "raise_errors"
    ],
    "add_metric": [
      "self",
      "id",
      "name",
      "score_func",
      "target",
      "greater_is_better",
      "multiclass"
    ],
    "remove_metric": [
      "self",
      "name_or_id"
    ],
    "get_logs": [
      "self",
      "experiment_name",
      "save"
    ],
    "dashboard": [
      "self",
      "estimator",
      "display_format",
      "dashboard_kwargs",
      "run_kwargs"
    ]
  },
  "_LOCK": [],
  "_get_context_lock": [],
  "_DisplayUtil": {
    "__init__": [
      "self",
      "display",
      "progress",
      "verbose",
      "sort",
      "asc"
    ],
    "update": [
      "self",
      "df"
    ],
    "finish": [
      "self",
      "df"
    ],
    "_create_display": [
      "self",
      "progress",
      "verbose",
      "monitor_rows"
    ]
  },
  "FugueBackend": {
    "__init__": [
      "self",
      "engine",
      "conf",
      "batch_size",
      "display_remote",
      "top_only"
    ],
    "__getstate__": [
      "self"
    ],
    "compare_models": [
      "self",
      "instance",
      "params"
    ],
    "_remote_compare_models": [
      "self",
      "idx",
      "report"
    ]
  },
  "set_active_mlflow_run": [
    "run"
  ],
  "clean_active_mlflow_run": [],
  "MlflowLogger": {
    "__init__": [
      "self"
    ],
    "init_experiment": [
      "self",
      "exp_name_log",
      "full_name",
      "setup"
    ],
    "active_run": [
      "self"
    ],
    "parent_run": [
      "self"
    ],
    "run_id": [
      "self"
    ],
    "finish_experiment": [
      "self"
    ],
    "log_params": [
      "self",
      "params",
      "model_name"
    ],
    "log_metrics": [
      "self",
      "metrics",
      "source"
    ],
    "set_tags": [
      "self",
      "source",
      "experiment_custom_tags",
      "runtime",
      "USI"
    ],
    "log_artifact": [
      "self",
      "file",
      "type"
    ],
    "log_plot": [
      "self",
      "plot",
      "title"
    ],
    "log_hpram_grid": [
      "self",
      "html_file",
      "title"
    ],
    "log_sklearn_pipeline": [
      "self",
      "experiment",
      "prep_pipe",
      "model",
      "path"
    ]
  },
  "CometLogger": {
    "__init__": [
      "self"
    ],
    "init_experiment": [
      "self",
      "exp_name_log",
      "full_name",
      "setup"
    ],
    "log_params": [
      "self",
      "params",
      "model_name"
    ],
    "set_tags": [
      "self",
      "source",
      "experiment_custom_tags",
      "runtime",
      "USI"
    ],
    "log_sklearn_pipeline": [
      "self",
      "experiment",
      "prep_pipe",
      "model",
      "path"
    ],
    "log_model_comparison": [
      "self",
      "model_result",
      "source"
    ],
    "log_metrics": [
      "self",
      "metrics",
      "source"
    ],
    "log_plot": [
      "self",
      "plot",
      "title"
    ],
    "log_hpram_grid": [
      "self",
      "html_file",
      "title"
    ],
    "log_artifact": [
      "self",
      "file",
      "type"
    ],
    "finish_experiment": [
      "self"
    ]
  },
  "SETUP_TAG": [],
  "BaseLogger": {
    "init_logger": [
      "self"
    ],
    "__del__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "log_params": [
      "self",
      "params",
      "model_name"
    ],
    "init_experiment": [
      "self",
      "exp_name_log",
      "full_name",
      "setup"
    ],
    "set_tags": [
      "self",
      "source",
      "experiment_custom_tags",
      "runtime",
      "USI"
    ],
    "_construct_pipeline_if_needed": [
      "self",
      "model",
      "prep_pipe"
    ],
    "log_sklearn_pipeline": [
      "self",
      "experiment",
      "prep_pipe",
      "model",
      "path"
    ],
    "log_model_comparison": [
      "self",
      "model_result",
      "source"
    ],
    "log_metrics": [
      "self",
      "metrics",
      "source"
    ],
    "log_plot": [
      "self",
      "plot",
      "title"
    ],
    "log_hpram_grid": [
      "self",
      "html_file",
      "title"
    ],
    "log_artifact": [
      "self",
      "file",
      "type"
    ],
    "finish_experiment": [
      "self"
    ]
  },
  "WandbLogger": {
    "__init__": [
      "self"
    ],
    "init_experiment": [
      "self",
      "exp_name_log",
      "full_name",
      "setup"
    ],
    "log_params": [
      "self",
      "params",
      "model_name"
    ],
    "log_metrics": [
      "self",
      "metrics",
      "source"
    ],
    "log_artifact": [
      "self",
      "file",
      "type"
    ],
    "log_sklearn_pipeline": [
      "self",
      "experiment",
      "prep_pipe",
      "model",
      "path"
    ],
    "log_model_comparison": [
      "self",
      "model_result",
      "source"
    ],
    "log_plot": [
      "self",
      "plot",
      "title"
    ],
    "log_hpram_grid": [
      "self",
      "html_file",
      "title"
    ],
    "finish_experiment": [
      "self"
    ]
  },
  "DagshubLogger": {
    "__init__": [
      "self",
      "remote",
      "repo"
    ],
    "splitter": [
      "repo"
    ],
    "init_experiment": [
      "self"
    ],
    "_dvc_add": [
      "self",
      "local_path",
      "remote_path"
    ],
    "_dvc_commit": [
      "self",
      "commit"
    ],
    "log_artifact": [
      "self",
      "file",
      "type"
    ]
  },
  "DashboardLogger": {
    "__init__": [
      "self",
      "logger_list"
    ],
    "__repr__": [
      "self"
    ],
    "init_loggers": [
      "self",
      "exp_name_log",
      "full_name",
      "setup"
    ],
    "log_params": [
      "self",
      "params"
    ],
    "log_model": [
      "self",
      "experiment",
      "model",
      "model_results",
      "pipeline",
      "score_dict",
      "source",
      "runtime",
      "model_fit_time",
      "log_holdout",
      "log_plots",
      "experiment_custom_tags",
      "tune_cv_results",
      "URI",
      "display"
    ],
    "log_experiment": [
      "self",
      "experiment",
      "log_profile",
      "log_data",
      "experiment_custom_tags",
      "runtime"
    ],
    "log_model_comparison": [
      "self",
      "results",
      "source"
    ],
    "finish": [
      "self"
    ]
  },
  "check_stats": [
    "estimator",
    "test",
    "alpha",
    "split"
  ],
  "TSForecastingExperiment": {
    "__init__": [
      "self"
    ],
    "_get_setup_display": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "_check_fh": [
      "self",
      "fh"
    ],
    "_check_clean_and_set_data": [
      "self",
      "data"
    ],
    "_return_target_names": [
      "self",
      "target"
    ],
    "_check_and_set_targets": [
      "self",
      "target"
    ],
    "_check_and_clean_index": [
      "self",
      "index",
      "seasonal_period"
    ],
    "_check_and_set_fh": [
      "self",
      "fh"
    ],
    "_set_point_alpha_intervals_enforce_pi": [
      "self",
      "point_alpha",
      "coverage"
    ],
    "_check_and_set_seasonal_period": [
      "self"
    ],
    "_convert_sp_to_int": [
      "self",
      "seasonal_period"
    ],
    "_set_exogenous_names": [
      "self"
    ],
    "_check_and_set_forecasting_types": [
      "self"
    ],
    "_check_pipeline": [
      "self"
    ],
    "_check_transformations": [
      "self"
    ],
    "_setup_train_test_split": [
      "self"
    ],
    "_set_fold_generator": [
      "self"
    ],
    "_set_should_preprocess_data": [
      "self"
    ],
    "_set_missingness": [
      "self"
    ],
    "_initialize_pipeline": [
      "self"
    ],
    "_set_strictly_positive": [
      "self"
    ],
    "_set_seasonal_type": [
      "self",
      "seasonality_type"
    ],
    "_set_is_white_noise": [
      "self"
    ],
    "_set_lowercase_d": [
      "self"
    ],
    "_set_uppercase_d": [
      "self"
    ],
    "_perform_setup_eda": [
      "self"
    ],
    "_setup_display_container": [
      "self"
    ],
    "_disable_metrics": [
      "self"
    ],
    "_mlflow_log_setup": [
      "self",
      "experiment_name"
    ],
    "setup": [
      "self",
      "data",
      "data_func",
      "target",
      "index",
      "ignore_features",
      "numeric_imputation_target",
      "numeric_imputation_exogenous",
      "transform_target",
      "transform_exogenous",
      "scale_target",
      "scale_exogenous",
      "fe_target_rr",
      "fe_exogenous",
      "fold_strategy",
      "fold",
      "fh",
      "hyperparameter_split",
      "seasonal_period",
      "ignore_seasonality_test",
      "sp_detection",
      "max_sp_to_consider",
      "remove_harmonics",
      "harmonic_order_method",
      "num_sps_to_use",
      "seasonality_type",
      "point_alpha",
      "coverage",
      "enforce_exogenous",
      "n_jobs",
      "use_gpu",
      "custom_pipeline",
      "html",
      "session_id",
      "system_log",
      "log_experiment",
      "experiment_name",
      "experiment_custom_tags",
      "log_plots",
      "log_profile",
      "log_data",
      "engine",
      "verbose",
      "profile",
      "profile_kwargs",
      "fig_kwargs"
    ],
    "_set_default_fig_kwargs": [
      "self"
    ],
    "compare_models": [
      "self",
      "include",
      "exclude",
      "fold",
      "round",
      "cross_validation",
      "sort",
      "n_select",
      "budget_time",
      "turbo",
      "errors",
      "fit_kwargs",
      "experiment_custom_tags",
      "engine",
      "verbose",
      "parallel"
    ],
    "create_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "cross_validation",
      "fit_kwargs",
      "experiment_custom_tags",
      "engine",
      "verbose"
    ],
    "update_fit_kwargs_with_fh_from_cv": [
      "fit_kwargs",
      "cv"
    ],
    "_get_final_model_from_pipeline": [
      "self",
      "pipeline",
      "check_is_fitted"
    ],
    "_create_model_without_cv": [
      "self",
      "model",
      "data_X",
      "data_y",
      "fit_kwargs",
      "round",
      "predict",
      "system",
      "display",
      "model_only"
    ],
    "_create_model_with_cv": [
      "self",
      "model",
      "data_X",
      "data_y",
      "fit_kwargs",
      "round",
      "cv",
      "metrics",
      "refit",
      "display"
    ],
    "tune_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "n_iter",
      "custom_grid",
      "optimize",
      "custom_scorer",
      "search_algorithm",
      "choose_better",
      "fit_kwargs",
      "return_tuner",
      "verbose",
      "tuner_verbose"
    ],
    "blend_models": [
      "self",
      "estimator_list",
      "method",
      "fold",
      "round",
      "choose_better",
      "optimize",
      "weights",
      "fit_kwargs",
      "verbose"
    ],
    "_plot_model_get_model_labels": [
      "self",
      "estimators",
      "data_kwargs"
    ],
    "_plot_model_get_data_y": [
      "self",
      "data_types_to_plot"
    ],
    "_plot_model_get_data_X": [
      "self",
      "data_types_to_plot",
      "include",
      "exclude"
    ],
    "_plot_model_get_train_test_split_data": [
      "self",
      "data_types_to_plot"
    ],
    "plot_model_check_display_format_": [
      "display_format"
    ],
    "_plot_model": [
      "self",
      "estimator",
      "plot",
      "return_fig",
      "return_data",
      "verbose",
      "display_format",
      "data_kwargs",
      "fig_kwargs",
      "system",
      "save"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "return_fig",
      "return_data",
      "verbose",
      "display_format",
      "data_kwargs",
      "fig_kwargs",
      "save"
    ],
    "_predict_model_reconcile_pipe_estimator": [
      "self",
      "estimator"
    ],
    "_predict_model_reconcile_fh": [
      "self",
      "estimator",
      "fh"
    ],
    "_predict_model_reconcile_X": [
      "self",
      "estimator",
      "X"
    ],
    "_predict_model_resolve_verbose": [
      "self",
      "verbose",
      "y_pred"
    ],
    "_predict_model_resolve_display": [
      "self",
      "verbose",
      "y_pred"
    ],
    "_predict_model_get_test_metrics": [
      "self",
      "pipeline",
      "estimator",
      "result"
    ],
    "predict_model": [
      "self",
      "estimator",
      "fh",
      "X",
      "return_pred_int",
      "alpha",
      "coverage",
      "round",
      "verbose"
    ],
    "finalize_model": [
      "self",
      "estimator",
      "fit_kwargs",
      "model_only",
      "experiment_custom_tags"
    ],
    "deploy_model": [
      "self",
      "model",
      "model_name",
      "authentication",
      "platform"
    ],
    "save_model": [
      "self",
      "model",
      "model_name",
      "model_only",
      "verbose"
    ],
    "load_model": [
      "self",
      "model_name",
      "platform",
      "authentication",
      "verbose"
    ],
    "_create_pipeline": [
      "self",
      "model",
      "transformer_steps_target",
      "transformer_steps_exogenous"
    ],
    "models": [
      "self",
      "type",
      "internal",
      "raise_errors"
    ],
    "get_metrics": [
      "self",
      "reset",
      "include_custom",
      "raise_errors"
    ],
    "add_metric": [
      "self",
      "id",
      "name",
      "score_func",
      "greater_is_better"
    ],
    "remove_metric": [
      "self",
      "name_or_id"
    ],
    "get_logs": [
      "self",
      "experiment_name",
      "save"
    ],
    "get_fold_generator": [
      "self",
      "fold",
      "fold_strategy"
    ],
    "check_stats": [
      "self",
      "estimator",
      "test",
      "alpha",
      "split",
      "data_type",
      "data_kwargs"
    ],
    "_get_y_data": [
      "self",
      "split",
      "data_type"
    ],
    "_get_X_data": [
      "self",
      "split",
      "data_type",
      "include",
      "exclude"
    ],
    "_get_cleaned_estimator_y_X": [
      "self",
      "estimator"
    ],
    "_is_estimator_finalized": [
      "self",
      "estimator"
    ],
    "_get_y_X_used_for_training": [
      "self",
      "estimator"
    ],
    "get_residuals": [
      "self",
      "estimator"
    ],
    "get_insample_predictions": [
      "self",
      "estimator"
    ],
    "_check_and_clean_resid": [
      "self",
      "resid"
    ],
    "get_additional_scorer_kwargs": [
      "self"
    ],
    "_get_pipeline_to_use": [
      "self",
      "estimator"
    ]
  },
  "_validate_split_requested": [
    "split"
  ],
  "_validate_data_type": [
    "data_type"
  ],
  "RegressionExperiment": {
    "__init__": [
      "self"
    ],
    "_get_models": [
      "self",
      "raise_errors"
    ],
    "_get_metrics": [
      "self",
      "raise_errors"
    ],
    "_get_default_plots_to_log": [
      "self"
    ],
    "setup": [
      "self",
      "data",
      "data_func",
      "target",
      "index",
      "train_size",
      "test_data",
      "ordinal_features",
      "numeric_features",
      "categorical_features",
      "date_features",
      "text_features",
      "ignore_features",
      "keep_features",
      "preprocess",
      "create_date_columns",
      "imputation_type",
      "numeric_imputation",
      "categorical_imputation",
      "iterative_imputation_iters",
      "numeric_iterative_imputer",
      "categorical_iterative_imputer",
      "text_features_method",
      "max_encoding_ohe",
      "encoding_method",
      "rare_to_value",
      "rare_value",
      "polynomial_features",
      "polynomial_degree",
      "low_variance_threshold",
      "group_features",
      "drop_groups",
      "remove_multicollinearity",
      "multicollinearity_threshold",
      "bin_numeric_features",
      "remove_outliers",
      "outliers_method",
      "outliers_threshold",
      "transformation",
      "transformation_method",
      "normalize",
      "normalize_method",
      "pca",
      "pca_method",
      "pca_components",
      "feature_selection",
      "feature_selection_method",
      "feature_selection_estimator",
      "n_features_to_select",
      "transform_target",
      "transform_target_method",
      "custom_pipeline",
      "custom_pipeline_position",
      "data_split_shuffle",
      "data_split_stratify",
      "fold_strategy",
      "fold",
      "fold_shuffle",
      "fold_groups",
      "n_jobs",
      "use_gpu",
      "html",
      "session_id",
      "system_log",
      "log_experiment",
      "experiment_name",
      "experiment_custom_tags",
      "log_plots",
      "log_profile",
      "log_data",
      "engine",
      "verbose",
      "memory",
      "profile",
      "profile_kwargs"
    ],
    "compare_models": [
      "self",
      "include",
      "exclude",
      "fold",
      "round",
      "cross_validation",
      "sort",
      "n_select",
      "budget_time",
      "turbo",
      "errors",
      "fit_kwargs",
      "groups",
      "experiment_custom_tags",
      "engine",
      "verbose",
      "parallel"
    ],
    "create_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "cross_validation",
      "fit_kwargs",
      "groups",
      "experiment_custom_tags",
      "engine",
      "verbose",
      "return_train_score"
    ],
    "tune_model": [
      "self",
      "estimator",
      "fold",
      "round",
      "n_iter",
      "custom_grid",
      "optimize",
      "custom_scorer",
      "search_library",
      "search_algorithm",
      "early_stopping",
      "early_stopping_max_iters",
      "choose_better",
      "fit_kwargs",
      "groups",
      "return_tuner",
      "verbose",
      "tuner_verbose",
      "return_train_score"
    ],
    "ensemble_model": [
      "self",
      "estimator",
      "method",
      "fold",
      "n_estimators",
      "round",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "verbose",
      "return_train_score"
    ],
    "blend_models": [
      "self",
      "estimator_list",
      "fold",
      "round",
      "choose_better",
      "optimize",
      "weights",
      "fit_kwargs",
      "groups",
      "verbose",
      "return_train_score"
    ],
    "stack_models": [
      "self",
      "estimator_list",
      "meta_model",
      "meta_model_fold",
      "fold",
      "round",
      "restack",
      "choose_better",
      "optimize",
      "fit_kwargs",
      "groups",
      "verbose",
      "return_train_score"
    ],
    "plot_model": [
      "self",
      "estimator",
      "plot",
      "scale",
      "save",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups",
      "verbose",
      "display_format"
    ],
    "evaluate_model": [
      "self",
      "estimator",
      "fold",
      "fit_kwargs",
      "plot_kwargs",
      "groups"
    ],
    "interpret_model": [
      "self",
      "estimator",
      "plot",
      "feature",
      "observation",
      "use_train_data",
      "X_new_sample",
      "y_new_sample",
      "save"
    ],
    "predict_model": [
      "self",
      "estimator",
      "data",
      "round",
      "verbose"
    ],
    "finalize_model": [
      "self",
      "estimator",
      "fit_kwargs",
      "groups",
      "model_only",
      "experiment_custom_tags"
    ],
    "deploy_model": [
      "self",
      "model",
      "model_name",
      "authentication",
      "platform"
    ],
    "save_model": [
      "self",
      "model",
      "model_name",
      "model_only",
      "verbose"
    ],
    "load_model": [
      "self",
      "model_name",
      "platform",
      "authentication",
      "verbose"
    ],
    "automl": [
      "self",
      "optimize",
      "use_holdout",
      "turbo",
      "return_train_score"
    ],
    "models": [
      "self",
      "type",
      "internal",
      "raise_errors"
    ],
    "get_metrics": [
      "self",
      "reset",
      "include_custom",
      "raise_errors"
    ],
    "add_metric": [
      "self",
      "id",
      "name",
      "score_func",
      "greater_is_better"
    ],
    "remove_metric": [
      "self",
      "name_or_id"
    ],
    "get_logs": [
      "self",
      "experiment_name",
      "save"
    ],
    "dashboard": [
      "self",
      "estimator",
      "display_format",
      "dashboard_kwargs",
      "run_kwargs"
    ]
  }
}