{
  "__version__": [],
  "download_data": [
    "path",
    "source"
  ],
  "load_data": [
    "path",
    "filename"
  ],
  "normalize_Y": [
    "Y",
    "indexD"
  ],
  "hidden_space": [],
  "compute_runtime_feval": [
    "trajectory",
    "target"
  ],
  "compute_ecdf": [
    "error",
    "targets"
  ],
  "compute_ranks": [
    "errors",
    "n_bootstrap"
  ],
  "meta_fcnet": [
    "fname_objective",
    "fname_cost",
    "noise"
  ],
  "get_default_architecture": [
    "input_dimensionality",
    "classification",
    "n_hidden"
  ],
  "meta_svm": [
    "fname_objective",
    "fname_cost",
    "noise"
  ],
  "meta_xgboost": [
    "fname_objective",
    "fname_cost",
    "noise"
  ],
  "get_architecture_forrester": [
    "input_dimensionality"
  ],
  "meta_forrester": [
    "fname_objective"
  ],
  "objective_function": [
    "config",
    "model_objective",
    "model_cost",
    "task_feature_objective",
    "task_feature_cost",
    "x_mean_objective",
    "x_std_objective",
    "x_mean_cost",
    "x_std_cost",
    "y_mean_objective",
    "y_std_objective",
    "y_mean_cost",
    "y_std_cost",
    "log_objective",
    "with_noise"
  ],
  "get_default_network": [
    "input_dimensionality"
  ],
  "Bohamiann": {
    "__init__": [
      "self",
      "X_init",
      "Y_init",
      "num_steps",
      "num_burnin",
      "lr",
      "get_architecture"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "get_f_minimum": [
      "self"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "RandomForest": {
    "__init__": [
      "self",
      "X_init",
      "Y_init",
      "num_trees",
      "do_bootstrapping",
      "seed"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "get_f_minimum": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "N_STEPS_MAX": [],
  "display_frames_as_gif": [
    "frames",
    "title"
  ],
  "simulation": [
    "state"
  ],
  "low_cost_simulation": [
    "state"
  ],
  "plot_emu_sim_comparison": [
    "env",
    "control_params",
    "emulator",
    "fidelity"
  ],
  "run_simulation": [
    "env",
    "controller_gains",
    "render"
  ],
  "run_emulation": [
    "dynamics_models",
    "controller_gains",
    "X_0",
    "fidelity"
  ],
  "calculate_linear_control": [
    "state",
    "gains"
  ],
  "add_data_to_gp": [
    "gp_model",
    "new_x",
    "new_y"
  ],
  "make_gp_inputs": [
    "control_inputs",
    "state_trajectory"
  ],
  "v_simulation": [
    "state"
  ],
  "plot_control": {
    "__init__": [
      "self",
      "velocity_emulator",
      "fidelity"
    ],
    "plot_slices": [
      "self",
      "control"
    ]
  },
  "evaluate_model": [
    "model",
    "x",
    "fidelity"
  ],
  "DynamicNegativeLowerConfidenceBound": {
    "__init__": [
      "self",
      "model",
      "input_space_size",
      "delta"
    ],
    "optimal_beta_selection": [
      "self"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "SIR": {
    "__init__": [
      "self",
      "N",
      "alpha"
    ],
    "set_alpha": [
      "self",
      "alpha"
    ]
  },
  "SEIR": {
    "__init__": [
      "self",
      "N",
      "alpha",
      "beta"
    ]
  },
  "SEIRGillespie": {
    "__init__": [
      "self",
      "model"
    ],
    "_get_initial_state": [
      "self"
    ],
    "_get_state_index_infected": [
      "self"
    ],
    "_get_possible_state_updates": [
      "self"
    ],
    "_get_current_rates": [
      "self",
      "state"
    ]
  },
  "AlphaPrior": {
    "__init__": [
      "self",
      "name"
    ],
    "evaluate": [
      "self",
      "alpha"
    ]
  },
  "GammaPrior": {
    "__init__": [
      "self",
      "a",
      "loc",
      "scale"
    ],
    "evaluate": [
      "self",
      "alpha"
    ]
  },
  "UniformPrior": {
    "__init__": [
      "self",
      "alpha_min",
      "alpha_max"
    ],
    "evaluate": [
      "self",
      "alpha"
    ]
  },
  "MeanMaxInfectionGillespie": {
    "__init__": [
      "self",
      "gillespie_model",
      "num_gil",
      "time_end",
      "alpha_prior"
    ],
    "evaluate_bare": [
      "self",
      "alpha"
    ],
    "evaluate": [
      "self",
      "alpha"
    ],
    "evaluate_time_bare": [
      "self",
      "alpha"
    ],
    "evaluate_height_bare": [
      "self",
      "alpha"
    ],
    "evaluate_time": [
      "self",
      "alpha"
    ],
    "evaluate_height": [
      "self",
      "alpha"
    ]
  },
  "_f_height_of_peak_weighted": [
    "alpha",
    "meanmax"
  ],
  "_f_time_of_peak_weighted": [
    "alpha",
    "meanmax"
  ],
  "_f_height_of_peak": [
    "alpha",
    "meanmax"
  ],
  "_f_time_of_peak": [
    "alpha",
    "meanmax"
  ],
  "height_of_peak_weighted": [
    "meanmax"
  ],
  "time_of_peak_weighted": [
    "meanmax"
  ],
  "height_of_peak": [
    "meanmax"
  ],
  "time_of_peak": [
    "meanmax"
  ],
  "SIRGillespie": {
    "__init__": [
      "self",
      "model"
    ],
    "_get_initial_state": [
      "self"
    ],
    "_get_state_index_infected": [
      "self"
    ],
    "_get_possible_state_updates": [
      "self"
    ],
    "_get_current_rates": [
      "self",
      "state"
    ]
  },
  "GillespieBase": {
    "__init__": [
      "self",
      "model"
    ],
    "_get_initial_state": [
      "self"
    ],
    "_get_state_index_infected": [
      "self"
    ],
    "_get_possible_state_updates": [
      "self"
    ],
    "_get_current_rates": [
      "self",
      "state"
    ],
    "_draw_next_event": [
      "self",
      "state"
    ],
    "_draw_gillespie": [
      "self",
      "time_end"
    ],
    "_draw_gillespie_fixed_time": [
      "self",
      "times_fixed"
    ],
    "_map_gillespie_times_to_fixed_times": [
      "self",
      "gillespie_path",
      "times_fixed"
    ],
    "run_simulation_fixed_time": [
      "self",
      "num_gil",
      "t_eval"
    ],
    "_compute_height_and_time_of_peak": [
      "self",
      "gillespie_path"
    ],
    "run_simulation_height_and_time_of_peak": [
      "self",
      "num_gil",
      "time_end"
    ]
  },
  "inference": [],
  "acquisition": [],
  "objective": [],
  "noise_level": [],
  "kernel": [],
  "options_acquisition": [],
  "optimizer_options": [],
  "config": [],
  "bo": [],
  "random_sample": [
    "bounds",
    "k"
  ],
  "static_sample": [
    "bounds"
  ],
  "grid_sample": [
    "n"
  ],
  "give_comparisons": [
    "func",
    "points",
    "si"
  ],
  "boundit": [
    "x",
    "bounds"
  ],
  "running_mean": [
    "x",
    "N"
  ],
  "max_difference": [
    "xs"
  ],
  "adam": [
    "objective",
    "x0",
    "args",
    "max_it",
    "alpha",
    "beta1",
    "beta2",
    "eps",
    "tol",
    "lag",
    "bounds",
    "Nw",
    "get_logger"
  ],
  "configure_logger": [
    "log_file"
  ],
  "comparison_form": [
    "y"
  ],
  "ComparisonGP": {
    "get_current_best": [
      "self"
    ],
    "get_y_pred": [
      "self"
    ],
    "log_likelihood": [
      "self"
    ],
    "predict": [
      "self",
      "Xnew",
      "full_cov",
      "include_likelihood"
    ],
    "predict_noiseless": [
      "self",
      "Xnew",
      "full_cov"
    ],
    "posterior_samples_f": [
      "self",
      "X",
      "size"
    ]
  },
  "EPComparisonGP": {
    "__init__": [
      "self",
      "X",
      "y",
      "yc",
      "kernel",
      "likelihood",
      "name",
      "ep_max_itt",
      "delta",
      "eta",
      "get_logger"
    ],
    "parameters_changed": [
      "self"
    ],
    "set_XY": [
      "self",
      "X",
      "y",
      "yc"
    ]
  },
  "VIComparisonGP": {
    "__init__": [
      "self",
      "X",
      "y",
      "yc",
      "kernel",
      "likelihood",
      "vi_mode",
      "name",
      "max_iters",
      "get_logger"
    ],
    "parameters_changed": [
      "self"
    ],
    "set_XY": [
      "self",
      "X",
      "y",
      "yc"
    ]
  },
  "VIComparisonGPMF": {
    "__init__": [
      "self",
      "X",
      "y",
      "yc",
      "kernel",
      "likelihood",
      "name",
      "max_iters",
      "get_logger"
    ]
  },
  "VIComparisonGPFR": {
    "__init__": [
      "self",
      "X",
      "y",
      "yc",
      "kernel",
      "likelihood",
      "name",
      "max_iters",
      "get_logger"
    ]
  },
  "MCMCComparisonGP": {
    "__init__": [
      "self",
      "X",
      "y",
      "yc",
      "kernel",
      "likelihood",
      "posterior_samples",
      "get_logger"
    ],
    "_fit_stan": [
      "self"
    ],
    "parameters_changed": [
      "self"
    ],
    "set_XY": [
      "self",
      "X",
      "y",
      "yc"
    ]
  },
  "ComparisonGPEmukitWrapper": {
    "__init__": [
      "self",
      "gpy_model",
      "batch_size"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_with_full_covariance": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "predict_covariance": [
      "self",
      "X",
      "with_noise"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "optimize": [
      "self"
    ]
  },
  "create_bayesian_optimization_loop": [
    "gpy_model",
    "lims",
    "batch_size",
    "acquisition"
  ],
  "BayesianOptimization": {
    "__init__": [
      "self",
      "options"
    ],
    "get_logger": [
      "self"
    ],
    "bayesian_optimization": [
      "self",
      "objective"
    ]
  },
  "remove_level_uncertainty": [
    "samples",
    "mean_same"
  ],
  "StanPosterior": {
    "__init__": [
      "self",
      "samples",
      "X",
      "kern",
      "noise",
      "remove_levels",
      "y",
      "yc",
      "get_logger",
      "Y"
    ],
    "_get_mu_L": [
      "self",
      "x_pred",
      "N",
      "woodbury_inv",
      "with_index"
    ],
    "_raw_predict_raw": [
      "self",
      "x_pred",
      "include_likelihood",
      "samples"
    ]
  },
  "phi": [],
  "sigmoid": [],
  "dlogphi_df": [],
  "dlogsigmoid_df": [],
  "d2logsigmoid_df": [],
  "dL_fr": [
    "L",
    "dsigma",
    "alpha",
    "beta",
    "K"
  ],
  "dL_mf": [
    "L",
    "dsigma",
    "alpha",
    "beta",
    "K"
  ],
  "dSigma_dLmn": [
    "L",
    "m",
    "n"
  ],
  "comp_y_ij": [
    "mu",
    "Sigma",
    "i",
    "j",
    "epsilon"
  ],
  "variational_expectations_ove_full_rank": [
    "mf",
    "Sigma",
    "ind_winners",
    "ind_loosers",
    "sigma2s"
  ],
  "df_d": [
    "y",
    "yc",
    "m",
    "L",
    "L_inv",
    "K",
    "sigma2s",
    "alpha",
    "beta",
    "s_to_l"
  ],
  "recompute_posterior_fr": [
    "alpha",
    "beta",
    "K"
  ],
  "recompute_posterior_mf": [
    "alpha",
    "beta",
    "K"
  ],
  "log_lik": [
    "x",
    "arg_list"
  ],
  "vi_comparison": [
    "X",
    "y",
    "yc",
    "kern",
    "sigma2s",
    "alpha",
    "beta",
    "max_iters",
    "lr",
    "method",
    "optimize",
    "get_logger"
  ],
  "npdf": [],
  "log_npdf": [],
  "logphi": [],
  "log_2_pi": [],
  "posdef_sqrtm": [
    "M"
  ],
  "sqrtm_block": [
    "M",
    "y",
    "yc"
  ],
  "MarginalMoments": {
    "__init__": [
      "self",
      "num_data"
    ]
  },
  "GaussianApproximation": {
    "__init__": [
      "self",
      "v",
      "tau"
    ],
    "_update_batch": [
      "self",
      "eta",
      "delta",
      "post_params",
      "marg_moments",
      "batch",
      "get_logger",
      "sigma2s"
    ]
  },
  "CavityParams": {
    "__init__": [
      "self",
      "num_data"
    ],
    "_update_i": [
      "self",
      "eta",
      "ga_approx",
      "post_params",
      "i"
    ],
    "_update_batch": [
      "self",
      "eta",
      "ga_approx",
      "post_params",
      "batch",
      "get_logger"
    ]
  },
  "update_posterior": [
    "K",
    "v",
    "tau",
    "y",
    "yc",
    "jitter",
    "get_logger"
  ],
  "ep_comparison": [
    "X",
    "y",
    "yc",
    "kern",
    "sigma2s",
    "max_itt",
    "delta",
    "eta",
    "tol",
    "ga_approx_old",
    "get_logger"
  ],
  "_match_moments_batch": [
    "v_cav",
    "tau_cav",
    "ind_winners",
    "ind_loosers",
    "nu2",
    "N",
    "get_logger"
  ],
  "_log_Z_tilde": [
    "marg_moments",
    "ga_approx",
    "cav_params",
    "y",
    "yc"
  ],
  "_ep_marginal": [
    "K",
    "ga_approx",
    "Z_tilde",
    "y",
    "yc"
  ],
  "_inference": [
    "K",
    "ga_approx",
    "cav_params",
    "Z_tilde",
    "y",
    "yc"
  ],
  "_compute_moments_sampling": [
    "mf",
    "vf",
    "ind_winners",
    "ind_loosers",
    "nu2",
    "N",
    "get_logger"
  ],
  "dK_dX": [
    "self",
    "X",
    "X2",
    "dimX"
  ],
  "ExpectationAcquisition": {
    "dgp_ds_via_L": [
      "self",
      "s",
      "dl"
    ],
    "dgp_dL_via_Sigma": [
      "self",
      "L",
      "L_inv",
      "dsigma"
    ],
    "dgp_dSigma": [
      "self",
      "x",
      "X",
      "kern",
      "w_inv"
    ],
    "dgp_dmean": [
      "self",
      "kern",
      "w_vec",
      "x",
      "X"
    ],
    "dgp_dx": [
      "self",
      "s",
      "L",
      "L_inv",
      "w_vec",
      "w_inv",
      "kern",
      "x",
      "X"
    ],
    "acquisition_fun": [
      "self",
      "x",
      "m"
    ],
    "acquisition_fun_flat": [
      "self",
      "X",
      "m"
    ],
    "acq_fun_optimizer": [
      "self",
      "m",
      "bounds",
      "batch_size",
      "get_logger"
    ],
    "evaluate": [
      "self",
      "x",
      "model"
    ],
    "evaluate_with_gradients": [
      "self",
      "x",
      "model"
    ]
  },
  "SumOfVariances": {
    "opt_val": [
      "self",
      "f",
      "y",
      "m",
      "sqrt_nu"
    ],
    "opt_val_grad": [
      "self",
      "s",
      "f",
      "y",
      "m",
      "sqrt_nu",
      "L",
      "L_inv",
      "w_vec",
      "w_inv",
      "x"
    ],
    "opt_val_s": [
      "self",
      "f",
      "y",
      "m",
      "sqrt_nu"
    ],
    "opt_val_s_grad": [
      "self",
      "s",
      "f",
      "y",
      "m",
      "sqrt_nu",
      "L",
      "L_inv",
      "w_vec",
      "w_inv",
      "x"
    ],
    "dopt_val_s_df": [
      "self",
      "f",
      "y",
      "m",
      "sqrt_nu"
    ]
  },
  "QExpectedImprovement": {
    "opt_val": [
      "self",
      "f",
      "y",
      "m",
      "sqrt_nu"
    ],
    "opt_val_grad": [
      "self",
      "s",
      "f",
      "y",
      "m",
      "sqrt_nu",
      "L",
      "L_inv",
      "w_vec",
      "w_inv",
      "x"
    ],
    "dopt_val_df": [
      "self",
      "f",
      "y",
      "m",
      "sqrt_nu"
    ]
  },
  "SequentialThompsonSampler": {
    "__init__": [
      "self",
      "model",
      "seed",
      "delta",
      "num_points"
    ],
    "reset": [
      "self",
      "seed"
    ],
    "add_data": [
      "self",
      "x",
      "f"
    ],
    "get_mu_sigma": [
      "self",
      "x"
    ],
    "get_posterior_predictive_distribution": [
      "self",
      "x",
      "inds"
    ],
    "get_posterior_predictive_distribution_robust": [
      "self",
      "x",
      "num_points"
    ],
    "evaluate_and_add": [
      "self",
      "X"
    ]
  },
  "ThompsonSampling": {
    "acq_fun_optimizer": [
      "self",
      "m",
      "bounds",
      "batch_size",
      "get_logger"
    ],
    "reset": [
      "self",
      "model"
    ],
    "evaluate": [
      "self",
      "x",
      "model"
    ],
    "evaluate_with_gradients": [
      "self",
      "x",
      "model"
    ]
  },
  "AcquisitionFunction": {
    "__init__": [
      "self",
      "options",
      "optimizer_options"
    ],
    "acq_fun_optimizer": [
      "self",
      "m",
      "bounds",
      "batch_size",
      "get_logger"
    ],
    "reset": [
      "self",
      "model"
    ]
  },
  "EmukitAcquisitionFunctionWrapper": {
    "__init__": [
      "self",
      "model",
      "acquisitionFunction"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "reset": [
      "self",
      "model"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "SequentialGradientAcquisitionOptimizer": {
    "__init__": [
      "self",
      "space",
      "batch_size"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ],
    "optimize": [
      "self",
      "acquisition",
      "context"
    ]
  },
  "create_vanilla_bq_loop_with_rbf_kernel": [
    "X",
    "Y",
    "integral_bounds",
    "measure",
    "rbf_lengthscale",
    "rbf_variance"
  ],
  "OptimizerType": {
    "LBFGS": []
  },
  "UnknownConstraintGPBayesianOptimization": {
    "__init__": [
      "self",
      "variables_list",
      "X",
      "Y",
      "Yc",
      "noiseless",
      "acquisition_type",
      "normalize_Y",
      "acquisition_optimizer_type",
      "batch_size",
      "model_update_interval"
    ],
    "_model_chooser": [
      "self"
    ],
    "_model_chooser_constraint": [
      "self"
    ],
    "_acquisition_chooser": [
      "self"
    ],
    "suggest_new_locations": [
      "self"
    ]
  },
  "GPBayesianOptimization": {
    "__init__": [
      "self",
      "variables_list",
      "X",
      "Y",
      "noiseless",
      "acquisition_type",
      "normalize_Y",
      "acquisition_optimizer_type",
      "model_update_interval",
      "batch_size"
    ],
    "_model_chooser": [
      "self"
    ],
    "_acquisition_chooser": [
      "self"
    ],
    "suggest_new_locations": [
      "self"
    ],
    "run_optimization": [
      "self",
      "user_function",
      "num_iterations"
    ]
  },
  "AcquisitionType": {
    "EI": [],
    "PI": [],
    "NLCB": []
  },
  "ModelType": {
    "RandomForest": [],
    "BayesianNeuralNetwork": []
  },
  "svm": [],
  "l": [],
  "space": [],
  "s_min": [],
  "s_max": [],
  "wrapper": [
    "x",
    "s"
  ],
  "res": [],
  "ContinuousFidelityEntropySearch": {
    "__init__": [
      "self",
      "model",
      "space",
      "target_fidelity_index",
      "num_samples",
      "num_representer_points",
      "burn_in_steps"
    ],
    "_sample_representer_points": [
      "self"
    ],
    "_get_proposal_function": [
      "self",
      "model",
      "space"
    ]
  },
  "FabolasLoop": {
    "__init__": [
      "self",
      "space",
      "X_init",
      "Y_init",
      "cost_init",
      "s_min",
      "s_max",
      "update_interval",
      "num_eval_points",
      "marginalize_hypers"
    ]
  },
  "FabolasKernel": {
    "__init__": [
      "self",
      "input_dim",
      "basis_func",
      "a",
      "b",
      "active_dims"
    ],
    "K": [
      "self",
      "X",
      "X2"
    ],
    "update_gradients_full": [
      "self",
      "dL_dK",
      "X",
      "X2"
    ],
    "Kdiag": [
      "self",
      "X"
    ]
  },
  "linear": [
    "s"
  ],
  "quad": [
    "s"
  ],
  "transform": [
    "s",
    "s_min",
    "s_max"
  ],
  "retransform": [
    "s_transform",
    "s_min",
    "s_max"
  ],
  "FabolasModel": {
    "__init__": [
      "self",
      "X_init",
      "Y_init",
      "s_min",
      "s_max",
      "basis_func",
      "noise"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "get_f_minimum": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ],
    "predict_covariance": [
      "self",
      "X",
      "with_noise"
    ],
    "get_covariance_between_points": [
      "self",
      "X1",
      "X2"
    ]
  },
  "fmin_fabolas": [
    "func",
    "space",
    "s_min",
    "s_max",
    "n_iters",
    "n_init",
    "marginalize_hypers"
  ],
  "_log": [],
  "HighFidelityGp": {
    "__init__": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "LinearAutoRegressiveModel": {
    "__init__": [
      "self",
      "X",
      "Y",
      "n_restarts"
    ],
    "predict": [
      "self",
      "X"
    ],
    "optimize": [
      "self"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "NonLinearAutoRegressiveModel": {
    "__init__": [
      "self",
      "X",
      "Y",
      "n_restarts"
    ],
    "predict": [
      "self",
      "X"
    ],
    "optimize": [
      "self"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "float_type": [],
  "init_layers_mf": [
    "Y",
    "Z",
    "kernels",
    "num_outputs",
    "Layer"
  ],
  "DGP_Base": {
    "__init__": [
      "self",
      "X",
      "Y",
      "likelihood",
      "layers",
      "minibatch_size",
      "num_samples"
    ],
    "propagate": [
      "self",
      "X",
      "full_cov",
      "S",
      "zs"
    ],
    "_build_predict": [
      "self",
      "X",
      "full_cov",
      "S",
      "fidelity"
    ],
    "_likelihood_at_fidelity": [
      "self",
      "Fmu",
      "Fvar",
      "Y",
      "variance"
    ],
    "E_log_p_Y": [
      "self",
      "X_f",
      "Y_f",
      "fidelity"
    ],
    "_build_likelihood": [
      "self"
    ],
    "predict_f": [
      "self",
      "Xnew",
      "num_samples",
      "fidelity"
    ],
    "predict_f_full_cov": [
      "self",
      "Xnew",
      "num_samples",
      "fidelity"
    ],
    "predict_all_layers": [
      "self",
      "Xnew",
      "num_samples"
    ],
    "predict_all_layers_full_cov": [
      "self",
      "Xnew",
      "num_samples"
    ],
    "predict_y": [
      "self",
      "Xnew",
      "num_samples"
    ],
    "predict_density": [
      "self",
      "Xnew",
      "Ynew",
      "num_samples"
    ],
    "make_mf_dgp": [
      "cls",
      "X",
      "Y",
      "Z",
      "add_linear",
      "minibatch_size"
    ],
    "multi_step_training": [
      "self",
      "n_iter",
      "n_iter_2"
    ],
    "fix_inducing_point_locations": [
      "self"
    ],
    "run_adam": [
      "self",
      "lr",
      "iterations"
    ]
  },
  "PrintAction": {
    "__init__": [
      "self",
      "model",
      "text"
    ],
    "run": [
      "self",
      "ctx"
    ]
  },
  "MultiFidelityDeepGP": {
    "__init__": [
      "self",
      "X",
      "Y",
      "Z",
      "n_iter",
      "fix_inducing",
      "multi_step_training",
      "minibatch_size"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "_get_model": [
      "self",
      "X",
      "Y",
      "Z"
    ],
    "predict": [
      "self",
      "X"
    ],
    "optimize": [
      "self"
    ],
    "_make_inducing_points": [
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "GPyModelWrapper": {
    "__init__": [
      "self",
      "gpy_model",
      "n_restarts"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_noiseless": [
      "self",
      "X"
    ],
    "predict_with_full_covariance": [
      "self",
      "X"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ],
    "get_joint_prediction_gradients": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self",
      "verbose"
    ],
    "calculate_variance_reduction": [
      "self",
      "x_train_new",
      "x_test"
    ],
    "predict_covariance": [
      "self",
      "X",
      "with_noise"
    ],
    "get_covariance_between_points": [
      "self",
      "X1",
      "X2"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "generate_hyperparameters_samples": [
      "self",
      "n_samples",
      "n_burnin",
      "subsample_interval",
      "step_size",
      "leapfrog_steps"
    ],
    "fix_model_hyperparameters": [
      "self",
      "sample_hyperparameters"
    ]
  },
  "dSigma": [
    "x_predict",
    "x_train",
    "kern",
    "w_inv"
  ],
  "dmean": [
    "x_predict",
    "x_train",
    "kern",
    "w_vec"
  ],
  "GPyMultiOutputWrapper": {
    "__init__": [
      "self",
      "gpy_model",
      "n_outputs",
      "n_optimization_restarts",
      "verbose_optimization"
    ],
    "calculate_variance_reduction": [
      "self",
      "x_train_new",
      "x_test"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "predict_covariance": [
      "self",
      "X",
      "with_noise"
    ],
    "get_covariance_between_points": [
      "self",
      "X1",
      "X2"
    ],
    "generate_hyperparameters_samples": [
      "self",
      "n_samples",
      "n_burnin",
      "subsample_interval",
      "step_size",
      "leapfrog_steps"
    ],
    "fix_model_hyperparameters": [
      "self",
      "sample_hyperparameters"
    ]
  },
  "BaseGaussianProcessGPy": {
    "__init__": [
      "self",
      "kern",
      "gpy_model",
      "noise_free"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "observation_noise_variance": [
      "self"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X_pred"
    ],
    "predict_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "solve_linear": [
      "self",
      "z"
    ],
    "graminv_residual": [
      "self"
    ],
    "optimize": [
      "self"
    ]
  },
  "RBFGPy": {
    "__init__": [
      "self",
      "gpy_rbf"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ]
  },
  "ProductMatern12GPy": {
    "__init__": [
      "self",
      "gpy_matern",
      "lengthscales",
      "variance"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "_K_from_prod": [
      "self",
      "x1",
      "x2",
      "skip"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ]
  },
  "ProductMatern32GPy": {
    "__init__": [
      "self",
      "gpy_matern",
      "lengthscales",
      "variance"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "_K_from_prod": [
      "self",
      "x1",
      "x2",
      "skip"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ]
  },
  "ProductMatern52GPy": {
    "__init__": [
      "self",
      "gpy_matern",
      "lengthscales",
      "variance"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "_K_from_prod": [
      "self",
      "x1",
      "x2",
      "skip"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ]
  },
  "BrownianGPy": {
    "__init__": [
      "self",
      "gpy_brownian"
    ],
    "variance": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ]
  },
  "ProductBrownianGPy": {
    "__init__": [
      "self",
      "gpy_brownian",
      "offset",
      "variance",
      "input_dim"
    ],
    "variance": [
      "self"
    ],
    "offset": [
      "self"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "_K_from_prod": [
      "self",
      "x1",
      "x2",
      "skip"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "create_emukit_model_from_gpy_model": [
    "gpy_model",
    "integral_bounds",
    "measure",
    "integral_name"
  ],
  "SimpleGaussianProcessModel": {
    "__init__": [
      "self",
      "x",
      "y"
    ],
    "__repr__": [
      "self"
    ],
    "optimize": [
      "self"
    ],
    "predict": [
      "self",
      "x_new"
    ],
    "_calc_kernel": [
      "self",
      "X",
      "X2"
    ],
    "_negative_marginal_log_likelihood": [
      "self"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "SklearnGPRWrapper": {
    "__init__": [
      "self",
      "sklearn_model"
    ],
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "__all__": [],
  "BoundsType": [],
  "IBaseGaussianProcess": {
    "__init__": [
      "self",
      "kern"
    ],
    "observation_noise_variance": [
      "self"
    ],
    "predict_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "solve_linear": [
      "self",
      "z"
    ],
    "graminv_residual": [
      "self"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "IStandardKernel": {
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IRBF": {
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IProductMatern12": {
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "_dK_dx1_1d": [
      "self",
      "x1",
      "x2",
      "lengthscale"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IProductMatern32": {
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "_dK_dx1_1d": [
      "self",
      "x1",
      "x2",
      "lengthscale"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IProductMatern52": {
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "_dK_dx1_1d": [
      "self",
      "x1",
      "x2",
      "lengthscale"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IBrownian": {
    "variance": [
      "self"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ]
  },
  "IProductBrownian": {
    "variance": [
      "self"
    ],
    "offset": [
      "self"
    ],
    "_dK_dx1_1d": [
      "self",
      "x1",
      "x2"
    ]
  },
  "BoxDomain": {
    "__init__": [
      "self",
      "bounds",
      "name"
    ],
    "bounds": [
      "self",
      "new_bounds"
    ],
    "_check_bound_validity": [
      "self",
      "bounds"
    ],
    "convert_to_list_of_continuous_parameters": [
      "self"
    ]
  },
  "GaussianMeasure": {
    "__init__": [
      "self",
      "mean",
      "variance"
    ],
    "input_dim": [
      "self"
    ],
    "full_covariance_matrix": [
      "self"
    ],
    "can_sample": [
      "self"
    ],
    "compute_density": [
      "self",
      "x"
    ],
    "compute_density_gradient": [
      "self",
      "x"
    ],
    "reasonable_box": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "context_manager"
    ]
  },
  "IntegrationMeasure": {
    "__init__": [
      "self",
      "domain",
      "name"
    ],
    "input_dim": [
      "self"
    ],
    "can_sample": [
      "self"
    ],
    "compute_density": [
      "self",
      "x"
    ],
    "compute_density_gradient": [
      "self",
      "x"
    ],
    "reasonable_box": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "context_manager"
    ]
  },
  "LebesgueMeasure": {
    "__init__": [
      "self",
      "domain",
      "normalized"
    ],
    "input_dim": [
      "self"
    ],
    "can_sample": [
      "self"
    ],
    "compute_density": [
      "self",
      "x"
    ],
    "compute_density_gradient": [
      "self",
      "x"
    ],
    "reasonable_box": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "context_manager"
    ],
    "from_bounds": [
      "cls",
      "bounds",
      "normalized"
    ]
  },
  "NumericalPrecisionError": {},
  "VanillaBayesianQuadrature": {
    "__init__": [
      "self",
      "base_gp",
      "X",
      "Y"
    ],
    "predict_base": [
      "self",
      "X_pred"
    ],
    "predict_base_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "integrate": [
      "self"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "WSABIL": {
    "__init__": [
      "self",
      "base_gp",
      "X",
      "Y",
      "adapt_alpha"
    ],
    "_compute_alpha": [
      "self",
      "X",
      "Y"
    ],
    "compute_warping_params": [
      "self",
      "X",
      "Y"
    ]
  },
  "Warping": {
    "transform": [
      "self",
      "Y"
    ],
    "inverse_transform": [
      "self",
      "Y"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "IdentityWarping": {
    "transform": [
      "self",
      "Y"
    ],
    "inverse_transform": [
      "self",
      "Y"
    ]
  },
  "SquareRootWarping": {
    "__init__": [
      "self",
      "offset",
      "is_inverted"
    ],
    "transform": [
      "self",
      "Y"
    ],
    "inverse_transform": [
      "self",
      "Y"
    ]
  },
  "WarpedBayesianQuadratureModel": {
    "__init__": [
      "self",
      "base_gp",
      "warping",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "integral_bounds": [
      "self"
    ],
    "reasonable_box_bounds": [
      "self"
    ],
    "measure": [
      "self"
    ],
    "transform": [
      "self",
      "Y"
    ],
    "inverse_transform": [
      "self",
      "Y"
    ],
    "predict_base": [
      "self",
      "X_pred"
    ],
    "predict_base_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "predict_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "predict": [
      "self",
      "X_pred"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "compute_warping_params": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "integrate": [
      "self"
    ],
    "symmetrize_matrix": [
      "A"
    ]
  },
  "BoundedBayesianQuadrature": {
    "__init__": [
      "self",
      "base_gp",
      "X",
      "Y",
      "lower_bound",
      "upper_bound"
    ],
    "bound": [
      "self"
    ],
    "is_lower_bounded": [
      "self"
    ],
    "predict_base": [
      "self",
      "X_pred"
    ],
    "predict_base_with_full_covariance": [
      "self",
      "X_pred"
    ],
    "integrate": [
      "self"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "VanillaBayesianQuadratureLoop": {
    "__init__": [
      "self",
      "model",
      "acquisition",
      "model_updater",
      "acquisition_optimizer"
    ]
  },
  "BayesianMonteCarlo": {
    "__init__": [
      "self",
      "model",
      "model_updater"
    ]
  },
  "WSABILLoop": {
    "__init__": [
      "self",
      "model",
      "model_updater",
      "acquisition_optimizer"
    ]
  },
  "BayesianMonteCarloPointCalculator": {
    "__init__": [
      "self",
      "model",
      "parameter_space"
    ],
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "MutualInformation": {
    "__init__": [
      "self",
      "model"
    ],
    "has_gradients": [
      "self"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ]
  },
  "UncertaintySampling": {
    "__init__": [
      "self",
      "model",
      "measure_power"
    ],
    "has_gradients": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ]
  },
  "SquaredCorrelation": {
    "__init__": [
      "self",
      "model"
    ],
    "has_gradients": [
      "self"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "_evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "_value_terms": [
      "self",
      "x"
    ],
    "_gradient_terms": [
      "self",
      "x"
    ]
  },
  "QuadratureKernel": {
    "__init__": [
      "self",
      "kern",
      "measure",
      "variable_names"
    ],
    "K": [
      "self",
      "x1",
      "x2"
    ],
    "qK": [
      "self",
      "x2"
    ],
    "Kq": [
      "self",
      "x1"
    ],
    "qKq": [
      "self"
    ],
    "dK_dx1": [
      "self",
      "x1",
      "x2"
    ],
    "dK_dx2": [
      "self",
      "x1",
      "x2"
    ],
    "dKdiag_dx": [
      "self",
      "x"
    ],
    "dqK_dx": [
      "self",
      "x2"
    ],
    "dKq_dx": [
      "self",
      "x1"
    ]
  },
  "QuadratureProductKernel": {
    "__init__": [
      "self",
      "kern",
      "measure",
      "variable_names"
    ],
    "_qK_unscaled": [
      "self",
      "x2",
      "skip"
    ],
    "qK": [
      "self",
      "x2",
      "skip"
    ],
    "qKq": [
      "self"
    ],
    "dqK_dx": [
      "self",
      "x2"
    ],
    "_scale": [
      "self",
      "z"
    ],
    "_get_univariate_parameters": [
      "self",
      "dim"
    ],
    "_qK_1d": [
      "self",
      "x"
    ],
    "_qKq_1d": [
      "self"
    ],
    "_dqK_dx_1d": [
      "self",
      "x"
    ]
  },
  "LebesgueEmbedding": {
    "from_integral_bounds": [
      "cls",
      "kern",
      "integral_bounds",
      "normalized",
      "variable_names"
    ]
  },
  "GaussianEmbedding": {
    "from_measure_params": [
      "cls",
      "kern",
      "mean",
      "variance",
      "variable_names"
    ]
  },
  "QuadratureBrownian": {
    "__init__": [
      "self",
      "brownian_kernel",
      "measure",
      "variable_names"
    ],
    "variance": [
      "self"
    ]
  },
  "QuadratureBrownianLebesgueMeasure": {
    "__init__": [
      "self",
      "brownian_kernel",
      "measure",
      "variable_names"
    ],
    "qK": [
      "self",
      "x2"
    ],
    "qKq": [
      "self"
    ],
    "dqK_dx": [
      "self",
      "x2"
    ]
  },
  "QuadratureProductBrownian": {
    "__init__": [
      "self",
      "brownian_kernel",
      "measure",
      "variable_names"
    ],
    "variance": [
      "self"
    ],
    "offset": [
      "self"
    ]
  },
  "QuadratureProductBrownianLebesgueMeasure": {
    "__init__": [
      "self",
      "brownian_kernel",
      "measure",
      "variable_names"
    ],
    "_scale": [
      "self",
      "z"
    ],
    "_get_univariate_parameters": [
      "self",
      "dim"
    ],
    "_qK_1d": [
      "self",
      "x"
    ],
    "_qKq_1d": [
      "self"
    ],
    "_dqK_dx_1d": [
      "self",
      "x"
    ]
  },
  "QuadratureProductMatern52": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "QuadratureProductMatern52LebesgueMeasure": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "_scale": [
      "self",
      "z"
    ],
    "_get_univariate_parameters": [
      "self",
      "dim"
    ],
    "_qK_1d": [
      "self",
      "x"
    ],
    "_qKq_1d": [
      "self"
    ],
    "_dqK_dx_1d": [
      "self",
      "x"
    ]
  },
  "QuadratureRBF": {
    "__init__": [
      "self",
      "rbf_kernel",
      "measure",
      "variable_names"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "_scaled_vector_diff": [
      "self",
      "v1",
      "v2",
      "scales"
    ]
  },
  "QuadratureRBFLebesgueMeasure": {
    "__init__": [
      "self",
      "rbf_kernel",
      "measure",
      "variable_names"
    ],
    "qK": [
      "self",
      "x2"
    ],
    "qKq": [
      "self"
    ],
    "dqK_dx": [
      "self",
      "x2"
    ]
  },
  "QuadratureRBFGaussianMeasure": {
    "__init__": [
      "self",
      "rbf_kernel",
      "measure",
      "variable_names"
    ],
    "qK": [
      "self",
      "x2",
      "scale_factor"
    ],
    "qKq": [
      "self"
    ],
    "dqK_dx": [
      "self",
      "x2"
    ]
  },
  "QuadratureProductMatern12": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "QuadratureProductMatern12LebesgueMeasure": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "_scale": [
      "self",
      "z"
    ],
    "_get_univariate_parameters": [
      "self",
      "dim"
    ],
    "_qK_1d": [
      "self",
      "x"
    ],
    "_qKq_1d": [
      "self"
    ],
    "_dqK_dx_1d": [
      "self",
      "x"
    ]
  },
  "QuadratureProductMatern32": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "nu": [
      "self"
    ],
    "lengthscales": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "QuadratureProductMatern32LebesgueMeasure": {
    "__init__": [
      "self",
      "matern_kernel",
      "measure",
      "variable_names"
    ],
    "_scale": [
      "self",
      "z"
    ],
    "_get_univariate_parameters": [
      "self",
      "dim"
    ],
    "_qK_1d": [
      "self",
      "x"
    ],
    "_qKq_1d": [
      "self"
    ],
    "_dqK_dx_1d": [
      "self",
      "x"
    ]
  },
  "convert_x_list_to_array": [
    "x_list"
  ],
  "convert_y_list_to_array": [
    "y_list"
  ],
  "convert_xy_lists_to_arrays": [
    "x_list",
    "y_list"
  ],
  "GPyLinearMultiFidelityModel": {
    "__init__": [
      "self",
      "X",
      "Y",
      "kernel",
      "n_fidelities",
      "likelihood"
    ]
  },
  "make_non_linear_kernels": [
    "base_kernel_class",
    "n_fidelities",
    "n_input_dims",
    "ARD"
  ],
  "NonLinearMultiFidelityModel": {
    "__init__": [
      "self",
      "X_init",
      "Y_init",
      "n_fidelities",
      "kernels",
      "n_samples",
      "verbose",
      "optimization_restarts"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "n_samples": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_prediction_gradients": [
      "self",
      "X"
    ],
    "_predict_samples": [
      "self",
      "X",
      "fidelity"
    ],
    "_predict_samples_with_gradients": [
      "self",
      "X",
      "fidelity"
    ],
    "_propagate_samples_through_level": [
      "self",
      "X",
      "i_level",
      "sample_mean",
      "sample_variance"
    ],
    "_propagate_samples_through_level_gradient": [
      "self",
      "dsample_mean_dx",
      "dsample_var_dx",
      "i_fidelity",
      "sample_variance",
      "x_augmented"
    ],
    "optimize": [
      "self"
    ],
    "get_f_minimum": [
      "self"
    ],
    "_predict_deterministic": [
      "self",
      "X",
      "fidelity"
    ]
  },
  "LinearMultiFidelityKernel": {
    "__init__": [
      "self",
      "kernels"
    ],
    "K": [
      "self",
      "X",
      "X2"
    ],
    "Kdiag": [
      "self",
      "X"
    ],
    "gradients_X": [
      "self",
      "dL_dK",
      "X",
      "X2"
    ],
    "_calculate_block_matrix_gradients": [
      "self",
      "dL_dK",
      "X",
      "X2",
      "i",
      "j"
    ],
    "gradients_X_diag": [
      "self",
      "dL_dKdiag",
      "X"
    ],
    "update_gradients_diag": [
      "self",
      "dL_dKdiag",
      "X"
    ],
    "_update_sub_kernel_gradients_diag": [
      "self",
      "X",
      "dL_dKdiag"
    ],
    "_update_scaling_parameter_gradients_diag": [
      "self",
      "X",
      "dL_dKdiag"
    ],
    "update_gradients_full": [
      "self",
      "dL_dK",
      "X",
      "X2"
    ],
    "_update_sub_kernel_gradients_full": [
      "self",
      "X",
      "X2",
      "dL_dK"
    ],
    "_update_scaling_parameter_gradients_full": [
      "self",
      "X",
      "X2",
      "dL_dK"
    ],
    "_calculate_d_likelihood_d_scaling_param": [
      "self",
      "dL_dK",
      "X",
      "X2",
      "i_scaling",
      "k_all_fidelities"
    ]
  },
  "McmcSampler": {
    "__init__": [
      "self",
      "space"
    ],
    "get_samples": [
      "self",
      "n_samples",
      "log_p_function",
      "burn_in_steps"
    ]
  },
  "AffineInvariantEnsembleSampler": {
    "__init__": [
      "self",
      "space"
    ],
    "get_samples": [
      "self",
      "n_samples",
      "log_p_function",
      "burn_in_steps",
      "n_steps"
    ]
  },
  "Metric": {
    "evaluate": [
      "self",
      "loop",
      "loop_state"
    ],
    "reset": [
      "self"
    ]
  },
  "MeanSquaredErrorMetric": {
    "__init__": [
      "self",
      "x_test",
      "y_test",
      "name"
    ],
    "evaluate": [
      "self",
      "loop",
      "loop_state"
    ]
  },
  "MinimumObservedValueMetric": {
    "__init__": [
      "self",
      "name"
    ],
    "evaluate": [
      "self",
      "loop",
      "loop_state"
    ]
  },
  "TimeMetric": {
    "__init__": [
      "self",
      "name"
    ],
    "evaluate": [
      "self",
      "loop",
      "loop_state"
    ],
    "reset": [
      "self"
    ]
  },
  "CumulativeCostMetric": {
    "__init__": [
      "self",
      "name"
    ],
    "evaluate": [
      "self",
      "loop",
      "loop_state"
    ],
    "reset": [
      "self"
    ]
  },
  "Benchmarker": {
    "__init__": [
      "self",
      "loops_with_names",
      "test_function",
      "parameter_space",
      "metrics",
      "initial_design"
    ],
    "run_benchmark": [
      "self",
      "n_initial_data",
      "n_iterations",
      "n_repeats"
    ],
    "_subscribe_metrics_to_loop_events": [
      "self",
      "outer_loop"
    ],
    "_create_initial_loop_state": [
      "self",
      "n_initial_data"
    ]
  },
  "_add_value_to_metrics_dict": [
    "loop_state",
    "value",
    "key_name"
  ],
  "RandomSearch": {
    "__init__": [
      "self",
      "space",
      "x_init",
      "y_init",
      "cost_init"
    ]
  },
  "BenchmarkPlot": {
    "__init__": [
      "self",
      "benchmark_results",
      "loop_colours",
      "loop_line_styles",
      "x_axis_metric_name",
      "metrics_to_plot"
    ],
    "make_plot": [
      "self",
      "log_y"
    ],
    "save_plot": [
      "self",
      "file_name"
    ]
  },
  "_get_metric_stats": [
    "metric"
  ],
  "_get_default_colours": [],
  "BenchmarkResult": {
    "__init__": [
      "self",
      "loop_names",
      "n_repeats",
      "metric_names"
    ],
    "add_results": [
      "self",
      "loop_name",
      "i_repeat",
      "metric_name",
      "metric_values"
    ],
    "extract_metric_as_array": [
      "self",
      "loop_name",
      "metric_name"
    ]
  },
  "branin_function": [],
  "_branin": [
    "x"
  ],
  "multi_fidelity_forrester_function": [
    "high_fidelity_noise_std_deviation",
    "low_fidelity_noise_std_deviation"
  ],
  "forrester_function": [
    "noise_standard_deviation"
  ],
  "forrester": [
    "x",
    "sd"
  ],
  "forrester_low": [
    "x",
    "sd"
  ],
  "sixhumpcamel_function": [],
  "_sixhumpcamel": [
    "x"
  ],
  "multi_fidelity_non_linear_sin": [
    "high_fidelity_noise_std_deviation",
    "low_fidelity_noise_std_deviation"
  ],
  "nonlinear_sin_low": [
    "x",
    "sd"
  ],
  "nonlinear_sin_high": [
    "x",
    "sd"
  ],
  "hennig1D": [],
  "_hennig1D": [
    "x"
  ],
  "circular_gaussian": [
    "mean",
    "variance"
  ],
  "_circular_gaussian": [
    "x",
    "mean",
    "variance"
  ],
  "univariate_approximate_ground_truth_integral": [
    "func",
    "integral_bounds"
  ],
  "bivariate_approximate_ground_truth_integral": [
    "func",
    "integral_bounds"
  ],
  "hennig2D": [],
  "_hennig2D": [
    "x",
    "S"
  ],
  "sombrero2D": [
    "freq"
  ],
  "_sombrero2D": [
    "x",
    "freq"
  ],
  "multi_fidelity_branin_function": [],
  "multi_fidelity_hartmann_3d": [],
  "multi_fidelity_borehole_function": [
    "high_noise_std_deviation",
    "low_noise_std_deviation"
  ],
  "_borehole_high": [
    "x",
    "sd"
  ],
  "_borehole_low": [
    "x",
    "sd"
  ],
  "multi_fidelity_park_function": [],
  "multi_fidelity_currin_function": [],
  "Ishigami": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "fidelity1": [
      "self",
      "x"
    ],
    "fidelity2": [
      "self",
      "x"
    ],
    "fidelity3": [
      "self",
      "x"
    ],
    "fidelity4": [
      "self",
      "x"
    ],
    "f0": [
      "self"
    ],
    "f1": [
      "self",
      "x1"
    ],
    "f2": [
      "self",
      "x2"
    ],
    "f3": [
      "self",
      "x3"
    ],
    "f12": [
      "self",
      "x12"
    ],
    "f13": [
      "self",
      "x13"
    ],
    "f23": [
      "self",
      "x23"
    ],
    "f123": [
      "self",
      "x123"
    ]
  },
  "ExperimentalDesignLoop": {
    "__init__": [
      "self",
      "space",
      "model",
      "acquisition",
      "update_interval",
      "batch_size",
      "acquisition_optimizer"
    ]
  },
  "ICalculateVarianceReduction": {
    "calculate_variance_reduction": [
      "self",
      "x_train_new",
      "x_test"
    ]
  },
  "ModelVariance": {
    "__init__": [
      "self",
      "model"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "IntegratedVarianceReduction": {
    "__init__": [
      "self",
      "model",
      "space",
      "x_monte_carlo",
      "num_monte_carlo_points"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "EventHandler": {
    "__call__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Parameter": {
    "__init__": [
      "self",
      "name"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "dimension": [
      "self"
    ],
    "model_parameters": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "check_in_domain": [
      "self",
      "x"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "Encoding": {
    "__init__": [
      "self",
      "categories",
      "encodings"
    ],
    "dimension": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "round_row": [
      "self",
      "x_row"
    ],
    "get_category": [
      "self",
      "encoding"
    ],
    "get_encoding": [
      "self",
      "category"
    ]
  },
  "OneHotEncoding": {
    "__init__": [
      "self",
      "categories"
    ],
    "round_row": [
      "self",
      "x_row"
    ]
  },
  "OrdinalEncoding": {
    "__init__": [
      "self",
      "categories"
    ],
    "round_row": [
      "self",
      "x_row"
    ]
  },
  "ParameterSpace": {
    "__init__": [
      "self",
      "parameters",
      "constraints"
    ],
    "find_parameter_index_in_model": [
      "self",
      "parameter_name"
    ],
    "dimensionality": [
      "self"
    ],
    "parameters": [
      "self"
    ],
    "parameter_names": [
      "self"
    ],
    "get_parameter_by_name": [
      "self",
      "name"
    ],
    "get_bounds": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "check_points_in_domain": [
      "self",
      "x"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "CategoricalParameter": {
    "__init__": [
      "self",
      "name",
      "encoding"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "encodings": [
      "self"
    ],
    "model_parameters": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "bounds": [
      "self"
    ],
    "dimension": [
      "self"
    ],
    "check_in_domain": [
      "self",
      "x"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "BanditParameter": {
    "__init__": [
      "self",
      "name",
      "domain",
      "sub_parameter_names"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_create_parameter_names": [
      "self",
      "domain"
    ],
    "_create_parameters": [
      "self",
      "domain",
      "parameter_names"
    ],
    "model_parameters": [
      "self"
    ],
    "check_in_domain": [
      "self",
      "x"
    ],
    "bounds": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "dimension": [
      "self"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "DiscreteParameter": {
    "__init__": [
      "self",
      "name",
      "domain"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "check_in_domain": [
      "self",
      "x"
    ],
    "bounds": [
      "self"
    ],
    "round": [
      "self",
      "x"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "InformationSourceParameter": {
    "__init__": [
      "self",
      "n_sources"
    ]
  },
  "ContinuousParameter": {
    "__init__": [
      "self",
      "name",
      "min_value",
      "max_value"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "check_in_domain": [
      "self",
      "x"
    ],
    "bounds": [
      "self"
    ],
    "sample_uniform": [
      "self",
      "point_count"
    ]
  },
  "IConstraint": {
    "evaluate": [
      "self",
      "x"
    ]
  },
  "InequalityConstraint": {
    "__init__": [
      "self",
      "lower_bound",
      "upper_bound"
    ]
  },
  "LinearInequalityConstraint": {
    "__init__": [
      "self",
      "constraint_matrix",
      "lower_bound",
      "upper_bound"
    ],
    "evaluate": [
      "self",
      "x"
    ]
  },
  "NonlinearInequalityConstraint": {
    "__init__": [
      "self",
      "constraint_function",
      "lower_bound",
      "upper_bound",
      "jacobian_fun"
    ],
    "evaluate": [
      "self",
      "x"
    ]
  },
  "Optimizer": {
    "__init__": [
      "self",
      "bounds"
    ],
    "optimize": [
      "self",
      "x0",
      "f",
      "df",
      "f_df"
    ]
  },
  "OptLbfgs": {
    "__init__": [
      "self",
      "bounds",
      "max_iterations"
    ],
    "optimize": [
      "self",
      "x0",
      "f",
      "df",
      "f_df"
    ]
  },
  "apply_optimizer": [
    "optimizer",
    "x0",
    "space",
    "f",
    "df",
    "f_df",
    "context_manager"
  ],
  "OptimizationWithContext": {
    "__init__": [
      "self",
      "x0",
      "f",
      "df",
      "f_df",
      "context_manager"
    ],
    "f_no_context": [
      "self",
      "x"
    ],
    "df_no_context": [
      "self",
      "x"
    ],
    "f_df_no_context": [
      "self",
      "x"
    ]
  },
  "OptTrustRegionConstrained": {
    "__init__": [
      "self",
      "bounds",
      "constraints",
      "max_iterations"
    ],
    "optimize": [
      "self",
      "x0",
      "f",
      "df",
      "f_df"
    ]
  },
  "_get_scipy_constraints": [
    "constraint_list"
  ],
  "LocalSearchAcquisitionOptimizer": {
    "__init__": [
      "self",
      "space",
      "num_steps",
      "num_init_points",
      "std_dev",
      "num_continuous"
    ],
    "_neighbours_per_parameter": [
      "self",
      "all_features",
      "parameters"
    ],
    "_neighbours": [
      "self",
      "all_features",
      "parameters"
    ],
    "_one_local_search": [
      "self",
      "acquisition",
      "x",
      "context_manager"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ]
  },
  "MultiSourceAcquisitionOptimizer": {
    "__init__": [
      "self",
      "acquisition_optimizer",
      "space"
    ],
    "_get_information_source_parameter": [
      "self"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ],
    "optimize": [
      "self",
      "acquisition",
      "context"
    ]
  },
  "GradientAcquisitionOptimizer": {
    "__init__": [
      "self",
      "space",
      "num_samples",
      "num_anchor"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ],
    "_get_optimizer": [
      "self",
      "context_manager"
    ]
  },
  "AnchorPointsGenerator": {
    "__init__": [
      "self",
      "space",
      "num_samples"
    ],
    "get_anchor_point_scores": [
      "self",
      "X"
    ],
    "get": [
      "self",
      "num_anchor",
      "context_manager"
    ]
  },
  "ObjectiveAnchorPointsGenerator": {
    "__init__": [
      "self",
      "space",
      "acquisition",
      "num_samples"
    ],
    "get_anchor_point_scores": [
      "self",
      "X"
    ]
  },
  "Context": [],
  "ContextManager": {
    "__init__": [
      "self",
      "space",
      "context"
    ],
    "expand_vector": [
      "self",
      "x"
    ]
  },
  "RandomSearchAcquisitionOptimizer": {
    "__init__": [
      "self",
      "space",
      "num_eval_points"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ]
  },
  "AcquisitionOptimizerBase": {
    "__init__": [
      "self",
      "space"
    ],
    "_optimize": [
      "self",
      "acquisition",
      "context_manager"
    ],
    "optimize": [
      "self",
      "acquisition",
      "context"
    ]
  },
  "IModel": {
    "predict": [
      "self",
      "X"
    ],
    "set_data": [
      "self",
      "X",
      "Y"
    ],
    "optimize": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ]
  },
  "IDifferentiable": {
    "get_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "IJointlyDifferentiable": {
    "predict_with_full_covariance": [
      "self",
      "X"
    ],
    "get_joint_prediction_gradients": [
      "self",
      "X"
    ]
  },
  "IPriorHyperparameters": {
    "generate_hyperparameters_samples": [
      "self",
      "n_samples",
      "n_burnin",
      "subsample_interval",
      "step_size",
      "leapfrog_steps"
    ],
    "fix_model_hyperparameters": [
      "self",
      "sample_hyperparameters"
    ]
  },
  "IModelWithNoise": {
    "predict_noiseless": [
      "self",
      "X"
    ]
  },
  "RandomDesign": {
    "__init__": [
      "self",
      "parameter_space"
    ],
    "get_samples": [
      "self",
      "point_count"
    ]
  },
  "SobolDesign": {
    "__init__": [
      "self",
      "parameter_space"
    ],
    "get_samples": [
      "self",
      "point_count"
    ]
  },
  "LatinDesign": {
    "__init__": [
      "self",
      "parameter_space"
    ],
    "get_samples": [
      "self",
      "point_count"
    ]
  },
  "InitialDesignBase": {
    "__init__": [
      "self",
      "parameter_space"
    ],
    "get_samples": [
      "self",
      "point_count"
    ]
  },
  "StoppingCondition": {
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "should_stop": [
      "self",
      "loop_state"
    ]
  },
  "And": {
    "__init__": [
      "self",
      "left",
      "right"
    ],
    "should_stop": [
      "self",
      "loop_state"
    ]
  },
  "Or": {
    "__init__": [
      "self",
      "left",
      "right"
    ],
    "should_stop": [
      "self",
      "loop_state"
    ]
  },
  "FixedIterationsStoppingCondition": {
    "__init__": [
      "self",
      "i_max"
    ],
    "should_stop": [
      "self",
      "loop_state"
    ]
  },
  "ConvergenceStoppingCondition": {
    "__init__": [
      "self",
      "eps"
    ],
    "should_stop": [
      "self",
      "loop_state"
    ]
  },
  "UserFunctionResult": {
    "__init__": [
      "self",
      "X",
      "Y"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__getattr__": [
      "self",
      "item"
    ],
    "__repr__": [
      "self"
    ]
  },
  "OuterLoop": {
    "__init__": [
      "self",
      "candidate_point_calculator",
      "model_updaters",
      "loop_state"
    ],
    "run_loop": [
      "self",
      "user_function",
      "stopping_condition",
      "context"
    ],
    "_update_models": [
      "self"
    ],
    "get_next_points": [
      "self",
      "results",
      "context"
    ]
  },
  "UserFunction": {
    "evaluate": [
      "self",
      "X"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "UserFunctionWrapper": {
    "__init__": [
      "self",
      "f",
      "extra_output_names"
    ],
    "evaluate": [
      "self",
      "inputs"
    ]
  },
  "MultiSourceFunctionWrapper": {
    "__init__": [
      "self",
      "f",
      "source_index",
      "extra_output_names"
    ],
    "evaluate": [
      "self",
      "inputs"
    ]
  },
  "CandidatePointCalculator": {
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "SequentialPointCalculator": {
    "__init__": [
      "self",
      "acquisition",
      "acquisition_optimizer"
    ],
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "GreedyBatchPointCalculator": {
    "__init__": [
      "self",
      "model",
      "acquisition",
      "acquisition_optimizer",
      "batch_size"
    ],
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "RandomSampling": {
    "__init__": [
      "self",
      "parameter_space"
    ],
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "ModelUpdater": {
    "update": [
      "self",
      "loop_state"
    ]
  },
  "NoopModelUpdater": {
    "update": [
      "self",
      "loop_state"
    ]
  },
  "FixedIntervalUpdater": {
    "__init__": [
      "self",
      "model",
      "interval",
      "targets_extractor_fcn"
    ],
    "update": [
      "self",
      "loop_state"
    ]
  },
  "LoopState": {
    "__init__": [
      "self",
      "initial_results"
    ],
    "update": [
      "self",
      "results"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "__getattr__": [
      "self",
      "item"
    ]
  },
  "create_loop_state": [
    "x_init",
    "y_init"
  ],
  "IntegratedHyperParameterAcquisition": {
    "__init__": [
      "self",
      "model",
      "acquisition_generator",
      "n_samples",
      "n_burnin",
      "subsample_interval",
      "step_size",
      "leapfrog_steps"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "update_parameters": [
      "self"
    ],
    "has_gradients": [
      "self"
    ],
    "update_batches": [
      "self",
      "x_batch",
      "lipschitz_constant",
      "f_min"
    ]
  },
  "Acquisition": {
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__truediv__": [
      "self",
      "denominator"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "Quotient": {
    "__init__": [
      "self",
      "numerator",
      "denominator"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "Product": {
    "__init__": [
      "self",
      "acquisition_1",
      "acquisition_2"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "Sum": {
    "__init__": [
      "self",
      "acquisition_1",
      "acquisition_2"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "update_parameters": [
      "self"
    ]
  },
  "acquisition_per_expected_cost": [
    "acquisition",
    "cost_model",
    "min_cost"
  ],
  "CostAcquisition": {
    "__init__": [
      "self",
      "cost_model",
      "min_cost"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ]
  },
  "ModelFreeMonteCarloSensitivity": {
    "__init__": [
      "self",
      "objective",
      "input_domain"
    ],
    "_generate_samples": [
      "self",
      "num_monte_carlo_points"
    ],
    "saltelli_estimators": [
      "self",
      "f_main_sample",
      "f_fixing_sample",
      "f_new_fixing_sample",
      "num_monte_carlo_points",
      "total_mean",
      "total_variance"
    ],
    "compute_statistics": [
      "self",
      "sample"
    ],
    "compute_effects": [
      "self",
      "main_sample",
      "fixing_sample",
      "num_monte_carlo_points"
    ]
  },
  "MonteCarloSensitivity": {
    "__init__": [
      "self",
      "model",
      "input_domain"
    ]
  },
  "N_SAMPLES": [],
  "MAX_ITER": [],
  "LocalPenalizationPointCalculator": {
    "__init__": [
      "self",
      "acquisition",
      "acquisition_optimizer",
      "model",
      "parameter_space",
      "batch_size",
      "fixed_lipschitz_constant",
      "fixed_minimum"
    ],
    "compute_next_points": [
      "self",
      "loop_state",
      "context"
    ]
  },
  "_estimate_lipschitz_constant": [
    "space",
    "model"
  ],
  "sq2": [],
  "eps": [],
  "l2p": [],
  "joint_min": [
    "mu",
    "var",
    "with_derivatives"
  ],
  "min_factor": [
    "Mu",
    "Sigma",
    "k",
    "gamma"
  ],
  "lt_factor": [
    "s",
    "l",
    "M",
    "V",
    "mp",
    "p",
    "gamma"
  ],
  "log_relative_gauss": [
    "z"
  ],
  "IEntropySearchModel": {
    "predict_covariance": [
      "self",
      "X",
      "with_noise"
    ],
    "get_covariance_between_points": [
      "self",
      "X1",
      "X2"
    ]
  },
  "BayesianOptimizationLoop": {
    "__init__": [
      "self",
      "space",
      "model",
      "acquisition",
      "update_interval",
      "batch_size",
      "acquisition_optimizer"
    ],
    "get_results": [
      "self"
    ]
  },
  "BayesianOptimizationResults": {
    "__init__": [
      "self",
      "loop_state"
    ]
  },
  "CostSensitiveBayesianOptimizationLoop": {
    "__init__": [
      "self",
      "space",
      "model_objective",
      "model_cost",
      "acquisition",
      "update_interval",
      "acquisition_optimizer"
    ]
  },
  "UnknownConstraintBayesianOptimizationLoop": {
    "__init__": [
      "self",
      "space",
      "model_objective",
      "model_constraint",
      "acquisition",
      "update_interval",
      "batch_size"
    ]
  },
  "ExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "jitter"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ],
    "_get_model_predictions": [
      "self",
      "x"
    ],
    "_get_y_minimum": [
      "self"
    ]
  },
  "MeanPluginExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "jitter"
    ],
    "_get_y_minimum": [
      "self"
    ],
    "_get_model_predictions": [
      "self",
      "x"
    ]
  },
  "get_standard_normal_pdf_cdf": [
    "x",
    "mean",
    "standard_deviation"
  ],
  "MultipointExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "jitter",
      "fast_compute",
      "eps"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "_get_acquisition": [
      "self",
      "mu",
      "Sigma",
      "y_minimum"
    ],
    "_get_acquisition_gradient": [
      "self",
      "mu",
      "Sigma",
      "dmu_dx",
      "dSigma_dx",
      "y_minimum",
      "pk",
      "symmetric_term"
    ],
    "_get_non_symmetric_and_symmetric_term_k": [
      "self",
      "b_k",
      "mu_k",
      "Sigma_k",
      "pk",
      "k"
    ],
    "_gradient_of_the_acquisition_first_term": [
      "self",
      "mu",
      "dmu_dx",
      "dSigma_dx",
      "y_minimum",
      "pk",
      "k",
      "bk",
      "mk",
      "Sigk",
      "Lk"
    ],
    "_gradient_of_the_acquisition_second_term": [
      "self",
      "mu",
      "dmu_dx",
      "dSigma_dx",
      "y_minimum",
      "pk",
      "k",
      "bk",
      "mk",
      "Sigk",
      "mk_dx",
      "Sigk_dx",
      "symmetric_term",
      "gradpk",
      "hesspk"
    ]
  },
  "get_covariance_given_smallest": [
    "Sigma",
    "k"
  ],
  "get_covariance_given_value_of_i": [
    "Sigma",
    "i"
  ],
  "get_correlations_given_value_of_i": [
    "b",
    "mu",
    "Sigma",
    "i"
  ],
  "decompose_mvn": [
    "x",
    "mu",
    "Sigma",
    "k"
  ],
  "Phi_gradient": [
    "x",
    "mu",
    "Sigma"
  ],
  "Phi_hessian": [
    "x",
    "mu",
    "Sigma",
    "gradient"
  ],
  "LogAcquisition": {
    "__init__": [
      "self",
      "acquisition"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "ProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "jitter"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "MaxValueEntropySearch": {
    "__init__": [
      "self",
      "model",
      "space",
      "num_samples",
      "grid_size"
    ],
    "update_parameters": [
      "self"
    ],
    "_required_parameters_initialized": [
      "self"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "_fit_gumbel": [
    "fmean",
    "fsd"
  ],
  "MUMBO": {
    "__init__": [
      "self",
      "model",
      "space",
      "target_information_source_index",
      "num_samples",
      "grid_size"
    ],
    "update_parameters": [
      "self"
    ],
    "evaluate": [
      "self",
      "x"
    ]
  },
  "_find_source_parameter": [
    "space"
  ],
  "ProbabilityOfFeasibility": {
    "__init__": [
      "self",
      "model",
      "jitter"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "EntropySearch": {
    "__init__": [
      "self",
      "model",
      "space",
      "sampler",
      "num_samples",
      "num_representer_points",
      "proposal_function",
      "burn_in_steps"
    ],
    "_sample_representer_points": [
      "self"
    ],
    "update_parameters": [
      "self"
    ],
    "update_pmin": [
      "self"
    ],
    "_required_parameters_initialized": [
      "self"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "_innovations": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  },
  "MultiInformationSourceEntropySearch": {
    "__init__": [
      "self",
      "model",
      "space",
      "target_information_source_index",
      "num_samples",
      "num_representer_points",
      "burn_in_steps"
    ],
    "_sample_representer_points": [
      "self"
    ],
    "_get_proposal_function": [
      "self",
      "model",
      "space"
    ]
  },
  "LocalPenalization": {
    "__init__": [
      "self",
      "model"
    ],
    "has_gradients": [
      "self"
    ],
    "update_batches": [
      "self",
      "x_batch",
      "lipschitz_constant",
      "f_min"
    ],
    "_compute_parameters": [
      "self",
      "x_batch",
      "lipschitz_constant",
      "f_min"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ]
  },
  "_distance_calculation": [
    "x_1",
    "x_2"
  ],
  "_distance_with_gradient": [
    "x_1",
    "x_2"
  ],
  "NegativeLowerConfidenceBound": {
    "__init__": [
      "self",
      "model",
      "beta"
    ],
    "evaluate": [
      "self",
      "x"
    ],
    "evaluate_with_gradients": [
      "self",
      "x"
    ],
    "has_gradients": [
      "self"
    ]
  }
}