{
  "__version__": [],
  "torch_nanstd": [
    "input",
    "dim",
    "keepdim",
    "ddof"
  ],
  "standard_scaling": [
    "input",
    "clip_value"
  ],
  "outlier_removing": [
    "input",
    "threshold"
  ],
  "permute_classes": [
    "input"
  ],
  "BalancedBinarize": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "MulticlassAssigner": {
    "__init__": [
      "self",
      "num_classes",
      "mode",
      "ordered_prob"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "Reg2Cls": {
    "__init__": [
      "self",
      "hp"
    ],
    "forward": [
      "self",
      "X",
      "y"
    ],
    "_num2cat": [
      "self",
      "X"
    ],
    "_process_features": [
      "self",
      "X"
    ]
  },
  "TreeLayer": {
    "__init__": [
      "self",
      "tree_model",
      "max_depth",
      "n_estimators",
      "out_dim",
      "device"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "TreeSCM": {
    "__init__": [
      "self",
      "seq_len",
      "num_features",
      "num_outputs",
      "is_causal",
      "num_causes",
      "y_is_effect",
      "in_clique",
      "sort_features",
      "num_layers",
      "hidden_dim",
      "tree_model",
      "max_depth_lambda",
      "n_estimators_lambda",
      "sampling",
      "pre_sample_cause_stats",
      "noise_std",
      "pre_sample_noise_std",
      "device"
    ],
    "generate_layer_modules": [
      "self",
      "is_output_layer"
    ],
    "forward": [
      "self"
    ],
    "handle_outputs": [
      "self",
      "causes",
      "outputs"
    ]
  },
  "trunc_norm_sampler": [
    "mu",
    "sigma"
  ],
  "beta_sampler": [
    "a",
    "b"
  ],
  "gamma_sampler": [
    "a",
    "b"
  ],
  "uniform_sampler": [
    "a",
    "b"
  ],
  "uniform_int_sampler": [
    "a",
    "b"
  ],
  "HpSampler": {
    "__init__": [
      "self",
      "distribution",
      "device"
    ],
    "initialize_distribution": [
      "self"
    ],
    "initialize_meta_distribution": [
      "self"
    ],
    "ensure_hyperparameter": [
      "self",
      "attr_name",
      "distribution",
      "min",
      "max"
    ],
    "setup_meta_beta_sampler": [
      "self"
    ],
    "setup_meta_gamma_sampler": [
      "self"
    ],
    "setup_meta_trunc_norm_sampler": [
      "self"
    ],
    "setup_meta_trunc_norm_log_scaled_sampler": [
      "self"
    ],
    "setup_meta_choice_sampler": [
      "self"
    ],
    "setup_meta_choice_mixed_sampler": [
      "self"
    ],
    "forward": [
      "self"
    ]
  },
  "HpSamplerList": {
    "__init__": [
      "self",
      "hyperparameters",
      "device"
    ],
    "sample": [
      "self"
    ]
  },
  "StdScaleLayer": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SignActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "Heaviside": {
    "forward": [
      "self",
      "x"
    ]
  },
  "RBFActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "RandomFreqSineActivation": {
    "__init__": [
      "self",
      "min_scale",
      "max_scale"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RandomFunctionActivation": {
    "__init__": [
      "self",
      "n_frequencies"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FunctionActivation": {
    "__init__": [
      "self",
      "f"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RandomScaleLayer": {
    "__init__": [
      "self",
      "individual"
    ],
    "initialize": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ExpActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "SqrtAbsActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "UnitIntervalIndicator": {
    "forward": [
      "self",
      "x"
    ]
  },
  "SineActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "SquareActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "AbsActivation": {
    "forward": [
      "self",
      "x"
    ]
  },
  "StdRandomScaleFactory": {
    "__init__": [
      "self",
      "act_class",
      "individual"
    ],
    "__call__": [
      "self"
    ]
  },
  "RandomChoiceActivation": {
    "__init__": [
      "self",
      "act_list"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RandomChoiceFactory": {
    "__init__": [
      "self",
      "act_classes"
    ],
    "__call__": [
      "self"
    ]
  },
  "get_activations": [
    "random",
    "scale",
    "diverse"
  ],
  "GaussianNoise": {
    "__init__": [
      "self",
      "std"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "XSampler": {
    "__init__": [
      "self",
      "seq_len",
      "num_features",
      "pre_stats",
      "sampling",
      "device"
    ],
    "_pre_stats": [
      "self"
    ],
    "sample": [
      "self",
      "return_numpy"
    ],
    "sample_normal_all": [
      "self"
    ],
    "sample_uniform": [
      "self"
    ],
    "sample_normal": [
      "self",
      "n"
    ],
    "sample_multinomial": [
      "self"
    ],
    "sample_zipf": [
      "self"
    ],
    "sample_mixed": [
      "self"
    ]
  },
  "dense2sparse": [
    "dense_tensor",
    "row_lengths",
    "dtype"
  ],
  "sparse2dense": [
    "sparse_tensor",
    "row_lengths",
    "max_len",
    "dtype"
  ],
  "SliceNestedTensor": {
    "__init__": [
      "self",
      "nested_tensor"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__len__": [
      "self"
    ],
    "to": [
      "self"
    ]
  },
  "cat_slice_nested_tensors": [
    "tensors",
    "dim"
  ],
  "LoadPriorDataset": {
    "__init__": [
      "self",
      "data_dir",
      "batch_size",
      "ddp_world_size",
      "ddp_rank",
      "start_from",
      "max_batches",
      "timeout",
      "delete_after_load",
      "device"
    ],
    "__iter__": [
      "self"
    ],
    "_load_batch_file": [
      "self"
    ],
    "__next__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SavePriorDataset": {
    "__init__": [
      "self",
      "args"
    ],
    "save_metadata": [
      "self"
    ],
    "save_batch_sparse": [
      "self",
      "batch_idx",
      "X",
      "y",
      "d",
      "seq_lens",
      "train_sizes"
    ],
    "run": [
      "self"
    ]
  },
  "MLPSCM": {
    "__init__": [
      "self",
      "seq_len",
      "num_features",
      "num_outputs",
      "is_causal",
      "num_causes",
      "y_is_effect",
      "in_clique",
      "sort_features",
      "num_layers",
      "hidden_dim",
      "mlp_activations",
      "init_std",
      "block_wise_dropout",
      "mlp_dropout_prob",
      "scale_init_std_by_dropout",
      "sampling",
      "pre_sample_cause_stats",
      "noise_std",
      "pre_sample_noise_std",
      "device"
    ],
    "generate_layer_modules": [
      "self",
      "is_output_layer"
    ],
    "initialize_parameters": [
      "self"
    ],
    "initialize_with_block_dropout": [
      "self",
      "param",
      "index"
    ],
    "initialize_normally": [
      "self",
      "param",
      "index"
    ],
    "forward": [
      "self"
    ],
    "handle_outputs": [
      "self",
      "causes",
      "outputs"
    ]
  },
  "Prior": {
    "__init__": [
      "self",
      "batch_size",
      "min_features",
      "max_features",
      "max_classes",
      "min_seq_len",
      "max_seq_len",
      "log_seq_len",
      "min_train_size",
      "max_train_size",
      "replay_small"
    ],
    "validate_train_size_range": [
      "min_train_size",
      "max_train_size"
    ],
    "sample_seq_len": [
      "min_seq_len",
      "max_seq_len",
      "log",
      "replay_small"
    ],
    "sample_train_size": [
      "min_train_size",
      "max_train_size",
      "seq_len"
    ],
    "adjust_max_features": [
      "seq_len",
      "max_features"
    ],
    "delete_unique_features": [
      "X",
      "d"
    ],
    "sanity_check": [
      "X",
      "y",
      "train_size",
      "n_attempts",
      "min_classes"
    ]
  },
  "SCMPrior": {
    "__init__": [
      "self",
      "batch_size",
      "batch_size_per_gp",
      "batch_size_per_subgp",
      "min_features",
      "max_features",
      "max_classes",
      "min_seq_len",
      "max_seq_len",
      "log_seq_len",
      "seq_len_per_gp",
      "min_train_size",
      "max_train_size",
      "replay_small",
      "prior_type",
      "fixed_hp",
      "sampled_hp",
      "n_jobs",
      "num_threads_per_generate",
      "device"
    ],
    "hp_sampling": [
      "self"
    ],
    "generate_dataset": [
      "self",
      "params"
    ],
    "get_batch": [
      "self",
      "batch_size"
    ],
    "get_prior": [
      "self"
    ]
  },
  "DummyPrior": {
    "__init__": [
      "self",
      "batch_size",
      "min_features",
      "max_features",
      "max_classes",
      "min_seq_len",
      "max_seq_len",
      "log_seq_len",
      "min_train_size",
      "max_train_size",
      "device"
    ],
    "get_batch": [
      "self",
      "batch_size"
    ]
  },
  "PriorDataset": {
    "__init__": [
      "self",
      "batch_size",
      "batch_size_per_gp",
      "batch_size_per_subgp",
      "min_features",
      "max_features",
      "max_classes",
      "min_seq_len",
      "max_seq_len",
      "log_seq_len",
      "seq_len_per_gp",
      "min_train_size",
      "max_train_size",
      "replay_small",
      "prior_type",
      "scm_fixed_hp",
      "scm_sampled_hp",
      "n_jobs",
      "num_threads_per_generate",
      "device"
    ],
    "get_batch": [
      "self",
      "batch_size"
    ],
    "__iter__": [
      "self"
    ],
    "__next__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "DisablePrinting": {
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "DEFAULT_FIXED_HP": [],
  "DEFAULT_SAMPLED_HP": [],
  "_check_version_compatibility": [
    "metadata"
  ],
  "TabICLBaseEstimator": {
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_resolve_device": [
      "self"
    ],
    "_resolve_amp_fa3": [
      "self"
    ],
    "_build_inference_config": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "save": [
      "self",
      "path",
      "save_model_weights",
      "save_training_data",
      "save_kv_cache"
    ],
    "load": [
      "cls",
      "path",
      "device"
    ],
    "softmax": [
      "x",
      "axis",
      "temperature"
    ]
  },
  "TabICLClassifier": {
    "__init__": [
      "self",
      "n_estimators",
      "norm_methods",
      "feat_shuffle_method",
      "class_shuffle_method",
      "outlier_threshold",
      "softmax_temperature",
      "average_logits",
      "support_many_classes",
      "batch_size",
      "model_path",
      "allow_auto_download",
      "checkpoint_version",
      "device",
      "use_amp",
      "use_fa3",
      "offload_mode",
      "disk_offload_dir",
      "random_state",
      "n_jobs",
      "verbose",
      "inference_config"
    ],
    "_load_model": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "kv_cache"
    ],
    "_build_kv_cache": [
      "self"
    ],
    "_batch_forward": [
      "self",
      "Xs",
      "ys",
      "feature_shuffles"
    ],
    "_batch_forward_with_cache": [
      "self",
      "Xs",
      "kv_cache"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_is_pandas_df": [
    "X"
  ],
  "_get_feature_names": [
    "X"
  ],
  "_check_feature_names": [
    "estimator",
    "X"
  ],
  "_use_interchange_protocol": [
    "X"
  ],
  "_num_features": [
    "X"
  ],
  "_check_n_features": [
    "estimator",
    "X",
    "reset"
  ],
  "_num_samples": [
    "x"
  ],
  "check_consistent_length": [],
  "_check_y": [
    "y",
    "multi_output",
    "y_numeric",
    "estimator"
  ],
  "validate_data": [
    "X",
    "y",
    "reset",
    "validate_separately",
    "skip_check_array"
  ],
  "RecursionLimitManager": {
    "__init__": [
      "self",
      "limit"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "TransformToNumerical": {
    "__init__": [
      "self",
      "verbose"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "UniqueFeatureFilter": {
    "__init__": [
      "self",
      "threshold"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "OutlierRemover": {
    "__init__": [
      "self",
      "threshold"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "CustomStandardScaler": {
    "__init__": [
      "self",
      "clip_min",
      "clip_max",
      "epsilon"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "RTDLQuantileTransformer": {
    "__init__": [
      "self",
      "noise",
      "n_quantiles",
      "subsample",
      "output_distribution",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "_add_noise": [
      "self",
      "X"
    ]
  },
  "PreprocessingPipeline": {
    "__init__": [
      "self",
      "normalization_method",
      "outlier_threshold",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "Shuffler": {
    "__init__": [
      "self",
      "n_elements",
      "method",
      "max_elements_for_latin",
      "random_state"
    ],
    "shuffle": [
      "self",
      "n_estimators"
    ],
    "_latin_squares": [
      "self"
    ]
  },
  "EnsembleGenerator": {
    "__init__": [
      "self",
      "classification",
      "n_estimators",
      "norm_methods",
      "feat_shuffle_method",
      "class_shuffle_method",
      "outlier_threshold",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_generate_ensemble": [
      "self"
    ],
    "transform": [
      "self",
      "X",
      "mode"
    ]
  },
  "TabICLRegressor": {
    "__init__": [
      "self",
      "n_estimators",
      "norm_methods",
      "feat_shuffle_method",
      "outlier_threshold",
      "batch_size",
      "model_path",
      "allow_auto_download",
      "checkpoint_version",
      "device",
      "use_amp",
      "use_fa3",
      "offload_mode",
      "disk_offload_dir",
      "random_state",
      "n_jobs",
      "verbose",
      "inference_config"
    ],
    "_load_model": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "kv_cache"
    ],
    "_build_kv_cache": [
      "self"
    ],
    "_batch_forward": [
      "self",
      "Xs",
      "ys",
      "output_type",
      "alphas"
    ],
    "_batch_forward_with_cache": [
      "self",
      "Xs",
      "kv_cache",
      "output_type",
      "alphas"
    ],
    "predict": [
      "self",
      "X",
      "output_type",
      "alphas"
    ]
  },
  "str2bool": [
    "value"
  ],
  "train_size_type": [
    "value"
  ],
  "build_parser": [],
  "_get_cosine_with_restarts_lr_lambda": [
    "current_step"
  ],
  "get_cosine_with_restarts": [
    "optimizer",
    "num_warmup_steps",
    "num_training_steps",
    "num_cycles",
    "amplitude_decay",
    "lr_end",
    "last_epoch"
  ],
  "get_scheduler": [
    "config",
    "optimizer"
  ],
  "Timer": {
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "ddp_cleanup": [
    "func"
  ],
  "Trainer": {
    "__init__": [
      "self",
      "config"
    ],
    "configure_ddp": [
      "self"
    ],
    "configure_wandb": [
      "self"
    ],
    "build_model": [
      "self"
    ],
    "configure_prior": [
      "self"
    ],
    "configure_optimizer": [
      "self"
    ],
    "configure_amp": [
      "self"
    ],
    "get_latest_checkpoint": [
      "self"
    ],
    "load_checkpoint": [
      "self"
    ],
    "save_checkpoint": [
      "self",
      "name"
    ],
    "manage_checkpoint": [
      "self"
    ],
    "train": [
      "self"
    ],
    "validate_micro_batch": [
      "self",
      "micro_seq_len",
      "micro_train_size"
    ],
    "align_micro_batch": [
      "self",
      "micro_X",
      "micro_y",
      "micro_d",
      "seq_len"
    ],
    "run_micro_batch": [
      "self",
      "micro_batch",
      "micro_batch_idx",
      "num_micro_batches"
    ],
    "run_batch": [
      "self",
      "batch"
    ]
  },
  "ICLearning": {
    "__init__": [
      "self",
      "max_classes",
      "out_dim",
      "d_model",
      "num_blocks",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "ssmax",
      "recompute"
    ],
    "_grouping": [
      "self",
      "num_classes"
    ],
    "_fit_node": [
      "self",
      "node",
      "R",
      "y",
      "current_depth"
    ],
    "_fit_hierarchical": [
      "self",
      "R_train",
      "y_train"
    ],
    "_label_encoding": [
      "self",
      "y"
    ],
    "_icl_predictions": [
      "self",
      "R",
      "y_train"
    ],
    "_predict_standard": [
      "self",
      "R",
      "y_train",
      "return_logits",
      "softmax_temperature",
      "auto_batch"
    ],
    "_predict_hierarchical": [
      "self",
      "R_test",
      "softmax_temperature",
      "inference_recurrence"
    ],
    "_inference_forward": [
      "self",
      "R",
      "y_train",
      "return_logits",
      "softmax_temperature",
      "mgr_config"
    ],
    "forward": [
      "self",
      "R",
      "y_train",
      "return_logits",
      "softmax_temperature",
      "mgr_config"
    ],
    "prepare_repr_cache": [
      "self",
      "R",
      "y_train"
    ],
    "_icl_predictions_repr_cache": [
      "self",
      "R",
      "train_size"
    ],
    "forward_with_repr_cache": [
      "self",
      "R",
      "train_size",
      "num_classes",
      "return_logits",
      "softmax_temperature",
      "mgr_config"
    ],
    "_icl_predictions_with_cache": [
      "self",
      "R",
      "icl_cache",
      "y_train",
      "use_cache",
      "store_cache"
    ],
    "forward_with_cache": [
      "self",
      "R",
      "icl_cache",
      "y_train",
      "num_classes",
      "return_logits",
      "softmax_temperature",
      "use_cache",
      "store_cache",
      "mgr_config"
    ]
  },
  "KVCacheEntry": {
    "is_valid": [
      "self"
    ],
    "__getitem__": [
      "self",
      "indices"
    ],
    "__setitem__": [
      "self",
      "indices",
      "other"
    ],
    "to": [
      "self",
      "device"
    ],
    "concat": [
      "entries",
      "dim"
    ]
  },
  "KVCache": {
    "is_populated": [
      "self"
    ],
    "__getitem__": [
      "self",
      "indices"
    ],
    "__setitem__": [
      "self",
      "indices",
      "other"
    ],
    "to": [
      "self",
      "device"
    ],
    "concat": [
      "caches",
      "dim"
    ],
    "preallocate": [
      "self",
      "reference",
      "batch_shape",
      "device"
    ]
  },
  "TabICLCache": {
    "__post_init__": [
      "self"
    ],
    "cache_type": [
      "self"
    ],
    "cache_size_mb": [
      "self"
    ],
    "is_empty": [
      "self"
    ],
    "slice_batch": [
      "self",
      "start",
      "end"
    ],
    "to": [
      "self",
      "device"
    ],
    "concat": [
      "caches",
      "dim"
    ]
  },
  "ColEmbedding": {
    "__init__": [
      "self",
      "embed_dim",
      "num_blocks",
      "nhead",
      "dim_feedforward",
      "num_inds",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "affine",
      "feature_group",
      "feature_group_size",
      "target_aware",
      "max_classes",
      "reserve_cls_tokens",
      "ssmax",
      "mixed_radix_ensemble",
      "recompute"
    ],
    "map_feature_shuffle": [
      "reference_pattern",
      "other_pattern"
    ],
    "feature_grouping": [
      "self",
      "X"
    ],
    "_compute_mixed_radix_bases": [
      "self",
      "num_classes"
    ],
    "_extract_mixed_radix_digit": [
      "self",
      "y",
      "digit_idx",
      "bases"
    ],
    "_compute_embeddings": [
      "self",
      "features",
      "train_size",
      "y_train",
      "embed_with_test"
    ],
    "_train_forward": [
      "self",
      "X",
      "y_train",
      "d",
      "embed_with_test"
    ],
    "_train_forward_with_feature_group": [
      "self",
      "X",
      "y_train",
      "embed_with_test"
    ],
    "_train_forward_without_feature_group": [
      "self",
      "X",
      "y_train",
      "d",
      "embed_with_test"
    ],
    "_inference_forward": [
      "self",
      "X",
      "y_train",
      "embed_with_test",
      "feature_shuffles",
      "mgr_config"
    ],
    "_inference_with_feature_group": [
      "self",
      "X",
      "y_train",
      "train_size",
      "embed_with_test"
    ],
    "_inference_without_feature_group": [
      "self",
      "X",
      "y_train",
      "train_size",
      "embed_with_test",
      "feature_shuffles"
    ],
    "forward": [
      "self",
      "X",
      "y_train",
      "d",
      "embed_with_test",
      "feature_shuffles",
      "mgr_config"
    ],
    "_compute_embeddings_with_cache": [
      "self",
      "features",
      "col_cache",
      "train_size",
      "y_train",
      "use_cache",
      "store_cache"
    ],
    "forward_with_cache": [
      "self",
      "X",
      "col_cache",
      "y_train",
      "use_cache",
      "store_cache",
      "mgr_config"
    ]
  },
  "_logn": [
    "n",
    "device",
    "dtype"
  ],
  "SSMax": {
    "__init__": [
      "self",
      "num_heads"
    ],
    "forward": [
      "self",
      "q",
      "n"
    ]
  },
  "SSMaxMLP": {
    "__init__": [
      "self",
      "num_heads",
      "n_hidden",
      "elementwise",
      "head_dim"
    ],
    "forward": [
      "self",
      "q",
      "n"
    ]
  },
  "QASSMaxMLP": {
    "__init__": [
      "self",
      "num_heads",
      "head_dim",
      "n_hidden",
      "elementwise"
    ],
    "forward": [
      "self",
      "q",
      "n"
    ]
  },
  "create_ssmax_layer": [
    "ssmax_type",
    "num_heads",
    "embed_dim"
  ],
  "TabICL": {
    "__init__": [
      "self",
      "max_classes",
      "num_quantiles",
      "embed_dim",
      "col_num_blocks",
      "col_nhead",
      "col_num_inds",
      "col_affine",
      "col_feature_group",
      "col_feature_group_size",
      "col_target_aware",
      "col_ssmax",
      "row_num_blocks",
      "row_nhead",
      "row_num_cls",
      "row_rope_base",
      "row_rope_interleaved",
      "icl_num_blocks",
      "icl_nhead",
      "icl_ssmax",
      "ff_factor",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "recompute"
    ],
    "has_cache": [
      "self"
    ],
    "clear_cache": [
      "self"
    ],
    "_train_forward": [
      "self",
      "X",
      "y_train",
      "d",
      "embed_with_test"
    ],
    "_inference_forward": [
      "self",
      "X",
      "y_train",
      "feature_shuffles",
      "embed_with_test",
      "return_logits",
      "softmax_temperature",
      "inference_config"
    ],
    "forward": [
      "self",
      "X",
      "y_train",
      "d",
      "embed_with_test",
      "feature_shuffles",
      "return_logits",
      "softmax_temperature",
      "inference_config"
    ],
    "predict_stats": [
      "self",
      "X",
      "y_train",
      "output_type",
      "alphas",
      "embed_with_test",
      "inference_config"
    ],
    "forward_with_cache": [
      "self",
      "X_train",
      "y_train",
      "X_test",
      "return_logits",
      "softmax_temperature",
      "use_cache",
      "store_cache",
      "cache",
      "cache_mode",
      "inference_config"
    ],
    "predict_stats_with_cache": [
      "self",
      "X_train",
      "y_train",
      "X_test",
      "output_type",
      "alphas",
      "use_cache",
      "store_cache",
      "cache",
      "cache_mode",
      "inference_config"
    ]
  },
  "_use_flash_attn3": [],
  "flash_attn3_toggle": [
    "enabled"
  ],
  "sdpa_with_flattened_batch": [
    "q",
    "k",
    "v",
    "attn_mask",
    "dropout_p",
    "ssmax_layer"
  ],
  "multi_head_attention_forward": [
    "query",
    "num_heads",
    "in_proj_weight",
    "in_proj_bias",
    "dropout_p",
    "out_proj_weight",
    "out_proj_bias",
    "key",
    "value",
    "cached_kv",
    "training",
    "key_padding_mask",
    "attn_mask",
    "rope",
    "ssmax_layer",
    "need_kv"
  ],
  "ClassNode": {
    "__init__": [
      "self",
      "depth"
    ]
  },
  "OneHotAndLinear": {
    "__init__": [
      "self",
      "num_classes",
      "embed_dim"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "SkippableLinear": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "skip_value"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "MultiheadAttention": {
    "__init__": [
      "self",
      "embed_dim",
      "num_heads",
      "dropout",
      "ssmax"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "value",
      "cached_kv",
      "key_padding_mask",
      "attn_mask",
      "rope",
      "need_kv"
    ]
  },
  "MultiheadAttentionBlock": {
    "__init__": [
      "self",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "ssmax"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "cached_kv",
      "key_padding_mask",
      "attn_mask",
      "train_size",
      "rope",
      "need_kv"
    ],
    "_attn_block": [
      "self",
      "q",
      "k",
      "v",
      "cached_kv",
      "key_padding_mask",
      "attn_mask",
      "rope",
      "need_kv"
    ],
    "_ff_block": [
      "self",
      "x"
    ]
  },
  "InducedSelfAttentionBlock": {
    "__init__": [
      "self",
      "d_model",
      "nhead",
      "dim_feedforward",
      "num_inds",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "ssmax",
      "skip_value"
    ],
    "induced_attention": [
      "self",
      "src",
      "train_size"
    ],
    "forward": [
      "self",
      "src",
      "train_size"
    ],
    "induced_attention_with_cache": [
      "self",
      "src",
      "col_cache",
      "block_idx",
      "train_size",
      "use_cache",
      "store_cache"
    ],
    "forward_with_cache": [
      "self",
      "src",
      "col_cache",
      "block_idx",
      "train_size",
      "use_cache",
      "store_cache"
    ]
  },
  "MgrConfig": {
    "_ALLOWED_KEYS": [],
    "_TYPE_SPECS": [],
    "__init__": [
      "self"
    ],
    "keys": [
      "self"
    ],
    "items": [
      "self"
    ],
    "_validate_and_set": [
      "self",
      "key",
      "value"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "get": [
      "self",
      "key",
      "default"
    ],
    "update": [
      "self",
      "other"
    ]
  },
  "InferenceConfig": {
    "__post_init__": [
      "self"
    ],
    "update_from_dict": [
      "self",
      "config_dict"
    ]
  },
  "RowInteraction": {
    "__init__": [
      "self",
      "embed_dim",
      "num_blocks",
      "nhead",
      "dim_feedforward",
      "num_cls",
      "rope_base",
      "rope_interleaved",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "recompute"
    ],
    "_aggregate_embeddings": [
      "self",
      "embeddings",
      "key_mask"
    ],
    "_train_forward": [
      "self",
      "embeddings",
      "d"
    ],
    "_inference_forward": [
      "self",
      "embeddings",
      "mgr_config"
    ],
    "forward": [
      "self",
      "embeddings",
      "d",
      "mgr_config"
    ]
  },
  "Encoder": {
    "__init__": [
      "self",
      "num_blocks",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "use_rope",
      "rope_base",
      "rope_interleaved",
      "ssmax",
      "recompute"
    ],
    "forward": [
      "self",
      "src",
      "train_size"
    ],
    "forward_with_cache": [
      "self",
      "src",
      "icl_cache",
      "train_size",
      "use_cache",
      "store_cache"
    ]
  },
  "SetTransformer": {
    "__init__": [
      "self",
      "num_blocks",
      "d_model",
      "nhead",
      "dim_feedforward",
      "num_inds",
      "dropout",
      "activation",
      "norm_first",
      "bias_free_ln",
      "ssmax",
      "recompute"
    ],
    "forward": [
      "self",
      "src",
      "train_size"
    ],
    "forward_with_cache": [
      "self",
      "src",
      "col_cache",
      "train_size",
      "use_cache",
      "store_cache"
    ]
  },
  "exists": [
    "val"
  ],
  "default": [
    "val",
    "d"
  ],
  "broadcat": [
    "tensors",
    "dim"
  ],
  "rotate_half_interleaved": [
    "x"
  ],
  "rotate_half_contiguous": [
    "x"
  ],
  "apply_rotary_emb": [
    "freqs",
    "t",
    "start_index",
    "scale",
    "seq_dim",
    "interleaved"
  ],
  "apply_learned_rotations": [
    "rotations",
    "t",
    "start_index",
    "freq_ranges"
  ],
  "RotaryEmbedding": {
    "__init__": [
      "self",
      "dim",
      "interleaved",
      "custom_freqs",
      "freqs_for",
      "theta",
      "max_freq",
      "num_freqs",
      "learned_freq",
      "use_xpos",
      "xpos_scale_base",
      "interpolate_factor",
      "theta_rescale_factor",
      "seq_before_head_dim",
      "cache_if_possible"
    ],
    "device": [
      "self"
    ],
    "tmp_store": [
      "self",
      "key",
      "value"
    ],
    "get_seq_pos": [
      "self",
      "seq_len",
      "device",
      "dtype",
      "offset"
    ],
    "rotate_queries_or_keys": [
      "self",
      "t",
      "seq_dim",
      "offset",
      "scale"
    ],
    "rotate_queries_with_cached_keys": [
      "self",
      "q",
      "k",
      "seq_dim",
      "offset"
    ],
    "rotate_queries_and_keys": [
      "self",
      "q",
      "k",
      "seq_dim"
    ],
    "get_scale": [
      "self",
      "t",
      "seq_len",
      "offset"
    ],
    "get_axial_freqs": [
      "self"
    ],
    "forward": [
      "self",
      "t",
      "seq_len",
      "offset"
    ]
  },
  "MemoryEstimator": {
    "estimate_peak_mem": [
      "batch_size",
      "seq_len",
      "enc_name",
      "include_inputs",
      "in_dim"
    ],
    "estimate_batch_size": [
      "seq_len",
      "target_memory",
      "enc_name",
      "include_inputs",
      "in_dim"
    ]
  },
  "OffloadMode": {
    "GPU": [],
    "CPU": [],
    "DISK": [],
    "AUTO": []
  },
  "OffloadConfig": {},
  "PinnedBufferPool": {
    "__init__": [
      "self",
      "max_buffers_per_shape"
    ],
    "get": [
      "self",
      "shape",
      "dtype"
    ],
    "put": [
      "self",
      "buf"
    ],
    "clear": [
      "self"
    ]
  },
  "DiskTensor": {
    "__init__": [
      "self",
      "shape",
      "dtype",
      "path",
      "cleanup"
    ],
    "_resolve_dtype": [
      "dtype"
    ],
    "_cleanup_file": [
      "path"
    ],
    "tensor": [
      "self"
    ],
    "__getitem__": [
      "self",
      "indices"
    ],
    "__setitem__": [
      "self",
      "indices",
      "value"
    ],
    "flush": [
      "self"
    ],
    "nbytes": [
      "self"
    ]
  },
  "AsyncCopyManager": {
    "__init__": [
      "self",
      "device",
      "max_pending",
      "buffer_pool"
    ],
    "submit_copy": [
      "self",
      "gpu_tensor",
      "target",
      "indices"
    ],
    "_drain_one": [
      "self"
    ],
    "drain_all": [
      "self"
    ],
    "get_bytes_written": [
      "self"
    ],
    "reset_bytes_counter": [
      "self"
    ],
    "clear": [
      "self"
    ]
  },
  "InferenceManager": {
    "__init__": [
      "self",
      "enc_name",
      "out_dim",
      "out_no_seq"
    ],
    "configure": [
      "self",
      "min_batch_size",
      "safety_factor",
      "offload",
      "auto_offload_threshold",
      "device",
      "use_amp",
      "use_fa3",
      "verbose",
      "disk_offload_dir",
      "disk_min_free_mb",
      "disk_flush_mb",
      "disk_cleanup",
      "disk_file_prefix",
      "disk_dtype",
      "cpu_safety_factor",
      "disk_safety_factor",
      "max_pinned_memory_mb",
      "use_async",
      "async_depth"
    ],
    "_normalize_offload": [
      "self",
      "offload"
    ],
    "get_available_cpu_memory": [
      "self"
    ],
    "get_available_gpu_memory": [
      "self"
    ],
    "get_available_disk_space": [
      "self",
      "path"
    ],
    "_estimate_tensor_mb": [
      "self",
      "shape",
      "dtype",
      "repeat"
    ],
    "estimate_safe_batch_size": [
      "self",
      "seq_len",
      "include_inputs",
      "in_dim",
      "max_bs"
    ],
    "_resolve_offload_mode": [
      "self",
      "output_mb",
      "gpu_free_mb",
      "cpu_free_mb",
      "disk_free_mb"
    ],
    "_allocate_output_buffer": [
      "self",
      "mode",
      "shape",
      "dtype"
    ],
    "_to_exe_device": [
      "self",
      "tensor"
    ],
    "_prepare_inputs": [
      "self",
      "inputs"
    ],
    "_run_forward": [
      "self",
      "forward_fn",
      "inputs"
    ],
    "__call__": [
      "self",
      "forward_fn",
      "inputs",
      "auto_batch",
      "output_repeat"
    ],
    "compute_split_sizes": [
      "batch_dims",
      "batch_size"
    ],
    "compute_n_batches": [
      "batch_dims",
      "split_sizes"
    ],
    "create_multidim_batches": [
      "self",
      "inputs",
      "batch_dims",
      "split_sizes"
    ]
  },
  "QuantileDistributionConfig": {},
  "isotonic_regression_pava": [
    "y",
    "weights"
  ],
  "enforce_monotonicity": [
    "quantiles",
    "method",
    "weights"
  ],
  "estimate_exp_tail_params": [
    "quantiles",
    "alpha_levels",
    "num_tail_quantiles"
  ],
  "estimate_gpd_tail_params": [
    "quantiles",
    "alpha_levels",
    "num_tail_quantiles"
  ],
  "QuantileDistribution": {
    "arg_constraints": [],
    "support": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "quantiles",
      "alpha_levels",
      "tail_type",
      "fix_crossing",
      "crossing_method"
    ],
    "_setup_spline": [
      "self"
    ],
    "_setup_tails": [
      "self"
    ],
    "icdf": [
      "self",
      "alpha"
    ],
    "_expand_to_alpha": [
      "self",
      "param",
      "alpha"
    ],
    "_icdf_left_tail": [
      "self",
      "alpha"
    ],
    "_icdf_right_tail": [
      "self",
      "alpha"
    ],
    "_icdf_gpd_left": [
      "self",
      "alpha"
    ],
    "_icdf_gpd_right": [
      "self",
      "alpha"
    ],
    "_icdf_spline": [
      "self",
      "alpha"
    ],
    "cdf": [
      "self",
      "z"
    ],
    "_expand_to_z": [
      "self",
      "param",
      "z"
    ],
    "_cdf_left_tail": [
      "self",
      "z"
    ],
    "_cdf_right_tail": [
      "self",
      "z"
    ],
    "_cdf_spline": [
      "self",
      "z"
    ],
    "_icdf_derivative": [
      "self",
      "alpha"
    ],
    "_deriv_left_tail": [
      "self",
      "alpha"
    ],
    "_deriv_right_tail": [
      "self",
      "alpha"
    ],
    "_deriv_spline": [
      "self",
      "alpha"
    ],
    "log_prob": [
      "self",
      "z"
    ],
    "pdf": [
      "self",
      "z"
    ],
    "crps": [
      "self",
      "z"
    ],
    "_crps_left_tail": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_left_tail_exp": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_left_tail_gpd": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_right_tail": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_right_tail_exp": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_right_tail_gpd": [
      "self",
      "z",
      "alpha_z"
    ],
    "_crps_spline": [
      "self",
      "z",
      "alpha_z"
    ],
    "pinball": [
      "self",
      "z",
      "num_quantiles"
    ],
    "mean": [
      "self"
    ],
    "_mean_exp_analytical": [
      "self"
    ],
    "_mean_gpd_analytical": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "_variance_exp_analytical": [
      "self"
    ],
    "_variance_gpd_analytical": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "sample_shape"
    ]
  },
  "QuantileToDistribution": {
    "__init__": [
      "self",
      "alpha_levels",
      "num_quantiles",
      "tail_type",
      "fix_crossing",
      "crossing_method"
    ],
    "forward": [
      "self",
      "quantiles"
    ]
  }
}