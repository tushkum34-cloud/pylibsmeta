{
  "is_initialized": [],
  "_r_install_if_not_available": [
    "pkg_name"
  ],
  "_setup_r_glmnet": [],
  "_to_r_obj": [
    "X",
    "R_name"
  ],
  "r_glmnet_bench": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "iterations",
    "cv",
    "reg_multiplier"
  ],
  "_build_and_fit": [
    "model_args",
    "train_args"
  ],
  "_hstack_sparse_or_dense": [
    "to_stack"
  ],
  "h2o_bench": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "iterations",
    "cv",
    "reg_multiplier"
  ],
  "zeros_bench": [
    "dat"
  ],
  "_load": [
    "which",
    "n_rows"
  ],
  "_naive_sandwich": [
    "x",
    "d"
  ],
  "_fast_sandwich": [
    "X",
    "d"
  ],
  "_split_sandwich": [
    "X",
    "threshold"
  ],
  "_dense_sandwich": [
    "X",
    "d"
  ],
  "_run_one_problem_all_methods": [
    "x",
    "d",
    "include_naive",
    "dtype"
  ],
  "main": [],
  "random_seed": [],
  "glum_bench": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "iterations",
    "cv",
    "diagnostics_level",
    "reg_multiplier",
    "hessian_approx"
  ],
  "_compute_path": [
    "niters",
    "model_args",
    "fit_args"
  ],
  "_numpy_mklC": [
    "X",
    "d"
  ],
  "_numpy_mklF": [
    "X",
    "d"
  ],
  "_bench": [
    "f",
    "iter"
  ],
  "_dense_sandwichC": [
    "X",
    "d"
  ],
  "_dense_sandwichF": [
    "X",
    "d"
  ],
  "_mn_run": [
    "m",
    "n",
    "iter",
    "dtype"
  ],
  "main2": [],
  "benchmark_convergence_tolerance": [],
  "cache_location": [],
  "runtime": [
    "f",
    "iterations"
  ],
  "get_sklearn_family": [
    "distribution"
  ],
  "get_obj_val": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "intercept",
    "coefs"
  ],
  "exposure_and_offset_to_weights": [
    "power",
    "y",
    "exposure",
    "sample_weight",
    "offset"
  ],
  "BenchmarkParams": {
    "__init__": [
      "self",
      "problem_name",
      "library_name",
      "num_rows",
      "storage",
      "threads",
      "single_precision",
      "regularization_strength",
      "cv",
      "hessian_approx",
      "diagnostics_level"
    ],
    "param_names": [],
    "update_params": [
      "self"
    ],
    "get_result_fname": [
      "self"
    ]
  },
  "defaults": [],
  "benchmark_params_cli": [
    "func"
  ],
  "_get_params": [
    "params"
  ],
  "get_params_from_fname": [
    "fname"
  ],
  "_get_size_of_cache_directory": [],
  "clear_cache": [
    "force"
  ],
  "get_tweedie_p": [
    "distribution"
  ],
  "joblib_memory": [],
  "Problem": {
    "data_loader": [],
    "distribution": [],
    "regularization_strength": [],
    "l1_ratio": []
  },
  "load_data": [
    "loader_func",
    "num_rows",
    "storage",
    "single_precision",
    "noise",
    "distribution",
    "data_setup"
  ],
  "get_all_problems": [],
  "_get_comma_sep_names": [
    "xs"
  ],
  "cli_analyze": [
    "params",
    "output_dir",
    "export",
    "cols"
  ],
  "_extract_dict_results_to_pd_series": [
    "fname",
    "results"
  ],
  "_identify_parameter_fnames": [
    "root_dir",
    "constraint_params"
  ],
  "_load_benchmark_results": [
    "output_dir",
    "fname"
  ],
  "orig_sklearn_fork_bench": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "iterations",
    "cv",
    "reg_multiplier"
  ],
  "liblinear_bench": [
    "dat",
    "distribution",
    "alpha",
    "l1_ratio",
    "iterations",
    "cv",
    "reg_multiplier"
  ],
  "cli_run": [
    "params",
    "output_dir",
    "iterations"
  ],
  "execute_problem_library": [
    "params",
    "iterations",
    "diagnostics_level"
  ],
  "get_all_libraries": [],
  "get_limited_problems_libraries": [
    "problem_names",
    "library_names"
  ],
  "get_limited_problems": [
    "problem_names"
  ],
  "_save_benchmark_results": [
    "output_dir",
    "params",
    "result"
  ],
  "Link": {
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ],
    "to_tweedie": [
      "self",
      "safe"
    ]
  },
  "catch_p": [
    "fun"
  ],
  "TweedieLink": {
    "__init__": [
      "self",
      "power"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie__repr__": [
      "self"
    ],
    "power": [
      "self",
      "power"
    ],
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ]
  },
  "IdentityLink": {
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ]
  },
  "LogLink": {
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ]
  },
  "LogitLink": {
    "__eq__": [
      "self",
      "other"
    ],
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ]
  },
  "CloglogLink": {
    "__eq__": [
      "self",
      "other"
    ],
    "link": [
      "self",
      "mu"
    ],
    "derivative": [
      "self",
      "mu"
    ],
    "inverse": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative": [
      "self",
      "lin_pred"
    ],
    "inverse_derivative2": [
      "self",
      "lin_pred"
    ]
  },
  "_logger": [],
  "_asanyarray": [
    "x"
  ],
  "_align_df_categories": [
    "df",
    "dtypes",
    "has_missing_category",
    "cat_missing_method"
  ],
  "_add_missing_categories": [
    "df",
    "dtypes",
    "feature_names",
    "categorical_format",
    "cat_missing_name"
  ],
  "_expand_categorical_penalties": [
    "penalty",
    "X",
    "drop_first",
    "has_missing_category"
  ],
  "_is_contiguous": [
    "X"
  ],
  "_safe_lin_pred": [
    "X",
    "coef",
    "offset"
  ],
  "_safe_sandwich_dot": [
    "X",
    "d",
    "rows",
    "cols",
    "intercept"
  ],
  "_safe_toarray": [
    "X"
  ],
  "_positional_args_deprecated": [
    "unchanged_args",
    "unchanged_args_number"
  ],
  "ExponentialDispersionModel": {
    "lower_bound": [
      "self"
    ],
    "upper_bound": [
      "self"
    ],
    "include_lower_bound": [
      "self"
    ],
    "include_upper_bound": [
      "self"
    ],
    "in_y_range": [
      "self",
      "x"
    ],
    "to_tweedie": [
      "self",
      "safe"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "variance": [
      "self",
      "mu",
      "dispersion",
      "sample_weight"
    ],
    "variance_derivative": [
      "self",
      "mu",
      "dispersion",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "unit_deviance_derivative": [
      "self",
      "y",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "deviance_derivative": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "_mu_deviance_derivative": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "link",
      "offset"
    ],
    "eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "rowwise_gradient_hessian": [
      "self",
      "link",
      "coef",
      "dispersion",
      "X",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "offset"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_fisher_information": [
      "self",
      "link",
      "X",
      "y",
      "mu",
      "sample_weight",
      "dispersion",
      "fit_intercept"
    ],
    "_observed_information": [
      "self",
      "link",
      "X",
      "y",
      "mu",
      "sample_weight",
      "dispersion",
      "fit_intercept"
    ],
    "_score_matrix": [
      "self",
      "link",
      "X",
      "y",
      "mu",
      "sample_weight",
      "dispersion",
      "fit_intercept"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "TweedieDistribution": {
    "upper_bound": [],
    "include_upper_bound": [],
    "__init__": [
      "self",
      "power"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "lower_bound": [
      "self"
    ],
    "include_lower_bound": [
      "self"
    ],
    "power": [
      "self",
      "power"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "NormalDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "PoissonDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "GammaDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "InverseGaussianDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "__tweedie_repr__": [
      "self"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "GeneralizedHyperbolicSecant": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ]
  },
  "BinomialDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__eq__": [
      "self",
      "other"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "NegativeBinomialDistribution": {
    "lower_bound": [],
    "upper_bound": [],
    "include_lower_bound": [],
    "include_upper_bound": [],
    "__init__": [
      "self",
      "theta"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "theta": [
      "self",
      "theta"
    ],
    "unit_variance": [
      "self",
      "mu"
    ],
    "unit_variance_derivative": [
      "self",
      "mu"
    ],
    "deviance": [
      "self",
      "y",
      "mu",
      "sample_weight"
    ],
    "unit_deviance": [
      "self",
      "y",
      "mu"
    ],
    "_rowwise_gradient_hessian": [
      "self",
      "link",
      "y",
      "sample_weight",
      "eta",
      "mu",
      "gradient_rows",
      "hessian_rows"
    ],
    "_eta_mu_deviance": [
      "self",
      "link",
      "factor",
      "cur_eta",
      "X_dot_d",
      "y",
      "sample_weight",
      "eta_out",
      "mu_out"
    ],
    "log_likelihood": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "dispersion"
    ],
    "dispersion": [
      "self",
      "y",
      "mu",
      "sample_weight",
      "ddof",
      "method"
    ]
  },
  "guess_intercept": [
    "y",
    "sample_weight",
    "link",
    "distribution",
    "eta"
  ],
  "get_one_over_variance": [
    "distribution",
    "link",
    "mu",
    "eta",
    "dispersion",
    "sample_weight"
  ],
  "_as_float_arrays": [],
  "__all__": [],
  "GeneralizedLinearRegressorCV": {
    "__init__": [
      "self"
    ],
    "_validate_hyperparameters": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ]
  },
  "_float_itemsize_to_dtype": [],
  "VectorLike": [],
  "ArrayLike": [],
  "ShapedArrayLike": [],
  "WaldTestResult": {},
  "check_array_tabmat_compliant": [
    "mat",
    "drop_first"
  ],
  "check_X_y_tabmat_compliant": [
    "X",
    "y"
  ],
  "_check_weights": [
    "sample_weight",
    "n_samples",
    "dtype",
    "force_all_finite"
  ],
  "_check_offset": [
    "offset",
    "n_rows",
    "dtype"
  ],
  "_parse_formula": [
    "formula",
    "include_intercept"
  ],
  "check_bounds": [
    "bounds",
    "n_features",
    "dtype"
  ],
  "check_inequality_constraints": [
    "A_ineq",
    "b_ineq",
    "n_features",
    "dtype"
  ],
  "_standardize": [
    "X",
    "sample_weight",
    "center_predictors",
    "estimate_as_if_scaled_model",
    "lower_bounds",
    "upper_bounds",
    "A_ineq",
    "P1",
    "P2"
  ],
  "_unstandardize": [
    "col_means",
    "col_stds",
    "intercept",
    "coef"
  ],
  "_one_over_var_inf_to_val": [
    "arr",
    "val"
  ],
  "_standardize_warm_start": [
    "coef",
    "col_means",
    "col_stds"
  ],
  "get_family": [
    "family"
  ],
  "get_link": [
    "link",
    "family"
  ],
  "setup_p1": [
    "P1",
    "X",
    "dtype",
    "alpha",
    "l1_ratio"
  ],
  "setup_p2": [
    "P2",
    "X",
    "stype",
    "dtype",
    "alpha",
    "l1_ratio"
  ],
  "is_pos_semidef": [
    "p"
  ],
  "_group_sum": [
    "groups",
    "data"
  ],
  "GeneralizedLinearRegressorBase": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "family_instance": [
      "self"
    ],
    "link_instance": [
      "self"
    ],
    "_get_start_coef": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset",
      "col_means",
      "col_stds",
      "dtype"
    ],
    "_convert_from_pandas": [
      "self",
      "df",
      "context"
    ],
    "_set_up_for_fit": [
      "self",
      "y"
    ],
    "_get_alpha_path": [
      "self",
      "P1_no_alpha",
      "X",
      "y",
      "w",
      "offset"
    ],
    "_solve": [
      "self",
      "X",
      "y",
      "sample_weight",
      "P2",
      "P1",
      "coef",
      "offset",
      "lower_bounds",
      "upper_bounds",
      "A_ineq",
      "b_ineq"
    ],
    "_solve_regularization_path": [
      "self",
      "X",
      "y",
      "sample_weight",
      "alphas",
      "P2_no_alpha",
      "P1_no_alpha",
      "coef",
      "offset",
      "lower_bounds",
      "upper_bounds",
      "A_ineq",
      "b_ineq"
    ],
    "report_diagnostics": [
      "self"
    ],
    "get_formatted_diagnostics": [
      "self"
    ],
    "_find_alpha_index": [
      "self",
      "alpha"
    ],
    "linear_predictor": [
      "self",
      "X",
      "offset"
    ],
    "predict": [
      "self",
      "X",
      "sample_weight",
      "offset"
    ],
    "coef_table": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "wald_test": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "_wald_test_matrix": [
      "self",
      "R",
      "r"
    ],
    "_wald_test_feature_names": [
      "self",
      "features",
      "values"
    ],
    "_wald_test_formula": [
      "self",
      "formula"
    ],
    "_wald_test_term_names": [
      "self",
      "terms",
      "values"
    ],
    "std_errors": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "covariance_matrix": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "_validate_hyperparameters": [
      "self"
    ],
    "_should_copy_X": [
      "self"
    ],
    "_set_up_and_check_fit_args": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset",
      "force_all_finite",
      "context"
    ]
  },
  "GeneralizedLinearRegressor": {
    "__init__": [
      "self"
    ],
    "_validate_hyperparameters": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "offset"
    ],
    "_compute_information_criteria": [
      "self",
      "X",
      "y",
      "sample_weight",
      "context"
    ],
    "aic": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "aicc": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "bic": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_get_info_criteria": [
      "self",
      "crit",
      "X",
      "y",
      "sample_weight",
      "context"
    ]
  },
  "timeit": [
    "runtime_attr"
  ],
  "_least_squares_solver": [
    "state",
    "data",
    "hessian"
  ],
  "_cd_solver": [
    "state",
    "data",
    "active_hessian"
  ],
  "update_hessian": [
    "state",
    "data",
    "active_set"
  ],
  "_is_subset": [
    "x",
    "y"
  ],
  "build_hessian_delta": [
    "X",
    "hessian_rows",
    "intercept",
    "P2",
    "active_rows",
    "active_cols"
  ],
  "_irls_solver": [
    "inner_solver",
    "coef",
    "data"
  ],
  "ProgressBar": {
    "__init__": [
      "self",
      "start_norm",
      "tol",
      "verbose"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ],
    "_update": [
      "self",
      "n_iter",
      "iteration_runtime",
      "cur_grad_norm"
    ]
  },
  "IRLSData": {
    "__post_init__": [
      "self",
      "lower_bounds",
      "upper_bounds"
    ]
  },
  "_setup_bounds": [
    "bounds",
    "dtype"
  ],
  "IRLSState": {
    "__init__": [
      "self",
      "coef",
      "data"
    ],
    "_record_iteration": [
      "self"
    ]
  },
  "check_convergence": [
    "state",
    "data"
  ],
  "_update_predictions": [
    "state",
    "data",
    "coef",
    "X_dot_step",
    "factor"
  ],
  "eta_mu_objective": [
    "family",
    "link",
    "X_dot_step",
    "factor",
    "coef",
    "cur_eta",
    "y",
    "sample_weight",
    "P1",
    "P2",
    "intercept_offset"
  ],
  "update_quadratic": [
    "state",
    "data",
    "coef_P2"
  ],
  "_make_coef_P2": [
    "intercept_offset",
    "P2",
    "coef"
  ],
  "identify_active_set": [
    "state",
    "data"
  ],
  "line_search": [
    "state",
    "data",
    "d"
  ],
  "_get_obj_and_derivative": [
    "coef",
    "X",
    "y",
    "sample_weight",
    "P2",
    "family",
    "link",
    "offset"
  ],
  "_lbfgs_solver": [
    "coef",
    "X",
    "y",
    "sample_weight",
    "P2",
    "verbose",
    "family",
    "link",
    "max_iter",
    "tol",
    "offset"
  ],
  "_trust_constr_solver": [
    "coef",
    "X",
    "y",
    "sample_weight",
    "P2",
    "fit_intercept",
    "verbose",
    "family",
    "link",
    "max_iter",
    "xtol",
    "gtol",
    "offset",
    "A_ineq",
    "b_ineq"
  ]
}