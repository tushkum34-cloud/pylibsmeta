{
  "get_version": [],
  "__version__": [],
  "__all__": [],
  "ParamScheduler": {
    "WHERE_EPSILON": [],
    "__call__": [
      "self",
      "where"
    ]
  },
  "ConstantParamScheduler": {
    "__init__": [
      "self",
      "value"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "CosineParamScheduler": {
    "__init__": [
      "self",
      "start_value",
      "end_value"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "ExponentialParamScheduler": {
    "__init__": [
      "self",
      "start_value",
      "decay"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "LinearParamScheduler": {
    "__init__": [
      "self",
      "start_value",
      "end_value"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "MultiStepParamScheduler": {
    "__init__": [
      "self",
      "values",
      "num_updates",
      "milestones"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "PolynomialDecayParamScheduler": {
    "__init__": [
      "self",
      "base_value",
      "power"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "StepParamScheduler": {
    "__init__": [
      "self",
      "num_updates",
      "values"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "StepWithFixedGammaParamScheduler": {
    "__init__": [
      "self",
      "base_value",
      "num_decays",
      "gamma",
      "num_updates"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "CompositeParamScheduler": {
    "__init__": [
      "self",
      "schedulers",
      "lengths",
      "interval_scaling"
    ],
    "__call__": [
      "self",
      "where"
    ]
  },
  "_IncompatibleKeys": {},
  "Checkpointer": {
    "__init__": [
      "self",
      "model",
      "save_dir"
    ],
    "add_checkpointable": [
      "self",
      "key",
      "checkpointable"
    ],
    "save": [
      "self",
      "name"
    ],
    "load": [
      "self",
      "path",
      "checkpointables"
    ],
    "has_checkpoint": [
      "self"
    ],
    "get_checkpoint_file": [
      "self"
    ],
    "get_all_checkpoint_files": [
      "self"
    ],
    "resume_or_load": [
      "self",
      "path"
    ],
    "tag_last_checkpoint": [
      "self",
      "last_filename_basename"
    ],
    "_load_file": [
      "self",
      "f"
    ],
    "_load_model": [
      "self",
      "checkpoint"
    ],
    "_log_incompatible_keys": [
      "self",
      "incompatible"
    ],
    "_convert_ndarray_to_tensor": [
      "self",
      "state_dict"
    ]
  },
  "PeriodicCheckpointer": {
    "__init__": [
      "self",
      "checkpointer",
      "period",
      "max_iter",
      "max_to_keep",
      "file_prefix"
    ],
    "step": [
      "self",
      "iteration"
    ],
    "save": [
      "self",
      "name"
    ]
  },
  "_filter_reused_missing_keys": [
    "model",
    "keys"
  ],
  "get_missing_parameters_message": [
    "keys"
  ],
  "get_unexpected_parameters_message": [
    "keys"
  ],
  "_strip_prefix_if_present": [
    "state_dict",
    "prefix"
  ],
  "_group_checkpoint_keys": [
    "keys"
  ],
  "_group_to_str": [
    "group"
  ],
  "_named_modules_with_dup": [
    "model",
    "prefix"
  ],
  "get_cache_dir": [
    "cache_dir"
  ],
  "PathManager": [],
  "BASE_KEY": [],
  "CfgNode": {
    "_open_cfg": [
      "cls",
      "filename"
    ],
    "load_yaml_with_base": [
      "cls",
      "filename",
      "allow_unsafe"
    ],
    "merge_from_file": [
      "self",
      "cfg_filename",
      "allow_unsafe"
    ],
    "merge_from_other_cfg": [
      "self",
      "cfg_other"
    ],
    "merge_from_list": [
      "self",
      "cfg_list"
    ],
    "__setattr__": [
      "self",
      "name",
      "val"
    ]
  },
  "Registry": {
    "__init__": [
      "self",
      "name"
    ],
    "_do_register": [
      "self",
      "name",
      "obj"
    ],
    "register": [
      "self",
      "obj"
    ],
    "get": [
      "self",
      "name"
    ],
    "__contains__": [
      "self",
      "name"
    ],
    "__repr__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__str__": []
  },
  "Timer": {
    "__init__": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "pause": [
      "self"
    ],
    "is_paused": [
      "self"
    ],
    "resume": [
      "self"
    ],
    "seconds": [
      "self"
    ],
    "avg_seconds": [
      "self"
    ]
  },
  "HistoryBuffer": {
    "__init__": [
      "self",
      "max_length"
    ],
    "update": [
      "self",
      "value",
      "iteration"
    ],
    "latest": [
      "self"
    ],
    "median": [
      "self",
      "window_size"
    ],
    "avg": [
      "self",
      "window_size"
    ],
    "global_avg": [
      "self"
    ],
    "values": [
      "self"
    ]
  },
  "timeit": [
    "num_iters",
    "warmup_iters"
  ],
  "benchmark": [
    "func",
    "bm_name",
    "kwargs_list"
  ],
  "_MeanOfBatchVarianceEstimator": {
    "__init__": [
      "self",
      "mean_buffer",
      "var_buffer"
    ],
    "update": [
      "self",
      "batch_mean",
      "batch_var",
      "batch_size"
    ]
  },
  "_PopulationVarianceEstimator": {
    "__init__": [
      "self",
      "mean_buffer",
      "var_buffer"
    ],
    "update": [
      "self",
      "batch_mean",
      "batch_var",
      "batch_size"
    ],
    "pop_var": [
      "self"
    ]
  },
  "update_bn_stats": [
    "model",
    "data_loader",
    "num_iters",
    "progress"
  ],
  "get_bn_modules": [
    "model"
  ],
  "Handle": [],
  "get_shape": [
    "val"
  ],
  "generic_activation_jit": [
    "op_name"
  ],
  "addmm_flop_jit": [
    "inputs",
    "outputs"
  ],
  "linear_flop_jit": [
    "inputs",
    "outputs"
  ],
  "bmm_flop_jit": [
    "inputs",
    "outputs"
  ],
  "conv_flop_count": [
    "x_shape",
    "w_shape",
    "out_shape",
    "transposed"
  ],
  "conv_flop_jit": [
    "inputs",
    "outputs"
  ],
  "einsum_flop_jit": [
    "inputs",
    "outputs"
  ],
  "matmul_flop_jit": [
    "inputs",
    "outputs"
  ],
  "norm_flop_counter": [
    "affine_arg_index"
  ],
  "batchnorm_flop_jit": [
    "inputs",
    "outputs"
  ],
  "elementwise_flop_counter": [
    "input_scale",
    "output_scale"
  ],
  "_AllReduce": {
    "forward": [
      "ctx",
      "input"
    ],
    "backward": [
      "ctx",
      "grad_output"
    ]
  },
  "differentiable_all_reduce": [
    "input"
  ],
  "_AllGather": {
    "forward": [
      "ctx",
      "x"
    ],
    "backward": [
      "ctx"
    ]
  },
  "differentiable_all_gather": [
    "input"
  ],
  "smooth_l1_loss": [
    "input",
    "target",
    "beta",
    "reduction"
  ],
  "parameter_count": [
    "model"
  ],
  "parameter_count_table": [
    "model",
    "max_depth"
  ],
  "SqueezeExcitation": {
    "__init__": [
      "self",
      "num_channels",
      "num_channels_reduced",
      "reduction_ratio",
      "is_3d",
      "activation"
    ],
    "forward": [
      "self",
      "input_tensor"
    ]
  },
  "SpatialSqueezeExcitation": {
    "__init__": [
      "self",
      "num_channels",
      "is_3d"
    ],
    "forward": [
      "self",
      "input_tensor"
    ]
  },
  "ChannelSpatialSqueezeExcitation": {
    "__init__": [
      "self",
      "num_channels",
      "num_channels_reduced",
      "reduction_ratio",
      "is_3d",
      "activation"
    ],
    "forward": [
      "self",
      "input_tensor"
    ]
  },
  "ActivationCountAnalysis": {
    "__init__": [
      "self",
      "model",
      "inputs"
    ]
  },
  "activation_count": [
    "model",
    "inputs",
    "supported_ops"
  ],
  "_format_size": [
    "x",
    "sig_figs",
    "hide_zero"
  ],
  "_pretty_statistics": [
    "statistics",
    "sig_figs",
    "hide_zero"
  ],
  "_group_by_module": [
    "statistics"
  ],
  "_indicate_uncalled_modules": [
    "statistics",
    "stat_name",
    "uncalled_modules",
    "uncalled_indicator"
  ],
  "_remove_zero_statistics": [
    "statistics",
    "force_keep",
    "require_trivial_children"
  ],
  "_fill_missing_statistics": [
    "model",
    "statistics"
  ],
  "_model_stats_str": [
    "model",
    "statistics"
  ],
  "_get_input_sizes": [
    "iterable"
  ],
  "flop_count_str": [
    "flops",
    "activations"
  ],
  "_get_single_child": [
    "name",
    "statistics"
  ],
  "_try_combine": [
    "stats1",
    "stats2"
  ],
  "_fastforward": [
    "name",
    "statistics"
  ],
  "_model_stats_table": [
    "statistics",
    "max_depth",
    "stat_columns"
  ],
  "flop_count_table": [
    "flops",
    "max_depth",
    "activations",
    "show_param_shapes"
  ],
  "sigmoid_focal_loss": [
    "inputs",
    "targets",
    "alpha",
    "gamma",
    "reduction"
  ],
  "sigmoid_focal_loss_star": [
    "inputs",
    "targets",
    "alpha",
    "gamma",
    "reduction"
  ],
  "c2_xavier_fill": [
    "module"
  ],
  "c2_msra_fill": [
    "module"
  ],
  "T": [],
  "Statistics": {},
  "_named_modules_without_dup": [
    "model"
  ],
  "_get_scoped_trace_graph": [
    "module",
    "inputs",
    "aliases"
  ],
  "JitModelAnalysis": {
    "__init__": [
      "self",
      "model",
      "inputs"
    ],
    "total": [
      "self",
      "module_name"
    ],
    "by_operator": [
      "self",
      "module_name"
    ],
    "by_module_and_operator": [
      "self"
    ],
    "by_module": [
      "self"
    ],
    "unsupported_ops": [
      "self",
      "module_name"
    ],
    "uncalled_modules": [
      "self"
    ],
    "set_op_handle": [
      "self"
    ],
    "clear_op_handles": [
      "self"
    ],
    "canonical_module_name": [
      "self",
      "name"
    ],
    "copy": [
      "self",
      "new_model",
      "new_inputs"
    ],
    "tracer_warnings": [
      "self",
      "mode"
    ],
    "ancestor_mode": [
      "self",
      "mode"
    ],
    "unsupported_ops_warnings": [
      "self",
      "enabled"
    ],
    "uncalled_modules_warnings": [
      "self",
      "enabled"
    ],
    "_warn_unsupported_ops": [
      "self",
      "ops"
    ],
    "_warn_uncalled_mods": [
      "self",
      "uncalled_mods"
    ],
    "_get_aliases": [
      "self",
      "model"
    ],
    "_get_all_ancestors": [
      "self",
      "module_name"
    ],
    "_analyze": [
      "self"
    ],
    "_simplify_op_name": [
      "self",
      "full_op_name"
    ],
    "_has_forward": [
      "self",
      "mod_name"
    ],
    "_should_ignore_node": [
      "self",
      "node"
    ]
  },
  "giou_loss": [
    "boxes1",
    "boxes2",
    "reduction",
    "eps"
  ],
  "FlopCountAnalysis": {
    "__init__": [
      "self",
      "model",
      "inputs"
    ]
  },
  "flop_count": [
    "model",
    "inputs",
    "supported_ops"
  ],
  "to_float_tensor": [
    "numpy_array"
  ],
  "to_numpy": [
    "float_tensor",
    "target_shape",
    "target_dtype"
  ],
  "Transform": {
    "_set_attributes": [
      "self",
      "params"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "apply_segmentation": [
      "self",
      "segmentation"
    ],
    "apply_box": [
      "self",
      "box"
    ],
    "apply_polygons": [
      "self",
      "polygons"
    ],
    "register_type": [
      "cls",
      "data_type",
      "func"
    ],
    "inverse": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_T": [],
  "TransformList": {
    "__init__": [
      "self",
      "transforms"
    ],
    "_apply": [
      "self",
      "x",
      "meth"
    ],
    "__getattribute__": [
      "self",
      "name"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "inverse": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [],
    "apply_coords": [
      "self",
      "x"
    ],
    "apply_image": [
      "self",
      "x"
    ]
  },
  "HFlipTransform": {
    "__init__": [
      "self",
      "width"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "inverse": [
      "self"
    ]
  },
  "VFlipTransform": {
    "__init__": [
      "self",
      "height"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "inverse": [
      "self"
    ]
  },
  "NoOpTransform": {
    "__init__": [
      "self"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "inverse": [
      "self"
    ],
    "__getattr__": [
      "self",
      "name"
    ]
  },
  "ScaleTransform": {
    "__init__": [
      "self",
      "h",
      "w",
      "new_h",
      "new_w",
      "interp"
    ],
    "apply_image": [
      "self",
      "img",
      "interp"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "apply_segmentation": [
      "self",
      "segmentation"
    ],
    "inverse": [
      "self"
    ]
  },
  "GridSampleTransform": {
    "__init__": [
      "self",
      "grid",
      "interp"
    ],
    "apply_image": [
      "self",
      "img",
      "interp"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "apply_segmentation": [
      "self",
      "segmentation"
    ]
  },
  "CropTransform": {
    "__init__": [
      "self",
      "x0",
      "y0",
      "w",
      "h",
      "orig_w",
      "orig_h"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "apply_polygons": [
      "self",
      "polygons"
    ],
    "inverse": [
      "self"
    ]
  },
  "PadTransform": {
    "__init__": [
      "self",
      "x0",
      "y0",
      "x1",
      "y1",
      "orig_w",
      "orig_h",
      "pad_value",
      "seg_pad_value"
    ],
    "apply_image": [
      "self",
      "img"
    ],
    "apply_segmentation": [
      "self",
      "img"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "inverse": [
      "self"
    ]
  },
  "BlendTransform": {
    "__init__": [
      "self",
      "src_image",
      "src_weight",
      "dst_weight"
    ],
    "apply_image": [
      "self",
      "img",
      "interp"
    ],
    "apply_coords": [
      "self",
      "coords"
    ],
    "apply_segmentation": [
      "self",
      "segmentation"
    ],
    "inverse": [
      "self"
    ]
  }
}