{
  "__all__": [],
  "__path__": [],
  "T": [],
  "copy_with": [
    "obj"
  ],
  "will_extractall_into": [
    "tar",
    "path"
  ],
  "safe_extractall": [
    "tar",
    "path",
    "members"
  ],
  "SizedIterable": {
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "K": [],
  "V": [],
  "maybe_len": [
    "obj"
  ],
  "prod": [
    "xs"
  ],
  "Cyclic": {
    "__iter__": [
      "self"
    ],
    "stream": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "batcher": [
    "iterable",
    "batch_size"
  ],
  "Chain": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "_SubIndex": {},
  "Fuse": {
    "__post_init__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "_get_range": [
      "self",
      "start",
      "stop"
    ],
    "_location_for": [
      "self",
      "idx",
      "side"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__iter__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "split": [
    "xs",
    "indices"
  ],
  "split_into": [
    "xs",
    "n"
  ],
  "Cached": {
    "__post_init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "PickleCached": {
    "__iter__": [
      "self"
    ],
    "__del__": [
      "self"
    ]
  },
  "PseudoShuffled": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "IterableSlice": {
    "__init__": [
      "self",
      "iterable",
      "length"
    ],
    "__iter__": [
      "self"
    ]
  },
  "SizedIterableSlice": {
    "__len__": [
      "self"
    ]
  },
  "Map": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "StarMap": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "Filter": {
    "__iter__": [
      "self"
    ]
  },
  "RandomYield": {
    "__post_init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "rows_to_columns": [
    "rows",
    "wrap"
  ],
  "columns_to_rows": [
    "columns"
  ],
  "roundrobin": [],
  "partition": [
    "it",
    "fn"
  ],
  "select": [
    "keys",
    "source",
    "ignore_missing"
  ],
  "trim_nans": [
    "xs",
    "trim"
  ],
  "inverse": [
    "dct"
  ],
  "_no_default": [],
  "pluck_attr": [
    "seq",
    "name",
    "default"
  ],
  "power_set": [
    "iterable"
  ],
  "join_items": [
    "left",
    "right",
    "how",
    "default"
  ],
  "replace": [
    "values",
    "idx",
    "value"
  ],
  "chop": [
    "at",
    "take"
  ],
  "GluonTSException": {
    "guard": [
      "cls",
      "condition"
    ]
  },
  "GluonTSHyperparametersError": {
    "__str__": [
      "self"
    ]
  },
  "GluonTSDataError": {},
  "GluonTSUserError": {},
  "GluonTSDateBoundsError": {},
  "assert_gluonts": [
    "exception_class",
    "condition",
    "message"
  ],
  "assert_data_error": [
    "condition",
    "message"
  ],
  "U": [],
  "R": [],
  "P": [],
  "OptionalOrMaybe": [],
  "box": [
    "val"
  ],
  "unbox": [
    "val"
  ],
  "flatten": [
    "val"
  ],
  "expect": [
    "val",
    "msg"
  ],
  "do": [
    "val",
    "fn"
  ],
  "map": [
    "val",
    "fn"
  ],
  "map_or": [
    "val",
    "fn",
    "default"
  ],
  "map_or_else": [
    "val",
    "fn",
    "factory"
  ],
  "unwrap": [
    "val"
  ],
  "unwrap_or": [
    "val",
    "default"
  ],
  "unwrap_or_else": [
    "val",
    "factory"
  ],
  "and_": [
    "val",
    "other"
  ],
  "and_then": [
    "val",
    "fn"
  ],
  "or_": [
    "val",
    "default"
  ],
  "or_else": [
    "val",
    "factory"
  ],
  "contains": [
    "val",
    "other"
  ],
  "filter": [
    "val",
    "pred"
  ],
  "xor": [
    "val",
    "other"
  ],
  "iter": [
    "val"
  ],
  "zip": [
    "val",
    "other"
  ],
  "zip_with": [
    "val",
    "other",
    "fn"
  ],
  "Maybe": {
    "unbox": [
      "self"
    ],
    "is_some": [
      "self"
    ],
    "is_none": [
      "self"
    ],
    "expect": [
      "self",
      "msg"
    ],
    "do": [
      "self",
      "fn"
    ],
    "map": [
      "self",
      "fn"
    ],
    "map_or": [
      "self",
      "fn",
      "default"
    ],
    "map_or_else": [
      "self",
      "fn",
      "factory"
    ],
    "unwrap": [
      "self"
    ],
    "unwrap_or": [
      "self",
      "default"
    ],
    "unwrap_or_else": [
      "self",
      "fn"
    ],
    "and_": [
      "self",
      "other"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "and_then": [
      "self",
      "fn"
    ],
    "or_": [
      "self",
      "default"
    ],
    "__or__": [
      "self",
      "default"
    ],
    "or_else": [
      "self",
      "factory"
    ],
    "contains": [
      "self",
      "other"
    ],
    "filter": [
      "self",
      "pred"
    ],
    "xor": [
      "self",
      "other"
    ],
    "__xor__": [
      "self",
      "other"
    ],
    "iter": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "zip": [
      "self",
      "other"
    ],
    "zip_with": [
      "self",
      "other",
      "fn"
    ],
    "flatten": [
      "self"
    ]
  },
  "Some": {
    "__repr__": [
      "self"
    ],
    "unbox": [
      "self"
    ],
    "is_some": [
      "self"
    ],
    "unwrap": [
      "self"
    ],
    "expect": [
      "self",
      "msg"
    ],
    "do": [
      "self",
      "fn"
    ],
    "map": [
      "self",
      "fn"
    ],
    "map_or": [
      "self",
      "fn",
      "default"
    ],
    "map_or_else": [
      "self",
      "fn",
      "factory"
    ],
    "unwrap_or": [
      "self",
      "default"
    ],
    "unwrap_or_else": [
      "self",
      "fn"
    ],
    "and_": [
      "self",
      "other"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "and_then": [
      "self",
      "fn"
    ],
    "or_": [
      "self",
      "default"
    ],
    "__or__": [
      "self",
      "default"
    ],
    "or_else": [
      "self",
      "factory"
    ],
    "contains": [
      "self",
      "other"
    ],
    "filter": [
      "self",
      "pred"
    ],
    "xor": [
      "self",
      "other"
    ],
    "iter": [
      "self"
    ],
    "zip": [
      "self",
      "other"
    ],
    "zip_with": [
      "self",
      "other",
      "fn"
    ],
    "flatten": [
      "self"
    ]
  },
  "_Nothing": {
    "__repr__": [
      "self"
    ],
    "unbox": [
      "self"
    ],
    "is_some": [
      "self"
    ],
    "unwrap": [
      "self"
    ],
    "expect": [
      "self",
      "msg"
    ],
    "do": [
      "self",
      "fn"
    ],
    "map": [
      "self",
      "fn"
    ],
    "map_or": [
      "self",
      "fn",
      "default"
    ],
    "map_or_else": [
      "self",
      "fn",
      "factory"
    ],
    "unwrap_or": [
      "self",
      "default"
    ],
    "unwrap_or_else": [
      "self",
      "fn"
    ],
    "and_": [
      "self",
      "other"
    ],
    "and_then": [
      "self",
      "fn"
    ],
    "or_": [
      "self",
      "default"
    ],
    "or_else": [
      "self",
      "factory"
    ],
    "contains": [
      "self",
      "other"
    ],
    "filter": [
      "self",
      "pred"
    ],
    "xor": [
      "self",
      "other"
    ],
    "iter": [
      "self"
    ],
    "zip": [
      "self",
      "other"
    ],
    "zip_with": [
      "self",
      "other",
      "fn"
    ],
    "flatten": [
      "self"
    ]
  },
  "tqdm": [
    "it"
  ],
  "_orjson": [],
  "_ujson": [],
  "_json": [],
  "Environment": {
    "get_data_path": [
      "self",
      "create"
    ]
  },
  "env": [],
  "PYDANTIC_V2": [],
  "ServerFacade": {
    "__init__": [
      "self",
      "base_address"
    ],
    "url": [
      "self",
      "path"
    ],
    "ping": [
      "self"
    ],
    "execution_parameters": [
      "self"
    ],
    "invocations": [
      "self",
      "data_entries",
      "configuration"
    ],
    "batch_invocations": [
      "self",
      "data_entries"
    ]
  },
  "free_port": [],
  "Server": {
    "run": [
      "self"
    ]
  },
  "temporary_server": [
    "env",
    "forecaster_type",
    "settings"
  ],
  "temporary_train_env": [
    "hyperparameters",
    "dataset_name"
  ],
  "temporary_serve_env": [
    "predictor"
  ],
  "stack": [
    "data"
  ],
  "batchify": [
    "data"
  ],
  "TemporaryDirectory": [],
  "chunks": [
    "l",
    "n"
  ],
  "empirical_cdf": [
    "samples",
    "num_bins"
  ],
  "assert_recursively_equal": [
    "obj_a",
    "obj_b",
    "equal_nan"
  ],
  "assert_recursively_close": [
    "obj_a",
    "obj_b",
    "rtol",
    "atol",
    "equal_nan"
  ],
  "_assert_recursively_close": [
    "obj_a",
    "obj_b",
    "location"
  ],
  "make_dummy_datasets_with_features": [
    "num_ts",
    "start",
    "freq",
    "min_length",
    "max_length",
    "prediction_length",
    "cardinality",
    "num_feat_dynamic_real",
    "num_past_feat_dynamic_real"
  ],
  "get_dataset": [],
  "BasicFeatureInfo": {},
  "CategoricalFeatureInfo": {},
  "MetaData": {},
  "SourceContext": {},
  "TrainDatasets": {
    "save": [
      "self",
      "path_str",
      "writer",
      "overwrite"
    ]
  },
  "infer_file_type": [
    "path"
  ],
  "_rglob": [
    "path",
    "pattern",
    "levels"
  ],
  "FileDataset": [
    "path",
    "freq",
    "one_dim_target",
    "cache",
    "use_timestamp",
    "loader_class",
    "pattern",
    "levels",
    "translate",
    "ignore_hidden"
  ],
  "_FileDataset": [
    "dataset",
    "freq",
    "one_dim_target",
    "cache",
    "use_timestamp",
    "translate"
  ],
  "ListDataset": [
    "data_iter",
    "freq",
    "one_dim_target",
    "use_timestamp",
    "translate"
  ],
  "_as_period": [
    "val",
    "freq"
  ],
  "ProcessStartField": {
    "__call__": [
      "self",
      "data"
    ]
  },
  "ProcessTimeSeriesField": {
    "__init__": [
      "self",
      "name",
      "is_required",
      "is_static",
      "is_cat"
    ],
    "__call__": [
      "self",
      "data"
    ]
  },
  "ProcessDataEntry": {
    "__init__": [
      "self",
      "freq",
      "one_dim_target",
      "use_timestamp"
    ],
    "__call__": [
      "self",
      "data"
    ]
  },
  "load_datasets": [
    "metadata",
    "train",
    "test",
    "one_dim_target",
    "cache"
  ],
  "load": [
    "file_obj"
  ],
  "dump": [
    "objects",
    "file_obj"
  ],
  "encode_json": [
    "arg"
  ],
  "_encode_json_dict": [
    "arg"
  ],
  "_encode_json_list": [
    "arg"
  ],
  "_encode_json_array": [
    "arg"
  ],
  "_encode_json_period": [
    "arg"
  ],
  "JsonLinesFile": {
    "SUFFIXES": [],
    "__post_init__": [
      "self"
    ],
    "open": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "_line_starts": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "JsonLinesWriter": {
    "write_to_file": [
      "self",
      "dataset",
      "path"
    ],
    "write_to_folder": [
      "self",
      "dataset",
      "folder",
      "name"
    ]
  },
  "logger": [],
  "DataLoader": [],
  "Batch": {
    "__call__": [
      "self",
      "data",
      "is_train"
    ]
  },
  "Stack": {
    "__call__": [
      "self",
      "data",
      "is_train"
    ]
  },
  "as_stacked_batches": [
    "dataset"
  ],
  "TrainDataLoader": [
    "dataset"
  ],
  "ValidationDataLoader": [
    "dataset"
  ],
  "InferenceDataLoader": [
    "dataset"
  ],
  "FieldName": {
    "ITEM_ID": [],
    "INFO": [],
    "START": [],
    "TARGET": [],
    "FEAT_STATIC_CAT": [],
    "FEAT_STATIC_REAL": [],
    "FEAT_DYNAMIC_CAT": [],
    "FEAT_DYNAMIC_REAL": [],
    "PAST_FEAT_DYNAMIC_CAT": [],
    "PAST_FEAT_DYNAMIC_REAL": [],
    "FEAT_DYNAMIC_REAL_LEGACY": [],
    "FEAT_DYNAMIC": [],
    "PAST_FEAT_DYNAMIC": [],
    "FEAT_TIME": [],
    "FEAT_CONST": [],
    "FEAT_AGE": [],
    "OBSERVED_VALUES": [],
    "IS_PAD": [],
    "FORECAST_START": [],
    "TARGET_DIM_INDICATOR": []
  },
  "DataEntry": [],
  "DataBatch": [],
  "Dataset": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "DatasetCollection": {
    "iter_sequential": [
      "self"
    ],
    "iter_interleaved": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "DatasetWriter": {
    "write_to_file": [
      "self",
      "dataset",
      "path"
    ],
    "write_to_folder": [
      "self",
      "dataset",
      "folder",
      "name"
    ]
  },
  "forecast_start": [
    "entry",
    "time_axis"
  ],
  "period_index": [
    "entry",
    "freq"
  ],
  "to_pandas": [
    "entry",
    "freq"
  ],
  "PandasDataset": {
    "__post_init__": [
      "self",
      "dataframes",
      "static_features"
    ],
    "num_feat_static_cat": [
      "self"
    ],
    "num_feat_static_real": [
      "self"
    ],
    "num_feat_dynamic_real": [
      "self"
    ],
    "num_past_feat_dynamic_real": [
      "self"
    ],
    "static_cardinalities": [
      "self"
    ],
    "_pair_to_dataentry": [
      "self",
      "item_id",
      "df"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "from_long_dataframe": [
      "cls",
      "dataframe",
      "item_id",
      "timestamp",
      "static_feature_columns",
      "static_features"
    ]
  },
  "pair_with_item_id": [
    "obj"
  ],
  "infer_freq": [
    "index"
  ],
  "is_uniform": [
    "index"
  ],
  "periods_between": [
    "start",
    "end"
  ],
  "to_positive_slice": [
    "slice_",
    "length"
  ],
  "to_integer_slice": [
    "slice_",
    "start"
  ],
  "slice_data_entry": [
    "entry",
    "slice_",
    "prediction_length"
  ],
  "AbstractBaseSplitter": {
    "training_entry": [
      "self",
      "entry"
    ],
    "test_pair": [
      "self",
      "entry",
      "prediction_length",
      "offset"
    ],
    "split": [
      "self",
      "dataset"
    ],
    "generate_training_entries": [
      "self",
      "dataset"
    ],
    "generate_test_pairs": [
      "self",
      "dataset",
      "prediction_length",
      "windows",
      "distance",
      "max_history"
    ]
  },
  "OffsetSplitter": {
    "training_entry": [
      "self",
      "entry"
    ],
    "test_pair": [
      "self",
      "entry",
      "prediction_length",
      "offset"
    ]
  },
  "DateSplitter": {
    "training_entry": [
      "self",
      "entry"
    ],
    "test_pair": [
      "self",
      "entry",
      "prediction_length",
      "offset"
    ]
  },
  "TestData": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "input": [
      "self"
    ],
    "label": [
      "self"
    ]
  },
  "InputDataset": {
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "LabelDataset": {
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "TestTemplate": {
    "generate_instances": [
      "self",
      "prediction_length",
      "windows",
      "distance",
      "max_history"
    ]
  },
  "TrainingDataset": {
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "MultivariateGrouper": {
    "__init__": [
      "self",
      "max_target_dim",
      "num_test_dates",
      "train_fill_rule",
      "test_fill_rule"
    ],
    "__call__": [
      "self",
      "dataset"
    ],
    "_preprocess": [
      "self",
      "dataset"
    ],
    "_group_all": [
      "self",
      "dataset"
    ],
    "_prepare_train_data": [
      "self",
      "dataset"
    ],
    "_prepare_test_data": [
      "self",
      "dataset"
    ],
    "_align_data_entry": [
      "self",
      "data"
    ],
    "_left_pad_data": [
      "self",
      "data"
    ],
    "_transform_target": [
      "funcs",
      "dataset"
    ],
    "_restrict_max_dimensionality": [
      "self",
      "data"
    ],
    "to_ts": [
      "data"
    ]
  },
  "HierarchicalTimeSeries": {
    "__init__": [
      "self",
      "ts_at_bottom_level",
      "S"
    ],
    "freq": [
      "self"
    ],
    "ts_at_all_levels": [
      "self"
    ],
    "S": [
      "self"
    ],
    "num_ts": [
      "self"
    ],
    "num_bottom_ts": [
      "self"
    ],
    "aggregate_ts": [
      "ts_at_bottom_level",
      "S"
    ],
    "to_dataset": [
      "self",
      "feat_dynamic_real"
    ]
  },
  "ScaleHistogram": {
    "__init__": [
      "self",
      "base",
      "bin_counts",
      "empty_target_count"
    ],
    "bucket_index": [
      "self",
      "target_values"
    ],
    "add": [
      "self",
      "target_values"
    ],
    "count": [
      "self",
      "target"
    ],
    "__len__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "DatasetStatistics": {
    "__eq__": [
      "self",
      "other"
    ]
  },
  "calculate_dataset_statistics": [
    "ts_dataset"
  ],
  "generate_uber_dataset": [
    "dataset_path",
    "uber_freq",
    "prediction_length",
    "dataset_writer"
  ],
  "metadata": [
    "cardinality",
    "freq",
    "prediction_length"
  ],
  "request_retrieve_hook": [
    "tqdm"
  ],
  "GPCopulaDataset": {},
  "root": [],
  "datasets_info": [],
  "generate_gp_copula_dataset": [
    "dataset_path",
    "dataset_name",
    "dataset_writer",
    "prediction_length"
  ],
  "download_dataset": [
    "dataset_path",
    "ds_info"
  ],
  "get_data": [
    "dataset_path",
    "ds_info"
  ],
  "clean_up_dataset": [
    "dataset_path",
    "ds_info"
  ],
  "generate_artificial_dataset": [
    "dataset_path",
    "dataset",
    "dataset_writer",
    "prediction_length"
  ],
  "generate_m4_dataset": [
    "dataset_path",
    "m4_freq",
    "pandas_freq",
    "prediction_length",
    "dataset_writer"
  ],
  "generate_m5_dataset": [
    "dataset_path",
    "pandas_freq",
    "prediction_length",
    "m5_file_path",
    "dataset_writer"
  ],
  "datasets": [],
  "convert_data": [
    "data",
    "train_offset",
    "default_start_timestamp"
  ],
  "generate_forecasting_dataset": [
    "dataset_path",
    "dataset_name",
    "dataset_writer",
    "prediction_length"
  ],
  "default_prediction_length_from_frequency": [
    "freq"
  ],
  "URL": [],
  "generate_airpassengers_dataset": [
    "dataset_path",
    "dataset_writer"
  ],
  "check_dataset": [
    "dataset_path",
    "length",
    "sheet_name"
  ],
  "M3Setting": {},
  "generate_m3_dataset": [
    "dataset_path",
    "m3_freq",
    "dataset_writer",
    "prediction_length"
  ],
  "load_from_pandas": [
    "df",
    "time_index",
    "agg_freq"
  ],
  "LstnetDataset": {},
  "generate_lstnet_dataset": [
    "dataset_path",
    "dataset_name",
    "dataset_writer",
    "prediction_length"
  ],
  "get_download_path": [],
  "dataset_recipes": [],
  "dataset_names": [],
  "default_dataset_path": [],
  "default_dataset_writer": [],
  "materialize_dataset": [
    "dataset_name",
    "path",
    "regenerate",
    "dataset_writer",
    "prediction_length"
  ],
  "NUM_REGIONS": [],
  "generate_ett_small_dataset": [
    "dataset_path",
    "dataset_writer",
    "base_file_name",
    "freq",
    "prediction_length"
  ],
  "parse_bool": [],
  "parse_attribute": [
    "ty",
    "value"
  ],
  "frequency_converter": [
    "freq"
  ],
  "convert_base": [
    "text"
  ],
  "convert_multiple": [
    "text"
  ],
  "TSFReader": {
    "__init__": [
      "self",
      "path",
      "target_name"
    ],
    "read": [
      "self"
    ],
    "_read_header": [
      "self",
      "lines"
    ],
    "_read_data": [
      "self",
      "line"
    ],
    "_data_target": [
      "self",
      "s"
    ],
    "_tag": [
      "self",
      "line"
    ],
    "_tag_attribute": [
      "self",
      "name",
      "ty"
    ],
    "_tag_frequency": [
      "self",
      "frequency"
    ],
    "_tag_horizon": [
      "self",
      "horizon"
    ],
    "_tag_missing": [
      "self",
      "missing"
    ],
    "_tag_equallength": [
      "self",
      "equallength"
    ],
    "_tag_data": [
      "self"
    ]
  },
  "generate_ercot_dataset": [
    "dataset_path",
    "dataset_writer"
  ],
  "DatasetInfo": {},
  "ArtificialDataset": {
    "__init__": [
      "self",
      "freq"
    ],
    "metadata": [
      "self"
    ],
    "train": [
      "self"
    ],
    "test": [
      "self"
    ],
    "generate": [
      "self"
    ]
  },
  "ConstantDataset": {
    "__init__": [
      "self",
      "num_timeseries",
      "num_steps",
      "freq",
      "start",
      "is_nan",
      "is_random_constant",
      "is_different_scales",
      "is_piecewise",
      "is_noise",
      "is_long",
      "is_short",
      "is_trend",
      "num_missing_middle",
      "is_promotions",
      "holidays"
    ],
    "metadata": [
      "self"
    ],
    "determine_constant": [
      "self",
      "index",
      "constant",
      "seed"
    ],
    "compute_data_from_recipe": [
      "self",
      "num_steps",
      "constant",
      "one_to_zero",
      "zero_to_one",
      "scale_features"
    ],
    "piecewise_constant": [
      "self",
      "index",
      "num_steps"
    ],
    "get_num_steps": [
      "self",
      "index",
      "num_steps_max",
      "long_freq",
      "num_steps_min",
      "short_freq"
    ],
    "insert_nans_and_zeros": [
      "ts_len"
    ],
    "insert_missing_vals_middle": [
      "self",
      "ts_len",
      "constant"
    ],
    "generate_ts": [
      "self",
      "num_ts_steps",
      "is_train"
    ],
    "train": [
      "self"
    ],
    "test": [
      "self"
    ]
  },
  "ComplexSeasonalTimeSeries": {
    "__init__": [
      "self",
      "num_series",
      "prediction_length",
      "freq_str",
      "length_low",
      "length_high",
      "min_val",
      "max_val",
      "is_integer",
      "proportion_missing_values",
      "is_noise",
      "is_scale",
      "percentage_unique_timestamps",
      "is_out_of_bounds_date",
      "seasonality",
      "clip_values"
    ],
    "metadata": [
      "self"
    ],
    "_get_period": [
      "self"
    ],
    "_get_start": [
      "self",
      "index",
      "my_random"
    ],
    "_special_time_point_indicator": [
      "self",
      "index"
    ],
    "train": [
      "self"
    ],
    "test": [
      "self"
    ],
    "make_timeseries": [
      "self",
      "seed"
    ]
  },
  "RecipeDataset": {
    "__init__": [
      "self",
      "recipe",
      "metadata",
      "max_train_length",
      "prediction_length",
      "num_timeseries",
      "trim_length_fun",
      "data_start"
    ],
    "metadata": [
      "self"
    ],
    "train": [
      "self"
    ],
    "test": [
      "self"
    ],
    "dataset_info": [
      "self",
      "train_ds",
      "test_ds"
    ],
    "trim_ts_item_end": [
      "x",
      "length"
    ],
    "trim_ts_item_front": [
      "x",
      "length"
    ],
    "generate": [
      "self"
    ]
  },
  "default_synthetic": [],
  "constant_dataset": [],
  "ar_p": [
    "phi",
    "sigma",
    "length",
    "xhist",
    "c",
    "noise"
  ],
  "ValueOrCallable": [],
  "Recipe": [],
  "Env": [],
  "resolve": [
    "val_or_callable",
    "context"
  ],
  "generate": [
    "length",
    "recipe",
    "start",
    "global_state",
    "seed",
    "item_id_prefix"
  ],
  "evaluate": [
    "recipe",
    "length"
  ],
  "make_func": [
    "length",
    "recipe",
    "global_state"
  ],
  "take_as_list": [
    "iterator",
    "num"
  ],
  "Debug": {
    "__init__": [
      "self",
      "print_global"
    ],
    "__call__": [
      "self",
      "x",
      "global_state"
    ]
  },
  "Lifted": {
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ],
    "__rsub__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__truediv__": [
      "self",
      "other"
    ],
    "__rtruediv__": [
      "self",
      "other"
    ],
    "__pow__": [
      "self",
      "other"
    ],
    "__rpow__": [
      "self",
      "other"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__rand__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "__xor__": [
      "self",
      "other"
    ],
    "__rxor__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__iter__": [
      "self"
    ],
    "__call__": [
      "self",
      "x",
      "length",
      "field_name",
      "global_state"
    ]
  },
  "expand_shape": [
    "s",
    "length"
  ],
  "NumpyFunc": {
    "__init__": [
      "self",
      "func",
      "func_args",
      "func_kwargs"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "lifted_numpy": [],
  "_NUMPY_FUNC_NAMES": [],
  "Length": {
    "__init__": [
      "self",
      "l"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "lift": [
    "input"
  ],
  "_LiftedUnpacked": {
    "__init__": [
      "self",
      "base",
      "i"
    ],
    "__call__": [
      "self"
    ]
  },
  "_LiftedBinaryOp": {
    "__init__": [
      "self",
      "left",
      "right",
      "op"
    ],
    "__call__": [
      "self"
    ]
  },
  "RandomGaussian": {
    "__init__": [
      "self",
      "stddev",
      "shape"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "BinaryHolidays": {
    "__init__": [
      "self",
      "dates",
      "holidays"
    ],
    "__call__": [
      "self"
    ]
  },
  "RandomBinary": {
    "__init__": [
      "self",
      "prob"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "RandomSymmetricDirichlet": {
    "__init__": [
      "self",
      "alpha",
      "shape"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "BinaryMarkovChain": {
    "__init__": [
      "self",
      "one_to_zero",
      "zero_to_one"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Constant": {
    "__init__": [
      "self",
      "constant"
    ],
    "__call__": [
      "self"
    ]
  },
  "ConstantVec": {
    "__init__": [
      "self",
      "constant"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "NormalizeMax": {
    "__init__": [
      "self",
      "input"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "OnesLike": {
    "__init__": [
      "self",
      "other"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "LinearTrend": {
    "__init__": [
      "self",
      "slope"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "RandomCat": {
    "__init__": [
      "self",
      "cardinalities",
      "prob_fun"
    ],
    "__call__": [
      "self",
      "x",
      "field_name",
      "global_state"
    ]
  },
  "Lag": {
    "__init__": [
      "self",
      "input",
      "lag",
      "pad_const"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "ForEachCat": {
    "__init__": [
      "self",
      "fun",
      "cat_field",
      "cat_idx"
    ],
    "__call__": [
      "self",
      "x",
      "length",
      "field_name",
      "global_state"
    ]
  },
  "Eval": {
    "__init__": [
      "self",
      "expr"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "SmoothSeasonality": {
    "__init__": [
      "self",
      "period",
      "phase"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Add": {
    "__init__": [
      "self",
      "inputs"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Mul": {
    "__init__": [
      "self",
      "inputs"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "NanWhere": {
    "__init__": [
      "self",
      "source",
      "nan_indicator"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "OneMinus": {
    "__init__": [
      "self",
      "source"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Concatenate": {
    "__init__": [
      "self",
      "inputs",
      "axis"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "StackPrefix": {
    "__init__": [
      "self",
      "prefix"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "_LEGACY_WARNING_WAS_SHOWN": [],
  "Ref": {
    "__init__": [
      "self",
      "field_name"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "RandomUniform": {
    "__init__": [
      "self",
      "low",
      "high",
      "shape"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "RandomInteger": {
    "__init__": [
      "self",
      "low",
      "high",
      "shape"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "RandomChangepoints": {
    "__init__": [
      "self",
      "max_num_changepoints"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Repeated": {
    "__init__": [
      "self",
      "pattern"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Convolve": {
    "__init__": [
      "self",
      "input",
      "filter"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "Dilated": {
    "__init__": [
      "self",
      "source",
      "dilation"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "ARp": {
    "__init__": [
      "self",
      "phi",
      "sigma",
      "xhist",
      "c",
      "noise"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "normalized_ar1": [
    "tau",
    "x0",
    "norm",
    "sigma"
  ],
  "Choose": {
    "__init__": [
      "self",
      "options",
      "selector"
    ],
    "__call__": [
      "self",
      "x",
      "length"
    ]
  },
  "EvalRecipe": {
    "__init__": [
      "self",
      "recipe",
      "op"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "ArrowDecoder": {
    "from_schema": [
      "cls",
      "schema"
    ],
    "decode": [
      "self",
      "batch",
      "row_number"
    ],
    "decode_batch": [
      "self",
      "batch"
    ]
  },
  "File": {
    "SUFFIXES": [],
    "infer": [
      "path"
    ],
    "metadata": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "ArrowFile": {
    "metadata": [
      "self"
    ],
    "batch_offsets": [
      "self"
    ],
    "__post_init__": [
      "self"
    ],
    "location_for": [
      "self",
      "idx"
    ],
    "schema": [
      "self"
    ],
    "iter_batches": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "ArrowStreamFile": {
    "metadata": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "ParquetFile": {
    "__post_init__": [
      "self"
    ],
    "location_for": [
      "self",
      "idx"
    ],
    "metadata": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__len__": [
      "self"
    ]
  },
  "ArrowEncoder": {
    "infer": [
      "cls",
      "sample",
      "flatten_arrays"
    ],
    "encode": [
      "self",
      "entry"
    ]
  },
  "into_arrow_batches": [
    "dataset",
    "batch_size",
    "flatten_arrays"
  ],
  "_encode_py_to_arrow": [
    "val"
  ],
  "_encode_py_pd_period": [
    "val"
  ],
  "write_dataset": [
    "Writer",
    "dataset",
    "path",
    "metadata",
    "batch_size",
    "flatten_arrays"
  ],
  "Compression": [],
  "ArrowWriter": {
    "write_to_file": [
      "self",
      "dataset",
      "path"
    ],
    "write_to_folder": [
      "self",
      "dataset",
      "folder",
      "name"
    ]
  },
  "ParquetWriter": {
    "write_to_file": [
      "self",
      "dataset",
      "path"
    ],
    "write_to_folder": [
      "self",
      "dataset",
      "folder",
      "name"
    ]
  },
  "cli": [],
  "write": [
    "dataset",
    "out",
    "freq",
    "type_",
    "stream",
    "compression"
  ],
  "Op": {
    "__call__": [
      "self",
      "item"
    ],
    "fields": [
      "self"
    ]
  },
  "Get": {
    "__call__": [
      "self",
      "item"
    ],
    "fields": [
      "self"
    ]
  },
  "Method": {
    "__call__": [
      "self",
      "item"
    ],
    "fields": [
      "self"
    ]
  },
  "GetAttr": {
    "__call__": [
      "self",
      "item"
    ],
    "fields": [
      "self"
    ]
  },
  "GetItem": {
    "__call__": [
      "self",
      "item"
    ],
    "fields": [
      "self"
    ]
  },
  "one_of": [
    "s"
  ],
  "Token": {},
  "TokenStream": {
    "from_str": [
      "cls",
      "s"
    ],
    "pop": [
      "self",
      "ty",
      "val"
    ],
    "pop_if": [
      "self",
      "ty",
      "val"
    ],
    "peek": [
      "self",
      "ty",
      "val"
    ],
    "__len__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "check_type": [
    "token",
    "ty",
    "val"
  ],
  "Parser": {
    "parse_number": [
      "self"
    ],
    "parse_args": [
      "self"
    ],
    "parse_getitem": [
      "self",
      "obj"
    ],
    "parse_dot": [
      "self",
      "obj"
    ],
    "parse_invoke": [
      "self",
      "obj"
    ],
    "parse_expr": [
      "self"
    ]
  },
  "parse": [
    "x"
  ],
  "Translator": {
    "parse": [
      "fields",
      "drop"
    ],
    "__call__": [
      "self",
      "item"
    ],
    "get_fields": [
      "self"
    ]
  },
  "ModelConfig": {
    "__post_init__": [
      "self"
    ]
  },
  "StatsForecastPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "quantile_levels"
    ],
    "predict_item": [
      "self",
      "entry"
    ]
  },
  "ADIDAPredictor": {
    "ModelType": []
  },
  "AutoARIMAPredictor": {
    "ModelType": []
  },
  "AutoCESPredictor": {
    "ModelType": []
  },
  "AutoETSPredictor": {
    "ModelType": []
  },
  "AutoThetaPredictor": {
    "ModelType": []
  },
  "CrostonClassicPredictor": {
    "ModelType": []
  },
  "CrostonOptimizedPredictor": {
    "ModelType": []
  },
  "CrostonSBAPredictor": {
    "ModelType": []
  },
  "IMAPAPredictor": {
    "ModelType": []
  },
  "DynamicOptimizedThetaPredictor": {
    "ModelType": []
  },
  "DynamicThetaPredictor": {
    "ModelType": []
  },
  "HistoricAveragePredictor": {
    "ModelType": []
  },
  "HoltPredictor": {
    "ModelType": []
  },
  "HoltWintersPredictor": {
    "ModelType": []
  },
  "MSTLPredictor": {
    "ModelType": []
  },
  "NaivePredictor": {
    "ModelType": []
  },
  "OptimizedThetaPredictor": {
    "ModelType": []
  },
  "RandomWalkWithDriftPredictor": {
    "ModelType": []
  },
  "SeasonalExponentialSmoothingPredictor": {
    "ModelType": []
  },
  "SeasonalExponentialSmoothingOptimizedPredictor": {
    "ModelType": []
  },
  "SeasonalNaivePredictor": {
    "ModelType": []
  },
  "SeasonalWindowAveragePredictor": {
    "ModelType": []
  },
  "SimpleExponentialSmoothingPredictor": {
    "ModelType": []
  },
  "SimpleExponentialSmoothingOptimizedPredictor": {
    "ModelType": []
  },
  "TSBPredictor": {
    "ModelType": []
  },
  "ThetaPredictor": {
    "ModelType": []
  },
  "WindowAveragePredictor": {
    "ModelType": []
  },
  "models_without_fitted_capability": [],
  "get_formatted_S": [
    "_S",
    "ts_names"
  ],
  "format_data_entry": [
    "entry",
    "S"
  ],
  "unpivot": [
    "df"
  ],
  "format_reconciled_forecasts": [
    "df",
    "prediction_length",
    "fcst_col_name",
    "S"
  ],
  "prune_fcst_df": [
    "df",
    "base_reconciliation_model_name"
  ],
  "HierarchicalForecastPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "base_model",
      "reconciler",
      "S",
      "tags",
      "ts_names",
      "intervals_method",
      "quantile_levels",
      "n_jobs",
      "model_params",
      "reconciler_params"
    ],
    "predict_item": [
      "self",
      "entry"
    ]
  },
  "UNIVARIATE_QUANTILE_FORECAST_METHODS": [],
  "UNIVARIATE_POINT_FORECAST_METHODS": [],
  "SUPPORTED_UNIVARIATE_METHODS": [],
  "RForecastPredictor": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "method_name",
      "period",
      "trunc_length",
      "save_info",
      "params"
    ],
    "_get_r_forecast": [
      "self",
      "data"
    ],
    "_preprocess_data": [
      "self",
      "data"
    ],
    "_warning_message": [
      "self"
    ],
    "_forecast_dict_to_obj": [
      "self",
      "forecast_dict",
      "forecast_start_date",
      "item_id",
      "info"
    ]
  },
  "unlist": [
    "l"
  ],
  "interval_to_quantile_level": [
    "interval_level",
    "side"
  ],
  "quantile_to_interval_level": [
    "quantile_level"
  ],
  "proc": [],
  "R_IS_INSTALLED": [],
  "USAGE_MESSAGE": [],
  "RBasePredictor": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "period",
      "trunc_length",
      "save_info",
      "r_file_prefix"
    ],
    "_get_r_forecast": [
      "self",
      "data"
    ],
    "_run_r_forecast": [
      "self",
      "data"
    ],
    "_preprocess_data": [
      "self",
      "data"
    ],
    "_warning_message": [
      "self"
    ],
    "_forecast_dict_to_obj": [
      "self",
      "forecast_dict",
      "forecast_start_date",
      "item_id",
      "info"
    ],
    "predict": [
      "self",
      "dataset"
    ]
  },
  "HIERARCHICAL_POINT_FORECAST_METHODS": [],
  "SUPPORTED_HIERARCHICAL_METHODS": [],
  "RHierarchicalForecastPredictor": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "is_hts",
      "target_dim",
      "num_bottom_ts",
      "nodes",
      "method_name",
      "fmethod",
      "period",
      "trunc_length",
      "save_info",
      "nonnegative",
      "level",
      "algorithm",
      "covariance",
      "numcores",
      "params"
    ],
    "_get_r_forecast": [
      "self",
      "data"
    ],
    "_preprocess_data": [
      "self",
      "data"
    ],
    "_forecast_dict_to_obj": [
      "self",
      "forecast_dict",
      "forecast_start_date",
      "item_id",
      "info"
    ]
  },
  "PROPHET_IS_INSTALLED": [],
  "feat_name": [
    "i"
  ],
  "ProphetDataEntry": {
    "prophet_training_data": [
      "self"
    ],
    "forecast_start": [
      "self"
    ],
    "freq": [
      "self"
    ]
  },
  "ProphetPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "prophet_params",
      "init_model"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "_run_prophet": [
      "self",
      "data",
      "params"
    ],
    "_make_prophet_data_entry": [
      "self",
      "entry"
    ]
  },
  "ThirdPartyEstimator": {
    "__init__": [
      "self",
      "predictor_cls"
    ],
    "train": [
      "self",
      "training_data",
      "validation_dataset"
    ]
  },
  "TreeEstimator": {
    "__init__": [
      "self"
    ]
  },
  "FeatureImportanceResult": {
    "check_shape": [
      "cls",
      "values"
    ],
    "mean": [
      "self",
      "axis"
    ]
  },
  "ExplanationResult": {},
  "QRF": {
    "__init__": [
      "self",
      "params"
    ],
    "fit": [
      "self",
      "x_train",
      "y_train"
    ],
    "predict": [
      "self",
      "x_test",
      "quantile"
    ]
  },
  "QuantileReg": {
    "__init__": [
      "self",
      "quantiles",
      "params"
    ],
    "fit": [
      "self",
      "x_train",
      "y_train"
    ],
    "predict": [
      "self",
      "x_test",
      "quantile"
    ]
  },
  "QRX": {
    "__init__": [
      "self",
      "model",
      "xgboost_params",
      "min_bin_size"
    ],
    "_create_xgboost_model": [
      "model_params"
    ],
    "__eq__": [
      "self",
      "that"
    ],
    "fit": [
      "self",
      "x_train",
      "y_train",
      "max_sample_size",
      "seed",
      "x_train_is_dataframe",
      "model_is_already_trained"
    ],
    "clump": [
      "dic",
      "min_num",
      "sorted_keys"
    ],
    "preprocess_df": [
      "self",
      "df",
      "min_bin_size"
    ],
    "get_closest_pt": [
      "cls",
      "sorted_list",
      "num"
    ],
    "_get_and_cache_quantile_computation": [
      "self",
      "feature_vector_in_train",
      "quantile"
    ],
    "predict": [
      "self",
      "x_test",
      "quantile"
    ],
    "estimate_dist": [
      "self",
      "x_test"
    ]
  },
  "LSF": [],
  "CardinalityLabel": {
    "auto": [],
    "ignore": []
  },
  "Cardinality": [],
  "PreprocessGeneric": {
    "__init__": [
      "self",
      "context_window_size",
      "forecast_horizon",
      "stratify_targets",
      "n_ignore_last",
      "max_n_datapts",
      "seed",
      "num_samples"
    ],
    "make_features": [
      "self",
      "time_series",
      "starting_index"
    ],
    "preprocess_from_single_ts": [
      "self",
      "time_series"
    ],
    "infer_feature_characteristics": [
      "self",
      "ts"
    ],
    "preprocess_from_list": [
      "self",
      "ts_list",
      "change_internal_variables"
    ],
    "get_num_samples": [
      "self",
      "ts_list"
    ],
    "infer_cardinalities": [
      "self",
      "ts_list"
    ]
  },
  "PreprocessOnlyLagFeatures": {
    "__init__": [
      "self",
      "context_window_size",
      "forecast_horizon",
      "stratify_targets",
      "n_ignore_last",
      "num_samples",
      "use_feat_static_real",
      "use_past_feat_dynamic_real",
      "use_feat_dynamic_real",
      "use_feat_dynamic_cat",
      "cardinality",
      "one_hot_encode",
      "subtract_mean",
      "count_nans"
    ],
    "_pre_transform": [
      "cls",
      "time_series_window",
      "subtract_mean",
      "count_nans"
    ],
    "encode_one_hot": [
      "self",
      "feat",
      "cardinality"
    ],
    "encode_one_hot_all": [
      "self",
      "feat_list"
    ],
    "infer_cardinalities": [
      "self",
      "time_series"
    ],
    "infer_feature_characteristics": [
      "self",
      "ts"
    ],
    "make_features": [
      "self",
      "time_series",
      "starting_index"
    ]
  },
  "RotbaumForecast": {
    "__init__": [
      "self",
      "models",
      "featurized_data",
      "start_date",
      "prediction_length",
      "item_id"
    ],
    "quantile": [
      "self",
      "q"
    ],
    "estimate_dists": [
      "self"
    ]
  },
  "TreePredictor": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "n_ignore_last",
      "lead_time",
      "max_n_datapts",
      "min_bin_size",
      "context_length",
      "use_feat_static_real",
      "use_past_feat_dynamic_real",
      "use_feat_dynamic_real",
      "use_feat_dynamic_cat",
      "cardinality",
      "one_hot_encode",
      "model_params",
      "max_workers",
      "method",
      "quantiles",
      "subtract_mean",
      "count_nans",
      "model",
      "seed"
    ],
    "train": [
      "self",
      "training_data",
      "train_QRX_only_using_timestep"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path"
    ],
    "explain": [
      "self",
      "importance_type",
      "percentage"
    ]
  },
  "seasonality_test": [
    "past_ts_data",
    "season_length"
  ],
  "naive_2": [
    "past_ts_data",
    "prediction_length",
    "season_length"
  ],
  "Naive2Predictor": {
    "__init__": [
      "self",
      "prediction_length",
      "season_length"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "Dark": {
    "background_color": [],
    "styles": []
  },
  "version": [],
  "COPPER": [],
  "RED": [],
  "SALMON": [],
  "ORANGE": [],
  "YELLOW": [],
  "GREEN": [],
  "BLUE": [],
  "__version__": [],
  "MetricCollection": {
    "update": [
      "self",
      "data"
    ],
    "update_all": [
      "self",
      "stream"
    ],
    "get": [
      "self"
    ]
  },
  "Metric": {
    "update": [
      "self",
      "data"
    ],
    "update_all": [
      "self",
      "stream"
    ],
    "get": [
      "self"
    ]
  },
  "DirectMetric": {
    "update": [
      "self",
      "data"
    ],
    "get": [
      "self"
    ]
  },
  "DerivedMetric": {
    "update": [
      "self",
      "data"
    ],
    "get": [
      "self"
    ]
  },
  "MetricDefinition": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "BaseMetricDefinition": {
    "__call__": [
      "self",
      "axis"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "add": [
      "self"
    ]
  },
  "MetricDefinitionCollection": {
    "__call__": [
      "self",
      "axis"
    ],
    "__add__": [
      "self",
      "other"
    ]
  },
  "MeanAbsoluteLabel": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "mean_absolute_label": [],
  "SumAbsoluteLabel": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "sum_absolute_label": [],
  "SumNumMaskedTargetValues": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "sum_num_masked_target_values": [],
  "SumError": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "sum_error": [],
  "SumAbsoluteError": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "sum_absolute_error": [],
  "MAE": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "mae": [],
  "MSE": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "mse": [],
  "SumQuantileLoss": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "Coverage": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "MAPE": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "mape": [],
  "SMAPE": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "smape": [],
  "MSIS": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "msis": [],
  "MASE": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "mase": [],
  "MeanScaledQuantileLoss": {
    "__call__": [
      "self",
      "axis"
    ]
  },
  "ND": {
    "normalized_deviation": [
      "sum_absolute_error",
      "sum_absolute_label"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "nd": [],
  "RMSE": {
    "root_mean_squared_error": [
      "mean_squared_error"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "rmse": [],
  "NRMSE": {
    "normalize_root_mean_squared_error": [
      "root_mean_squared_error",
      "mean_absolute_label"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "nrmse": [],
  "WeightedSumQuantileLoss": {
    "weight_sum_quantile_loss": [
      "sum_quantile_loss",
      "sum_absolute_label"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "MeanSumQuantileLoss": {
    "mean": [],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "MeanWeightedSumQuantileLoss": {
    "mean": [],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "AverageMeanScaledQuantileLoss": {
    "mean": [],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "MAECoverage": {
    "mean": [
      "quantile_levels"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "OWA": {
    "calculate_OWA": [
      "smape",
      "smape_naive2",
      "mase",
      "mase_naive2"
    ],
    "__call__": [
      "self",
      "axis"
    ]
  },
  "owa": [],
  "num_masked_target_values": [
    "data"
  ],
  "absolute_label": [
    "data"
  ],
  "error": [
    "data",
    "forecast_type"
  ],
  "absolute_error": [
    "data",
    "forecast_type"
  ],
  "squared_error": [
    "data",
    "forecast_type"
  ],
  "quantile_loss": [
    "data",
    "q"
  ],
  "coverage": [
    "data",
    "q"
  ],
  "absolute_percentage_error": [
    "data",
    "forecast_type"
  ],
  "symmetric_absolute_percentage_error": [
    "data",
    "forecast_type"
  ],
  "scaled_interval_score": [
    "data",
    "alpha"
  ],
  "absolute_scaled_error": [
    "data",
    "forecast_type"
  ],
  "scaled_quantile_loss": [
    "data",
    "q"
  ],
  "Aggregation": {
    "__post_init__": [
      "self"
    ],
    "step": [
      "self",
      "values"
    ],
    "get": [
      "self"
    ]
  },
  "Sum": {
    "step": [
      "self",
      "values"
    ],
    "get": [
      "self"
    ]
  },
  "Mean": {
    "step": [
      "self",
      "values"
    ],
    "get": [
      "self"
    ]
  },
  "seasonal_error": [
    "time_series",
    "seasonality",
    "time_axis"
  ],
  "log_metric": [
    "metric",
    "value"
  ],
  "log_version": [
    "forecaster_type"
  ],
  "run_train_and_test": [
    "env",
    "forecaster_type"
  ],
  "run_train": [
    "forecaster",
    "train_dataset",
    "hyperparameters",
    "validation_dataset",
    "from_predictor"
  ],
  "run_test": [
    "env",
    "predictor",
    "test_dataset",
    "hyperparameters"
  ],
  "Forecaster": [],
  "forecaster_type_by_name": [
    "name"
  ],
  "invoke_with": [
    "fn"
  ],
  "ForecasterNotFound": {},
  "TrainEnv": {
    "__init__": [
      "self"
    ],
    "_load": [
      "self"
    ],
    "_listify_dataset": [
      "self"
    ]
  },
  "ServeEnv": {
    "__init__": [
      "self"
    ]
  },
  "serve_command": [
    "data_path",
    "forecaster",
    "force_static"
  ],
  "train_command": [
    "data_path",
    "forecaster"
  ],
  "split_by_prefix": [
    "data"
  ],
  "decode_nested_parameters": [
    "parameters"
  ],
  "encode_nested_parameters": [
    "obj"
  ],
  "decode_sagemaker_parameter": [
    "value"
  ],
  "encode_sagemaker_parameter": [
    "value"
  ],
  "decode_sagemaker_parameters": [
    "encoded_params"
  ],
  "encode_sagemaker_parameters": [
    "decoded_params"
  ],
  "detrim_and_decode_sagemaker_parameters": [
    "trimmed_params"
  ],
  "encode_and_trim_sagemaker_parameters": [
    "decoded_params",
    "max_len"
  ],
  "trim_encoded_sagemaker_parameters": [
    "encoded_params",
    "max_len"
  ],
  "detrim_sagemaker_parameters": [
    "trimmed_params"
  ],
  "DataConfig": {},
  "InpuDataConfig": {
    "__getitem__": [
      "self",
      "item"
    ],
    "channels": [
      "self"
    ],
    "channel_names": [
      "self"
    ]
  },
  "TrainPaths": {
    "__init__": [
      "self",
      "base"
    ]
  },
  "ServePaths": {
    "__init__": [
      "self",
      "base"
    ]
  },
  "Installer": {
    "__init__": [
      "self",
      "packages"
    ],
    "cleanup": [
      "self"
    ],
    "copy_install": [
      "self",
      "path"
    ],
    "pip_install": [
      "self",
      "path"
    ],
    "install_requirement": [
      "self",
      "path"
    ],
    "install": [
      "self",
      "path"
    ],
    "handle_archive": [
      "self",
      "open_fn",
      "extractall_fn",
      "path"
    ]
  },
  "install_and_restart": [
    "code_channel",
    "packages"
  ],
  "MB": [],
  "Settings": {
    "sagemaker_server_bind": [
      "self"
    ],
    "number_of_workers": [
      "self"
    ]
  },
  "make_flask_app": [
    "env",
    "forecaster_type",
    "settings"
  ],
  "OutputType": [],
  "ForecastConfig": {
    "as_json_dict": [
      "self",
      "forecast"
    ]
  },
  "InferenceRequest": {},
  "ThrougputIter": {
    "__init__": [
      "self",
      "iterable"
    ],
    "__iter__": [
      "self"
    ]
  },
  "log_throughput": [
    "instances",
    "timings"
  ],
  "get_base_app": [
    "execution_params"
  ],
  "handle_predictions": [
    "predictor",
    "instances",
    "configuration"
  ],
  "inference_invocations": [
    "predictor_factory"
  ],
  "with_timeout": [
    "fn",
    "args",
    "timeout"
  ],
  "make_predictions": [
    "predictor",
    "dataset",
    "configuration"
  ],
  "ScoredInstanceStat": {},
  "batch_inference_invocations": [
    "predictor_factory",
    "configuration",
    "settings"
  ],
  "make_app": [
    "predictor_factory",
    "execution_params",
    "batch_transform_config",
    "settings"
  ],
  "MAX_WINDOW": [],
  "distance_to_holiday": [
    "holiday"
  ],
  "EasterSunday": [],
  "NewYearsDay": [],
  "SuperBowl": [],
  "MothersDay": [],
  "IndependenceDay": [],
  "ChristmasEve": [],
  "ChristmasDay": [],
  "NewYearsEve": [],
  "BlackFriday": [],
  "CyberMonday": [],
  "NEW_YEARS_DAY": [],
  "MARTIN_LUTHER_KING_DAY": [],
  "SUPERBOWL": [],
  "PRESIDENTS_DAY": [],
  "GOOD_FRIDAY": [],
  "EASTER_SUNDAY": [],
  "EASTER_MONDAY": [],
  "MOTHERS_DAY": [],
  "INDEPENDENCE_DAY": [],
  "LABOR_DAY": [],
  "MEMORIAL_DAY": [],
  "COLUMBUS_DAY": [],
  "THANKSGIVING": [],
  "CHRISTMAS_EVE": [],
  "CHRISTMAS_DAY": [],
  "NEW_YEARS_EVE": [],
  "BLACK_FRIDAY": [],
  "CYBER_MONDAY": [],
  "SPECIAL_DATE_FEATURES": [],
  "indicator": [
    "distance"
  ],
  "exponential_kernel": [
    "alpha",
    "tol"
  ],
  "squared_exponential_kernel": [
    "alpha",
    "tol"
  ],
  "SpecialDateFeatureSet": {
    "__init__": [
      "self",
      "feature_names",
      "kernel_function"
    ],
    "__call__": [
      "self",
      "dates"
    ]
  },
  "TimeFeature": [],
  "_normalize": [
    "xs",
    "num"
  ],
  "second_of_minute": [
    "index"
  ],
  "second_of_minute_index": [
    "index"
  ],
  "minute_of_hour": [
    "index"
  ],
  "minute_of_hour_index": [
    "index"
  ],
  "hour_of_day": [
    "index"
  ],
  "hour_of_day_index": [
    "index"
  ],
  "day_of_week": [
    "index"
  ],
  "day_of_week_index": [
    "index"
  ],
  "day_of_month": [
    "index"
  ],
  "day_of_month_index": [
    "index"
  ],
  "day_of_year": [
    "index"
  ],
  "day_of_year_index": [
    "index"
  ],
  "month_of_year": [
    "index"
  ],
  "month_of_year_index": [
    "index"
  ],
  "week_of_year": [
    "index"
  ],
  "week_of_year_index": [
    "index"
  ],
  "norm_freq_str": [
    "freq_str"
  ],
  "time_features_from_frequency_str": [
    "freq_str"
  ],
  "_make_lags": [
    "middle",
    "delta"
  ],
  "get_lags_for_frequency": [
    "freq_str",
    "lag_ub",
    "num_lags",
    "num_default_lags"
  ],
  "DEFAULT_SEASONALITIES": [],
  "get_seasonality": [
    "freq",
    "seasonalities"
  ],
  "encode_mx_context": [
    "v"
  ],
  "encode_mx_ndarray": [
    "v"
  ],
  "pad_to_size": [
    "x",
    "size",
    "axis",
    "is_right_pad"
  ],
  "_is_stackable": [
    "arrays",
    "axis"
  ],
  "_pad_arrays": [
    "data",
    "axis",
    "is_right_pad"
  ],
  "as_in_context": [
    "batch",
    "ctx"
  ],
  "get_activation": [
    "activation"
  ],
  "get_activation_deriv": [
    "act"
  ],
  "deriv_tanh": [
    "F",
    "x"
  ],
  "deriv_softrelu": [
    "F",
    "x"
  ],
  "deriv_elu": [
    "F",
    "x",
    "alpha"
  ],
  "deriv_swish": [
    "F",
    "x",
    "beta"
  ],
  "deriv_lipswish": [
    "F",
    "x",
    "beta"
  ],
  "LipSwish": {
    "__init__": [
      "self",
      "beta_initializer"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "beta"
    ]
  },
  "Tensor": [],
  "HybridContext": {
    "__init__": [
      "self",
      "net",
      "hybridize",
      "data_batch"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "assert_shape": [
    "x",
    "expected_shape"
  ],
  "copy_parameters": [
    "net_source",
    "net_dest",
    "ignore_extra",
    "allow_missing"
  ],
  "get_hybrid_forward_input_names": [
    "hybrid_block_type"
  ],
  "hybrid_block_to_symbol_block": [
    "hb",
    "data_batch"
  ],
  "export_symb_block": [
    "hb",
    "model_dir",
    "model_name",
    "epoch"
  ],
  "import_symb_block": [
    "num_inputs",
    "model_dir",
    "model_name",
    "epoch"
  ],
  "export_repr_block": [
    "rb",
    "model_dir",
    "model_name",
    "epoch"
  ],
  "import_repr_block": [
    "model_dir",
    "model_name",
    "epoch"
  ],
  "cumsum": [
    "F",
    "x",
    "exclusive",
    "reverse"
  ],
  "weighted_average": [
    "F",
    "x",
    "weights",
    "axis",
    "include_zeros_in_denominator"
  ],
  "make_nd_diag": [
    "F",
    "x",
    "d"
  ],
  "_broadcast_param": [
    "param",
    "axes",
    "sizes"
  ],
  "mx_switch": [
    "F"
  ],
  "equals_parameter_dict": [
    "this",
    "that"
  ],
  "equals_representable_block": [
    "this",
    "that"
  ],
  "skip_encoding_mx_gluon_parameterdict": [
    "v"
  ],
  "_": [
    "tensor"
  ],
  "batch_diagonal": [
    "F",
    "matrix",
    "num_data_points",
    "float_type"
  ],
  "lower_triangular_ones": [
    "F",
    "d",
    "offset"
  ],
  "jitter_cholesky_eig": [
    "F",
    "matrix",
    "num_data_points",
    "float_type",
    "diag_weight"
  ],
  "jitter_cholesky": [
    "F",
    "matrix",
    "num_data_points",
    "float_type",
    "max_iter_jitter",
    "neg_tol",
    "diag_weight",
    "increase_jitter"
  ],
  "MXContext": {
    "validate": [
      "cls",
      "v"
    ],
    "__get_validators__": [
      "cls"
    ]
  },
  "NUM_GPUS": [],
  "num_gpus": [
    "refresh"
  ],
  "get_mxnet_context": [
    "gpu_number"
  ],
  "check_gpu_support": [],
  "MixtureDistribution": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mixture_probs",
      "components",
      "F"
    ],
    "F": [
      "self"
    ],
    "support_min_max": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ]
  },
  "MixtureArgs": {
    "__init__": [
      "self",
      "distr_outputs",
      "prefix"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "MixtureDistributionOutput": {
    "__init__": [
      "self",
      "distr_outputs"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ],
    "value_in_support": [
      "self"
    ]
  },
  "EmpiricalDistribution": {
    "__init__": [
      "self",
      "samples",
      "event_dim"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "quantile_losses": [
      "self",
      "obs",
      "quantiles",
      "levels"
    ],
    "crps_univariate": [
      "self",
      "x"
    ],
    "loss": [
      "self",
      "x"
    ]
  },
  "EmpiricalDistributionOutput": {
    "__init__": [
      "self",
      "num_samples",
      "distr_output"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "domain_map": [
      "self",
      "F"
    ],
    "event_shape": [
      "self"
    ]
  },
  "BijectionOutput": {
    "__init__": [
      "self"
    ],
    "domain_map": [
      "self",
      "F"
    ],
    "bijection": [
      "self",
      "bij_args"
    ],
    "event_shape": [
      "self"
    ]
  },
  "Gamma": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "GammaOutput": {
    "domain_map": [
      "cls",
      "F",
      "alpha",
      "beta"
    ],
    "event_shape": [
      "self"
    ],
    "value_in_support": [
      "self"
    ]
  },
  "TransformedDistribution": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms"
    ],
    "F": [
      "self"
    ],
    "support_min_max": [
      "self"
    ],
    "_slice_bijection": [
      "self",
      "trans",
      "item"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "event_dim": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "log_prob": [
      "self",
      "y"
    ],
    "cdf": [
      "self",
      "y"
    ],
    "quantile": [
      "self",
      "level"
    ]
  },
  "AffineTransformedDistribution": {
    "__init__": [
      "self",
      "base_distribution",
      "loc",
      "scale"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "sum_trailing_axes": [
    "F",
    "x",
    "k"
  ],
  "Categorical": {
    "__init__": [
      "self",
      "log_probs"
    ],
    "F": [
      "self"
    ],
    "probs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "CategoricalOutput": {
    "__init__": [
      "self",
      "num_cats",
      "temperature"
    ],
    "domain_map": [
      "self",
      "F",
      "probs"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "Deterministic": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "value"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "args": [
      "self"
    ]
  },
  "DeterministicArgProj": {
    "__init__": [
      "self",
      "value",
      "args_dim",
      "dtype"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "DeterministicOutput": {
    "__init__": [
      "self",
      "value"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "event_shape": [
      "self"
    ]
  },
  "log_abs_det": [
    "A"
  ],
  "InvertibleResnetHybridBlock": {
    "__init__": [
      "self",
      "event_shape",
      "hidden_units",
      "num_hidden_layers",
      "num_inv_iters",
      "ignore_logdet",
      "activation",
      "num_power_iter",
      "flatten",
      "coeff",
      "use_caching"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ]
  },
  "iresnet": [
    "num_blocks"
  ],
  "Poisson": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "rate"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "PoissonOutput": {
    "domain_map": [
      "cls",
      "F",
      "rate"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "ZeroInflatedPoissonOutput": [],
  "Binned": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "bin_log_probs",
      "bin_centers",
      "label_smoothing"
    ],
    "F": [
      "self"
    ],
    "support_min_max": [
      "self"
    ],
    "_compute_edges": [
      "F",
      "bin_centers"
    ],
    "bin_probs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "_get_mask": [
      "self",
      "x"
    ],
    "_smooth_mask": [
      "F",
      "mask",
      "alpha"
    ],
    "smooth_ce_loss": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "loss": [
      "self",
      "x"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "BinnedArgs": {
    "__init__": [
      "self",
      "num_bins",
      "bin_centers"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "bin_centers"
    ]
  },
  "BinnedOutput": {
    "__init__": [
      "self",
      "bin_centers",
      "label_smoothing"
    ],
    "get_args_proj": [
      "self"
    ],
    "_scale_bin_centers": [
      "F",
      "bin_centers",
      "loc",
      "scale"
    ],
    "distribution": [
      "self",
      "args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "GenPareto": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "xi",
      "beta"
    ],
    "F": [
      "self"
    ],
    "support_min_max": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "GenParetoOutput": {
    "domain_map": [
      "cls",
      "F",
      "xi",
      "beta"
    ],
    "event_shape": [
      "self"
    ],
    "value_in_support": [
      "self"
    ]
  },
  "StudentT": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "nu",
      "F"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "StudentTOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "sigma",
      "nu"
    ],
    "event_shape": [
      "self"
    ]
  },
  "NanMixture": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "nan_prob",
      "distribution",
      "F"
    ],
    "distribution": [
      "self"
    ],
    "nan_prob": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ]
  },
  "NanMixtureArgs": {
    "__init__": [
      "self",
      "distr_output",
      "prefix"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "NanMixtureOutput": {
    "__init__": [
      "self",
      "distr_output"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "ISQF": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "spline_knots",
      "spline_heights",
      "beta_l",
      "beta_r",
      "qk_y",
      "qk_x",
      "num_qk",
      "num_pieces",
      "tol"
    ],
    "F": [
      "self"
    ],
    "args": [
      "self"
    ],
    "parametrize_qk": [
      "F",
      "quantile_knots"
    ],
    "parametrize_spline": [
      "F",
      "spline_knots",
      "qk",
      "qk_plus",
      "num_pieces",
      "tol"
    ],
    "parametrize_tail": [
      "F",
      "beta",
      "qk_x",
      "qk_y"
    ],
    "quantile": [
      "self",
      "input_alpha"
    ],
    "quantile_internal": [
      "self",
      "alpha",
      "axis"
    ],
    "quantile_spline": [
      "self",
      "alpha",
      "axis"
    ],
    "quantile_tail": [
      "self",
      "alpha",
      "axis",
      "left_tail"
    ],
    "cdf_spline": [
      "self",
      "z"
    ],
    "cdf_tail": [
      "self",
      "z",
      "left_tail"
    ],
    "crps_tail": [
      "self",
      "z",
      "left_tail"
    ],
    "crps_spline": [
      "self",
      "z"
    ],
    "loss": [
      "self",
      "z"
    ],
    "crps": [
      "self",
      "z"
    ],
    "cdf": [
      "self",
      "z"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ]
  },
  "ISQFOutput": {
    "__init__": [
      "self",
      "num_pieces",
      "qk_x",
      "tol"
    ],
    "domain_map": [
      "cls",
      "F"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "reshape_spline_args": [
      "self",
      "distr_args",
      "qk_x"
    ],
    "event_shape": [
      "self"
    ]
  },
  "TransformedISQF": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms"
    ],
    "crps": [
      "self",
      "y"
    ]
  },
  "TransformedDistributionOutput": {
    "__init__": [
      "self",
      "base_distr_output",
      "transforms_output"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "_split_args": [
      "self",
      "args"
    ],
    "domain_map": [
      "self",
      "F"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "Gaussian": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mu",
      "sigma"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "fit": [
      "cls",
      "F",
      "samples"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "args": [
      "self"
    ]
  },
  "GaussianOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "sigma"
    ],
    "event_shape": [
      "self"
    ]
  },
  "ParameterBounds": {
    "__init__": [
      "self",
      "lower",
      "upper"
    ]
  },
  "_safe_split": [
    "x",
    "num_outputs",
    "axis",
    "squeeze_axis"
  ],
  "LDS": {
    "__init__": [
      "self",
      "emission_coeff",
      "transition_coeff",
      "innovation_coeff",
      "noise_std",
      "residuals",
      "prior_mean",
      "prior_cov",
      "latent_dim",
      "output_dim",
      "seq_length"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x",
      "scale",
      "observed"
    ],
    "kalman_filter": [
      "self",
      "targets",
      "observed"
    ],
    "sample": [
      "self",
      "num_samples",
      "scale"
    ],
    "sample_marginals": [
      "self",
      "num_samples",
      "scale"
    ]
  },
  "LDSArgsProj": {
    "__init__": [
      "self",
      "output_dim",
      "noise_std_bounds",
      "innovation_bounds"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "kalman_filter_step": [
    "F",
    "target",
    "prior_mean",
    "prior_cov",
    "emission_coeff",
    "residual",
    "noise_std",
    "latent_dim",
    "output_dim"
  ],
  "LogitNormal": {
    "__init__": [
      "self",
      "mu",
      "sigma"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "args": [
      "self"
    ]
  },
  "LogitNormalOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "sigma"
    ],
    "event_shape": [
      "self"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ]
  },
  "Laplace": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mu",
      "b"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "args": [
      "self"
    ]
  },
  "LaplaceOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "b"
    ],
    "event_shape": [
      "self"
    ]
  },
  "LaplaceFixedVarianceOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "b"
    ]
  },
  "DirichletMultinomial": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "dim",
      "n_trials",
      "alpha",
      "float_type"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ]
  },
  "DirichletMultinomialOutput": {
    "__init__": [
      "self",
      "dim",
      "n_trials"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "domain_map": [
      "self",
      "F",
      "alpha_vector"
    ],
    "event_shape": [
      "self"
    ]
  },
  "PiecewiseLinear": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "gamma",
      "slopes",
      "knot_spacings"
    ],
    "F": [
      "self"
    ],
    "args": [
      "self"
    ],
    "_to_orig_params": [
      "F",
      "slopes",
      "knot_spacings"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "loss": [
      "self",
      "x"
    ],
    "crps": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "quantile_internal": [
      "self",
      "x",
      "axis"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ]
  },
  "PiecewiseLinearOutput": {
    "__init__": [
      "self",
      "num_pieces"
    ],
    "domain_map": [
      "cls",
      "F",
      "gamma",
      "slopes",
      "knot_spacings"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "FixedKnotsArgProj": {
    "__init__": [
      "self",
      "knot_spacings"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "FixedKnotsPiecewiseLinearOutput": {
    "__init__": [
      "self",
      "quantile_levels"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "domain_map": [
      "cls",
      "F",
      "gamma",
      "slopes",
      "knot_spacings"
    ]
  },
  "TransformedPiecewiseLinear": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms"
    ],
    "crps": [
      "self",
      "y"
    ]
  },
  "Beta": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "BetaOutput": {
    "domain_map": [
      "cls",
      "F",
      "alpha",
      "beta"
    ],
    "event_shape": [
      "self"
    ],
    "value_in_support": [
      "self"
    ]
  },
  "Bijection": {
    "__init__": [
      "self"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "inverse_bijection": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ]
  },
  "InverseBijection": {
    "__init__": [
      "self",
      "bijection"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "inverse_bijection": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ]
  },
  "ComposedBijection": {
    "__init__": [
      "self",
      "bijections"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ],
    "__iadd__": [
      "self",
      "bijections"
    ],
    "__add__": [
      "self",
      "bijections"
    ]
  },
  "BijectionHybridBlock": {},
  "ComposedBijectionHybridBlock": {
    "__init__": [
      "self",
      "bij_blocks"
    ],
    "__iadd__": [
      "self",
      "bij_blocks"
    ]
  },
  "_Exp": {
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ]
  },
  "_Log": {
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ]
  },
  "_Softrelu": {
    "_log_expm1": [
      "self",
      "F",
      "y"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ]
  },
  "AffineTransformation": {
    "__init__": [
      "self",
      "loc",
      "scale"
    ],
    "f": [
      "self",
      "x"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "x",
      "y"
    ],
    "sign": [
      "self"
    ],
    "event_dim": [
      "self"
    ]
  },
  "exp": [],
  "log": [],
  "softrelu": [],
  "MultivariateGaussian": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mu",
      "L",
      "F"
    ],
    "F": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ]
  },
  "MultivariateGaussianOutput": {
    "__init__": [
      "self",
      "dim"
    ],
    "domain_map": [
      "self",
      "F",
      "mu_vector",
      "L_vector"
    ],
    "event_shape": [
      "self"
    ]
  },
  "BoxCoxTransform": {
    "arg_names": [],
    "__init__": [
      "self",
      "lambda_1",
      "lambda_2",
      "tol_lambda_1",
      "F"
    ],
    "args": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "sign": [
      "self"
    ],
    "f": [
      "self",
      "z"
    ],
    "f_inv": [
      "self",
      "y"
    ],
    "log_abs_det_jac": [
      "self",
      "z",
      "y"
    ]
  },
  "BoxCoxTransformOutput": {
    "__init__": [
      "self",
      "lb_obs",
      "fix_lambda_2"
    ],
    "domain_map": [
      "self",
      "F"
    ],
    "event_shape": [
      "self"
    ]
  },
  "InverseBoxCoxTransform": {
    "arg_names": [],
    "__init__": [
      "self",
      "lambda_1",
      "lambda_2",
      "tol_lambda_1",
      "F"
    ],
    "event_dim": [
      "self"
    ]
  },
  "InverseBoxCoxTransformOutput": {
    "event_shape": [
      "self"
    ]
  },
  "MAX_SUPPORT_VAL": [],
  "nans_like": [
    "x"
  ],
  "softplus": [
    "F",
    "x"
  ],
  "getF": [
    "var"
  ],
  "_index_tensor": [
    "x",
    "item"
  ],
  "Distribution": {
    "is_reparameterizable": [],
    "F": [
      "self"
    ],
    "support_min_max": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "crps": [
      "self",
      "x"
    ],
    "loss": [
      "self",
      "x"
    ],
    "prob": [
      "self",
      "x"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "batch_dim": [
      "self"
    ],
    "all_dim": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "_tensor_cdf_bisection": [
      "self",
      "level",
      "tol",
      "max_iter"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "slice_axis": [
      "self",
      "axis",
      "begin",
      "end"
    ]
  },
  "_expand_param": [
    "p",
    "num_samples"
  ],
  "_sample_multiple": [
    "sample_func"
  ],
  "sigma_minimum": [],
  "capacitance_tril": [
    "F",
    "rank",
    "W",
    "D"
  ],
  "log_det": [
    "F",
    "batch_D",
    "batch_capacitance_tril"
  ],
  "mahalanobis_distance": [
    "F",
    "W",
    "D",
    "capacitance_tril",
    "x"
  ],
  "lowrank_log_likelihood": [
    "rank",
    "mu",
    "D",
    "W",
    "x"
  ],
  "LowrankMultivariateGaussian": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "dim",
      "rank",
      "mu",
      "D",
      "W"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "fit": [
      "cls",
      "F",
      "samples",
      "rank"
    ]
  },
  "inv_softplus": [
    "y"
  ],
  "LowrankMultivariateGaussianOutput": {
    "__init__": [
      "self",
      "dim",
      "rank",
      "sigma_init",
      "sigma_minimum"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "domain_map": [
      "self",
      "F",
      "mu_vector",
      "D_vector",
      "W_vector"
    ],
    "event_shape": [
      "self"
    ]
  },
  "GPArgProj": {
    "__init__": [
      "self",
      "rank",
      "sigma_init",
      "sigma_minimum",
      "mu_ratio",
      "dropout_rate",
      "prefix"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "LowrankGPOutput": {
    "__init__": [
      "self",
      "rank",
      "dim",
      "sigma_init",
      "mu_ratio",
      "dropout_rate"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale",
      "dim"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ]
  },
  "NegativeBinomial": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "mu",
      "alpha"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "args": [
      "self"
    ]
  },
  "NegativeBinomialOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "alpha"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "ZeroInflatedNegativeBinomialOutput": [],
  "ArgProj": {
    "__init__": [
      "self",
      "args_dim",
      "domain_map",
      "dtype",
      "prefix"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "Output": {
    "dtype": [
      "self",
      "dtype"
    ],
    "eps": [
      "cls"
    ],
    "get_args_proj": [
      "self",
      "prefix"
    ],
    "domain_map": [
      "self",
      "F"
    ]
  },
  "DistributionOutput": {
    "__init__": [
      "self"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "value_in_support": [
      "self"
    ],
    "domain_map": [
      "self",
      "F"
    ]
  },
  "ZeroAndOneInflatedBeta": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "beta",
      "zero_probability",
      "one_probability"
    ],
    "log_prob": [
      "self",
      "x"
    ]
  },
  "ZeroInflatedBeta": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "beta",
      "zero_probability"
    ]
  },
  "OneInflatedBeta": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "beta",
      "one_probability"
    ]
  },
  "ZeroAndOneInflatedBetaOutput": {
    "domain_map": [
      "cls",
      "F",
      "alpha",
      "beta",
      "zero_probability",
      "one_probability"
    ],
    "event_shape": [
      "self"
    ],
    "value_in_support": [
      "self"
    ]
  },
  "ZeroInflatedBetaOutput": {
    "domain_map": [
      "cls",
      "F",
      "alpha",
      "beta",
      "zero_probability"
    ]
  },
  "OneInflatedBetaOutput": {
    "domain_map": [
      "cls",
      "F",
      "alpha",
      "beta",
      "one_probability"
    ]
  },
  "Dirichlet": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "alpha",
      "float_type"
    ],
    "F": [
      "self"
    ],
    "args": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ]
  },
  "DirichletOutput": {
    "__init__": [
      "self",
      "dim"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "domain_map": [
      "self",
      "F",
      "alpha_vector"
    ],
    "event_shape": [
      "self"
    ]
  },
  "Uniform": {
    "is_reparameterizable": [],
    "__init__": [
      "self",
      "low",
      "high"
    ],
    "F": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype"
    ],
    "sample_rep": [
      "self",
      "num_samples",
      "dtype"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "args": [
      "self"
    ]
  },
  "UniformOutput": {
    "domain_map": [
      "cls",
      "F",
      "low",
      "width"
    ],
    "event_shape": [
      "self"
    ]
  },
  "KernelOutput": {
    "get_args_proj": [
      "self",
      "float_type"
    ],
    "kernel": [
      "self",
      "args"
    ],
    "compute_std": [
      "F",
      "data",
      "axis"
    ]
  },
  "KernelOutputDict": {
    "__init__": [
      "self"
    ],
    "get_num_args": [
      "self"
    ],
    "get_args_proj": [
      "self",
      "float_type"
    ],
    "gp_params_scaling": [
      "self",
      "F",
      "past_target",
      "past_time_feat"
    ],
    "domain_map": [
      "self",
      "F"
    ],
    "kernel": [
      "self",
      "kernel_args"
    ]
  },
  "Kernel": {
    "kernel_matrix": [
      "self",
      "x1",
      "x2"
    ],
    "_compute_square_dist": [
      "self",
      "F",
      "x1",
      "x2"
    ]
  },
  "PeriodicKernel": {
    "__init__": [
      "self",
      "amplitude",
      "length_scale",
      "frequency",
      "F"
    ],
    "kernel_matrix": [
      "self",
      "x1",
      "x2"
    ]
  },
  "PeriodicKernelOutput": {
    "gp_params_scaling": [
      "self",
      "F",
      "past_target",
      "past_time_feat"
    ],
    "domain_map": [
      "cls",
      "F",
      "amplitude",
      "length_scale",
      "frequency"
    ]
  },
  "RBFKernel": {
    "__init__": [
      "self",
      "amplitude",
      "length_scale",
      "F"
    ],
    "kernel_matrix": [
      "self",
      "x1",
      "x2"
    ]
  },
  "RBFKernelOutput": {
    "gp_params_scaling": [
      "self",
      "F",
      "past_target",
      "past_time_feat"
    ],
    "domain_map": [
      "self",
      "F",
      "amplitude",
      "length_scale"
    ]
  },
  "jacobian_sn_mlp_block_bf": [
    "layers"
  ],
  "SNMLPBlock": {
    "__init__": [
      "self",
      "in_units",
      "hidden_units",
      "out_units",
      "num_hidden_layers",
      "activation",
      "jacobian_method",
      "num_power_iter",
      "coeff",
      "flatten"
    ],
    "get_weights": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ],
    "jacobian": [
      "self",
      "x"
    ]
  },
  "FeatureEmbedder": {
    "__init__": [
      "self",
      "cardinalities",
      "embedding_dims",
      "dtype"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "features"
    ]
  },
  "FeatureAssembler": {
    "__init__": [
      "self",
      "T",
      "use_static_cat",
      "use_static_real",
      "use_dynamic_cat",
      "use_dynamic_real",
      "embed_static",
      "embed_dynamic",
      "dtype"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "feat_dynamic_cat",
      "feat_dynamic_real"
    ],
    "process_static_cat": [
      "self",
      "F",
      "feature"
    ],
    "process_dynamic_cat": [
      "self",
      "F",
      "feature"
    ],
    "process_static_real": [
      "self",
      "F",
      "feature"
    ],
    "process_dynamic_real": [
      "self",
      "F",
      "feature"
    ]
  },
  "EPSILON": [],
  "SNDense": {
    "__init__": [
      "self",
      "units",
      "in_units",
      "coeff",
      "activation",
      "use_bias",
      "flatten",
      "weight_initializer",
      "bias_initializer",
      "dtype",
      "num_power_iter",
      "ctx"
    ],
    "weight": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "_weight",
      "_u",
      "_bias"
    ],
    "__repr__": [
      "self"
    ],
    "_spectral_norm": [
      "self",
      "weight",
      "u"
    ]
  },
  "MLP": {
    "__init__": [
      "self",
      "layer_sizes",
      "flatten",
      "activation"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "uniform_weights": [
    "objects"
  ],
  "crps_weights_pwl": [
    "quantile_levels"
  ],
  "QuantileLoss": {
    "__init__": [
      "self",
      "quantiles",
      "quantile_weights",
      "weight",
      "batch_axis"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "compute_quantile_loss": [
      "F",
      "y_true",
      "y_pred_p",
      "p"
    ]
  },
  "QuantileOutput": {
    "__init__": [
      "self",
      "quantiles",
      "quantile_weights"
    ],
    "quantiles": [
      "self"
    ],
    "get_loss": [
      "self"
    ],
    "get_quantile_proj": [
      "self"
    ]
  },
  "IncrementalDenseLayerProjection": {
    "__init__": [
      "self",
      "num_outputs"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "IncrementalQuantileOutput": {
    "__init__": [
      "self",
      "quantiles",
      "quantile_weights"
    ],
    "get_loss": [
      "self"
    ],
    "get_quantile_proj": [
      "self"
    ]
  },
  "VariationalZoneoutCell": {
    "__init__": [
      "self",
      "base_cell",
      "zoneout_outputs",
      "zoneout_states"
    ],
    "__repr__": [
      "self"
    ],
    "_alias": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "_initialize_states_masks": [
      "self",
      "F",
      "states"
    ],
    "_initialize_outputs_mask": [
      "self",
      "F",
      "output"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "inputs",
      "states"
    ]
  },
  "RNNZoneoutCell": {
    "__init__": [
      "self",
      "base_cell",
      "zoneout_outputs",
      "zoneout_states"
    ],
    "__repr__": [
      "self"
    ],
    "_alias": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "inputs",
      "states"
    ]
  },
  "ActivationRegularizationLoss": {
    "__init__": [
      "self",
      "alpha",
      "weight",
      "batch_axis",
      "time_axis"
    ],
    "__repr__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F"
    ]
  },
  "TemporalActivationRegularizationLoss": {
    "__init__": [
      "self",
      "beta",
      "weight",
      "batch_axis",
      "time_axis"
    ],
    "__repr__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F"
    ]
  },
  "Seq2SeqDecoder": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "static_input",
      "dynamic_input"
    ]
  },
  "ForkingMLPDecoder": {
    "__init__": [
      "self",
      "dec_len",
      "final_dim",
      "hidden_dimension_sequence"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "static_input",
      "dynamic_input"
    ]
  },
  "OneShotDecoder": {
    "__init__": [
      "self",
      "decoder_length",
      "layer_sizes",
      "static_outputs_per_time_step"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "static_input",
      "dynamic_input"
    ]
  },
  "Seq2SeqEnc2Dec": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "encoder_output_static",
      "encoder_output_dynamic",
      "future_features_dynamic"
    ]
  },
  "PassThroughEnc2Dec": {
    "hybrid_forward": [
      "self",
      "F",
      "encoder_output_static",
      "encoder_output_dynamic",
      "future_features_dynamic"
    ]
  },
  "FutureFeatIntegratorEnc2Dec": {
    "hybrid_forward": [
      "self",
      "F",
      "encoder_output_static",
      "encoder_output_dynamic",
      "future_features_dynamic"
    ]
  },
  "RNN": {
    "__init__": [
      "self",
      "mode",
      "num_hidden",
      "num_layers",
      "bidirectional"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "inputs"
    ]
  },
  "Seq2SeqEncoder": {
    "hybrid_forward": [
      "self",
      "F",
      "target",
      "static_features",
      "dynamic_features"
    ],
    "_assemble_inputs": [
      "self",
      "F",
      "target",
      "static_features",
      "dynamic_features"
    ]
  },
  "HierarchicalCausalConv1DEncoder": {
    "__init__": [
      "self",
      "dilation_seq",
      "kernel_size_seq",
      "channels_seq",
      "use_residual",
      "use_static_feat",
      "use_dynamic_feat"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "target",
      "static_features",
      "dynamic_features"
    ]
  },
  "RNNEncoder": {
    "__init__": [
      "self",
      "mode",
      "hidden_size",
      "num_layers",
      "bidirectional",
      "use_static_feat",
      "use_dynamic_feat"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "target",
      "static_features",
      "dynamic_features"
    ]
  },
  "MLPEncoder": {
    "__init__": [
      "self",
      "layer_sizes"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "target",
      "static_features",
      "dynamic_features"
    ]
  },
  "RNNCovariateEncoder": {
    "__init__": [
      "self",
      "use_static_feat",
      "use_dynamic_feat"
    ]
  },
  "_get_int": [
    "a"
  ],
  "CausalConv1D": {
    "__init__": [
      "self",
      "channels",
      "kernel_size",
      "dilation",
      "activation"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data"
    ]
  },
  "DilatedCausalGated": {
    "__init__": [
      "self",
      "inner_channels",
      "out_channels",
      "kernel_size",
      "dilation"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "ResidualSequential": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "Scaler": {
    "__init__": [
      "self",
      "keepdims",
      "axis"
    ],
    "compute_scale": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ]
  },
  "MeanScaler": {
    "__init__": [
      "self",
      "minimum_scale",
      "default_scale"
    ],
    "compute_scale": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ]
  },
  "MinMax": {
    "__init__": [
      "self"
    ],
    "compute_scale": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ]
  },
  "NOPScaler": {
    "__init__": [
      "self"
    ],
    "compute_scale": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ]
  },
  "HybridRepresentation": {
    "__init__": [
      "self",
      "representations"
    ],
    "initialize_from_dataset": [
      "self",
      "input_dataset",
      "ctx"
    ],
    "initialize_from_array": [
      "self",
      "input_array",
      "ctx"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ]
  },
  "DiscretePIT": {
    "__init__": [
      "self",
      "num_bins",
      "mlp_transf",
      "embedding_size"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "GlobalRelativeBinning": {
    "__init__": [
      "self",
      "num_bins",
      "is_quantile",
      "linear_scaling_limit",
      "quantile_scaling_limit"
    ],
    "initialize_from_dataset": [
      "self",
      "input_dataset",
      "ctx"
    ],
    "initialize_from_array": [
      "self",
      "input_array",
      "ctx"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "ensure_binning_monotonicity": [
    "bin_centers"
  ],
  "bin_edges_from_bin_centers": [
    "bin_centers"
  ],
  "Digitize": {
    "forward": [
      "self",
      "is_train",
      "req",
      "in_data",
      "out_data",
      "aux"
    ],
    "backward": [
      "self",
      "req",
      "out_grad",
      "in_data",
      "out_data",
      "in_grad",
      "aux"
    ]
  },
  "DigitizeProp": {
    "__init__": [
      "self"
    ],
    "list_arguments": [
      "self"
    ],
    "list_outputs": [
      "self"
    ],
    "infer_shape": [
      "self",
      "in_shapes"
    ],
    "create_operator": [
      "self",
      "ctx",
      "in_shapes",
      "in_dtypes"
    ]
  },
  "Embedding": {
    "__init__": [
      "self",
      "num_bins",
      "size"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ]
  },
  "Representation": {
    "__init__": [
      "self"
    ],
    "initialize_from_dataset": [
      "self",
      "input_dataset",
      "ctx"
    ],
    "initialize_from_array": [
      "self",
      "input_array",
      "ctx"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "LocalAbsoluteBinning": {
    "__init__": [
      "self",
      "num_bins",
      "is_quantile"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "MeanScaling": {
    "__init__": [
      "self",
      "scale_min",
      "clip_max"
    ],
    "compute_scale": [
      "self",
      "F",
      "data",
      "observed_indicator"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "CustomBinning": {
    "__init__": [
      "self",
      "bin_centers"
    ],
    "initialize_from_dataset": [
      "self",
      "input_dataset",
      "ctx"
    ],
    "initialize_from_array": [
      "self",
      "input_array",
      "ctx"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "DimExpansion": {
    "__init__": [
      "self",
      "axis"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ]
  },
  "RepresentationChain": {
    "__init__": [
      "self",
      "chain"
    ],
    "initialize_from_dataset": [
      "self",
      "input_dataset",
      "ctx"
    ],
    "initialize_from_array": [
      "self",
      "input_array",
      "ctx"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "observed_indicator",
      "scale",
      "rep_params"
    ],
    "post_transform": [
      "self",
      "F",
      "samples",
      "scale",
      "rep_params"
    ]
  },
  "IterationAveragingStrategy": {
    "__init__": [
      "self",
      "eta"
    ],
    "update_average_trigger": [
      "self",
      "metric",
      "epoch"
    ],
    "apply": [
      "self",
      "model"
    ],
    "update_average": [
      "self",
      "model"
    ],
    "load_averaged_model": [
      "self",
      "model"
    ],
    "load_cached_model": [
      "self",
      "model"
    ]
  },
  "NTA": {
    "__init__": [
      "self",
      "epochs",
      "n",
      "maximize",
      "last_n_trigger",
      "eta",
      "fallback_alpha"
    ],
    "update_average_trigger": [
      "self",
      "metric",
      "epoch"
    ]
  },
  "Alpha_Suffix": {
    "__init__": [
      "self",
      "epochs",
      "alpha",
      "eta"
    ],
    "update_average_trigger": [
      "self",
      "metric",
      "epoch"
    ]
  },
  "ModelIterationAveraging": {
    "__init__": [
      "self",
      "avg_strategy"
    ],
    "on_validation_epoch_start": [
      "self",
      "training_network"
    ],
    "on_validation_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ],
    "on_train_batch_end": [
      "self",
      "training_network"
    ],
    "on_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer",
      "best_epoch_info",
      "ctx"
    ],
    "on_train_end": [
      "self",
      "training_network",
      "temporary_dir",
      "ctx"
    ]
  },
  "EPOCH_INFO_STRING": [],
  "save_epoch_info": [
    "tmp_path",
    "epoch_info"
  ],
  "AveragingStrategy": {
    "__init__": [
      "self",
      "num_models",
      "metric",
      "maximize"
    ],
    "apply": [
      "self",
      "model_path"
    ],
    "get_checkpoint_information": [
      "model_path"
    ],
    "select_checkpoints": [
      "self",
      "checkpoints"
    ],
    "average": [
      "self",
      "param_paths",
      "weights"
    ],
    "average_arrays": [
      "arrays",
      "weights"
    ]
  },
  "SelectNBestSoftmax": {
    "select_checkpoints": [
      "self",
      "checkpoints"
    ]
  },
  "SelectNBestMean": {
    "select_checkpoints": [
      "self",
      "checkpoints"
    ]
  },
  "ModelAveraging": {
    "__init__": [
      "self",
      "avg_strategy"
    ],
    "on_train_end": [
      "self",
      "training_network",
      "temporary_dir",
      "ctx"
    ]
  },
  "MODEL_ARTIFACT_FILE_NAME": [],
  "STATE_ARTIFACT_FILE_NAME": [],
  "check_loss_finite": [
    "val"
  ],
  "loss_value": [
    "loss"
  ],
  "Trainer": {
    "__init__": [
      "self",
      "ctx",
      "epochs",
      "num_batches_per_epoch",
      "learning_rate",
      "clip_gradient",
      "weight_decay",
      "init",
      "hybridize",
      "callbacks",
      "add_default_callbacks"
    ],
    "count_model_params": [
      "self",
      "net"
    ],
    "__call__": [
      "self",
      "net",
      "train_iter",
      "validation_iter"
    ]
  },
  "Callback": {
    "on_train_start": [
      "self",
      "max_epochs"
    ],
    "on_network_initializing_end": [
      "self",
      "training_network"
    ],
    "on_train_epoch_start": [
      "self",
      "training_network"
    ],
    "on_validation_epoch_start": [
      "self",
      "training_network"
    ],
    "on_train_batch_end": [
      "self",
      "training_network"
    ],
    "on_validation_batch_end": [
      "self",
      "training_network"
    ],
    "on_train_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ],
    "on_validation_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ],
    "on_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer",
      "best_epoch_info",
      "ctx"
    ],
    "on_train_end": [
      "self",
      "training_network",
      "temporary_dir",
      "ctx"
    ]
  },
  "CallbackList": {
    "__init__": [
      "self",
      "callbacks"
    ],
    "_exec": [
      "self",
      "function_name"
    ],
    "on_train_start": [
      "self"
    ],
    "on_network_initializing_end": [
      "self"
    ],
    "on_train_epoch_start": [
      "self"
    ],
    "on_validation_epoch_start": [
      "self"
    ],
    "on_train_batch_end": [
      "self"
    ],
    "on_validation_batch_end": [
      "self"
    ],
    "on_train_epoch_end": [
      "self"
    ],
    "on_validation_epoch_end": [
      "self"
    ],
    "on_epoch_end": [
      "self"
    ],
    "on_train_end": [
      "self"
    ]
  },
  "TrainingHistory": {
    "__init__": [
      "self"
    ],
    "on_train_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ],
    "on_validation_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ]
  },
  "TerminateOnNaN": {
    "on_train_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer"
    ]
  },
  "WarmStart": {
    "__init__": [
      "self",
      "predictor"
    ],
    "on_network_initializing_end": [
      "self",
      "training_network"
    ]
  },
  "_Timer": {
    "start": [
      "self"
    ],
    "remaining": [
      "self"
    ],
    "is_running": [
      "self"
    ]
  },
  "TrainingTimeLimit": {
    "__init__": [
      "self"
    ],
    "on_train_start": [
      "self",
      "max_epochs"
    ],
    "on_train_batch_end": [
      "self",
      "training_network"
    ],
    "on_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer",
      "best_epoch_info",
      "ctx"
    ]
  },
  "Objective": {
    "from_str": [
      "s"
    ],
    "update": [
      "self",
      "metric"
    ],
    "should_update": [
      "self",
      "metric"
    ]
  },
  "Min": {
    "should_update": [
      "self",
      "metric"
    ]
  },
  "Max": {
    "should_update": [
      "self",
      "metric"
    ]
  },
  "Patience": {
    "reset": [
      "self"
    ],
    "step": [
      "self",
      "metric_value"
    ]
  },
  "MetricAttentiveScheduler": {
    "__post_init__": [
      "self"
    ],
    "step": [
      "self",
      "metric_value"
    ]
  },
  "LearningRateReduction": {
    "__init__": [
      "self",
      "objective",
      "patience",
      "base_lr",
      "decay_factor",
      "min_lr"
    ],
    "on_epoch_end": [
      "self",
      "epoch_no",
      "epoch_loss",
      "training_network",
      "trainer",
      "best_epoch_info",
      "ctx"
    ]
  },
  "DistributionForecast": {
    "__init__": [
      "self",
      "distribution",
      "start_date",
      "item_id",
      "info"
    ],
    "mean": [
      "self"
    ],
    "mean_ts": [
      "self"
    ],
    "quantile": [
      "self",
      "level"
    ],
    "to_sample_forecast": [
      "self",
      "num_samples"
    ],
    "to_quantile_forecast": [
      "self",
      "quantiles"
    ]
  },
  "GluonPredictor": {
    "BlockType": [],
    "__init__": [
      "self",
      "input_names",
      "prediction_net",
      "batch_size",
      "prediction_length",
      "ctx",
      "input_transform",
      "lead_time",
      "forecast_generator",
      "output_transform",
      "dtype"
    ],
    "network": [
      "self"
    ],
    "hybridize": [
      "self",
      "batch"
    ],
    "as_symbol_block_predictor": [
      "self",
      "batch",
      "dataset"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples",
      "num_workers",
      "num_prefetch"
    ],
    "__eq__": [
      "self",
      "that"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "serialize_prediction_net": [
      "self",
      "path"
    ]
  },
  "SymbolBlockPredictor": {
    "BlockType": [],
    "as_symbol_block_predictor": [
      "self",
      "batch",
      "dataset"
    ],
    "serialize_prediction_net": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path",
      "ctx"
    ]
  },
  "RepresentableBlockPredictor": {
    "BlockType": [],
    "__init__": [
      "self",
      "prediction_net",
      "batch_size",
      "prediction_length",
      "ctx",
      "input_transform",
      "lead_time",
      "forecast_generator",
      "output_transform",
      "dtype"
    ],
    "as_symbol_block_predictor": [
      "self",
      "batch",
      "dataset"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "serialize_prediction_net": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path",
      "ctx"
    ]
  },
  "TrainOutput": {},
  "GluonEstimator": {
    "__init__": [
      "self"
    ],
    "from_hyperparameters": [
      "cls"
    ],
    "create_transformation": [
      "self"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "train_model": [
      "self",
      "training_data",
      "validation_data",
      "from_predictor",
      "shuffle_buffer_length",
      "cache_data"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data",
      "shuffle_buffer_length",
      "cache_data"
    ],
    "train_from": [
      "self",
      "predictor",
      "training_data",
      "validation_data",
      "shuffle_buffer_length",
      "cache_data"
    ]
  },
  "DeepAREstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "dropoutcell_type",
      "dropout_rate",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "use_feat_static_real",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "scaling",
      "lags_seq",
      "time_features",
      "num_parallel_samples",
      "imputation_method",
      "train_sampler",
      "validation_sampler",
      "dtype",
      "alpha",
      "beta",
      "batch_size",
      "default_scale",
      "minimum_scale",
      "impute_missing_values",
      "num_imputation_samples",
      "nonnegative_pred_samples"
    ],
    "derive_auto_fields": [
      "cls",
      "train_iter"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "DeepARNetwork": {
    "__init__": [
      "self",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "distr_output",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "lags_seq",
      "dropoutcell_type",
      "scaling",
      "dtype",
      "num_imputation_samples",
      "minimum_scale",
      "impute_missing_values",
      "default_scale",
      "nonnegative_pred_samples"
    ],
    "get_lagged_subsequences": [
      "F",
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "imputation_rnn_unroll": [
      "self",
      "F",
      "begin_state",
      "sequence",
      "sequence_length",
      "subsequences_length",
      "scale",
      "target",
      "target_observed_values",
      "time_feat",
      "repeated_static_feat",
      "is_padded_indicator"
    ],
    "prepare_inputs_imputation_step": [
      "self",
      "F",
      "begin_state",
      "imputed_sequence",
      "sequence_length",
      "subsequences_length",
      "scale",
      "target",
      "target_observed_values",
      "time_feat",
      "repeated_static_feat",
      "is_padded_indicator",
      "state",
      "i"
    ],
    "impute_target_if_unobserved": [
      "self",
      "F",
      "output",
      "scale",
      "current_target",
      "current_observed_indicator",
      "is_pad"
    ],
    "insert_imputed_target": [
      "self",
      "F",
      "i",
      "subsequences_length",
      "pre_sequence",
      "post_sequence",
      "target_value"
    ],
    "unroll_encoder_imputation": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "unroll_encoder_default": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "post_process_samples": [
      "self",
      "F",
      "samples"
    ]
  },
  "DeepARTrainingNetwork": {
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "distribution": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "return_rnn_outputs"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target",
      "future_observed_values"
    ]
  },
  "DeepARPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "F",
      "static_feat",
      "past_target",
      "time_feat",
      "scale",
      "begin_states"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "past_is_pad"
    ]
  },
  "NBEATSEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "trainer",
      "num_stacks",
      "widths",
      "num_blocks",
      "num_block_layers",
      "expansion_coefficient_lengths",
      "sharing",
      "stack_types",
      "loss_function",
      "train_sampler",
      "validation_sampler",
      "batch_size",
      "scale"
    ],
    "_validate_nbeats_argument": [
      "self",
      "argument_value",
      "argument_name",
      "default_value",
      "validation_condition",
      "invalidation_message"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "VALID_N_BEATS_STACK_TYPES": [],
  "VALID_LOSS_FUNCTIONS": [],
  "linear_space": [
    "F",
    "backcast_length",
    "forecast_length",
    "fwd_looking"
  ],
  "seasonality_model": [
    "F",
    "num_coefficients",
    "context_length",
    "prediction_length",
    "is_forecast"
  ],
  "trend_model": [
    "F",
    "num_coefficients",
    "context_length",
    "prediction_length",
    "is_forecast"
  ],
  "NBEATSBlock": {
    "__init__": [
      "self",
      "width",
      "num_block_layers",
      "expansion_coefficient_length",
      "prediction_length",
      "context_length",
      "has_backcast"
    ],
    "initialize_basis": [
      "self",
      "F"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "NBEATSGenericBlock": {
    "__init__": [
      "self"
    ]
  },
  "NBEATSSeasonalBlock": {
    "__init__": [
      "self"
    ],
    "initialize_basis": [
      "self",
      "F"
    ]
  },
  "NBEATSTrendBlock": {
    "__init__": [
      "self"
    ],
    "initialize_basis": [
      "self",
      "F"
    ]
  },
  "NBEATSNetwork": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "num_stacks",
      "widths",
      "num_blocks",
      "num_block_layers",
      "expansion_coefficient_lengths",
      "sharing",
      "stack_types",
      "scale"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ],
    "smape_loss": [
      "self",
      "F",
      "forecast",
      "future_target",
      "future_observed_values"
    ],
    "mape_loss": [
      "self",
      "F",
      "forecast",
      "future_target",
      "future_observed_values"
    ],
    "mase_loss": [
      "self",
      "F",
      "forecast",
      "future_target",
      "past_target",
      "periodicity",
      "future_observed_values"
    ]
  },
  "NBEATSTrainingNetwork": {
    "__init__": [
      "self",
      "loss_function",
      "freq"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "NBEATSPredictionNetwork": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "AGGREGATION_METHODS": [],
  "NBEATSEnsemblePredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "predictors",
      "aggregation_method"
    ],
    "set_aggregation_method": [
      "self",
      "aggregation_method"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path",
      "ctx"
    ],
    "hybridize": [
      "self",
      "batch"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "__eq__": [
      "self",
      "that"
    ]
  },
  "NBEATSEnsembleEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "meta_context_length",
      "meta_loss_function",
      "meta_bagging_size",
      "trainer",
      "num_stacks",
      "widths",
      "num_blocks",
      "num_block_layers",
      "expansion_coefficient_lengths",
      "sharing",
      "stack_types",
      "aggregation_method"
    ],
    "_estimator_factory": [
      "self"
    ],
    "from_hyperparameters": [
      "cls"
    ],
    "_train": [
      "self",
      "training_data",
      "validation_data",
      "from_predictor"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data"
    ],
    "train_from": [
      "self",
      "predictor",
      "training_data",
      "validation_data"
    ]
  },
  "DeepRenewalProcessEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "num_cells",
      "num_layers",
      "dropout_rate",
      "interval_distr_output",
      "size_distr_output",
      "train_sampler",
      "validation_sampler",
      "trainer",
      "batch_size",
      "num_parallel_samples"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "_create_post_split_transform": [],
    "_stack_fn": [
      "self"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "DeepRenewalNetwork": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "interval_distr_output",
      "size_distr_output",
      "num_cells",
      "num_layers",
      "dropout_rate"
    ],
    "begin_state": [
      "self",
      "batch_size"
    ],
    "distribution": [
      "self",
      "cond_mean",
      "interval_alpha_bias",
      "size_alpha_bias"
    ],
    "forwardshift": [
      "A"
    ],
    "mu_map": [
      "self",
      "data",
      "shift",
      "state"
    ]
  },
  "DeepRenewalTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "valid_length",
      "interval_alpha_bias",
      "size_alpha_bias"
    ]
  },
  "DeepRenewalPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "F",
      "past_target",
      "interval_alpha_bias",
      "size_alpha_bias",
      "time_remaining"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "time_remaining",
      "interval_alpha_bias",
      "size_alpha_bias"
    ]
  },
  "DeepRenewalProcessSampleOutputTransform": {
    "__call__": [
      "self",
      "entry",
      "output"
    ]
  },
  "DeepRenewalProcessPredictor": {
    "BlockType": [],
    "__init__": [
      "self",
      "prediction_net",
      "batch_size",
      "prediction_length",
      "ctx",
      "input_transform",
      "input_names",
      "lead_time",
      "forecast_generator",
      "output_transform",
      "dtype"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "deserialize": [
      "cls",
      "path",
      "ctx"
    ]
  },
  "AddAxisLength": {
    "__init__": [
      "self",
      "target_field",
      "axis",
      "output_field"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "GaussianProcessEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "trainer",
      "context_length",
      "kernel_output",
      "params_scaling",
      "dtype",
      "max_iter_jitter",
      "jitter_method",
      "sample_noise",
      "time_features",
      "num_parallel_samples",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "GaussianProcessNetworkBase": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "cardinality",
      "kernel_output",
      "params_scaling",
      "float_type",
      "max_iter_jitter",
      "jitter_method"
    ],
    "get_gp_params": [
      "self",
      "F",
      "past_target",
      "past_time_feat",
      "feat_static_cat"
    ]
  },
  "GaussianProcessTrainingNetwork": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_time_feat",
      "feat_static_cat"
    ]
  },
  "GaussianProcessPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples",
      "sample_noise"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_time_feat",
      "future_time_feat",
      "feat_static_cat"
    ]
  },
  "GaussianProcess": {
    "__init__": [
      "self",
      "sigma",
      "kernel",
      "prediction_length",
      "context_length",
      "num_samples",
      "float_type",
      "jitter_method",
      "max_iter_jitter",
      "neg_tol",
      "diag_weight",
      "increase_jitter",
      "sample_noise",
      "F"
    ],
    "_compute_cholesky_gp": [
      "self",
      "kernel_matrix",
      "num_data_points",
      "noise"
    ],
    "log_prob": [
      "self",
      "x_train",
      "y_train"
    ],
    "sample": [
      "self",
      "mean",
      "covariance"
    ],
    "exact_inference": [
      "self",
      "x_train",
      "y_train",
      "x_test"
    ],
    "plot": [
      "ts_idx",
      "x_train",
      "y_train",
      "x_test",
      "mean",
      "std",
      "samples",
      "axis"
    ]
  },
  "_make_block_diagonal": [
    "blocks"
  ],
  "_make_2_block_diagonal": [
    "F",
    "left",
    "right"
  ],
  "ISSM": {
    "__init__": [
      "self"
    ],
    "latent_dim": [
      "self"
    ],
    "output_dim": [
      "self"
    ],
    "time_features": [
      "self"
    ],
    "emission_coeff": [
      "self",
      "features"
    ],
    "transition_coeff": [
      "self",
      "features"
    ],
    "innovation_coeff": [
      "self",
      "features"
    ],
    "get_issm_coeff": [
      "self",
      "features"
    ]
  },
  "LevelISSM": {
    "latent_dim": [
      "self"
    ],
    "output_dim": [
      "self"
    ],
    "time_features": [
      "self"
    ],
    "emission_coeff": [
      "self",
      "feature"
    ],
    "transition_coeff": [
      "self",
      "feature"
    ],
    "innovation_coeff": [
      "self",
      "feature"
    ]
  },
  "LevelTrendISSM": {
    "latent_dim": [
      "self"
    ],
    "output_dim": [
      "self"
    ],
    "time_features": [
      "self"
    ],
    "transition_coeff": [
      "self",
      "feature"
    ]
  },
  "SeasonalityISSM": {
    "__init__": [
      "self",
      "num_seasons",
      "time_feature"
    ],
    "latent_dim": [
      "self"
    ],
    "output_dim": [
      "self"
    ],
    "time_features": [
      "self"
    ],
    "emission_coeff": [
      "self",
      "feature"
    ],
    "innovation_coeff": [
      "self",
      "feature"
    ]
  },
  "MonthOfYearSeasonalISSM": [],
  "WeekOfYearSeasonalISSM": [],
  "DayOfWeekSeasonalISSM": [],
  "HourOfDaySeasonalISSM": [],
  "MinuteOfHourSeasonalISSM": [],
  "CompositeISSM": {
    "__init__": [
      "self",
      "seasonal_issms",
      "add_trend"
    ],
    "latent_dim": [
      "self"
    ],
    "output_dim": [
      "self"
    ],
    "time_features": [
      "self"
    ],
    "get_from_freq": [
      "cls",
      "freq",
      "add_trend"
    ],
    "get_issm_coeff": [
      "self",
      "features"
    ]
  },
  "SEASON_INDICATORS_FIELD": [],
  "FREQ_LONGEST_PERIOD_DICT": [],
  "longest_period_from_frequency_str": [
    "freq_str"
  ],
  "DeepStateEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "add_trend",
      "past_length",
      "num_periods_to_train",
      "trainer",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "embedding_dimension",
      "issm",
      "scaling",
      "time_features",
      "noise_std_bounds",
      "prior_cov_bounds",
      "innovation_bounds",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "DeepStateNetwork": {
    "__init__": [
      "self",
      "num_layers",
      "num_cells",
      "cell_type",
      "past_length",
      "prediction_length",
      "issm",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "scaling",
      "noise_std_bounds",
      "prior_cov_bounds",
      "innovation_bounds"
    ],
    "compute_lds": [
      "self",
      "F",
      "feat_static_cat",
      "seasonal_indicators",
      "time_feat",
      "length",
      "prior_mean",
      "prior_cov",
      "lstm_begin_state"
    ]
  },
  "DeepStateTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_observed_values",
      "past_seasonal_indicators",
      "past_time_feat",
      "past_target"
    ]
  },
  "DeepStatePredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_observed_values",
      "past_seasonal_indicators",
      "past_time_feat",
      "past_target",
      "future_seasonal_indicators",
      "future_time_feat"
    ]
  },
  "LSTNetEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "num_series",
      "skip_size",
      "ar_window",
      "channels",
      "lead_time",
      "kernel_size",
      "trainer",
      "dropout_rate",
      "output_activation",
      "rnn_cell_type",
      "rnn_num_cells",
      "rnn_num_layers",
      "skip_rnn_cell_type",
      "skip_rnn_num_layers",
      "skip_rnn_num_cells",
      "scaling",
      "train_sampler",
      "validation_sampler",
      "batch_size",
      "dtype"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "LSTNetBase": {
    "__init__": [
      "self",
      "num_series",
      "channels",
      "kernel_size",
      "rnn_cell_type",
      "rnn_num_layers",
      "rnn_num_cells",
      "skip_rnn_cell_type",
      "skip_rnn_num_layers",
      "skip_rnn_num_cells",
      "skip_size",
      "ar_window",
      "context_length",
      "lead_time",
      "prediction_length",
      "dropout_rate",
      "output_activation",
      "scaling",
      "dtype"
    ],
    "_create_rnn_layer": [
      "num_cells",
      "num_layers",
      "cell_type",
      "dropout_rate"
    ],
    "_skip_rnn_layer": [
      "self",
      "F",
      "x"
    ],
    "_ar_highway": [
      "self",
      "F",
      "x",
      "observed"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values"
    ]
  },
  "LSTNetTrain": {
    "__init__": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "LSTNetPredict": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values"
    ]
  },
  "DeepFactorEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "num_hidden_global",
      "num_layers_global",
      "num_factors",
      "num_hidden_local",
      "num_layers_local",
      "cell_type",
      "trainer",
      "context_length",
      "num_parallel_samples",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "DeepFactorNetworkBase": {
    "__init__": [
      "self",
      "global_model",
      "local_model",
      "embedder"
    ],
    "assemble_features": [
      "self",
      "F",
      "feat_static_cat",
      "time_feat"
    ],
    "compute_global_local": [
      "self",
      "F",
      "feat_static_cat",
      "time_feat"
    ],
    "negative_normal_likelihood": [
      "self",
      "F",
      "y",
      "mu",
      "sigma"
    ]
  },
  "DeepFactorTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "past_target"
    ]
  },
  "DeepFactorPredictionNetwork": {
    "__init__": [
      "self",
      "prediction_len",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "future_time_feat",
      "past_target"
    ]
  },
  "RNNModel": {
    "__init__": [
      "self",
      "mode",
      "num_hidden",
      "num_layers",
      "num_output",
      "bidirectional"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "inputs"
    ]
  },
  "GPVAREstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "target_dim",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "target_dim_sample",
      "distr_output",
      "rank",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "shuffle_target_dim",
      "time_features",
      "conditioning_length",
      "use_marginal_transformation",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "GPVARNetwork": {
    "__init__": [
      "self",
      "target_dim_sample"
    ],
    "unroll": [
      "self",
      "F",
      "lags",
      "scale",
      "time_feat",
      "target_dimension_indicator",
      "unroll_length",
      "begin_state"
    ],
    "distr": [
      "self",
      "rnn_outputs",
      "time_features",
      "scale",
      "lags_scaled",
      "target_dimension_indicator",
      "seq_len"
    ]
  },
  "GPVARTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ]
  },
  "GPVARPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "make_states": [
      "self",
      "begin_states"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ]
  },
  "projection_mat": [
    "S",
    "D"
  ],
  "DeepVARHierarchicalEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "S",
      "D",
      "num_samples_for_loss",
      "likelihood_weight",
      "CRPS_weight",
      "sample_LH",
      "coherent_train_samples",
      "coherent_pred_samples",
      "warmstart_epoch_frac",
      "seq_axis",
      "log_coherency_error",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "use_feat_dynamic_real",
      "cardinality",
      "embedding_dimension",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "time_features",
      "batch_size"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "reconcile_samples": [
    "reconciliation_mat",
    "samples",
    "seq_axis"
  ],
  "coherency_error": [
    "S",
    "samples"
  ],
  "DeepVARHierarchicalNetwork": {
    "__init__": [
      "self",
      "M",
      "S",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "distr_output",
      "dropout_rate",
      "lags_seq",
      "target_dim",
      "cardinality",
      "embedding_dimension",
      "scaling",
      "seq_axis"
    ],
    "get_samples_for_loss": [
      "self",
      "distr"
    ],
    "loss": [
      "self",
      "F",
      "target",
      "distr"
    ],
    "post_process_samples": [
      "self",
      "samples"
    ]
  },
  "DeepVARHierarchicalTrainingNetwork": {
    "__init__": [
      "self",
      "num_samples_for_loss",
      "likelihood_weight",
      "CRPS_weight",
      "coherent_train_samples",
      "warmstart_epoch_frac",
      "epochs",
      "num_batches_per_epoch",
      "sample_LH"
    ]
  },
  "DeepVARHierarchicalPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples",
      "log_coherency_error",
      "coherent_pred_samples"
    ]
  },
  "PointProcessSampleForecast": {
    "prediction_length": [],
    "mean": [],
    "_index": [],
    "__init__": [
      "self",
      "samples",
      "valid_length",
      "start_date",
      "freq",
      "prediction_interval_length",
      "item_id",
      "info"
    ],
    "dim": [
      "self"
    ],
    "freq": [
      "self"
    ],
    "index": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "quantile": [
      "self",
      "q"
    ],
    "plot": [
      "self"
    ]
  },
  "PointProcessForecastGenerator": {
    "__call__": [
      "self",
      "inference_data_loader",
      "prediction_net",
      "input_names",
      "output_transform",
      "num_samples",
      "freq"
    ]
  },
  "PointProcessGluonPredictor": {
    "__init__": [
      "self",
      "input_names",
      "prediction_net",
      "batch_size",
      "prediction_interval_length",
      "freq",
      "ctx",
      "input_transform",
      "dtype",
      "forecast_generator"
    ],
    "hybridize": [
      "self",
      "batch"
    ],
    "as_symbol_block_predictor": [
      "self",
      "batch",
      "dataset"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples",
      "num_workers",
      "num_prefetch"
    ],
    "serialize_prediction_net": [
      "self",
      "path"
    ]
  },
  "Weibull": {
    "is_reparametrizable": [],
    "__init__": [
      "self",
      "rate",
      "shape"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "log_intensity": [
      "self",
      "x"
    ],
    "log_survival": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype",
      "lower_bound"
    ]
  },
  "WeibullOutput": {
    "domain_map": [
      "cls",
      "F",
      "rate",
      "shape"
    ],
    "event_shape": [
      "self"
    ]
  },
  "TPPDistribution": {
    "log_intensity": [
      "self",
      "x"
    ],
    "log_survival": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "y"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype",
      "lower_bound"
    ]
  },
  "TPPTransformedDistribution": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms"
    ],
    "_check_signs": [
      "self",
      "transforms"
    ],
    "log_intensity": [
      "self",
      "y"
    ],
    "log_survival": [
      "self",
      "y"
    ],
    "cdf": [
      "self",
      "y"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype",
      "lower_bound"
    ]
  },
  "TPPDistributionOutput": {
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ]
  },
  "Loglogistic": {
    "is_reparametrizable": [],
    "__init__": [
      "self",
      "mu",
      "sigma"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "log_intensity": [
      "self",
      "x"
    ],
    "log_survival": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "num_samples",
      "dtype",
      "lower_bound"
    ]
  },
  "LoglogisticOutput": {
    "domain_map": [
      "cls",
      "F",
      "mu",
      "sigma"
    ],
    "event_shape": [
      "self"
    ]
  },
  "DeepTPPEstimator": {
    "__init__": [
      "self",
      "prediction_interval_length",
      "context_interval_length",
      "num_marks",
      "time_distr_output",
      "embedding_dim",
      "trainer",
      "num_hidden_dimensions",
      "num_parallel_samples",
      "num_training_instances",
      "freq",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "DeepTPPNetworkBase": {
    "__init__": [
      "self",
      "num_marks",
      "interval_length",
      "time_distr_output",
      "embedding_dim",
      "num_hidden_dimensions",
      "output_scale",
      "apply_log_to_rnn_inputs"
    ],
    "hybridize": [
      "self",
      "active"
    ]
  },
  "DeepTPPTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "target",
      "valid_length"
    ]
  },
  "DeepTPPPredictionNetwork": {
    "__init__": [
      "self",
      "prediction_interval_length",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_valid_length"
    ]
  },
  "CanonicalEstimator": {
    "__init__": [
      "self",
      "model",
      "is_sequential",
      "freq",
      "context_length",
      "prediction_length",
      "trainer",
      "num_parallel_samples",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "CanonicalRNNEstimator": {
    "__init__": [
      "self",
      "freq",
      "context_length",
      "prediction_length",
      "trainer",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "cardinality",
      "embedding_dimension",
      "distr_output"
    ]
  },
  "MLPForecasterEstimator": {
    "__init__": [
      "self",
      "freq",
      "context_length",
      "prediction_length",
      "trainer",
      "hidden_dim_sequence",
      "num_parallel_samples",
      "cardinality",
      "embedding_dimension",
      "distr_output"
    ]
  },
  "CanonicalNetworkBase": {
    "__init__": [
      "self",
      "model",
      "embedder",
      "distr_output",
      "is_sequential"
    ],
    "assemble_features": [
      "self",
      "F",
      "feat_static_cat",
      "time_feat"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "CanonicalTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "past_target"
    ]
  },
  "CanonicalPredictionNetwork": {
    "__init__": [
      "self",
      "prediction_len",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "future_time_feat",
      "past_target"
    ]
  },
  "QuantizeScaled": {
    "__init__": [
      "self",
      "bin_edges",
      "past_target",
      "future_target",
      "scale"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "WaveNetEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "trainer",
      "cardinality",
      "seasonality",
      "embedding_dimension",
      "num_bins",
      "hybridize_prediction_net",
      "n_residue",
      "n_skip",
      "dilation_depth",
      "n_stacks",
      "train_window_length",
      "temperature",
      "act_type",
      "num_parallel_samples",
      "train_sampler",
      "validation_sampler",
      "batch_size",
      "negative_data"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "_get_wavenet_args": [
      "self"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "LookupValues": {
    "__init__": [
      "self",
      "values"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "indices",
      "bin_values"
    ]
  },
  "conv1d": [
    "channels",
    "kernel_size",
    "in_channels",
    "use_bias"
  ],
  "CausalDilatedResidue": {
    "__init__": [
      "self",
      "n_residue",
      "n_skip",
      "dilation",
      "return_dense_out",
      "kernel_size"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "WaveNet": {
    "__init__": [
      "self",
      "bin_values",
      "n_residue",
      "n_skip",
      "dilation_depth",
      "n_stacks",
      "act_type",
      "cardinality",
      "embedding_dimension",
      "pred_length"
    ],
    "_get_dilations": [
      "dilation_depth",
      "n_stacks"
    ],
    "get_receptive_field": [
      "dilation_depth",
      "n_stacks"
    ],
    "is_last_layer": [
      "self",
      "i"
    ],
    "get_full_features": [
      "self",
      "F",
      "feat_static_cat",
      "past_observed_values",
      "past_time_feat",
      "future_time_feat",
      "future_observed_values",
      "scale"
    ],
    "target_feature_embedding": [
      "self",
      "F",
      "target",
      "features"
    ],
    "base_net": [
      "self",
      "F",
      "inputs",
      "one_step_prediction",
      "queues"
    ]
  },
  "WaveNetTraining": {
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_target",
      "past_observed_values",
      "past_time_feat",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "scale"
    ]
  },
  "WaveNetSampler": {
    "__init__": [
      "self",
      "bin_values",
      "num_samples",
      "temperature"
    ],
    "get_initial_conv_queues": [
      "self",
      "F",
      "past_target",
      "features"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_target",
      "past_observed_values",
      "past_time_feat",
      "future_time_feat",
      "scale"
    ]
  },
  "FourierDateFeatures": {
    "__init__": [
      "self",
      "freq"
    ],
    "__call__": [
      "self",
      "index"
    ]
  },
  "DeepVAREstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "target_dim",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "use_feat_dynamic_real",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "rank",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "time_features",
      "conditioning_length",
      "use_marginal_transformation",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "make_rnn_cell": [
    "num_cells",
    "num_layers",
    "cell_type",
    "residual",
    "dropout_rate"
  ],
  "DeepVARNetwork": {
    "__init__": [
      "self",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "distr_output",
      "dropout_rate",
      "lags_seq",
      "target_dim",
      "cardinality",
      "embedding_dimension",
      "scaling"
    ],
    "get_lagged_subsequences": [
      "F",
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "unroll": [
      "self",
      "F",
      "lags",
      "scale",
      "time_feat",
      "target_dimension_indicator",
      "unroll_length",
      "begin_state"
    ],
    "unroll_encoder": [
      "self",
      "F",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "target_dimension_indicator"
    ],
    "distr": [
      "self",
      "rnn_outputs",
      "time_features",
      "scale",
      "lags_scaled",
      "target_dimension_indicator",
      "seq_len"
    ],
    "loss": [
      "self",
      "F",
      "target",
      "distr"
    ],
    "train_hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ],
    "sampling_decoder": [
      "self",
      "F",
      "past_target_cdf",
      "target_dimension_indicator",
      "time_feat",
      "scale",
      "begin_states"
    ],
    "make_states": [
      "self",
      "begin_states"
    ],
    "predict_hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ],
    "post_process_samples": [
      "self",
      "samples"
    ]
  },
  "DeepVARTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ]
  },
  "DeepVARPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ]
  },
  "ForkingSeq2SeqEstimator": {
    "__init__": [
      "self",
      "encoder",
      "decoder",
      "freq",
      "prediction_length",
      "quantile_output",
      "distr_output",
      "context_length",
      "use_past_feat_dynamic_real",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "cardinality",
      "embedding_dimension",
      "add_time_feature",
      "add_age_feature",
      "enable_encoder_dynamic_feature",
      "enable_decoder_dynamic_feature",
      "trainer",
      "scaling",
      "scaling_decoder_dynamic_feature",
      "dtype",
      "num_forking",
      "max_ts_len",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "Seq2SeqEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "embedding_dimension",
      "encoder",
      "decoder_mlp_layer",
      "decoder_mlp_static_dim",
      "scaler",
      "context_length",
      "quantiles",
      "trainer",
      "train_sampler",
      "validation_sampler",
      "num_parallel_samples",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "MLP2QRForecaster": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "embedding_dimension",
      "encoder_mlp_layer",
      "decoder_mlp_layer",
      "decoder_mlp_static_dim",
      "scaler",
      "context_length",
      "quantiles",
      "trainer",
      "num_parallel_samples"
    ]
  },
  "RNN2QRForecaster": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "embedding_dimension",
      "encoder_rnn_layer",
      "encoder_rnn_num_hidden",
      "decoder_mlp_layer",
      "decoder_mlp_static_dim",
      "encoder_rnn_model",
      "encoder_rnn_bidirectional",
      "scaler",
      "context_length",
      "quantiles",
      "trainer",
      "num_parallel_samples"
    ]
  },
  "CNN2QRForecaster": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinality",
      "embedding_dimension",
      "decoder_mlp_layer",
      "decoder_mlp_static_dim",
      "scaler",
      "context_length",
      "quantiles",
      "trainer",
      "num_parallel_samples"
    ]
  },
  "MQCNNEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "use_past_feat_dynamic_real",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "cardinality",
      "embedding_dimension",
      "add_time_feature",
      "add_age_feature",
      "enable_encoder_dynamic_feature",
      "enable_decoder_dynamic_feature",
      "seed",
      "decoder_mlp_dim_seq",
      "channels_seq",
      "dilation_seq",
      "kernel_size_seq",
      "use_residual",
      "quantiles",
      "distr_output",
      "trainer",
      "scaling",
      "scaling_decoder_dynamic_feature",
      "num_forking",
      "max_ts_len",
      "is_iqf",
      "batch_size",
      "train_sampler",
      "validation_sampler"
    ],
    "derive_auto_fields": [
      "cls",
      "train_iter"
    ],
    "from_inputs": [
      "cls",
      "train_iter"
    ]
  },
  "MQRNNEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "freq",
      "context_length",
      "decoder_mlp_dim_seq",
      "trainer",
      "quantiles",
      "distr_output",
      "scaling",
      "scaling_decoder_dynamic_feature",
      "num_forking",
      "is_iqf",
      "batch_size",
      "train_sampler",
      "validation_sampler"
    ]
  },
  "Seq2SeqNetworkBase": {
    "__init__": [
      "self",
      "embedder",
      "scaler",
      "encoder",
      "enc2dec",
      "decoder",
      "quantile_output"
    ],
    "compute_decoder_outputs": [
      "self",
      "F",
      "past_target",
      "feat_static_cat",
      "past_feat_dynamic_real",
      "future_feat_dynamic_real"
    ]
  },
  "Seq2SeqTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "future_target",
      "feat_static_cat",
      "past_feat_dynamic_real",
      "future_feat_dynamic_real"
    ]
  },
  "Seq2SeqPredictionNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "feat_static_cat",
      "past_feat_dynamic_real",
      "future_feat_dynamic_real"
    ]
  },
  "ForkingSeq2SeqNetworkBase": {
    "__init__": [
      "self",
      "encoder",
      "enc2dec",
      "decoder",
      "context_length",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "quantile_output",
      "scaling",
      "scaling_decoder_dynamic_feature",
      "dtype",
      "num_forking"
    ],
    "get_decoder_network_output": [
      "self",
      "F",
      "past_target",
      "past_feat_dynamic",
      "future_feat_dynamic",
      "feat_static_cat",
      "past_observed_values"
    ]
  },
  "ForkingSeq2SeqTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "future_target",
      "past_feat_dynamic",
      "future_feat_dynamic",
      "feat_static_cat",
      "past_observed_values",
      "future_observed_values"
    ]
  },
  "ForkingSeq2SeqPredictionNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_feat_dynamic",
      "future_feat_dynamic",
      "feat_static_cat",
      "past_observed_values"
    ]
  },
  "ForkingSeq2SeqDistributionPredictionNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_feat_dynamic",
      "future_feat_dynamic",
      "feat_static_cat",
      "past_observed_values"
    ]
  },
  "ForkingSequenceSplitter": {
    "__init__": [
      "self",
      "instance_sampler",
      "enc_len",
      "dec_len",
      "num_forking",
      "target_field",
      "encoder_series_fields",
      "decoder_series_fields",
      "encoder_disabled_fields",
      "decoder_disabled_fields",
      "prediction_time_decoder_exclude",
      "is_pad_out",
      "start_input_field"
    ],
    "_past": [
      "self",
      "col_name"
    ],
    "_future": [
      "self",
      "col_name"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "_default_feat_args": [
    "dims_or_cardinalities"
  ],
  "TemporalFusionTransformerEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "trainer",
      "hidden_dim",
      "variable_dim",
      "num_heads",
      "quantiles",
      "num_instance_per_series",
      "dropout_rate",
      "time_features",
      "static_cardinalities",
      "dynamic_cardinalities",
      "static_feature_dims",
      "dynamic_feature_dims",
      "past_dynamic_features",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "FeatureProjector": {
    "__init__": [
      "self",
      "feature_dims",
      "embedding_dims",
      "dtype"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "features"
    ]
  },
  "TemporalFusionTransformerNetwork": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_var",
      "d_hidden",
      "n_head",
      "quantiles",
      "d_past_feat_dynamic_real",
      "c_past_feat_dynamic_cat",
      "d_feat_dynamic_real",
      "c_feat_dynamic_cat",
      "d_feat_static_real",
      "c_feat_static_cat",
      "dropout"
    ],
    "_preprocess": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ],
    "_postprocess": [
      "self",
      "F",
      "preds",
      "offset",
      "scale"
    ],
    "_forward": [
      "self",
      "F",
      "past_observed_values",
      "past_covariates",
      "future_covariates",
      "static_covariates"
    ]
  },
  "TemporalFusionTransformerTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ]
  },
  "TemporalFusionTransformerPredictionNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ]
  },
  "GatedLinearUnit": {
    "__init__": [
      "self",
      "axis",
      "nonlinear"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "GatedResidualNetwork": {
    "__init__": [
      "self",
      "d_hidden",
      "d_input",
      "d_output",
      "d_static",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "c"
    ]
  },
  "VariableSelectionNetwork": {
    "__init__": [
      "self",
      "d_hidden",
      "n_vars",
      "dropout",
      "add_static"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "variables",
      "static"
    ]
  },
  "SelfAttention": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_hidden",
      "n_head",
      "bias",
      "share_values",
      "dropout",
      "temperature"
    ],
    "_split_head": [
      "self",
      "F",
      "x"
    ],
    "_merge_head": [
      "self",
      "F",
      "x"
    ],
    "_compute_qkv": [
      "self",
      "F",
      "x"
    ],
    "_apply_mask": [
      "self",
      "F",
      "score",
      "key_mask"
    ],
    "_compute_attn_score": [
      "self",
      "F",
      "q",
      "k",
      "mask"
    ],
    "_compute_attn_output": [
      "self",
      "F",
      "score",
      "v"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "mask"
    ]
  },
  "TemporalFusionEncoder": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_input",
      "d_hidden"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "ctx_input",
      "tgt_input",
      "states"
    ]
  },
  "TemporalFusionDecoder": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_hidden",
      "d_var",
      "n_head",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "static",
      "mask"
    ]
  },
  "BroadcastTo": {
    "__init__": [
      "self",
      "field",
      "ext_length",
      "target_field"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "TransformerEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "trainer",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "model_dim",
      "inner_ff_dim_scale",
      "pre_seq",
      "post_seq",
      "act_type",
      "num_heads",
      "scaling",
      "lags_seq",
      "time_features",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "num_parallel_samples",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "LARGE_NEGATIVE_VALUE": [],
  "TransformerNetwork": {
    "__init__": [
      "self",
      "encoder",
      "decoder",
      "history_length",
      "context_length",
      "prediction_length",
      "distr_output",
      "cardinality",
      "embedding_dimension",
      "lags_seq",
      "scaling"
    ],
    "get_lagged_subsequences": [
      "F",
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "create_network_input": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "upper_triangular_mask": [
      "F",
      "d"
    ]
  },
  "TransformerTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values"
    ]
  },
  "TransformerPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "F",
      "static_feat",
      "past_target",
      "time_feat",
      "scale",
      "enc_out"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat"
    ]
  },
  "split_heads": [
    "F",
    "x",
    "dim_per_head",
    "heads"
  ],
  "dot_attention": [
    "F",
    "queries",
    "keys",
    "values",
    "mask",
    "dropout"
  ],
  "combine_heads": [
    "F",
    "x",
    "dim_per_head",
    "heads"
  ],
  "LayerNormalization": {
    "__init__": [
      "self",
      "scale_init",
      "shift_init",
      "eps"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data"
    ]
  },
  "InputLayer": {
    "__init__": [
      "self",
      "model_size"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data"
    ]
  },
  "MultiHeadAttentionBase": {
    "__init__": [
      "self",
      "att_dim_in",
      "heads",
      "att_dim_out",
      "dropout"
    ],
    "_attend": [
      "self",
      "F",
      "queries",
      "keys",
      "values",
      "mask"
    ]
  },
  "MultiHeadSelfAttention": {
    "__init__": [
      "self",
      "att_dim_in",
      "heads",
      "att_dim_out",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "inputs",
      "mask",
      "cache"
    ]
  },
  "MultiHeadAttention": {
    "__init__": [
      "self",
      "att_dim_in",
      "heads",
      "att_dim_out",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "queries",
      "memory",
      "mask"
    ]
  },
  "TransformerFeedForward": {
    "__init__": [
      "self",
      "inner_dim",
      "out_dim",
      "act_type",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "TransformerProcessBlock": {
    "__init__": [
      "self",
      "sequence",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "prev"
    ]
  },
  "TransformerEncoder": {
    "__init__": [
      "self",
      "encoder_length",
      "config"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data"
    ]
  },
  "TransformerDecoder": {
    "__init__": [
      "self",
      "decoder_length",
      "config"
    ],
    "cache_reset": [
      "self"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "data",
      "enc_out",
      "mask",
      "is_train"
    ]
  },
  "SimpleFeedForwardEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "sampling",
      "trainer",
      "num_hidden_dimensions",
      "context_length",
      "distr_output",
      "imputation_method",
      "batch_normalization",
      "mean_scaling",
      "num_parallel_samples",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "SimpleFeedForwardNetworkBase": {
    "__init__": [
      "self",
      "num_hidden_dimensions",
      "prediction_length",
      "context_length",
      "batch_normalization",
      "mean_scaling",
      "distr_output"
    ],
    "get_distr_args": [
      "self",
      "F",
      "past_target"
    ]
  },
  "SimpleFeedForwardTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "future_target",
      "future_observed_values"
    ]
  },
  "SimpleFeedForwardSamplingNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target"
    ]
  },
  "SimpleFeedForwardDistributionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "past_target"
    ]
  },
  "calculate_seasonal_error": [
    "past_data",
    "freq",
    "seasonality"
  ],
  "abs_error": [
    "target",
    "forecast"
  ],
  "abs_target_sum": [
    "target"
  ],
  "abs_target_mean": [
    "target"
  ],
  "num_masked_values": [
    "target"
  ],
  "_to_dataframe": [
    "input_label"
  ],
  "make_evaluation_predictions": [
    "dataset",
    "predictor",
    "num_samples"
  ],
  "train_dataset_stats_key": [],
  "test_dataset_stats_key": [],
  "estimator_key": [],
  "agg_metrics_key": [],
  "serialize_message": [
    "logger",
    "message",
    "variable"
  ],
  "backtest_metrics": [
    "test_dataset",
    "predictor",
    "evaluator",
    "num_samples",
    "logging_file"
  ],
  "worker_function": [
    "evaluator",
    "inp"
  ],
  "aggregate_all": [
    "metric_per_ts",
    "agg_funs"
  ],
  "aggregate_no_nan": [
    "metric_per_ts",
    "agg_funs"
  ],
  "aggregate_valid": [
    "metric_per_ts",
    "agg_funs"
  ],
  "validate_forecast": [
    "forecast",
    "quantiles"
  ],
  "Evaluator": {
    "default_quantiles": [],
    "__init__": [
      "self",
      "quantiles",
      "seasonality",
      "alpha",
      "calculate_owa",
      "custom_eval_fn",
      "num_workers",
      "chunk_size",
      "aggregation_strategy",
      "ignore_invalid_values",
      "allow_nan_forecast"
    ],
    "__call__": [
      "self",
      "ts_iterator",
      "fcst_iterator",
      "num_series"
    ],
    "extract_pred_target": [
      "time_series",
      "forecast"
    ],
    "extract_past_data": [
      "time_series",
      "forecast"
    ],
    "get_base_metrics": [
      "self",
      "forecast",
      "pred_target",
      "mean_fcst",
      "median_fcst",
      "seasonal_error"
    ],
    "get_metrics_per_ts": [
      "self",
      "time_series",
      "forecast"
    ],
    "get_aggregate_metrics": [
      "self",
      "metric_per_ts"
    ]
  },
  "MultivariateEvaluator": {
    "__init__": [
      "self",
      "quantiles",
      "seasonality",
      "alpha",
      "eval_dims",
      "target_agg_funcs",
      "custom_eval_fn",
      "num_workers"
    ],
    "extract_target_by_dim": [
      "it_iterator",
      "dim"
    ],
    "extract_forecast_by_dim": [
      "forecast_iterator",
      "dim"
    ],
    "extract_aggregate_target": [
      "it_iterator",
      "agg_fun"
    ],
    "extract_aggregate_forecast": [
      "forecast_iterator",
      "agg_fun"
    ],
    "peek": [
      "iterator"
    ],
    "get_target_dimensionality": [
      "forecast"
    ],
    "get_eval_dims": [
      "self",
      "target_dimensionality"
    ],
    "calculate_aggregate_multivariate_metrics": [
      "self",
      "ts_iterator",
      "forecast_iterator",
      "agg_fun"
    ],
    "calculate_aggregate_vector_metrics": [
      "self",
      "all_agg_metrics",
      "all_metrics_per_ts"
    ],
    "__call__": [
      "self",
      "ts_iterator",
      "fcst_iterator",
      "num_series"
    ]
  },
  "target_transformation_length": [
    "target",
    "pred_length",
    "is_train"
  ],
  "MissingValueImputation": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "values"
    ]
  },
  "LeavesMissingValues": {
    "__call__": [
      "self",
      "values"
    ]
  },
  "DummyValueImputation": {
    "__init__": [
      "self",
      "dummy_value"
    ],
    "__call__": [
      "self",
      "values"
    ]
  },
  "MeanValueImputation": {
    "__call__": [
      "self",
      "values"
    ]
  },
  "LastValueImputation": {
    "__call__": [
      "self",
      "values"
    ]
  },
  "CausalMeanValueImputation": {
    "__call__": [
      "self",
      "values"
    ]
  },
  "RollingMeanValueImputation": {
    "__init__": [
      "self",
      "window_size"
    ],
    "__call__": [
      "self",
      "values"
    ]
  },
  "AddObservedValuesIndicator": {
    "__init__": [
      "self",
      "target_field",
      "output_field",
      "imputation_method",
      "dtype"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "AddConstFeature": {
    "__init__": [
      "self",
      "output_field",
      "target_field",
      "pred_length",
      "const",
      "dtype"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "AddTimeFeatures": {
    "__init__": [
      "self",
      "start_field",
      "target_field",
      "output_field",
      "time_features",
      "pred_length",
      "dtype"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "AddAgeFeature": {
    "__init__": [
      "self",
      "target_field",
      "output_field",
      "pred_length",
      "log_scale",
      "dtype"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "AddAggregateLags": {
    "__init__": [
      "self",
      "target_field",
      "output_field",
      "pred_length",
      "base_freq",
      "agg_freq",
      "agg_lags",
      "agg_fun",
      "dtype"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "CountTrailingZeros": {
    "__init__": [
      "self",
      "new_field",
      "target_field",
      "axis",
      "as_array"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "Transformation": {
    "__call__": [
      "self",
      "data_it",
      "is_train"
    ],
    "chain": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "apply": [
      "self",
      "dataset",
      "is_train"
    ]
  },
  "TransformedDataset": {
    "__init__": [
      "self",
      "base_dataset",
      "transformation",
      "is_train"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Identity": {
    "__call__": [
      "self",
      "data_it",
      "is_train"
    ]
  },
  "MapTransformation": {
    "__call__": [
      "self",
      "data_it",
      "is_train"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "SimpleTransformation": {
    "map_transform": [
      "self",
      "data",
      "is_train"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "AdhocTransform": {
    "__init__": [
      "self",
      "func"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "FlatMapTransformation": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "data_it",
      "is_train"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "FilterTransformation": {
    "__init__": [
      "self",
      "condition"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "equals_filter_transformation": [
    "this",
    "that"
  ],
  "RenameFields": {
    "__init__": [
      "self",
      "mapping"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "RemoveFields": {
    "__init__": [
      "self",
      "field_names"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "SetField": {
    "__init__": [
      "self",
      "output_field",
      "value"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "SetFieldIfNotPresent": {
    "__init__": [
      "self",
      "field",
      "value"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "SelectFields": {
    "__init__": [
      "self",
      "input_fields",
      "allow_missing"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "erf": [
    "x"
  ],
  "erfinv": [
    "x"
  ],
  "Valmap": {
    "__init__": [
      "self",
      "fn"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "AsNumpyArray": {
    "__init__": [
      "self",
      "field",
      "expected_ndim",
      "dtype"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "ExpandDimArray": {
    "__init__": [
      "self",
      "field",
      "axis"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "VstackFeatures": {
    "__init__": [
      "self",
      "output_field",
      "input_fields",
      "drop_inputs",
      "h_stack"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "ConcatFeatures": {
    "__init__": [
      "self",
      "output_field",
      "input_fields",
      "drop_inputs"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "SwapAxes": {
    "__init__": [
      "self",
      "input_fields",
      "axes"
    ],
    "transform": [
      "self",
      "data"
    ],
    "swap": [
      "self",
      "v"
    ]
  },
  "ListFeatures": {
    "__init__": [
      "self",
      "output_field",
      "input_fields",
      "drop_inputs"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "TargetDimIndicator": {
    "__init__": [
      "self",
      "field_name",
      "target_field"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "SampleTargetDim": {
    "__init__": [
      "self",
      "field_name",
      "target_field",
      "observed_values_field",
      "num_samples",
      "shuffle"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "CDFtoGaussianTransform": {
    "__init__": [
      "self",
      "target_dim",
      "target_field",
      "observed_values_field",
      "cdf_suffix",
      "max_context_length",
      "dtype"
    ],
    "map_transform": [
      "self",
      "data",
      "is_train"
    ],
    "_preprocess_data": [
      "self",
      "data",
      "is_train"
    ],
    "_calc_pw_linear_params": [
      "self",
      "data"
    ],
    "_empirical_cdf_forward_transform": [
      "self",
      "sorted_values",
      "values",
      "slopes",
      "intercepts"
    ],
    "_add_noise": [
      "x"
    ],
    "_search_sorted": [
      "sorted_vec",
      "to_insert_vec"
    ],
    "_forward_transform": [
      "self",
      "sorted_vec",
      "target",
      "slopes",
      "intercepts"
    ],
    "standard_gaussian_cdf": [
      "x"
    ],
    "standard_gaussian_ppf": [
      "y"
    ],
    "winsorized_cutoff": [
      "m"
    ],
    "_fill": [
      "target",
      "expected_length"
    ]
  },
  "cdf_to_gaussian_forward_transform": [
    "input_batch",
    "outputs"
  ],
  "ToIntervalSizeFormat": {
    "__init__": [
      "self",
      "target_field",
      "drop_empty",
      "discard_first"
    ],
    "_process_sparse_time_sample": [
      "self",
      "a"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "QuantizeMeanScaled": {
    "__init__": [
      "self",
      "bin_edges",
      "past_target_field",
      "past_observed_values_field",
      "future_target_field",
      "scale_field"
    ],
    "transform": [
      "self",
      "data"
    ]
  },
  "InstanceSplitter": {
    "__init__": [
      "self",
      "target_field",
      "is_pad_field",
      "start_field",
      "forecast_start_field",
      "instance_sampler",
      "past_length",
      "future_length",
      "lead_time",
      "output_NTC",
      "time_series_fields",
      "dummy_value"
    ],
    "_past": [
      "self",
      "col_name"
    ],
    "_future": [
      "self",
      "col_name"
    ],
    "_split_array": [
      "self",
      "array",
      "idx"
    ],
    "_split_instance": [
      "self",
      "entry",
      "idx"
    ],
    "flatmap_transform": [
      "self",
      "entry",
      "is_train"
    ]
  },
  "CanonicalInstanceSplitter": {
    "__init__": [
      "self",
      "target_field",
      "is_pad_field",
      "start_field",
      "forecast_start_field",
      "instance_sampler",
      "instance_length",
      "output_NTC",
      "time_series_fields",
      "allow_target_padding",
      "pad_value",
      "use_prediction_features",
      "prediction_length"
    ],
    "_past": [
      "self",
      "col_name"
    ],
    "_future": [
      "self",
      "col_name"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "ContinuousTimeInstanceSplitter": {
    "__init__": [
      "self",
      "past_interval_length",
      "future_interval_length",
      "freq",
      "instance_sampler",
      "target_field",
      "start_field",
      "end_field",
      "forecast_start_field"
    ],
    "_mask_sorted": [
      "self",
      "a",
      "lb",
      "ub"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "TFTInstanceSplitter": {
    "__init__": [
      "self",
      "instance_sampler",
      "past_length",
      "future_length",
      "target_field",
      "is_pad_field",
      "start_field",
      "forecast_start_field",
      "observed_value_field",
      "lead_time",
      "output_NTC",
      "time_series_fields",
      "past_time_series_fields",
      "dummy_value"
    ],
    "flatmap_transform": [
      "self",
      "data",
      "is_train"
    ]
  },
  "InstanceSampler": {
    "_get_bounds": [
      "self",
      "ts"
    ],
    "__call__": [
      "self",
      "ts"
    ]
  },
  "NumInstanceSampler": {
    "__call__": [
      "self",
      "ts"
    ]
  },
  "UniformSplitSampler": {
    "__call__": [
      "self",
      "ts"
    ]
  },
  "PredictionSplitSampler": {
    "__call__": [
      "self",
      "ts"
    ]
  },
  "ValidationSplitSampler": [
    "axis",
    "min_past",
    "min_future"
  ],
  "TestSplitSampler": [
    "axis",
    "min_past"
  ],
  "ExpectedNumInstanceSampler": {
    "__call__": [
      "self",
      "ts"
    ]
  },
  "BucketInstanceSampler": {
    "__call__": [
      "self",
      "ts"
    ]
  },
  "ContinuousTimePointSampler": {
    "_get_bounds": [
      "self",
      "interval_length"
    ],
    "__call__": [
      "self",
      "interval_length"
    ]
  },
  "ContinuousTimeUniformSampler": {
    "__call__": [
      "self",
      "interval_length"
    ]
  },
  "ContinuousTimePredictionSampler": {
    "__call__": [
      "self",
      "interval_length"
    ]
  },
  "SplitFrame": {
    "__post_init__": [
      "self"
    ],
    "past": [
      "self"
    ],
    "future": [
      "self"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "__len__": [
      "self"
    ],
    "set": [
      "self",
      "name",
      "value",
      "tdim"
    ],
    "set_like": [
      "self",
      "ref",
      "column",
      "value",
      "tdim"
    ],
    "set_past": [
      "self",
      "name",
      "value",
      "tdim"
    ],
    "set_future": [
      "self",
      "name",
      "value",
      "tdim"
    ],
    "remove": [
      "self",
      "column"
    ],
    "_repr_html_": [
      "self"
    ],
    "as_dict": [
      "self"
    ],
    "resize": [
      "self",
      "past_length",
      "future_length",
      "pad_value"
    ],
    "with_index": [
      "self",
      "index"
    ],
    "_batch": [
      "split_frames"
    ]
  },
  "BatchSplitFrame": {
    "batch_size": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "past": [
      "self"
    ],
    "future": [
      "self"
    ],
    "items": [
      "self"
    ],
    "as_dict": [
      "self"
    ]
  },
  "BatchSplitFrameItems": {
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "split_frame": [
    "full"
  ],
  "AxisView": {
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ]
  },
  "pad_axis": [
    "a"
  ],
  "_replace": [
    "obj"
  ],
  "tag": [
    "name",
    "data"
  ],
  "html_table": [
    "columns"
  ],
  "Field": {
    "load_from": [
      "self",
      "data",
      "name"
    ],
    "_get": [
      "self",
      "data",
      "name"
    ]
  },
  "Metadata": {
    "_load": [
      "self",
      "value"
    ]
  },
  "Scalar": {
    "_load": [
      "self",
      "value"
    ]
  },
  "Array": {
    "_load": [
      "self",
      "value"
    ]
  },
  "TimeSeries": {
    "_load": [
      "self",
      "value",
      "length"
    ]
  },
  "Fields": [],
  "Schema": {
    "__init__": [
      "self",
      "fields"
    ],
    "_load_static": [
      "self",
      "data"
    ],
    "_load_metadata": [
      "self",
      "data"
    ],
    "load_timeframe": [
      "self",
      "data",
      "start",
      "freq"
    ],
    "load_splitframe": [
      "self",
      "data",
      "future_length",
      "start",
      "freq"
    ]
  },
  "BatchTimeSeries": {
    "_slice_tdim": [
      "self",
      "idx"
    ],
    "batch_size": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "__array__": [
      "self"
    ],
    "items": [
      "self"
    ],
    "pad": [
      "self",
      "value",
      "left",
      "right"
    ],
    "like": [
      "self",
      "values",
      "name"
    ]
  },
  "TimeSeriesItems": {
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "time_series": [
    "values"
  ],
  "LeftOrRight": [],
  "Pad": {
    "extend": [
      "self",
      "left",
      "right"
    ]
  },
  "ILoc": {
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "TimeView": {
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "TimeBase": {
    "_slice_tdim": [
      "self",
      "idx"
    ],
    "__len__": [
      "self"
    ],
    "pad": [
      "self",
      "value",
      "left",
      "right"
    ],
    "iloc": [
      "self"
    ],
    "loc": [
      "self"
    ],
    "start": [
      "self"
    ],
    "end": [
      "self"
    ],
    "head": [
      "self",
      "count"
    ],
    "tail": [
      "self",
      "count"
    ],
    "resize": [
      "self",
      "length",
      "pad_value",
      "pad",
      "skip"
    ],
    "index_of": [
      "self",
      "period"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "with_index": [
      "self",
      "index"
    ]
  },
  "Batchable": [],
  "batch": [
    "xs"
  ],
  "from_pandas": [
    "obj"
  ],
  "_is_number": [
    "value"
  ],
  "_BasePeriod": {
    "freqstr": [
      "self"
    ],
    "year": [
      "self"
    ],
    "month": [
      "self"
    ],
    "day": [
      "self"
    ],
    "hour": [
      "self"
    ],
    "minute": [
      "self"
    ],
    "second": [
      "self"
    ],
    "dayofweek": [
      "self"
    ],
    "dayofyear": [
      "self"
    ],
    "week": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ]
  },
  "Period": {
    "__init_passed_kwargs__": [
      "self"
    ],
    "periods": [
      "self",
      "count"
    ],
    "to_pandas": [
      "self"
    ],
    "to_timestamp": [
      "self"
    ],
    "unix_epoch": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "to_numpy": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "__array__": [
      "self"
    ]
  },
  "Periods": {
    "start": [
      "self"
    ],
    "end": [
      "self"
    ],
    "head": [
      "self",
      "count"
    ],
    "tail": [
      "self",
      "count"
    ],
    "future": [
      "self",
      "count"
    ],
    "past": [
      "self",
      "count"
    ],
    "prepend": [
      "self",
      "count"
    ],
    "extend": [
      "self",
      "count"
    ],
    "to_pandas": [
      "self"
    ],
    "from_pandas": [
      "cls",
      "index"
    ],
    "intersection": [
      "self",
      "other"
    ],
    "index_of": [
      "self",
      "period"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "to_numpy": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "__array__": [
      "self"
    ],
    "unix_epoch": [
      "self"
    ]
  },
  "_encode_zebras_periods": [
    "v"
  ],
  "period": [
    "data",
    "freq"
  ],
  "periods": [
    "start",
    "freq",
    "count"
  ],
  "NpFreq": [],
  "weekday_offsets": [],
  "_canonical_freqstr": [
    "n",
    "name",
    "suffix"
  ],
  "_freq_numpy_to_pandas": [],
  "_freq_pandas_to_numpy": [],
  "_canonical_name": [
    "name"
  ],
  "Freq": {
    "__post_init__": [
      "self"
    ],
    "__init_passed_kwargs__": [
      "self"
    ],
    "np_freq": [
      "self"
    ],
    "step": [
      "self"
    ],
    "__get_validators__": [
      "cls"
    ],
    "from_pandas": [
      "cls",
      "freq"
    ],
    "to_pandas": [
      "self"
    ],
    "align": [
      "self",
      "timestamp"
    ],
    "shift": [
      "self",
      "start",
      "count"
    ],
    "range": [
      "self",
      "start",
      "count"
    ],
    "__str__": [
      "self"
    ]
  },
  "freq": [
    "arg"
  ],
  "TimeFrame": {
    "__post_init__": [
      "self"
    ],
    "eq_shape": [
      "self",
      "other"
    ],
    "eq_to": [
      "self",
      "other"
    ],
    "_time_view": [
      "self",
      "column"
    ],
    "_slice_tdim": [
      "self",
      "idx"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "pad": [
      "self",
      "value",
      "left",
      "right"
    ],
    "astype": [
      "self",
      "type",
      "columns"
    ],
    "__repr__": [
      "self"
    ],
    "_table_columns": [
      "self"
    ],
    "_repr_html_": [
      "self"
    ],
    "from_pandas": [
      "cls",
      "df"
    ],
    "set": [
      "self",
      "name",
      "value",
      "tdim"
    ],
    "set_static": [
      "self",
      "name",
      "value"
    ],
    "set_like": [
      "self",
      "ref",
      "column",
      "value",
      "tdim"
    ],
    "remove": [
      "self",
      "column"
    ],
    "remove_static": [
      "self",
      "name"
    ],
    "like": [
      "self",
      "columns",
      "static"
    ],
    "rename": [
      "self",
      "mapping"
    ],
    "rename_static": [
      "self",
      "mapping"
    ],
    "stack": [
      "self",
      "select",
      "into",
      "drop"
    ],
    "as_dict": [
      "self",
      "prefix",
      "static"
    ],
    "rolsplit": [
      "self",
      "index"
    ],
    "split": [
      "self",
      "index",
      "past_length",
      "future_length",
      "pad_value"
    ],
    "apply": [
      "self",
      "fn",
      "columns"
    ],
    "__len__": [
      "self"
    ],
    "_batch": [
      "xs"
    ]
  },
  "BatchTimeFrame": {
    "batch_size": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "like": [
      "self",
      "columns",
      "static",
      "tdims"
    ],
    "items": [
      "self"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "as_dict": [
      "self",
      "prefix",
      "static"
    ]
  },
  "BatchTimeFrameItems": {
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "time_frame": [
    "columns"
  ],
  "resolve_device": [
    "device"
  ],
  "get_forward_input_names": [
    "module"
  ],
  "lagged_sequence_values": [
    "indices",
    "prior_sequence",
    "sequence",
    "dim"
  ],
  "repeat_along_dim": [
    "a",
    "dim",
    "repeats"
  ],
  "slice_along_dim": [
    "a",
    "dim",
    "slice_"
  ],
  "take_last": [
    "a",
    "dim",
    "num"
  ],
  "unsqueeze_expand": [
    "a",
    "dim",
    "size"
  ],
  "equals_tensor": [
    "this",
    "that"
  ],
  "StdScaler": {
    "__init__": [
      "self",
      "dim",
      "keepdim",
      "minimum_scale"
    ],
    "__call__": [
      "self",
      "data",
      "weights"
    ]
  },
  "QuantileLayer": {
    "__init__": [
      "self",
      "num_output",
      "cos_embedding_dim"
    ],
    "forward": [
      "self",
      "tau"
    ]
  },
  "ImplicitQuantileModule": {
    "__init__": [
      "self",
      "in_features",
      "args_dim",
      "domain_map",
      "concentration1",
      "concentration0",
      "output_domain_map",
      "cos_embedding_dim"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "ImplicitQuantileNetwork": {
    "__init__": [
      "self",
      "outputs",
      "taus",
      "validate_args"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "quantile_loss": [
      "self",
      "value"
    ]
  },
  "ImplicitQuantileNetworkOutput": {
    "distr_cls": [],
    "args_dim": [],
    "__init__": [
      "self",
      "output_domain",
      "concentration1",
      "concentration0",
      "cos_embedding_dim"
    ],
    "get_args_proj": [
      "self",
      "in_features"
    ],
    "domain_map": [
      "cls"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ],
    "loss": [
      "self",
      "target",
      "distr_args",
      "loc",
      "scale"
    ]
  },
  "BinnedUniforms": {
    "arg_constraints": [],
    "support": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "bins_lower_bound",
      "bins_upper_bound",
      "logits",
      "numb_bins",
      "validate_args"
    ],
    "mode": [
      "self"
    ],
    "median": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "bins_prob": [
      "self"
    ],
    "log_bins_prob": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "log_binned_p": [
      "self",
      "x"
    ],
    "pdf": [
      "self",
      "x"
    ],
    "get_one_hot_bin_indicator": [
      "self",
      "x",
      "in_float"
    ],
    "icdf": [
      "self",
      "quantiles"
    ],
    "_inverse_cdf": [
      "self",
      "quantiles"
    ],
    "_icdf_binned": [
      "self",
      "quantiles"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "_cdf_binned": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ],
    "variance": [
      "self"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "entropy": [
      "self"
    ],
    "enumerate_support": [
      "self",
      "expand"
    ]
  },
  "BinnedUniformsOutput": {
    "__init__": [
      "self",
      "bins_lower_bound",
      "bins_upper_bound",
      "num_bins"
    ],
    "domain_map": [
      "cls",
      "logits"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "CONST_SQRT_2": [],
  "CONST_INV_SQRT_2PI": [],
  "CONST_INV_SQRT_2": [],
  "CONST_LOG_INV_SQRT_2PI": [],
  "CONST_LOG_SQRT_2PI_E": [],
  "TruncatedNormal": {
    "arg_constraints": [],
    "has_rsample": [],
    "eps": [],
    "__init__": [
      "self",
      "loc",
      "scale",
      "min",
      "max",
      "upscale",
      "tanh_loc"
    ],
    "support": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "entropy": [
      "self"
    ],
    "_little_phi": [
      "x"
    ],
    "_big_phi": [
      "self",
      "x"
    ],
    "_inv_big_phi": [
      "x"
    ],
    "cdf_truncated_standard_normal": [
      "self",
      "value"
    ],
    "icdf_truncated_standard_normal": [
      "self",
      "value"
    ],
    "log_prob_truncated_standard_normal": [
      "self",
      "value"
    ],
    "_to_std_rv": [
      "self",
      "value"
    ],
    "_from_std_rv": [
      "self",
      "value"
    ],
    "cdf": [
      "self",
      "value"
    ],
    "icdf": [
      "self",
      "value"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ]
  },
  "TruncatedNormalOutput": {
    "__init__": [
      "self",
      "min",
      "max",
      "upscale",
      "tanh_loc"
    ],
    "domain_map": [
      "cls",
      "loc",
      "scale"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "SplicedBinnedPareto": {
    "arg_constraints": [],
    "support": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "bins_lower_bound",
      "bins_upper_bound",
      "logits",
      "upper_gp_xi",
      "upper_gp_beta",
      "lower_gp_xi",
      "lower_gp_beta",
      "numb_bins",
      "tail_percentile_gen_pareto",
      "validate_args"
    ],
    "log_prob": [
      "self",
      "x",
      "for_training"
    ],
    "pdf": [
      "self",
      "x"
    ],
    "_inverse_cdf": [
      "self",
      "quantiles"
    ],
    "cdf": [
      "self",
      "x"
    ]
  },
  "SplicedBinnedParetoOutput": {
    "__init__": [
      "self",
      "bins_lower_bound",
      "bins_upper_bound",
      "num_bins",
      "tail_percentile_gen_pareto"
    ],
    "domain_map": [
      "cls",
      "logits",
      "upper_gp_xi",
      "upper_gp_beta",
      "lower_gp_xi",
      "lower_gp_beta"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "GeneralizedPareto": {
    "arg_constraints": [],
    "support": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "xi",
      "beta",
      "validate_args"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "stddev": [
      "self"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "icdf": [
      "self",
      "value"
    ]
  },
  "GeneralizedParetoOutput": {
    "__init__": [
      "self"
    ],
    "domain_map": [
      "cls",
      "xi",
      "beta"
    ],
    "distribution": [
      "self",
      "distr_args",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "DiscreteDistribution": {
    "__init__": [
      "self",
      "values",
      "probs",
      "validate_args"
    ],
    "adjust_probs": [
      "values_sorted",
      "probs_sorted"
    ],
    "mean": [
      "self"
    ],
    "log_prob": [
      "self",
      "obs"
    ],
    "rps": [
      "self",
      "obs",
      "check_for_duplicates"
    ],
    "quantile_losses": [
      "self",
      "obs",
      "quantiles",
      "levels"
    ],
    "sample": [
      "self",
      "sample_shape"
    ]
  },
  "PtArgProj": {
    "__init__": [
      "self",
      "in_features",
      "args_dim",
      "domain_map"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "NormalOutput": {
    "domain_map": [
      "cls",
      "loc",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "AffineTransformed": {
    "__init__": [
      "self",
      "base_distribution",
      "loc",
      "scale"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "stddev": [
      "self"
    ]
  },
  "LambdaLayer": {
    "__init__": [
      "self",
      "function"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "has_validation_loop": [
    "trainer"
  ],
  "PyTorchPredictor": {
    "__init__": [
      "self",
      "input_names",
      "prediction_net",
      "batch_size",
      "prediction_length",
      "input_transform",
      "forecast_generator",
      "output_transform",
      "lead_time",
      "device"
    ],
    "to": [
      "self",
      "device"
    ],
    "network": [
      "self"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path",
      "device"
    ]
  },
  "PyTorchLightningEstimator": {
    "__init__": [
      "self",
      "trainer_kwargs",
      "lead_time"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "train_model": [
      "self",
      "training_data",
      "validation_data",
      "from_predictor",
      "shuffle_buffer_length",
      "cache_data",
      "ckpt_path"
    ],
    "_worker_init_fn": [
      "worker_id"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data",
      "shuffle_buffer_length",
      "cache_data",
      "ckpt_path"
    ],
    "train_from": [
      "self",
      "predictor",
      "training_data",
      "validation_data",
      "shuffle_buffer_length",
      "cache_data",
      "ckpt_path"
    ]
  },
  "PatchTSTLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "SinusoidalPositionalEmbedding": {
    "__init__": [
      "self",
      "num_positions",
      "embedding_dim"
    ],
    "_init_weight": [
      "out"
    ],
    "forward": [
      "self",
      "input_ids_shape",
      "past_key_values_length"
    ]
  },
  "PatchTSTModel": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "patch_len",
      "stride",
      "padding_patch",
      "d_model",
      "nhead",
      "dim_feedforward",
      "num_feat_dynamic_real",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "scaling",
      "distr_output"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_values",
      "past_time_feat",
      "future_time_feat"
    ],
    "loss": [
      "self",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values",
      "past_time_feat",
      "future_time_feat"
    ]
  },
  "PREDICTION_INPUT_NAMES": [],
  "TRAINING_INPUT_NAMES": [],
  "PatchTSTEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "patch_len",
      "context_length",
      "stride",
      "padding_patch",
      "d_model",
      "nhead",
      "dim_feedforward",
      "num_feat_dynamic_real",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "lr",
      "weight_decay",
      "scaling",
      "distr_output",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "train_sampler",
      "validation_sampler"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "module",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module",
      "shuffle_buffer_length"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ]
  },
  "DeepARLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay",
      "patience"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "DeepARModel": {
    "__init__": [
      "self",
      "freq",
      "context_length",
      "prediction_length",
      "num_feat_dynamic_real",
      "num_feat_static_real",
      "num_feat_static_cat",
      "cardinality",
      "embedding_dimension",
      "num_layers",
      "hidden_size",
      "dropout_rate",
      "distr_output",
      "lags_seq",
      "scaling",
      "default_scale",
      "num_parallel_samples",
      "nonnegative_pred_samples"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "_number_of_features": [
      "self"
    ],
    "_past_length": [
      "self"
    ],
    "prepare_rnn_input": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "unroll_lagged_rnn": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "output_distribution": [
      "self",
      "params",
      "scale",
      "trailing_n"
    ],
    "post_process_samples": [
      "self",
      "samples"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "num_parallel_samples"
    ],
    "log_prob": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target"
    ],
    "loss": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "future_only",
      "aggregate_by"
    ]
  },
  "DeepNPTSEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "num_hidden_nodes",
      "batch_norm",
      "use_feat_static_cat",
      "num_feat_static_real",
      "num_feat_dynamic_real",
      "cardinality",
      "embedding_dimension",
      "input_scaling",
      "dropout_rate",
      "network_type",
      "epochs",
      "lr",
      "batch_size",
      "num_batches_per_epoch",
      "cache_data",
      "loss_scaling"
    ],
    "input_transform": [
      "self"
    ],
    "instance_splitter": [
      "self",
      "instance_sampler",
      "is_train"
    ],
    "training_data_loader": [
      "self",
      "training_dataset",
      "batch_size",
      "num_batches_per_epoch"
    ],
    "train_model": [
      "self",
      "training_data",
      "cache_data"
    ],
    "get_predictor": [
      "self",
      "net",
      "device"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data",
      "cache_data"
    ]
  },
  "INPUT_SCALING_MAP": [],
  "init_weights": [
    "module",
    "scale"
  ],
  "DeepNPTSNetwork": {
    "__init__": [
      "self",
      "context_length",
      "num_hidden_nodes",
      "cardinality",
      "embedding_dimension",
      "num_time_features",
      "batch_norm",
      "input_scaling",
      "dropout_rate"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_target",
      "past_observed_values",
      "past_time_feat"
    ]
  },
  "DeepNPTSNetworkDiscrete": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_target",
      "past_observed_values",
      "past_time_feat"
    ]
  },
  "DeepNPTSNetworkSmooth": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_target",
      "past_observed_values",
      "past_time_feat"
    ]
  },
  "DeepNPTSMultiStepNetwork": {
    "__init__": [
      "self",
      "net",
      "prediction_length",
      "num_parallel_samples"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_target",
      "past_observed_values",
      "past_time_feat",
      "future_time_feat"
    ]
  },
  "_one_if_too_small": [
    "x",
    "min_value"
  ],
  "min_max_scaling": [
    "seq",
    "dim",
    "keepdim",
    "min_scale"
  ],
  "standard_normal_scaling": [
    "seq",
    "dim",
    "keepdim",
    "min_scale"
  ],
  "DLinearLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "MovingAvg": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SeriesDecomp": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DLinearModel": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "hidden_dimension",
      "distr_output",
      "kernel_size",
      "scaling"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_values"
    ],
    "loss": [
      "self",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "DLinearEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "hidden_dimension",
      "lr",
      "weight_decay",
      "scaling",
      "distr_output",
      "kernel_size",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "train_sampler",
      "validation_sampler"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "module",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module",
      "shuffle_buffer_length"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ]
  },
  "TiDELightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay",
      "patience"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "ResBlock": {
    "__init__": [
      "self",
      "dim_in",
      "dim_hidden",
      "dim_out",
      "dropout_rate",
      "layer_norm"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FeatureProjection": {
    "__init__": [
      "self",
      "input_dim",
      "hidden_dim",
      "output_dim",
      "dropout_rate",
      "layer_norm"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DenseEncoder": {
    "__init__": [
      "self",
      "num_layers",
      "input_dim",
      "hidden_dim",
      "dropout_rate",
      "layer_norm"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DenseDecoder": {
    "__init__": [
      "self",
      "num_layers",
      "hidden_dim",
      "output_dim",
      "dropout_rate",
      "layer_norm"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalDecoder": {
    "__init__": [
      "self",
      "input_dim",
      "hidden_dim",
      "output_dim",
      "dropout_rate",
      "layer_norm"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TiDEModel": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "num_feat_dynamic_real",
      "num_feat_dynamic_proj",
      "num_feat_static_real",
      "num_feat_static_cat",
      "cardinality",
      "embedding_dimension",
      "feat_proj_hidden_dim",
      "encoder_hidden_dim",
      "decoder_hidden_dim",
      "temporal_hidden_dim",
      "distr_hidden_dim",
      "decoder_output_dim",
      "dropout_rate",
      "num_layers_encoder",
      "num_layers_decoder",
      "layer_norm",
      "distr_output",
      "scaling"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "feat_static_real",
      "feat_static_cat",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat"
    ],
    "loss": [
      "self",
      "feat_static_real",
      "feat_static_cat",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values"
    ]
  },
  "TiDEEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "feat_proj_hidden_dim",
      "encoder_hidden_dim",
      "decoder_hidden_dim",
      "temporal_hidden_dim",
      "distr_hidden_dim",
      "num_layers_encoder",
      "num_layers_decoder",
      "decoder_output_dim",
      "dropout_rate",
      "num_feat_dynamic_proj",
      "num_feat_dynamic_real",
      "num_feat_static_real",
      "num_feat_static_cat",
      "cardinality",
      "embedding_dimension",
      "layer_norm",
      "lr",
      "weight_decay",
      "patience",
      "scaling",
      "distr_output",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "train_sampler",
      "validation_sampler"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "module",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module",
      "shuffle_buffer_length"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ]
  },
  "WaveNetLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "CausalDilatedResidualLayer": {
    "__init__": [
      "self",
      "num_residual_channels",
      "num_skip_channels",
      "dilation",
      "kernel_size",
      "return_dense_output"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ITransformerLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "num_parallel_samples",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "ITransformerModel": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "scaling",
      "distr_output",
      "nonnegative_pred_samples"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_values"
    ],
    "loss": [
      "self",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "ITransformerEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "lr",
      "weight_decay",
      "scaling",
      "distr_output",
      "num_parallel_samples",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "train_sampler",
      "validation_sampler",
      "nonnegative_pred_samples"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "module",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module",
      "shuffle_buffer_length"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ]
  },
  "TemporalFusionTransformerLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "patience",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "TemporalFusionTransformerModel": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_feat_static_real",
      "c_feat_static_cat",
      "d_feat_dynamic_real",
      "c_feat_dynamic_cat",
      "d_past_feat_dynamic_real",
      "c_past_feat_dynamic_cat",
      "num_heads",
      "d_hidden",
      "d_var",
      "dropout_rate",
      "distr_output"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "input_types": [
      "self"
    ],
    "_preprocess": [
      "self",
      "past_target",
      "past_observed_values",
      "feat_static_real",
      "feat_static_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_values",
      "feat_static_real",
      "feat_static_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat"
    ],
    "loss": [
      "self",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values",
      "feat_static_real",
      "feat_static_cat",
      "feat_dynamic_real",
      "feat_dynamic_cat",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat"
    ]
  },
  "MQF2MultiHorizonLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay",
      "patience"
    ],
    "forward": [
      "self"
    ],
    "_compute_loss": [
      "self",
      "batch"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "MQF2MultiHorizonModel": {
    "__init__": [
      "self",
      "freq",
      "context_length",
      "prediction_length",
      "num_feat_dynamic_real",
      "num_feat_static_real",
      "num_feat_static_cat",
      "cardinality",
      "distr_output",
      "embedding_dimension",
      "num_layers",
      "hidden_size",
      "dropout_rate",
      "lags_seq",
      "scaling",
      "num_parallel_samples",
      "icnn_hidden_size",
      "icnn_num_layers",
      "is_energy_score",
      "threshold_input",
      "es_num_samples",
      "estimate_logdet"
    ],
    "output_distribution": [
      "self",
      "picnn",
      "hidden_state",
      "scale",
      "inference"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "num_parallel_samples"
    ],
    "loss": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "future_only",
      "aggregate_by"
    ]
  },
  "DeepConvexNet": {
    "__init__": [
      "self",
      "picnn",
      "dim",
      "is_energy_score",
      "estimate_logdet",
      "m1",
      "m2",
      "rtol",
      "atol"
    ],
    "get_potential": [
      "self",
      "x",
      "context"
    ],
    "forward_transform": [
      "self",
      "x",
      "logdet",
      "context",
      "extra"
    ]
  },
  "SequentialNet": {
    "__init__": [
      "self",
      "networks"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ],
    "es_sample": [
      "self",
      "hidden_state",
      "dimension"
    ],
    "energy_score": [
      "self",
      "z",
      "hidden_state",
      "es_num_samples",
      "beta"
    ]
  },
  "MQF2MultiHorizonEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "num_layers",
      "hidden_size",
      "lr",
      "weight_decay",
      "dropout_rate",
      "num_feat_dynamic_real",
      "num_feat_static_cat",
      "num_feat_static_real",
      "cardinality",
      "embedding_dimension",
      "scaling",
      "lags_seq",
      "time_features",
      "num_parallel_samples",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "icnn_hidden_size",
      "icnn_num_layers",
      "is_energy_score",
      "es_num_samples",
      "beta",
      "threshold_input",
      "estimate_logdet"
    ],
    "create_lightning_module": [
      "self"
    ]
  },
  "MQF2Distribution": {
    "__init__": [
      "self",
      "picnn",
      "hidden_state",
      "prediction_length",
      "is_energy_score",
      "es_num_samples",
      "beta",
      "threshold_input",
      "validate_args"
    ],
    "stack_sliding_view": [
      "self",
      "z"
    ],
    "loss": [
      "self",
      "z"
    ],
    "log_prob": [
      "self",
      "z"
    ],
    "energy_score": [
      "self",
      "z"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "quantile": [
      "self",
      "alpha",
      "hidden_state"
    ],
    "batch_shape": [
      "self"
    ],
    "event_shape": [
      "self"
    ],
    "event_dim": [
      "self"
    ]
  },
  "MQF2DistributionOutput": {
    "__init__": [
      "self",
      "prediction_length",
      "is_energy_score",
      "threshold_input",
      "es_num_samples",
      "beta"
    ],
    "domain_map": [
      "cls",
      "hidden_state"
    ],
    "distribution": [
      "self",
      "picnn",
      "hidden_state",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "TransformedMQF2Distribution": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms",
      "is_energy_score",
      "validate_args"
    ],
    "scale_input": [
      "self",
      "y"
    ],
    "repeat_scale": [
      "self",
      "scale"
    ],
    "log_prob": [
      "self",
      "y"
    ],
    "energy_score": [
      "self",
      "y"
    ],
    "loss": [
      "self",
      "z"
    ]
  },
  "SimpleFeedForwardLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "mean_abs_scaling": [
    "seq",
    "min_scale"
  ],
  "make_linear_layer": [
    "dim_in",
    "dim_out"
  ],
  "SimpleFeedForwardModel": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "hidden_dimensions",
      "distr_output",
      "batch_norm"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "past_target"
    ],
    "loss": [
      "self",
      "past_target",
      "future_target",
      "future_observed_values"
    ]
  },
  "LagTSTLightningModule": {
    "__init__": [
      "self",
      "model_kwargs",
      "lr",
      "weight_decay"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "LagTSTModel": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "freq",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "scaling",
      "lags_seq",
      "distr_output"
    ],
    "_past_length": [
      "self"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_values"
    ],
    "loss": [
      "self",
      "past_target",
      "past_observed_values",
      "future_target",
      "future_observed_values"
    ]
  },
  "LagTSTEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "context_length",
      "d_model",
      "nhead",
      "dim_feedforward",
      "lags_seq",
      "dropout",
      "activation",
      "norm_first",
      "num_encoder_layers",
      "lr",
      "weight_decay",
      "scaling",
      "distr_output",
      "batch_size",
      "num_batches_per_epoch",
      "trainer_kwargs",
      "train_sampler",
      "validation_sampler"
    ],
    "create_transformation": [
      "self"
    ],
    "create_lightning_module": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "module",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data",
      "module",
      "shuffle_buffer_length"
    ],
    "create_validation_data_loader": [
      "self",
      "data",
      "module"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "module"
    ]
  },
  "EVALUATE_ALL_LEVELS": [],
  "main": [],
  "evaluate_predictor": [
    "predictor",
    "test_dataset",
    "freq",
    "metrics",
    "evaluate_all_levels"
  ],
  "evaluate_forecasts_at_all_levels": [
    "forecast_at_all_levels_it",
    "test_ts_at_all_levels_it",
    "temporal_hierarchy",
    "evaluator",
    "metrics"
  ],
  "TEMPORAL_HIERARCHIES": [],
  "truncate_target": [
    "dataset",
    "prediction_length",
    "lead_time"
  ],
  "to_dataframe_it": [
    "test"
  ],
  "crps": [
    "forecast",
    "actuals",
    "levels",
    "weighted"
  ],
  "TemporalHierarchy": {
    "__init__": [
      "self",
      "agg_multiples",
      "freq_strs"
    ],
    "_adj_mat": [
      "self"
    ],
    "_hierarchical_adj_mat": [
      "self"
    ],
    "adj_mat": [
      "self",
      "option"
    ],
    "num_nodes_per_level": [
      "self"
    ],
    "nodes": [
      "self"
    ],
    "_get_agg_mat": [
      "agg_multiples"
    ]
  },
  "_check_freqs": [
    "deltas"
  ],
  "freqs_to_agg_mulitples": [
    "freq_strs"
  ],
  "to_TemporalHierarchy": [
    "freq_strs"
  ],
  "agg_series": [
    "seq",
    "agg_multiple"
  ],
  "unpack_forecasts": [
    "forecast_at_all_levels_it",
    "temporal_hierarchy",
    "target_temporal_hierarchy",
    "num_samples"
  ],
  "get_ts_at_all_levels": [
    "ts_it",
    "temporal_hierarchy",
    "prediction_length",
    "target_temporal_hierarchy"
  ],
  "naive_reconcilation_mat": [
    "S",
    "nodes"
  ],
  "AddTimeFeaturesAtAggregateLevels": {
    "__init__": [
      "self",
      "agg_multiples",
      "agg_estimators"
    ],
    "transform": [
      "self",
      "data"
    ],
    "_get_time_features_agg_level": [
      "forecast_start",
      "past_length_bottom_ts",
      "agg_estimator"
    ]
  },
  "COPDeepAREstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "base_estimator_name",
      "base_estimator_hps",
      "use_gnn",
      "use_mlp",
      "adj_mat_option",
      "non_negative",
      "do_reconciliation",
      "loss_function",
      "warmstart_epoch_frac",
      "trainer",
      "lag_ub",
      "num_samples_for_loss",
      "return_forecasts_at_all_levels",
      "naive_reconciliation",
      "dtype",
      "impute_missing_values",
      "imputation_method",
      "num_imputation_samples"
    ],
    "create_transformation": [
      "self"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "COPNetwork": {
    "__init__": [
      "self",
      "estimators",
      "prediction_length",
      "temporal_hierarchy",
      "do_reconciliation",
      "dtype",
      "use_gnn",
      "use_mlp",
      "adj_mat_option",
      "non_negative",
      "naive_reconciliation",
      "prediction",
      "loss_function"
    ],
    "get_target_related_feat_at_agg_level": [
      "self",
      "agg_level",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_target",
      "future_observed_values"
    ],
    "_embeddings_to_distr": [
      "self",
      "F",
      "embeddings_at_all_levels",
      "scales"
    ],
    "_distr_to_samples": [
      "self",
      "distr_at_all_levels",
      "num_samples"
    ]
  },
  "COPDeepARTrainingNetwork": {
    "__init__": [
      "self",
      "num_batches_per_epoch",
      "epochs",
      "warmstart_epoch_frac",
      "num_samples_for_loss"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "agg_features_dict"
    ]
  },
  "COPDeepARPredictionNetwork": {
    "__init__": [
      "self",
      "return_forecasts_at_all_levels",
      "num_parallel_samples"
    ],
    "_decode_one_window": [
      "self",
      "F",
      "model",
      "window_size",
      "offset",
      "static_feat",
      "past_target",
      "time_feat",
      "scale",
      "begin_states"
    ],
    "sampling_decoder": [
      "self",
      "F",
      "state_ls",
      "scale_ls",
      "static_feat_ls",
      "past_target_ls",
      "future_time_feat_agg_ls"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "past_is_pad",
      "agg_features_dict"
    ]
  },
  "GNN": {
    "__init__": [
      "self",
      "units",
      "num_layers",
      "adj_matrix",
      "use_mlp"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "LOSS_FUNCTIONS": [],
  "batchify_with_dict": [
    "data",
    "ctx",
    "dtype",
    "variable_length",
    "is_right_pad"
  ],
  "RepresentableBlockPredictorBatchifyWithDict": {
    "__init__": [
      "self",
      "prediction_net",
      "batch_size",
      "prediction_length",
      "ctx",
      "input_transform",
      "lead_time",
      "forecast_generator",
      "output_transform",
      "dtype"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples",
      "num_workers",
      "num_prefetch"
    ],
    "deserialize": [
      "cls",
      "path",
      "ctx"
    ]
  },
  "create_prediction_network": [
    "estimator"
  ],
  "DeepAREstimatorForCOP": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "dropoutcell_type",
      "dropout_rate",
      "use_feat_dynamic_real",
      "use_feat_static_cat",
      "use_feat_static_real",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "scaling",
      "lags_seq",
      "time_features",
      "num_parallel_samples",
      "imputation_method",
      "train_sampler",
      "validation_sampler",
      "dtype",
      "alpha",
      "beta",
      "batch_size",
      "default_scale",
      "minimum_scale",
      "impute_missing_values",
      "num_imputation_samples",
      "history_length"
    ]
  },
  "fill_forward": [
    "a",
    "fill_start"
  ],
  "labels_filter": [
    "a",
    "num_open",
    "num_clear",
    "initial_label",
    "forward_fill"
  ],
  "n_k_filter": [
    "a",
    "num_open",
    "num_clear",
    "num_open_suff",
    "num_clear_suff",
    "initial_label",
    "forward_fill"
  ],
  "range_overlap": [
    "left_range",
    "right_range"
  ],
  "labels_to_ranges_numba": [
    "labels"
  ],
  "labels_to_ranges": [
    "labels"
  ],
  "ranges_to_singletons": [
    "ranges"
  ],
  "segment_precision_recall": [
    "real_ranges",
    "pred_ranges"
  ],
  "PrecisionRecallAndWeights": {},
  "singleton_precision_recall": [
    "true_labels",
    "pred_labels"
  ],
  "precision_recall_curve_per_ts": [
    "labels",
    "scores",
    "thresholds",
    "partial_filter",
    "singleton_curve",
    "precision_recall_fn"
  ],
  "aggregate_precision_recall_curve": [
    "label_score_iterable",
    "thresholds",
    "partial_filter",
    "singleton_curve",
    "precision_recall_fn",
    "n_jobs"
  ],
  "aggregate_precision_recall": [
    "labels_pred_iterable",
    "precision_recall_fn"
  ],
  "extend_ranges": [
    "ranges",
    "extension_length",
    "direction"
  ],
  "buffered_precision_recall": [
    "real_ranges",
    "pred_ranges",
    "buffer_length"
  ],
  "bounded_pr_auc": [
    "precisions",
    "recalls",
    "lower_bound"
  ],
  "_get_mixed_pattern": [
    "x",
    "pattern"
  ],
  "get_mixed_pattern": [
    "unit_length",
    "num_duplicates"
  ],
  "group_electricity_cv": [
    "num_ts",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "group_exchangerate_cv": [
    "num_ts",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "group_traffic_cv": [
    "num_ts",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "KMeans": [
    "x",
    "K",
    "Niter",
    "verbose"
  ],
  "_get_pre_features": [
    "x"
  ],
  "KMeans_inside_dataset": [
    "num_ts_",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "KMeans_m5_dataset": [
    "num_ts_",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "group_traffic_mb": [
    "num_ts",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "get_m4_by_freq": [
    "context_length",
    "prediction_length",
    "len_per_ts",
    "num_ts",
    "num_groups",
    "file_name"
  ],
  "get_temperature_data": [
    "context_length",
    "prediction_length",
    "samples_per_ts",
    "num_groups"
  ],
  "get_amazon_sales": [],
  "get_group_data_by_var": [
    "name",
    "num_groups",
    "len_sample"
  ],
  "get_group_data_by_hash": [
    "name",
    "q",
    "num_groups"
  ],
  "get_group_data_by_duplicate": [
    "name",
    "num_duplicates",
    "num_groups"
  ],
  "get_whole_data_by_duplicate": [
    "name",
    "num_duplicates"
  ],
  "get_group_data": [
    "name"
  ],
  "get_whole_data": [
    "name"
  ],
  "get_synthetic_data": [
    "model_name",
    "num_groups",
    "mean_boundary"
  ],
  "get_synthetic_data_mlp": [
    "model_name",
    "num_groups",
    "mean_boundary",
    "num_duplicates"
  ],
  "get_synthetic_data_linear": [
    "context_length",
    "prediction_length",
    "num_groups",
    "steps_per_ts",
    "num_duplicates"
  ],
  "get_synthetic_data_linear_simple": [
    "model_name",
    "num_groups",
    "mean_boundary",
    "num_duplicates"
  ],
  "get_synthetic_data_sin": [
    "model_name",
    "num_groups",
    "mean_boundary",
    "num_duplicates"
  ],
  "group_electricity_mb": [
    "num_ts",
    "num_groups",
    "context_length",
    "prediction_length",
    "file_name"
  ],
  "SGD": {
    "__init__": [
      "self",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "nesterov",
      "decreasing_step_size",
      "validation_freq",
      "eval_model",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "SCott": {
    "__init__": [
      "self",
      "freq",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "num_strata",
      "nesterov",
      "decreasing_step_size",
      "weighted_batch",
      "validation_freq",
      "eval_model",
      "gamma",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs",
      "weighted_batch",
      "group_ratio"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "Adagrad": {
    "__init__": [
      "self",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "decreasing_step_size",
      "validation_freq",
      "eval_model",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "SAdagrad": {
    "__init__": [
      "self",
      "freq",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "num_strata",
      "nesterov",
      "decreasing_step_size",
      "weighted_batch",
      "validation_freq",
      "eval_model",
      "gamma",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs",
      "weighted_batch",
      "group_ratio"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "SCSG": {
    "__init__": [
      "self",
      "freq",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "num_strata",
      "nesterov",
      "decreasing_step_size",
      "gradient_variance_freq",
      "weighted_batch",
      "validation_freq",
      "eval_model",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "Adam": {
    "__init__": [
      "self",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "decreasing_step_size",
      "validation_freq",
      "eval_model",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "SAdam": {
    "__init__": [
      "self",
      "freq",
      "task_name",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "num_workers",
      "pin_memory",
      "learning_rate",
      "weight_decay",
      "num_strata",
      "nesterov",
      "decreasing_step_size",
      "weighted_batch",
      "validation_freq",
      "eval_model",
      "gamma",
      "tensorboard_path",
      "device"
    ],
    "inference": [
      "self",
      "model",
      "inputs",
      "weighted_batch",
      "group_ratio"
    ],
    "__call__": [
      "self",
      "net",
      "input_names",
      "data_loaders"
    ]
  },
  "Timer": {
    "__init__": [
      "self",
      "verbosity_level",
      "skip_first",
      "on_cuda"
    ],
    "reset": [
      "self"
    ],
    "__call__": [
      "self",
      "label",
      "epoch",
      "verbosity"
    ],
    "_cuda_sync": [
      "self"
    ],
    "_default_log_fn": [
      "self",
      "_",
      "values",
      "tags"
    ]
  },
  "AREstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "freq",
      "trainer",
      "context_length",
      "num_parallel_samples"
    ],
    "create_transformation": [
      "self",
      "is_full_batch"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "ARNetworkBase": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length"
    ]
  },
  "ARTrainingNetwork": {
    "forward": [
      "self",
      "past_target",
      "future_target"
    ]
  },
  "ARPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "forward": [
      "self",
      "past_target"
    ]
  },
  "LSTMNetworkBase": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "input_size",
      "hidden_layer_size",
      "num_layers"
    ]
  },
  "LSTMTrainingNetwork": {
    "forward": [
      "self",
      "past_target",
      "future_target"
    ]
  },
  "LSTMPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "forward": [
      "self",
      "past_target"
    ]
  },
  "LSTMEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "freq",
      "trainer",
      "context_length",
      "input_size",
      "num_parallel_samples",
      "hidden_layer_size"
    ],
    "create_transformation": [
      "self",
      "is_full_batch"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "add_spikes": [
    "ts",
    "only_upper_spikes"
  ],
  "create_ds": [
    "num_points",
    "t_dof",
    "noise_mult",
    "points_per_sinusoid",
    "magnitude_sin"
  ],
  "create_ds_iid": [
    "num_points",
    "noise_mult"
  ],
  "add_spikes_asymmetric": [
    "ts",
    "xi"
  ],
  "create_ds_asymmetric": [
    "num_points",
    "t_dof",
    "noise_mult",
    "xi",
    "points_per_sinusoid",
    "magnitude_sin"
  ],
  "GaussianModel": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "device"
    ],
    "to_device": [
      "self",
      "device"
    ],
    "forward": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "icdf": [
      "self",
      "value"
    ]
  },
  "train_step_from_batch": [
    "ts_chunks",
    "targets",
    "distr_tcn",
    "optimizer"
  ],
  "eval_on_series": [
    "distr_tcn",
    "optimizer",
    "series_tensor",
    "ts_len",
    "context_length",
    "is_train",
    "return_predictions",
    "lead_time"
  ],
  "plot_prediction": [
    "val_ts_tensor",
    "predictions",
    "context_length",
    "lead_time",
    "start",
    "end",
    "fig"
  ],
  "highlight_min": [
    "data",
    "color"
  ],
  "Chomp1d": {
    "__init__": [
      "self",
      "chomp_size",
      "last"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TCNBlock": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "dilation",
      "bias",
      "fwd_time",
      "final"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TCN": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "channels",
      "layers",
      "bias",
      "fwd_time"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DistributionalTCN": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "channels",
      "layers",
      "bias",
      "fwd_time",
      "output_distr"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SelfAttentionEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "cardinalities",
      "context_length",
      "trainer",
      "model_dim",
      "ffn_dim_multiplier",
      "num_heads",
      "num_layers",
      "num_outputs",
      "kernel_sizes",
      "distance_encoding",
      "pre_layer_norm",
      "dropout",
      "temperature",
      "time_features",
      "use_feat_dynamic_real",
      "use_feat_dynamic_cat",
      "use_feat_static_real",
      "use_feat_static_cat",
      "train_sampler",
      "validation_sampler",
      "batch_size"
    ],
    "create_transformation": [
      "self"
    ],
    "_create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_data_loader": [
      "self",
      "data"
    ],
    "create_validation_data_loader": [
      "self",
      "data"
    ],
    "create_training_network": [
      "self"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network"
    ]
  },
  "SelfAttentionBlock": {
    "__init__": [
      "self",
      "d_hidden",
      "m_ffn",
      "n_head",
      "kernel_sizes",
      "dist_enc",
      "pre_ln",
      "dropout",
      "temperature"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "mask"
    ]
  },
  "SelfAttentionNetwork": {
    "__init__": [
      "self",
      "context_length",
      "prediction_length",
      "d_hidden",
      "m_ffn",
      "n_head",
      "n_layers",
      "n_output",
      "cardinalities",
      "kernel_sizes",
      "dist_enc",
      "pre_ln",
      "dropout",
      "temperature",
      "normalizer_eps"
    ],
    "_preprocess": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "future_target",
      "future_feat_dynamic_real",
      "future_feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ],
    "_postprocess": [
      "self",
      "F",
      "preds",
      "offset",
      "scale"
    ],
    "_forward_step": [
      "self",
      "F",
      "horizon",
      "target",
      "covars",
      "mask"
    ]
  },
  "SelfAttentionTrainingNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "future_target",
      "future_observed_values",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "future_feat_dynamic_real",
      "future_feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ]
  },
  "SelfAttentionPredictionNetwork": {
    "hybrid_forward": [
      "self",
      "F",
      "past_target",
      "past_observed_values",
      "past_is_pad",
      "past_feat_dynamic_real",
      "past_feat_dynamic_cat",
      "future_feat_dynamic_real",
      "future_feat_dynamic_cat",
      "feat_static_real",
      "feat_static_cat"
    ]
  },
  "_torch_gather": [
    "F",
    "data",
    "idx",
    "axis"
  ],
  "PosFFN": {
    "__init__": [
      "self",
      "d_model",
      "d_hidden",
      "activation",
      "pre_ln",
      "dropout"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x"
    ]
  },
  "tensor_to_np": [
    "tensor"
  ],
  "get_mask": [
    "pad_size",
    "lengths"
  ],
  "CRPS": {
    "__init__": [
      "self",
      "quantiles",
      "rescale",
      "compute_on_step",
      "dist_sync_on_step",
      "process_group",
      "dist_sync_fn"
    ],
    "update": [
      "self",
      "y_pred",
      "y_true",
      "mask",
      "scales"
    ],
    "compute": [
      "self"
    ]
  },
  "QuantileWidth": {
    "__init__": [
      "self",
      "quantiles",
      "compute_on_step",
      "dist_sync_on_step",
      "process_group",
      "dist_sync_fn"
    ],
    "update": [
      "self",
      "y_pred",
      "y_true",
      "mask"
    ],
    "compute": [
      "self"
    ]
  },
  "NormalizedDeviation": {
    "__init__": [
      "self",
      "rescale",
      "compute_on_step",
      "dist_sync_on_step",
      "process_group",
      "dist_sync_fn"
    ],
    "update": [
      "self",
      "y_pred",
      "y_true",
      "mask",
      "scales"
    ],
    "compute": [
      "self"
    ]
  },
  "abs_error_sum": [
    "y_pred",
    "y_true"
  ],
  "naive_error": [
    "y_past",
    "seasonality"
  ],
  "mean_weighted_quantile_loss": [
    "y_pred",
    "y_true",
    "quantiles"
  ],
  "compute_metrics": [
    "forecasts",
    "dataset",
    "quantiles",
    "seasonality"
  ],
  "M1DataModule": {
    "__init__": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory"
    ],
    "name": [
      "cls"
    ]
  },
  "generate_m1_dataset": [
    "dataset_path",
    "m1_freq",
    "category",
    "prediction_length"
  ],
  "CheatMetaData": {
    "parse_file": [
      "cls",
      "file"
    ],
    "save": [
      "self",
      "file"
    ],
    "get_hash": [
      "self"
    ]
  },
  "CheatArtificialDataModule": {
    "__init__": [
      "self",
      "context_length_multiple",
      "prediction_length",
      "support_length_multiple",
      "test_set_size",
      "val_set_size",
      "train_set_size",
      "freq",
      "support_set_size",
      "cheat_chance",
      "noise_level",
      "query_length_scale",
      "support_length_scale_same_as_query",
      "data_dir",
      "standardize",
      "batch_size_train",
      "batch_size_val_test",
      "num_workers",
      "random_seed"
    ],
    "dataset_names_val_test": [
      "self"
    ],
    "dataset_names_val": [
      "self"
    ],
    "dataset_names_test": [
      "self"
    ],
    "context_length": [
      "self"
    ],
    "support_length": [
      "self"
    ],
    "prediction_length": [
      "self"
    ],
    "dataset_name": [
      "self"
    ],
    "root": [
      "self"
    ],
    "setup": [
      "self",
      "stage"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "test_dataloader": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "generate_split": [
      "self",
      "split",
      "n_samples",
      "always_cheat",
      "query_length_scale"
    ],
    "generate_artificial_tuplets": [
      "self",
      "item_id",
      "always_cheat",
      "query_length_scale"
    ],
    "get_log_batches": [
      "self",
      "n_logging_samples"
    ],
    "evaluate_model": [
      "self",
      "model",
      "quantiles",
      "test"
    ],
    "name": [
      "cls"
    ]
  },
  "CheatCounterfactual": {
    "parse_file": [
      "cls",
      "file"
    ]
  },
  "CheatCounterfactualArtificialDataModule": {
    "__init__": [
      "self",
      "context_length_multiple",
      "prediction_length",
      "support_length_multiple",
      "test_set_size",
      "val_set_size",
      "train_set_size",
      "freq",
      "support_set_size",
      "cheat_chance",
      "noise_level",
      "query_length_scale",
      "support_length_scale_same_as_query",
      "counterfactual_size",
      "counterfactual_mixing",
      "data_dir",
      "standardize",
      "batch_size_train",
      "batch_size_val_test",
      "num_workers",
      "random_seed"
    ],
    "dataset_names_val_test": [
      "self"
    ],
    "dataset_names_train": [
      "self"
    ],
    "dataset_name": [
      "self"
    ],
    "train_dataloader": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "generate_split": [
      "self",
      "split",
      "n_samples",
      "always_cheat",
      "query_length_scale",
      "counterfactual_size"
    ],
    "generate_artificial_tuplets": [
      "self",
      "item_id",
      "always_cheat",
      "query_length_scale",
      "counterfactual_size"
    ],
    "name": [
      "cls"
    ]
  },
  "M3DataModule": {
    "__init__": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory"
    ],
    "name": [
      "cls"
    ]
  },
  "GluonTSDataModule": {
    "__init__": [
      "self",
      "dataset_name",
      "context_length_multiple",
      "support_length_multiple",
      "support_set_size",
      "num_queries",
      "data_dir",
      "prediction_length",
      "standardize",
      "batch_size_train",
      "batch_size_val_test",
      "num_workers",
      "seed",
      "catch22_train",
      "catch22_val_test",
      "cheat"
    ],
    "context_length": [
      "self"
    ],
    "support_length": [
      "self"
    ],
    "prediction_length": [
      "self"
    ],
    "root": [
      "self"
    ],
    "meta": [
      "self"
    ],
    "sampling_triplet_dataset": [
      "self",
      "split"
    ],
    "sequential_triplet_dataset": [
      "self",
      "split"
    ],
    "setup": [
      "self",
      "stage"
    ],
    "catch22_nn": [
      "self"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "test_dataloader": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "catch22": [
      "self"
    ],
    "name": [
      "cls"
    ],
    "evaluate_model": [
      "self"
    ],
    "_filters": [
      "self",
      "prediction_length",
      "min_length"
    ],
    "_materialize": [
      "self",
      "directory"
    ]
  },
  "get_features": [
    "ts"
  ],
  "normalize_features": [
    "df"
  ],
  "count_lines": [
    "filename"
  ],
  "ArtificialDataModule": {
    "__init__": [
      "self",
      "dataset_name",
      "context_length_multiple",
      "support_length_multiple",
      "support_set_size",
      "num_queries",
      "data_dir",
      "prediction_length",
      "test_set_size",
      "val_set_size",
      "train_set_size",
      "standardize",
      "batch_size_train",
      "batch_size_val",
      "batch_size_test",
      "num_workers",
      "seed"
    ],
    "context_length": [
      "self"
    ],
    "support_length": [
      "self"
    ],
    "prediction_length": [
      "self"
    ],
    "root": [
      "self"
    ],
    "meta": [
      "self"
    ],
    "setup": [
      "self",
      "stage"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "test_dataloader": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "generate_split": [
      "self",
      "split",
      "n_samples"
    ],
    "name": [
      "cls"
    ],
    "evaluate_model": [
      "self"
    ]
  },
  "_write_data_to_file": [
    "file",
    "data"
  ],
  "generate_artificial_tuplets": [
    "dataset_name",
    "context_length",
    "support_length",
    "prediction_length",
    "support_set_size",
    "item_id"
  ],
  "FREQ_M1_M3": [],
  "FREQ_M4": [],
  "CATEGORIES_M1": [],
  "CATEGORIES_M3_M4": [],
  "M1": [],
  "M3": [],
  "M4": [],
  "DATASETS_SINGLE": [],
  "DATASETS_FULL": [],
  "DATASETS_FILTERED": [],
  "sample_datasets": [
    "n_folds",
    "train_size",
    "val_size",
    "test_size",
    "seed"
  ],
  "M4_PREDICTION_LENGTHS": [],
  "M4DataModule": {
    "__init__": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory"
    ],
    "name": [
      "cls"
    ]
  },
  "DatasetSplits": {
    "train": [
      "self",
      "val",
      "name"
    ],
    "val": [
      "self",
      "name"
    ],
    "test": [
      "self",
      "name"
    ]
  },
  "DatasetSplit": {
    "data": [
      "self",
      "evaluation"
    ],
    "support_set": [
      "self"
    ],
    "evaluation": [
      "self"
    ],
    "prepare": [
      "self"
    ]
  },
  "EvaluationDataset": {},
  "_generate_evaluation_dataset": [
    "dataset",
    "prediction_length"
  ],
  "DominickDataModule": {
    "__init__": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory"
    ],
    "name": [
      "cls"
    ]
  },
  "generate_dominick_dataset": [
    "dataset_path",
    "prediction_length"
  ],
  "SuperDataModule": {
    "__init__": [
      "self",
      "dataset_names_train",
      "dataset_names_val",
      "dataset_names_test",
      "num_queries",
      "support_set_size",
      "prediction_length",
      "context_length_multiple",
      "support_length_multiple",
      "dataset_sampling",
      "data_dir",
      "standardize",
      "batch_size_train",
      "batch_size_val_test",
      "num_workers",
      "seed",
      "catch22_train",
      "catch22_val_test",
      "cheat"
    ],
    "prediction_length": [
      "self"
    ],
    "setup": [
      "self",
      "stage"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "test_dataloader": [
      "self"
    ],
    "get_log_batches": [
      "self",
      "n_logging_samples"
    ],
    "name": [
      "cls"
    ]
  },
  "M": [],
  "register_data_module": [
    "cls"
  ],
  "get_data_module": [
    "name"
  ],
  "Item": [],
  "ConstantTargetFilter": {
    "__init__": [
      "self",
      "prediction_length",
      "required_length"
    ],
    "__call__": [
      "self",
      "items"
    ]
  },
  "AbsoluteValueFilter": {
    "__init__": [
      "self",
      "value"
    ],
    "__call__": [
      "self",
      "items"
    ]
  },
  "EndOfSeriesCutFilter": {
    "__init__": [
      "self",
      "prediction_length"
    ],
    "__call__": [
      "self",
      "items"
    ]
  },
  "MinLengthFilter": {
    "__init__": [
      "self",
      "length"
    ],
    "__call__": [
      "self",
      "items"
    ]
  },
  "Transform": {
    "__call__": [
      "self",
      "items"
    ]
  },
  "ItemIDTransform": {
    "__init__": [
      "self",
      "required_length"
    ],
    "__call__": [
      "self",
      "items"
    ]
  },
  "read_transform_write": [
    "file",
    "filters",
    "source"
  ],
  "plot_forecast_supportset_attention": [
    "query_past",
    "query_future",
    "pred",
    "supps",
    "attention",
    "quantiles"
  ],
  "plot_quantile_forecast": [
    "query_past",
    "query_future",
    "pred",
    "quantiles"
  ],
  "_plot_quantile_forecast": [
    "sub",
    "query_past",
    "query_future",
    "pred",
    "quantiles"
  ],
  "plot_point_forecast": [
    "sub",
    "query_past",
    "query_future",
    "pred"
  ],
  "get_save_dir_from_csvlogger": [
    "logger"
  ],
  "get_loss_steps": [
    "loss_name",
    "trainer"
  ],
  "QuantileMetricLoggerCallback": {
    "__init__": [
      "self",
      "quantiles",
      "split",
      "every_n_epochs"
    ],
    "on_validation_epoch_end": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "InitialSaveCallback": {
    "__init__": [
      "self",
      "args_to_save"
    ],
    "on_pretrain_routine_start": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "ParameterCountCallback": {
    "__init__": [
      "self"
    ],
    "on_pretrain_routine_start": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "ForecastPlotLoggerCallback": {
    "__init__": [
      "self",
      "log_batch",
      "quantiles",
      "split",
      "every_n_epochs"
    ],
    "on_validation_epoch_end": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "ForecastSupportSetAttentionPlotLoggerCallback": {
    "__init__": [
      "self",
      "log_batch",
      "quantiles",
      "split",
      "every_n_epochs"
    ],
    "on_validation_epoch_end": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "LossPlotLoggerCallback": {
    "__init__": [
      "self",
      "every_n_epochs"
    ],
    "on_validation_epoch_end": [
      "self",
      "trainer",
      "pl_module"
    ],
    "on_fit_end": [
      "self",
      "trainer",
      "pl_module"
    ],
    "plot_loss": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "CheatLossPlotLoggerCallback": {
    "__init__": [
      "self",
      "dataset_names_val"
    ],
    "plot_loss": [
      "self",
      "trainer",
      "pl_module"
    ]
  },
  "MacroCRPSPlotCallback": {
    "__init__": [
      "self",
      "every_n_epochs"
    ],
    "on_validation_epoch_end": [
      "self",
      "trainer",
      "pl_module"
    ],
    "on_fit_end": [
      "self",
      "trainer",
      "pl_module"
    ],
    "plot_crps": [
      "self",
      "trainer",
      "scaled"
    ]
  },
  "SeriesBatch": {
    "from_lists": [
      "cls",
      "lists",
      "squeeze"
    ],
    "pin_memory": [
      "self"
    ],
    "unpad": [
      "self",
      "to_numpy",
      "squeeze"
    ],
    "to": [
      "self",
      "device"
    ],
    "rescale": [
      "self"
    ],
    "one_per_split": [
      "self"
    ],
    "first_n": [
      "self",
      "n"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "TripletBatch": {
    "collate": [
      "cls",
      "triplets"
    ],
    "to": [
      "self",
      "device"
    ],
    "pin_memory": [
      "self"
    ],
    "reduce_to_unique_query": [
      "self"
    ],
    "first_n": [
      "self",
      "n"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "WeightedIndexIterator": {
    "__init__": [
      "self",
      "weights",
      "num_cache"
    ],
    "__iter__": [
      "self"
    ],
    "__next__": [
      "self"
    ]
  },
  "Triplet": {
    "__iter__": [
      "self"
    ]
  },
  "TripletDataset": {
    "__init__": [
      "self",
      "queries",
      "support_sets"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "SamplingTripletDataset": {
    "__init__": [
      "self",
      "dataset",
      "support_set_size",
      "num_queries",
      "context_length",
      "support_length",
      "prediction_length",
      "catch22_nn",
      "cheat"
    ],
    "__iter__": [
      "self"
    ],
    "_sample_queries": [
      "self"
    ]
  },
  "SequentialTripletDataset": {
    "__init__": [
      "self",
      "dataset",
      "support_set_size",
      "num_queries",
      "context_length",
      "support_length",
      "prediction_length",
      "support_dataset",
      "seed",
      "catch22_nn",
      "cheat"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "_last_slice": [
      "self",
      "series"
    ]
  },
  "sample_supps": [
    "supps_size",
    "length",
    "dataset",
    "index_iterator",
    "q_split",
    "cheat_query"
  ],
  "SuperSamplingTripletDataset": {
    "__init__": [
      "self",
      "datasets",
      "dataset_sampling"
    ],
    "__iter__": [
      "self"
    ]
  },
  "TimeSeriesDataset": {
    "__init__": [
      "self",
      "series",
      "prediction_length",
      "freq",
      "standardize"
    ],
    "rescale_dataset": [
      "self",
      "series"
    ],
    "number_of_time_steps": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "load_weights": [
    "model",
    "path_to_weights"
  ],
  "MetaLightningModule": {
    "__init__": [
      "self",
      "model",
      "val_dataset_names",
      "test_dataset_names",
      "lr_scheduler_monitor",
      "loss",
      "crps",
      "crps_scaled",
      "lr",
      "lr_on_plateau_patience",
      "lr_on_plateau_factor",
      "quantile_width"
    ],
    "configure_optimizers": [
      "self"
    ],
    "training_step": [
      "self",
      "batch"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_epoch_end": [
      "self",
      "validation_step_outputs"
    ],
    "test_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "test_epoch_end": [
      "self",
      "test_step_outputs"
    ]
  },
  "_init_metrics": [
    "dataset_names",
    "crps",
    "crps_scaled"
  ],
  "MetaModel": {
    "forward": [
      "self",
      "supps",
      "query"
    ],
    "device": [
      "self"
    ]
  },
  "SeriesModel": {
    "forward": [
      "self",
      "query"
    ],
    "device": [
      "self"
    ]
  },
  "register_model": [
    "cls"
  ],
  "get_model": [
    "name"
  ],
  "LSTMEncoderFeedforwardDecoderConfig": {},
  "LSTMEncoderFeedforwardDecoder": {
    "__init__": [
      "self",
      "config"
    ],
    "name": [
      "cls"
    ],
    "forward": [
      "self",
      "supps",
      "query"
    ]
  },
  "EncoderDecoderMetaModel": {
    "__init__": [
      "self",
      "feature_extractor",
      "supps_enc",
      "query_enc",
      "attention",
      "decoder"
    ],
    "forward": [
      "self",
      "supps",
      "query",
      "return_attention"
    ]
  },
  "IwataKumagaiEcDcConfig": {},
  "IwataKumagaiEcDc": {
    "__init__": [
      "self",
      "config"
    ],
    "name": [
      "cls"
    ]
  },
  "CNNLSTMEcDcConfig": {},
  "CNNLSTMEcDc": {
    "__init__": [
      "self",
      "config"
    ],
    "name": [
      "cls"
    ]
  },
  "TcnEcDcConfig": {},
  "TcnEcDc": {
    "__init__": [
      "self",
      "config"
    ],
    "name": [
      "cls"
    ]
  },
  "SupportSetEncoder": {
    "forward": [
      "self",
      "supps"
    ]
  },
  "LSTMSupportSetEncoder": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "num_layers",
      "bidirectional"
    ],
    "forward": [
      "self",
      "supps"
    ]
  },
  "CNNSupportSetEncoder": {
    "__init__": [
      "self",
      "input_size",
      "out_channels"
    ],
    "forward": [
      "self",
      "supps"
    ]
  },
  "TcnSupportSetEncoder": {
    "__init__": [
      "self",
      "encoder",
      "num_channels",
      "num_layers",
      "kernel_size"
    ],
    "forward": [
      "self",
      "supps"
    ]
  },
  "FeatureExtractor": {
    "forward": [
      "self",
      "series"
    ]
  },
  "IdentityFeatureExtractor": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "series"
    ]
  },
  "QueryEncoder": {
    "forward": [
      "self",
      "query"
    ]
  },
  "LSTMQueryEncoder": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "num_layers"
    ],
    "forward": [
      "self",
      "query"
    ]
  },
  "TcnQueryEncoder": {
    "__init__": [
      "self",
      "encoder",
      "num_channels",
      "num_layers",
      "kernel_size"
    ],
    "forward": [
      "self",
      "query"
    ]
  },
  "Decoder": {
    "forward": [
      "self",
      "query",
      "value"
    ]
  },
  "FeedForwardQuantileDecoder": {
    "__init__": [
      "self",
      "num_quantiles",
      "embed_size",
      "q_size",
      "hidden_size",
      "prediction_length"
    ],
    "forward": [
      "self",
      "query",
      "value"
    ]
  },
  "SupportSetQueryAttention": {
    "forward": [
      "self",
      "query",
      "supps"
    ]
  },
  "MultiHeadSupportSetQueryAttention": {
    "__init__": [
      "self",
      "supps_size",
      "q_size",
      "num_heads"
    ],
    "forward": [
      "self",
      "supps",
      "query",
      "mask"
    ]
  },
  "SqueezeChannels": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CausalConvolution": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "dilation"
    ],
    "forward": [
      "self",
      "sequences"
    ]
  },
  "CausalConvolutionBlock": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "dilation",
      "final"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CausalCNN": {
    "__init__": [
      "self",
      "in_channels",
      "channels",
      "depth",
      "out_channels",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CausalCNNEncoder": {
    "__init__": [
      "self",
      "in_channels",
      "channels",
      "depth",
      "out_channels",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "real": [
    "catch22"
  ],
  "artificial": [
    "config"
  ],
  "statistics": [],
  "_tensor_collator": [
    "batch"
  ],
  "_variable_length_collator": [
    "batch"
  ],
  "_pair_variable_length_collator": [
    "batch"
  ],
  "DomAdaptDataset": {
    "__init__": [
      "self",
      "source_dataset",
      "target_dataset"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "from_domains": [
      "cls",
      "source_dataset",
      "target_dataset"
    ]
  },
  "SeasonalDataset": {
    "__getitem__": [
      "self",
      "index"
    ],
    "d_data": [
      "self"
    ],
    "d_feats": [
      "self"
    ],
    "full_windows": [
      "cls",
      "corpus"
    ],
    "create_dataset": [
      "cls",
      "n_instances_train",
      "n_instances_test",
      "n_samples"
    ]
  },
  "FourierDataset": {},
  "ComplexDataset": {},
  "RandomDataset": {},
  "TrendFourierDataset": {},
  "BenchmarkDataset": {
    "__getitem__": [
      "self",
      "index"
    ],
    "d_data": [
      "self"
    ],
    "d_feats": [
      "self"
    ],
    "create_dataset": [
      "cls",
      "dataset",
      "freq",
      "n_instances_train",
      "n_instances_eval",
      "eval_size",
      "window_size",
      "window_size_plus",
      "window_size_minus",
      "window_shift",
      "train_size",
      "validation",
      "seed"
    ]
  },
  "_freqs": [],
  "_window_size": [],
  "_horizons": [],
  "update_configs": [
    "configs",
    "defaults"
  ],
  "parse_configs": [
    "cmd"
  ],
  "ZScoreNormalizer": {
    "__init__": [
      "self",
      "eps",
      "rescale_loss"
    ],
    "forward_pre_hook": [
      "self",
      "module",
      "input"
    ],
    "forward_hook": [
      "self",
      "module",
      "input",
      "output"
    ]
  },
  "LossFunction": {
    "__call__": [
      "self",
      "preds",
      "truth"
    ],
    "_aggregate_loss": [
      "self",
      "loss",
      "loss_mask"
    ],
    "loss_hook": [
      "self",
      "module",
      "input",
      "output"
    ]
  },
  "MSELoss": {
    "__call__": [
      "self",
      "preds",
      "truth"
    ],
    "loss_hook": [
      "self",
      "module",
      "input",
      "output"
    ]
  },
  "MAELoss": {
    "__call__": [
      "self",
      "preds",
      "truth"
    ]
  },
  "DomAdaptEstimator": {
    "__init__": [
      "self",
      "src_module",
      "tgt_module",
      "balance_loss",
      "forecast_target"
    ],
    "forward": [
      "self",
      "src_data",
      "tgt_data",
      "src_feats",
      "tgt_feats",
      "src_nan_mask",
      "tgt_nan_mask",
      "src_length",
      "tgt_length"
    ]
  },
  "AdversarialDomAdaptEstimator": {
    "__init__": [
      "self",
      "src_module",
      "tgt_module",
      "balance_loss",
      "forecast_target",
      "disc_lambda"
    ],
    "generative": [
      "self"
    ],
    "discriminative": [
      "self"
    ],
    "forward": [
      "self",
      "src_data",
      "tgt_data",
      "src_feats",
      "tgt_feats",
      "src_nan_mask",
      "tgt_nan_mask",
      "src_length",
      "tgt_length"
    ]
  },
  "MIN_TRADEOFF": [],
  "AttentionEstimator": {
    "__init__": [
      "self"
    ],
    "_create_modules": [
      "self"
    ],
    "tradeoff": [
      "self"
    ],
    "n_layer": [
      "self"
    ],
    "tie_layers": [
      "self"
    ],
    "register_loss_func": [
      "self",
      "func"
    ],
    "_step": [
      "self",
      "data",
      "feats",
      "mask"
    ],
    "_rollout": [
      "self",
      "data",
      "feats",
      "mask",
      "total_steps"
    ],
    "forward": [
      "self",
      "data",
      "feats",
      "nan_mask",
      "length"
    ],
    "from_configs": [
      "cls",
      "d_data",
      "d_feats",
      "d_hidden",
      "n_layer",
      "horizon",
      "window_size",
      "n_head",
      "n_enc_layer",
      "n_dec_layer",
      "symmetric",
      "share_values",
      "tie_casts",
      "tie_layers",
      "dropout",
      "temperature",
      "norm",
      "add_dist",
      "normalize_input",
      "rescale_output",
      "layerwise_loss"
    ],
    "create_twin_estimator": [
      "self",
      "d_data",
      "d_feats"
    ]
  },
  "AdversarialEstimator": {
    "__init__": [
      "self"
    ],
    "_create_modules": [
      "self"
    ],
    "generative": [
      "self"
    ],
    "discriminative": [
      "self"
    ],
    "generative_named_parameters": [
      "self"
    ],
    "discriminative_named_parameters": [
      "self"
    ],
    "generative_parameters": [
      "self"
    ],
    "discriminative_parameters": [
      "self"
    ],
    "prob_domain": [
      "self"
    ],
    "from_configs": [
      "cls",
      "d_data",
      "d_feats",
      "d_hidden",
      "n_layer",
      "horizon",
      "window_size",
      "n_head",
      "n_enc_layer",
      "n_dec_layer",
      "n_disc_layer",
      "symmetric",
      "share_values",
      "tie_casts",
      "tie_layers",
      "dropout",
      "temperature",
      "norm",
      "add_dist",
      "normalize_input",
      "rescale_output",
      "layerwise_loss"
    ],
    "from_base": [
      "cls",
      "base",
      "n_disc_layer"
    ],
    "create_twin_estimator": [
      "self",
      "d_data",
      "d_feats"
    ]
  },
  "AttentionTrainer": {
    "_batch_loop": [
      "self",
      "epoch"
    ],
    "_train": [
      "self"
    ],
    "_validate": [
      "self"
    ],
    "from_configs": [
      "cls",
      "dataset",
      "model",
      "log_dir",
      "cuda_device",
      "n_epochs",
      "nb_epoch",
      "batch_size",
      "max_grad_norm",
      "lr",
      "betas",
      "weight_decay",
      "amsgrad",
      "debug"
    ]
  },
  "AttentionEvaluator": {
    "_test": [
      "self"
    ],
    "_predict": [
      "self"
    ],
    "from_trainer": [
      "cls",
      "trainer",
      "model_tag"
    ]
  },
  "DomAdaptTrainer": {
    "_train": [
      "self"
    ],
    "_validate": [
      "self"
    ],
    "from_configs": [
      "cls",
      "dataset",
      "model",
      "log_dir",
      "cuda_device",
      "n_epochs",
      "nb_epoch",
      "batch_size",
      "max_grad_norm",
      "lr",
      "betas",
      "weight_decay",
      "amsgrad",
      "debug"
    ]
  },
  "DomAdaptEvaluator": {
    "_test": [
      "self"
    ],
    "predict": [
      "self",
      "dataset"
    ],
    "_predict": [
      "self"
    ],
    "from_trainer": [
      "cls",
      "trainer",
      "model_tag"
    ]
  },
  "AdversarialDomAdaptTrainer": {
    "__init__": [
      "self",
      "dataset",
      "model",
      "optimizer",
      "scheduler"
    ],
    "_train": [
      "self"
    ],
    "_validate": [
      "self"
    ],
    "from_configs": [
      "cls",
      "dataset",
      "model",
      "log_dir",
      "cuda_device",
      "n_epochs",
      "nb_epoch",
      "batch_size",
      "max_grad_norm",
      "lr",
      "betas",
      "weight_decay",
      "amsgrad",
      "debug"
    ]
  },
  "AdversarialDomAdaptEvaluator": {
    "from_trainer": [
      "cls",
      "trainer",
      "model_tag"
    ]
  },
  "InstanceNorm1d": {
    "forward": [
      "self",
      "x"
    ]
  },
  "AttentionKernel": {
    "__init__": [
      "self",
      "d_hidden",
      "n_head",
      "n_enc_layer",
      "n_dec_layer",
      "m_output",
      "symmetric",
      "share_values",
      "dropout",
      "temperature",
      "norm",
      "add_dist"
    ],
    "_reset_parameters": [
      "self"
    ],
    "_kernel": [
      "self",
      "q",
      "k"
    ],
    "_compute_attn_score": [
      "self",
      "shape",
      "left_pad",
      "right_pad",
      "mask"
    ],
    "_compute_attn_output": [
      "self",
      "score",
      "value",
      "dist_comp"
    ],
    "forward": [
      "self",
      "shape",
      "inter_value",
      "extra_value",
      "mask"
    ]
  },
  "ExpKernel": {
    "_kernel": [
      "self",
      "q",
      "k"
    ]
  },
  "SimpleDiscriminator": {
    "__init__": [
      "self",
      "d_model",
      "n_layer",
      "n_hidden"
    ],
    "_reset_parameters": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "EncoderModule": {
    "__init__": [
      "self",
      "d_data",
      "d_feats",
      "d_hidden",
      "d_value"
    ],
    "_reset_parameters": [
      "self"
    ],
    "_compute_shape": [
      "self",
      "data"
    ],
    "_compute_value": [
      "self",
      "data"
    ],
    "forward": [
      "self",
      "data",
      "feats"
    ]
  },
  "DecoderModule": {
    "__init__": [
      "self",
      "d_data",
      "d_hidden"
    ],
    "_reset_parameters": [
      "self"
    ],
    "forward": [
      "self",
      "data"
    ]
  },
  "AttentionBlock": {
    "__init__": [
      "self",
      "encoder",
      "kernel",
      "decoder"
    ],
    "forward": [
      "self",
      "data",
      "feats",
      "mask"
    ]
  },
  "AdversarialBlock": {
    "__init__": [
      "self",
      "encoder",
      "kernel",
      "decoder",
      "disc"
    ],
    "generative": [
      "self"
    ],
    "discriminative": [
      "self"
    ],
    "forward": [
      "self",
      "data",
      "feats",
      "mask"
    ]
  },
  "_dict_equal": [
    "dict1",
    "dict2",
    "cmp_func"
  ],
  "_pad_array_along_axis": [
    "array",
    "pad",
    "axis",
    "constant_values"
  ],
  "TimeSeriesInstant": {
    "__init__": [
      "self",
      "target",
      "timestamp",
      "series_name",
      "target_names"
    ],
    "add_features": [
      "self",
      "name",
      "data",
      "data_type"
    ],
    "categorical_features": [
      "self"
    ],
    "numerical_features": [
      "self"
    ],
    "d_data": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "TimeSeriesCorpus": {
    "__init__": [
      "self",
      "instances",
      "scopes",
      "categorical_encoders",
      "numerical_encoders",
      "add_series_id"
    ],
    "_check_consistency": [
      "self",
      "instances"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__getattr__": [
      "self",
      "key"
    ],
    "cardinalities": [
      "self"
    ],
    "split_by_timestamp": [
      "self",
      "split_timestamp",
      "horizon",
      "context",
      "n_rolls",
      "shift",
      "raise_error"
    ],
    "split_from_end": [
      "self",
      "horizon",
      "context",
      "n_rolls",
      "shift",
      "raise_error"
    ],
    "split_from_end_by_blocks": [
      "self",
      "horizon",
      "context",
      "n_rolls",
      "n_blocks",
      "shift",
      "raise_error"
    ]
  },
  "ForecastingDataset": {
    "__init__": [
      "self",
      "corpus",
      "windows",
      "horizon",
      "context",
      "gap"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "_fetch": [
      "self",
      "index"
    ],
    "sliding_windows": [
      "cls",
      "corpus",
      "horizon",
      "context",
      "gap",
      "shift"
    ],
    "random_windows": [
      "cls",
      "corpus",
      "n_windows",
      "horizon",
      "context",
      "gap",
      "shift",
      "cold_start",
      "favor_recent"
    ]
  },
  "_default_collate_err_msg_format": [],
  "np_str_obj_array_pattern": [],
  "_default_collate": [
    "batch"
  ],
  "copy_to_gpu": [
    "data",
    "cuda_device",
    "non_blocking"
  ],
  "MetaDataset": {
    "__getattr__": [
      "self",
      "key"
    ],
    "train_size": [
      "self"
    ],
    "valid_size": [
      "self"
    ],
    "test_size": [
      "self"
    ],
    "_data_loader": [
      "self",
      "dataset",
      "batch_size",
      "shuffle",
      "cuda_device",
      "is_training",
      "n_workers",
      "n_batches"
    ],
    "train_loader": [
      "self",
      "batch_size",
      "shuffle",
      "cuda_device",
      "n_workers",
      "n_batches"
    ],
    "valid_loader": [
      "self",
      "batch_size",
      "cuda_device",
      "n_workers"
    ],
    "test_loader": [
      "self",
      "batch_size",
      "cuda_device",
      "n_workers"
    ]
  },
  "WindowsDataset": {
    "__init__": [
      "self",
      "corpus",
      "windows"
    ],
    "__len__": [
      "self"
    ],
    "_fetch": [
      "self",
      "index"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "sliding_windows": [
      "cls",
      "corpus",
      "window_size",
      "window_size_plus",
      "window_size_minus",
      "window_shift",
      "seed"
    ],
    "random_windows": [
      "cls",
      "corpus",
      "n_windows",
      "window_size",
      "window_size_plus",
      "window_size_minus",
      "window_shift",
      "seed"
    ]
  },
  "add_datetime_features": [
    "ts",
    "add_month_of_year",
    "add_week_of_year",
    "add_day_of_year",
    "add_day_of_month",
    "add_day_of_week",
    "add_hour_of_day",
    "add_minute_of_hour",
    "normalized"
  ],
  "add_duration_feature": [
    "ts",
    "log_scale",
    "normalized"
  ],
  "quantile_error": [
    "preds",
    "target",
    "percentage"
  ],
  "quantile_percent_error": [
    "preds",
    "target",
    "percentage"
  ],
  "absolute_percent_error": [
    "preds",
    "target"
  ],
  "root_square_error": [
    "preds",
    "target"
  ],
  "root_square_percent_error": [
    "preds",
    "target"
  ],
  "tweedie_loss": [
    "p"
  ],
  "Meter": {
    "__init__": [
      "self",
      "min_mode"
    ],
    "_initialize": [
      "self"
    ],
    "restart": [
      "self"
    ],
    "update": [
      "self"
    ],
    "value": [
      "self"
    ],
    "is_optimal": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict"
    ],
    "__repr__": [
      "self"
    ]
  },
  "NumericalAverageMeter": {
    "_initialize": [
      "self"
    ],
    "update": [
      "self",
      "value"
    ],
    "value": [
      "self"
    ]
  },
  "BatchAverageMeter": {
    "__init__": [
      "self",
      "min_mode",
      "avg_in_batch"
    ],
    "update": [
      "self",
      "values"
    ]
  },
  "MeanDeviationMeter": {
    "__init__": [
      "self"
    ],
    "_initialize": [
      "self"
    ],
    "update": [
      "self",
      "deviation",
      "base"
    ],
    "value": [
      "self"
    ]
  },
  "RootMeanSquareDeviationMeter": {
    "update": [
      "self",
      "deviation",
      "base"
    ],
    "value": [
      "self"
    ]
  },
  "MeterDict": {
    "__init__": [
      "self",
      "meters",
      "meterdicts"
    ],
    "register_meter": [
      "self",
      "name",
      "meter"
    ],
    "register_meterdict": [
      "self",
      "name",
      "meterdict"
    ],
    "__setattr__": [
      "self",
      "name",
      "value"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__delattr__": [
      "self",
      "name"
    ],
    "__setitem__": [
      "self",
      "name",
      "value"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "__contains__": [
      "self",
      "name"
    ],
    "get": [
      "self",
      "name",
      "default"
    ],
    "_named_dicts": [
      "self",
      "memo",
      "prefix"
    ],
    "_named_meters": [
      "self",
      "prefix"
    ],
    "restart": [
      "self"
    ],
    "value": [
      "self"
    ],
    "best": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict"
    ],
    "__repr__": [
      "self"
    ]
  },
  "GeLU": {
    "forward": [
      "self",
      "x"
    ]
  },
  "Swish": {
    "forward": [
      "self",
      "x"
    ]
  },
  "PositiveSoftplus": {
    "__init__": [
      "self",
      "margin",
      "beta",
      "threshold"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "distribution_cat": [
    "distributions",
    "dim"
  ],
  "GaussianLayer": {
    "__init__": [
      "self",
      "d_hidden",
      "d_data"
    ],
    "forward": [
      "self",
      "hidden"
    ]
  },
  "ResidualBlock": {
    "__init__": [
      "self",
      "residual_network",
      "skip_network"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "LockedDropout": {
    "__init__": [
      "self",
      "dropout",
      "lock_dim",
      "inplace"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DilatedQueue": {
    "__init__": [
      "self",
      "maxlen"
    ],
    "_reset": [
      "self"
    ],
    "initialize": [
      "self",
      "x"
    ],
    "append": [
      "self",
      "x"
    ]
  },
  "add_weightnorm": [],
  "PositionwiseFFN": {
    "__init__": [
      "self",
      "d_model",
      "d_hidden",
      "pre_ln",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TransformerEncoderBlock": {
    "__init__": [
      "self",
      "d_qk",
      "d_value",
      "d_ffn",
      "n_head",
      "n_groups",
      "bidirectional",
      "apply_rel_dist",
      "composite_attention",
      "pre_ln",
      "dropout",
      "temperature"
    ],
    "forward": [
      "self",
      "value",
      "shape",
      "estimate",
      "mask"
    ]
  },
  "TransformerDecoderBlock": {
    "__init__": [
      "self",
      "d_query",
      "d_src",
      "d_ffn",
      "n_head",
      "bidirectional",
      "apply_rel_dist",
      "pre_ln",
      "dropout",
      "temperature"
    ],
    "forward": [
      "self",
      "x",
      "src",
      "mask",
      "src_mask"
    ]
  },
  "Attention": {
    "__init__": [
      "self",
      "d_hidden",
      "n_head",
      "bias",
      "dropout",
      "temperature"
    ],
    "_split_head": [
      "self",
      "x"
    ],
    "_merge_head": [
      "self",
      "x"
    ],
    "_compute_qkv": [
      "self"
    ],
    "_compute_attn_score": [
      "self",
      "q",
      "k"
    ],
    "_compute_attn_output": [
      "self",
      "score",
      "v"
    ]
  },
  "LearnablePositionalEmbedding": {
    "__init__": [
      "self",
      "d_embed",
      "max_len",
      "hierarchy"
    ],
    "_reset_parameters": [
      "self"
    ],
    "n_levels": [
      "self"
    ],
    "forward": [
      "self",
      "pos_seq"
    ]
  },
  "GroupSelfAttention": {
    "__init__": [
      "self",
      "d_qk",
      "d_value",
      "n_head",
      "n_groups",
      "bias",
      "bidirectional",
      "apply_rel_dist",
      "share_values",
      "dropout",
      "temperature"
    ],
    "_reset_parameters": [
      "self"
    ],
    "_compute_qkv": [
      "self",
      "value",
      "shape"
    ],
    "forward": [
      "self",
      "value",
      "shape"
    ]
  },
  "CompositeAttention": {
    "_compute_qkv": [
      "self",
      "value",
      "shape",
      "estimate"
    ],
    "_compute_attn_output": [
      "self",
      "score",
      "v",
      "e"
    ],
    "forward": [
      "self",
      "value",
      "shape",
      "estimate",
      "mask"
    ]
  },
  "InterAttention": {
    "__init__": [
      "self",
      "d_query",
      "d_kv",
      "n_head",
      "bias",
      "apply_kv_proj",
      "apply_rel_dist",
      "share_values",
      "dropout",
      "temperature"
    ],
    "_reset_parameters": [
      "self"
    ],
    "_compute_qkv": [
      "self",
      "query",
      "src"
    ],
    "_apply_mask": [
      "self",
      "score",
      "key_mask"
    ],
    "_compute_attn_score": [
      "self",
      "q",
      "k",
      "key_mask",
      "gap"
    ],
    "_compute_attn_output": [
      "self",
      "score",
      "v"
    ],
    "forward": [
      "self",
      "query",
      "src",
      "src_mask",
      "gap"
    ]
  },
  "is_distributed": [],
  "get_world_size": [],
  "get_rank": [],
  "is_main_process": [],
  "synchronize": [],
  "reduce_value": [
    "value",
    "dst",
    "average"
  ],
  "init_distributed": [
    "cuda",
    "local_rank",
    "node_rank",
    "n_nodes",
    "n_procs",
    "master_addr",
    "master_port"
  ],
  "Optimization": {
    "__init__": [
      "self",
      "grad_cum_step",
      "max_grad_norm",
      "lr_decay_freq"
    ],
    "on_train_begin": [
      "self"
    ],
    "on_batch_end": [
      "self",
      "batch"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ]
  },
  "DebugStopper": {
    "__init__": [
      "self",
      "debug_stop_batch",
      "debug_stop_epoch"
    ],
    "on_train_begin": [
      "self"
    ],
    "on_batch_end": [
      "self",
      "batch"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ],
    "on_valid_batch_end": [
      "self",
      "batch"
    ]
  },
  "EarlyStopping": {
    "__init__": [
      "self",
      "patience",
      "monitor",
      "minimize",
      "threshold"
    ],
    "on_train_begin": [
      "self"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ],
    "on_train_end": [
      "self"
    ]
  },
  "Checkpoint": {
    "__init__": [
      "self",
      "monitor",
      "minimize",
      "threshold",
      "keep_epoch_dump"
    ],
    "on_train_begin": [
      "self"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ]
  },
  "ProgressBar": {
    "__init__": [
      "self",
      "batch_monitors",
      "epoch_monitors"
    ],
    "on_epoch_begin": [
      "self",
      "epoch"
    ],
    "on_batch_end": [
      "self",
      "batch"
    ],
    "on_valid_begin": [
      "self",
      "epoch"
    ],
    "on_valid_batch_end": [
      "self",
      "batch"
    ],
    "on_valid_end": [
      "self",
      "epoch"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ]
  },
  "Tensorboard": {
    "__init__": [
      "self",
      "batch_monitors",
      "epoch_monitors",
      "hparams",
      "metrics",
      "comment"
    ],
    "on_train_begin": [
      "self"
    ],
    "on_batch_end": [
      "self",
      "batch"
    ],
    "on_epoch_end": [
      "self",
      "epoch"
    ],
    "on_train_end": [
      "self"
    ]
  },
  "HyperOptManager": {
    "__init__": [
      "self",
      "dataset",
      "work_dir",
      "fixed_params",
      "cuda_device",
      "key_factor",
      "min_mode",
      "resume"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ],
    "hyperparameters": [
      "self",
      "n_iter"
    ],
    "get_log_dir": [
      "self",
      "params"
    ],
    "get_optimal_model": [
      "self"
    ],
    "dump_records": [
      "self"
    ],
    "load_records": [
      "self"
    ],
    "update_record": [
      "self",
      "params"
    ],
    "print_params": [
      "params"
    ],
    "run_training": [
      "self",
      "params"
    ],
    "run_test": [
      "self",
      "exp_dir"
    ],
    "random_search": [
      "self",
      "n_iter"
    ],
    "fixed_train": [
      "self"
    ]
  },
  "make_metrics": [
    "metrics_names"
  ],
  "make_job_name": [
    "base_job_name"
  ],
  "GluonTSPredictor": {
    "__init__": [
      "self",
      "endpoint_name",
      "sagemaker_session"
    ]
  },
  "GluonTSModel": {
    "__framework_name__": [],
    "_LOWEST_MMS_VERSION": [],
    "__init__": [
      "self",
      "model_data",
      "role",
      "entry_point",
      "image",
      "framework_version",
      "predictor_cls",
      "model_server_workers"
    ],
    "prepare_container_def": [
      "self",
      "instance_type",
      "accelerator_type"
    ]
  },
  "TrainResult": {},
  "Locations": {
    "job_output_path": [
      "self"
    ],
    "job_code_location": [
      "self"
    ],
    "estimator_path": [
      "self"
    ],
    "output_archive": [
      "self"
    ],
    "model_archive": [
      "self"
    ]
  },
  "GluonTSFramework": {
    "__framework_name__": [],
    "_LOWEST_SCRIPT_MODE_VERSION": [],
    "LATEST_VERSION": [],
    "__init__": [
      "self",
      "sagemaker_session",
      "role",
      "image_uri",
      "base_job_name",
      "instance_type",
      "instance_count",
      "dependencies",
      "output_path",
      "code_location",
      "framework_version",
      "hyperparameters",
      "entry_point"
    ],
    "create_model": [
      "self",
      "model_server_workers",
      "role",
      "vpc_config_override",
      "entry_point",
      "source_dir",
      "dependencies",
      "image_uri"
    ],
    "_prepare_init_params_from_job_description": [
      "cls",
      "job_details",
      "model_channel_name"
    ],
    "_initialize_job": [
      "self",
      "monitored_metrics",
      "dataset",
      "num_samples",
      "quantiles",
      "job_name"
    ],
    "_upload_estimator": [
      "self",
      "locations",
      "estimator"
    ],
    "_prepare_inputs": [
      "self",
      "locations",
      "dataset"
    ],
    "_retrieve_metrics": [
      "self",
      "locations"
    ],
    "_retrieve_model": [
      "self",
      "locations"
    ],
    "train": [
      "self",
      "dataset",
      "estimator",
      "num_samples",
      "quantiles",
      "monitored_metrics",
      "wait",
      "logs",
      "job_name"
    ],
    "run": [
      "cls",
      "entry_point",
      "inputs",
      "sagemaker_session",
      "role",
      "image_uri",
      "base_job_name",
      "instance_type",
      "instance_count",
      "dependencies",
      "output_path",
      "code_location",
      "framework_version",
      "hyperparameters",
      "source_dir",
      "monitored_metrics",
      "wait",
      "logs",
      "job_name"
    ]
  },
  "GLUONTS_VERSION": [],
  "FRAMEWORK_NAME": [],
  "LOWEST_MMS_VERSION": [],
  "LOWEST_SCRIPT_MODE_VERSION": [],
  "LATEST_GLUONTS_VERSION": [],
  "PYTHON_VERSION": [],
  "ENTRY_POINTS_FOLDER": [],
  "TRAIN_SCRIPT": [],
  "MONITORED_METRICS": [],
  "NUM_SAMPLES": [],
  "QUANTILES": [],
  "run": [
    "arguments"
  ],
  "train": [
    "arguments"
  ],
  "LocalTabularPredictor": [],
  "run_example": [],
  "no_scaling": [
    "series"
  ],
  "get_features_dataframe": [
    "series",
    "time_features",
    "lag_indices",
    "past_data"
  ],
  "TabularPredictor": {
    "__init__": [
      "self",
      "ag_model",
      "prediction_length",
      "time_features",
      "lag_indices",
      "scaling",
      "batch_size",
      "quantiles_to_predict",
      "dtype"
    ],
    "auto_regression": [
      "self"
    ],
    "_to_forecast": [
      "self",
      "ag_output",
      "start_timestamp",
      "item_id"
    ],
    "_predict_serial": [
      "self",
      "dataset"
    ],
    "_predict_batch_one_shot": [
      "self",
      "dataset"
    ],
    "_predict_batch_autoreg": [
      "self",
      "dataset"
    ],
    "_predict_batch": [
      "self",
      "dataset",
      "batch_size"
    ],
    "predict": [
      "self",
      "dataset",
      "batch_size"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path",
      "scaling"
    ]
  },
  "TabularEstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "lag_indices",
      "time_features",
      "scaling",
      "batch_size",
      "disable_auto_regression",
      "last_k_for_val",
      "quantiles_to_predict",
      "eval_metric"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data"
    ]
  },
  "parser": [],
  "args": [],
  "create_table": [
    "path"
  ],
  "Params": {
    "__init__": [
      "self",
      "json_path"
    ],
    "save": [
      "self",
      "json_path"
    ],
    "update": [
      "self",
      "json_path"
    ],
    "dict": [
      "self"
    ]
  },
  "AttackResults": {
    "__init__": [
      "self",
      "batch",
      "perturbation",
      "true_future_target",
      "attack_idx"
    ]
  },
  "Metrics": {
    "__init__": [
      "self",
      "mse",
      "mape",
      "ql",
      "quantiles"
    ]
  },
  "smoothed_inference": [
    "batch",
    "past_target",
    "net",
    "sigma",
    "device",
    "num_noised_samples",
    "intermediate_noise",
    "retain_positivity"
  ],
  "requires_grad_": [
    "model",
    "requires_grad"
  ],
  "get_augmented_dataset": [
    "dataset",
    "num_noises",
    "sigma"
  ],
  "add_ts_dataframe": [
    "data_iterator",
    "freq"
  ],
  "ts_iter": [
    "dataset",
    "freq"
  ],
  "load_pickle": [
    "filename"
  ],
  "change_device": [
    "var",
    "device"
  ],
  "calc_loss": [
    "attack_data",
    "forecasts",
    "attack_idx",
    "target_items",
    "quantiles"
  ],
  "DATASETS": [],
  "device": [],
  "hidden_dim": [],
  "sparsity": [],
  "sampling_size": [],
  "save_object": [
    "obj",
    "filename"
  ],
  "load_object": [
    "filename"
  ],
  "check": [
    "FOLDER"
  ],
  "seed": [
    "np_seed",
    "torch_seed"
  ],
  "SparseNet": {
    "__init__": [
      "self",
      "context_length",
      "target_dim",
      "target_item",
      "hidden_dim",
      "m",
      "max_norm",
      "norm"
    ],
    "_r": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "n_sample"
    ]
  },
  "forward_model": [
    "model",
    "inputs"
  ],
  "generate_adv_target": [
    "mode",
    "future_target",
    "factor"
  ],
  "SparseLayerAttack": {
    "__init__": [
      "self",
      "model",
      "params",
      "input_names"
    ],
    "attack_batch": [
      "self",
      "batch",
      "true_future_target"
    ]
  },
  "AttackLoss": {
    "__init__": [
      "self",
      "c",
      "attack_idx",
      "target_items",
      "device"
    ],
    "forward": [
      "self",
      "perturbation",
      "mu",
      "adv_target"
    ]
  },
  "AttackModule": {
    "__init__": [
      "self",
      "model",
      "params",
      "c",
      "batch",
      "input_names"
    ],
    "forward": [
      "self",
      "num_parallel_samples"
    ],
    "get_perturbation": [
      "self"
    ],
    "get_grad": [
      "self"
    ]
  },
  "SparseAttackModule": {
    "__init__": [
      "self",
      "model",
      "params",
      "c",
      "batch",
      "input_names",
      "attack_item"
    ],
    "forward": [
      "self",
      "num_parallel_samples"
    ],
    "get_perturbation": [
      "self"
    ],
    "get_grad": [
      "self"
    ]
  },
  "Attack": {
    "__init__": [
      "self",
      "model",
      "params",
      "input_names"
    ],
    "attack_step": [
      "self",
      "attack_module",
      "optimizer",
      "adv_target",
      "ground_truth"
    ],
    "attack_batch": [
      "self",
      "batch",
      "true_future_target"
    ]
  },
  "Trainer_adv": {
    "__init__": [
      "self",
      "sparse_net",
      "noise_sd",
      "clamp",
      "epochs",
      "batch_size",
      "num_batches_per_epoch",
      "learning_rate",
      "weight_decay",
      "maximum_learning_rate",
      "clip_gradient",
      "device"
    ],
    "__call__": [
      "self",
      "net",
      "train_iter",
      "validation_iter"
    ]
  },
  "TransformedIterableDataset": {
    "__init__": [
      "self",
      "dataset",
      "transform",
      "is_train",
      "shuffle_buffer_length",
      "cache_data"
    ],
    "__iter__": [
      "self"
    ]
  },
  "generate_pts_m5_dataset": [
    "dataset_path",
    "pandas_freq",
    "prediction_length",
    "alpha"
  ],
  "lags_for_fourier_time_features_from_frequency": [
    "freq_str",
    "num_lags"
  ],
  "CustomDateFeatureSet": {
    "__init__": [
      "self",
      "reference_dates",
      "kernel_function"
    ],
    "__call__": [
      "self",
      "dates"
    ]
  },
  "CustomHolidayFeatureSet": {
    "__init__": [
      "self",
      "custom_holidays",
      "kernel_function"
    ],
    "__call__": [
      "self",
      "dates"
    ]
  },
  "fourier_time_features_from_frequency": [
    "freq_str"
  ],
  "broadcast_shape": [],
  "ImplicitQuantile": {
    "arg_constraints": [],
    "__init__": [
      "self",
      "implicit_quantile_function",
      "taus",
      "nn_output",
      "predicted_quantiles",
      "validate_args"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "quantile_loss": [
      "quantile_forecast",
      "target",
      "tau"
    ]
  },
  "TransformedImplicitQuantile": {
    "__init__": [
      "self",
      "base_distribution",
      "transforms"
    ],
    "log_prob": [
      "self",
      "x"
    ]
  },
  "ZeroInflatedDistribution": {
    "arg_constraints": [],
    "__init__": [
      "self",
      "gate",
      "base_dist",
      "validate_args"
    ],
    "support": [
      "self"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ]
  },
  "ZeroInflatedPoisson": {
    "arg_constraints": [],
    "support": [],
    "__init__": [
      "self",
      "gate",
      "rate",
      "validate_args"
    ],
    "rate": [
      "self"
    ]
  },
  "ZeroInflatedNegativeBinomial": {
    "arg_constraints": [],
    "support": [],
    "__init__": [
      "self",
      "gate",
      "total_count",
      "probs",
      "logits",
      "validate_args"
    ],
    "total_count": [
      "self"
    ],
    "probs": [
      "self"
    ],
    "logits": [
      "self"
    ]
  },
  "default": [
    "val",
    "d"
  ],
  "extract": [
    "a",
    "t",
    "x_shape"
  ],
  "noise_like": [
    "shape",
    "device",
    "repeat"
  ],
  "cosine_beta_schedule": [
    "timesteps",
    "s"
  ],
  "GaussianDiffusion": {
    "__init__": [
      "self",
      "denoise_fn",
      "input_size",
      "beta_end",
      "diff_steps",
      "loss_type",
      "betas",
      "beta_schedule"
    ],
    "scale": [
      "self",
      "scale"
    ],
    "q_mean_variance": [
      "self",
      "x_start",
      "t"
    ],
    "predict_start_from_noise": [
      "self",
      "x_t",
      "t",
      "noise"
    ],
    "q_posterior": [
      "self",
      "x_start",
      "x_t",
      "t"
    ],
    "p_mean_variance": [
      "self",
      "x",
      "cond",
      "t",
      "clip_denoised"
    ],
    "p_sample": [
      "self",
      "x",
      "cond",
      "t",
      "clip_denoised",
      "repeat_noise"
    ],
    "p_sample_loop": [
      "self",
      "shape",
      "cond"
    ],
    "sample": [
      "self",
      "sample_shape",
      "cond"
    ],
    "interpolate": [
      "self",
      "x1",
      "x2",
      "t",
      "lam"
    ],
    "q_sample": [
      "self",
      "x_start",
      "t",
      "noise"
    ],
    "p_losses": [
      "self",
      "x_start",
      "cond",
      "t",
      "noise"
    ],
    "log_prob": [
      "self",
      "x",
      "cond"
    ]
  },
  "create_masks": [
    "input_size",
    "hidden_size",
    "n_hidden",
    "input_order",
    "input_degrees"
  ],
  "FlowSequential": {
    "forward": [
      "self",
      "x",
      "y"
    ],
    "inverse": [
      "self",
      "u",
      "y"
    ]
  },
  "BatchNorm": {
    "__init__": [
      "self",
      "input_size",
      "momentum",
      "eps"
    ],
    "forward": [
      "self",
      "x",
      "cond_y"
    ],
    "inverse": [
      "self",
      "y",
      "cond_y"
    ]
  },
  "LinearMaskedCoupling": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "n_hidden",
      "mask",
      "cond_label_size"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ],
    "inverse": [
      "self",
      "u",
      "y"
    ]
  },
  "MaskedLinear": {
    "__init__": [
      "self",
      "input_size",
      "n_outputs",
      "mask",
      "cond_label_size"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "MADE": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "n_hidden",
      "cond_label_size",
      "activation",
      "input_order",
      "input_degrees"
    ],
    "base_dist": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ],
    "inverse": [
      "self",
      "u",
      "y",
      "sum_log_abs_det_jacobians"
    ],
    "log_prob": [
      "self",
      "x",
      "y"
    ]
  },
  "Flow": {
    "__init__": [
      "self",
      "input_size"
    ],
    "base_dist": [
      "self"
    ],
    "scale": [
      "self",
      "scale"
    ],
    "forward": [
      "self",
      "x",
      "cond"
    ],
    "inverse": [
      "self",
      "u",
      "cond"
    ],
    "log_prob": [
      "self",
      "x",
      "cond"
    ],
    "sample": [
      "self",
      "sample_shape",
      "cond"
    ]
  },
  "RealNVP": {
    "__init__": [
      "self",
      "n_blocks",
      "input_size",
      "hidden_size",
      "n_hidden",
      "cond_label_size",
      "batch_norm"
    ]
  },
  "MAF": {
    "__init__": [
      "self",
      "n_blocks",
      "input_size",
      "hidden_size",
      "n_hidden",
      "cond_label_size",
      "activation",
      "input_order",
      "batch_norm"
    ]
  },
  "IndependentDistributionOutput": {
    "__init__": [
      "self",
      "dim"
    ],
    "event_shape": [
      "self"
    ],
    "independent": [
      "self",
      "distr"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ]
  },
  "IndependentNormalOutput": {
    "__init__": [
      "self",
      "dim"
    ]
  },
  "StudentTMixtureOutput": {
    "__init__": [
      "self",
      "components"
    ],
    "domain_map": [
      "cls",
      "mix_logits",
      "df",
      "loc",
      "scale"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "NormalMixtureOutput": {
    "__init__": [
      "self",
      "components"
    ],
    "domain_map": [
      "cls",
      "mix_logits",
      "loc",
      "scale"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "LowRankMultivariateNormalOutput": {
    "__init__": [
      "self",
      "dim",
      "rank",
      "sigma_init",
      "sigma_minimum"
    ],
    "domain_map": [
      "self",
      "loc",
      "cov_factor",
      "cov_diag"
    ],
    "inv_softplus": [
      "self",
      "y"
    ],
    "event_shape": [
      "self"
    ]
  },
  "MultivariateNormalOutput": {
    "__init__": [
      "self",
      "dim"
    ],
    "domain_map": [
      "self",
      "loc",
      "scale"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "FlowOutput": {
    "__init__": [
      "self",
      "flow",
      "input_size",
      "cond_size"
    ],
    "domain_map": [
      "cls",
      "cond"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "DiffusionOutput": {
    "__init__": [
      "self",
      "diffusion",
      "input_size",
      "cond_size"
    ],
    "domain_map": [
      "cls",
      "cond"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "QuantilePtArgProj": {
    "__init__": [
      "self",
      "in_features",
      "output_domain_cls",
      "args_dim",
      "domain_map"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ImplicitQuantileOutput": {
    "in_features": [],
    "args_dim": [],
    "__init__": [
      "self",
      "output_domain"
    ],
    "set_output_domain_map": [
      "cls",
      "output_domain"
    ],
    "set_args_proj": [
      "cls"
    ],
    "domain_map": [
      "cls"
    ],
    "args_proj": [
      "cls",
      "in_features"
    ],
    "get_args_proj": [
      "self",
      "in_features",
      "prefix"
    ],
    "distribution": [
      "self",
      "distr_args",
      "scale"
    ],
    "event_shape": [
      "self"
    ]
  },
  "get_module_forward_input_names": [
    "module"
  ],
  "PyTorchEstimator": {
    "__init__": [
      "self",
      "trainer",
      "lead_time",
      "dtype"
    ],
    "create_transformation": [
      "self"
    ],
    "create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ],
    "get_loader": [
      "self",
      "training_data",
      "validation_data",
      "num_workers",
      "prefetch_factor",
      "shuffle_buffer_length",
      "cache_data"
    ],
    "train_model": [
      "self",
      "training_data",
      "validation_data",
      "num_workers",
      "prefetch_factor",
      "shuffle_buffer_length",
      "cache_data"
    ],
    "_worker_init_fn": [
      "worker_id"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data",
      "num_workers",
      "prefetch_factor",
      "shuffle_buffer_length",
      "cache_data"
    ]
  },
  "linspace": [
    "backcast_length",
    "forecast_length"
  ],
  "TempFlowEstimator": {
    "__init__": [
      "self",
      "input_size",
      "freq",
      "prediction_length",
      "target_dim",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "flow_type",
      "n_blocks",
      "hidden_size",
      "n_hidden",
      "conditioning_length",
      "dequantize",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "time_features"
    ],
    "create_transformation": [
      "self"
    ],
    "create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "TempFlowTrainingNetwork": {
    "__init__": [
      "self",
      "input_size",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "dropout_rate",
      "lags_seq",
      "target_dim",
      "conditioning_length",
      "flow_type",
      "n_blocks",
      "hidden_size",
      "n_hidden",
      "dequantize",
      "cardinality",
      "embedding_dimension",
      "scaling"
    ],
    "get_lagged_subsequences": [
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "unroll": [
      "self",
      "lags",
      "scale",
      "time_feat",
      "target_dimension_indicator",
      "unroll_length",
      "begin_state"
    ],
    "unroll_encoder": [
      "self",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "target_dimension_indicator"
    ],
    "distr_args": [
      "self",
      "rnn_outputs"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ]
  },
  "TempFlowPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "past_target_cdf",
      "target_dimension_indicator",
      "time_feat",
      "scale",
      "begin_states"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ]
  },
  "DiffusionEmbedding": {
    "__init__": [
      "self",
      "dim",
      "proj_dim",
      "max_steps"
    ],
    "forward": [
      "self",
      "diffusion_step"
    ],
    "_build_embedding": [
      "self",
      "dim",
      "max_steps"
    ]
  },
  "CondUpsampler": {
    "__init__": [
      "self",
      "cond_length",
      "target_dim"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "EpsilonTheta": {
    "__init__": [
      "self",
      "target_dim",
      "cond_length",
      "time_emb_dim",
      "residual_layers",
      "residual_channels",
      "dilation_cycle_length",
      "residual_hidden"
    ],
    "forward": [
      "self",
      "inputs",
      "time",
      "cond"
    ]
  },
  "TimeGradTrainingNetwork": {
    "__init__": [
      "self",
      "input_size",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "dropout_rate",
      "lags_seq",
      "target_dim",
      "conditioning_length",
      "diff_steps",
      "loss_type",
      "beta_end",
      "beta_schedule",
      "residual_layers",
      "residual_channels",
      "dilation_cycle_length",
      "cardinality",
      "embedding_dimension",
      "scaling"
    ],
    "get_lagged_subsequences": [
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "unroll": [
      "self",
      "lags",
      "scale",
      "time_feat",
      "target_dimension_indicator",
      "unroll_length",
      "begin_state"
    ],
    "unroll_encoder": [
      "self",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "target_dimension_indicator"
    ],
    "distr_args": [
      "self",
      "rnn_outputs"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ]
  },
  "TimeGradPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "past_target_cdf",
      "target_dimension_indicator",
      "time_feat",
      "scale",
      "begin_states"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ]
  },
  "TimeGradEstimator": {
    "__init__": [
      "self",
      "input_size",
      "freq",
      "prediction_length",
      "target_dim",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "num_parallel_samples",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "conditioning_length",
      "diff_steps",
      "loss_type",
      "beta_end",
      "beta_schedule",
      "residual_layers",
      "residual_channels",
      "dilation_cycle_length",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "time_features"
    ],
    "create_transformation": [
      "self"
    ],
    "create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "ProjectParams": {
    "__init__": [
      "self",
      "in_features",
      "num_quantiles"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TransformerTempFlowTrainingNetwork": {
    "__init__": [
      "self",
      "input_size",
      "d_model",
      "num_heads",
      "act_type",
      "dropout_rate",
      "dim_feedforward_scale",
      "num_encoder_layers",
      "num_decoder_layers",
      "history_length",
      "context_length",
      "prediction_length",
      "lags_seq",
      "target_dim",
      "conditioning_length",
      "flow_type",
      "n_blocks",
      "hidden_size",
      "n_hidden",
      "dequantize",
      "scaling"
    ],
    "get_lagged_subsequences": [
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "create_network_input": [
      "self",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "target_dimension_indicator"
    ],
    "distr_args": [
      "self",
      "decoder_output"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat",
      "future_target_cdf",
      "future_observed_values"
    ]
  },
  "TransformerTempFlowPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "past_target_cdf",
      "target_dimension_indicator",
      "time_feat",
      "scale",
      "enc_out"
    ],
    "forward": [
      "self",
      "target_dimension_indicator",
      "past_time_feat",
      "past_target_cdf",
      "past_observed_values",
      "past_is_pad",
      "future_time_feat"
    ]
  },
  "TransformerTempFlowEstimator": {
    "__init__": [
      "self",
      "input_size",
      "freq",
      "prediction_length",
      "target_dim",
      "trainer",
      "context_length",
      "d_model",
      "dim_feedforward_scale",
      "act_type",
      "num_heads",
      "num_encoder_layers",
      "num_decoder_layers",
      "num_parallel_samples",
      "dropout_rate",
      "use_feat_dynamic_real",
      "flow_type",
      "n_blocks",
      "hidden_size",
      "n_hidden",
      "conditioning_length",
      "dequantize",
      "scaling",
      "pick_incomplete",
      "lags_seq",
      "time_features"
    ],
    "create_transformation": [
      "self"
    ],
    "create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "CausalDeepAREstimator": {
    "__init__": [
      "self",
      "freq",
      "prediction_length",
      "input_size",
      "trainer",
      "context_length",
      "num_layers",
      "num_cells",
      "cell_type",
      "dropout_rate",
      "use_feat_dynamic_real",
      "use_feat_dynamic_cat",
      "use_feat_static_cat",
      "use_feat_static_real",
      "cardinality",
      "embedding_dimension",
      "distr_output",
      "control_output",
      "scaling",
      "lags_seq",
      "time_features",
      "num_parallel_samples",
      "dtype"
    ],
    "create_transformation": [
      "self"
    ],
    "create_instance_splitter": [
      "self",
      "mode"
    ],
    "create_training_network": [
      "self",
      "device"
    ],
    "create_predictor": [
      "self",
      "transformation",
      "trained_network",
      "device"
    ]
  },
  "CausalDeepARNetwork": {
    "__init__": [
      "self",
      "input_size",
      "num_layers",
      "num_cells",
      "cell_type",
      "history_length",
      "context_length",
      "prediction_length",
      "distr_output",
      "control_output",
      "dropout_rate",
      "cardinality",
      "embedding_dimension",
      "lags_seq",
      "scaling",
      "dtype"
    ],
    "get_lagged_subsequences": [
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "unroll_encoder": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "past_control",
      "future_control",
      "future_time_feat",
      "future_target"
    ]
  },
  "CausalDeepARTrainingNetwork": {
    "distribution": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "past_control",
      "future_control"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "future_target",
      "future_observed_values",
      "past_control",
      "future_control"
    ]
  },
  "CausalDeepARPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "sampling_decoder": [
      "self",
      "static_feat",
      "past_target",
      "past_control",
      "time_feat",
      "scale",
      "control_scale",
      "future_control",
      "begin_states"
    ],
    "forward": [
      "self",
      "feat_static_cat",
      "feat_static_real",
      "past_time_feat",
      "past_target",
      "past_observed_values",
      "future_time_feat",
      "past_control",
      "future_control"
    ]
  },
  "SimpleFeedForwardPredictionNetwork": {
    "__init__": [
      "self",
      "num_parallel_samples"
    ],
    "forward": [
      "self",
      "past_target"
    ]
  },
  "Grouper": {
    "__init__": [
      "self",
      "fill_value",
      "max_target_dim",
      "align_data",
      "num_test_dates"
    ],
    "__call__": [
      "self",
      "dataset"
    ],
    "_group_all": [
      "self",
      "dataset"
    ],
    "to_ts": [
      "self",
      "data"
    ],
    "_align_data_entry": [
      "self",
      "data"
    ],
    "_preprocess": [
      "self",
      "dataset"
    ],
    "_prepare_train_data": [
      "self",
      "dataset",
      "funcs"
    ],
    "_prepare_test_data": [
      "self",
      "dataset"
    ]
  },
  "extract_dataset": [
    "dataset_name"
  ],
  "pivot_dataset": [
    "dataset"
  ],
  "MultivariateDatasetInfo": {},
  "make_dataset": [
    "values",
    "prediction_length",
    "start",
    "freq"
  ],
  "make_multivariate_dataset": [
    "dataset_name",
    "num_test_dates",
    "prediction_length",
    "max_target_dim",
    "dataset_benchmark_name"
  ],
  "random_periodic": [
    "max_target_dim",
    "prediction_length"
  ],
  "electricity": [
    "max_target_dim"
  ],
  "solar": [
    "max_target_dim"
  ],
  "traffic": [
    "max_target_dim"
  ],
  "wiki": [
    "max_target_dim"
  ],
  "exchange_rate": [
    "max_target_dim"
  ],
  "taxi_30min": [
    "max_target_dim"
  ],
  "ensembles": [],
  "simulate": [
    "data_path",
    "evaluations_path",
    "output_path",
    "max_ensemble_size",
    "default_samples",
    "hyperensemble_samples",
    "random_samples",
    "sample_datasets",
    "seed"
  ],
  "_evaluate_ensemble": [
    "ensemble",
    "evaluator"
  ],
  "upload": [
    "path",
    "bucket",
    "prefix"
  ],
  "compute_stats": [
    "dataset",
    "data_path",
    "output_path"
  ],
  "download": [
    "dataset",
    "path"
  ],
  "_download_dataset": [
    "name",
    "base"
  ],
  "compute_catch22": [
    "dataset",
    "data_path",
    "output_path"
  ],
  "_get_features": [
    "ts"
  ],
  "iterate_configurations": [
    "configs",
    "skip"
  ],
  "generate_configurations": [
    "path"
  ],
  "explode_key_values": [
    "primary_key",
    "mapping",
    "process_key"
  ],
  "_generate_configurations": [
    "config"
  ],
  "run_sacred_script": [
    "script"
  ],
  "_sacred_value": [
    "value"
  ],
  "archive": [
    "evaluations_path",
    "archive_path"
  ],
  "schedule": [
    "config_path",
    "sagemaker_role",
    "experiment",
    "data_bucket",
    "data_bucket_prefix",
    "output_bucket",
    "output_bucket_prefix",
    "instance_type",
    "docker_image",
    "max_runtime",
    "nskip",
    "local"
  ],
  "evaluations": [],
  "_download_public_evaluations": [
    "include_forecasts",
    "evaluations_path"
  ],
  "_download_object": [
    "key",
    "bucket",
    "client",
    "destination"
  ],
  "_extract_object_names": [
    "response"
  ],
  "_move_job": [
    "job",
    "target",
    "include_forecasts"
  ],
  "surrogate": [
    "experiment",
    "config_path",
    "data_path",
    "evaluations_path",
    "nskip"
  ],
  "analysis": [],
  "ensemble_recommender": [
    "experiment",
    "config_path",
    "evaluations_path",
    "nskip"
  ],
  "recommender": [
    "experiment",
    "config_path",
    "data_path",
    "evaluations_path",
    "nskip"
  ],
  "ensemble": [
    "experiment",
    "config_path",
    "data_path",
    "evaluations_path",
    "nskip"
  ],
  "ex": [],
  "experiment_config": [],
  "_suppress_useless_warnings": [],
  "DEFAULT_DATA_PATH": [],
  "DEFAULT_DATA_CATCH22_PATH": [],
  "DEFAULT_DATA_STATS_PATH": [],
  "DEFAULT_EVALUATIONS_PATH": [],
  "DEFAULT_ENSEMBLE_EVALUATIONS_PATH": [],
  "EnsembleConfig": [],
  "Config": {
    "to_dataframe": [
      "cls",
      "configs"
    ]
  },
  "D": [],
  "register_dataset": [
    "cls"
  ],
  "get_dataset_config": [
    "name",
    "path"
  ],
  "GluonTsDatasetConfig": {
    "generate": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ],
    "_prediction_length_multiplier": [
      "self"
    ],
    "_filters": [
      "self",
      "prediction_length"
    ],
    "_materialize": [
      "self",
      "directory",
      "regenerate"
    ]
  },
  "MonashDatasetConfig": {
    "_prediction_length": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory",
      "regenerate"
    ]
  },
  "M3DatasetConfig": {
    "generate": [
      "self"
    ]
  },
  "KaggleDatasetConfig": {
    "generate": [
      "self"
    ],
    "_link": [
      "self"
    ],
    "_extract_data": [
      "self",
      "path"
    ]
  },
  "_get_frequency": [
    "monash_frequency"
  ],
  "_get_base": [
    "part"
  ],
  "_get_multiple": [
    "part"
  ],
  "DatasetConfig": {
    "name": [
      "cls"
    ],
    "generate": [
      "self"
    ],
    "prepare": [
      "self"
    ],
    "has_time_features": [
      "self"
    ],
    "max_training_time": [
      "self"
    ],
    "meta": [
      "self"
    ],
    "data": [
      "self"
    ],
    "root": [
      "self"
    ],
    "stats": [
      "self",
      "root"
    ],
    "catch22": [
      "self",
      "root"
    ]
  },
  "ExchangeRateDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ]
  },
  "ElectricityDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "SolarDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ]
  },
  "WikiDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ]
  },
  "TaxiDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ]
  },
  "M3MonthlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "M3QuarterlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "M3YearlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "M3OtherDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4HourlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4DailyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4WeeklyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4MonthlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4QuarterlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M4YearlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ]
  },
  "M5DatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_materialize": [
      "self",
      "directory",
      "regenerate"
    ]
  },
  "TourismMonthlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "TourismQuarterlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "TourismYearlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ]
  },
  "NN5DatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_gluonts_name": [
      "self"
    ]
  },
  "LondonSmartMetersDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "WindFarmsDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_filters": [
      "self",
      "prediction_length"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "CarPartsDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "DominickDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ],
    "_prediction_length_multiplier": [
      "self"
    ]
  },
  "FredMdDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "SanFranciscoTrafficDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "PedestrianCountDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "HospitalDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "CovidDeathsDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "KddCupDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "CifDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "has_time_features": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "AustralianElectricityDemandDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "BitcoinDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "RideshareDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "VehicleTripsDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ],
    "_prediction_length_multiplier": [
      "self"
    ]
  },
  "WeatherDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "TemperatureRainDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "M1YearlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "M1QuarterlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "M1MonthlyDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_file": [
      "self"
    ],
    "_record": [
      "self"
    ],
    "_prediction_length": [
      "self"
    ]
  },
  "RossmannDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_link": [
      "self"
    ],
    "_extract_data": [
      "self",
      "path"
    ]
  },
  "CorporacionFavoritaDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_link": [
      "self"
    ],
    "_extract_data": [
      "self",
      "path"
    ]
  },
  "WalmartDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_link": [
      "self"
    ],
    "_extract_data": [
      "self",
      "path"
    ]
  },
  "RestaurantDatasetConfig": {
    "name": [
      "cls"
    ],
    "max_training_time": [
      "self"
    ],
    "_link": [
      "self"
    ],
    "_extract_data": [
      "self",
      "path"
    ]
  },
  "get_model_config": [
    "name"
  ],
  "SeasonalNaiveModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "ThetaModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "Naive2ModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "NptsModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "DeepARModelConfig": {
    "name": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "MQCnnModelConfig": {
    "name": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "MQRnnModelConfig": {
    "name": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "SimpleFeedforwardModelConfig": {
    "name": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "TemporalFusionTransformerModelConfig": {
    "name": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "NBeatsModelConfig": {
    "name": [
      "cls"
    ],
    "prediction_samples": [
      "self"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "ProphetModelConfig": {
    "name": [
      "cls"
    ],
    "save_predictor": [
      "self",
      "predictor",
      "path"
    ],
    "load_predictor": [
      "self",
      "path"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "STLARModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "ARIMAModelConfig": {
    "name": [
      "cls"
    ],
    "prefers_parallel_predictions": [
      "self"
    ],
    "max_time_series_length": [
      "self",
      "config"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "ETSModelConfig": {
    "name": [
      "cls"
    ],
    "create_estimator": [
      "self",
      "freq",
      "prediction_length",
      "time_features",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "C": [],
  "TrainConfig": {
    "training_hyperparameters": [
      "cls"
    ],
    "create_predictor": [
      "self",
      "estimator",
      "network"
    ],
    "_create_trainer": [
      "self",
      "training_time",
      "validation_milestones",
      "callbacks"
    ]
  },
  "compute_owa": [
    "metrics",
    "datasets",
    "metadata"
  ],
  "_naive_2_forecasts": [
    "dataset",
    "freq",
    "prediction_length"
  ],
  "evaluate_forecasts": [
    "forecasts",
    "data"
  ],
  "Evaluation": {
    "performance": [
      "cls",
      "evaluations"
    ]
  },
  "QuantileForecasts": {
    "prediction_length": [
      "self"
    ],
    "seasonality": [
      "self"
    ],
    "get": [
      "self",
      "index"
    ],
    "median": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "load": [
      "cls",
      "path"
    ],
    "save": [
      "self",
      "path"
    ]
  },
  "ncrps": [
    "y_pred",
    "y_true"
  ],
  "generate_forecasts": [
    "predictor",
    "dataset",
    "num_samples",
    "parallelize"
  ],
  "EnsembleWeighting": [],
  "ensemble_forecasts": [
    "forecasts",
    "weighting",
    "ncrps"
  ],
  "Dimension": {},
  "plot_scatter_matrix": [
    "data_entries",
    "dimensions",
    "title",
    "savefig",
    "position_legend",
    "size",
    "tick_fontsize",
    "axis_fontsize",
    "legend_fontsize",
    "legend_ncol",
    "ylog",
    "xmul",
    "plot_pareto_front"
  ],
  "float_formatter": [
    "column",
    "value",
    "minimize"
  ],
  "compress_directory": [
    "directory",
    "target",
    "include"
  ],
  "S": [],
  "E": [],
  "register_surrogate": [
    "name"
  ],
  "register_ensemble_surrogate": [
    "name"
  ],
  "create_surrogate": [
    "name",
    "tracker",
    "predict",
    "input_flags"
  ],
  "create_ensemble_surrogate": [
    "name",
    "tracker",
    "predict",
    "input_flags"
  ],
  "RandomForestSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "use_simple_dataset_features",
      "use_seasonal_naive_performance",
      "use_catch22_features",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "NonparametricSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "use_simple_dataset_features",
      "use_seasonal_naive_performance",
      "use_catch22_features",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "XGBoostSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "objective",
      "use_simple_dataset_features",
      "use_seasonal_naive_performance",
      "use_catch22_features",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "required_cpus": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "OutputNormalization": [],
  "Surrogate": {
    "__init__": [
      "self",
      "tracker",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "required_cpus": [
      "self"
    ],
    "required_memory": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "DatasetFeaturesMixin": {},
  "MLPSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "objective",
      "discount",
      "hidden_layer_sizes",
      "weight_decay",
      "dropout",
      "use_simple_dataset_features",
      "use_seasonal_naive_performance",
      "use_catch22_features",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "required_cpus": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_trainer": [
      "self"
    ],
    "_init_model": [
      "self",
      "input_dim"
    ]
  },
  "DeepSetSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "objective",
      "discount",
      "hidden_layer_sizes",
      "weight_decay",
      "dropout",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "required_cpus": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_trainer": [
      "self"
    ],
    "_init_model": [
      "self",
      "input_dim"
    ]
  },
  "AutoGluonSurrogate": {
    "__init__": [
      "self",
      "tracker",
      "time_limit",
      "use_simple_dataset_features",
      "use_seasonal_naive_performance",
      "use_catch22_features",
      "predict",
      "output_normalization",
      "impute_simulatable"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "RandomSurrogate": {
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "ConfigTransformer": {
    "__init__": [
      "self",
      "add_model_features",
      "add_dataset_statistics",
      "add_seasonal_naive_performance",
      "add_catch22_features",
      "tracker"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "EnsembleConfigTransformer": {
    "__init__": [
      "self"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "configs"
    ]
  },
  "Encoder": {
    "feature_names_": [
      "self"
    ]
  },
  "NanImputer": {
    "fit": [
      "self",
      "_X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "Selector": {
    "__init__": [
      "self",
      "use",
      "ignore"
    ],
    "fit": [
      "self",
      "_X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "ModelEncoder": {
    "__init__": [
      "self",
      "transform_full_config"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "DatasetStatisticsEncoder": {
    "__init__": [
      "self"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "SeasonalNaivePerformanceEncoder": {
    "__init__": [
      "self",
      "tracker"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ],
    "_get_performance_array": [
      "self",
      "X"
    ]
  },
  "DatasetCatch22Encoder": {
    "__init__": [
      "self"
    ],
    "feature_names_": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "PerformanceTransformer": {
    "__init__": [
      "self",
      "metrics"
    ],
    "features_names_": [
      "self"
    ],
    "fit": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ]
  },
  "PerformanceEncoder": {
    "__init__": [
      "self",
      "metrics"
    ],
    "fit": [
      "self",
      "X",
      "_y"
    ],
    "transform": [
      "self",
      "X",
      "_y"
    ],
    "inverse_transform": [
      "self",
      "X",
      "_y"
    ]
  },
  "ListMLELoss": {
    "__init__": [
      "self",
      "discount"
    ],
    "forward": [
      "self",
      "y_pred",
      "y_true",
      "group_ids"
    ]
  },
  "MLPLightningModule": {
    "__init__": [
      "self",
      "model",
      "loss",
      "weight_decay"
    ],
    "configure_optimizers": [
      "self"
    ],
    "configure_callbacks": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "_batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "_batch_idx"
    ]
  },
  "DeepSetModel": {
    "__init__": [
      "self",
      "input_dim",
      "hidden_dim",
      "output_dim",
      "encoder_dims",
      "decoder_dims",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "lengths"
    ]
  },
  "_MLP": {
    "__init__": [
      "self",
      "layer_dims",
      "dropout"
    ]
  },
  "DeepSetLightningModule": {
    "__init__": [
      "self",
      "model",
      "loss",
      "weight_decay"
    ],
    "configure_optimizers": [
      "self"
    ],
    "configure_callbacks": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "_batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "_batch_idx"
    ]
  },
  "register_recommender": [
    "name"
  ],
  "register_ensemble_recommender": [
    "name"
  ],
  "create_recommender": [
    "name"
  ],
  "create_ensemble_recommender": [
    "name"
  ],
  "Recommendation": {},
  "Recommender": {
    "__init__": [
      "self",
      "objectives",
      "focus",
      "generator"
    ],
    "required_cpus": [
      "self"
    ],
    "required_memory": [
      "self"
    ],
    "fit": [
      "self",
      "configs",
      "_performances"
    ],
    "recommend": [
      "self",
      "dataset",
      "candidates",
      "max_count"
    ],
    "_get_performances": [
      "self",
      "configs"
    ]
  },
  "OptimalRecommender": {
    "__init__": [
      "self",
      "tracker",
      "objectives",
      "focus",
      "generator"
    ],
    "_get_performances": [
      "self",
      "configs"
    ]
  },
  "ParetoRecommender": {
    "__init__": [
      "self",
      "surrogate",
      "objectives",
      "focus",
      "generator"
    ],
    "required_cpus": [
      "self"
    ],
    "required_memory": [
      "self"
    ],
    "fit": [
      "self",
      "configs",
      "performances"
    ],
    "_get_performances": [
      "self",
      "configs"
    ]
  },
  "GreedyRecommender": {
    "__init__": [
      "self",
      "objectives",
      "focus",
      "generator",
      "enforce_single_objective"
    ],
    "fit": [
      "self",
      "configs",
      "performances"
    ],
    "recommend": [
      "self",
      "dataset",
      "candidates",
      "max_count"
    ]
  },
  "_dummy_performance": [],
  "pareto_efficiency_mask": [
    "X"
  ],
  "epsilon_net_indices": [
    "X",
    "dim"
  ],
  "argsort_nondominated": [
    "X",
    "dim",
    "max_items",
    "flatten"
  ],
  "ReplayCandidateGenerator": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "configs"
    ],
    "generate": [
      "self",
      "candidates"
    ]
  },
  "CandidateGenerator": {
    "fit": [
      "self",
      "configs"
    ],
    "generate": [
      "self",
      "candidates"
    ]
  },
  "Performance": {
    "from_dict": [
      "cls",
      "metrics"
    ],
    "metrics": [
      "cls"
    ],
    "to_dataframe": [
      "cls",
      "performances",
      "std"
    ]
  },
  "metric_definitions": [],
  "_FLOATING_POINT_REGEX": [],
  "_metric_regex": [
    "target"
  ],
  "fit_estimator": [
    "config",
    "dataset",
    "num_learning_rate_decays",
    "num_model_checkpoints",
    "validate",
    "verbose"
  ],
  "FitResult": {
    "evaluate_predictors": [
      "self",
      "dataset_config",
      "dataset_split",
      "directory",
      "validation"
    ],
    "serialize_predictors": [
      "self",
      "directory"
    ]
  },
  "_suppress_stdout_stderr": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "CustomFramework": {
    "_framework_name": [],
    "create_model": [
      "self"
    ]
  },
  "upload_directory": [
    "client",
    "directory",
    "bucket",
    "prefix"
  ],
  "image_uri": [
    "path"
  ],
  "Artifact": {
    "__init__": [
      "self",
      "path",
      "cleanup"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "TrainingJob": {
    "__init__": [
      "self",
      "info"
    ],
    "name": [
      "self"
    ],
    "status": [
      "self"
    ],
    "date_created": [
      "self"
    ],
    "hyperparameters": [
      "self"
    ],
    "pull_logs": [
      "self"
    ],
    "logs": [
      "self"
    ],
    "metrics": [
      "self"
    ],
    "artifact": [
      "self",
      "cache"
    ],
    "move_to": [
      "self",
      "experiment"
    ],
    "delete": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_cache_dir": [
      "self"
    ]
  },
  "Analysis": {
    "__init__": [
      "self",
      "experiment",
      "only_completed",
      "include",
      "resolve_duplicates"
    ],
    "get": [
      "self",
      "name"
    ],
    "status": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_fetch_training_jobs": [
    "session",
    "experiment",
    "only_completed",
    "resolve_duplicates"
  ],
  "_process_hyperparameter_value": [
    "v"
  ],
  "_SESSION": [],
  "default_session": [],
  "account_id": [],
  "Evaluations": {
    "dataframe": [
      "self",
      "std"
    ]
  },
  "Tracker": {
    "get_evaluations": [
      "self"
    ],
    "get_performance": [
      "self",
      "config"
    ]
  },
  "Job": {
    "from_training_job": [
      "cls",
      "job"
    ],
    "load": [
      "cls",
      "directory"
    ],
    "__init__": [
      "self",
      "model",
      "dataset",
      "config",
      "performance",
      "source_path",
      "source_job"
    ],
    "hyperparameters": [
      "self"
    ],
    "static_metrics": [
      "self"
    ],
    "metrics": [
      "self"
    ],
    "performances": [
      "self"
    ],
    "get_forecast": [
      "self",
      "index"
    ],
    "save": [
      "self",
      "path",
      "include_forecasts"
    ]
  },
  "load_jobs_from_analysis": [
    "analysis"
  ],
  "load_jobs_from_directory": [
    "directory"
  ],
  "_extract_configuration": [
    "job"
  ],
  "_extract_performance": [
    "job"
  ],
  "_check_all_data_available": [
    "target"
  ],
  "ValidationMetric": [],
  "ValidationScores": {},
  "JobInfo": {},
  "extract_job_infos": [
    "training_jobs",
    "validation_metric",
    "group_seeds",
    "data_path"
  ],
  "ModelTracker": {
    "for_experiment": [
      "cls",
      "name",
      "force_refresh"
    ],
    "from_directory": [
      "cls",
      "directory"
    ],
    "__init__": [
      "self",
      "jobs",
      "validation_metric",
      "group_seeds",
      "data_path"
    ],
    "get_evaluations": [
      "self"
    ],
    "unique_model_configs": [
      "self"
    ],
    "get_training_jobs": [
      "self",
      "config"
    ],
    "get_forecasts": [
      "self",
      "config"
    ],
    "get_validation_scores": [
      "self",
      "config"
    ],
    "get_performance": [
      "self",
      "config"
    ],
    "__contains__": [
      "self",
      "config"
    ]
  },
  "EnsembleTracker": {
    "__init__": [
      "self",
      "directory"
    ],
    "unique_ensembles": [
      "self"
    ],
    "get_evaluations": [
      "self"
    ],
    "get_performance": [
      "self",
      "config"
    ]
  },
  "TimedTrainer": {
    "__init__": [
      "self",
      "training_time",
      "validation_milestones",
      "learning_rate",
      "callbacks"
    ],
    "__call__": [
      "self",
      "net",
      "train_iter",
      "validation_iter"
    ],
    "_train_loop": [
      "self",
      "net",
      "train_iter",
      "validation_iter"
    ]
  },
  "_loss_value": [
    "loss"
  ],
  "ModelSaverCallback": {
    "__init__": [
      "self",
      "directory",
      "milestones"
    ],
    "on_train_start": [
      "self",
      "trainer"
    ],
    "on_network_initialization_end": [
      "self",
      "network"
    ],
    "on_train_batch_end": [
      "self",
      "network",
      "time_elapsed"
    ]
  },
  "LearningRateScheduleCallback": {
    "__init__": [
      "self",
      "milestones",
      "decay"
    ],
    "on_train_start": [
      "self",
      "trainer"
    ],
    "on_train_batch_end": [
      "self",
      "network",
      "time_elapsed"
    ]
  },
  "ConfigAnalyzer": {
    "__init__": [
      "self",
      "tracker"
    ],
    "run": [
      "self",
      "model_config"
    ]
  },
  "EnsembleAnalyzer": {
    "__init__": [
      "self",
      "tracker",
      "ensemble_size",
      "ensemble_weighting",
      "config_class"
    ],
    "run": [
      "self"
    ],
    "_run_on_dataset": [
      "self",
      "data"
    ],
    "_performance_on_dataset": [
      "self",
      "X_test",
      "y_test"
    ],
    "get_ensemble_performance": [
      "self",
      "models",
      "dataset",
      "member_performances",
      "num_samples"
    ],
    "_combine_metrics": [
      "self",
      "performances",
      "metric"
    ],
    "get_all_performances": [
      "self",
      "models",
      "data_path"
    ]
  },
  "loocv_split": [
    "tracker"
  ],
  "compute_ranks": [
    "candidates"
  ],
  "_check_candidates": [
    "candidates"
  ],
  "union_dicts": [
    "dicts"
  ],
  "hypervolume": [
    "points",
    "box"
  ],
  "maximum_spread": [
    "solution"
  ],
  "pure_diversity": [
    "solution"
  ],
  "_compute_pd": [
    "distances"
  ],
  "_get_ij_dist": [
    "distances"
  ],
  "_is_connected": [
    "adjacency",
    "i",
    "j"
  ],
  "_GLOBAL_DATA_CACHE": [],
  "num_fitting_processes": [
    "cpus_per_process",
    "memory_per_process"
  ],
  "run_parallel": [
    "execute",
    "data",
    "num_processes"
  ],
  "_worker": [
    "execute",
    "inputs",
    "outputs"
  ],
  "SurrogateAnalyzer": {
    "__init__": [
      "self",
      "surrogate",
      "tracker",
      "metrics"
    ],
    "run": [
      "self"
    ],
    "_run_on_dataset": [
      "self",
      "data"
    ],
    "_score": [
      "self",
      "y_pred",
      "y_true"
    ]
  },
  "mrr": [
    "y_pred",
    "y_true"
  ],
  "precision_k": [
    "k",
    "y_pred",
    "y_true"
  ],
  "ndcg": [
    "y_pred",
    "y_true"
  ],
  "SacredMongoClient": {
    "__init__": [
      "self",
      "experiment",
      "host",
      "port",
      "database",
      "only_completed"
    ],
    "query_one": [
      "self",
      "config",
      "others"
    ],
    "query": [
      "self",
      "config",
      "others"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "SacredExperiment": {
    "__init__": [
      "self",
      "info",
      "db",
      "gridfs"
    ],
    "config": [
      "self"
    ],
    "artifacts": [
      "self"
    ],
    "read_parquet": [
      "self",
      "artifact"
    ],
    "read_pickle": [
      "self",
      "artifact"
    ],
    "delete": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ModelRecommenderAnalyzer": {
    "__init__": [
      "self",
      "tracker",
      "recommender",
      "num_recommendations"
    ],
    "run": [
      "self"
    ],
    "_run_on_dataset": [
      "self",
      "data"
    ]
  },
  "EnsembleRecommenderAnalyzer": {
    "__init__": [
      "self",
      "tracker",
      "recommender",
      "num_recommendations"
    ],
    "run": [
      "self"
    ],
    "_run_on_dataset": [
      "self",
      "data"
    ]
  },
  "divide_into": [
    "length",
    "n"
  ],
  "partition_sequence": [
    "xs",
    "n"
  ],
  "Apply": {
    "__init__": [
      "self",
      "fn",
      "partitions"
    ],
    "__iter__": [
      "self"
    ]
  },
  "imap_unordered": [
    "fn",
    "data",
    "num_workers",
    "batch_size"
  ],
  "lifted": [
    "fns"
  ],
  "Pipeline": {
    "__init__": [
      "self",
      "fns"
    ],
    "apply": [
      "self",
      "parts"
    ],
    "parapply": [
      "self",
      "parts"
    ],
    "and_then": [
      "self"
    ],
    "and_then_each": [
      "self"
    ],
    "but_first": [
      "self"
    ],
    "but_first_each": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ]
  },
  "partition_map": [
    "xs",
    "n"
  ],
  "sentinel": {},
  "map_to_queue": [
    "fn",
    "emitter",
    "queue",
    "encode",
    "batch_size"
  ],
  "ParApplyIterator": {
    "__init__": [
      "self",
      "procs",
      "queue",
      "decode"
    ],
    "join": [
      "self"
    ],
    "start": [
      "self"
    ],
    "kill": [
      "self"
    ],
    "terminate": [
      "self"
    ],
    "__next__": [
      "self"
    ]
  },
  "ParApply": {
    "__init__": [
      "self",
      "fn",
      "emitter",
      "batch_size",
      "queue_size",
      "encode",
      "decode"
    ],
    "__iter__": [
      "self"
    ]
  },
  "thinning_sampler": [
    "rng",
    "lamb",
    "xmin",
    "lamb_min"
  ],
  "Hawkes": [
    "rng",
    "background",
    "kernel",
    "xmin",
    "xmax",
    "N_max"
  ],
  "GMMModel": {
    "__init__": [
      "self"
    ],
    "_get_dx_": [
      "F",
      "x",
      "mu_"
    ],
    "_get_Rx_": [
      "F",
      "dx_",
      "kR_"
    ],
    "hybrid_forward": [
      "self",
      "F",
      "x",
      "log_prior_",
      "mu_",
      "kR_"
    ],
    "m_step": [
      "x",
      "qz"
    ]
  },
  "GMMTrainer": {
    "__init__": [
      "self",
      "model",
      "pseudo_count",
      "jitter"
    ],
    "zero_stats": [
      "self"
    ],
    "add": [
      "self",
      "x"
    ],
    "update": [
      "self"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "infer_lambda": [
    "model"
  ],
  "elapsed": [
    "collection"
  ],
  "SchemaTracker": {
    "_with_missing": [
      "self",
      "key",
      "Ty"
    ],
    "copy": [
      "self"
    ],
    "add": [
      "self",
      "name",
      "ty",
      "force"
    ],
    "union": [
      "self",
      "name",
      "ty"
    ],
    "remove": [
      "self",
      "name",
      "ignore_missing"
    ],
    "pop": [
      "self",
      "name"
    ]
  },
  "infer_type": [
    "val"
  ],
  "Action": {
    "apply": [
      "self",
      "stream"
    ],
    "apply_one": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ],
    "bind": [
      "self",
      "schema"
    ],
    "requires": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ]
  },
  "Bind": {
    "apply": [
      "self",
      "stream"
    ]
  },
  "MapPipeline": {
    "__call__": [
      "self",
      "data"
    ],
    "__radd__": [
      "self",
      "other"
    ]
  },
  "Copy": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "Set": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "SetDefault": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "Update": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "UpdateDefault": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "Remove": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "Move": {
    "__call__": [
      "self",
      "data"
    ],
    "apply_schema": [
      "self",
      "schema"
    ]
  },
  "NeuralLV": {
    "__init__": [
      "self",
      "num_time_series",
      "num_time_steps",
      "low_rank_param",
      "is_full_matrix",
      "p0",
      "r",
      "k",
      "A",
      "is_sym"
    ],
    "solve_discrete_lv": [
      "self",
      "mat1",
      "mat2",
      "is_full_matrix"
    ],
    "run": [
      "self",
      "num_epochs",
      "model"
    ]
  },
  "LowRankVectorEmbedding": {
    "__init__": [
      "self",
      "neural_lv"
    ],
    "forward": [
      "self"
    ]
  },
  "lv_plot_ts": [
    "p",
    "p_approx",
    "max_num_plots",
    "num_rows",
    "fig_size_width"
  ],
  "compute_mat_vec_prod": [
    "B",
    "C",
    "p"
  ],
  "compute_low_rank_product": [
    "B",
    "C"
  ],
  "generate_data": [
    "num_ts",
    "ctx",
    "dtype",
    "seed"
  ],
  "ListElement": {
    "__init__": [
      "self",
      "ll",
      "val",
      "prv",
      "nxt"
    ],
    "remove": [
      "self"
    ]
  },
  "LinkedList": {
    "__init__": [
      "self",
      "elements"
    ],
    "push": [
      "self",
      "val"
    ],
    "last": [
      "self"
    ],
    "reverse": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Dependency": {
    "__init__": [
      "self",
      "fn",
      "dependencies"
    ],
    "resolve": [
      "self",
      "env"
    ]
  },
  "_Config": {
    "arbitrary_types_allowed": []
  },
  "_ScopedSettings": {
    "__init__": [
      "self",
      "settings",
      "kwargs"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "let": [
    "settings"
  ],
  "inject": [
    "settings"
  ],
  "fqname_for": [
    "obj"
  ],
  "A": [],
  "from_hyperparameters": [
    "cls"
  ],
  "equals": [
    "this",
    "that"
  ],
  "equals_default_impl": [
    "this",
    "that"
  ],
  "equals_list": [
    "this",
    "that"
  ],
  "equals_dict": [
    "this",
    "that"
  ],
  "equals_ndarray": [
    "this",
    "that"
  ],
  "tensor_to_numpy": [
    "tensor"
  ],
  "_numpy_to_numpy": [
    "tensor"
  ],
  "skip_encoding": [
    "v"
  ],
  "BaseValidatedInitializerModel": {},
  "validated": [
    "base_model"
  ],
  "join": [
    "a",
    "b",
    "sep"
  ],
  "_encode": [
    "data",
    "path",
    "result"
  ],
  "_asdict": [
    "trie"
  ],
  "nest": [
    "data"
  ],
  "get_args": [
    "data"
  ],
  "_translate": [
    "data"
  ],
  "decode": [
    "data"
  ],
  "encode": [
    "obj"
  ],
  "clone": [
    "data",
    "kwargs"
  ],
  "bad_type_msg": [],
  "StatelessMeta": {
    "__call__": [
      "cls"
    ]
  },
  "Stateless": {
    "__getnewargs_ex__": [
      "self"
    ],
    "__setattr__": [
      "self",
      "name",
      "value"
    ]
  },
  "Stateful": {},
  "Kind": {
    "Type": [],
    "Instance": [],
    "Stateful": []
  },
  "encode_from_state": [
    "v"
  ],
  "encode_path": [
    "v"
  ],
  "encode_pydantic_model": [
    "v"
  ],
  "encode_partial": [
    "v"
  ],
  "decode_disallow": [],
  "encode_np_dtype": [
    "v"
  ],
  "encode_np_ndarray": [
    "v"
  ],
  "encode_np_datetime64": [
    "v"
  ],
  "encode_np_inexact": [
    "v"
  ],
  "encode_np_integer": [
    "v"
  ],
  "encode_pd_timestamp": [
    "v"
  ],
  "encode_pd_period": [
    "v"
  ],
  "encode_pd_baseoffset": [
    "v"
  ],
  "dump_json": [
    "o",
    "indent"
  ],
  "load_json": [
    "s"
  ],
  "parse_expr": [
    "v"
  ],
  "parse_num": [
    "v"
  ],
  "parse_unary_op": [
    "v"
  ],
  "parse_str": [
    "v"
  ],
  "parse_list": [
    "v"
  ],
  "parse_tuple": [
    "v"
  ],
  "parse_dict": [
    "v"
  ],
  "parse_set": [
    "v"
  ],
  "parse_keyword": [
    "v"
  ],
  "parse_name_constant": [
    "v"
  ],
  "parse_constant": [
    "v"
  ],
  "parse_name": [
    "v"
  ],
  "parse_expr_call": [
    "v"
  ],
  "_EventualType": {
    "_instance": [],
    "__new__": [
      "cls"
    ],
    "__repr__": [
      "self"
    ]
  },
  "EVENTUAL": [],
  "Eventual": {
    "set": [
      "self",
      "value"
    ],
    "set_default": [
      "self",
      "value"
    ],
    "unwrap": [
      "self"
    ]
  },
  "OrElse": {
    "__post_init__": [
      "self"
    ],
    "_call": [
      "self",
      "env"
    ]
  },
  "dataclass": [
    "cls"
  ],
  "_dataclass": [
    "cls",
    "init",
    "repr",
    "eq",
    "order",
    "unsafe_hash",
    "frozen"
  ],
  "Input": {},
  "InputSpec": {
    "shapes": [
      "self"
    ],
    "dtypes": [
      "self"
    ],
    "zeros": [
      "self"
    ]
  },
  "BatchForecast": {
    "__getitem__": [
      "self",
      "name"
    ]
  },
  "_get_data_batch": [
    "input_batch",
    "label_batch",
    "forecast_batch",
    "seasonality",
    "mask_invalid_label",
    "allow_nan_forecast"
  ],
  "evaluate_forecasts_raw": [
    "forecasts"
  ],
  "evaluate_model": [
    "model"
  ],
  "OutputTransform": [],
  "LOG_CACHE": [],
  "OUTPUT_TRANSFORM_NOT_SUPPORTED_MSG": [],
  "NOT_SAMPLE_BASED_MSG": [],
  "log_once": [
    "msg"
  ],
  "to_numpy": [
    "x"
  ],
  "_unpack": [
    "batched"
  ],
  "make_distribution_forecast": [
    "distr"
  ],
  "ForecastGenerator": {
    "__call__": [
      "self",
      "inference_data_loader",
      "prediction_net",
      "input_names",
      "output_transform",
      "num_samples"
    ]
  },
  "QuantileForecastGenerator": {
    "__init__": [
      "self",
      "quantiles"
    ],
    "__call__": [
      "self",
      "inference_data_loader",
      "prediction_net",
      "input_names",
      "output_transform",
      "num_samples"
    ]
  },
  "SampleForecastGenerator": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "inference_data_loader",
      "prediction_net",
      "input_names",
      "output_transform",
      "num_samples"
    ]
  },
  "DistributionForecastGenerator": {
    "__init__": [
      "self",
      "distr_output"
    ],
    "__call__": [
      "self",
      "inference_data_loader",
      "prediction_net",
      "input_names",
      "output_transform",
      "num_samples"
    ]
  },
  "_linear_interpolation": [
    "xs",
    "ys",
    "x"
  ],
  "ExponentialTailApproximation": {
    "__init__": [
      "self",
      "x_coord",
      "y_coord",
      "tol"
    ],
    "init_exponential_tail_weights": [
      "self"
    ],
    "left": [
      "self",
      "x"
    ],
    "right": [
      "self",
      "x"
    ],
    "tail_range": [
      "self",
      "default_left_tail",
      "default_right_tail"
    ]
  },
  "Quantile": {
    "from_float": [
      "cls",
      "quantile"
    ],
    "from_str": [
      "cls",
      "quantile"
    ],
    "parse": [
      "cls",
      "quantile"
    ],
    "__str__": [
      "self"
    ]
  },
  "Forecast": {
    "_index": [],
    "mean": [
      "self"
    ],
    "quantile": [
      "self",
      "q"
    ],
    "quantile_ts": [
      "self",
      "q"
    ],
    "median": [
      "self"
    ],
    "freq": [
      "self"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "plot": [
      "self"
    ],
    "index": [
      "self"
    ],
    "dim": [
      "self"
    ],
    "copy_dim": [
      "self",
      "dim"
    ],
    "copy_aggregate": [
      "self",
      "agg_fun"
    ]
  },
  "SampleForecast": {
    "__init__": [
      "self",
      "samples",
      "start_date",
      "item_id",
      "info"
    ],
    "_sorted_samples": [
      "self"
    ],
    "num_samples": [
      "self"
    ],
    "prediction_length": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "mean_ts": [
      "self"
    ],
    "quantile": [
      "self",
      "q"
    ],
    "copy_dim": [
      "self",
      "dim"
    ],
    "copy_aggregate": [
      "self",
      "agg_fun"
    ],
    "dim": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "to_quantile_forecast": [
      "self",
      "quantiles"
    ]
  },
  "QuantileForecast": {
    "__init__": [
      "self",
      "forecast_arrays",
      "start_date",
      "forecast_keys",
      "item_id",
      "info"
    ],
    "quantile": [
      "self",
      "inference_quantile"
    ],
    "copy_dim": [
      "self",
      "dim"
    ],
    "mean": [
      "self"
    ],
    "dim": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Predictor": {
    "__init__": [
      "self",
      "prediction_length",
      "lead_time"
    ],
    "predict": [
      "self",
      "dataset"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path"
    ],
    "from_hyperparameters": [
      "cls"
    ],
    "derive_auto_fields": [
      "cls",
      "train_iter"
    ],
    "from_inputs": [
      "cls",
      "train_iter"
    ]
  },
  "RepresentablePredictor": {
    "predict": [
      "self",
      "dataset"
    ],
    "predict_item": [
      "self",
      "item"
    ],
    "__eq__": [
      "self",
      "that"
    ],
    "serialize": [
      "self",
      "path"
    ],
    "deserialize": [
      "cls",
      "path"
    ]
  },
  "WorkerError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "_worker_loop": [
    "predictor_path",
    "input_queue",
    "output_queue",
    "worker_id"
  ],
  "ParallelizedPredictor": {
    "__init__": [
      "self",
      "base_predictor",
      "num_workers",
      "chunk_size"
    ],
    "_grouper": [
      "self",
      "iterable",
      "n"
    ],
    "terminate": [
      "self"
    ],
    "predict": [
      "self",
      "dataset"
    ]
  },
  "Localizer": {
    "__init__": [
      "self",
      "estimator"
    ],
    "predict": [
      "self",
      "dataset"
    ]
  },
  "Estimator": {
    "__init__": [
      "self",
      "lead_time"
    ],
    "train": [
      "self",
      "training_data",
      "validation_data"
    ],
    "from_hyperparameters": [
      "cls"
    ],
    "derive_auto_fields": [
      "cls",
      "train_iter"
    ],
    "from_inputs": [
      "cls",
      "train_iter"
    ]
  },
  "IncrementallyTrainable": {
    "train_from": [
      "self",
      "predictor",
      "training_data",
      "validation_data"
    ]
  },
  "MeanPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "num_samples",
      "context_length"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "MovingAveragePredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "MeanEstimator": {
    "__init__": [
      "self",
      "prediction_length",
      "num_samples"
    ],
    "train": [
      "self",
      "training_data",
      "validation_dataset"
    ]
  },
  "IdentityPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "num_samples"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "ConstantPredictor": {
    "__init__": [
      "self",
      "samples"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "ConstantValuePredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "value",
      "num_samples"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "SeasonalAggregatePredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "season_length",
      "num_seasons",
      "agg_fun",
      "imputation_method"
    ],
    "predict_item": [
      "self",
      "item"
    ]
  },
  "WeightedSampler": {
    "sample": [
      "weights",
      "num_samples"
    ]
  },
  "NPTS": {
    "compute_weights": [
      "train_features",
      "pred_features",
      "target_isnan_positions",
      "kernel",
      "do_exp"
    ],
    "predict": [
      "targets",
      "prediction_length",
      "sampling_weights_iterator",
      "num_samples",
      "item_id"
    ],
    "log_distance_kernel": [
      "alpha"
    ],
    "log_weighted_distance_kernel": [
      "kernel_weights"
    ],
    "uniform_kernel": []
  },
  "KernelType": {
    "exponential": [],
    "uniform": []
  },
  "NPTSPredictor": {
    "__init__": [
      "self",
      "prediction_length",
      "context_length",
      "kernel_type",
      "exp_kernel_weights",
      "use_seasonal_model",
      "use_default_time_features",
      "num_default_time_features",
      "feature_scale"
    ],
    "_is_exp_kernel": [
      "self"
    ],
    "predict": [
      "self",
      "dataset",
      "num_samples"
    ],
    "predict_time_series": [
      "self",
      "ts",
      "num_samples",
      "custom_features",
      "item_id"
    ],
    "_get_features": [
      "self",
      "train_index",
      "prediction_length",
      "custom_features"
    ]
  }
}