{
  "TestLatentInformationGain": {
    "setUp": [
      "self"
    ],
    "test_initialization": [
      "self"
    ],
    "test_acqf": [
      "self"
    ],
    "test_non_NPR": [
      "self"
    ]
  },
  "_get_vbll_model": [
    "num_inputs",
    "num_hidden"
  ],
  "TestBLLMaxPosteriorSampling": {
    "test_initialization": [
      "self"
    ],
    "test_initialization_errors": [
      "self"
    ],
    "test_call_discrete_inputs": [
      "self"
    ],
    "test_call_continuous_inputs": [
      "self"
    ],
    "test_call_errors": [
      "self"
    ],
    "test_custom_bounds": [
      "self"
    ],
    "test_scipy_optimization_failures": [
      "self"
    ]
  },
  "TestAugmentedUpperConfidenceBound": {
    "_get_mock_agp": [
      "self",
      "batch_shape",
      "dtype"
    ],
    "test_upper_confidence_bound": [
      "self"
    ],
    "test_upper_confidence_bound_batch": [
      "self"
    ],
    "test_get_mean_and_sigma": [
      "self"
    ]
  },
  "InputConstructorBaseTestCase": {
    "setUp": [
      "self",
      "suppress_input_warnings"
    ]
  },
  "TestAnalyticalAcquisitionFunctionInputConstructors": {
    "test_construct_inputs_best_f": [
      "self"
    ]
  },
  "TestFullyBayesianAcquisitionFunctionInputConstructors": {
    "test_construct_inputs_scorebo": [
      "self"
    ],
    "test_construct_inputs_sal": [
      "self"
    ],
    "test_construct_inputs_bqbc": [
      "self"
    ],
    "test_construct_inputs_bayesian_variance_reduction": [
      "self"
    ]
  },
  "TestQStatisticalDistanceActiveLearning": {
    "test_q_statistical_distance_active_learning": [
      "self"
    ]
  },
  "TestQBayesianQueryByComittee": {
    "test_q_bayesian_query_by_comittee": [
      "self"
    ]
  },
  "TestQBayesianVarianceReduction": {
    "test_q_bayesian_variance_reduction": [
      "self"
    ]
  },
  "TestQSelfCorrectingBayesianOptimization": {
    "test_q_self_correcting_bayesian_optimization": [
      "self"
    ]
  },
  "NO": [],
  "TestQHEntropySearch": {
    "test_initialize_q_hentropy_search": [
      "self"
    ],
    "test_qhentropy_search": [
      "self"
    ]
  },
  "TestLogRegionalExpectedImprovement": {
    "test_log_regional_expected_improvement": [
      "self"
    ],
    "_test_log_regional_expected_improvement": [
      "self",
      "dtype"
    ]
  },
  "TestQLogRegionalExpectedImprovement": {
    "test_q_log_regional_expected_improvement": [
      "self"
    ],
    "_test_q_log_regional_expected_improvement": [
      "self",
      "dtype"
    ],
    "test_q_log_regional_expected_improvement_batch": [
      "self"
    ],
    "_test_q_log_regional_expected_improvement_batch": [
      "self",
      "dtype"
    ]
  },
  "MockDiscretizedModel": {
    "__init__": [
      "self",
      "borders",
      "probabilities"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ]
  },
  "TestDiscretizedExpectedImprovement": {
    "test_ag_integrate": [
      "self"
    ],
    "test_ag_integrate_batch": [
      "self"
    ],
    "test_forward": [
      "self"
    ],
    "test_forward_approximating_normal": [
      "self"
    ],
    "test_unsupported_posterior_transform": [
      "self"
    ]
  },
  "TestDiscretizedProbabilityofImprovement": {
    "test_ag_integrate": [
      "self"
    ],
    "test_ag_integrate_batch": [
      "self"
    ],
    "test_forward": [
      "self"
    ],
    "test_forward_approximating_normal": [
      "self"
    ]
  },
  "TestBLLPosterior": {
    "setUp": [
      "self"
    ],
    "test_initialization": [
      "self"
    ],
    "test_rsample_default": [
      "self"
    ],
    "test_rsample_with_explicit_shape": [
      "self"
    ],
    "test_mean": [
      "self"
    ],
    "test_variance": [
      "self"
    ],
    "test_device": [
      "self"
    ],
    "test_dtype": [
      "self"
    ],
    "test_mvn_property": [
      "self"
    ],
    "test_base_sample_shape": [
      "self"
    ],
    "test_batch_range": [
      "self"
    ],
    "test_extended_shape": [
      "self"
    ],
    "test_rsample_from_base_samples": [
      "self"
    ],
    "test_quantile": [
      "self"
    ],
    "test_density": [
      "self"
    ],
    "test_multi_output": [
      "self"
    ]
  },
  "TestRiemannPosterior": {
    "test_properties": [
      "self"
    ],
    "test_integrate": [
      "self"
    ],
    "test_rsample": [
      "self"
    ],
    "test_rsample_from_base_samples": [
      "self"
    ],
    "test_mean": [
      "self"
    ],
    "test_variance": [
      "self"
    ],
    "test_confidence_region": [
      "self"
    ],
    "test_icdf": [
      "self"
    ]
  },
  "TestMultivariateRiemannPosterior": {
    "test_multivariate_rsample": [
      "self"
    ]
  },
  "TestGetSamplerRiemann": {
    "test_get_sampler_riemann": [
      "self"
    ]
  },
  "TestStatDist": {
    "test_mvn_kl_divergence": [
      "self"
    ],
    "test_mvn_hellinger_distance": [
      "self"
    ]
  },
  "DummyPFN": {
    "__init__": [
      "self",
      "n_buckets"
    ],
    "forward": [
      "self",
      "train_X",
      "train_Y",
      "test_X"
    ]
  },
  "TestPriorFittedNetwork": {
    "test_raises": [
      "self"
    ],
    "test_shapes": [
      "self"
    ],
    "test_input_transform": [
      "self"
    ],
    "test_unpack_checkpoint": [
      "self"
    ]
  },
  "TestPriorFittedNetworkUtils": {
    "test_download_model_cache_miss": [
      "self",
      "_mock_makedirs",
      "mock_exists",
      "mock_torch_save",
      "mock_torch_load",
      "mock_gzip",
      "mock_requests_get"
    ],
    "test_download_model_cache_hit": [
      "self",
      "mock_exists",
      "mock_torch_load"
    ]
  },
  "TestMultivariatePFN": {
    "setUp": [
      "self"
    ],
    "test_posterior": [
      "self"
    ],
    "test_estimate_covariances": [
      "self"
    ],
    "test_compute_conditional_means": [
      "self"
    ],
    "test_estimate_correlations": [
      "self"
    ]
  },
  "_build_loc_and_cholesky": [
    "shape"
  ],
  "VBLLHelperTestCase": {
    "setUp": [
      "self"
    ]
  },
  "TestNormal": {
    "test_initialization": [
      "self"
    ],
    "test_properties": [
      "self"
    ],
    "test_inner_products": [
      "self"
    ],
    "test_addition": [
      "self"
    ],
    "test_matmul": [
      "self"
    ],
    "test_squeeze": [
      "self"
    ]
  },
  "TestDenseNormal": {
    "test_initialization": [
      "self"
    ],
    "test_properties": [
      "self"
    ],
    "test_inner_products": [
      "self"
    ],
    "test_inverse_covariance": [
      "self"
    ],
    "test_matmul": [
      "self"
    ],
    "test_squeeze": [
      "self"
    ]
  },
  "TestLowRankNormal": {
    "test_initialization": [
      "self"
    ],
    "test_properties": [
      "self"
    ],
    "test_inner_products": [
      "self"
    ],
    "test_matmul": [
      "self"
    ],
    "test_squeeze": [
      "self"
    ]
  },
  "TestDenseNormalPrec": {
    "test_initialization": [
      "self"
    ],
    "test_properties": [
      "self"
    ],
    "test_inner_products": [
      "self"
    ],
    "test_covariance": [
      "self"
    ],
    "test_matmul": [
      "self"
    ],
    "test_squeeze": [
      "self"
    ]
  },
  "TestGetParameterization": {
    "test_get_parameterization": [
      "self"
    ]
  },
  "_get_random_data_with_source": [
    "batch_shape",
    "n",
    "d",
    "n_source",
    "q"
  ],
  "TestAugmentedSingleTaskGP": {
    "_get_model_and_data": [
      "self",
      "batch_shape",
      "n",
      "d",
      "n_source",
      "train_Yvar",
      "outcome_transform",
      "input_transform",
      "extra_model_kwargs"
    ],
    "test_data_init": [
      "self"
    ],
    "test_init_error": [
      "self"
    ],
    "test_get_reliable_observation": [
      "self"
    ],
    "test_gp": [
      "self"
    ],
    "test_condition_on_observations": [
      "self"
    ],
    "test_fixed_noise_likelihood": [
      "self"
    ],
    "test_fantasized_noise": [
      "self"
    ]
  },
  "device": [],
  "Identity": {
    "__call__": [
      "self",
      "posterior"
    ]
  },
  "TestNeuralProcessModel": {
    "initialize": [
      "self"
    ],
    "test_r_encoder": [
      "self"
    ],
    "test_z_encoder": [
      "self"
    ],
    "test_decoder": [
      "self"
    ],
    "test_sample_z": [
      "self"
    ],
    "test_KLD_gaussian": [
      "self"
    ],
    "test_data_to_z_params": [
      "self"
    ],
    "test_forward": [
      "self"
    ],
    "test_random_split_context_target": [
      "self"
    ],
    "test_posterior": [
      "self"
    ],
    "test_transform_inputs": [
      "self"
    ]
  },
  "_reg_data_singletask": [
    "d",
    "n"
  ],
  "_get_fast_training_settings": [],
  "TestAbstractBLLClass": {
    "test_cannot_instantiate_abstract_class": [
      "self"
    ]
  },
  "TestVBLLModel": {
    "test_initialization": [
      "self"
    ],
    "test_mean_initialization": [
      "self"
    ],
    "test_backbone_initialization": [
      "self"
    ],
    "test_training": [
      "self"
    ],
    "test_early_stopping": [
      "self"
    ],
    "test_initialization_of_model_parameters": [
      "self"
    ],
    "test_update_of_reg_weight": [
      "self"
    ],
    "test_shape_of_sampling": [
      "self"
    ],
    "test_shape_of_forward": [
      "self"
    ],
    "test_shape_of_predictions": [
      "self"
    ],
    "test_validation_loss": [
      "self"
    ]
  },
  "TestExampleModel": {
    "test_example_gp": [
      "self"
    ]
  },
  "SAMPLE_DIM": [],
  "DISTANCE_METRICS": [],
  "qBayesianVarianceReduction": {
    "__init__": [
      "self",
      "model",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qBayesianQueryByComittee": {
    "__init__": [
      "self",
      "model",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qStatisticalDistanceActiveLearning": {
    "__init__": [
      "self",
      "model",
      "X_pending",
      "distance_metric"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "CLAMP_LB": [],
  "qSelfCorrectingBayesianOptimization": {
    "__init__": [
      "self",
      "model",
      "optimal_outputs",
      "optimal_inputs",
      "X_pending",
      "distance_metric",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "__all__": [],
  "LatentInformationGain": {
    "__init__": [
      "self",
      "model",
      "num_samples",
      "min_std",
      "scaler"
    ],
    "forward": [
      "self",
      "candidate_x"
    ]
  },
  "BLLMaxPosteriorSampling": {
    "__init__": [
      "self",
      "model",
      "num_restarts",
      "bounds",
      "discrete_inputs"
    ],
    "__call__": [
      "self",
      "X_cand",
      "num_samples"
    ]
  },
  "_optimize_sample_path": [
    "f",
    "num_restarts",
    "bounds",
    "lb",
    "ub",
    "device"
  ],
  "DiscretizedAcquistionFunction": {
    "__init__": [
      "self",
      "model",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ],
    "ag_integrate": [
      "self",
      "lower_bound",
      "upper_bound"
    ]
  },
  "DiscretizedExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform"
    ],
    "ag_integrate": [
      "self",
      "lower_bound",
      "upper_bound"
    ]
  },
  "DiscretizedProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform"
    ],
    "ag_integrate": [
      "self",
      "lower_bound",
      "upper_bound"
    ]
  },
  "construct_inputs_best_f": [
    "model",
    "training_data",
    "posterior_transform",
    "best_f"
  ],
  "construct_inputs_BAL": [
    "model",
    "X_pending"
  ],
  "construct_inputs_SAL": [
    "model",
    "distance_metric",
    "X_pending"
  ],
  "construct_inputs_SCoreBO": [
    "model",
    "bounds",
    "num_optima",
    "posterior_transform",
    "distance_metric",
    "X_pending"
  ],
  "TAU_RELU": [],
  "TAU_MAX": [],
  "LogRegionalExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "X_dev",
      "posterior_transform",
      "maximize",
      "length",
      "bounds"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qLogRegionalExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "X_dev",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "length",
      "bounds",
      "fat",
      "tau_relu"
    ],
    "_get_samples_and_objectives": [
      "self",
      "X"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "get_sampler_and_num_points": [
    "sampler",
    "num_points"
  ],
  "qHEntropySearch": {
    "__init__": [
      "self",
      "model",
      "loss_function_class",
      "loss_function_hyperparameters",
      "n_fantasy_at_design_pts",
      "n_fantasy_at_action_pts",
      "design_sampler",
      "action_sampler"
    ],
    "forward": [
      "self",
      "X",
      "A"
    ],
    "get_augmented_q_batch_size": [
      "self",
      "q"
    ],
    "extract_candidates": [
      "self",
      "X_full"
    ]
  },
  "qLossFunctionTopK": {
    "__init__": [
      "self",
      "dist_weight",
      "dist_threshold"
    ],
    "forward": [
      "self",
      "A",
      "Y"
    ]
  },
  "qLossFunctionMinMax": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "A",
      "Y"
    ]
  },
  "AugmentedUpperConfidenceBound": {
    "__init__": [
      "self",
      "model",
      "cost",
      "best_f",
      "beta",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_mean_and_sigma": [
      "self",
      "X",
      "model",
      "compute_sigma",
      "min_var"
    ]
  },
  "BoundedRiemannPosterior": {
    "batch_range": [],
    "__init__": [
      "self",
      "borders",
      "probabilities"
    ],
    "integrate": [
      "self",
      "ag_integrate_fn"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "base_sample_shape": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "mean_of_square": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "confidence_region": [
      "self",
      "confidence_level"
    ],
    "icdf": [
      "self",
      "value"
    ]
  },
  "MultivariateRiemannPosterior": {
    "__init__": [
      "self",
      "borders",
      "probabilities",
      "correlation_matrix"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ]
  },
  "_get_sampler_riemann": [
    "posterior",
    "sample_shape"
  ],
  "BLLPosterior": {
    "__init__": [
      "self",
      "model",
      "distribution",
      "X",
      "output_dim"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ]
  },
  "mvn_kl_divergence": [
    "p_mean",
    "q_mean",
    "p_covar",
    "q_covar"
  ],
  "mvn_hellinger_distance": [
    "p_mean",
    "q_mean",
    "p_covar",
    "q_covar"
  ],
  "SampleModel": {
    "__init__": [
      "self",
      "backbone",
      "sampled_params",
      "num_inputs",
      "num_outputs"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "VBLLNetwork": {
    "__init__": [
      "self",
      "in_features",
      "hidden_features",
      "out_features",
      "num_layers",
      "parameterization",
      "cov_rank",
      "mean_initialization",
      "prior_scale",
      "wishart_scale",
      "clamp_noise_init",
      "kl_scale",
      "backbone",
      "activation",
      "device"
    ],
    "forward": [
      "self",
      "x"
    ],
    "sample_posterior_function": [
      "self",
      "sample_shape"
    ]
  },
  "_get_optimizer": [
    "optimizer_class",
    "model_parameters",
    "lr"
  ],
  "VBLLModel": {
    "__init__": [
      "self"
    ],
    "backbone": [
      "self"
    ],
    "head": [
      "self"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "__call__": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "train_X",
      "train_y",
      "val_X",
      "val_y",
      "optimization_settings",
      "initialization_params"
    ],
    "set_reg_weight": [
      "self",
      "new_weight"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "__str__": [
      "self"
    ]
  },
  "MLP": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "hidden_dims",
      "activation",
      "init_func"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "REncoder": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "hidden_dims",
      "activation",
      "init_func"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "ZEncoder": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "hidden_dims",
      "activation",
      "init_func"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "Decoder": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "hidden_dims",
      "activation",
      "init_func"
    ],
    "forward": [
      "self",
      "x_pred",
      "z"
    ]
  },
  "NeuralProcessModel": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "r_hidden_dims",
      "z_hidden_dims",
      "decoder_hidden_dims",
      "x_dim",
      "y_dim",
      "r_dim",
      "z_dim",
      "n_context",
      "activation",
      "init_func",
      "likelihood",
      "input_transform"
    ],
    "data_to_z_params": [
      "self",
      "x",
      "y",
      "r_dim"
    ],
    "sample_z": [
      "self",
      "mu",
      "logvar",
      "n",
      "min_std",
      "scaler"
    ],
    "KLD_gaussian": [
      "self",
      "min_std",
      "scaler"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "transform_inputs": [
      "self",
      "X",
      "input_transform"
    ],
    "forward": [
      "self",
      "train_X",
      "train_Y",
      "axis"
    ],
    "random_split_context_target": [
      "self",
      "x",
      "y",
      "n_context",
      "axis"
    ]
  },
  "get_random_x_for_agp": [
    "n",
    "bounds",
    "q",
    "seed"
  ],
  "SingleTaskAugmentedGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "m",
      "likelihood",
      "covar_module",
      "mean_module",
      "outcome_transform",
      "input_transform"
    ],
    "_init_fit_gp": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "likelihood",
      "covar_module",
      "mean_module",
      "outcome_transform",
      "input_transform"
    ]
  },
  "_get_reliable_observations": [
    "trusty_model",
    "other_model",
    "x",
    "m"
  ],
  "ExampleModel": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar"
    ]
  },
  "tp": [
    "M"
  ],
  "Normal": {
    "__init__": [
      "self",
      "loc",
      "chol"
    ],
    "mean": [
      "self"
    ],
    "var": [
      "self"
    ],
    "chol_covariance": [
      "self"
    ],
    "covariance_diagonal": [
      "self"
    ],
    "covariance": [
      "self"
    ],
    "precision": [
      "self"
    ],
    "logdet_covariance": [
      "self"
    ],
    "logdet_precision": [
      "self"
    ],
    "trace_covariance": [
      "self"
    ],
    "trace_precision": [
      "self"
    ],
    "covariance_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "precision_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "__add__": [
      "self",
      "inp"
    ],
    "__matmul__": [
      "self",
      "inp"
    ],
    "squeeze": [
      "self",
      "idx"
    ]
  },
  "DenseNormal": {
    "__init__": [
      "self",
      "loc",
      "cholesky"
    ],
    "mean": [
      "self"
    ],
    "chol_covariance": [
      "self"
    ],
    "covariance": [
      "self"
    ],
    "inverse_covariance": [
      "self"
    ],
    "logdet_covariance": [
      "self"
    ],
    "trace_covariance": [
      "self"
    ],
    "covariance_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "precision_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "__matmul__": [
      "self",
      "inp"
    ],
    "squeeze": [
      "self",
      "idx"
    ]
  },
  "LowRankNormal": {
    "__init__": [
      "self",
      "loc",
      "cov_factor",
      "diag"
    ],
    "mean": [
      "self"
    ],
    "chol_covariance": [
      "self"
    ],
    "inverse_covariance": [
      "self"
    ],
    "logdet_covariance": [
      "self"
    ],
    "trace_covariance": [
      "self"
    ],
    "covariance_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "precision_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "__matmul__": [
      "self",
      "inp"
    ],
    "squeeze": [
      "self",
      "idx"
    ]
  },
  "DenseNormalPrec": {
    "__init__": [
      "self",
      "loc",
      "cholesky",
      "validate_args"
    ],
    "mean": [
      "self"
    ],
    "chol_covariance": [
      "self"
    ],
    "covariance": [
      "self"
    ],
    "inverse_covariance": [
      "self"
    ],
    "logdet_covariance": [
      "self"
    ],
    "trace_covariance": [
      "self"
    ],
    "covariance_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "precision_weighted_inner_prod": [
      "self",
      "b",
      "reduce_dim"
    ],
    "__matmul__": [
      "self",
      "inp"
    ],
    "squeeze": [
      "self",
      "idx"
    ]
  },
  "get_parameterization": [
    "p"
  ],
  "gaussian_kl": [
    "p",
    "q_scale"
  ],
  "VBLLReturn": {},
  "Regression": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "regularization_weight",
      "parameterization",
      "mean_initialization",
      "prior_scale",
      "wishart_scale",
      "cov_rank",
      "clamp_noise_init",
      "dof"
    ],
    "W": [
      "self"
    ],
    "noise": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ],
    "predictive": [
      "self",
      "x"
    ],
    "_get_train_loss_fn": [
      "self",
      "x"
    ],
    "_get_val_loss_fn": [
      "self",
      "x"
    ]
  },
  "PFNModel": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "model",
      "checkpoint_url",
      "train_Yvar",
      "batch_first",
      "constant_model_kwargs",
      "input_transform",
      "load_training_checkpoint"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "_prepare_data": [
      "self",
      "X"
    ],
    "pfn_predict": [
      "self",
      "X",
      "train_X",
      "train_Y"
    ],
    "borders": [
      "self"
    ]
  },
  "MultivariatePFNModel": {
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "estimate_correlations": [
      "self",
      "X",
      "train_X",
      "train_Y",
      "marginals"
    ],
    "_compute_conditional_means": [
      "self",
      "X",
      "train_X",
      "train_Y",
      "marginals"
    ],
    "_estimate_covariances": [
      "self",
      "cond_mean",
      "cond_val",
      "mean",
      "var"
    ],
    "_map_psd": [
      "self",
      "A"
    ]
  },
  "AbstractBLLModel": {
    "__init__": [
      "self"
    ],
    "num_outputs": [
      "self"
    ],
    "num_inputs": [
      "self"
    ],
    "device": [
      "self"
    ],
    "__call__": [
      "self",
      "X"
    ],
    "fit": [
      "self"
    ],
    "sample": [
      "self",
      "sample_shape"
    ]
  },
  "ModelPaths": {
    "pfns4bo_hebo": [],
    "pfns4bo_bnn": []
  },
  "download_model": [
    "model_path",
    "proxies",
    "cache_dir"
  ],
  "TYPE_CHECKING": [],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "__commit_id__": [],
  "commit_id": [],
  "_Flag": {
    "on": [
      "cls"
    ],
    "off": [
      "cls"
    ],
    "_set_state": [
      "cls",
      "state"
    ],
    "__init__": [
      "self",
      "state"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "propagate_grads": {},
  "validate_input_scaling": {},
  "log_level": {
    "_set_level": [
      "cls",
      "level"
    ],
    "__init__": [
      "self",
      "level"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "_debug_warn": [
    "w"
  ],
  "_rethrow_warn": [
    "w"
  ],
  "DEFAULT_WARNING_HANDLER": [],
  "FitGPyTorchMLL": [],
  "fit_gpytorch_mll": [
    "mll",
    "closure",
    "optimizer",
    "closure_kwargs",
    "optimizer_kwargs"
  ],
  "_fit_fallback": [
    "mll",
    "_",
    "__"
  ],
  "_fit_list": [
    "mll",
    "_",
    "__"
  ],
  "_fit_fallback_approximate": [
    "mll",
    "_",
    "__"
  ],
  "fit_fully_bayesian_model_nuts": [
    "model",
    "max_tree_depth",
    "warmup_steps",
    "num_samples",
    "thinning",
    "disable_progbar",
    "jit_compile"
  ],
  "get_fitted_map_saas_model": [
    "train_X",
    "train_Y",
    "train_Yvar",
    "input_transform",
    "outcome_transform",
    "tau",
    "optimizer_kwargs"
  ],
  "get_fitted_map_saas_ensemble": [
    "train_X",
    "train_Y",
    "train_Yvar",
    "input_transform",
    "outcome_transform",
    "taus",
    "num_taus",
    "optimizer_kwargs"
  ],
  "LOG_LEVEL_DEFAULT": [],
  "_get_logger": [
    "name",
    "level"
  ],
  "shape_to_str": [
    "shape"
  ],
  "logger": [],
  "CVFolds": {},
  "CVResults": {},
  "gen_loo_cv_folds": [
    "train_X",
    "train_Y",
    "train_Yvar"
  ],
  "batch_cross_validation": [
    "model_cls",
    "mll_cls",
    "cv_folds",
    "fit_args",
    "observation_noise",
    "model_init_kwargs"
  ],
  "SamplingStrategy": {
    "forward": [
      "self",
      "X",
      "num_samples"
    ]
  },
  "MaxPosteriorSampling": {
    "__init__": [
      "self",
      "model",
      "objective",
      "posterior_transform",
      "replacement"
    ],
    "forward": [
      "self",
      "X",
      "num_samples",
      "observation_noise"
    ],
    "maximize_samples": [
      "self",
      "X",
      "samples",
      "num_samples"
    ]
  },
  "BoltzmannSampling": {
    "__init__": [
      "self",
      "acq_func",
      "eta",
      "replacement"
    ],
    "forward": [
      "self",
      "X",
      "num_samples"
    ]
  },
  "ConstrainedMaxPosteriorSampling": {
    "__init__": [
      "self",
      "model",
      "constraint_model",
      "objective",
      "posterior_transform",
      "replacement"
    ],
    "_convert_samples_to_scores": [
      "self",
      "Y_samples",
      "C_samples"
    ],
    "forward": [
      "self",
      "X",
      "num_samples",
      "observation_noise"
    ]
  },
  "_flip_sub_unique": [
    "x",
    "k"
  ],
  "_NoFixedFeatures": {},
  "_remove_fixed_features_from_optimization": [
    "fixed_features",
    "acquisition_function",
    "initial_conditions",
    "d",
    "lower_bounds",
    "upper_bounds",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints"
  ],
  "TGenCandidates": [],
  "gen_candidates_scipy": [
    "initial_conditions",
    "acquisition_function",
    "lower_bounds",
    "upper_bounds",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "options",
    "fixed_features",
    "timeout_sec",
    "use_parallel_mode"
  ],
  "_get_f_np_wrapper": [
    "shapeX",
    "device",
    "dtype",
    "with_grad"
  ],
  "get_reasons_against_fast_path": [
    "method",
    "with_grad",
    "minimize_options",
    "timeout_sec"
  ],
  "gen_candidates_torch": [
    "initial_conditions",
    "acquisition_function",
    "lower_bounds",
    "upper_bounds",
    "optimizer",
    "options",
    "callback",
    "fixed_features",
    "timeout_sec"
  ],
  "get_best_candidates": [
    "batch_candidates",
    "batch_values"
  ],
  "_process_scipy_result": [
    "res",
    "options"
  ],
  "MCAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending"
    ],
    "_get_samples_and_objectives": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "SampleReductionProtocol": {
    "__call__": [
      "X"
    ]
  },
  "SampleReducingMCAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "sample_reduction",
      "q_reduction",
      "constraints",
      "eta",
      "fat"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_non_reduced_forward": [
      "self",
      "X"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ],
    "_apply_constraints": [
      "self",
      "acqval",
      "samples"
    ]
  },
  "qExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "constraints",
      "eta"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "qNoisyExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "X_baseline",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "prune_baseline",
      "cache_root",
      "constraints",
      "eta",
      "marginalize_dim"
    ],
    "compute_best_f": [
      "self",
      "obj"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ],
    "_get_samples_and_objectives": [
      "self",
      "X"
    ],
    "_compute_best_feasible_objective": [
      "self",
      "samples",
      "obj"
    ]
  },
  "qProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "tau",
      "constraints",
      "eta"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "qSimpleRegret": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "qUpperConfidenceBound": {
    "__init__": [
      "self",
      "model",
      "beta",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending"
    ],
    "_get_beta_prime": [
      "self",
      "beta"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "qLowerConfidenceBound": {
    "_get_beta_prime": [
      "self",
      "beta"
    ]
  },
  "qPosteriorStandardDeviation": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "constraints",
      "eta"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "MCMC_DIM": [],
  "ESTIMATION_TYPES": [],
  "MC_ADD_TERM": [],
  "FULLY_BAYESIAN_ERROR_MSG": [],
  "qJointEntropySearch": {
    "__init__": [
      "self",
      "model",
      "optimal_inputs",
      "optimal_outputs",
      "condition_noiseless",
      "posterior_transform",
      "X_pending",
      "estimation_type",
      "num_samples"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_compute_lower_bound_information_gain": [
      "self",
      "X",
      "return_parts"
    ],
    "_compute_monte_carlo_variables": [
      "self",
      "posterior"
    ],
    "_compute_monte_carlo_information_gain": [
      "self",
      "X",
      "return_parts"
    ]
  },
  "NEGATIVE_INFOGAIN_WARNING": [],
  "check_negative_info_gain": [
    "info_gain"
  ],
  "FullyBayesianAcquisitionFunction": {
    "__init__": [
      "self",
      "model"
    ]
  },
  "qBayesianActiveLearningByDisagreement": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "posterior_transform",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "get_acquisition_function": [
    "acquisition_function_name",
    "model",
    "objective",
    "X_observed",
    "posterior_transform",
    "X_pending",
    "constraints",
    "eta",
    "mc_samples",
    "seed"
  ],
  "supports_cache_root": [
    "model"
  ],
  "_get_cache_root_not_supported_message": [
    "model_cls"
  ],
  "CachedCholeskyMCSamplerMixin": {
    "__init__": [
      "self",
      "model",
      "cache_root",
      "sampler"
    ],
    "_compute_root_decomposition": [
      "self",
      "posterior"
    ],
    "_get_f_X_samples": [
      "self",
      "posterior",
      "q_in"
    ],
    "_set_sampler": [
      "self",
      "q_in",
      "posterior"
    ]
  },
  "_neg_inv_sqrt2": [],
  "_log_sqrt_pi_div_2": [],
  "AnalyticAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "posterior_transform",
      "allow_multi_output"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "_mean_and_sigma": [
      "self",
      "X",
      "compute_sigma",
      "min_var"
    ]
  },
  "LogProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qAnalyticProbabilityOfImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "LogExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ConstrainedAnalyticAcquisitionFunctionMixin": {
    "__init__": [
      "self",
      "constraints"
    ],
    "register_buffer": [
      "self",
      "name",
      "value"
    ],
    "_preprocess_constraint_bounds": [
      "self",
      "constraints"
    ],
    "_compute_log_prob_feas": [
      "self",
      "means",
      "sigmas"
    ]
  },
  "LogConstrainedExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "objective_index",
      "constraints",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "LogProbabilityOfFeasibility": {
    "__init__": [
      "self",
      "model",
      "constraints"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ConstrainedExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "objective_index",
      "constraints",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "LogNoisyExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "X_observed",
      "num_fantasies",
      "maximize",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "NoisyExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "X_observed",
      "num_fantasies",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "UpperConfidenceBound": {
    "__init__": [
      "self",
      "model",
      "beta",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PosteriorMean": {
    "__init__": [
      "self",
      "model",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ScalarizedPosteriorMean": {
    "__init__": [
      "self",
      "model",
      "weights",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PosteriorStandardDeviation": {
    "__init__": [
      "self",
      "model",
      "posterior_transform",
      "maximize"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_scaled_improvement": [
    "mean",
    "sigma",
    "best_f",
    "maximize"
  ],
  "_ei_helper": [
    "u"
  ],
  "_log_ei_helper": [
    "u"
  ],
  "_log_abs_u_Phi_div_phi": [
    "u"
  ],
  "_check_noisy_ei_model": [
    "model"
  ],
  "_get_noiseless_fantasy_model": [
    "model",
    "batch_X_observed",
    "Y_fantasized"
  ],
  "qNegIntegratedPosteriorVariance": {
    "__init__": [
      "self",
      "model",
      "mc_points",
      "sampler",
      "posterior_transform",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PairwiseMCPosteriorVariance": {
    "__init__": [
      "self",
      "model",
      "objective",
      "sampler"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qPredictiveEntropySearch": {
    "__init__": [
      "self",
      "model",
      "optimal_inputs",
      "maximize",
      "X_pending",
      "max_ep_iterations",
      "ep_jitter",
      "test_jitter",
      "threshold"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PriorGuidedAcquisitionFunction": {
    "__init__": [
      "self",
      "acq_function",
      "prior_module",
      "log",
      "prior_exponent",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "MaxValueBase": {
    "__init__": [
      "self",
      "model",
      "candidate_set",
      "num_mv_samples",
      "posterior_transform",
      "use_gumbel",
      "maximize",
      "X_pending",
      "train_inputs"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_sample_max_values": [
      "self",
      "num_samples",
      "X_pending"
    ],
    "_compute_information_gain": [
      "self",
      "X"
    ]
  },
  "qMaxValueEntropy": {
    "__init__": [
      "self",
      "model",
      "candidate_set",
      "num_fantasies",
      "num_mv_samples",
      "num_y_samples",
      "posterior_transform",
      "use_gumbel",
      "maximize",
      "X_pending",
      "train_inputs"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "_compute_information_gain": [
      "self",
      "X",
      "mean_M",
      "variance_M",
      "covar_mM"
    ]
  },
  "qLowerBoundMaxValueEntropy": {
    "__init__": [
      "self",
      "model",
      "candidate_set",
      "num_mv_samples",
      "posterior_transform",
      "use_gumbel",
      "maximize",
      "X_pending",
      "train_inputs"
    ],
    "_compute_information_gain": [
      "self",
      "X",
      "mean_M",
      "variance_M",
      "covar_mM"
    ]
  },
  "qMultiFidelityMaxValueEntropy": {
    "__init__": [
      "self",
      "model",
      "candidate_set",
      "num_fantasies",
      "num_mv_samples",
      "num_y_samples",
      "posterior_transform",
      "use_gumbel",
      "maximize",
      "X_pending",
      "cost_aware_utility",
      "project",
      "expand"
    ],
    "cost_sampler": [
      "self"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qMultiFidelityLowerBoundMaxValueEntropy": {
    "__init__": [
      "self",
      "model",
      "candidate_set",
      "num_fantasies",
      "num_mv_samples",
      "num_y_samples",
      "X_pending",
      "posterior_transform",
      "use_gumbel",
      "maximize",
      "cost_aware_utility",
      "project",
      "expand"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "_compute_information_gain": [
      "self",
      "X",
      "mean_M",
      "variance_M",
      "covar_mM"
    ]
  },
  "_sample_max_value_Thompson": [
    "model",
    "candidate_set",
    "num_samples",
    "posterior_transform",
    "maximize"
  ],
  "_sample_max_value_Gumbel": [
    "model",
    "candidate_set",
    "num_samples",
    "posterior_transform",
    "maximize"
  ],
  "repeat_to_match_aug_dim": [
    "target_tensor",
    "reference_tensor"
  ],
  "compute_best_feasible_objective": [
    "samples",
    "obj",
    "constraints",
    "model",
    "objective",
    "posterior_transform",
    "X_baseline",
    "infeasible_obj"
  ],
  "_estimate_objective_lower_bound": [
    "model",
    "objective",
    "posterior_transform",
    "X"
  ],
  "get_infeasible_cost": [
    "X",
    "model",
    "objective",
    "posterior_transform"
  ],
  "_prune_inferior_shared_processing": [
    "model",
    "X",
    "is_moo",
    "objective",
    "posterior_transform",
    "constraints",
    "num_samples",
    "max_frac",
    "sampler",
    "marginalize_dim"
  ],
  "prune_inferior_points": [
    "model",
    "X",
    "objective",
    "posterior_transform",
    "constraints",
    "num_samples",
    "max_frac",
    "sampler",
    "marginalize_dim"
  ],
  "project_to_target_fidelity": [
    "X",
    "target_fidelities",
    "d"
  ],
  "expand_trace_observations": [
    "X",
    "fidelity_dims",
    "num_trace_obs"
  ],
  "project_to_sample_points": [
    "X",
    "sample_points"
  ],
  "get_optimal_samples": [
    "model",
    "bounds",
    "num_optima",
    "raw_samples",
    "num_restarts",
    "posterior_transform",
    "objective",
    "return_transformed"
  ],
  "RiskMeasureMCObjective": {
    "__init__": [
      "self",
      "n_w",
      "preprocessing_function"
    ],
    "_prepare_samples": [
      "self",
      "samples"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "CVaR": {
    "__init__": [
      "self",
      "alpha",
      "n_w",
      "preprocessing_function"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "VaR": {
    "__init__": [
      "self",
      "alpha",
      "n_w",
      "preprocessing_function"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "WorstCase": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "Expectation": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "AcquisitionFunction": {
    "__init__": [
      "self",
      "model"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "OneShotAcquisitionFunction": {
    "get_augmented_q_batch_size": [
      "self",
      "q"
    ],
    "extract_candidates": [
      "self",
      "X_full"
    ]
  },
  "MCSamplerMixin": {
    "_default_sample_shape": [],
    "__init__": [
      "self",
      "sampler"
    ],
    "get_posterior_samples": [
      "self",
      "posterior"
    ],
    "sample_shape": [
      "self"
    ]
  },
  "MultiModelAcquisitionFunction": {
    "__init__": [
      "self",
      "model_dict"
    ]
  },
  "SIGMA_JITTER": [],
  "AnalyticExpectedUtilityOfBestOption": {
    "__init__": [
      "self",
      "pref_model",
      "outcome_model",
      "previous_winner"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qExpectedUtilityOfBestOption": {
    "__init__": [
      "self",
      "pref_model",
      "outcome_model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PairwiseBayesianActiveLearningByDisagreement": {
    "__init__": [
      "self",
      "pref_model",
      "outcome_model",
      "num_samples",
      "std_noise"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ProximalAcquisitionFunction": {
    "__init__": [
      "self",
      "acq_function",
      "proximal_weights",
      "transformed_weighting",
      "beta"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_validate_model": [
    "model",
    "proximal_weights"
  ],
  "_get_input_transform": [
    "model"
  ],
  "DEFAULT_NUM_PREF_SAMPLES": [],
  "PosteriorTransform": {
    "evaluate": [
      "self",
      "Y"
    ],
    "forward": [
      "self",
      "posterior"
    ]
  },
  "ScalarizedPosteriorTransform": {
    "__init__": [
      "self",
      "weights",
      "offset"
    ],
    "evaluate": [
      "self",
      "Y"
    ],
    "forward": [
      "self",
      "posterior"
    ]
  },
  "ExpectationPosteriorTransform": {
    "__init__": [
      "self",
      "n_w",
      "weights"
    ],
    "evaluate": [
      "self",
      "Y"
    ],
    "forward": [
      "self",
      "posterior"
    ]
  },
  "MCAcquisitionObjective": {
    "forward": [
      "self",
      "samples",
      "X"
    ],
    "__call__": [
      "self",
      "samples",
      "X"
    ]
  },
  "IdentityMCObjective": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "LinearMCObjective": {
    "__init__": [
      "self",
      "weights"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "GenericMCObjective": {
    "__init__": [
      "self",
      "objective"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "ConstrainedMCObjective": {
    "__init__": [
      "self",
      "objective",
      "constraints",
      "infeasible_cost",
      "eta"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "LEARNED_OBJECTIVE_PREF_MODEL_MIXED_DTYPE_WARN": [],
  "LearnedObjective": {
    "__init__": [
      "self",
      "pref_model",
      "sample_shape",
      "seed"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "get_dtype_of_sequence": [
    "values"
  ],
  "get_device_of_sequence": [
    "values"
  ],
  "FixedFeatureAcquisitionFunction": {
    "__init__": [
      "self",
      "acq_function",
      "d",
      "columns",
      "values"
    ],
    "forward": [
      "self",
      "X"
    ],
    "X_pending": [
      "self",
      "X_pending"
    ],
    "_construct_X_full": [
      "self",
      "X"
    ]
  },
  "qKnowledgeGradient": {
    "__init__": [
      "self",
      "model",
      "num_fantasies",
      "sampler",
      "objective",
      "posterior_transform",
      "inner_sampler",
      "X_pending",
      "current_value"
    ],
    "forward": [
      "self",
      "X"
    ],
    "evaluate": [
      "self",
      "X",
      "bounds"
    ],
    "get_augmented_q_batch_size": [
      "self",
      "q"
    ],
    "extract_candidates": [
      "self",
      "X_full"
    ]
  },
  "qMultiFidelityKnowledgeGradient": {
    "__init__": [
      "self",
      "model",
      "num_fantasies",
      "sampler",
      "objective",
      "posterior_transform",
      "inner_sampler",
      "X_pending",
      "current_value",
      "cost_aware_utility",
      "project",
      "expand",
      "valfunc_cls",
      "valfunc_argfac"
    ],
    "cost_sampler": [
      "self"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ProjectedAcquisitionFunction": {
    "__init__": [
      "self",
      "base_value_function",
      "project"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_get_value_function": [
    "model",
    "objective",
    "posterior_transform",
    "sampler",
    "project",
    "valfunc_cls",
    "valfunc_argfac"
  ],
  "_split_fantasy_points": [
    "X",
    "n_f"
  ],
  "TAcqfArgConstructor": [],
  "qMultiStepLookahead": {
    "__init__": [
      "self",
      "model",
      "batch_sizes",
      "num_fantasies",
      "samplers",
      "valfunc_cls",
      "valfunc_argfacs",
      "objective",
      "posterior_transform",
      "inner_mc_samples",
      "X_pending",
      "collapse_fantasy_base_samples"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_num_auxiliary": [
      "self"
    ],
    "_set_samplers_batch_range": [
      "self",
      "batch_shape"
    ],
    "get_augmented_q_batch_size": [
      "self",
      "q"
    ],
    "get_split_shapes": [
      "self",
      "X"
    ],
    "get_multi_step_tree_input_representation": [
      "self",
      "X"
    ],
    "extract_candidates": [
      "self",
      "X_full"
    ],
    "get_induced_fantasy_model": [
      "self",
      "X"
    ]
  },
  "_step": [
    "model",
    "Xs",
    "samplers",
    "valfunc_cls",
    "valfunc_argfacs",
    "inner_samplers",
    "objective",
    "posterior_transform",
    "running_val",
    "sample_weights",
    "step_index"
  ],
  "_compute_stage_value": [
    "model",
    "valfunc_cls",
    "X",
    "objective",
    "posterior_transform",
    "inner_sampler",
    "arg_fac"
  ],
  "_construct_sample_weights": [
    "prev_weights",
    "sampler"
  ],
  "_construct_inner_samplers": [
    "batch_sizes",
    "valfunc_cls",
    "inner_mc_samples",
    "objective"
  ],
  "_get_induced_fantasy_model": [
    "model",
    "Xs",
    "samplers"
  ],
  "warmstart_multistep": [
    "acq_function",
    "bounds",
    "num_restarts",
    "raw_samples",
    "full_optimizer"
  ],
  "make_best_f": [
    "model",
    "X"
  ],
  "DecoupledAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "X_evaluation_mask"
    ],
    "X_evaluation_mask": [
      "self",
      "X_evaluation_mask"
    ],
    "set_X_pending": [
      "self",
      "X_pending",
      "X_pending_evaluation_mask"
    ],
    "construct_evaluation_mask": [
      "self",
      "X"
    ]
  },
  "MultiOutputAcquisitionFunction": {
    "forward": [
      "self",
      "X"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ]
  },
  "MultiOutputPosteriorMean": {
    "__init__": [
      "self",
      "model",
      "weights"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "MultiOutputAcquisitionFunctionWrapper": {
    "__init__": [
      "self",
      "acqfs"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "ACQF_INPUT_CONSTRUCTOR_REGISTRY": [],
  "T": [],
  "MaybeDict": [],
  "TOptimizeObjectiveKwargs": [],
  "_field_is_shared": [
    "datasets",
    "fieldname"
  ],
  "_get_dataset_field": [
    "dataset",
    "fieldname",
    "transform",
    "join_rule",
    "first_only",
    "assert_shared"
  ],
  "get_acqf_input_constructor": [
    "acqf_cls"
  ],
  "allow_only_specific_variable_kwargs": [
    "f"
  ],
  "acqf_input_constructor": [],
  "_register_acqf_input_constructor": [
    "acqf_cls",
    "input_constructor"
  ],
  "construct_inputs_posterior_mean": [
    "model",
    "posterior_transform"
  ],
  "construct_inputs_pof": [
    "model",
    "constraints_tuple"
  ],
  "construct_inputs_logcei": [
    "model",
    "training_data",
    "objective_index",
    "constraints_tuple",
    "best_f",
    "maximize"
  ],
  "construct_inputs_ucb": [
    "model",
    "posterior_transform",
    "beta",
    "maximize"
  ],
  "construct_inputs_noisy_ei": [
    "model",
    "training_data",
    "num_fantasies",
    "maximize"
  ],
  "construct_inputs_qSimpleRegret": [
    "model",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "constraints",
    "X_baseline"
  ],
  "construct_inputs_qEI": [
    "model",
    "training_data",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "best_f",
    "constraints",
    "eta"
  ],
  "construct_inputs_qLogEI": [
    "model",
    "training_data",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "best_f",
    "constraints",
    "eta",
    "fat",
    "tau_max",
    "tau_relu"
  ],
  "construct_inputs_LogPF": [
    "model",
    "constraints",
    "posterior_transform",
    "X_pending",
    "sampler",
    "eta",
    "fat",
    "tau_max"
  ],
  "construct_inputs_qNEI": [
    "model",
    "training_data",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "X_baseline",
    "prune_baseline",
    "cache_root",
    "constraints",
    "eta"
  ],
  "construct_inputs_qLogNEI": [
    "model",
    "training_data",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "X_baseline",
    "prune_baseline",
    "cache_root",
    "constraints",
    "eta",
    "fat",
    "tau_max",
    "tau_relu",
    "incremental"
  ],
  "construct_inputs_qPI": [
    "model",
    "training_data",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "tau",
    "best_f",
    "constraints",
    "eta"
  ],
  "construct_inputs_qUCB": [
    "model",
    "objective",
    "posterior_transform",
    "X_pending",
    "sampler",
    "X_baseline",
    "constraints",
    "beta"
  ],
  "_get_sampler": [
    "mc_samples",
    "qmc"
  ],
  "construct_inputs_EHVI": [
    "model",
    "training_data",
    "objective_thresholds",
    "posterior_transform",
    "constraints",
    "alpha",
    "Y_pmean"
  ],
  "construct_inputs_qEHVI": [
    "model",
    "training_data",
    "objective_thresholds",
    "objective",
    "constraints",
    "alpha",
    "sampler",
    "X_pending",
    "eta",
    "mc_samples",
    "qmc"
  ],
  "construct_inputs_qNEHVI": [
    "model",
    "training_data",
    "objective_thresholds",
    "objective",
    "X_baseline",
    "constraints",
    "alpha",
    "sampler",
    "X_pending",
    "eta",
    "fat",
    "mc_samples",
    "qmc",
    "prune_baseline",
    "cache_pending",
    "max_iep",
    "incremental_nehvi",
    "cache_root"
  ],
  "construct_inputs_qLogNEHVI": [
    "model",
    "training_data",
    "objective_thresholds",
    "objective",
    "X_baseline",
    "constraints",
    "alpha",
    "sampler",
    "X_pending",
    "eta",
    "fat",
    "mc_samples",
    "qmc",
    "prune_baseline",
    "cache_pending",
    "max_iep",
    "incremental_nehvi",
    "cache_root",
    "tau_relu",
    "tau_max"
  ],
  "construct_inputs_qLogNParEGO": [
    "model",
    "training_data",
    "scalarization_weights",
    "objective",
    "X_pending",
    "sampler",
    "X_baseline",
    "prune_baseline",
    "cache_root",
    "constraints",
    "eta",
    "fat",
    "tau_max",
    "tau_relu"
  ],
  "construct_inputs_qMES": [
    "model",
    "training_data",
    "bounds",
    "posterior_transform",
    "candidate_size",
    "maximize"
  ],
  "construct_inputs_mf_base": [
    "target_fidelities",
    "fidelity_weights",
    "cost_intercept",
    "num_trace_observations"
  ],
  "construct_inputs_qKG": [
    "model",
    "training_data",
    "bounds",
    "objective",
    "posterior_transform",
    "num_fantasies",
    "with_current_value"
  ],
  "construct_inputs_qHVKG": [
    "model",
    "training_data",
    "bounds",
    "objective_thresholds",
    "objective",
    "posterior_transform",
    "num_fantasies",
    "num_pareto"
  ],
  "construct_inputs_qMFKG": [
    "model",
    "training_data",
    "bounds",
    "target_fidelities",
    "objective",
    "posterior_transform",
    "fidelity_weights",
    "cost_intercept",
    "num_trace_observations",
    "num_fantasies"
  ],
  "construct_inputs_qMFHVKG": [
    "model",
    "training_data",
    "bounds",
    "target_fidelities",
    "objective_thresholds",
    "objective",
    "posterior_transform",
    "fidelity_weights",
    "cost_intercept",
    "num_trace_observations",
    "num_fantasies",
    "num_pareto"
  ],
  "construct_inputs_qMFMES": [
    "model",
    "training_data",
    "bounds",
    "target_fidelities",
    "num_fantasies",
    "fidelity_weights",
    "cost_intercept",
    "num_trace_observations",
    "candidate_size",
    "maximize"
  ],
  "construct_inputs_analytic_eubo": [
    "model",
    "pref_model",
    "previous_winner",
    "sample_multiplier",
    "objective",
    "posterior_transform"
  ],
  "construct_inputs_qeubo": [
    "model",
    "pref_model",
    "sample_multiplier",
    "sampler",
    "objective",
    "posterior_transform",
    "X_pending"
  ],
  "get_best_f_analytic": [
    "training_data",
    "posterior_transform"
  ],
  "get_best_f_mc": [
    "training_data",
    "objective",
    "posterior_transform",
    "constraints",
    "model"
  ],
  "optimize_objective": [
    "model",
    "bounds",
    "q",
    "acq_function",
    "objective",
    "posterior_transform",
    "linear_constraints",
    "fixed_features",
    "qmc",
    "mc_samples",
    "seed_inner",
    "optimizer_options",
    "post_processing_func",
    "batch_initial_conditions",
    "sequential"
  ],
  "construct_inputs_qJES": [
    "model",
    "bounds",
    "num_optima",
    "condition_noiseless",
    "posterior_transform",
    "X_pending",
    "estimation_type",
    "num_samples"
  ],
  "construct_inputs_BALD": [
    "model",
    "X_pending",
    "sampler",
    "posterior_transform"
  ],
  "construct_inputs_NIPV": [
    "model",
    "bounds",
    "num_mc_points",
    "X_pending",
    "posterior_transform"
  ],
  "_get_ref_point": [
    "objective_thresholds",
    "objective"
  ],
  "_construct_constraint_dict_from_tuple": [
    "constraints_tuple",
    "acqf_class"
  ],
  "L2Penalty": {
    "__init__": [
      "self",
      "init_point"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "L1Penalty": {
    "__init__": [
      "self",
      "init_point"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "GaussianPenalty": {
    "__init__": [
      "self",
      "init_point",
      "sigma"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "GroupLassoPenalty": {
    "__init__": [
      "self",
      "init_point",
      "groups"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "narrow_gaussian": [
    "X",
    "a"
  ],
  "nnz_approx": [
    "X",
    "target_point",
    "a"
  ],
  "L0Approximation": {
    "__init__": [
      "self",
      "target_point",
      "a"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "L0PenaltyApprox": {
    "__init__": [
      "self",
      "target_point",
      "a"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "PenalizedAcquisitionFunction": {
    "__init__": [
      "self",
      "raw_acqf",
      "penalty_func",
      "regularization_parameter"
    ],
    "forward": [
      "self",
      "X"
    ],
    "X_pending": [
      "self"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ]
  },
  "group_lasso_regularizer": [
    "X",
    "groups"
  ],
  "L1PenaltyObjective": {
    "__init__": [
      "self",
      "init_point"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PenalizedMCObjective": {
    "__init__": [
      "self",
      "objective",
      "penalty_objective",
      "regularization_parameter",
      "expand_dim"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "L0PenaltyApproxObjective": {
    "__init__": [
      "self",
      "target_point",
      "a"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "CostAwareUtility": {
    "forward": [
      "self",
      "X",
      "deltas",
      "sampler"
    ]
  },
  "GenericCostAwareUtility": {
    "__init__": [
      "self",
      "cost"
    ],
    "forward": [
      "self",
      "X",
      "deltas",
      "sampler"
    ]
  },
  "InverseCostWeightedUtility": {
    "__init__": [
      "self",
      "cost_model",
      "use_mean",
      "cost_objective",
      "log"
    ],
    "forward": [
      "self",
      "X",
      "deltas",
      "sampler",
      "X_evaluation_mask"
    ]
  },
  "BATCH_SIZE_CHANGE_ERROR": [],
  "PathwiseThompsonSampling": {
    "__init__": [
      "self",
      "model",
      "objective",
      "posterior_transform"
    ],
    "redraw": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_pathwise_forward": [
      "self",
      "X"
    ],
    "select_from_ensemble_models": [
      "self",
      "values"
    ]
  },
  "FloatOrTensor": [],
  "LogImprovementMCAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "constraints",
      "eta",
      "fat",
      "tau_max"
    ]
  },
  "qLogExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "best_f",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "constraints",
      "eta",
      "fat",
      "tau_max",
      "tau_relu"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "qLogNoisyExpectedImprovement": {
    "__init__": [
      "self",
      "model",
      "X_baseline",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "constraints",
      "eta",
      "fat",
      "prune_baseline",
      "cache_root",
      "tau_max",
      "tau_relu",
      "marginalize_dim",
      "incremental"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ],
    "_init_baseline": [
      "self",
      "model",
      "X_baseline",
      "X_pending",
      "sampler",
      "objective",
      "posterior_transform",
      "cache_root"
    ],
    "X_baseline": [
      "self"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "compute_best_f": [
      "self",
      "obj"
    ],
    "_get_samples_and_objectives": [
      "self",
      "X"
    ],
    "_compute_best_feasible_objective": [
      "self",
      "samples",
      "obj"
    ]
  },
  "qLogProbabilityOfFeasibility": {
    "__init__": [
      "self",
      "model",
      "constraints",
      "sampler",
      "objective",
      "posterior_transform",
      "X_pending",
      "eta",
      "fat",
      "tau_max"
    ],
    "_non_reduced_forward": [
      "self",
      "X"
    ],
    "_sample_forward": [
      "self",
      "obj"
    ]
  },
  "_log_improvement": [
    "Y",
    "best_f",
    "tau",
    "fat"
  ],
  "check_tau": [
    "tau",
    "name"
  ],
  "qExpectedHypervolumeImprovement": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "partitioning",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "eta",
      "fat"
    ],
    "_compute_qehvi": [
      "self",
      "samples",
      "X"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qNoisyExpectedHypervolumeImprovement": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "X_baseline",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "eta",
      "fat",
      "prune_baseline",
      "alpha",
      "cache_pending",
      "max_iep",
      "incremental_nehvi",
      "cache_root",
      "marginalize_dim"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "LowerBoundMultiObjectiveEntropySearch": {
    "__init__": [
      "self",
      "model",
      "pareto_sets",
      "pareto_fronts",
      "hypercell_bounds",
      "X_pending",
      "estimation_type",
      "num_samples"
    ],
    "_compute_posterior_statistics": [
      "self",
      "X"
    ],
    "_compute_monte_carlo_variables": [
      "self",
      "posterior"
    ],
    "_compute_lower_bound_information_gain": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qLowerBoundMultiObjectiveJointEntropySearch": {
    "__init__": [
      "self",
      "model",
      "pareto_sets",
      "pareto_fronts",
      "hypercell_bounds",
      "X_pending",
      "estimation_type",
      "num_samples"
    ],
    "_compute_posterior_statistics": [
      "self",
      "X"
    ],
    "_compute_monte_carlo_variables": [
      "self",
      "posterior"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_compute_entropy_noiseless": [
    "hypercell_bounds",
    "mean",
    "variance",
    "observation_noise"
  ],
  "_compute_entropy_upper_bound": [
    "hypercell_bounds",
    "mean",
    "variance",
    "observation_noise",
    "only_diagonal"
  ],
  "_compute_entropy_monte_carlo": [
    "hypercell_bounds",
    "mean",
    "variance",
    "observation_noise",
    "samples",
    "samples_log_prob"
  ],
  "qLogNParEGO": {
    "__init__": [
      "self",
      "model",
      "X_baseline",
      "scalarization_weights",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "eta",
      "fat",
      "prune_baseline",
      "cache_root",
      "tau_relu",
      "tau_max",
      "incremental"
    ]
  },
  "ExpectedHypervolumeImprovement": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "partitioning",
      "posterior_transform"
    ],
    "psi": [
      "self",
      "lower",
      "upper",
      "mu",
      "sigma"
    ],
    "nu": [
      "self",
      "lower",
      "upper",
      "mu",
      "sigma"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "MultiObjectiveAnalyticAcquisitionFunction": {
    "__init__": [
      "self",
      "model",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ]
  },
  "MultiObjectiveMCAcquisitionFunction": {
    "_default_sample_shape": [],
    "__init__": [
      "self",
      "model",
      "sampler",
      "objective",
      "constraints",
      "eta",
      "X_pending"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qMultiObjectivePredictiveEntropySearch": {
    "__init__": [
      "self",
      "model",
      "pareto_sets",
      "maximize",
      "X_pending",
      "max_ep_iterations",
      "ep_jitter",
      "test_jitter",
      "threshold"
    ],
    "_expectation_propagation": [
      "self"
    ],
    "_compute_information_gain": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "log_cdf_robust": [
    "x"
  ],
  "_initialize_predictive_matrices": [
    "X",
    "model",
    "observation_noise",
    "jitter",
    "natural"
  ],
  "_get_omega_f_contribution": [
    "mean",
    "cov",
    "N",
    "P",
    "M"
  ],
  "_replace_pareto_diagonal": [
    "A"
  ],
  "_update_omega": [
    "mean_f",
    "cov_f",
    "omega_f_nat_mean",
    "omega_f_nat_cov",
    "N",
    "P",
    "M",
    "maximize",
    "jitter"
  ],
  "_safe_update_omega": [
    "mean_f",
    "cov_f",
    "omega_f_nat_mean",
    "omega_f_nat_cov",
    "N",
    "P",
    "M",
    "maximize",
    "jitter"
  ],
  "_update_marginals": [
    "pred_f_nat_mean",
    "pred_f_nat_cov",
    "omega_f_nat_mean",
    "omega_f_nat_cov",
    "N",
    "P"
  ],
  "_damped_update": [
    "old_factor",
    "new_factor",
    "damping_factor"
  ],
  "_update_damping": [
    "nat_cov",
    "nat_cov_new",
    "damping_factor",
    "jitter"
  ],
  "_update_damping_when_converged": [
    "mean_old",
    "mean_new",
    "cov_old",
    "cov_new",
    "damping_factor",
    "iteration",
    "threshold"
  ],
  "_augment_factors_with_cached_factors": [
    "q",
    "N",
    "omega_f_nat_mean",
    "cached_omega_f_nat_mean",
    "omega_f_nat_cov",
    "cached_omega_f_nat_cov"
  ],
  "_compute_log_determinant": [
    "cov",
    "q"
  ],
  "qMultiObjectiveMaxValueEntropy": {
    "__init__": [
      "self"
    ]
  },
  "qLowerBoundMultiObjectiveMaxValueEntropySearch": {
    "__init__": [
      "self",
      "model",
      "hypercell_bounds",
      "X_pending",
      "estimation_type",
      "num_samples"
    ],
    "_compute_posterior_statistics": [
      "self",
      "X"
    ],
    "_compute_monte_carlo_variables": [
      "self",
      "posterior"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "get_default_partitioning_alpha": [
    "num_objectives"
  ],
  "prune_inferior_points_multi_objective": [
    "model",
    "X",
    "ref_point",
    "objective",
    "constraints",
    "num_samples",
    "max_frac",
    "marginalize_dim"
  ],
  "compute_sample_box_decomposition": [
    "pareto_fronts",
    "partitioning",
    "maximize",
    "num_constraints"
  ],
  "random_search_optimizer": [
    "model",
    "bounds",
    "num_points",
    "maximize",
    "pop_size",
    "max_tries"
  ],
  "sample_optimal_points": [
    "model",
    "bounds",
    "num_samples",
    "num_points",
    "optimizer",
    "maximize",
    "optimizer_kwargs"
  ],
  "MCMultiOutputObjective": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "GenericMCMultiOutputObjective": {},
  "IdentityMCMultiOutputObjective": {
    "__init__": [
      "self",
      "outcomes",
      "num_outcomes"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "WeightedMCMultiOutputObjective": {
    "__init__": [
      "self",
      "weights",
      "outcomes",
      "num_outcomes"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "FeasibilityWeightedMCMultiOutputObjective": {
    "__init__": [
      "self",
      "model",
      "X_baseline",
      "constraint_idcs",
      "objective"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "MultiOutputRiskMeasureMCObjective": {
    "__init__": [
      "self",
      "n_w",
      "preprocessing_function"
    ],
    "_prepare_samples": [
      "self",
      "samples"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "MultiOutputExpectation": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "IndependentCVaR": {
    "_get_sorted_prepared_samples": [
      "self",
      "samples"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "IndependentVaR": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "MultiOutputWorstCase": {
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "MVaR": {
    "_verify_output_shape": [],
    "__init__": [
      "self",
      "n_w",
      "alpha",
      "expectation",
      "preprocessing_function"
    ],
    "get_mvar_set_via_counting": [
      "self",
      "Y"
    ],
    "get_mvar_set_vectorized": [
      "self",
      "Y"
    ],
    "make_differentiable": [
      "self",
      "prepared_samples",
      "mvars"
    ],
    "forward": [
      "self",
      "samples",
      "X"
    ]
  },
  "MARS": {
    "__init__": [
      "self",
      "alpha",
      "n_w",
      "chebyshev_weights",
      "baseline_Y",
      "ref_point",
      "preprocessing_function"
    ],
    "set_baseline_Y": [
      "self",
      "model",
      "X_baseline",
      "Y_samples"
    ],
    "chebyshev_weights": [
      "self",
      "chebyshev_weights"
    ],
    "baseline_Y": [
      "self",
      "baseline_Y"
    ],
    "chebyshev_objective": [
      "self"
    ],
    "_construct_chebyshev_objective": [
      "self"
    ],
    "_prepare_samples": [
      "self",
      "samples"
    ],
    "_get_Y_normalization_bounds": [
      "Y",
      "ref_point"
    ]
  },
  "qHypervolumeKnowledgeGradient": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "num_fantasies",
      "num_pareto",
      "sampler",
      "objective",
      "inner_sampler",
      "X_evaluation_mask",
      "X_pending",
      "X_pending_evaluation_mask",
      "current_value",
      "use_posterior_mean",
      "cost_aware_utility",
      "log"
    ],
    "cost_sampler": [
      "self"
    ],
    "forward": [
      "self",
      "X"
    ],
    "get_augmented_q_batch_size": [
      "self",
      "q"
    ],
    "extract_candidates": [
      "self",
      "X_full"
    ]
  },
  "qMultiFidelityHypervolumeKnowledgeGradient": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "target_fidelities",
      "num_fantasies",
      "num_pareto",
      "sampler",
      "objective",
      "inner_sampler",
      "X_pending",
      "X_evaluation_mask",
      "X_pending_evaluation_mask",
      "current_value",
      "cost_aware_utility",
      "project",
      "valfunc_cls",
      "valfunc_argfac",
      "use_posterior_mean",
      "log"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_get_hv_value_function": [
    "model",
    "ref_point",
    "objective",
    "sampler",
    "project",
    "valfunc_cls",
    "valfunc_argfac",
    "use_posterior_mean",
    "log"
  ],
  "_split_hvkg_fantasy_points": [
    "X",
    "n_f",
    "num_pareto"
  ],
  "_check_log_utilities": [
    "cost_aware_utility"
  ],
  "MOMF": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "partitioning",
      "sampler",
      "objective",
      "constraints",
      "eta",
      "X_pending",
      "cost_call"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qLogExpectedHypervolumeImprovement": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "partitioning",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "eta",
      "fat",
      "tau_relu",
      "tau_max"
    ],
    "_compute_log_qehvi": [
      "self",
      "samples",
      "X"
    ],
    "_log_improvement": [
      "self",
      "obj_subsets",
      "view_shape"
    ],
    "_log_cell_lengths": [
      "self",
      "log_improvement_i",
      "view_shape"
    ],
    "_log_smooth_relu": [
      "self",
      "X"
    ],
    "_smooth_min": [
      "self",
      "X",
      "dim",
      "keepdim"
    ],
    "_smooth_minimum": [
      "self",
      "X",
      "Y"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "qLogNoisyExpectedHypervolumeImprovement": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "X_baseline",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "eta",
      "prune_baseline",
      "alpha",
      "cache_pending",
      "max_iep",
      "incremental_nehvi",
      "cache_root",
      "tau_relu",
      "tau_max",
      "fat",
      "marginalize_dim"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "TorchPosterior": {
    "__init__": [
      "self",
      "distribution"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "d"
    ],
    "quantile": [
      "self",
      "value"
    ],
    "density": [
      "self",
      "value"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ]
  },
  "LatentKroneckerGPPosterior": {
    "__init__": [
      "self",
      "model",
      "X",
      "T"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ]
  },
  "Posterior": {
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "quantile": [
      "self",
      "value"
    ],
    "density": [
      "self",
      "value"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ]
  },
  "GPyTorchPosterior": {
    "__init__": [
      "self",
      "distribution"
    ],
    "mvn": [
      "self"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "quantile": [
      "self",
      "value"
    ],
    "density": [
      "self",
      "value"
    ]
  },
  "_validate_scalarize_inputs": [
    "weights",
    "m"
  ],
  "scalarize_posterior_gpytorch": [
    "posterior",
    "weights",
    "offset"
  ],
  "scalarize_posterior": [
    "posterior",
    "weights",
    "offset"
  ],
  "TOL": [],
  "batched_bisect": [
    "f",
    "target",
    "bounds",
    "tol",
    "max_steps"
  ],
  "_quantile": [
    "posterior",
    "value"
  ],
  "GaussianMixturePosterior": {
    "__init__": [
      "self",
      "distribution"
    ],
    "mixture_mean": [
      "self"
    ],
    "mixture_variance": [
      "self"
    ],
    "mixture_covariance_matrix": [
      "self"
    ],
    "quantile": [
      "self",
      "value"
    ],
    "batch_range": [
      "self"
    ]
  },
  "FullyBayesianPosterior": {
    "__init__": [
      "self",
      "distribution"
    ]
  },
  "_reshape_base_samples_non_interleaved": [
    "mvn",
    "base_samples",
    "sample_shape"
  ],
  "HigherOrderGPPosterior": {
    "__init__": [
      "self",
      "distribution",
      "joint_covariance_matrix",
      "train_train_covar",
      "test_train_covar",
      "train_targets",
      "output_shape",
      "num_outputs"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "_prepare_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ]
  },
  "MultitaskGPPosterior": {
    "__init__": [
      "self",
      "distribution",
      "joint_covariance_matrix",
      "test_train_covar",
      "train_diff",
      "test_mean",
      "train_train_covar",
      "train_noise",
      "test_noise"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "_prepare_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples",
      "train_diff"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "_draw_from_base_covar": [
      "self",
      "covar",
      "base_samples"
    ]
  },
  "_permute_solve": [
    "A",
    "b"
  ],
  "PosteriorList": {
    "__init__": [
      "self"
    ],
    "_is_gaussian_mixture": [
      "self"
    ],
    "_get_mcmc_batch_dimension": [
      "self"
    ],
    "_reshape_tensor": [
      "X",
      "mcmc_samples"
    ],
    "_reshape_and_cat": [
      "self",
      "tensors"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "__getattr__": [
      "self",
      "name"
    ]
  },
  "TransformedPosterior": {
    "__init__": [
      "self",
      "posterior",
      "sample_transform",
      "mean_transform",
      "variance_transform"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ]
  },
  "EnsemblePosterior": {
    "__init__": [
      "self",
      "values",
      "weights"
    ],
    "ensemble_size": [
      "self"
    ],
    "mixture_size": [
      "self"
    ],
    "_compute_normalized_weights": [
      "self"
    ],
    "_compute_normalized_mixture_weights": [
      "self"
    ],
    "weights": [
      "self"
    ],
    "mixture_weights": [
      "self"
    ],
    "mixture_dims": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "mixture_mean": [
      "self"
    ],
    "mixture_variance": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "batch_shape": [
      "self"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ]
  },
  "mock_optimize_context_manager": [
    "force"
  ],
  "mock_optimize": [
    "f"
  ],
  "_log2": [],
  "_inv_sqrt_3": [],
  "TAU": [],
  "ALPHA": [],
  "exp": [
    "x"
  ],
  "log": [
    "x"
  ],
  "add": [
    "a",
    "b"
  ],
  "sub": [
    "a",
    "b"
  ],
  "div": [
    "a",
    "b"
  ],
  "mul": [
    "a",
    "b"
  ],
  "log1mexp": [
    "x"
  ],
  "log1pexp": [
    "x"
  ],
  "logexpit": [
    "X"
  ],
  "logplusexp": [
    "a",
    "b"
  ],
  "logdiffexp": [
    "log_a",
    "log_b"
  ],
  "logsumexp": [
    "x",
    "dim",
    "keepdim"
  ],
  "_inf_max_helper": [
    "max_fun",
    "x",
    "dim",
    "keepdim"
  ],
  "_any": [
    "x",
    "dim",
    "keepdim"
  ],
  "logmeanexp": [
    "X",
    "dim",
    "keepdim"
  ],
  "log_softplus": [
    "x",
    "tau"
  ],
  "smooth_amax": [
    "X",
    "dim",
    "keepdim",
    "tau"
  ],
  "smooth_amin": [
    "X",
    "dim",
    "keepdim",
    "tau"
  ],
  "check_dtype_float32_or_float64": [
    "X"
  ],
  "log_fatplus": [
    "x",
    "tau"
  ],
  "fatplus": [
    "x",
    "tau"
  ],
  "fatmax": [
    "x",
    "dim",
    "keepdim",
    "tau",
    "alpha"
  ],
  "fatmin": [
    "x",
    "dim",
    "keepdim",
    "tau",
    "alpha"
  ],
  "fatmaximum": [
    "a",
    "b",
    "tau",
    "alpha"
  ],
  "fatminimum": [
    "a",
    "b",
    "tau",
    "alpha"
  ],
  "log_fatmoid": [
    "X",
    "tau"
  ],
  "fatmoid": [
    "X",
    "tau"
  ],
  "cauchy": [
    "x"
  ],
  "_pareto": [
    "x",
    "alpha",
    "check"
  ],
  "sigmoid": [
    "X",
    "log",
    "fat"
  ],
  "approximate_round": [
    "X",
    "tau"
  ],
  "IdentitySTEFunction": {
    "backward": [
      "ctx",
      "grad_output"
    ]
  },
  "RoundSTE": {
    "forward": [
      "ctx",
      "X"
    ]
  },
  "OneHotArgmaxSTE": {
    "forward": [
      "ctx",
      "X"
    ]
  },
  "BufferDict": {
    "__init__": [
      "self",
      "buffers"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__setitem__": [
      "self",
      "key",
      "buffer"
    ],
    "__delitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__contains__": [
      "self",
      "key"
    ],
    "clear": [
      "self"
    ],
    "pop": [
      "self",
      "key"
    ],
    "keys": [
      "self"
    ],
    "items": [
      "self"
    ],
    "values": [
      "self"
    ],
    "update": [
      "self",
      "buffers"
    ],
    "extra_repr": [
      "self"
    ],
    "__call__": [
      "self",
      "input"
    ]
  },
  "MLL": [],
  "AIC": [],
  "BIC": [],
  "compute_in_sample_model_fit_metric": [
    "model",
    "criterion"
  ],
  "extract_batch_covar": [
    "mt_mvn"
  ],
  "_reshape_base_samples": [
    "base_samples",
    "sample_shape",
    "posterior"
  ],
  "sample_cached_cholesky": [
    "posterior",
    "baseline_L",
    "q",
    "base_samples",
    "sample_shape",
    "max_tries"
  ],
  "manual_seed": [
    "seed"
  ],
  "draw_sobol_samples": [
    "bounds",
    "n",
    "q",
    "batch_shape",
    "seed"
  ],
  "draw_sobol_normal_samples": [
    "d",
    "n",
    "device",
    "dtype",
    "seed"
  ],
  "sample_hypersphere": [
    "d",
    "n",
    "qmc",
    "seed",
    "device",
    "dtype"
  ],
  "sample_simplex": [
    "d",
    "n",
    "qmc",
    "seed",
    "device",
    "dtype"
  ],
  "sample_polytope": [
    "A",
    "b",
    "x0",
    "n",
    "n0",
    "n_thinning",
    "seed"
  ],
  "batched_multinomial": [
    "weights",
    "num_samples",
    "replacement",
    "generator",
    "out"
  ],
  "_convert_bounds_to_inequality_constraints": [
    "bounds"
  ],
  "find_interior_point": [
    "A",
    "b",
    "A_eq",
    "b_eq"
  ],
  "PolytopeSampler": {
    "__init__": [
      "self",
      "inequality_constraints",
      "equality_constraints",
      "bounds",
      "interior_point"
    ],
    "feasible": [
      "self",
      "x"
    ],
    "find_interior_point": [
      "self"
    ],
    "draw": [
      "self",
      "n"
    ]
  },
  "HitAndRunPolytopeSampler": {
    "__init__": [
      "self",
      "inequality_constraints",
      "equality_constraints",
      "bounds",
      "interior_point",
      "n_burnin",
      "n_thinning",
      "seed"
    ],
    "draw": [
      "self",
      "n"
    ]
  },
  "DelaunayPolytopeSampler": {
    "__init__": [
      "self",
      "inequality_constraints",
      "equality_constraints",
      "bounds",
      "interior_point"
    ],
    "draw": [
      "self",
      "n",
      "seed"
    ]
  },
  "normalize_sparse_linear_constraints": [
    "bounds",
    "constraints"
  ],
  "normalize_dense_linear_constraints": [
    "bounds",
    "constraints"
  ],
  "get_polytope_samples": [
    "n",
    "bounds",
    "inequality_constraints",
    "equality_constraints",
    "seed",
    "n_burnin",
    "n_thinning"
  ],
  "sparse_to_dense_constraints": [
    "d",
    "constraints"
  ],
  "optimize_posterior_samples": [
    "paths",
    "bounds",
    "raw_samples",
    "num_restarts",
    "sample_transform",
    "return_transformed"
  ],
  "boltzmann_sample": [
    "function_values",
    "num_samples",
    "eta",
    "replacement",
    "temp_decrease"
  ],
  "sample_truncated_normal_perturbations": [
    "X",
    "n_discrete_points",
    "sigma",
    "bounds",
    "qmc"
  ],
  "sample_perturbed_subset_dims": [
    "X",
    "bounds",
    "n_discrete_points",
    "sigma",
    "qmc",
    "prob_perturb"
  ],
  "get_feasible_samples": [
    "samples",
    "inequality_constraints"
  ],
  "get_outcome_feasibility_probability": [
    "model",
    "X",
    "outcome_constraints",
    "threshold",
    "nsample_outcome",
    "seed"
  ],
  "estimate_feasible_volume": [
    "bounds",
    "model",
    "outcome_constraints",
    "inequality_constraints",
    "nsample_feature",
    "nsample_outcome",
    "threshold",
    "verbose",
    "seed",
    "device",
    "dtype"
  ],
  "standardize": [
    "Y"
  ],
  "_update_constant_bounds": [
    "bounds"
  ],
  "normalize": [
    "X",
    "bounds",
    "update_constant_bounds"
  ],
  "unnormalize": [
    "X",
    "bounds",
    "update_constant_bounds"
  ],
  "normalize_indices": [
    "indices",
    "d"
  ],
  "_verify_output_shape": [
    "acqf",
    "X",
    "output"
  ],
  "is_fully_bayesian": [
    "model"
  ],
  "is_ensemble": [
    "model"
  ],
  "t_batch_mode_transform": [
    "expected_q",
    "assert_output_shape"
  ],
  "average_over_ensemble_models": [
    "method"
  ],
  "concatenate_pending_points": [
    "method"
  ],
  "match_batch_shape": [
    "X",
    "Y"
  ],
  "BotorchContainer": {
    "__post_init__": [
      "self",
      "validate_init"
    ],
    "__call__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "shape": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_validate": [
      "self"
    ]
  },
  "DenseContainer": {
    "__call__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "shape": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_validate": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "SliceContainer": {
    "__call__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "shape": [
      "self"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_validate": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "EMPTY_SIZE": [],
  "skip_if_import_error": [
    "func"
  ],
  "sample_random_feasible": [
    "f",
    "dtype",
    "device"
  ],
  "BotorchTestCase": {
    "device": [],
    "setUp": [
      "self",
      "suppress_input_warnings"
    ],
    "assertAllClose": [
      "self",
      "input",
      "other",
      "rtol",
      "atol",
      "equal_nan"
    ]
  },
  "BaseTestProblemTestCaseMixIn": {
    "test_forward_and_evaluate_true": [
      "self"
    ],
    "functions": [
      "self"
    ]
  },
  "SyntheticTestFunctionTestCaseMixin": {
    "test_optimal_value": [
      "self"
    ],
    "test_optimizer": [
      "self"
    ],
    "functions": [
      "self"
    ]
  },
  "MultiObjectiveTestProblemTestCaseMixin": {
    "test_attributes": [
      "self"
    ],
    "test_max_hv": [
      "self"
    ],
    "test_ref_point": [
      "self"
    ],
    "functions": [
      "self"
    ]
  },
  "ConstrainedTestProblemTestCaseMixin": {
    "test_num_constraints": [
      "self"
    ],
    "test_evaluate_slack": [
      "self"
    ],
    "test_worst_feasible_value": [
      "self"
    ],
    "functions": [
      "self"
    ]
  },
  "TestCorruptedProblemsMixin": {
    "setUp": [
      "self",
      "suppress_input_warnings"
    ]
  },
  "MockPosterior": {
    "__init__": [
      "self",
      "mean",
      "variance",
      "samples",
      "base_shape",
      "batch_range"
    ],
    "device": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "_extended_shape": [
      "self",
      "sample_shape"
    ],
    "base_sample_shape": [
      "self"
    ],
    "batch_range": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "rsample_from_base_samples": [
      "self",
      "sample_shape",
      "base_samples"
    ]
  },
  "get_sampler_mock": [
    "posterior",
    "sample_shape"
  ],
  "MockModel": {
    "__init__": [
      "self",
      "posterior"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "posterior_transform",
      "observation_noise"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ]
  },
  "MockAcquisitionFunction": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "X"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ]
  },
  "get_random_data": [
    "batch_shape",
    "m",
    "d",
    "n"
  ],
  "get_test_posterior": [
    "batch_shape",
    "q",
    "m",
    "interleaved",
    "lazy",
    "independent"
  ],
  "get_max_violation_of_bounds": [
    "samples",
    "bounds"
  ],
  "get_max_violation_of_constraints": [
    "samples",
    "constraints",
    "equality"
  ],
  "get_objective_weights_transform": [
    "weights"
  ],
  "apply_constraints_nonnegative_soft": [
    "obj",
    "constraints",
    "samples",
    "eta"
  ],
  "compute_feasibility_indicator": [
    "constraints",
    "samples",
    "marginalize_dim"
  ],
  "compute_smoothed_feasibility_indicator": [
    "constraints",
    "samples",
    "eta",
    "log",
    "fat"
  ],
  "apply_constraints": [
    "obj",
    "constraints",
    "samples",
    "infeasible_cost",
    "eta"
  ],
  "SupervisedDataset": {
    "__init__": [
      "self",
      "X",
      "Y"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "Yvar": [
      "self"
    ],
    "_validate": [
      "self",
      "validate_feature_names",
      "validate_outcome_names",
      "validate_group_indices"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "clone": [
      "self",
      "deepcopy",
      "mask"
    ]
  },
  "RankingDataset": {
    "__init__": [
      "self",
      "X",
      "Y",
      "feature_names",
      "outcome_names",
      "validate_init"
    ],
    "_validate": [
      "self"
    ]
  },
  "MultiTaskDataset": {
    "__init__": [
      "self",
      "datasets",
      "target_outcome_name",
      "task_feature_index"
    ],
    "from_joint_dataset": [
      "cls",
      "dataset",
      "task_feature_index",
      "target_task_value",
      "outcome_names_per_task"
    ],
    "_validate_datasets": [
      "self",
      "datasets"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "Yvar": [
      "self"
    ],
    "get_dataset_without_task_feature": [
      "self",
      "outcome_name"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "clone": [
      "self",
      "deepcopy",
      "mask"
    ]
  },
  "ContextualDataset": {
    "__init__": [
      "self",
      "datasets",
      "parameter_decomposition",
      "metric_decomposition"
    ],
    "feature_names": [
      "self"
    ],
    "outcome_names": [
      "self"
    ],
    "X": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "Yvar": [
      "self"
    ],
    "_extract_context_buckets": [
      "self"
    ],
    "_validate_datasets": [
      "self"
    ],
    "_validate_decompositions": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "clone": [
      "self",
      "deepcopy",
      "mask"
    ]
  },
  "_DefaultType": {},
  "DEFAULT": [],
  "TensorCheckpoint": {},
  "delattr_ctx": [
    "instance"
  ],
  "parameter_rollback_ctx": [
    "parameters",
    "checkpoint"
  ],
  "module_rollback_ctx": [
    "module",
    "name_filter",
    "checkpoint"
  ],
  "zero_grad_ctx": [
    "parameters",
    "zero_on_enter",
    "zero_on_exit"
  ],
  "separate_mtmvn": [
    "mvn"
  ],
  "get_outcome_constraint_transforms": [
    "outcome_constraints"
  ],
  "get_monotonicity_constraints": [
    "d",
    "descending",
    "dtype",
    "device"
  ],
  "NonTransformedInterval": {
    "__init__": [
      "self",
      "lower_bound",
      "upper_bound",
      "initial_value"
    ],
    "transform": [
      "self",
      "tensor"
    ],
    "inverse_transform": [
      "self",
      "transformed_tensor"
    ]
  },
  "LogTransformedInterval": {
    "__init__": [
      "self",
      "lower_bound",
      "upper_bound",
      "initial_value"
    ],
    "transform": [
      "self",
      "tensor"
    ],
    "inverse_transform": [
      "self",
      "transformed_tensor"
    ]
  },
  "get_constants": [
    "values",
    "device",
    "dtype"
  ],
  "get_constants_like": [
    "values",
    "ref"
  ],
  "type_bypassing_encoder": [
    "arg"
  ],
  "Dispatcher": {
    "__init__": [
      "self",
      "name",
      "doc",
      "encoder"
    ],
    "__getitem__": [
      "self",
      "args",
      "types"
    ],
    "__call__": [
      "self"
    ],
    "dispatch": [
      "self"
    ],
    "encode_args": [
      "self",
      "args"
    ],
    "_help": [
      "self"
    ],
    "help": [
      "self"
    ],
    "_source": [
      "self"
    ],
    "source": [
      "self"
    ],
    "encoder": [
      "self"
    ]
  },
  "get_model": [
    "train_X",
    "train_Y",
    "standardize_model",
    "use_model_list"
  ],
  "get_fully_bayesian_model": [
    "train_X",
    "train_Y",
    "num_models",
    "standardize_model",
    "infer_noise"
  ],
  "_get_mcmc_samples": [
    "num_samples",
    "dim",
    "infer_noise"
  ],
  "get_fully_bayesian_model_list": [
    "train_X",
    "train_Y",
    "num_models",
    "standardize_model",
    "infer_noise"
  ],
  "get_sample_moments": [
    "samples",
    "sample_shape"
  ],
  "standardize_moments": [
    "transform",
    "loc",
    "covariance_matrix"
  ],
  "gen_multi_task_dataset": [
    "yvar",
    "task_values",
    "skip_task_features_in_datasets"
  ],
  "get_pvar_expected": [
    "posterior",
    "model",
    "X",
    "m"
  ],
  "DummyNonScalarizingPosteriorTransform": {
    "scalarize": [],
    "evaluate": [
      "self",
      "Y"
    ],
    "forward": [
      "self",
      "posterior"
    ]
  },
  "SimpleGPyTorchModel": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "outcome_transform",
      "input_transform"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CaseNd": [],
  "_log_2": [],
  "_sqrt_pi": [],
  "_inv_sqrt_pi": [],
  "_inv_sqrt_2pi": [],
  "_inv_sqrt_2": [],
  "_neg_inv_sqrt_2": [],
  "_log_sqrt_2pi": [],
  "_log_two_inv_sqrt_2pi": [],
  "case_dispatcher": [
    "out",
    "cases",
    "default"
  ],
  "gen_positional_indices": [
    "shape",
    "dim",
    "device"
  ],
  "build_positional_indices": [
    "shape",
    "dim",
    "device"
  ],
  "leggauss": [
    "deg"
  ],
  "ndtr": [
    "x"
  ],
  "phi": [
    "x"
  ],
  "log_phi": [
    "x"
  ],
  "log_ndtr": [
    "x"
  ],
  "log_erfc": [
    "x"
  ],
  "log_erfcx": [
    "x"
  ],
  "standard_normal_log_hazard": [
    "x"
  ],
  "log_prob_normal_in": [
    "a",
    "b"
  ],
  "swap_along_dim_": [
    "values",
    "i",
    "j",
    "dim",
    "buffer"
  ],
  "compute_log_prob_feas_from_bounds": [
    "con_lower_inds",
    "con_upper_inds",
    "con_both_inds",
    "con_lower",
    "con_upper",
    "con_both",
    "means",
    "sigmas"
  ],
  "percentile_of_score": [
    "data",
    "score",
    "dim"
  ],
  "_inf": [],
  "_2pi": [],
  "_sqrt_2pi": [],
  "_inv_2pi": [],
  "bvn": [
    "r",
    "xl",
    "yl",
    "xu",
    "yu"
  ],
  "bvnu": [
    "r",
    "h",
    "k"
  ],
  "_bvnu_polar": [
    "r",
    "h",
    "k",
    "num_points"
  ],
  "_bvnu_taylor": [
    "r",
    "h",
    "k",
    "num_points"
  ],
  "bvnmom": [
    "r",
    "xl",
    "yl",
    "xu",
    "yu",
    "p"
  ],
  "mvnxpbState": {},
  "MVNXPB": {
    "__init__": [
      "self",
      "covariance_matrix",
      "bounds"
    ],
    "build": [
      "cls",
      "step",
      "perm",
      "bounds",
      "piv_chol",
      "plug_ins",
      "log_prob",
      "log_prob_extra"
    ],
    "solve": [
      "self",
      "num_steps",
      "eps"
    ],
    "select_pivot": [
      "self"
    ],
    "pivot_": [
      "self",
      "pivot"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "concat": [
      "self",
      "other",
      "dim"
    ],
    "expand": [
      "self"
    ],
    "augment": [
      "self",
      "covariance_matrix",
      "bounds",
      "cross_covariance_matrix",
      "disable_pivoting",
      "jitter",
      "max_tries"
    ],
    "detach": [
      "self"
    ],
    "clone": [
      "self"
    ],
    "asdict": [
      "self"
    ]
  },
  "TruncatedMultivariateNormal": {
    "__init__": [
      "self",
      "loc",
      "covariance_matrix",
      "precision_matrix",
      "scale_tril",
      "bounds",
      "solver",
      "sampler",
      "validate_args"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "log_partition": [
      "self"
    ],
    "solver": [
      "self"
    ],
    "sampler": [
      "self"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ],
    "__repr__": [
      "self"
    ]
  },
  "block_matrix_concat": [
    "blocks"
  ],
  "augment_cholesky": [
    "Laa",
    "Kbb",
    "Kba",
    "Lba",
    "jitter"
  ],
  "PivotedCholesky": {
    "__post_init__": [
      "self",
      "validate_init"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "update_": [
      "self",
      "eps"
    ],
    "pivot_": [
      "self",
      "pivot"
    ],
    "expand": [
      "self"
    ],
    "concat": [
      "self",
      "other",
      "dim"
    ],
    "detach": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "_twopi": [],
  "LinearEllipticalSliceSampler": {
    "__init__": [
      "self",
      "inequality_constraints",
      "bounds",
      "interior_point",
      "fixed_indices",
      "mean",
      "covariance_matrix",
      "covariance_root",
      "check_feasibility",
      "burnin",
      "thinning",
      "num_chains"
    ],
    "_fixed_features_initialization": [
      "self",
      "A",
      "b",
      "interior_point",
      "fixed_indices",
      "mean",
      "covariance_matrix",
      "covariance_root"
    ],
    "_standardization_initialization": [
      "self"
    ],
    "lifetime_samples": [
      "self"
    ],
    "draw": [
      "self",
      "n"
    ],
    "step": [
      "self"
    ],
    "_draw_angle": [
      "self",
      "nu"
    ],
    "_get_cart_coords": [
      "self",
      "nu",
      "theta"
    ],
    "_trim_intervals": [
      "self",
      "left",
      "right"
    ],
    "_find_active_intersection_angles": [
      "self",
      "nu"
    ],
    "_find_intersection_angles": [
      "self",
      "nu"
    ],
    "_is_feasible": [
      "self",
      "points",
      "transformed"
    ],
    "_transform": [
      "self",
      "x"
    ],
    "_untransform": [
      "self",
      "z"
    ],
    "_standardize": [
      "self",
      "x"
    ],
    "_unstandardize": [
      "self",
      "z"
    ]
  },
  "get_index_tensors": [
    "fixed_indices",
    "d"
  ],
  "UnifiedSkewNormal": {
    "arg_constraints": [],
    "__init__": [
      "self",
      "trunc",
      "gauss",
      "cross_covariance_matrix",
      "validate_args"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "_log_prob": [
      "self",
      "value"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ],
    "__repr__": [
      "self"
    ],
    "covariance_matrix": [
      "self"
    ],
    "scale_tril": [
      "self"
    ],
    "_orthogonalized_gauss": [
      "self"
    ],
    "_iLyy_Kyx": [
      "self"
    ],
    "_iKyy_Kyx": [
      "self"
    ],
    "_iLxx_Kxy": [
      "self"
    ],
    "_iKxx_Kxy": [
      "self"
    ],
    "_K_schur_Kyy": [
      "self"
    ]
  },
  "MIN_Y_RANGE": [],
  "infer_reference_point": [
    "pareto_Y",
    "max_ref_point",
    "scale",
    "scale_max_ref_point"
  ],
  "Hypervolume": {
    "__init__": [
      "self",
      "ref_point"
    ],
    "ref_point": [
      "self",
      "ref_point"
    ],
    "compute": [
      "self",
      "pareto_Y"
    ],
    "_hv_recursive": [
      "self",
      "i",
      "n_pareto",
      "bounds"
    ],
    "_initialize_multilist": [
      "self",
      "pareto_Y"
    ]
  },
  "sort_by_dimension": [
    "nodes",
    "i"
  ],
  "Node": {
    "__init__": [
      "self",
      "m",
      "dtype",
      "device",
      "data"
    ]
  },
  "MultiList": {
    "__init__": [
      "self",
      "m",
      "dtype",
      "device"
    ],
    "append": [
      "self",
      "node",
      "index"
    ],
    "extend": [
      "self",
      "nodes",
      "index"
    ],
    "remove": [
      "self",
      "node",
      "index",
      "bounds"
    ],
    "reinsert": [
      "self",
      "node",
      "index",
      "bounds"
    ]
  },
  "SubsetIndexCachingMixin": {
    "__init__": [
      "self"
    ],
    "compute_q_subset_indices": [
      "self",
      "q_out",
      "device"
    ]
  },
  "compute_subset_indices": [
    "q",
    "device"
  ],
  "NoisyExpectedHypervolumeMixin": {
    "__init__": [
      "self",
      "model",
      "ref_point",
      "X_baseline",
      "sampler",
      "objective",
      "constraints",
      "X_pending",
      "prune_baseline",
      "alpha",
      "cache_pending",
      "max_iep",
      "incremental_nehvi",
      "cache_root",
      "marginalize_dim"
    ],
    "X_baseline": [
      "self"
    ],
    "_compute_initial_hvs": [
      "self",
      "obj",
      "feas"
    ],
    "_set_cell_bounds": [
      "self",
      "num_new_points"
    ],
    "set_X_pending": [
      "self",
      "X_pending"
    ],
    "_hypervolumes": [
      "self"
    ],
    "_compute_posterior_samples_and_concat_pending": [
      "self",
      "X"
    ]
  },
  "get_hypervolume_maximizing_subset": [
    "n",
    "Y",
    "ref_point"
  ],
  "get_chebyshev_scalarization": [
    "weights",
    "Y",
    "alpha"
  ],
  "MAX_BYTES": [],
  "is_non_dominated": [
    "Y",
    "maximize",
    "deduplicate"
  ],
  "_is_non_dominated_loop": [
    "Y",
    "maximize",
    "deduplicate"
  ],
  "_expand_ref_point": [
    "ref_point",
    "batch_shape"
  ],
  "_pad_batch_pareto_frontier": [
    "Y",
    "ref_point",
    "is_pareto",
    "feasibility_mask"
  ],
  "compute_local_upper_bounds": [
    "U",
    "Z",
    "z"
  ],
  "get_partition_bounds": [
    "Z",
    "U",
    "ref_point"
  ],
  "update_local_upper_bounds_incremental": [
    "new_pareto_Y",
    "U",
    "Z"
  ],
  "compute_non_dominated_hypercell_bounds_2d": [
    "pareto_Y_sorted",
    "ref_point"
  ],
  "compute_dominated_hypercell_bounds_2d": [
    "pareto_Y_sorted",
    "ref_point"
  ],
  "BoxDecomposition": {
    "__init__": [
      "self",
      "ref_point",
      "sort",
      "Y"
    ],
    "pareto_Y": [
      "self"
    ],
    "ref_point": [
      "self"
    ],
    "Y": [
      "self"
    ],
    "_compute_pareto_Y": [
      "self"
    ],
    "_reset_pareto_Y": [
      "self"
    ],
    "partition_space": [
      "self"
    ],
    "_partition_space_2d": [
      "self"
    ],
    "_partition_space": [
      "self"
    ],
    "get_hypercell_bounds": [
      "self"
    ],
    "_update_neg_Y": [
      "self",
      "Y"
    ],
    "update": [
      "self",
      "Y"
    ],
    "_validate_inputs": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "_compute_hypervolume_if_y_has_data": [
      "self"
    ],
    "compute_hypervolume": [
      "self"
    ]
  },
  "FastPartitioning": {
    "__init__": [
      "self",
      "ref_point",
      "Y"
    ],
    "update": [
      "self",
      "Y"
    ],
    "_get_single_cell": [
      "self"
    ],
    "partition_space": [
      "self"
    ],
    "_partition_space": [
      "self"
    ],
    "_get_partitioning": [
      "self"
    ],
    "get_hypercell_bounds": [
      "self"
    ]
  },
  "DominatedPartitioning": {
    "_partition_space_2d": [
      "self"
    ],
    "_get_partitioning": [
      "self"
    ],
    "_compute_hypervolume_if_y_has_data": [
      "self"
    ],
    "_get_single_cell": [
      "self"
    ]
  },
  "NondominatedPartitioning": {
    "__init__": [
      "self",
      "ref_point",
      "Y",
      "alpha"
    ],
    "_partition_space": [
      "self"
    ],
    "_partition_space_2d": [
      "self"
    ],
    "_get_augmented_pareto_front_indices": [
      "self"
    ],
    "get_hypercell_bounds": [
      "self"
    ],
    "_get_hypercell_bounds": [
      "self",
      "aug_pareto_Y"
    ],
    "_compute_hypervolume_if_y_has_data": [
      "self"
    ]
  },
  "FastNondominatedPartitioning": {
    "__init__": [
      "self",
      "ref_point",
      "Y"
    ],
    "_get_single_cell": [
      "self"
    ],
    "_get_partitioning": [
      "self"
    ],
    "_partition_space_2d": [
      "self"
    ],
    "_compute_hypervolume_if_y_has_data": [
      "self"
    ]
  },
  "BoxDecompositionList": {
    "__init__": [
      "self"
    ],
    "pareto_Y": [
      "self"
    ],
    "ref_point": [
      "self"
    ],
    "get_hypercell_bounds": [
      "self"
    ],
    "update": [
      "self",
      "Y"
    ],
    "compute_hypervolume": [
      "self"
    ]
  },
  "SyntheticTestFunction": {
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "optimal_value": [
      "self"
    ]
  },
  "Ackley": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Beale": {
    "dim": [],
    "continuous_inds": [],
    "_optimal_value": [],
    "_bounds": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Branin": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Bukin": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Cosine8": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_is_minimization_by_default": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DropWave": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_check_grad_at_opt": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DixonPrice": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "EggHolder": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Griewank": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Hartmann": {
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "optimizers": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "HolderTable": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Levy": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Michalewicz": {
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "optimizers": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Powell": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Rastrigin": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Rosenbrock": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Shekel": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimizers": [],
    "__init__": [
      "self",
      "m",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "SixHumpCamel": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "StyblinskiTang": {
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "ThreeHumpCamel": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "AckleyMixed": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "randomize_optimum",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Labs": {
    "_check_grad_at_opt": [],
    "_is_minimization_by_default": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_optimizer_from_binary_seq": [
      "self",
      "seq"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "ConstrainedSyntheticTestFunction": {
    "__init__": [
      "self",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_validate_constraint_noise": [
      "self",
      "constraint_noise_std"
    ]
  },
  "ConstrainedGramacy": {
    "num_objectives": [],
    "num_constraints": [],
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimizers": [],
    "_optimal_value": [],
    "_worst_feasible_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "ConstrainedHartmann": {
    "num_constraints": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "ConstrainedHartmannSmooth": {
    "num_constraints": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "PressureVessel": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "_bounds": [],
    "_optimal_value": [],
    "_worst_feasible_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "WeldedBeamSO": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "_bounds": [],
    "_optimal_value": [],
    "_worst_feasible_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "TensionCompressionString": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "_bounds": [],
    "_optimal_value": [],
    "_worst_feasible_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "SpeedReducer": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "_bounds": [],
    "_optimal_value": [],
    "_worst_feasible_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "KeaneBumpFunction": {
    "num_constraints": [],
    "_optimal_value_lookup": [],
    "_worst_feasible_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "bounds",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "validate_parameter_indices": [
    "dim",
    "bounds",
    "continuous_inds",
    "discrete_inds",
    "categorical_inds"
  ],
  "validate_inputs": [
    "X",
    "dim",
    "bounds",
    "discrete_inds",
    "categorical_inds"
  ],
  "BaseTestProblem": {
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "dtype"
    ],
    "forward": [
      "self",
      "X",
      "noise"
    ],
    "evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "is_minimization_problem": [
      "self"
    ]
  },
  "ConstrainedBaseTestProblem": {
    "evaluate_slack": [
      "self",
      "X",
      "noise"
    ],
    "is_feasible": [
      "self",
      "X",
      "noise"
    ],
    "evaluate_slack_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ],
    "worst_feasible_value": [
      "self"
    ]
  },
  "MultiObjectiveTestProblem": {
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "dtype"
    ],
    "max_hv": [
      "self"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ],
    "is_minimization_problem": [
      "self"
    ]
  },
  "SeedingMixin": {
    "has_seeds": [
      "self"
    ],
    "increment_seed": [
      "self"
    ],
    "seed": [
      "self"
    ]
  },
  "OutlierGenerator": {
    "__call__": [
      "self",
      "problem",
      "X",
      "bounds"
    ]
  },
  "constant_outlier_generator": [
    "problem",
    "X",
    "bounds",
    "constant"
  ],
  "CorruptedTestProblem": {
    "__init__": [
      "self",
      "base_test_problem",
      "outlier_generator",
      "outlier_fraction",
      "bounds",
      "seeds"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X",
      "noise"
    ]
  },
  "round_nearest": [
    "X",
    "increment",
    "bounds"
  ],
  "BraninCurrin": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "_max_hv": [],
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_rescaled_branin": [
      "self",
      "X"
    ],
    "_currin": [
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DH": {
    "num_objectives": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_h": [
      "self",
      "X"
    ],
    "_g": [
      "self",
      "X"
    ],
    "_S": [
      "self",
      "X"
    ]
  },
  "DH1": {
    "alpha": [],
    "beta": [],
    "_x_1_lb": [],
    "_area_under_curve": [],
    "_min_dim": [],
    "_h": [
      "self",
      "X"
    ],
    "_g": [
      "self",
      "X"
    ],
    "_S": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DH2": {
    "beta": []
  },
  "DH3": {
    "_x_1_lb": [],
    "_area_under_curve": [],
    "_min_dim": [],
    "_exp_args": [
      "x"
    ],
    "_h": [
      "self",
      "X"
    ],
    "_g": [
      "self",
      "X"
    ],
    "_S": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DH4": {
    "_x_1_lb": [],
    "_area_under_curve": [],
    "_h": [
      "self",
      "X"
    ]
  },
  "DTLZ": {
    "__init__": [
      "self",
      "dim",
      "num_objectives",
      "noise_std",
      "negate",
      "dtype"
    ]
  },
  "DTLZ1": {
    "_ref_val": [],
    "_max_hv": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ]
  },
  "DTLZ2": {
    "_ref_val": [],
    "_max_hv": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ]
  },
  "DTLZ3": {
    "_ref_val": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DTLZ4": {
    "_alpha": []
  },
  "DTLZ5": {
    "_ref_val": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "DTLZ7": {
    "_ref_val": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "GMM": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "num_objectives",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Penicillin": {
    "_max_hv": [],
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "Y_xs": [],
    "Y_ps": [],
    "K_1": [],
    "K_2": [],
    "m_X": [],
    "alpha_1": [],
    "alpha_2": [],
    "alpha_3": [],
    "mu_X": [],
    "K_X": [],
    "mu_p": [],
    "K_p": [],
    "K_I": [],
    "K": [],
    "k_g": [],
    "E_g": [],
    "k_d": [],
    "E_d": [],
    "lambd": [],
    "T_v": [],
    "T_o": [],
    "R": [],
    "V_max": [],
    "penicillin_vectorized": [
      "cls",
      "X_input"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "ToyRobust": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_ref_point": [],
    "num_objectives": [],
    "levy": [],
    "forward": [
      "self",
      "X",
      "noise"
    ],
    "f_1": [
      "self",
      "X"
    ],
    "f_2": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "VehicleSafety": {
    "_ref_point": [],
    "_max_hv": [],
    "_bounds": [],
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "ZDT": {
    "_ref_point": [],
    "__init__": [
      "self",
      "dim",
      "num_objectives",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_g": [
      "X"
    ]
  },
  "ZDT1": {
    "_max_hv": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ]
  },
  "ZDT2": {
    "_max_hv": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ]
  },
  "ZDT3": {
    "_max_hv": [],
    "_parts": [],
    "_eps": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "gen_pareto_front": [
      "self",
      "n"
    ]
  },
  "CarSideImpact": {
    "continuous_inds": [],
    "_bounds": [],
    "_ref_point": [],
    "_max_hv": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "BNH": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "num_constraints": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "CONSTR": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "num_constraints": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "ConstrainedBraninCurrin": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "num_constraints": [],
    "_bounds": [],
    "_con_bounds": [],
    "_ref_point": [],
    "_max_hv": [],
    "__init__": [
      "self",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "dtype"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "C2DTLZ2": {
    "num_constraints": [],
    "_r": [],
    "_max_hv": [],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "DiscBrake": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "num_constraints": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "MW7": {
    "num_constraints": [],
    "num_objectives": [],
    "_ref_point": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "constraint_noise_std",
      "negate",
      "dtype"
    ],
    "LA2": [
      "self",
      "A",
      "B",
      "C",
      "D",
      "theta"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "OSY": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "SRN": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "num_constraints": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "WeldedBeam": {
    "dim": [],
    "continuous_inds": [],
    "num_constraints": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "_evaluate_slack_true": [
      "self",
      "X"
    ]
  },
  "Ishigami": {
    "__init__": [
      "self",
      "b",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_optimal_value": [
      "self"
    ],
    "compute_dgsm": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Gsobol": {
    "__init__": [
      "self",
      "dim",
      "a",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_optimal_value": [
      "self"
    ],
    "optimal_sobol_indicies": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "Morris": {
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_optimal_value": [
      "self"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "MOMFBraninCurrin": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "_max_hv": [],
    "_branin": [
      "self",
      "X"
    ],
    "_currin": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "MOMFPark": {
    "dim": [],
    "continuous_inds": [],
    "num_objectives": [],
    "_bounds": [],
    "_ref_point": [],
    "_max_hv": [],
    "_transform": [
      "self",
      "X"
    ],
    "_park1": [
      "self",
      "X"
    ],
    "_park2": [
      "self",
      "X"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "AugmentedBranin": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "AugmentedHartmann": {
    "dim": [],
    "continuous_inds": [],
    "_bounds": [],
    "_optimal_value": [],
    "_optimizers": [],
    "_check_grad_at_opt": [],
    "__init__": [
      "self",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "AugmentedRosenbrock": {
    "_optimal_value": [],
    "__init__": [
      "self",
      "dim",
      "noise_std",
      "negate",
      "dtype"
    ],
    "_evaluate_true": [
      "self",
      "X"
    ]
  },
  "WingWeightMultiFidelity": {
    "dim": [],
    "continuous_inds": [],
    "_num_fidelities": [],
    "_bounds": [],
    "fidelities": [],
    "_optimal_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "cost": [
      "self",
      "X"
    ]
  },
  "BoreholeMultiFidelity": {
    "dim": [],
    "continuous_inds": [],
    "_num_fidelities": [],
    "_bounds": [],
    "fidelities": [],
    "_optimal_value": [],
    "_evaluate_true": [
      "self",
      "X"
    ],
    "cost": [
      "self",
      "X"
    ]
  },
  "BotorchError": {},
  "CandidateGenerationError": {},
  "DeprecationError": {},
  "InputDataError": {},
  "UnsupportedError": {},
  "BotorchTensorDimensionError": {},
  "ModelFittingError": {},
  "OptimizationTimeoutError": {
    "__init__": []
  },
  "OptimizationGradientError": {
    "__init__": []
  },
  "InfeasibilityError": {},
  "BotorchWarning": {},
  "BadInitialCandidatesWarning": {},
  "InputDataWarning": {},
  "CostAwareWarning": {},
  "OptimizationWarning": {},
  "SamplingWarning": {},
  "BotorchTensorDimensionWarning": {},
  "UserInputWarning": {},
  "NumericsWarning": {},
  "legacy_ei_numerics_warning": [
    "legacy_name"
  ],
  "_get_single_precision_warning": [
    "dtype_str"
  ],
  "FixedHomotopySchedule": {
    "__init__": [
      "self",
      "values"
    ],
    "num_steps": [
      "self"
    ],
    "value": [
      "self"
    ],
    "should_stop": [
      "self"
    ],
    "restart": [
      "self"
    ],
    "step": [
      "self"
    ]
  },
  "LinearHomotopySchedule": {
    "__init__": [
      "self",
      "start",
      "end",
      "num_steps"
    ]
  },
  "LogLinearHomotopySchedule": {
    "__init__": [
      "self",
      "start",
      "end",
      "num_steps"
    ]
  },
  "HomotopyParameter": {},
  "Homotopy": {
    "__init__": [
      "self",
      "homotopy_parameters",
      "callbacks"
    ],
    "_execute_callbacks": [
      "self"
    ],
    "should_stop": [
      "self"
    ],
    "restart": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "step": [
      "self"
    ]
  },
  "status_messages": [],
  "task_messages": [],
  "uses_c_implementation": [],
  "OptimState": {
    "__init__": [
      "self",
      "bounds",
      "maxls",
      "x0",
      "n",
      "m"
    ]
  },
  "fmin_l_bfgs_b_batched": [
    "func",
    "x0",
    "bounds",
    "maxcor",
    "factr",
    "ftol",
    "pgtol",
    "tol",
    "maxiter",
    "disp",
    "callback",
    "maxls",
    "pass_batch_indices"
  ],
  "_minimize_lbfgsb": [
    "fun",
    "x0",
    "bounds",
    "maxcor",
    "ftol",
    "gtol",
    "maxiter",
    "callback",
    "maxls",
    "pass_batch_indices"
  ],
  "translate_bounds_for_lbfgsb": [
    "lower_bounds",
    "upper_bounds",
    "num_features",
    "q"
  ],
  "_LBFGSB_MAXITER_MAXFUN_REGEX": [],
  "OptimizationStatus": {
    "RUNNING": [],
    "SUCCESS": [],
    "FAILURE": [],
    "STOPPED": []
  },
  "OptimizationResult": {},
  "scipy_minimize": [
    "closure",
    "parameters",
    "bounds",
    "callback",
    "x0",
    "method",
    "options",
    "timeout_sec"
  ],
  "torch_minimize": [
    "closure",
    "parameters",
    "bounds",
    "callback",
    "optimizer",
    "scheduler",
    "step_limit",
    "timeout_sec",
    "stopping_criterion"
  ],
  "TGenInitialConditions": [],
  "transform_constraints": [
    "constraints",
    "q",
    "d"
  ],
  "transform_intra_point_constraint": [
    "constraint",
    "d",
    "q"
  ],
  "transform_inter_point_constraint": [
    "constraint",
    "d"
  ],
  "sample_q_batches_from_polytope": [
    "n",
    "q",
    "bounds",
    "n_burnin",
    "n_thinning",
    "seed",
    "inequality_constraints",
    "equality_constraints"
  ],
  "gen_batch_initial_conditions": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "raw_samples",
    "fixed_features",
    "options",
    "inequality_constraints",
    "equality_constraints",
    "generator",
    "fixed_X_fantasies"
  ],
  "gen_one_shot_kg_initial_conditions": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "raw_samples",
    "fixed_features",
    "options",
    "inequality_constraints",
    "equality_constraints"
  ],
  "gen_one_shot_hvkg_initial_conditions": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "raw_samples",
    "fixed_features",
    "options",
    "inequality_constraints",
    "equality_constraints"
  ],
  "gen_value_function_initial_conditions": [
    "acq_function",
    "bounds",
    "num_restarts",
    "raw_samples",
    "current_model",
    "fixed_features",
    "options"
  ],
  "initialize_q_batch": [
    "X",
    "acq_vals",
    "n",
    "eta"
  ],
  "initialize_q_batch_nonneg": [
    "X",
    "acq_vals",
    "n",
    "eta",
    "alpha"
  ],
  "initialize_q_batch_topn": [
    "X",
    "acq_vals",
    "n",
    "largest",
    "sorted"
  ],
  "sample_points_around_best": [
    "acq_function",
    "n_discrete_points",
    "sigma",
    "bounds",
    "best_pct",
    "subset_sigma",
    "prob_perturb"
  ],
  "is_nonnegative": [
    "acq_function"
  ],
  "ScipyConstraintDict": [],
  "get_constraint_tolerance": [
    "dtype"
  ],
  "make_scipy_bounds": [
    "X",
    "lower_bounds",
    "upper_bounds"
  ],
  "make_scipy_linear_constraints": [
    "shapeX",
    "inequality_constraints",
    "equality_constraints"
  ],
  "eval_lin_constraint": [
    "x",
    "flat_idxr",
    "coeffs",
    "rhs"
  ],
  "lin_constraint_jac": [
    "x",
    "flat_idxr",
    "coeffs",
    "n"
  ],
  "_arrayify": [
    "X"
  ],
  "_validate_linear_constraints_shape_input": [
    "shapeX"
  ],
  "_validate_linear_constraints_indices_input": [
    "indices",
    "q",
    "d"
  ],
  "_make_linear_constraints": [
    "indices",
    "coefficients",
    "rhs",
    "shapeX",
    "eq"
  ],
  "_make_nonlinear_constraints": [
    "f_np_wrapper",
    "nlc",
    "is_intrapoint",
    "shapeX"
  ],
  "_generate_unfixed_nonlin_constraints": [
    "constraints",
    "fixed_features",
    "dimension"
  ],
  "_generate_unfixed_lin_constraints": [
    "constraints",
    "fixed_features",
    "dimension",
    "eq"
  ],
  "_make_f_and_grad_nonlinear_inequality_constraints": [
    "f_np_wrapper",
    "nlc"
  ],
  "nonlinear_constraint_is_feasible": [
    "nonlinear_inequality_constraint",
    "is_intrapoint",
    "x",
    "tolerance"
  ],
  "make_scipy_nonlinear_inequality_constraints": [
    "nonlinear_inequality_constraints",
    "f_np_wrapper",
    "x0",
    "shapeX"
  ],
  "evaluate_feasibility": [
    "X",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "tolerance"
  ],
  "project_to_feasible_space_via_slsqp": [
    "X",
    "bounds",
    "inequality_constraints",
    "equality_constraints"
  ],
  "StoppingCriterion": {
    "__call__": [
      "self",
      "fvals"
    ],
    "reset": [
      "self"
    ]
  },
  "ExpMAStoppingCriterion": {
    "__init__": [
      "self",
      "maxiter",
      "minimize",
      "n_window",
      "eta",
      "rel_tol"
    ],
    "__call__": [
      "self",
      "fvals"
    ],
    "reset": [
      "self"
    ]
  },
  "TBoundsDict": [],
  "TScipyObjective": [],
  "TModToArray": [],
  "TArrayToMod": [],
  "fit_gpytorch_mll_scipy": [
    "mll",
    "parameters",
    "bounds",
    "closure",
    "closure_kwargs",
    "method",
    "options",
    "callback",
    "timeout_sec"
  ],
  "fit_gpytorch_mll_torch": [
    "mll",
    "parameters",
    "bounds",
    "closure",
    "closure_kwargs",
    "step_limit",
    "stopping_criterion",
    "optimizer",
    "scheduler",
    "callback",
    "timeout_sec"
  ],
  "prune_candidates": [
    "candidates",
    "acq_values",
    "prune_tolerance"
  ],
  "optimize_acqf_homotopy": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "homotopy",
    "prune_tolerance",
    "raw_samples",
    "options",
    "final_options",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "fixed_features",
    "fixed_features_list",
    "post_processing_func",
    "batch_initial_conditions",
    "gen_candidates"
  ],
  "STD_CONT_PERTURBATION": [],
  "RAW_SAMPLES": [],
  "NUM_RESTARTS": [],
  "MAX_BATCH_SIZE": [],
  "MAX_ITER_ALTER": [],
  "MAX_ITER_DISCRETE": [],
  "MAX_ITER_CONT": [],
  "MAX_DISCRETE_VALUES": [],
  "MAX_ITER_INIT": [],
  "CONVERGENCE_TOL": [],
  "DUPLICATE_TOL": [],
  "STOP_AFTER_SHARE_CONVERGED": [],
  "SUPPORTED_OPTIONS": [],
  "SUPPORTED_INITIALIZATION": [],
  "_setup_continuous_relaxation": [
    "discrete_dims",
    "max_discrete_values",
    "post_processing_func"
  ],
  "_filter_infeasible": [
    "X",
    "inequality_constraints",
    "equality_constraints"
  ],
  "get_nearest_neighbors": [
    "current_x",
    "bounds",
    "discrete_dims"
  ],
  "get_categorical_neighbors": [
    "current_x",
    "cat_dims",
    "max_num_cat_values"
  ],
  "get_spray_points": [
    "X_baseline",
    "cont_dims",
    "discrete_dims",
    "cat_dims",
    "bounds",
    "num_spray_points",
    "std_cont_perturbation"
  ],
  "sample_feasible_points": [
    "opt_inputs",
    "discrete_dims",
    "cat_dims",
    "num_points"
  ],
  "round_discrete_dims": [
    "X",
    "discrete_dims"
  ],
  "generate_starting_points": [
    "opt_inputs",
    "discrete_dims",
    "cat_dims",
    "cont_dims"
  ],
  "discrete_step": [
    "opt_inputs",
    "discrete_dims",
    "cat_dims",
    "current_x"
  ],
  "continuous_step": [
    "opt_inputs",
    "discrete_dims",
    "cat_dims",
    "current_x"
  ],
  "optimize_acqf_mixed_alternating": [
    "acq_function",
    "bounds",
    "discrete_dims",
    "cat_dims",
    "options",
    "q",
    "raw_samples",
    "num_restarts",
    "post_processing_func",
    "sequential",
    "fixed_features",
    "inequality_constraints",
    "equality_constraints"
  ],
  "complement_indices_like": [
    "indices",
    "d"
  ],
  "complement_indices": [
    "indices",
    "d"
  ],
  "INIT_OPTION_KEYS": [],
  "OptimizeAcqfInputs": {
    "full_tree": [
      "self"
    ],
    "__post_init__": [
      "self"
    ],
    "get_ic_generator": [
      "self"
    ]
  },
  "_optimize_acqf_all_features_fixed": [],
  "_validate_sequential_inputs": [
    "opt_inputs"
  ],
  "_optimize_acqf_sequential_q": [
    "opt_inputs"
  ],
  "_combine_initial_conditions": [
    "provided_initial_conditions",
    "generated_initial_conditions",
    "dim"
  ],
  "_optimize_acqf_batch": [
    "opt_inputs"
  ],
  "optimize_acqf": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "raw_samples",
    "options",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "fixed_features",
    "post_processing_func",
    "batch_initial_conditions",
    "return_best_only",
    "gen_candidates",
    "sequential",
    "acq_function_sequence"
  ],
  "_optimize_acqf": [
    "opt_inputs"
  ],
  "optimize_acqf_cyclic": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "raw_samples",
    "options",
    "inequality_constraints",
    "equality_constraints",
    "fixed_features",
    "post_processing_func",
    "batch_initial_conditions",
    "cyclic_options"
  ],
  "optimize_acqf_list": [
    "acq_function_list",
    "bounds",
    "num_restarts",
    "raw_samples",
    "options",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "fixed_features",
    "fixed_features_list",
    "post_processing_func",
    "ic_generator",
    "ic_gen_kwargs"
  ],
  "optimize_acqf_mixed": [
    "acq_function",
    "bounds",
    "q",
    "num_restarts",
    "fixed_features_list",
    "raw_samples",
    "options",
    "inequality_constraints",
    "equality_constraints",
    "nonlinear_inequality_constraints",
    "post_processing_func",
    "batch_initial_conditions",
    "return_best_only",
    "gen_candidates",
    "ic_generator",
    "timeout_sec",
    "retry_on_optimization_warning",
    "ic_gen_kwargs"
  ],
  "optimize_acqf_discrete": [
    "acq_function",
    "q",
    "choices",
    "max_batch_size",
    "unique",
    "X_avoid",
    "inequality_constraints"
  ],
  "_split_batch_eval_acqf": [
    "acq_function",
    "X",
    "max_batch_size"
  ],
  "_generate_neighbors": [
    "x",
    "discrete_choices",
    "X_avoid",
    "inequality_constraints"
  ],
  "_filter_invalid": [
    "X",
    "X_avoid"
  ],
  "_gen_batch_initial_conditions_local_search": [
    "discrete_choices",
    "raw_samples",
    "X_avoid",
    "inequality_constraints",
    "min_points",
    "max_tries"
  ],
  "_gen_starting_points_local_search": [
    "discrete_choices",
    "raw_samples",
    "batch_initial_conditions",
    "X_avoid",
    "inequality_constraints",
    "min_points",
    "acq_function",
    "max_batch_size",
    "max_tries"
  ],
  "optimize_acqf_discrete_local_search": [
    "acq_function",
    "discrete_choices",
    "q",
    "num_restarts",
    "raw_samples",
    "inequality_constraints",
    "X_avoid",
    "batch_initial_conditions",
    "max_batch_size",
    "max_tries",
    "unique"
  ],
  "_handle_numerical_errors": [
    "error",
    "x",
    "dtype"
  ],
  "_warning_handler_template": [
    "w",
    "debug",
    "rethrow"
  ],
  "check_scipy_version_at_least": [
    "minor",
    "major"
  ],
  "minimize_with_timeout": [
    "fun",
    "x0",
    "args",
    "method",
    "jac",
    "hess",
    "hessp",
    "bounds",
    "constraints",
    "tol",
    "callback",
    "options",
    "timeout_sec"
  ],
  "TorchAttr": {},
  "get_data_loader": [
    "model",
    "batch_size"
  ],
  "get_parameters": [
    "module",
    "requires_grad",
    "name_filter"
  ],
  "get_parameters_and_bounds": [
    "module",
    "requires_grad",
    "name_filter",
    "default_bounds"
  ],
  "get_name_filter": [
    "patterns"
  ],
  "sample_all_priors": [
    "model",
    "max_retries"
  ],
  "columnwise_clamp": [
    "X",
    "lower",
    "upper",
    "raise_on_violation"
  ],
  "fix_features": [
    "X",
    "fixed_features",
    "replace_current_value"
  ],
  "get_X_baseline": [
    "acq_function"
  ],
  "torch_to_numpy_dtype_dict": [],
  "as_ndarray": [
    "values",
    "dtype",
    "inplace"
  ],
  "get_bounds_as_ndarray": [
    "parameters",
    "bounds"
  ],
  "GetLossClosure": [],
  "get_loss_closure": [
    "mll",
    "data_loader"
  ],
  "get_loss_closure_with_grads": [
    "mll",
    "parameters",
    "data_loader"
  ],
  "_get_loss_closure_fallback_external": [
    "mll",
    "_likelihood_type",
    "_model_type",
    "data_loader"
  ],
  "_get_loss_closure_fallback_internal": [
    "mll",
    "_",
    "__",
    "___"
  ],
  "_get_loss_closure_exact_internal": [
    "mll",
    "_",
    "__",
    "___"
  ],
  "_get_loss_closure_sum_internal": [
    "mll",
    "_",
    "__",
    "___"
  ],
  "FILL_VALUE": [],
  "ForwardBackwardClosure": {
    "__init__": [
      "self",
      "forward",
      "parameters"
    ],
    "__call__": [
      "self"
    ]
  },
  "NdarrayOptimizationClosure": {
    "__init__": [
      "self",
      "closure",
      "parameters"
    ],
    "__call__": [
      "self",
      "state"
    ],
    "state": [
      "self",
      "state"
    ],
    "_get_gradient_ndarray": [
      "self"
    ]
  },
  "NormalQMCEngine": {
    "__init__": [
      "self",
      "d",
      "seed",
      "inv_transform"
    ],
    "draw": [
      "self",
      "n",
      "out",
      "dtype"
    ]
  },
  "MultivariateNormalQMCEngine": {
    "__init__": [
      "self",
      "mean",
      "cov",
      "seed",
      "inv_transform"
    ],
    "draw": [
      "self",
      "n",
      "out"
    ]
  },
  "KWARGS_DEPRECATED_MSG": [],
  "KWARG_ERR_MSG": [],
  "MCSampler": {
    "__init__": [
      "self",
      "sample_shape",
      "seed"
    ],
    "forward": [
      "self",
      "posterior"
    ],
    "_get_batch_range": [
      "self",
      "posterior"
    ],
    "_get_collapsed_shape": [
      "self",
      "posterior"
    ],
    "_get_extended_base_sample_shape": [
      "self",
      "posterior"
    ],
    "_update_base_samples": [
      "self",
      "posterior",
      "base_sampler"
    ],
    "_instance_check": [
      "self",
      "base_sampler"
    ]
  },
  "_posterior_to_distribution_encoder": [
    "posterior"
  ],
  "GetSampler": [],
  "get_sampler": [
    "posterior",
    "sample_shape"
  ],
  "_get_sampler_mvn": [
    "posterior",
    "sample_shape"
  ],
  "_get_sampler_derived": [
    "posterior",
    "sample_shape"
  ],
  "_get_sampler_list": [
    "posterior",
    "sample_shape"
  ],
  "_get_sampler_ensemble": [
    "posterior",
    "sample_shape",
    "seed"
  ],
  "_not_found_error": [
    "posterior",
    "sample_shape",
    "seed"
  ],
  "ForkedRNGSampler": {
    "forward": [
      "self",
      "posterior"
    ]
  },
  "StochasticSampler": {
    "forward": [
      "self",
      "posterior"
    ]
  },
  "NormalMCSampler": {
    "forward": [
      "self",
      "posterior"
    ],
    "_construct_base_samples": [
      "self",
      "posterior"
    ],
    "_update_base_samples": [
      "self",
      "posterior",
      "base_sampler"
    ]
  },
  "IIDNormalSampler": {
    "_construct_base_samples": [
      "self",
      "posterior"
    ]
  },
  "SobolQMCNormalSampler": {
    "_construct_base_samples": [
      "self",
      "posterior"
    ]
  },
  "PairwiseMCSampler": {
    "__init__": [
      "self",
      "max_num_comparisons",
      "seed"
    ],
    "forward": [
      "self",
      "posterior"
    ]
  },
  "PairwiseIIDNormalSampler": {
    "__init__": [
      "self",
      "sample_shape",
      "seed",
      "max_num_comparisons"
    ]
  },
  "PairwiseSobolQMCNormalSampler": {
    "__init__": [
      "self",
      "sample_shape",
      "seed",
      "max_num_comparisons"
    ]
  },
  "IndexSampler": {
    "forward": [
      "self",
      "posterior"
    ],
    "_construct_base_samples": [
      "self",
      "posterior"
    ],
    "_update_base_samples": [
      "self",
      "posterior",
      "base_sampler"
    ]
  },
  "ListSampler": {
    "__init__": [
      "self"
    ],
    "_validate_samplers": [
      "self"
    ],
    "sample_shape": [
      "self"
    ],
    "forward": [
      "self",
      "posterior"
    ],
    "_update_base_samples": [
      "self",
      "posterior",
      "base_sampler"
    ]
  },
  "TInputTransform": [],
  "TOutputTransform": [],
  "GetTrainInputs": [],
  "GetTrainTargets": [],
  "TransformedModuleMixin": {
    "__call__": [
      "self",
      "values"
    ]
  },
  "TensorTransform": {
    "forward": [
      "self",
      "values"
    ]
  },
  "ChainedTransform": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "SineCosineTransform": {
    "__init__": [
      "self",
      "scale"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "InverseLengthscaleTransform": {
    "__init__": [
      "self",
      "kernel"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "OutputscaleTransform": {
    "__init__": [
      "self",
      "kernel"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "FeatureSelector": {
    "__init__": [
      "self",
      "indices",
      "dim"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "OutcomeUntransformer": {
    "__init__": [
      "self",
      "transform",
      "num_outputs"
    ],
    "forward": [
      "self",
      "values"
    ]
  },
  "get_input_transform": [
    "model"
  ],
  "get_output_transform": [
    "model"
  ],
  "get_train_inputs": [
    "model",
    "transformed"
  ],
  "_get_train_inputs_Model": [
    "model",
    "transformed"
  ],
  "_get_train_inputs_SingleTaskVariationalGP": [
    "model",
    "transformed"
  ],
  "_get_train_inputs_ModelList": [
    "model",
    "transformed"
  ],
  "get_train_targets": [
    "model",
    "transformed"
  ],
  "_get_train_targets_Model": [
    "model",
    "transformed"
  ],
  "_get_train_targets_SingleTaskVariationalGP": [
    "model",
    "transformed"
  ],
  "_get_train_targets_ModelList": [
    "model",
    "transformed"
  ],
  "DrawMatheronPaths": [],
  "MatheronPath": {
    "__init__": [
      "self",
      "prior_paths",
      "update_paths",
      "input_transform",
      "output_transform"
    ]
  },
  "get_matheron_path_model": [
    "model",
    "sample_shape",
    "ensemble_as_batch"
  ],
  "draw_matheron_paths": [
    "model",
    "sample_shape",
    "prior_sampler",
    "update_strategy"
  ],
  "_draw_matheron_paths_ModelListGP": [
    "model",
    "sample_shape"
  ],
  "_draw_matheron_paths_ExactGP": [
    "model"
  ],
  "_draw_matheron_paths_ApproximateGP": [
    "model"
  ],
  "SamplePath": {
    "set_ensemble_as_batch": [
      "self",
      "ensemble_as_batch"
    ]
  },
  "PathDict": {
    "__init__": [
      "self",
      "paths",
      "join",
      "input_transform",
      "output_transform"
    ],
    "forward": [
      "self",
      "x"
    ],
    "items": [
      "self"
    ],
    "keys": [
      "self"
    ],
    "values": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__delitem__": [
      "self",
      "key"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__setitem__": [
      "self",
      "key",
      "val"
    ],
    "set_ensemble_as_batch": [
      "self",
      "ensemble_as_batch"
    ]
  },
  "PathList": {
    "__init__": [
      "self",
      "paths",
      "join",
      "input_transform",
      "output_transform"
    ],
    "forward": [
      "self",
      "x"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__delitem__": [
      "self",
      "key"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__setitem__": [
      "self",
      "key",
      "val"
    ],
    "set_ensemble_as_batch": [
      "self",
      "ensemble_as_batch"
    ]
  },
  "GeneralizedLinearPath": {
    "__init__": [
      "self",
      "feature_map",
      "weight",
      "bias_module",
      "input_transform",
      "output_transform",
      "is_ensemble",
      "ensemble_as_batch"
    ],
    "forward": [
      "self",
      "x"
    ],
    "set_ensemble_as_batch": [
      "self",
      "ensemble_as_batch"
    ]
  },
  "TPathwisePriorSampler": [],
  "DrawKernelFeaturePaths": [],
  "draw_kernel_feature_paths": [
    "model",
    "sample_shape"
  ],
  "_draw_kernel_feature_paths_fallback": [
    "num_inputs",
    "mean_module",
    "covar_module",
    "sample_shape",
    "num_features",
    "map_generator",
    "input_transform",
    "output_transform",
    "weight_generator",
    "is_ensemble"
  ],
  "_draw_kernel_feature_paths_ExactGP": [
    "model"
  ],
  "_draw_kernel_feature_paths_list": [
    "model",
    "join"
  ],
  "_draw_kernel_feature_paths_ApproximateGPyTorchModel": [
    "model"
  ],
  "_draw_kernel_feature_paths_ApproximateGP": [
    "model"
  ],
  "_draw_kernel_feature_paths_ApproximateGP_fallback": [
    "model",
    "_"
  ],
  "TPathwiseUpdate": [],
  "GaussianUpdate": [],
  "gaussian_update": [
    "model",
    "sample_values",
    "likelihood"
  ],
  "_gaussian_update_exact": [
    "kernel",
    "points",
    "target_values",
    "sample_values",
    "noise_covariance",
    "scale_tril",
    "input_transform",
    "is_ensemble"
  ],
  "_gaussian_update_ExactGP": [
    "model",
    "likelihood"
  ],
  "_gaussian_update_ApproximateGPyTorchModel": [
    "model",
    "likelihood"
  ],
  "_gaussian_update_ApproximateGP": [
    "model",
    "likelihood"
  ],
  "_gaussian_update_ApproximateGP_VariationalStrategy": [
    "model",
    "_"
  ],
  "TKernelFeatureMapGenerator": [],
  "GenKernelFeatures": [],
  "gen_kernel_features": [
    "kernel",
    "num_inputs",
    "num_outputs"
  ],
  "_gen_fourier_features": [
    "kernel",
    "weight_generator",
    "num_inputs",
    "num_outputs"
  ],
  "_gen_kernel_features_rbf": [
    "kernel"
  ],
  "_gen_kernel_features_matern": [
    "kernel"
  ],
  "_gen_kernel_features_scale": [
    "kernel"
  ],
  "FeatureMap": {},
  "KernelEvaluationMap": {
    "__init__": [
      "self",
      "kernel",
      "points",
      "input_transform",
      "output_transform"
    ],
    "forward": [
      "self",
      "x"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ]
  },
  "KernelFeatureMap": {
    "__init__": [
      "self",
      "kernel",
      "weight",
      "bias",
      "input_transform",
      "output_transform"
    ],
    "forward": [
      "self",
      "x"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ]
  },
  "ModelListGP": {
    "__init__": [
      "self"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "_set_transformed_inputs": [
      "self"
    ],
    "_revert_to_original_inputs": [
      "self"
    ]
  },
  "SingleTaskMultiFidelityGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "iteration_fidelity",
      "data_fidelities",
      "linear_truncated",
      "nu",
      "likelihood",
      "outcome_transform",
      "input_transform"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "fidelity_features"
    ]
  },
  "_setup_multifidelity_covar_module": [
    "dim",
    "aug_batch_shape",
    "iteration_fidelity",
    "data_fidelities",
    "linear_truncated",
    "nu"
  ],
  "FRACTIONS_OF_OUTLIERS": [],
  "RobustRelevancePursuitMixin": {
    "__init__": [
      "self",
      "base_likelihood",
      "dim",
      "prior_mean_of_support",
      "convex_parameterization",
      "cache_model_trace"
    ],
    "to_standard_model": [
      "self"
    ],
    "load_standard_model": [
      "self",
      "standard_model"
    ]
  },
  "RobustRelevancePursuitSingleTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "likelihood",
      "covar_module",
      "mean_module",
      "outcome_transform",
      "input_transform",
      "convex_parameterization",
      "prior_mean_of_support",
      "cache_model_trace"
    ],
    "to_standard_model": [
      "self"
    ]
  },
  "_fit_rrp": [
    "mll",
    "_",
    "__"
  ],
  "_fit_rrp_approximate_mll": [
    "mll",
    "_",
    "__"
  ],
  "MLL_ITER": [],
  "MLL_TOL": [],
  "RESET_PARAMETERS": [],
  "RESET_DENSE_PARAMETERS": [],
  "RelevancePursuitMixin": {
    "__init__": [
      "self",
      "dim",
      "support"
    ],
    "sparse_parameter": [
      "self"
    ],
    "set_sparse_parameter": [
      "self",
      "value"
    ],
    "_from_model": [
      "model"
    ],
    "is_sparse": [
      "self"
    ],
    "support": [
      "self"
    ],
    "is_active": [
      "self"
    ],
    "inactive_indices": [
      "self"
    ],
    "to_sparse": [
      "self"
    ],
    "to_dense": [
      "self"
    ],
    "expand_support": [
      "self",
      "indices"
    ],
    "contract_support": [
      "self",
      "indices"
    ],
    "full_support": [
      "self"
    ],
    "remove_support": [
      "self"
    ],
    "support_expansion": [
      "self",
      "mll",
      "n",
      "modifier"
    ],
    "expansion_objective": [
      "self",
      "mll"
    ],
    "_sparse_parameter_gradient": [
      "self",
      "mll"
    ],
    "support_contraction": [
      "self",
      "mll",
      "n",
      "modifier"
    ],
    "optimize_mll": [
      "self",
      "mll",
      "model_trace",
      "reset_parameters",
      "reset_dense_parameters",
      "closure",
      "optimizer",
      "closure_kwargs",
      "optimizer_kwargs"
    ]
  },
  "forward_relevance_pursuit": [
    "sparse_module",
    "mll",
    "sparsity_levels",
    "reset_parameters",
    "reset_dense_parameters",
    "record_model_trace",
    "initial_support",
    "closure",
    "optimizer",
    "closure_kwargs",
    "optimizer_kwargs"
  ],
  "backward_relevance_pursuit": [
    "sparse_module",
    "mll",
    "sparsity_levels",
    "reset_parameters",
    "reset_dense_parameters",
    "record_model_trace",
    "initial_support",
    "closure",
    "optimizer",
    "closure_kwargs",
    "optimizer_kwargs"
  ],
  "get_posterior_over_support": [
    "rp_class",
    "model_trace",
    "log_support_prior",
    "prior_mean_of_support"
  ],
  "_exp_log_pdf": [
    "x",
    "mean"
  ],
  "initialize_dense_parameters": [
    "model"
  ],
  "_get_initial_value": [
    "value",
    "lower",
    "upper"
  ],
  "_initialize_optimizer_kwargs": [
    "optimizer_kwargs"
  ],
  "LCEMGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "task_feature",
      "train_Yvar",
      "mean_module",
      "covar_module",
      "likelihood",
      "context_cat_feature",
      "context_emb_feature",
      "embs_dim_list",
      "output_tasks",
      "all_tasks",
      "outcome_transform",
      "input_transform"
    ],
    "_eval_context_covar": [
      "self"
    ],
    "_task_embeddings": [
      "self"
    ],
    "task_covar_module": [
      "self",
      "task_idcs"
    ],
    "forward": [
      "self",
      "x"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "task_feature",
      "output_tasks",
      "context_cat_feature",
      "context_emb_feature",
      "embs_dim_list"
    ]
  },
  "DeterministicModel": {
    "_set_transformed_inputs": [
      "self"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_forward": [
      "self",
      "X"
    ]
  },
  "GenericDeterministicModel": {
    "__init__": [
      "self",
      "f",
      "num_outputs",
      "batch_shape"
    ],
    "batch_shape": [
      "self"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "AffineDeterministicModel": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "PosteriorMeanModel": {
    "__init__": [
      "self",
      "model"
    ],
    "forward": [
      "self",
      "X"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ]
  },
  "FixedSingleSampleModel": {
    "__init__": [
      "self",
      "model",
      "w",
      "dim",
      "jitter",
      "dtype",
      "device"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "MatheronPathModel": {
    "__init__": [
      "self",
      "model",
      "sample_shape",
      "ensemble_as_batch",
      "seed"
    ],
    "forward": [
      "self",
      "X"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ]
  },
  "HeterogeneousMTGP": {
    "__init__": [
      "self",
      "train_Xs",
      "train_Ys",
      "train_Yvars",
      "feature_indices",
      "full_feature_dim",
      "rank",
      "use_saas_prior",
      "use_combinatorial_kernel",
      "all_tasks",
      "input_transform",
      "outcome_transform",
      "validate_task_values"
    ],
    "get_all_tasks": [
      "cls",
      "train_X",
      "task_feature",
      "output_tasks"
    ],
    "map_to_full_tensor": [
      "self",
      "X",
      "task_index"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "_split_inputs": [
      "self",
      "x"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "task_feature",
      "output_tasks",
      "rank",
      "use_saas_prior",
      "use_combinatorial_kernel"
    ]
  },
  "GPyTorchModel": {
    "_validate_tensor_args": [
      "X",
      "Y",
      "Yvar",
      "strict"
    ],
    "batch_shape": [
      "self"
    ],
    "num_outputs": [
      "self"
    ],
    "posterior": [
      "self",
      "X",
      "observation_noise",
      "posterior_transform"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y",
      "noise"
    ],
    "_extract_targets_and_noise": [
      "self"
    ],
    "_restore_targets_and_noise": [
      "self",
      "Y",
      "Yvar",
      "strict"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict",
      "keep_transforms"
    ]
  },
  "BatchedMultiOutputGPyTorchModel": {
    "get_batch_dimensions": [
      "train_X",
      "train_Y"
    ],
    "_set_dimensions": [
      "self",
      "train_X",
      "train_Y"
    ],
    "batch_shape": [
      "self"
    ],
    "_transform_tensor_args": [
      "self",
      "X",
      "Y",
      "Yvar"
    ],
    "_apply_noise": [
      "self",
      "X",
      "mvn",
      "observation_noise"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "subset_output": [
      "self",
      "idcs"
    ]
  },
  "ModelListGPyTorchModel": {
    "batch_shape": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "_broadcast_mvns": [
      "self",
      "mvns"
    ]
  },
  "MultiTaskGPyTorchModel": {
    "_extract_targets_and_noise": [
      "self"
    ],
    "_restore_targets_and_noise": [
      "self",
      "Y",
      "Yvar",
      "strict"
    ],
    "_apply_noise": [
      "self",
      "X",
      "mvn",
      "observation_noise"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "subset_output": [
      "self",
      "idcs"
    ]
  },
  "TFullyBayesianSingleTaskGP": [],
  "_sqrt5": [],
  "_handle_torch_linalg": [
    "exception"
  ],
  "_handle_valerr_in_dist_init": [
    "exception"
  ],
  "matern52_kernel": [
    "X",
    "lengthscale"
  ],
  "linear_kernel": [
    "X",
    "weight_variance"
  ],
  "compute_dists": [
    "X",
    "lengthscale"
  ],
  "reshape_and_detach": [
    "target",
    "new_value"
  ],
  "PyroModel": {
    "__init__": [
      "self",
      "use_input_warping",
      "indices_to_warp",
      "eps"
    ],
    "warp": [
      "self",
      "X",
      "c0",
      "c1"
    ],
    "_maybe_input_warp": [
      "self",
      "X"
    ],
    "set_inputs": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar"
    ],
    "sample": [
      "self"
    ],
    "postprocess_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "sample_noise": [
      "self"
    ],
    "sample_mean": [
      "self"
    ],
    "sample_concentrations": [
      "self"
    ]
  },
  "MaternPyroModel": {
    "sample": [
      "self"
    ],
    "sample_lengthscale": [
      "self",
      "dim"
    ],
    "sample_outputscale": [
      "self",
      "concentration",
      "rate"
    ],
    "postprocess_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "_get_covar_module": [
      "self",
      "use_scale_kernel",
      "batch_shape",
      "dtype",
      "device"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ]
  },
  "SaasPyroModel": {
    "sample_lengthscale": [
      "self",
      "dim",
      "alpha"
    ],
    "postprocess_mcmc_samples": [
      "self",
      "mcmc_samples"
    ]
  },
  "LinearPyroModel": {
    "sample": [
      "self"
    ],
    "sample_weight_variance": [
      "self",
      "alpha"
    ],
    "postprocess_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ]
  },
  "AbstractFullyBayesianSingleTaskGP": {
    "_is_fully_bayesian": [],
    "_is_ensemble": [],
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "outcome_transform",
      "input_transform",
      "use_input_warping",
      "indices_to_warp"
    ],
    "_check_if_fitted": [
      "self"
    ],
    "num_mcmc_samples": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "_aug_batch_shape": [
      "self"
    ],
    "train": [
      "self",
      "mode",
      "reset"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "forward": [
      "self",
      "X"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ]
  },
  "FullyBayesianSingleTaskGP": {
    "median_lengthscale": [
      "self"
    ],
    "_get_dummy_mcmc_samples": [
      "self",
      "num_mcmc_samples",
      "dim",
      "dtype",
      "device"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ]
  },
  "SaasFullyBayesianSingleTaskGP": {
    "_get_dummy_mcmc_samples": [
      "self",
      "num_mcmc_samples",
      "dim",
      "dtype",
      "device"
    ]
  },
  "FullyBayesianLinearSingleTaskGP": {
    "median_weight_variance": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ]
  },
  "SingleTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "likelihood",
      "covar_module",
      "mean_module",
      "outcome_transform",
      "input_transform"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MixedSingleTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "cat_dims",
      "train_Yvar",
      "cont_kernel_factory",
      "likelihood",
      "outcome_transform",
      "input_transform"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "categorical_features",
      "likelihood"
    ]
  },
  "TSaasFullyBayesianMultiTaskGP": [],
  "MultitaskSaasPyroModel": {
    "set_inputs": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "task_feature",
      "task_rank"
    ],
    "sample": [
      "self"
    ],
    "sample_latent_features": [
      "self"
    ],
    "sample_task_lengthscale": [
      "self",
      "concentration",
      "rate"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ]
  },
  "SaasFullyBayesianMultiTaskGP": {
    "_is_fully_bayesian": [],
    "_is_ensemble": [],
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "task_feature",
      "train_Yvar",
      "output_tasks",
      "rank",
      "all_tasks",
      "outcome_transform",
      "input_transform",
      "pyro_model",
      "validate_task_values"
    ],
    "train": [
      "self",
      "mode",
      "reset"
    ],
    "median_lengthscale": [
      "self"
    ],
    "num_mcmc_samples": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "fantasize": [
      "self"
    ],
    "_check_if_fitted": [
      "self"
    ],
    "load_mcmc_samples": [
      "self",
      "mcmc_samples"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ]
  },
  "LatentKroneckerGP": {
    "__init__": [
      "self",
      "train_X",
      "train_T",
      "train_Y",
      "likelihood",
      "mean_module_X",
      "mean_module_T",
      "covar_module_X",
      "covar_module_T",
      "input_transform",
      "outcome_transform"
    ],
    "use_iterative_methods": [
      "self",
      "tol",
      "max_iter",
      "covar_root_decomposition",
      "log_prob",
      "solves"
    ],
    "_get_mean": [
      "self",
      "X",
      "T",
      "mask"
    ],
    "forward": [
      "self",
      "X",
      "T"
    ],
    "posterior": [
      "self",
      "X",
      "T",
      "observation_noise",
      "posterior_transform"
    ],
    "_rsample_from_base_samples": [
      "self",
      "X",
      "T",
      "base_samples",
      "observation_noise"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y",
      "noise"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ]
  },
  "Model": {
    "_is_fully_bayesian": [],
    "_is_ensemble": [],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "batch_shape": [
      "self"
    ],
    "num_outputs": [
      "self"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ],
    "transform_inputs": [
      "self",
      "X",
      "input_transform"
    ],
    "_set_transformed_inputs": [
      "self"
    ],
    "_revert_to_original_inputs": [
      "self"
    ],
    "eval": [
      "self"
    ],
    "train": [
      "self",
      "mode"
    ],
    "dtypes_of_buffers": [
      "self"
    ]
  },
  "FantasizeMixin": {
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ],
    "posterior": [
      "self",
      "X"
    ],
    "transform_inputs": [
      "self",
      "X",
      "input_transform"
    ],
    "fantasize": [
      "self",
      "X",
      "sampler",
      "observation_noise"
    ]
  },
  "ModelList": {
    "__init__": [
      "self"
    ],
    "_get_group_subset_indices": [
      "self",
      "idcs"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "batch_shape": [
      "self"
    ],
    "num_outputs": [
      "self"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "transform_inputs": [
      "self",
      "X"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict",
      "keep_transforms"
    ],
    "fantasize": [
      "self",
      "X",
      "sampler",
      "observation_noise",
      "evaluation_mask"
    ]
  },
  "ModelDict": {
    "__init__": [
      "self"
    ]
  },
  "SACGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "decomposition"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "decomposition"
    ]
  },
  "LCEAGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "decomposition",
      "train_embedding",
      "cat_feature_dict",
      "embs_feature_dict",
      "embs_dim_list",
      "context_weight_dict"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "decomposition",
      "train_embedding",
      "cat_feature_dict",
      "embs_feature_dict",
      "embs_dim_list",
      "context_weight_dict"
    ]
  },
  "AffineFidelityCostModel": {
    "__init__": [
      "self",
      "fidelity_weights",
      "fixed_cost"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "FixedCostModel": {
    "__init__": [
      "self",
      "fixed_cost"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_check_strict_input": [
    "inputs",
    "t_inputs",
    "target_or_inputs"
  ],
  "_scaled_psd_safe_cholesky": [
    "matrix",
    "scale",
    "jitter"
  ],
  "_ensure_psd_with_jitter": [
    "matrix",
    "scale",
    "jitter",
    "max_tries"
  ],
  "PairwiseGP": {
    "_buffer_names": [],
    "__init__": [
      "self",
      "datapoints",
      "comparisons",
      "likelihood",
      "covar_module",
      "input_transform"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "_has_no_data": [
      "self"
    ],
    "_calc_covar": [
      "self",
      "X1",
      "X2"
    ],
    "_update_covar": [
      "self",
      "datapoints"
    ],
    "_prior_mean": [
      "self",
      "X"
    ],
    "_prior_predict": [
      "self",
      "X"
    ],
    "_grad_posterior_f": [
      "self",
      "utility",
      "datapoints",
      "D",
      "covar_chol",
      "covar_inv",
      "ret_np"
    ],
    "_hess_posterior_f": [
      "self",
      "utility",
      "datapoints",
      "D",
      "covar_chol",
      "covar_inv",
      "ret_np"
    ],
    "_update_utility_derived_values": [
      "self"
    ],
    "_update": [
      "self",
      "datapoints"
    ],
    "_transform_batch_shape": [
      "self",
      "X",
      "X_new"
    ],
    "_util_newton_updates": [
      "self",
      "dp",
      "x0",
      "max_iter",
      "xtol"
    ],
    "_consolidate_duplicates": [
      "self",
      "datapoints",
      "comparisons"
    ],
    "datapoints": [
      "self"
    ],
    "comparisons": [
      "self"
    ],
    "unconsolidated_utility": [
      "self"
    ],
    "num_outputs": [
      "self"
    ],
    "batch_shape": [
      "self"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ],
    "set_train_data": [
      "self",
      "datapoints",
      "comparisons",
      "strict",
      "update_model"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ],
    "_load_from_state_dict": [
      "self",
      "state_dict",
      "prefix",
      "local_metadata",
      "strict",
      "missing_keys",
      "unexpected_keys",
      "error_msgs"
    ],
    "forward": [
      "self",
      "datapoints"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y"
    ]
  },
  "PairwiseLaplaceMarginalLogLikelihood": {
    "__init__": [
      "self",
      "likelihood",
      "model"
    ],
    "forward": [
      "self",
      "post",
      "comp"
    ]
  },
  "_compute_multitask_mean": [
    "mean_module",
    "x_before",
    "task_idcs",
    "x_after"
  ],
  "MultiTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "task_feature",
      "train_Yvar",
      "mean_module",
      "covar_module",
      "likelihood",
      "task_covar_prior",
      "output_tasks",
      "rank",
      "all_tasks",
      "outcome_transform",
      "input_transform",
      "validate_task_values"
    ],
    "_map_tasks": [
      "self",
      "task_values"
    ],
    "_split_inputs": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "get_all_tasks": [
      "cls",
      "train_X",
      "task_feature",
      "output_tasks"
    ],
    "construct_inputs": [
      "cls",
      "training_data",
      "task_feature",
      "output_tasks",
      "task_covar_prior",
      "prior_config",
      "rank"
    ]
  },
  "KroneckerMultiTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "likelihood",
      "data_covar_module",
      "task_covar_prior",
      "rank",
      "outcome_transform",
      "input_transform"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_task_covar_matrix": [
      "self"
    ],
    "train_full_covar": [
      "self"
    ],
    "predictive_mean_cache": [
      "self"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "train": [
      "self",
      "val"
    ]
  },
  "FlattenedStandardize": {
    "__init__": [
      "self",
      "output_shape",
      "batch_shape",
      "min_stdv"
    ],
    "_squeeze_to_single_output": [
      "self",
      "tsr"
    ],
    "_return_to_output_shape": [
      "self",
      "tsr"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "HigherOrderGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "likelihood",
      "covar_modules",
      "num_latent_dims",
      "learn_latent_pars",
      "latent_init",
      "outcome_transform",
      "input_transform"
    ],
    "_initialize_latents": [
      "self",
      "latent_init",
      "num_latent_dims",
      "learn_latent_pars",
      "device",
      "dtype"
    ],
    "forward": [
      "self",
      "X"
    ],
    "get_fantasy_model": [
      "self",
      "inputs",
      "targets"
    ],
    "condition_on_observations": [
      "self",
      "X",
      "Y",
      "noise"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "make_posterior_variances": [
      "self",
      "joint_covariance_matrix"
    ]
  },
  "EnsembleModel": {
    "__init__": [
      "self",
      "weights"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_forward": [
      "self",
      "X"
    ],
    "num_outputs": [
      "self"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "posterior_transform"
    ]
  },
  "EPS": [],
  "SaasPriorHelper": {
    "__init__": [
      "self",
      "tau"
    ],
    "tau": [
      "self",
      "m"
    ],
    "inv_lengthscale_prior_param_or_closure": [
      "self",
      "m"
    ],
    "inv_lengthscale_prior_setting_closure": [
      "self",
      "m",
      "value"
    ],
    "tau_prior_param_or_closure": [
      "self",
      "m"
    ],
    "tau_prior_setting_closure": [
      "self",
      "m",
      "value"
    ]
  },
  "add_saas_prior": [
    "base_kernel",
    "tau",
    "log_scale"
  ],
  "get_map_saas_model": [
    "train_X",
    "train_Y",
    "train_Yvar",
    "input_transform",
    "outcome_transform",
    "tau"
  ],
  "get_mean_module_with_normal_prior": [
    "batch_shape"
  ],
  "get_gaussian_likelihood_with_gamma_prior": [
    "batch_shape"
  ],
  "get_additive_map_saas_covar_module": [
    "ard_num_dims",
    "num_taus",
    "active_dims",
    "batch_shape",
    "dtype",
    "device"
  ],
  "AdditiveMapSaasSingleTaskGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "outcome_transform",
      "input_transform",
      "num_taus"
    ]
  },
  "EnsembleMapSaasSingleTaskGP": {
    "_is_ensemble": [],
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "train_Yvar",
      "num_taus",
      "taus",
      "outcome_transform",
      "input_transform"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "construct_inputs": [
      "cls",
      "training_data"
    ],
    "load_state_dict": [
      "self",
      "state_dict",
      "strict"
    ]
  },
  "TRANSFORM_WARNING": [],
  "ApproximateGPyTorchModel": {
    "__init__": [
      "self",
      "model",
      "likelihood",
      "num_outputs"
    ],
    "num_outputs": [
      "self"
    ],
    "eval": [
      "self"
    ],
    "train": [
      "self",
      "mode"
    ],
    "posterior": [
      "self",
      "X",
      "output_indices",
      "observation_noise",
      "posterior_transform"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "_SingleTaskVariationalGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "num_outputs",
      "learn_inducing_points",
      "covar_module",
      "mean_module",
      "variational_distribution",
      "variational_strategy",
      "inducing_points",
      "inducing_point_allocator"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "SingleTaskVariationalGP": {
    "__init__": [
      "self",
      "train_X",
      "train_Y",
      "likelihood",
      "num_outputs",
      "learn_inducing_points",
      "covar_module",
      "mean_module",
      "variational_distribution",
      "variational_strategy",
      "inducing_points",
      "inducing_point_allocator",
      "outcome_transform",
      "input_transform"
    ],
    "batch_shape": [
      "self"
    ],
    "init_inducing_points": [
      "self",
      "inputs"
    ]
  },
  "DownsamplingKernel": {
    "__init__": [
      "self",
      "power_prior",
      "offset_prior",
      "power_constraint",
      "offset_constraint"
    ],
    "power": [
      "self",
      "value"
    ],
    "_set_power": [
      "self",
      "value"
    ],
    "offset": [
      "self",
      "value"
    ],
    "_set_offset": [
      "self",
      "value"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ]
  },
  "InfiniteWidthBNNKernel": {
    "has_lengthscale": [],
    "__init__": [
      "self",
      "depth",
      "batch_shape",
      "active_dims",
      "acos_eps",
      "device"
    ],
    "weight_var": [
      "self",
      "value"
    ],
    "bias_var": [
      "self",
      "value"
    ],
    "_initialize_var": [
      "self",
      "x"
    ],
    "_update_var": [
      "self",
      "K",
      "x"
    ],
    "k": [
      "self",
      "x1",
      "x2"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ]
  },
  "PositiveIndexKernel": {
    "__init__": [
      "self",
      "num_tasks",
      "rank",
      "task_prior",
      "diag_prior",
      "normalize_covar_matrix",
      "var_constraint",
      "target_task_index",
      "unit_scale_for_target"
    ],
    "_covar_factor_params": [
      "self",
      "m"
    ],
    "_covar_factor_closure": [
      "self",
      "m",
      "v"
    ],
    "covar_factor": [
      "self",
      "value"
    ],
    "_set_covar_factor": [
      "self",
      "value"
    ],
    "_lower_triangle_corr": [
      "self"
    ],
    "_diagonal": [
      "self"
    ],
    "_eval_covar_matrix": [
      "self"
    ],
    "covar_matrix": [
      "self"
    ]
  },
  "CategoricalKernel": {
    "has_lengthscale": [],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ]
  },
  "ExponentialDecayKernel": {
    "has_lengthscale": [],
    "__init__": [
      "self",
      "power_prior",
      "offset_prior",
      "power_constraint",
      "offset_constraint"
    ],
    "power": [
      "self",
      "value"
    ],
    "_set_power": [
      "self",
      "value"
    ],
    "offset": [
      "self",
      "value"
    ],
    "_set_offset": [
      "self",
      "value"
    ],
    "forward": [
      "self",
      "x1",
      "x2"
    ]
  },
  "LinearTruncatedFidelityKernel": {
    "__init__": [
      "self",
      "fidelity_dims",
      "dimension",
      "power_prior",
      "power_constraint",
      "nu",
      "lengthscale_prior_unbiased",
      "lengthscale_prior_biased",
      "lengthscale_constraint_unbiased",
      "lengthscale_constraint_biased",
      "covar_module_unbiased",
      "covar_module_biased"
    ],
    "power": [
      "self",
      "value"
    ],
    "_set_power": [
      "self",
      "value"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag"
    ]
  },
  "_positivity_constraint": [],
  "SECOND_ORDER_PRIOR_ERROR_MSG": [],
  "OrthogonalAdditiveKernel": {
    "__init__": [
      "self",
      "base_kernel",
      "dim",
      "quad_deg",
      "second_order",
      "batch_shape",
      "dtype",
      "device",
      "coeff_constraint",
      "offset_prior",
      "coeffs_1_prior",
      "coeffs_2_prior"
    ],
    "k": [
      "self",
      "x1",
      "x2"
    ],
    "offset": [
      "self",
      "value"
    ],
    "coeffs_1": [
      "self",
      "value"
    ],
    "coeffs_2": [
      "self",
      "value"
    ],
    "_set_coeffs_1": [
      "self",
      "value"
    ],
    "_set_coeffs_2": [
      "self",
      "value"
    ],
    "_set_offset": [
      "self",
      "value"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ],
    "_orthogonal_base_kernels": [
      "self",
      "x1",
      "x2"
    ],
    "normalizer": [
      "self",
      "eps"
    ]
  },
  "_check_hypercube": [
    "x",
    "name"
  ],
  "_reverse_triu_indices": [
    "d"
  ],
  "_coeffs_1_param": [
    "m"
  ],
  "_coeffs_2_param": [
    "m"
  ],
  "_offset_param": [
    "m"
  ],
  "_coeffs_1_closure": [
    "m",
    "v"
  ],
  "_coeffs_2_closure": [
    "m",
    "v"
  ],
  "_offset_closure": [
    "m",
    "v"
  ],
  "LOG_OUTPUTSCALE_CONSTRAINT": [],
  "DeltaKernel": {
    "forward": [
      "self",
      "x1",
      "x2"
    ]
  },
  "CombinatorialCovarModule": {
    "__init__": [
      "self",
      "ard_num_dims"
    ]
  },
  "MultiTaskConditionalKernel": {
    "__init__": [
      "self",
      "feature_indices",
      "task_feature_index",
      "use_saas_prior",
      "use_combinatorial_kernel"
    ],
    "construct_individual_kernels": [
      "self"
    ],
    "map_task_to_binary": [
      "self",
      "x_task"
    ],
    "forward": [
      "self",
      "x1",
      "x2"
    ]
  },
  "find_subsets": [
    "feature_indices"
  ],
  "map_subsets": [
    "subsets",
    "feature_indices"
  ],
  "SACKernel": {
    "__init__": [
      "self",
      "decomposition",
      "batch_shape",
      "device"
    ],
    "device": [
      "self"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ]
  },
  "get_order": [
    "indices"
  ],
  "is_contiguous": [
    "indices"
  ],
  "get_permutation": [
    "decomposition"
  ],
  "_create_new_permutation": [
    "decomposition"
  ],
  "LCEAKernel": {
    "__init__": [
      "self",
      "decomposition",
      "batch_shape",
      "train_embedding",
      "cat_feature_dict",
      "embs_feature_dict",
      "embs_dim_list",
      "context_weight_dict",
      "device"
    ],
    "device": [
      "self"
    ],
    "outputscale_list": [
      "self",
      "value"
    ],
    "_set_outputscale_list": [
      "self",
      "value"
    ],
    "_set_context_features": [
      "self",
      "cat_feature_dict",
      "embs_feature_dict",
      "embs_dim_list"
    ],
    "_set_emb_layers": [
      "self"
    ],
    "_eval_context_covar": [
      "self"
    ],
    "_task_embeddings": [
      "self"
    ],
    "_task_embeddings_batch": [
      "self"
    ],
    "train": [
      "self",
      "mode"
    ],
    "forward": [
      "self",
      "x1",
      "x2",
      "diag",
      "last_dim_is_batch"
    ],
    "_eval_base_covar_perm": [
      "self",
      "x1",
      "x2"
    ]
  },
  "SparseOutlierGaussianLikelihood": {
    "__init__": [
      "self",
      "base_noise",
      "dim",
      "outlier_indices",
      "rho_prior",
      "rho_constraint",
      "batch_shape",
      "convex_parameterization",
      "loo"
    ],
    "marginal": [
      "self",
      "function_dist",
      "X"
    ],
    "expected_log_prob": [
      "self",
      "target",
      "input"
    ]
  },
  "SparseOutlierNoise": {
    "__init__": [
      "self",
      "base_noise",
      "dim",
      "outlier_indices",
      "rho_prior",
      "rho_constraint",
      "batch_shape",
      "convex_parameterization",
      "loo"
    ],
    "sparse_parameter": [
      "self"
    ],
    "set_sparse_parameter": [
      "self",
      "value"
    ],
    "convex_parameterization": [
      "self"
    ],
    "_from_model": [
      "model"
    ],
    "_convex_rho": [
      "self"
    ],
    "rho": [
      "self"
    ],
    "_rho_selection_indices": [
      "self"
    ],
    "forward": [
      "self",
      "X",
      "shape",
      "diag_K"
    ],
    "expansion_objective": [
      "self",
      "mll"
    ],
    "_optimal_rhos": [
      "self",
      "mll"
    ]
  },
  "PairwiseLikelihood": {
    "__init__": [
      "self",
      "max_plate_nesting"
    ],
    "forward": [
      "self",
      "utility",
      "D"
    ],
    "p": [
      "self",
      "utility",
      "D"
    ],
    "log_p": [
      "self",
      "utility",
      "D"
    ],
    "negative_log_gradient_sum": [
      "self",
      "utility",
      "D"
    ],
    "negative_log_hessian_sum": [
      "self",
      "utility",
      "D"
    ]
  },
  "PairwiseProbitLikelihood": {
    "_zlim": [],
    "_calc_z": [
      "self",
      "utility",
      "D"
    ],
    "_calc_z_derived": [
      "self",
      "z"
    ],
    "p": [
      "self",
      "utility",
      "D",
      "log"
    ],
    "negative_log_gradient_sum": [
      "self",
      "utility",
      "D"
    ],
    "negative_log_hessian_sum": [
      "self",
      "utility",
      "D"
    ]
  },
  "PairwiseLogitLikelihood": {
    "_logit_lim": [],
    "_calc_logit": [
      "self",
      "utility",
      "D"
    ],
    "log_p": [
      "self",
      "utility",
      "D"
    ],
    "p": [
      "self",
      "utility",
      "D"
    ],
    "negative_log_gradient_sum": [
      "self",
      "utility",
      "D"
    ],
    "negative_log_hessian_sum": [
      "self",
      "utility",
      "D"
    ]
  },
  "_make_X_full": [
    "X",
    "output_indices",
    "tf"
  ],
  "multioutput_to_batch_mode_transform": [
    "train_X",
    "train_Y",
    "num_outputs",
    "train_Yvar"
  ],
  "add_output_dim": [
    "X",
    "original_batch_shape"
  ],
  "check_no_nans": [
    "Z"
  ],
  "check_min_max_scaling": [
    "X",
    "strict",
    "atol",
    "raise_on_fail",
    "ignore_dims"
  ],
  "check_standardization": [
    "Y",
    "atol_mean",
    "atol_std",
    "raise_on_fail"
  ],
  "mod_batch_shape": [
    "module",
    "names",
    "b"
  ],
  "gpt_posterior_settings": [],
  "detect_duplicates": [
    "X",
    "rtol",
    "atol"
  ],
  "consolidate_duplicates": [
    "X",
    "Y",
    "rtol",
    "atol"
  ],
  "fantasize": {},
  "get_task_value_remapping": [
    "observed_task_values",
    "all_task_values",
    "dtype",
    "default_task_value"
  ],
  "extract_targets_and_noise_single_output": [
    "model"
  ],
  "restore_targets_and_noise_single_output": [
    "model",
    "Y",
    "Yvar",
    "strict"
  ],
  "MIN_INFERRED_NOISE_LEVEL": [],
  "SQRT2": [],
  "SQRT3": [],
  "get_matern_kernel_with_gamma_prior": [
    "ard_num_dims",
    "batch_shape"
  ],
  "get_gaussian_likelihood_with_lognormal_prior": [
    "batch_shape"
  ],
  "get_covar_module_with_dim_scaled_prior": [
    "ard_num_dims",
    "batch_shape",
    "use_rbf_kernel",
    "active_dims"
  ],
  "NEG_INF": [],
  "InducingPointAllocator": {
    "_get_quality_function": [
      "self"
    ],
    "allocate_inducing_points": [
      "self",
      "inputs",
      "covar_module",
      "num_inducing",
      "input_batch_shape"
    ]
  },
  "QualityFunction": {
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "UnitQualityFunction": {
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "ExpectedImprovementQualityFunction": {
    "__init__": [
      "self",
      "model",
      "maximize"
    ],
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "GreedyVarianceReduction": {
    "_get_quality_function": [
      "self"
    ]
  },
  "GreedyImprovementReduction": {
    "__init__": [
      "self",
      "model",
      "maximize"
    ],
    "_get_quality_function": [
      "self"
    ]
  },
  "_pivoted_cholesky_init": [
    "train_inputs",
    "kernel_matrix",
    "max_length",
    "quality_scores",
    "epsilon"
  ],
  "get_rounding_input_transform": [
    "one_hot_bounds",
    "integer_indices",
    "categorical_features",
    "initialization",
    "return_numeric",
    "approximate"
  ],
  "lognorm_to_norm": [
    "mu",
    "Cov"
  ],
  "norm_to_lognorm": [
    "mu",
    "Cov"
  ],
  "norm_to_lognorm_mean": [
    "mu",
    "var"
  ],
  "norm_to_lognorm_variance": [
    "mu",
    "var"
  ],
  "expand_and_copy_tensor": [
    "X",
    "batch_shape"
  ],
  "subset_transform": [
    "transform"
  ],
  "interaction_features": [
    "X"
  ],
  "nanstd": [
    "X",
    "dim",
    "keepdim"
  ],
  "kumaraswamy_warp": [
    "X",
    "c0",
    "c1",
    "eps"
  ],
  "inv_kumaraswamy_warp": [
    "X",
    "c0",
    "c1",
    "eps"
  ],
  "_allclose": [
    "input",
    "other"
  ],
  "InputTransform": {
    "forward": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ],
    "preprocess_transform": [
      "self",
      "X"
    ]
  },
  "BatchBroadcastedInputTransform": {
    "__init__": [
      "self",
      "transforms",
      "broadcast_index"
    ],
    "transform": [
      "self",
      "X"
    ],
    "untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ],
    "preprocess_transform": [
      "self",
      "X"
    ],
    "_Xs_and_transforms": [
      "self",
      "X"
    ]
  },
  "ChainedInputTransform": {
    "__init__": [
      "self"
    ],
    "transform": [
      "self",
      "X"
    ],
    "untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ],
    "preprocess_transform": [
      "self",
      "X"
    ]
  },
  "ReversibleInputTransform": {
    "transform": [
      "self",
      "X"
    ],
    "untransform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "_untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ]
  },
  "AffineInputTransform": {
    "__init__": [
      "self",
      "d",
      "coefficient",
      "offset",
      "indices",
      "batch_shape",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "reverse"
    ],
    "coefficient": [
      "self"
    ],
    "offset": [
      "self"
    ],
    "learn_coefficients": [
      "self",
      "value"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "_untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ],
    "_check_shape": [
      "self",
      "X"
    ],
    "_to": [
      "self",
      "X"
    ],
    "_update_coefficients": [
      "self",
      "X"
    ]
  },
  "Normalize": {
    "__init__": [
      "self",
      "d",
      "indices",
      "bounds",
      "batch_shape",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "reverse",
      "min_range",
      "learn_bounds",
      "almost_zero",
      "center"
    ],
    "ranges": [
      "self"
    ],
    "mins": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "learn_bounds": [
      "self"
    ],
    "_update_coefficients": [
      "self",
      "X"
    ],
    "get_init_args": [
      "self"
    ]
  },
  "InputStandardize": {
    "__init__": [
      "self",
      "d",
      "indices",
      "batch_shape",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "reverse",
      "min_std"
    ],
    "stds": [
      "self"
    ],
    "means": [
      "self"
    ],
    "_update_coefficients": [
      "self",
      "X"
    ]
  },
  "Round": {
    "__init__": [
      "self",
      "integer_indices",
      "categorical_features",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "approximate",
      "tau"
    ],
    "transform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ],
    "get_init_args": [
      "self"
    ]
  },
  "Log10": {
    "__init__": [
      "self",
      "indices",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "reverse"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "_untransform": [
      "self",
      "X"
    ]
  },
  "Warp": {
    "_min_concentration_level": [],
    "__init__": [
      "self",
      "d",
      "indices",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize",
      "reverse",
      "eps",
      "concentration1_prior",
      "concentration0_prior",
      "batch_shape",
      "bounds"
    ],
    "_set_concentration": [
      "self",
      "i",
      "value"
    ],
    "_warp_transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "_untransform": [
      "self",
      "X"
    ],
    "_warp_untransform": [
      "self",
      "X"
    ]
  },
  "AppendFeatures": {
    "__init__": [
      "self",
      "feature_set",
      "f",
      "indices",
      "fkwargs",
      "skip_expand",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "InteractionFeatures": {
    "__init__": [
      "self",
      "indices"
    ]
  },
  "FilterFeatures": {
    "__init__": [
      "self",
      "feature_indices",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize"
    ],
    "transform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ]
  },
  "InputPerturbation": {
    "__init__": [
      "self",
      "perturbation_set",
      "bounds",
      "indices",
      "multiplicative",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "batch_shape": [
      "self"
    ],
    "_expanded_perturbations": [
      "self",
      "X"
    ]
  },
  "NumericToCategoricalEncoding": {
    "__init__": [
      "self",
      "dim",
      "categorical_features",
      "encoders",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize"
    ],
    "transform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ]
  },
  "OneHotToNumeric": {
    "__init__": [
      "self",
      "dim",
      "categorical_features",
      "transform_on_train",
      "transform_on_eval",
      "transform_on_fantasize"
    ],
    "transform": [
      "self",
      "X"
    ],
    "untransform": [
      "self",
      "X"
    ],
    "equals": [
      "self",
      "other"
    ]
  },
  "OutcomeTransform": {
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "_is_linear": [
      "self"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "ChainedOutcomeTransform": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "_is_linear": [
      "self"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "Standardize": {
    "__init__": [
      "self",
      "m",
      "outputs",
      "batch_shape",
      "min_stdv"
    ],
    "_get_per_input_means_stdvs": [
      "self",
      "X",
      "include_stdvs_sq"
    ],
    "_validate_training_inputs": [
      "self",
      "Y",
      "Yvar"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "_is_linear": [
      "self"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "StratifiedStandardize": {
    "__init__": [
      "self",
      "stratification_idx",
      "observed_task_values",
      "all_task_values",
      "batch_shape",
      "min_stdv",
      "dtype",
      "default_task_value"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "_get_per_input_means_stdvs": [
      "self",
      "X",
      "include_stdvs_sq"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "Log": {
    "__init__": [
      "self",
      "outputs"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "Power": {
    "__init__": [
      "self",
      "power",
      "outputs"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "Bilog": {
    "__init__": [
      "self",
      "outputs"
    ],
    "subset_output": [
      "self",
      "idcs"
    ],
    "forward": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform": [
      "self",
      "Y",
      "Yvar",
      "X"
    ],
    "untransform_posterior": [
      "self",
      "posterior",
      "X"
    ]
  },
  "SPHINX_RST_PATH": [],
  "BOTORCH_LIBRARY_PATH": [],
  "AUTOMODULE_REGEX": [],
  "EXCLUDED_MODULES": [],
  "parse_rst": [
    "rst_filename"
  ],
  "validate_complete_sphinx": [
    "path_to_botorch"
  ],
  "IGNORE_ALWAYS": [],
  "RUN_IF_SMOKE_TEST_IGNORE_IF_STANDARD": [],
  "run_script": [
    "tutorial",
    "timeout_minutes",
    "env"
  ],
  "run_tutorial": [
    "tutorial",
    "smoke_test"
  ],
  "run_tutorials": [
    "repo_dir",
    "include_ignored",
    "smoke_test",
    "name"
  ],
  "parse_requirements": [
    "filepath"
  ],
  "parse_precommit_config": [
    "filepath"
  ],
  "main": [],
  "js_scripts": [],
  "search_js_scripts": [],
  "parse_sphinx": [
    "input_dir",
    "output_dir"
  ],
  "patch_config": [
    "config_file",
    "base_url",
    "disable_algolia"
  ],
  "SCRIPTS_DIR": [],
  "LIB_DIR": [],
  "WEBSITE_DIR": [],
  "DOCS_DIR": [],
  "TUTORIALS_DIR": [],
  "NOTEBOOKS_COMMUNITY_DIR": [],
  "ORGANIZATION": [],
  "PROJECT": [],
  "priorities": [],
  "load_tutorial_metadata": [],
  "load_notebooks_community_metadata": [],
  "load_notebook": [
    "path"
  ],
  "create_folders": [
    "path",
    "is_community"
  ],
  "create_frontmatter": [
    "path",
    "nb_metadata"
  ],
  "create_imports": [],
  "get_current_git_tag": [],
  "create_buttons": [
    "nb_metadata"
  ],
  "handle_image_attachments": [
    "markdown",
    "attachments"
  ],
  "handle_image_paths_found_in_markdown": [
    "markdown",
    "new_img_dir",
    "nb_path"
  ],
  "transform_style_attributes": [
    "markdown"
  ],
  "sanitize_mdx": [
    "mdx"
  ],
  "get_source": [
    "cell"
  ],
  "handle_markdown_cell": [
    "cell",
    "new_img_dir",
    "nb_path"
  ],
  "handle_cell_input": [
    "cell",
    "language"
  ],
  "generate_img_base64_md": [
    "img_as_base64",
    "mime_type",
    "alt_text"
  ],
  "handle_image": [
    "values"
  ],
  "handle_markdown": [
    "values"
  ],
  "handle_pandas": [
    "values"
  ],
  "handle_plain": [
    "values"
  ],
  "handle_plotly": [
    "values",
    "plot_data_folder"
  ],
  "handle_tqdm": [
    "values"
  ],
  "CELL_OUTPUTS_TO_PROCESS": [],
  "aggregate_mdx": [
    "cell_outputs_to_process",
    "plot_data_folder"
  ],
  "prioritize_dtypes": [
    "cell_outputs"
  ],
  "aggregate_images_and_plotly": [
    "prioritized_data_dtype",
    "cell_output",
    "data",
    "plotly_flags",
    "cell_outputs_to_process",
    "i"
  ],
  "aggregate_plain_output": [
    "prioritized_data_dtype",
    "cell_output",
    "data",
    "cell_outputs_to_process",
    "i"
  ],
  "aggregate_output_types": [
    "cell_outputs"
  ],
  "handle_cell_outputs": [
    "cell",
    "plot_data_folder"
  ],
  "handle_code_cell": [
    "cell",
    "plot_data_folder"
  ],
  "transform_notebook": [
    "path",
    "nb_metadata",
    "is_community"
  ],
  "clean_up_directories": [],
  "base_path": [],
  "project": [],
  "copyright": [],
  "author": [],
  "extensions": [],
  "templates_path": [],
  "source_suffix": [],
  "index_doc": [],
  "language": [],
  "exclude_patterns": [],
  "pygments_style": [],
  "autodoc_default_options": [],
  "autodoc_typehints": [],
  "autoclass_content": [],
  "html_theme": [],
  "html_theme_options": [],
  "html_static_path": [],
  "html_css_files": [],
  "html_show_sphinx": [],
  "html_show_copyright": [],
  "htmlhelp_basename": [],
  "latex_elements": [],
  "latex_documents": [],
  "man_pages": [],
  "texinfo_documents": [],
  "epub_title": [],
  "epub_exclude_files": [],
  "todo_include_todos": []
}