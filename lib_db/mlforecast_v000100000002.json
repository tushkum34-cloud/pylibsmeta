{
  "__all__": [],
  "SaveFeatures": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "new_x"
    ],
    "get_features": [
      "self",
      "with_step"
    ]
  },
  "FLAVOR_NAME": [],
  "_MODEL_DATA_SUBPATH": [],
  "get_default_pip_requirements": [],
  "get_default_conda_env": [],
  "save_model": [
    "model",
    "path",
    "conda_env",
    "code_paths",
    "mlflow_model",
    "signature",
    "input_example",
    "pip_requirements",
    "extra_pip_requirements"
  ],
  "log_model": [
    "model",
    "artifact_path",
    "conda_env",
    "code_paths",
    "registered_model_name",
    "signature",
    "input_example",
    "await_registration_for",
    "pip_requirements",
    "extra_pip_requirements"
  ],
  "load_model": [
    "model_uri",
    "dst_path"
  ],
  "_load_pyfunc": [
    "path"
  ],
  "_MLForecastModelWrapper": {
    "__init__": [
      "self",
      "model"
    ],
    "predict": [
      "self",
      "config_df",
      "params"
    ]
  },
  "_pascal2camel": [
    "pascal_str"
  ],
  "_BaseLagTransform": {
    "_get_init_signature": [
      "self"
    ],
    "_set_core_tfm": [
      "self",
      "lag"
    ],
    "_get_name": [
      "self",
      "lag"
    ],
    "transform": [
      "self",
      "ga"
    ],
    "update": [
      "self",
      "ga"
    ],
    "take": [
      "self",
      "idxs"
    ],
    "stack": [
      "transforms"
    ],
    "_lag": [
      "self"
    ],
    "update_samples": [
      "self"
    ]
  },
  "Lag": {
    "__init__": [
      "self",
      "lag"
    ],
    "_set_core_tfm": [
      "self",
      "_lag"
    ],
    "_get_name": [
      "self",
      "lag"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "update_samples": [
      "self"
    ]
  },
  "_RollingBase": {
    "__init__": [
      "self",
      "window_size",
      "min_samples"
    ],
    "update_samples": [
      "self"
    ]
  },
  "RollingMean": {},
  "RollingStd": {},
  "RollingMin": {},
  "RollingMax": {},
  "RollingQuantile": {
    "__init__": [
      "self",
      "p",
      "window_size",
      "min_samples"
    ],
    "_set_core_tfm": [
      "self",
      "lag"
    ]
  },
  "_Seasonal_RollingBase": {
    "__init__": [
      "self",
      "season_length",
      "window_size",
      "min_samples"
    ],
    "update_samples": [
      "self"
    ]
  },
  "SeasonalRollingMean": {},
  "SeasonalRollingStd": {},
  "SeasonalRollingMin": {},
  "SeasonalRollingMax": {},
  "SeasonalRollingQuantile": {
    "__init__": [
      "self",
      "p",
      "season_length",
      "window_size",
      "min_samples"
    ]
  },
  "_ExpandingBase": {
    "__init__": [
      "self"
    ],
    "update_samples": [
      "self"
    ]
  },
  "ExpandingMean": {},
  "ExpandingStd": {},
  "ExpandingMin": {},
  "ExpandingMax": {},
  "ExpandingQuantile": {
    "__init__": [
      "self",
      "p"
    ],
    "update_samples": [
      "self"
    ]
  },
  "ExponentiallyWeightedMean": {
    "__init__": [
      "self",
      "alpha"
    ],
    "update_samples": [
      "self"
    ]
  },
  "Offset": {
    "__init__": [
      "self",
      "tfm",
      "n"
    ],
    "_get_name": [
      "self",
      "lag"
    ],
    "_set_core_tfm": [
      "self",
      "lag"
    ],
    "update_samples": [
      "self"
    ]
  },
  "Combine": {
    "__init__": [
      "self",
      "tfm1",
      "tfm2",
      "operator"
    ],
    "_set_core_tfm": [
      "self",
      "lag"
    ],
    "_get_name": [
      "self",
      "lag"
    ],
    "transform": [
      "self",
      "ga"
    ],
    "update": [
      "self",
      "ga"
    ],
    "update_samples": [
      "self"
    ]
  },
  "transform_exog": [
    "df",
    "lags",
    "lag_transforms",
    "id_col",
    "time_col",
    "num_threads"
  ],
  "date_features_dtypes": [],
  "_build_function_transform_name": [
    "tfm",
    "lag"
  ],
  "_build_lag_transform_name": [
    "tfm",
    "lag"
  ],
  "_build_transform_name": [
    "tfm",
    "lag"
  ],
  "_get_model_name": [
    "model"
  ],
  "_name_models": [
    "current_names"
  ],
  "_as_tuple": [
    "x"
  ],
  "Freq": [],
  "Lags": [],
  "LagTransform": [],
  "LagTransforms": [],
  "DateFeature": [],
  "Models": [],
  "TargetTransform": [],
  "Transforms": [],
  "_parse_transforms": [
    "lags",
    "lag_transforms",
    "namer"
  ],
  "TimeSeries": {
    "__init__": [
      "self",
      "freq",
      "lags",
      "lag_transforms",
      "date_features",
      "num_threads",
      "target_transforms",
      "lag_transforms_namer"
    ],
    "_get_core_lag_tfms": [
      "self"
    ],
    "_date_feature_names": [
      "self"
    ],
    "features": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_fit": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "keep_last_n",
      "weight_col"
    ],
    "_compute_transforms": [
      "self",
      "transforms",
      "updates_only"
    ],
    "_compute_date_feature": [
      "self",
      "dates",
      "feature"
    ],
    "_transform": [
      "self",
      "df",
      "dropna",
      "max_horizon",
      "return_X_y",
      "as_numpy"
    ],
    "fit_transform": [
      "self",
      "data",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "max_horizon",
      "return_X_y",
      "as_numpy",
      "weight_col"
    ],
    "_update_y": [
      "self",
      "new"
    ],
    "_update_features": [
      "self"
    ],
    "_get_raw_predictions": [
      "self"
    ],
    "_get_future_ids": [
      "self",
      "h"
    ],
    "_get_predictions": [
      "self"
    ],
    "_get_features_for_next_step": [
      "self",
      "X_df"
    ],
    "_backup": [
      "self"
    ],
    "_predict_setup": [
      "self"
    ],
    "_predict_recursive": [
      "self",
      "models",
      "horizon",
      "before_predict_callback",
      "after_predict_callback",
      "X_df"
    ],
    "_predict_multi": [
      "self",
      "models",
      "horizon",
      "before_predict_callback",
      "X_df"
    ],
    "_has_ga_target_tfms": [
      "self"
    ],
    "_maybe_subset": [
      "self",
      "idxs"
    ],
    "predict": [
      "self",
      "models",
      "horizon",
      "before_predict_callback",
      "after_predict_callback",
      "X_df",
      "ids"
    ],
    "save": [
      "self",
      "path"
    ],
    "load": [
      "path",
      "protocol"
    ],
    "update": [
      "self",
      "df"
    ]
  },
  "generate_daily_series": [
    "n_series",
    "min_length",
    "max_length",
    "n_static_features",
    "equal_ends",
    "static_as_categorical",
    "with_trend",
    "seed",
    "engine"
  ],
  "generate_prices_for_series": [
    "series",
    "horizon",
    "seed"
  ],
  "PredictionIntervals": {
    "__init__": [
      "self",
      "n_windows",
      "h",
      "method"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_ShortSeriesException": {
    "__init__": [
      "self",
      "idxs"
    ]
  },
  "_add_conformal_distribution_intervals": [
    "fcst_df",
    "cs_df",
    "model_names",
    "level",
    "cs_n_windows",
    "cs_h",
    "n_series",
    "horizon"
  ],
  "_add_conformal_error_intervals": [
    "fcst_df",
    "cs_df",
    "model_names",
    "level",
    "cs_n_windows",
    "cs_h",
    "n_series",
    "horizon"
  ],
  "_get_conformal_method": [
    "method"
  ],
  "MLForecast": {
    "__init__": [
      "self",
      "models",
      "freq",
      "lags",
      "lag_transforms",
      "date_features",
      "num_threads",
      "target_transforms",
      "lag_transforms_namer"
    ],
    "__repr__": [
      "self"
    ],
    "freq": [
      "self"
    ],
    "from_cv": [
      "cls",
      "cv"
    ],
    "preprocess": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "max_horizon",
      "return_X_y",
      "as_numpy",
      "weight_col"
    ],
    "fit_models": [
      "self",
      "X",
      "y"
    ],
    "_conformity_scores": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "max_horizon",
      "n_windows",
      "h",
      "as_numpy"
    ],
    "_invert_transforms_fitted": [
      "self",
      "df"
    ],
    "_extract_X_y": [
      "self",
      "prep",
      "target_col",
      "weight_col"
    ],
    "_compute_fitted_values": [
      "self",
      "base",
      "X",
      "y",
      "id_col",
      "time_col",
      "target_col",
      "max_horizon",
      "weight_col"
    ],
    "fit": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "max_horizon",
      "prediction_intervals",
      "fitted",
      "as_numpy",
      "weight_col"
    ],
    "forecast_fitted_values": [
      "self",
      "level"
    ],
    "make_future_dataframe": [
      "self",
      "h"
    ],
    "get_missing_future": [
      "self",
      "h",
      "X_df"
    ],
    "predict": [
      "self",
      "h",
      "before_predict_callback",
      "after_predict_callback",
      "new_df",
      "level",
      "X_df",
      "ids"
    ],
    "cross_validation": [
      "self",
      "df",
      "n_windows",
      "h",
      "id_col",
      "time_col",
      "target_col",
      "step_size",
      "static_features",
      "dropna",
      "keep_last_n",
      "refit",
      "max_horizon",
      "before_predict_callback",
      "after_predict_callback",
      "prediction_intervals",
      "level",
      "input_size",
      "fitted",
      "as_numpy",
      "weight_col"
    ],
    "cross_validation_fitted_values": [
      "self"
    ],
    "save": [
      "self",
      "path"
    ],
    "load": [
      "path"
    ],
    "update": [
      "self",
      "df"
    ]
  },
  "lightgbm_space": [
    "trial"
  ],
  "xgboost_space": [
    "trial"
  ],
  "catboost_space": [
    "trial"
  ],
  "linear_regression_space": [
    "trial"
  ],
  "ridge_space": [
    "trial"
  ],
  "lasso_space": [
    "trial"
  ],
  "elastic_net_space": [
    "trial"
  ],
  "random_forest_space": [
    "trial"
  ],
  "AutoModel": {
    "__init__": [
      "self",
      "model",
      "config"
    ],
    "__repr__": [
      "self"
    ]
  },
  "AutoLightGBM": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoXGBoost": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoCatboost": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoLinearRegression": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoRidge": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoLasso": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoElasticNet": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoRandomForest": {
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoMLForecast": {
    "__init__": [
      "self",
      "models",
      "freq",
      "season_length",
      "init_config",
      "fit_config",
      "num_threads"
    ],
    "__repr__": [
      "self"
    ],
    "_seasonality_based_config": [
      "self",
      "h",
      "min_samples",
      "min_value"
    ],
    "fit": [
      "self",
      "df",
      "n_windows",
      "h",
      "num_samples",
      "step_size",
      "input_size",
      "refit",
      "loss",
      "id_col",
      "time_col",
      "target_col",
      "study_kwargs",
      "optimize_kwargs",
      "fitted",
      "prediction_intervals"
    ],
    "predict": [
      "self",
      "h",
      "X_df",
      "level"
    ],
    "save": [
      "self",
      "path"
    ],
    "forecast_fitted_values": [
      "self",
      "level"
    ]
  },
  "_TrialToConfig": [],
  "mlforecast_objective": [
    "df",
    "config_fn",
    "loss",
    "model",
    "freq",
    "n_windows",
    "h",
    "step_size",
    "input_size",
    "refit",
    "id_col",
    "time_col",
    "target_col"
  ],
  "__version__": [],
  "_mape": [
    "y_true",
    "y_pred",
    "ids",
    "_dates"
  ],
  "_rmse": [
    "y_true",
    "y_pred",
    "ids",
    "_dates"
  ],
  "_metric2fn": [],
  "_update": [
    "bst",
    "n"
  ],
  "_predict": [
    "ts",
    "bst",
    "valid",
    "h",
    "before_predict_callback",
    "after_predict_callback"
  ],
  "_update_and_predict": [
    "ts",
    "bst",
    "valid",
    "n",
    "h",
    "before_predict_callback",
    "after_predict_callback"
  ],
  "CVResult": [],
  "LightGBMCV": {
    "__init__": [
      "self",
      "freq",
      "lags",
      "lag_transforms",
      "date_features",
      "num_threads",
      "target_transforms"
    ],
    "__repr__": [
      "self"
    ],
    "setup": [
      "self",
      "df",
      "n_windows",
      "h",
      "id_col",
      "time_col",
      "target_col",
      "step_size",
      "params",
      "static_features",
      "dropna",
      "keep_last_n",
      "weights",
      "metric",
      "input_size"
    ],
    "_single_threaded_partial_fit": [
      "self",
      "metric_values",
      "num_iterations",
      "before_predict_callback",
      "after_predict_callback"
    ],
    "_multithreaded_partial_fit": [
      "self",
      "metric_values",
      "num_iterations",
      "before_predict_callback",
      "after_predict_callback"
    ],
    "partial_fit": [
      "self",
      "num_iterations",
      "before_predict_callback",
      "after_predict_callback"
    ],
    "should_stop": [
      "self",
      "hist",
      "early_stopping_evals",
      "early_stopping_pct"
    ],
    "find_best_iter": [
      "self",
      "hist",
      "early_stopping_evals"
    ],
    "fit": [
      "self",
      "df",
      "n_windows",
      "h",
      "id_col",
      "time_col",
      "target_col",
      "step_size",
      "num_iterations",
      "params",
      "static_features",
      "dropna",
      "keep_last_n",
      "eval_every",
      "weights",
      "metric",
      "verbose_eval",
      "early_stopping_evals",
      "early_stopping_pct",
      "compute_cv_preds",
      "before_predict_callback",
      "after_predict_callback",
      "input_size"
    ],
    "predict": [
      "self",
      "h",
      "before_predict_callback",
      "after_predict_callback",
      "X_df"
    ]
  },
  "BaseTargetTransform": {
    "set_column_names": [
      "self",
      "id_col",
      "time_col",
      "target_col"
    ],
    "update": [
      "self",
      "df"
    ],
    "stack": [
      "transforms"
    ],
    "fit_transform": [
      "self",
      "df"
    ],
    "inverse_transform": [
      "self",
      "df"
    ]
  },
  "_BaseGroupedArrayTargetTransform": {
    "set_num_threads": [
      "self",
      "num_threads"
    ],
    "update": [
      "self",
      "ga"
    ],
    "fit_transform": [
      "self",
      "ga"
    ],
    "inverse_transform": [
      "self",
      "ga"
    ],
    "inverse_transform_fitted": [
      "self",
      "ga"
    ],
    "take": [
      "self",
      "idxs"
    ],
    "stack": [
      "scalers"
    ]
  },
  "Differences": {
    "store_fitted": [],
    "__init__": [
      "self",
      "differences"
    ],
    "fit_transform": [
      "self",
      "ga"
    ],
    "update": [
      "self",
      "ga"
    ],
    "inverse_transform": [
      "self",
      "ga"
    ],
    "inverse_transform_fitted": [
      "self",
      "ga"
    ],
    "take": [
      "self",
      "idxs"
    ],
    "stack": [
      "scalers"
    ]
  },
  "AutoDifferences": {
    "__init__": [
      "self",
      "max_diffs"
    ],
    "fit_transform": [
      "self",
      "ga"
    ],
    "update": [
      "self",
      "ga"
    ],
    "inverse_transform": [
      "self",
      "ga"
    ],
    "inverse_transform_fitted": [
      "self",
      "ga"
    ],
    "take": [
      "self",
      "idxs"
    ]
  },
  "AutoSeasonalDifferences": {
    "__init__": [
      "self",
      "season_length",
      "max_diffs",
      "n_seasons"
    ]
  },
  "AutoSeasonalityAndDifferences": {
    "__init__": [
      "self",
      "max_season_length",
      "max_diffs",
      "n_seasons"
    ]
  },
  "_BaseLocalScaler": {
    "update": [
      "self",
      "ga"
    ],
    "fit_transform": [
      "self",
      "ga"
    ],
    "inverse_transform": [
      "self",
      "ga"
    ],
    "take": [
      "self",
      "idxs"
    ]
  },
  "LocalStandardScaler": {
    "scaler_factory": []
  },
  "LocalMinMaxScaler": {
    "scaler_factory": []
  },
  "LocalRobustScaler": {
    "__init__": [
      "self",
      "scale"
    ]
  },
  "LocalBoxCox": {
    "__init__": [
      "self"
    ]
  },
  "GlobalSklearnTransformer": {
    "__init__": [
      "self",
      "transformer"
    ],
    "fit_transform": [
      "self",
      "df"
    ],
    "inverse_transform": [
      "self",
      "df"
    ],
    "update": [
      "self",
      "df"
    ],
    "stack": [
      "transforms"
    ]
  },
  "_transform_series": [
    "data",
    "indptr",
    "updates_only",
    "lag",
    "func"
  ],
  "GroupedArray": {
    "__init__": [
      "self",
      "data",
      "indptr"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__setitem__": [
      "self",
      "idx",
      "vals"
    ],
    "__copy__": [
      "self"
    ],
    "take": [
      "self",
      "idxs"
    ],
    "apply_transforms": [
      "self",
      "transforms",
      "updates_only"
    ],
    "apply_multithreaded_transforms": [
      "self",
      "transforms",
      "num_threads",
      "updates_only"
    ],
    "expand_target": [
      "self",
      "max_horizon"
    ],
    "take_from_groups": [
      "self",
      "idx"
    ],
    "append": [
      "self",
      "new_data"
    ],
    "append_several": [
      "self",
      "new_sizes",
      "new_values",
      "new_groups"
    ],
    "__repr__": [
      "self"
    ]
  },
  "d": [],
  "WindowInfo": [],
  "DistributedMLForecast": {
    "__init__": [
      "self",
      "models",
      "freq",
      "lags",
      "lag_transforms",
      "date_features",
      "num_threads",
      "target_transforms",
      "engine",
      "num_partitions",
      "lag_transforms_namer"
    ],
    "__repr__": [
      "self"
    ],
    "_preprocess_partition": [
      "part",
      "base_ts",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "window_info",
      "fit_ts_only"
    ],
    "_retrieve_df": [
      "items"
    ],
    "_preprocess_partitions": [
      "self",
      "data",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "window_info",
      "fit_ts_only"
    ],
    "_preprocess": [
      "self",
      "data",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "window_info"
    ],
    "preprocess": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n"
    ],
    "_fit": [
      "self",
      "data",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n",
      "window_info"
    ],
    "fit": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_features",
      "dropna",
      "keep_last_n"
    ],
    "_predict": [
      "items",
      "models",
      "horizon",
      "before_predict_callback",
      "after_predict_callback",
      "X_df",
      "ids",
      "schema"
    ],
    "_get_predict_schema": [
      "self"
    ],
    "predict": [
      "self",
      "h",
      "before_predict_callback",
      "after_predict_callback",
      "X_df",
      "new_df",
      "ids"
    ],
    "cross_validation": [
      "self",
      "df",
      "n_windows",
      "h",
      "id_col",
      "time_col",
      "target_col",
      "step_size",
      "static_features",
      "dropna",
      "keep_last_n",
      "refit",
      "before_predict_callback",
      "after_predict_callback",
      "input_size"
    ],
    "_save_ts": [
      "items",
      "path"
    ],
    "save": [
      "self",
      "path"
    ],
    "_load_ts": [
      "paths",
      "protocol"
    ],
    "load": [
      "path",
      "engine"
    ],
    "_update": [
      "items",
      "new_df"
    ],
    "update": [
      "self",
      "df"
    ],
    "to_local": [
      "self"
    ]
  },
  "RayLGBMForecast": {
    "model_": [
      "self"
    ]
  },
  "RayXGBForecast": {
    "model_": [
      "self"
    ]
  },
  "DaskLGBMForecast": {
    "model_": [
      "self"
    ]
  },
  "DaskXGBForecast": {
    "model_": [
      "self"
    ]
  },
  "SparkLGBMForecast": {
    "_pre_fit": [
      "self",
      "target_col"
    ],
    "extract_local_model": [
      "self",
      "trained_model"
    ]
  },
  "SparkXGBForecast": {
    "_pre_fit": [
      "self",
      "target_col"
    ],
    "extract_local_model": [
      "self",
      "trained_model"
    ]
  }
}