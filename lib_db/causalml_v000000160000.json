{
  "logger": [],
  "PropensityModel": {
    "__init__": [
      "self",
      "clip_bounds",
      "calibrate"
    ],
    "_model": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "LogisticRegressionPropensityModel": {
    "_model": [
      "self"
    ]
  },
  "ElasticNetPropensityModel": {},
  "GradientBoostedPropensityModel": {
    "__init__": [
      "self",
      "early_stop",
      "clip_bounds",
      "calibrate"
    ],
    "_model": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "stop_val_size"
    ]
  },
  "compute_propensity_score": [
    "X",
    "treatment",
    "p_model",
    "X_pred",
    "treatment_pred",
    "calibrate_p",
    "clip_bounds"
  ],
  "__all__": [],
  "smd": [
    "feature",
    "treatment"
  ],
  "create_table_one": [
    "data",
    "treatment_col",
    "features",
    "with_std",
    "with_counts"
  ],
  "NearestNeighborMatch": {
    "__init__": [
      "self",
      "caliper",
      "replace",
      "ratio",
      "shuffle",
      "treatment_to_control",
      "random_state",
      "n_jobs"
    ],
    "match": [
      "self",
      "data",
      "treatment_col",
      "score_cols"
    ],
    "match_by_group": [
      "self",
      "data",
      "treatment_col",
      "score_cols",
      "groupby_col"
    ]
  },
  "MatchOptimizer": {
    "__init__": [
      "self",
      "treatment_col",
      "ps_col",
      "user_col",
      "matching_covariates",
      "max_smd",
      "max_deviation",
      "caliper_range",
      "max_pihat_range",
      "max_iter_per_param",
      "min_users_per_group",
      "smd_cols",
      "dev_cols_transformations",
      "dev_factor",
      "verbose"
    ],
    "single_match": [
      "self",
      "score_cols",
      "pihat_threshold",
      "caliper"
    ],
    "check_table_one": [
      "self",
      "tableone",
      "matched",
      "score_cols",
      "pihat_threshold",
      "caliper"
    ],
    "match_and_check": [
      "self",
      "score_cols",
      "pihat_threshold",
      "caliper"
    ],
    "search_best_match": [
      "self",
      "df"
    ]
  },
  "NAN_INT": [],
  "LabelEncoder": {
    "__init__": [
      "self",
      "min_obs"
    ],
    "__repr__": [
      "self"
    ],
    "_get_label_encoder_and_max": [
      "self",
      "x"
    ],
    "_transform_col": [
      "self",
      "x",
      "i"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "OneHotEncoder": {
    "__init__": [
      "self",
      "min_obs"
    ],
    "__repr__": [
      "self"
    ],
    "_transform_col": [
      "self",
      "x",
      "i"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "load_data": [
    "data",
    "features",
    "transformations"
  ],
  "KEY_GENERATED_DATA": [],
  "KEY_ACTUAL": [],
  "RANDOM_SEED": [],
  "get_synthetic_preds": [
    "synthetic_data_func",
    "n",
    "estimators"
  ],
  "get_synthetic_summary": [
    "synthetic_data_func",
    "n",
    "k",
    "estimators"
  ],
  "scatter_plot_summary": [
    "synthetic_summary",
    "k",
    "drop_learners",
    "drop_cols"
  ],
  "bar_plot_summary": [
    "synthetic_summary",
    "k",
    "drop_learners",
    "drop_cols",
    "sort_cols"
  ],
  "distr_plot_single_sim": [
    "synthetic_preds",
    "kind",
    "drop_learners",
    "bins",
    "histtype",
    "alpha",
    "linewidth",
    "bw_method"
  ],
  "scatter_plot_single_sim": [
    "synthetic_preds"
  ],
  "get_synthetic_preds_holdout": [
    "synthetic_data_func",
    "n",
    "valid_size",
    "estimators"
  ],
  "get_synthetic_summary_holdout": [
    "synthetic_data_func",
    "n",
    "valid_size",
    "k"
  ],
  "scatter_plot_summary_holdout": [
    "train_summary",
    "validation_summary",
    "k",
    "label",
    "drop_learners",
    "drop_cols"
  ],
  "bar_plot_summary_holdout": [
    "train_summary",
    "validation_summary",
    "k",
    "drop_learners",
    "drop_cols"
  ],
  "get_synthetic_auuc": [
    "synthetic_preds",
    "drop_learners",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "plot"
  ],
  "_f_linear": [
    "x"
  ],
  "_f_quadratic": [
    "x"
  ],
  "_f_cubic": [
    "x"
  ],
  "_f_relu": [
    "x"
  ],
  "_f_sin": [
    "x"
  ],
  "_f_cos": [
    "x"
  ],
  "_generate_splines": [
    "n_functions",
    "n_initial_points",
    "s",
    "x_min",
    "x_max",
    "y_min",
    "y_max",
    "random_seed"
  ],
  "_standardize": [
    "x"
  ],
  "_fixed_transformation": [
    "fs",
    "x",
    "f_index"
  ],
  "_random_transformation": [
    "fs",
    "x"
  ],
  "_softmax": [
    "z",
    "p",
    "xb"
  ],
  "make_uplift_classification_logistic": [
    "n_samples",
    "treatment_name",
    "y_name",
    "n_classification_features",
    "n_classification_informative",
    "n_classification_redundant",
    "n_classification_repeated",
    "n_uplift_dict",
    "n_mix_informative_uplift_dict",
    "delta_uplift_dict",
    "positive_class_proportion",
    "random_seed",
    "feature_association_list",
    "random_select_association",
    "error_std"
  ],
  "make_uplift_classification": [
    "n_samples",
    "treatment_name",
    "y_name",
    "n_classification_features",
    "n_classification_informative",
    "n_classification_redundant",
    "n_classification_repeated",
    "n_uplift_increase_dict",
    "n_uplift_decrease_dict",
    "delta_uplift_increase_dict",
    "delta_uplift_decrease_dict",
    "n_uplift_increase_mix_informative_dict",
    "n_uplift_decrease_mix_informative_dict",
    "positive_class_proportion",
    "random_seed"
  ],
  "SemiSynthDataGenerator": {
    "__init__": [
      "self",
      "Q",
      "gamma",
      "train_frac",
      "val_frac",
      "B",
      "maxdepths",
      "lambdas",
      "M",
      "early_stopping_rounds",
      "verbose"
    ],
    "fit": [
      "self",
      "X",
      "w",
      "y",
      "initial_taus"
    ],
    "generate": [
      "self",
      "K",
      "n"
    ]
  },
  "continuous_objective": [
    "x",
    "Q",
    "a",
    "d"
  ],
  "deviance": [
    "y",
    "pred"
  ],
  "logit": [
    "x"
  ],
  "logistic": [
    "x"
  ],
  "binary_objective": [
    "x",
    "w",
    "y"
  ],
  "negative_gradient": [
    "y",
    "pred"
  ],
  "miu_m": [
    "y",
    "w",
    "X",
    "real_tau",
    "miu_m_minus_1",
    "val_y",
    "val_w",
    "val_X",
    "max_depth",
    "lambda_"
  ],
  "miu": [
    "y",
    "w",
    "X",
    "real_tau",
    "val_y",
    "val_w",
    "val_X",
    "max_depth",
    "lambda_",
    "M",
    "early_stopping_rounds",
    "verbose"
  ],
  "miu_cv": [
    "y",
    "w",
    "X",
    "real_tau",
    "train_frac",
    "val_frac",
    "B",
    "max_depths",
    "lambdas",
    "M",
    "early_stopping_rounds",
    "verbose",
    "n_jobs"
  ],
  "miu_row": [
    "row",
    "y",
    "w",
    "X",
    "real_tau",
    "train_frac",
    "val_frac",
    "M",
    "early_stopping_rounds",
    "verbose"
  ],
  "synthetic_data": [
    "mode",
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "simulate_nuisance_and_easy_treatment": [
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "simulate_randomized_trial": [
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "simulate_easy_propensity_difficult_baseline": [
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "simulate_unrelated_treatment_control": [
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "simulate_hidden_confounder": [
    "n",
    "p",
    "sigma",
    "adj"
  ],
  "SUMMARY_COLS": [],
  "one_sided": [
    "alpha",
    "p",
    "treatment"
  ],
  "alignment": [
    "alpha",
    "p",
    "treatment"
  ],
  "one_sided_att": [
    "alpha",
    "p",
    "treatment"
  ],
  "alignment_att": [
    "alpha",
    "p",
    "treatment"
  ],
  "Sensitivity": {
    "__init__": [
      "self",
      "df",
      "inference_features",
      "p_col",
      "treatment_col",
      "outcome_col",
      "learner"
    ],
    "get_prediction": [
      "self",
      "X",
      "p",
      "treatment",
      "y"
    ],
    "get_ate_ci": [
      "self",
      "X",
      "p",
      "treatment",
      "y"
    ],
    "get_class_object": [
      "method_name"
    ],
    "sensitivity_analysis": [
      "self",
      "methods",
      "sample_size",
      "confound",
      "alpha_range"
    ],
    "summary": [
      "self",
      "method"
    ],
    "sensitivity_estimate": [
      "self"
    ]
  },
  "SensitivityPlaceboTreatment": {
    "__init__": [
      "self"
    ],
    "sensitivity_estimate": [
      "self"
    ]
  },
  "SensitivityRandomCause": {
    "__init__": [
      "self"
    ],
    "sensitivity_estimate": [
      "self"
    ]
  },
  "SensitivityRandomReplace": {
    "__init__": [
      "self"
    ],
    "sensitivity_estimate": [
      "self"
    ]
  },
  "SensitivitySubsetData": {
    "__init__": [
      "self"
    ],
    "sensitivity_estimate": [
      "self"
    ]
  },
  "SensitivitySelectionBias": {
    "__init__": [
      "self"
    ],
    "causalsens": [
      "self"
    ],
    "summary": [
      "self",
      "method"
    ],
    "plot": [
      "sens_df",
      "partial_rsqs_df",
      "type",
      "ci",
      "partial_rsqs"
    ],
    "partial_rsqs_confounding": [
      "sens_df",
      "feature_name",
      "partial_rsqs_value",
      "range"
    ]
  },
  "RANDOM_COL": [],
  "plot": [
    "df",
    "kind",
    "tmle",
    "n",
    "figsize",
    "ci",
    "plot_chance_level",
    "chance_level_kw",
    "ax"
  ],
  "get_cumlift": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "random_seed"
  ],
  "get_cumgain": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "random_seed"
  ],
  "get_qini": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "random_seed"
  ],
  "get_tmlegain": [
    "df",
    "inference_col",
    "learner",
    "outcome_col",
    "treatment_col",
    "p_col",
    "n_segment",
    "cv",
    "ci"
  ],
  "get_tmleqini": [
    "df",
    "inference_col",
    "learner",
    "outcome_col",
    "treatment_col",
    "p_col",
    "n_segment",
    "cv",
    "ci",
    "normalize"
  ],
  "plot_gain": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "random_seed",
    "n",
    "figsize",
    "ax"
  ],
  "plot_lift": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "random_seed",
    "n",
    "figsize"
  ],
  "plot_qini": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "random_seed",
    "n",
    "figsize",
    "ax"
  ],
  "plot_tmlegain": [
    "df",
    "inference_col",
    "learner",
    "outcome_col",
    "treatment_col",
    "p_col",
    "n_segment",
    "cv",
    "ci",
    "figsize"
  ],
  "plot_tmleqini": [
    "df",
    "inference_col",
    "learner",
    "outcome_col",
    "treatment_col",
    "p_col",
    "n_segment",
    "cv",
    "ci",
    "figsize"
  ],
  "auuc_score": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "tmle"
  ],
  "qini_score": [
    "df",
    "outcome_col",
    "treatment_col",
    "treatment_effect_col",
    "normalize",
    "tmle"
  ],
  "plot_ps_diagnostics": [
    "df",
    "covariate_col",
    "treatment_col",
    "p_col",
    "bal_tol"
  ],
  "_plot_std_diffs": [
    "diffs_pre",
    "num_unbal_pre",
    "diffs_post",
    "num_unbal_post",
    "bal_tol"
  ],
  "get_simple_iptw": [
    "W",
    "propensity_score"
  ],
  "get_std_diffs": [
    "X",
    "W",
    "weight",
    "weighted",
    "numeric_threshold"
  ],
  "_get_numeric_vars": [
    "X",
    "threshold"
  ],
  "_get_mean_var": [
    "X"
  ],
  "_get_wmean_wvar": [
    "X",
    "weight"
  ],
  "logloss": [
    "y",
    "p"
  ],
  "classification_metrics": [
    "y",
    "p",
    "w",
    "metrics"
  ],
  "ape": [
    "y",
    "p"
  ],
  "mape": [
    "y",
    "p"
  ],
  "smape": [
    "y",
    "p"
  ],
  "rmse": [
    "y",
    "p"
  ],
  "gini": [
    "y",
    "p"
  ],
  "regression_metrics": [
    "y",
    "p",
    "w",
    "metrics"
  ],
  "EPS": [],
  "PolicyLearner": {
    "__init__": [
      "self",
      "outcome_learner",
      "treatment_learner",
      "policy_learner",
      "clip_bounds",
      "n_fold",
      "random_state",
      "calibration"
    ],
    "__repr__": [
      "self"
    ],
    "_outcome_estimate": [
      "self",
      "X",
      "w",
      "y"
    ],
    "_treatment_estimate": [
      "self",
      "X",
      "w"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "dhat"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "get_treatment_costs": [
    "treatment",
    "control_name",
    "cc_dict",
    "ic_dict"
  ],
  "get_actual_value": [
    "treatment",
    "observed_outcome",
    "conversion_value",
    "conditions",
    "conversion_cost",
    "impression_cost"
  ],
  "get_uplift_best": [
    "cate",
    "conditions"
  ],
  "CounterfactualUnitSelector": {
    "__init__": [
      "self",
      "learner",
      "nevertaker_payoff",
      "alwaystaker_payoff",
      "complier_payoff",
      "defier_payoff",
      "organic_conversion"
    ],
    "fit": [
      "self",
      "data",
      "treatment",
      "outcome"
    ],
    "predict": [
      "self",
      "data",
      "treatment",
      "outcome"
    ],
    "_gain_equality_check": [
      "self"
    ],
    "_make_segments": [
      "data",
      "treatment",
      "outcome"
    ],
    "_fit_segment_model": [
      "self",
      "data",
      "treatment",
      "outcome"
    ],
    "_fit_condprob_models": [
      "self",
      "data",
      "treatment",
      "outcome"
    ],
    "_get_exact_benefit": [
      "self",
      "data",
      "treatment",
      "outcome"
    ],
    "_obj_func_midp": [
      "self",
      "data",
      "treatment",
      "outcome"
    ]
  },
  "get_pns_bounds": [
    "data_exp",
    "data_obs",
    "T",
    "Y",
    "type"
  ],
  "CounterfactualValueEstimator": {
    "__init__": [
      "self",
      "treatment",
      "control_name",
      "treatment_names",
      "y_proba",
      "cate",
      "value",
      "conversion_cost",
      "impression_cost"
    ],
    "predict_best": [
      "self"
    ],
    "predict_counterfactuals": [
      "self"
    ],
    "_get_counterfactuals": [
      "self"
    ],
    "_get_counterfactual_values": [
      "self"
    ]
  },
  "IVRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "w"
    ],
    "predict": [
      "self"
    ]
  },
  "BaseDRIVLearner": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "assignment",
      "treatment",
      "y",
      "p",
      "pZ",
      "seed",
      "calibrate"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "assignment",
      "treatment",
      "y",
      "p",
      "pZ",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose",
      "seed",
      "calibrate"
    ],
    "estimate_ate": [
      "self",
      "X",
      "assignment",
      "treatment",
      "y",
      "p",
      "pZ",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "seed",
      "calibrate"
    ],
    "bootstrap": [
      "self",
      "X",
      "assignment",
      "treatment",
      "y",
      "p",
      "pZ",
      "size",
      "seed"
    ],
    "get_importance": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "method",
      "normalize",
      "test_size",
      "random_state"
    ],
    "get_shap_values": [
      "self",
      "X",
      "model_tau_feature",
      "tau",
      "features"
    ],
    "plot_importance": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "method",
      "normalize",
      "test_size",
      "random_state"
    ],
    "plot_shap_values": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "shap_dict"
    ],
    "plot_shap_dependence": [
      "self",
      "treatment_group",
      "feature_idx",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "shap_dict",
      "interaction_idx"
    ]
  },
  "BaseDRIVRegressor": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ]
  },
  "XGBDRIVRegressor": {
    "__init__": [
      "self",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseRLearner": {
    "__init__": [
      "self",
      "learner",
      "outcome_learner",
      "effect_learner",
      "propensity_learner",
      "ate_alpha",
      "control_name",
      "n_fold",
      "random_state",
      "cv_n_jobs"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "sample_weight",
      "verbose"
    ],
    "predict": [
      "self",
      "X",
      "p"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "sample_weight",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "sample_weight",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "pretrain"
    ]
  },
  "BaseRRegressor": {
    "__init__": [
      "self",
      "learner",
      "outcome_learner",
      "effect_learner",
      "propensity_learner",
      "ate_alpha",
      "control_name",
      "n_fold",
      "random_state"
    ]
  },
  "BaseRClassifier": {
    "__init__": [
      "self",
      "outcome_learner",
      "effect_learner",
      "propensity_learner",
      "ate_alpha",
      "control_name",
      "n_fold",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "sample_weight",
      "verbose"
    ],
    "predict": [
      "self",
      "X",
      "p"
    ]
  },
  "XGBRRegressor": {
    "__init__": [
      "self",
      "early_stopping",
      "test_size",
      "early_stopping_rounds",
      "effect_learner_objective",
      "effect_learner_n_estimators",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "sample_weight",
      "verbose"
    ]
  },
  "BaseLearner": {
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size"
    ],
    "bootstrap": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "size"
    ],
    "_format_p": [
      "p",
      "t_groups"
    ],
    "_set_propensity_models": [
      "self",
      "X",
      "treatment",
      "y"
    ],
    "get_importance": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "method",
      "normalize",
      "test_size",
      "random_state"
    ],
    "get_shap_values": [
      "self",
      "X",
      "model_tau_feature",
      "tau",
      "features"
    ],
    "plot_importance": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "method",
      "normalize",
      "test_size",
      "random_state"
    ],
    "plot_shap_values": [
      "self",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "shap_dict"
    ],
    "plot_shap_dependence": [
      "self",
      "treatment_group",
      "feature_idx",
      "X",
      "tau",
      "model_tau_feature",
      "features",
      "shap_dict",
      "interaction_idx"
    ]
  },
  "logit_tmle": [
    "x",
    "y",
    "a",
    "h0",
    "h1"
  ],
  "logit_tmle_grad": [
    "x",
    "y",
    "a",
    "h0",
    "h1"
  ],
  "logit_tmle_hess": [
    "x",
    "y",
    "a",
    "h0",
    "h1"
  ],
  "simple_tmle": [
    "y",
    "w",
    "q0w",
    "q1w",
    "p",
    "alpha"
  ],
  "TMLELearner": {
    "__init__": [
      "self",
      "learner",
      "ate_alpha",
      "control_name",
      "cv"
    ],
    "__repr__": [
      "self"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "segment",
      "return_ci"
    ]
  },
  "convert_pd_to_np": [],
  "check_treatment_vector": [
    "treatment",
    "control_name"
  ],
  "check_p_conditions": [
    "p",
    "t_groups"
  ],
  "check_explain_conditions": [
    "method",
    "models",
    "X",
    "treatment",
    "y"
  ],
  "clean_xgboost_objective": [
    "objective"
  ],
  "get_xgboost_objective_metric": [
    "objective"
  ],
  "get_weighted_variance": [
    "x",
    "sample_weight"
  ],
  "StatsmodelsOLS": {
    "__init__": [
      "self",
      "cov_type",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "BaseSLearner": {
    "__init__": [
      "self",
      "learner",
      "ate_alpha",
      "control_name"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "pretrain"
    ]
  },
  "BaseSRegressor": {
    "__init__": [
      "self",
      "learner",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseSClassifier": {
    "__init__": [
      "self",
      "learner",
      "ate_alpha",
      "control_name"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ]
  },
  "LRSRegressor": {
    "__init__": [
      "self",
      "ate_alpha",
      "control_name"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "pretrain"
    ]
  },
  "VALID_METHODS": [],
  "Explainer": {
    "__init__": [
      "self",
      "method",
      "control_name",
      "X",
      "tau",
      "classes",
      "model_tau",
      "features",
      "normalize",
      "test_size",
      "random_state",
      "override_checks",
      "r_learners"
    ],
    "check_conditions": [
      "self"
    ],
    "create_feature_names": [
      "self"
    ],
    "build_new_tau_models": [
      "self"
    ],
    "get_importance": [
      "self"
    ],
    "default_importance": [
      "self"
    ],
    "perm_importance": [
      "self"
    ],
    "get_shap_values": [
      "self"
    ],
    "plot_importance": [
      "self",
      "importance_dict",
      "title_prefix",
      "figsize"
    ],
    "plot_shap_values": [
      "self",
      "shap_dict"
    ],
    "plot_shap_dependence": [
      "self",
      "treatment_group",
      "feature_idx",
      "shap_dict",
      "interaction_idx"
    ]
  },
  "BaseTLearner": {
    "__init__": [
      "self",
      "learner",
      "control_learner",
      "treatment_learner",
      "ate_alpha",
      "control_name"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "pretrain"
    ]
  },
  "BaseTRegressor": {
    "__init__": [
      "self",
      "learner",
      "control_learner",
      "treatment_learner",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseTClassifier": {
    "__init__": [
      "self",
      "learner",
      "control_learner",
      "treatment_learner",
      "ate_alpha",
      "control_name"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ]
  },
  "XGBTRegressor": {
    "__init__": [
      "self",
      "ate_alpha",
      "control_name"
    ]
  },
  "MLPTRegressor": {
    "__init__": [
      "self",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseXLearner": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "control_effect_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "pretrain"
    ]
  },
  "BaseXRegressor": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "control_effect_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseXClassifier": {
    "__init__": [
      "self",
      "outcome_learner",
      "effect_learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "control_effect_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ]
  },
  "BaseDRLearner": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "seed"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "return_components",
      "verbose",
      "seed"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "bootstrap_ci",
      "n_bootstraps",
      "bootstrap_size",
      "seed",
      "pretrain"
    ]
  },
  "BaseDRRegressor": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ]
  },
  "BaseDRClassifier": {
    "__init__": [
      "self",
      "learner",
      "control_outcome_learner",
      "treatment_outcome_learner",
      "treatment_effect_learner",
      "ate_alpha",
      "control_name"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components",
      "verbose"
    ]
  },
  "XGBDRRegressor": {
    "__init__": [
      "self",
      "ate_alpha",
      "control_name"
    ]
  },
  "DragonNet": {
    "__init__": [
      "self",
      "neurons_per_layer",
      "targeted_reg",
      "ratio",
      "val_split",
      "batch_size",
      "epochs",
      "learning_rate",
      "momentum",
      "reg_l2",
      "use_adam",
      "adam_epochs",
      "adam_learning_rate",
      "loss_func",
      "verbose"
    ],
    "make_dragonnet": [
      "self",
      "input_dim"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict_propensity": [
      "self",
      "X"
    ],
    "predict_tau": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p",
      "return_components"
    ],
    "save": [
      "self",
      "h5_filepath"
    ],
    "load": [
      "self",
      "h5_filepath",
      "ratio",
      "dragonnet_loss"
    ]
  },
  "binary_classification_loss": [
    "concat_true",
    "concat_pred"
  ],
  "regression_loss": [
    "concat_true",
    "concat_pred"
  ],
  "dragonnet_loss_binarycross": [
    "concat_true",
    "concat_pred"
  ],
  "treatment_accuracy": [
    "concat_true",
    "concat_pred"
  ],
  "track_epsilon": [
    "concat_true",
    "concat_pred"
  ],
  "make_tarreg_loss": [
    "ratio",
    "dragonnet_loss"
  ],
  "EpsilonLayer": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "cat_group": [
    "dfx",
    "kpix",
    "n_group"
  ],
  "cat_transform": [
    "dfx",
    "kpix",
    "kpi1"
  ],
  "cv_fold_index": [
    "n",
    "i",
    "k",
    "random_seed"
  ],
  "cat_continuous": [
    "x",
    "granularity"
  ],
  "kpi_transform": [
    "dfx",
    "kpi_combo",
    "kpi_combo_new"
  ],
  "get_tree_leaves_mask": [
    "tree"
  ],
  "timeit": [
    "exclude_kwargs"
  ],
  "uplift_tree_string": [
    "decisionTree",
    "x_names"
  ],
  "uplift_tree_plot": [
    "decisionTree",
    "x_names"
  ],
  "plot_dist_tree_leaves_values": [
    "tree",
    "title",
    "figsize",
    "fontsize"
  ],
  "_MPLCTreeExporter": {
    "__init__": [
      "self",
      "causal_tree",
      "max_depth",
      "feature_names",
      "class_names",
      "label",
      "filled",
      "impurity",
      "groups_count",
      "treatment_groups",
      "node_ids",
      "proportion",
      "rounded",
      "precision",
      "fontsize"
    ],
    "node_to_str": [
      "self",
      "tree",
      "node_id",
      "criterion"
    ],
    "get_color": [
      "self",
      "value"
    ],
    "get_fill_color": [
      "self",
      "tree",
      "node_id"
    ]
  },
  "plot_causal_tree": [
    "causal_tree"
  ],
  "CAUSAL_TREES_CRITERIA": [],
  "get_check_y_params": [],
  "BaseCausalDecisionTree": {
    "__init__": [
      "self",
      "min_group_samples"
    ],
    "_support_missing_values": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input",
      "X_idx_sorted"
    ]
  },
  "CausalTreeRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "sample_weight",
      "check_input",
      "prepare_data"
    ],
    "predict": [
      "self",
      "X",
      "with_outcomes",
      "check_input"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "return_ci",
      "n_bootstraps",
      "bootstrap_size",
      "n_jobs",
      "verbose"
    ],
    "estimate_ate": [
      "self",
      "X",
      "treatment",
      "y"
    ],
    "bootstrap_pool": [
      "self",
      "X",
      "treatment",
      "y",
      "n_bootstraps",
      "bootstrap_size",
      "n_jobs",
      "verbose"
    ],
    "bootstrap": [
      "self",
      "X",
      "treatment",
      "y",
      "sample_size",
      "seed"
    ],
    "_prepare_data": [
      "self",
      "X",
      "treatment",
      "y"
    ],
    "_count_groups_distribution": [
      "self",
      "X",
      "treatment"
    ]
  },
  "_parallel_build_trees": [
    "tree",
    "forest",
    "X",
    "treatment",
    "y",
    "sample_weight",
    "tree_idx",
    "n_trees",
    "verbose",
    "class_weight",
    "n_samples_bootstrap"
  ],
  "CausalRandomForestRegressor": {
    "__init__": [
      "self",
      "n_estimators"
    ],
    "_fit": [
      "self",
      "X",
      "treatment",
      "y",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X",
      "with_outcomes"
    ],
    "calculate_error": [
      "self",
      "X_train",
      "X_test",
      "inbag",
      "calibrate",
      "memory_constrained",
      "memory_limit"
    ]
  },
  "DTYPE": [],
  "DOUBLE": [],
  "INT": [],
  "CRITERIA_CLF": [],
  "CRITERIA_REG": [],
  "DENSE_SPLITTERS": [],
  "SPARSE_SPLITTERS": [],
  "BaseDecisionTree": {
    "__init__": [
      "self"
    ],
    "get_depth": [
      "self"
    ],
    "get_n_leaves": [
      "self"
    ],
    "_support_missing_values": [
      "self",
      "X"
    ],
    "_compute_missing_values_in_feature_mask": [
      "self",
      "X",
      "estimator_name"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input",
      "missing_values_in_feature_mask"
    ],
    "_validate_X_predict": [
      "self",
      "X",
      "check_input"
    ],
    "predict": [
      "self",
      "X",
      "check_input"
    ],
    "apply": [
      "self",
      "X",
      "check_input"
    ],
    "decision_path": [
      "self",
      "X",
      "check_input"
    ],
    "_prune_tree": [
      "self"
    ],
    "cost_complexity_pruning_path": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "feature_importances_": [
      "self"
    ]
  },
  "pyro_logger": [],
  "CEVAE": {
    "__init__": [
      "self",
      "outcome_dist",
      "latent_dim",
      "hidden_dim",
      "num_epochs",
      "num_layers",
      "batch_size",
      "learning_rate",
      "learning_rate_decay",
      "num_samples",
      "weight_decay"
    ],
    "fit": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ],
    "fit_predict": [
      "self",
      "X",
      "treatment",
      "y",
      "p"
    ]
  },
  "FilterSelect": {
    "__init__": [
      "self"
    ],
    "_filter_F_one_feature": [
      "data",
      "treatment_indicator",
      "feature_name",
      "y_name",
      "order"
    ],
    "filter_F": [
      "self",
      "data",
      "treatment_indicator",
      "features",
      "y_name",
      "order"
    ],
    "_filter_LR_one_feature": [
      "data",
      "treatment_indicator",
      "feature_name",
      "y_name",
      "order",
      "disp"
    ],
    "filter_LR": [
      "self",
      "data",
      "treatment_indicator",
      "features",
      "y_name",
      "order",
      "disp"
    ],
    "_GetNodeSummary": [
      "data",
      "experiment_group_column",
      "y_name",
      "smooth"
    ],
    "_kl_divergence": [
      "pk",
      "qk"
    ],
    "_evaluate_KL": [
      "self",
      "nodeSummary",
      "control_group"
    ],
    "_evaluate_ED": [
      "nodeSummary",
      "control_group"
    ],
    "_evaluate_Chi": [
      "nodeSummary",
      "control_group"
    ],
    "_filter_D_one_feature": [
      "self",
      "data",
      "feature_name",
      "y_name",
      "n_bins",
      "method",
      "control_group",
      "experiment_group_column",
      "null_impute"
    ],
    "filter_D": [
      "self",
      "data",
      "features",
      "y_name",
      "n_bins",
      "method",
      "control_group",
      "experiment_group_column",
      "null_impute"
    ],
    "get_importance": [
      "self",
      "data",
      "features",
      "y_name",
      "method",
      "experiment_group_column",
      "control_group",
      "treatment_group",
      "n_bins",
      "null_impute",
      "order",
      "disp"
    ]
  }
}