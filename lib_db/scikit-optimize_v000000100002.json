{
  "check_callback": [
    "callback"
  ],
  "VerboseCallback": {
    "__init__": [
      "self",
      "n_total",
      "n_init",
      "n_random"
    ],
    "_print_info": [
      "self",
      "start"
    ],
    "__call__": [
      "self",
      "res"
    ]
  },
  "TimerCallback": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "res"
    ]
  },
  "EarlyStopper": {
    "__call__": [
      "self",
      "result"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "DeltaXStopper": {
    "__init__": [
      "self",
      "delta"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "DeltaYStopper": {
    "__init__": [
      "self",
      "delta",
      "n_best"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "HollowIterationsStopper": {
    "__init__": [
      "self",
      "n_iterations",
      "threshold"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "DeadlineStopper": {
    "__init__": [
      "self",
      "total_time"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "StdStopper": {
    "__init__": [
      "self",
      "threshold",
      "log_interval"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "ThresholdStopper": {
    "__init__": [
      "self",
      "threshold"
    ],
    "_criterion": [
      "self",
      "result"
    ]
  },
  "CheckpointSaver": {
    "__init__": [
      "self",
      "checkpoint_path"
    ],
    "__call__": [
      "self",
      "res"
    ],
    "load": [
      "self"
    ]
  },
  "_get_score_names": [
    "cv_results"
  ],
  "BayesSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "search_spaces",
      "optimizer_kwargs",
      "n_iter",
      "scoring",
      "fit_params",
      "n_jobs",
      "n_points",
      "iid",
      "refit",
      "cv",
      "verbose",
      "pre_dispatch",
      "random_state",
      "error_score",
      "return_train_score"
    ],
    "_check_search_space": [
      "self",
      "search_space"
    ],
    "optimizer_results_": [
      "self"
    ],
    "_make_optimizer": [
      "self",
      "params_space"
    ],
    "_step": [
      "self",
      "search_space",
      "optimizer",
      "score_name",
      "evaluate_candidates",
      "n_points"
    ],
    "total_iterations": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "_check_refit_for_multimetric": [
      "self",
      "scores"
    ]
  },
  "plot_convergence": [],
  "plot_gaussian_process": [
    "res",
    "ax",
    "n_calls",
    "objective",
    "n_points",
    "noise_level",
    "show_legend",
    "show_title",
    "show_acq_func",
    "show_next_point",
    "show_observations",
    "show_mu"
  ],
  "plot_regret": [],
  "_format_scatter_plot_axes": [
    "ax",
    "space",
    "ylabel",
    "plot_dims",
    "dim_labels"
  ],
  "_make_subgrid": [
    "ax",
    "n_rows",
    "n_cols",
    "fig_kwargs_"
  ],
  "partial_dependence": [
    "space",
    "model",
    "i",
    "j",
    "sample_points",
    "n_samples",
    "n_points",
    "x_eval"
  ],
  "plot_objective": [
    "result",
    "levels",
    "n_points",
    "n_samples",
    "size",
    "wspace",
    "hspace",
    "zscale",
    "dimensions",
    "sample_source",
    "minimum",
    "n_minimum_search",
    "plot_dims",
    "show_points",
    "cmap",
    "ax"
  ],
  "plot_evaluations": [
    "result",
    "bins",
    "dimensions",
    "plot_dims",
    "size",
    "wspace",
    "hspace",
    "cmap",
    "ax"
  ],
  "_get_ylim_diagonal": [
    "ax"
  ],
  "partial_dependence_1D": [
    "space",
    "model",
    "i",
    "samples",
    "n_points"
  ],
  "partial_dependence_2D": [
    "space",
    "model",
    "i",
    "j",
    "samples",
    "n_points"
  ],
  "plot_objective_2D": [
    "result",
    "dimension_identifier1",
    "dimension_identifier2",
    "n_points",
    "n_samples",
    "levels",
    "zscale",
    "sample_source",
    "minimum",
    "n_minimum_search",
    "ax"
  ],
  "plot_histogram": [
    "result",
    "dimension_identifier",
    "bins",
    "rotate_labels",
    "ax"
  ],
  "_map_categories": [
    "space",
    "points",
    "minimum"
  ],
  "_evenly_sample": [
    "dim",
    "n_points"
  ],
  "_cat_format": [
    "dimension",
    "x",
    "_"
  ],
  "_evaluate_min_params": [
    "result",
    "params",
    "n_minimum_search",
    "random_state"
  ],
  "__all__": [],
  "create_result": [
    "Xi",
    "yi",
    "space",
    "rng",
    "specs",
    "models"
  ],
  "eval_callbacks": [
    "callbacks",
    "result"
  ],
  "dump": [
    "res",
    "filename",
    "store_objective"
  ],
  "load": [
    "filename"
  ],
  "is_listlike": [
    "x"
  ],
  "is_2Dlistlike": [
    "x"
  ],
  "check_x_in_space": [
    "x",
    "space"
  ],
  "expected_minimum": [
    "res",
    "n_random_starts",
    "random_state"
  ],
  "expected_minimum_random_sampling": [
    "res",
    "n_random_starts",
    "random_state"
  ],
  "has_gradients": [
    "estimator"
  ],
  "cook_estimator": [
    "base_estimator",
    "space"
  ],
  "cook_initial_point_generator": [
    "generator"
  ],
  "dimensions_aslist": [
    "search_space"
  ],
  "point_asdict": [
    "search_space",
    "point_as_list"
  ],
  "point_aslist": [
    "search_space",
    "point_as_dict"
  ],
  "normalize_dimensions": [
    "dimensions"
  ],
  "check_list_types": [
    "x",
    "types"
  ],
  "check_dimension_names": [
    "dimensions"
  ],
  "use_named_args": [
    "dimensions"
  ],
  "_IS_32BIT": [],
  "show_versions": [],
  "gaussian_acquisition_1D": [
    "X",
    "model",
    "y_opt",
    "acq_func",
    "acq_func_kwargs",
    "return_grad"
  ],
  "_gaussian_acquisition": [
    "X",
    "model",
    "y_opt",
    "acq_func",
    "return_grad",
    "acq_func_kwargs"
  ],
  "gaussian_lcb": [
    "X",
    "model",
    "kappa",
    "return_grad"
  ],
  "gaussian_pi": [
    "X",
    "model",
    "y_opt",
    "xi",
    "return_grad"
  ],
  "gaussian_ei": [
    "X",
    "model",
    "y_opt",
    "xi",
    "return_grad"
  ],
  "gaussian_mes": [
    "X",
    "model",
    "n_min_samples"
  ],
  "gaussian_pvrs": [
    "X",
    "model",
    "n_thompson"
  ],
  "bench1": [
    "x"
  ],
  "bench1_with_time": [
    "x"
  ],
  "bench2": [
    "x"
  ],
  "bench3": [
    "x"
  ],
  "bench4": [
    "x"
  ],
  "bench5": [
    "x"
  ],
  "branin": [
    "x",
    "a",
    "b",
    "c",
    "r",
    "s",
    "t"
  ],
  "hart6": [
    "x",
    "alpha",
    "P",
    "A"
  ],
  "Transformer": {
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "Identity": {
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ]
  },
  "StringEncoder": {
    "__init__": [
      "self",
      "dtype"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ]
  },
  "LogN": {
    "__init__": [
      "self",
      "base"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ]
  },
  "CategoricalEncoder": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ]
  },
  "LabelEncoder": {
    "__init__": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ]
  },
  "Normalize": {
    "__init__": [
      "self",
      "low",
      "high",
      "is_int"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "Pipeline": {
    "__init__": [
      "self",
      "transformers"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "_Ellipsis": {
    "__repr__": [
      "self"
    ]
  },
  "_transpose_list_array": [
    "x"
  ],
  "check_dimension": [
    "dimension",
    "transform"
  ],
  "_check_dimension": [
    "dimension",
    "transform"
  ],
  "_check_dimension_old": [
    "dimension",
    "transform"
  ],
  "Dimension": {
    "prior": [],
    "rvs": [
      "self",
      "n_samples",
      "random_state"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "set_transformer": [
      "self"
    ],
    "size": [
      "self"
    ],
    "transformed_size": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "is_constant": [
      "self"
    ],
    "transformed_bounds": [
      "self"
    ],
    "name": [
      "self",
      "value"
    ]
  },
  "_uniform_inclusive": [
    "loc",
    "scale"
  ],
  "Real": {
    "__init__": [
      "self",
      "low",
      "high",
      "prior",
      "base",
      "transform",
      "name",
      "dtype"
    ],
    "set_transformer": [
      "self",
      "transform"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "bounds": [
      "self"
    ],
    "is_constant": [
      "self"
    ],
    "__contains__": [
      "self",
      "point"
    ],
    "transformed_bounds": [
      "self"
    ],
    "distance": [
      "self",
      "a",
      "b"
    ]
  },
  "Integer": {
    "__init__": [
      "self",
      "low",
      "high",
      "prior",
      "base",
      "transform",
      "name",
      "dtype"
    ],
    "set_transformer": [
      "self",
      "transform"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "bounds": [
      "self"
    ],
    "is_constant": [
      "self"
    ],
    "__contains__": [
      "self",
      "point"
    ],
    "transformed_bounds": [
      "self"
    ],
    "distance": [
      "self",
      "a",
      "b"
    ]
  },
  "Categorical": {
    "__init__": [
      "self",
      "categories",
      "prior",
      "transform",
      "name"
    ],
    "set_transformer": [
      "self",
      "transform"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "rvs": [
      "self",
      "n_samples",
      "random_state"
    ],
    "transformed_size": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "is_constant": [
      "self"
    ],
    "__contains__": [
      "self",
      "point"
    ],
    "transformed_bounds": [
      "self"
    ],
    "distance": [
      "self",
      "a",
      "b"
    ]
  },
  "Space": {
    "__init__": [
      "self",
      "dimensions",
      "constraint"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "dimension_names": [
      "self",
      "names"
    ],
    "is_real": [
      "self"
    ],
    "from_yaml": [
      "cls",
      "yml_path",
      "namespace"
    ],
    "from_df": [
      "cls",
      "df",
      "priors",
      "bases",
      "transforms"
    ],
    "rvs": [
      "self",
      "n_samples",
      "random_state"
    ],
    "set_transformer": [
      "self",
      "transform"
    ],
    "set_transformer_by_type": [
      "self",
      "transform",
      "dim_type"
    ],
    "get_transformer": [
      "self"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "n_dims": [
      "self"
    ],
    "transformed_n_dims": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "__contains__": [
      "self",
      "point"
    ],
    "__getitem__": [
      "self",
      "dimension_names"
    ],
    "transformed_bounds": [
      "self"
    ],
    "is_categorical": [
      "self"
    ],
    "is_partly_categorical": [
      "self"
    ],
    "n_constant_dimensions": [
      "self"
    ],
    "distance": [
      "self",
      "point_a",
      "point_b"
    ]
  },
  "base_minimize": [
    "func",
    "dimensions",
    "base_estimator",
    "n_calls",
    "n_random_starts",
    "n_initial_points",
    "initial_point_generator",
    "acq_func",
    "acq_optimizer",
    "x0",
    "y0",
    "random_state",
    "verbose",
    "callback",
    "n_points",
    "n_restarts_optimizer",
    "xi",
    "kappa",
    "n_jobs",
    "model_queue_size",
    "space_constraint"
  ],
  "dummy_minimize": [
    "func",
    "dimensions",
    "n_calls",
    "initial_point_generator",
    "x0",
    "y0",
    "random_state",
    "verbose",
    "callback",
    "model_queue_size",
    "init_point_gen_kwargs",
    "space_constraint"
  ],
  "gp_minimize": [
    "func",
    "dimensions",
    "base_estimator",
    "n_calls",
    "n_random_starts",
    "n_initial_points",
    "initial_point_generator",
    "acq_func",
    "acq_optimizer",
    "x0",
    "y0",
    "random_state",
    "verbose",
    "callback",
    "n_points",
    "n_restarts_optimizer",
    "xi",
    "kappa",
    "noise",
    "n_jobs",
    "model_queue_size",
    "space_constraint"
  ],
  "gbrt_minimize": [
    "func",
    "dimensions",
    "base_estimator",
    "n_calls",
    "n_random_starts",
    "n_initial_points",
    "initial_point_generator",
    "acq_func",
    "acq_optimizer",
    "x0",
    "y0",
    "random_state",
    "verbose",
    "callback",
    "n_points",
    "xi",
    "kappa",
    "n_jobs",
    "model_queue_size",
    "space_constraint"
  ],
  "forest_minimize": [
    "func",
    "dimensions",
    "base_estimator",
    "n_calls",
    "n_random_starts",
    "n_initial_points",
    "acq_func",
    "initial_point_generator",
    "x0",
    "y0",
    "random_state",
    "verbose",
    "callback",
    "n_points",
    "xi",
    "kappa",
    "n_jobs",
    "model_queue_size",
    "space_constraint"
  ],
  "Optimizer": {
    "__init__": [
      "self",
      "dimensions",
      "base_estimator",
      "n_random_starts",
      "n_initial_points",
      "initial_point_generator",
      "n_jobs",
      "acq_func",
      "acq_optimizer",
      "random_state",
      "model_queue_size",
      "space_constraint",
      "acq_func_kwargs",
      "acq_optimizer_kwargs",
      "avoid_duplicates"
    ],
    "copy": [
      "self",
      "random_state"
    ],
    "ask": [
      "self",
      "n_points",
      "strategy"
    ],
    "_ask": [
      "self"
    ],
    "tell": [
      "self",
      "x",
      "y",
      "fit"
    ],
    "_tell": [
      "self",
      "x",
      "y",
      "fit"
    ],
    "_check_y_is_valid": [
      "self",
      "x",
      "y"
    ],
    "run": [
      "self",
      "func",
      "n_iter"
    ],
    "update_next": [
      "self"
    ],
    "get_result": [
      "self"
    ]
  },
  "_parallel_fit": [
    "regressor",
    "X",
    "y"
  ],
  "GradientBoostingQuantileRegressor": {
    "__init__": [
      "self",
      "quantiles",
      "base_estimator",
      "n_jobs",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "return_std",
      "return_quantiles"
    ]
  },
  "_return_std": [
    "X",
    "trees",
    "predictions",
    "min_variance"
  ],
  "RandomForestRegressor": {
    "__init__": [
      "self",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "bootstrap",
      "oob_score",
      "n_jobs",
      "random_state",
      "verbose",
      "warm_start",
      "min_variance"
    ],
    "predict": [
      "self",
      "X",
      "return_std"
    ]
  },
  "ExtraTreesRegressor": {
    "__init__": [
      "self",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "bootstrap",
      "oob_score",
      "n_jobs",
      "random_state",
      "verbose",
      "warm_start",
      "min_variance"
    ],
    "predict": [
      "self",
      "X",
      "return_std"
    ]
  },
  "_param_for_white_kernel_in_Sum": [
    "kernel",
    "kernel_str"
  ],
  "GaussianProcessRegressor": {
    "__init__": [
      "self",
      "kernel",
      "alpha",
      "optimizer",
      "n_restarts_optimizer",
      "normalize_y",
      "copy_X_train",
      "random_state",
      "noise"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "return_std",
      "return_cov",
      "return_mean_grad",
      "return_std_grad"
    ]
  },
  "Kernel": {
    "__add__": [
      "self",
      "b"
    ],
    "__radd__": [
      "self",
      "b"
    ],
    "__mul__": [
      "self",
      "b"
    ],
    "__rmul__": [
      "self",
      "b"
    ],
    "__pow__": [
      "self",
      "b"
    ],
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "RBF": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "Matern": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "RationalQuadratic": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "ExpSineSquared": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "ConstantKernel": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "WhiteKernel": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "Exponentiation": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "Sum": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "Product": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "DotProduct": {
    "gradient_x": [
      "self",
      "x",
      "X_train"
    ]
  },
  "HammingKernel": {
    "__init__": [
      "self",
      "length_scale",
      "length_scale_bounds"
    ],
    "hyperparameter_length_scale": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ]
  },
  "_quadrature_combine": [
    "args"
  ],
  "_create_uniform_grid_exclude_border": [
    "n_dim",
    "order"
  ],
  "_create_uniform_grid_include_border": [
    "n_dim",
    "order"
  ],
  "_create_uniform_grid_only_border": [
    "n_dim",
    "order"
  ],
  "Grid": {
    "__init__": [
      "self",
      "border",
      "use_full_layout",
      "append_border"
    ],
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ]
  },
  "_random_permute_matrix": [
    "h",
    "random_state"
  ],
  "Lhs": {
    "__init__": [
      "self",
      "lhs_type",
      "criterion",
      "iterations"
    ],
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ],
    "_lhs_normalized": [
      "self",
      "n_dim",
      "n_samples",
      "random_state"
    ]
  },
  "InitialPointGenerator": {
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ],
    "set_params": [
      "self"
    ]
  },
  "Hammersly": {
    "__init__": [
      "self",
      "min_skip",
      "max_skip",
      "primes"
    ],
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ]
  },
  "Sobol": {
    "__init__": [
      "self",
      "skip",
      "randomize"
    ],
    "init": [
      "self",
      "dim_num"
    ],
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ],
    "_sobol": [
      "self",
      "dim_num",
      "seed"
    ]
  },
  "_bit_hi1": [
    "n"
  ],
  "_bit_lo0": [
    "n"
  ],
  "_random_shift": [
    "dm",
    "random_state"
  ],
  "Halton": {
    "__init__": [
      "self",
      "min_skip",
      "max_skip",
      "primes"
    ],
    "generate": [
      "self",
      "dimensions",
      "n_samples",
      "random_state"
    ]
  },
  "_van_der_corput_samples": [
    "idx",
    "number_base"
  ],
  "_create_primes": [
    "threshold"
  ]
}