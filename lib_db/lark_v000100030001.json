{
  "Pattern": {
    "__init__": [
      "self",
      "value",
      "flags",
      "raw"
    ],
    "__repr__": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "to_regexp": [
      "self"
    ],
    "min_width": [
      "self"
    ],
    "max_width": [
      "self"
    ],
    "_get_flags": [
      "self",
      "value"
    ]
  },
  "PatternStr": {
    "__serialize_fields__": [],
    "to_regexp": [
      "self"
    ],
    "min_width": [
      "self"
    ],
    "max_width": [
      "self"
    ]
  },
  "PatternRE": {
    "__serialize_fields__": [],
    "to_regexp": [
      "self"
    ],
    "_width": [],
    "_get_width": [
      "self"
    ],
    "min_width": [
      "self"
    ],
    "max_width": [
      "self"
    ]
  },
  "TerminalDef": {
    "__serialize_fields__": [],
    "__serialize_namespace__": [],
    "__init__": [
      "self",
      "name",
      "pattern",
      "priority"
    ],
    "__repr__": [
      "self"
    ],
    "user_repr": [
      "self"
    ]
  },
  "_T": [],
  "Token": {
    "__slots__": [],
    "__match_args__": [],
    "__new__": [
      "cls"
    ],
    "_future_new": [
      "cls",
      "type",
      "value",
      "start_pos",
      "line",
      "column",
      "end_line",
      "end_column",
      "end_pos"
    ],
    "update": [
      "self"
    ],
    "_future_update": [
      "self",
      "type",
      "value"
    ],
    "new_borrow_pos": [
      "cls",
      "type_",
      "value",
      "borrow_t"
    ],
    "__reduce__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": []
  },
  "LineCounter": {
    "__slots__": [],
    "__init__": [
      "self",
      "newline_char"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "feed": [
      "self",
      "token",
      "test_newline"
    ]
  },
  "UnlessCallback": {
    "__init__": [
      "self",
      "scanner"
    ],
    "__call__": [
      "self",
      "t"
    ]
  },
  "CallChain": {
    "__init__": [
      "self",
      "callback1",
      "callback2",
      "cond"
    ],
    "__call__": [
      "self",
      "t"
    ]
  },
  "_get_match": [
    "re_",
    "regexp",
    "s",
    "flags"
  ],
  "_create_unless": [
    "terminals",
    "g_regex_flags",
    "re_",
    "use_bytes"
  ],
  "Scanner": {
    "__init__": [
      "self",
      "terminals",
      "g_regex_flags",
      "re_",
      "use_bytes"
    ],
    "_build_mres": [
      "self",
      "terminals",
      "max_size"
    ],
    "match": [
      "self",
      "text",
      "pos"
    ],
    "fullmatch": [
      "self",
      "text"
    ]
  },
  "_regexp_has_newline": [
    "r"
  ],
  "LexerState": {
    "__slots__": [],
    "__init__": [
      "self",
      "text",
      "line_ctr",
      "last_token"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__copy__": [
      "self"
    ]
  },
  "LexerThread": {
    "__init__": [
      "self",
      "lexer",
      "lexer_state"
    ],
    "from_text": [
      "cls",
      "lexer",
      "text_or_slice"
    ],
    "from_custom_input": [
      "cls",
      "lexer",
      "text"
    ],
    "lex": [
      "self",
      "parser_state"
    ],
    "__copy__": [
      "self"
    ],
    "_Token": []
  },
  "_Callback": [],
  "Lexer": {
    "lex": [
      "self",
      "lexer_state",
      "parser_state"
    ],
    "make_lexer_state": [
      "self",
      "text"
    ]
  },
  "_check_regex_collisions": [
    "terminal_to_regexp",
    "comparator",
    "strict_mode",
    "max_collisions_to_show"
  ],
  "AbstractBasicLexer": {
    "__init__": [
      "self",
      "conf",
      "comparator"
    ],
    "next_token": [
      "self",
      "lex_state",
      "parser_state"
    ],
    "lex": [
      "self",
      "state",
      "parser_state"
    ]
  },
  "BasicLexer": {
    "__init__": [
      "self",
      "conf",
      "comparator"
    ],
    "_build_scanner": [
      "self"
    ],
    "scanner": [
      "self"
    ],
    "match": [
      "self",
      "text",
      "pos"
    ],
    "next_token": [
      "self",
      "lex_state",
      "parser_state"
    ]
  },
  "ContextualLexer": {
    "__init__": [
      "self",
      "conf",
      "states",
      "always_accept"
    ],
    "lex": [
      "self",
      "lexer_state",
      "parser_state"
    ]
  },
  "_LexerCallback": [],
  "ParserCallbacks": [],
  "LexerConf": {
    "__serialize_fields__": [],
    "__serialize_namespace__": [],
    "__init__": [
      "self",
      "terminals",
      "re_module",
      "ignore",
      "postlex",
      "callbacks",
      "g_regex_flags",
      "skip_validation",
      "use_bytes",
      "strict"
    ],
    "_deserialize": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ]
  },
  "ParserConf": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "rules",
      "callbacks",
      "start"
    ]
  },
  "is_iter_empty": [
    "i"
  ],
  "WriteTokensTransformer": {
    "__init__": [
      "self",
      "tokens",
      "term_subs"
    ],
    "__default__": [
      "self",
      "data",
      "children",
      "meta"
    ]
  },
  "Reconstructor": {
    "__init__": [
      "self",
      "parser",
      "term_subs"
    ],
    "_reconstruct": [
      "self",
      "tree"
    ],
    "reconstruct": [
      "self",
      "tree",
      "postproc",
      "insert_spaces"
    ]
  },
  "Meta": {
    "__init__": [
      "self"
    ]
  },
  "_Leaf_T": [],
  "Branch": [],
  "Tree": {
    "__init__": [
      "self",
      "data",
      "children",
      "meta"
    ],
    "meta": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__match_args__": [],
    "_pretty_label": [
      "self"
    ],
    "_pretty": [
      "self",
      "level",
      "indent_str"
    ],
    "pretty": [
      "self",
      "indent_str"
    ],
    "__rich__": [
      "self",
      "parent"
    ],
    "_rich": [
      "self",
      "parent"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "iter_subtrees": [
      "self"
    ],
    "iter_subtrees_topdown": [
      "self"
    ],
    "find_pred": [
      "self",
      "pred"
    ],
    "find_data": [
      "self",
      "data"
    ],
    "find_token": [
      "self",
      "token_type"
    ],
    "expand_kids_by_data": [
      "self"
    ],
    "scan_values": [
      "self",
      "pred"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "copy": [
      "self"
    ],
    "set": [
      "self",
      "data",
      "children"
    ]
  },
  "ParseTree": [],
  "SlottedTree": {
    "__slots__": []
  },
  "pydot__tree_to_png": [
    "tree",
    "filename",
    "rankdir"
  ],
  "pydot__tree_to_dot": [
    "tree",
    "filename",
    "rankdir"
  ],
  "pydot__tree_to_graph": [
    "tree",
    "rankdir"
  ],
  "Ast": {},
  "AsList": {},
  "WithMeta": {},
  "camel_to_snake": [
    "name"
  ],
  "create_transformer": [
    "ast_module",
    "transformer",
    "decorator_factory"
  ],
  "DedentError": {},
  "Indenter": {
    "__init__": [
      "self"
    ],
    "handle_NL": [
      "self",
      "token"
    ],
    "_process": [
      "self",
      "stream"
    ],
    "process": [
      "self",
      "stream"
    ],
    "always_accept": [
      "self"
    ],
    "NL_type": [
      "self"
    ],
    "OPEN_PAREN_types": [
      "self"
    ],
    "CLOSE_PAREN_types": [
      "self"
    ],
    "INDENT_type": [
      "self"
    ],
    "DEDENT_type": [
      "self"
    ],
    "tab_len": [
      "self"
    ]
  },
  "PythonIndenter": {
    "NL_type": [],
    "OPEN_PAREN_types": [],
    "CLOSE_PAREN_types": [],
    "INDENT_type": [],
    "DEDENT_type": [],
    "tab_len": []
  },
  "NO_VALUE": [],
  "T": [],
  "classify": [
    "seq",
    "key",
    "value"
  ],
  "_deserialize": [
    "data",
    "namespace",
    "memo"
  ],
  "Serialize": {
    "memo_serialize": [
      "self",
      "types_to_memoize"
    ],
    "serialize": [
      "self",
      "memo"
    ],
    "deserialize": [
      "cls",
      "data",
      "memo"
    ]
  },
  "SerializeMemoizer": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "types_to_memoize"
    ],
    "in_types": [
      "self",
      "value"
    ],
    "serialize": [
      "self"
    ],
    "deserialize": [
      "cls",
      "data",
      "namespace",
      "memo"
    ]
  },
  "categ_pattern": [],
  "get_regexp_width": [
    "expr"
  ],
  "TextSlice": {
    "__post_init__": [
      "self"
    ],
    "cast_from": [
      "cls",
      "text"
    ],
    "is_complete_text": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "count": [
      "self",
      "substr"
    ],
    "rindex": [
      "self",
      "substr"
    ]
  },
  "TextOrSlice": [],
  "LarkInput": [],
  "_ID_START": [],
  "_ID_CONTINUE": [],
  "_test_unicode_category": [
    "s",
    "categories"
  ],
  "is_id_continue": [
    "s"
  ],
  "is_id_start": [
    "s"
  ],
  "dedup_list": [
    "l"
  ],
  "Enumerator": {
    "__init__": [
      "self"
    ],
    "get": [
      "self",
      "item"
    ],
    "__len__": [
      "self"
    ],
    "reversed": [
      "self"
    ]
  },
  "combine_alternatives": [
    "lists"
  ],
  "FS": {
    "exists": [],
    "open": [
      "name",
      "mode"
    ]
  },
  "fzset": {
    "__repr__": [
      "self"
    ]
  },
  "classify_bool": [
    "seq",
    "pred"
  ],
  "bfs": [
    "initial",
    "expand"
  ],
  "bfs_all_unique": [
    "initial",
    "expand"
  ],
  "_serialize": [
    "value",
    "memo"
  ],
  "small_factors": [
    "n",
    "max_factor"
  ],
  "OrderedSet": {
    "__init__": [
      "self",
      "items"
    ],
    "__contains__": [
      "self",
      "item"
    ],
    "add": [
      "self",
      "item"
    ],
    "__iter__": [
      "self"
    ],
    "remove": [
      "self",
      "item"
    ],
    "__bool__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "PostLex": {
    "process": [
      "self",
      "stream"
    ]
  },
  "LarkOptions": {
    "OPTIONS_DOC": [],
    "__init__": [
      "self",
      "options_dict"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__setattr__": [
      "self",
      "name",
      "value"
    ],
    "serialize": [
      "self",
      "memo"
    ],
    "deserialize": [
      "cls",
      "data",
      "memo"
    ]
  },
  "_LOAD_ALLOWED_OPTIONS": [],
  "_VALID_PRIORITY_OPTIONS": [],
  "_VALID_AMBIGUITY_OPTIONS": [],
  "Lark": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "grammar"
    ],
    "_build_lexer": [
      "self",
      "dont_ignore"
    ],
    "_prepare_callbacks": [
      "self"
    ],
    "_build_parser": [
      "self"
    ],
    "save": [
      "self",
      "f",
      "exclude_options"
    ],
    "load": [
      "cls",
      "f"
    ],
    "_deserialize_lexer_conf": [
      "self",
      "data",
      "memo",
      "options"
    ],
    "_load": [
      "self",
      "f"
    ],
    "_load_from_dict": [
      "cls",
      "data",
      "memo"
    ],
    "open": [
      "cls",
      "grammar_filename",
      "rel_to"
    ],
    "open_from_package": [
      "cls",
      "package",
      "grammar_path",
      "search_paths"
    ],
    "__repr__": [
      "self"
    ],
    "lex": [
      "self",
      "text",
      "dont_ignore"
    ],
    "get_terminal": [
      "self",
      "name"
    ],
    "parse_interactive": [
      "self",
      "text",
      "start"
    ],
    "parse": [
      "self",
      "text",
      "start",
      "on_error"
    ]
  },
  "is_discarded_terminal": [
    "t"
  ],
  "_MakeTreeMatch": {
    "__init__": [
      "self",
      "name",
      "expansion"
    ],
    "__call__": [
      "self",
      "args"
    ]
  },
  "_best_from_group": [
    "seq",
    "group_key",
    "cmp_key"
  ],
  "_best_rules_from_group": [
    "rules"
  ],
  "_match": [
    "term",
    "token"
  ],
  "make_recons_rule": [
    "origin",
    "expansion",
    "old_expansion"
  ],
  "make_recons_rule_to_term": [
    "origin",
    "term"
  ],
  "parse_rulename": [
    "s"
  ],
  "ChildrenLexer": {
    "__init__": [
      "self",
      "children"
    ],
    "lex": [
      "self",
      "parser_state"
    ]
  },
  "TreeMatcher": {
    "__init__": [
      "self",
      "parser"
    ],
    "_build_recons_rules": [
      "self",
      "rules"
    ],
    "match_tree": [
      "self",
      "tree",
      "rulename"
    ]
  },
  "__all__": [],
  "_wrap_lexer": [
    "lexer_class"
  ],
  "_deserialize_parsing_frontend": [
    "data",
    "memo",
    "lexer_conf",
    "callbacks",
    "options"
  ],
  "ParsingFrontend": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "lexer_conf",
      "parser_conf",
      "options",
      "parser"
    ],
    "_verify_start": [
      "self",
      "start"
    ],
    "_make_lexer_thread": [
      "self",
      "text"
    ],
    "parse": [
      "self",
      "text",
      "start",
      "on_error"
    ],
    "parse_interactive": [
      "self",
      "text",
      "start"
    ]
  },
  "_validate_frontend_args": [
    "parser",
    "lexer"
  ],
  "_get_lexer_callbacks": [
    "transformer",
    "terminals"
  ],
  "PostLexConnector": {
    "__init__": [
      "self",
      "lexer",
      "postlexer"
    ],
    "lex": [
      "self",
      "lexer_state",
      "parser_state"
    ]
  },
  "create_basic_lexer": [
    "lexer_conf",
    "parser",
    "postlex",
    "options"
  ],
  "create_contextual_lexer": [
    "lexer_conf",
    "parser",
    "postlex",
    "options"
  ],
  "create_lalr_parser": [
    "lexer_conf",
    "parser_conf",
    "options"
  ],
  "EarleyRegexpMatcher": {
    "__init__": [
      "self",
      "lexer_conf"
    ],
    "match": [
      "self",
      "term",
      "text",
      "index"
    ]
  },
  "create_earley_parser__dynamic": [
    "lexer_conf",
    "parser_conf"
  ],
  "_match_earley_basic": [
    "term",
    "token"
  ],
  "create_earley_parser__basic": [
    "lexer_conf",
    "parser_conf"
  ],
  "create_earley_parser": [
    "lexer_conf",
    "parser_conf",
    "options"
  ],
  "CYK_FrontEnd": {
    "__init__": [
      "self",
      "lexer_conf",
      "parser_conf",
      "options"
    ],
    "parse": [
      "self",
      "lexer_thread",
      "start"
    ],
    "_transform": [
      "self",
      "tree"
    ],
    "_apply_callback": [
      "self",
      "tree"
    ]
  },
  "_construct_parsing_frontend": [
    "parser_type",
    "lexer_type",
    "lexer_conf",
    "parser_conf",
    "options"
  ],
  "_Return_T": [],
  "_Return_V": [],
  "_Leaf_U": [],
  "_R": [],
  "_FUNC": [],
  "_DECORATED": [],
  "_DiscardType": {
    "__repr__": [
      "self"
    ]
  },
  "Discard": [],
  "_Decoratable": {
    "_apply_v_args": [
      "cls",
      "visit_wrapper"
    ],
    "__class_getitem__": [
      "cls",
      "_"
    ]
  },
  "Transformer": {
    "__visit_tokens__": [],
    "__init__": [
      "self",
      "visit_tokens"
    ],
    "_call_userfunc": [
      "self",
      "tree",
      "new_children"
    ],
    "_call_userfunc_token": [
      "self",
      "token"
    ],
    "_transform_children": [
      "self",
      "children"
    ],
    "_transform_tree": [
      "self",
      "tree"
    ],
    "transform": [
      "self",
      "tree"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__default__": [
      "self",
      "data",
      "children",
      "meta"
    ],
    "__default_token__": [
      "self",
      "token"
    ]
  },
  "merge_transformers": [
    "base_transformer"
  ],
  "InlineTransformer": {
    "_call_userfunc": [
      "self",
      "tree",
      "new_children"
    ]
  },
  "TransformerChain": {
    "__init__": [
      "self"
    ],
    "transform": [
      "self",
      "tree"
    ],
    "__mul__": [
      "self",
      "other"
    ]
  },
  "Transformer_InPlace": {
    "_transform_tree": [
      "self",
      "tree"
    ],
    "transform": [
      "self",
      "tree"
    ]
  },
  "Transformer_NonRecursive": {
    "transform": [
      "self",
      "tree"
    ]
  },
  "Transformer_InPlaceRecursive": {
    "_transform_tree": [
      "self",
      "tree"
    ]
  },
  "VisitorBase": {
    "_call_userfunc": [
      "self",
      "tree"
    ],
    "__default__": [
      "self",
      "tree"
    ],
    "__class_getitem__": [
      "cls",
      "_"
    ]
  },
  "Visitor": {
    "visit": [
      "self",
      "tree"
    ],
    "visit_topdown": [
      "self",
      "tree"
    ]
  },
  "Visitor_Recursive": {
    "visit": [
      "self",
      "tree"
    ],
    "visit_topdown": [
      "self",
      "tree"
    ]
  },
  "Interpreter": {
    "visit": [
      "self",
      "tree"
    ],
    "_visit_tree": [
      "self",
      "tree"
    ],
    "visit_children": [
      "self",
      "tree"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__default__": [
      "self",
      "tree"
    ]
  },
  "_InterMethod": [],
  "visit_children_decor": [
    "func"
  ],
  "_apply_v_args": [
    "obj",
    "visit_wrapper"
  ],
  "_VArgsWrapper": {
    "__init__": [
      "self",
      "func",
      "visit_wrapper"
    ],
    "__call__": [
      "self"
    ],
    "__get__": [
      "self",
      "instance",
      "owner"
    ],
    "__set_name__": [
      "self",
      "owner",
      "name"
    ]
  },
  "_vargs_inline": [
    "f",
    "_data",
    "children",
    "_meta"
  ],
  "_vargs_meta_inline": [
    "f",
    "_data",
    "children",
    "meta"
  ],
  "_vargs_meta": [
    "f",
    "_data",
    "children",
    "meta"
  ],
  "_vargs_tree": [
    "f",
    "data",
    "children",
    "meta"
  ],
  "v_args": [
    "inline",
    "meta",
    "tree",
    "wrapper"
  ],
  "CollapseAmbiguities": {
    "_ambig": [
      "self",
      "options"
    ],
    "__default__": [
      "self",
      "data",
      "children_lists",
      "meta"
    ],
    "__default_token__": [
      "self",
      "t"
    ]
  },
  "LarkError": {},
  "ConfigurationError": {},
  "assert_config": [
    "value",
    "options",
    "msg"
  ],
  "GrammarError": {},
  "ParseError": {},
  "LexError": {},
  "UnexpectedInput": {
    "pos_in_stream": [],
    "_terminals_by_name": [],
    "get_context": [
      "self",
      "text",
      "span"
    ],
    "match_examples": [
      "self",
      "parse_fn",
      "examples",
      "token_type_match_fallback",
      "use_accepts"
    ],
    "_format_expected": [
      "self",
      "expected"
    ]
  },
  "UnexpectedEOF": {
    "__init__": [
      "self",
      "expected",
      "state",
      "terminals_by_name"
    ],
    "__str__": [
      "self"
    ]
  },
  "UnexpectedCharacters": {
    "__init__": [
      "self",
      "seq",
      "lex_pos",
      "line",
      "column",
      "allowed",
      "considered_tokens",
      "state",
      "token_history",
      "terminals_by_name",
      "considered_rules"
    ],
    "__str__": [
      "self"
    ]
  },
  "UnexpectedToken": {
    "__init__": [
      "self",
      "token",
      "expected",
      "considered_rules",
      "state",
      "interactive_parser",
      "terminals_by_name",
      "token_history"
    ],
    "accepts": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "VisitError": {
    "__init__": [
      "self",
      "rule",
      "obj",
      "orig_exc"
    ]
  },
  "MissingVariableError": {},
  "inline_args": [],
  "IMPORT_PATHS": [],
  "EXT": [],
  "_RE_FLAGS": [],
  "_EMPTY": [],
  "_TERMINAL_NAMES": [],
  "TERMINALS": [],
  "RULES": [],
  "SMALL_FACTOR_THRESHOLD": [],
  "REPEAT_BREAK_THRESHOLD": [],
  "FindRuleSize": {
    "__init__": [
      "self",
      "keep_all_tokens"
    ],
    "_will_not_get_removed": [
      "self",
      "sym"
    ],
    "_args_as_int": [
      "self",
      "args"
    ],
    "expansion": [
      "self",
      "args"
    ],
    "expansions": [
      "self",
      "args"
    ]
  },
  "EBNF_to_BNF": {
    "__init__": [
      "self"
    ],
    "_name_rule": [
      "self",
      "inner"
    ],
    "_add_rule": [
      "self",
      "key",
      "name",
      "expansions"
    ],
    "_add_recurse_rule": [
      "self",
      "type_",
      "expr"
    ],
    "_add_repeat_rule": [
      "self",
      "a",
      "b",
      "target",
      "atom"
    ],
    "_add_repeat_opt_rule": [
      "self",
      "a",
      "b",
      "target",
      "target_opt",
      "atom"
    ],
    "_generate_repeats": [
      "self",
      "rule",
      "mn",
      "mx"
    ],
    "expr": [
      "self",
      "rule",
      "op"
    ],
    "maybe": [
      "self",
      "rule"
    ]
  },
  "SimplifyRule_Visitor": {
    "_flatten": [
      "tree"
    ],
    "expansion": [
      "self",
      "tree"
    ],
    "alias": [
      "self",
      "tree"
    ],
    "expansions": [
      "self",
      "tree"
    ]
  },
  "RuleTreeToText": {
    "expansions": [
      "self",
      "x"
    ],
    "expansion": [
      "self",
      "symbols"
    ],
    "alias": [
      "self",
      "x"
    ]
  },
  "PrepareAnonTerminals": {
    "__init__": [
      "self",
      "terminals"
    ],
    "pattern": [
      "self",
      "p"
    ]
  },
  "_ReplaceSymbols": {
    "__init__": [
      "self"
    ],
    "value": [
      "self",
      "c"
    ],
    "template_usage": [
      "self",
      "c"
    ]
  },
  "ApplyTemplates": {
    "__init__": [
      "self",
      "rule_defs"
    ],
    "template_usage": [
      "self",
      "c"
    ]
  },
  "_rfind": [
    "s",
    "choices"
  ],
  "eval_escaping": [
    "s"
  ],
  "_literal_to_pattern": [
    "literal"
  ],
  "PrepareLiterals": {
    "literal": [
      "self",
      "literal"
    ],
    "range": [
      "self",
      "start",
      "end"
    ]
  },
  "_make_joined_pattern": [
    "regexp",
    "flags_set"
  ],
  "TerminalTreeToPattern": {
    "pattern": [
      "self",
      "ps"
    ],
    "expansion": [
      "self",
      "items"
    ],
    "expansions": [
      "self",
      "exps"
    ],
    "expr": [
      "self",
      "args"
    ],
    "maybe": [
      "self",
      "expr"
    ],
    "alias": [
      "self",
      "t"
    ],
    "value": [
      "self",
      "v"
    ]
  },
  "ValidateSymbols": {
    "value": [
      "self",
      "v"
    ]
  },
  "nr_deepcopy_tree": [
    "t"
  ],
  "Grammar": {
    "__init__": [
      "self",
      "rule_defs",
      "term_defs",
      "ignore"
    ],
    "__serialize_fields__": [],
    "compile": [
      "self",
      "start",
      "terminals_to_keep"
    ]
  },
  "PackageResource": [],
  "FromPackageLoader": {
    "__init__": [
      "self",
      "pkg_name",
      "search_paths"
    ],
    "__repr__": [
      "self"
    ],
    "__call__": [
      "self",
      "base_path",
      "grammar_path"
    ]
  },
  "stdlib_loader": [],
  "resolve_term_references": [
    "term_dict"
  ],
  "symbol_from_strcase": [
    "s"
  ],
  "PrepareGrammar": {
    "terminal": [
      "self",
      "name"
    ],
    "nonterminal": [
      "self",
      "name"
    ]
  },
  "_find_used_symbols": [
    "tree"
  ],
  "_get_parser": [],
  "GRAMMAR_ERRORS": [],
  "_translate_parser_exception": [
    "parse",
    "e"
  ],
  "_parse_grammar": [
    "text",
    "name",
    "start"
  ],
  "_error_repr": [
    "error"
  ],
  "_search_interactive_parser": [
    "interactive_parser",
    "predicate"
  ],
  "find_grammar_errors": [
    "text",
    "start"
  ],
  "_get_mangle": [
    "prefix",
    "aliases",
    "base_mangle"
  ],
  "_mangle_definition_tree": [
    "exp",
    "mangle"
  ],
  "_make_rule_tuple": [
    "modifiers_tree",
    "name",
    "params",
    "priority_tree",
    "expansions"
  ],
  "Definition": {
    "__init__": [
      "self",
      "is_term",
      "tree",
      "params",
      "options"
    ]
  },
  "GrammarBuilder": {
    "__init__": [
      "self",
      "global_keep_all_tokens",
      "import_paths",
      "used_files"
    ],
    "_grammar_error": [
      "self",
      "is_term",
      "msg"
    ],
    "_check_options": [
      "self",
      "is_term",
      "options"
    ],
    "_define": [
      "self",
      "name",
      "is_term",
      "exp",
      "params",
      "options"
    ],
    "_extend": [
      "self",
      "name",
      "is_term",
      "exp",
      "params",
      "options"
    ],
    "_ignore": [
      "self",
      "exp_or_name"
    ],
    "_unpack_import": [
      "self",
      "stmt",
      "grammar_name"
    ],
    "_unpack_definition": [
      "self",
      "tree",
      "mangle"
    ],
    "load_grammar": [
      "self",
      "grammar_text",
      "grammar_name",
      "mangle"
    ],
    "_remove_unused": [
      "self",
      "used"
    ],
    "do_import": [
      "self",
      "dotted_path",
      "base_path",
      "aliases",
      "base_mangle"
    ],
    "validate": [
      "self"
    ],
    "build": [
      "self"
    ]
  },
  "verify_used_files": [
    "file_hashes"
  ],
  "list_grammar_imports": [
    "grammar",
    "import_paths"
  ],
  "load_grammar": [
    "grammar",
    "source",
    "import_paths",
    "global_keep_all_tokens"
  ],
  "sha256_digest": [
    "s"
  ],
  "TOKEN_DEFAULT_PRIORITY": [],
  "Symbol": {
    "__slots__": [],
    "__init__": [
      "self",
      "name"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "fullrepr": [],
    "renamed": [
      "self",
      "f"
    ]
  },
  "Terminal": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "name",
      "filter_out"
    ],
    "fullrepr": [
      "self"
    ],
    "renamed": [
      "self",
      "f"
    ]
  },
  "NonTerminal": {
    "__serialize_fields__": [],
    "serialize": [
      "self",
      "memo"
    ]
  },
  "RuleOptions": {
    "__serialize_fields__": [],
    "__init__": [
      "self",
      "keep_all_tokens",
      "expand1",
      "priority",
      "template_source",
      "empty_indices"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Rule": {
    "__slots__": [],
    "__serialize_fields__": [],
    "__serialize_namespace__": [],
    "__init__": [
      "self",
      "origin",
      "expansion",
      "order",
      "alias",
      "options"
    ],
    "_deserialize": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "TreeOrCode": [],
  "MatchResult": [],
  "_TEMPLATE_MARKER": [],
  "TemplateConf": {
    "__init__": [
      "self",
      "parse"
    ],
    "test_var": [
      "self",
      "var"
    ],
    "_get_tree": [
      "self",
      "template"
    ],
    "__call__": [
      "self",
      "template"
    ],
    "_match_tree_template": [
      "self",
      "template",
      "tree"
    ]
  },
  "_ReplaceVars": {
    "__init__": [
      "self",
      "conf",
      "vars"
    ],
    "__default__": [
      "self",
      "data",
      "children",
      "meta"
    ]
  },
  "Template": {
    "__init__": [
      "self",
      "tree",
      "conf"
    ],
    "match": [
      "self",
      "tree"
    ],
    "search": [
      "self",
      "tree"
    ],
    "apply_vars": [
      "self",
      "vars"
    ]
  },
  "translate": [
    "t1",
    "t2",
    "tree"
  ],
  "TemplateTranslator": {
    "__init__": [
      "self",
      "translations"
    ],
    "translate": [
      "self",
      "tree"
    ]
  },
  "_get_template_name": [
    "value"
  ],
  "ExpandSingleChild": {
    "__init__": [
      "self",
      "node_builder"
    ],
    "__call__": [
      "self",
      "children"
    ]
  },
  "PropagatePositions": {
    "__init__": [
      "self",
      "node_builder",
      "node_filter"
    ],
    "__call__": [
      "self",
      "children"
    ],
    "_pp_get_meta": [
      "self",
      "children"
    ]
  },
  "make_propagate_positions": [
    "option"
  ],
  "ChildFilter": {
    "__init__": [
      "self",
      "to_include",
      "append_none",
      "node_builder"
    ],
    "__call__": [
      "self",
      "children"
    ]
  },
  "ChildFilterLALR": {
    "__call__": [
      "self",
      "children"
    ]
  },
  "ChildFilterLALR_NoPlaceholders": {
    "__init__": [
      "self",
      "to_include",
      "node_builder"
    ],
    "__call__": [
      "self",
      "children"
    ]
  },
  "_should_expand": [
    "sym"
  ],
  "maybe_create_child_filter": [
    "expansion",
    "keep_all_tokens",
    "ambiguous",
    "_empty_indices"
  ],
  "AmbiguousExpander": {
    "__init__": [
      "self",
      "to_expand",
      "tree_class",
      "node_builder"
    ],
    "__call__": [
      "self",
      "children"
    ]
  },
  "maybe_create_ambiguous_expander": [
    "tree_class",
    "expansion",
    "keep_all_tokens"
  ],
  "AmbiguousIntermediateExpander": {
    "__init__": [
      "self",
      "tree_class",
      "node_builder"
    ],
    "__call__": [
      "self",
      "children"
    ]
  },
  "inplace_transformer": [
    "func"
  ],
  "apply_visit_wrapper": [
    "func",
    "name",
    "wrapper"
  ],
  "ParseTreeBuilder": {
    "__init__": [
      "self",
      "rules",
      "tree_class",
      "propagate_positions",
      "ambiguous",
      "maybe_placeholders"
    ],
    "_init_builders": [
      "self",
      "rules"
    ],
    "create_callback": [
      "self",
      "transformer"
    ]
  },
  "datas": [],
  "get_hook_dirs": [],
  "Item": {
    "__slots__": [],
    "__init__": [
      "self",
      "rule",
      "ptr",
      "start"
    ],
    "advance": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Action": {
    "__init__": [
      "self",
      "name"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Shift": [],
  "Reduce": [],
  "StateT": [],
  "ParseTableBase": {
    "__init__": [
      "self",
      "states",
      "start_states",
      "end_states"
    ],
    "serialize": [
      "self",
      "memo"
    ],
    "deserialize": [
      "cls",
      "data",
      "memo"
    ]
  },
  "ParseTable": {},
  "IntParseTable": {
    "from_ParseTable": [
      "cls",
      "parse_table"
    ]
  },
  "digraph": [
    "X",
    "R",
    "G"
  ],
  "traverse": [
    "x",
    "S",
    "N",
    "X",
    "R",
    "G",
    "F"
  ],
  "LALR_Analyzer": {
    "__init__": [
      "self",
      "parser_conf",
      "debug",
      "strict"
    ],
    "compute_lr0_states": [
      "self"
    ],
    "compute_reads_relations": [
      "self"
    ],
    "compute_includes_lookback": [
      "self"
    ],
    "compute_lookaheads": [
      "self"
    ],
    "compute_lalr1_states": [
      "self"
    ],
    "compute_lalr": [
      "self"
    ]
  },
  "match": [
    "t",
    "s"
  ],
  "RuleNode": {
    "__init__": [
      "self",
      "rule",
      "children",
      "weight"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Parser": {
    "__init__": [
      "self",
      "rules"
    ],
    "_to_rule": [
      "self",
      "lark_rule"
    ],
    "parse": [
      "self",
      "tokenized",
      "start"
    ],
    "_to_tree": [
      "self",
      "rule_node"
    ]
  },
  "print_parse": [
    "node",
    "indent"
  ],
  "_parse": [
    "s",
    "g"
  ],
  "CnfWrapper": {
    "__init__": [
      "self",
      "grammar"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "UnitSkipRule": {
    "__init__": [
      "self",
      "lhs",
      "rhs",
      "skipped_rules",
      "weight",
      "alias"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": []
  },
  "build_unit_skiprule": [
    "unit_rule",
    "target_rule"
  ],
  "get_any_nt_unit_rule": [
    "g"
  ],
  "_remove_unit_rule": [
    "g",
    "rule"
  ],
  "_split": [
    "rule"
  ],
  "_term": [
    "g"
  ],
  "_bin": [
    "g"
  ],
  "_unit": [
    "g"
  ],
  "to_cnf": [
    "g"
  ],
  "unroll_unit_skiprule": [
    "lhs",
    "orig_rhs",
    "skipped_rules",
    "children",
    "weight",
    "alias"
  ],
  "revert_cnf": [
    "node"
  ],
  "InteractiveParser": {
    "__init__": [
      "self",
      "parser",
      "parser_state",
      "lexer_thread"
    ],
    "lexer_state": [
      "self"
    ],
    "feed_token": [
      "self",
      "token"
    ],
    "iter_parse": [
      "self"
    ],
    "exhaust_lexer": [
      "self"
    ],
    "feed_eof": [
      "self",
      "last_token"
    ],
    "__copy__": [
      "self"
    ],
    "copy": [
      "self",
      "deepcopy_values"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "as_immutable": [
      "self"
    ],
    "pretty": [
      "self"
    ],
    "choices": [
      "self"
    ],
    "accepts": [
      "self"
    ],
    "resume_parse": [
      "self"
    ]
  },
  "ImmutableInteractiveParser": {
    "result": [],
    "__hash__": [
      "self"
    ],
    "feed_token": [
      "self",
      "token"
    ],
    "exhaust_lexer": [
      "self"
    ],
    "as_mutable": [
      "self"
    ]
  },
  "ParseConf": {
    "__slots__": [],
    "__init__": [
      "self",
      "parse_table",
      "callbacks",
      "start"
    ]
  },
  "ParserState": {
    "__slots__": [],
    "__init__": [
      "self",
      "parse_conf",
      "lexer",
      "state_stack",
      "value_stack"
    ],
    "position": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__copy__": [
      "self"
    ],
    "copy": [
      "self",
      "deepcopy_values"
    ],
    "feed_token": [
      "self",
      "token",
      "is_end"
    ]
  },
  "ForestNode": {},
  "SymbolNode": {
    "__slots__": [],
    "__init__": [
      "self",
      "s",
      "start",
      "end"
    ],
    "add_family": [
      "self",
      "lr0",
      "rule",
      "start",
      "left",
      "right"
    ],
    "add_path": [
      "self",
      "transitive",
      "node"
    ],
    "load_paths": [
      "self"
    ],
    "is_ambiguous": [
      "self"
    ],
    "children": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "StableSymbolNode": {
    "Set": []
  },
  "PackedNode": {
    "__slots__": [],
    "__init__": [
      "self",
      "parent",
      "s",
      "rule",
      "start",
      "left",
      "right"
    ],
    "is_empty": [
      "self"
    ],
    "sort_key": [
      "self"
    ],
    "children": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "TokenNode": {
    "__slots__": [],
    "__init__": [
      "self",
      "token",
      "term",
      "priority"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ForestVisitor": {
    "__init__": [
      "self",
      "single_visit"
    ],
    "visit_token_node": [
      "self",
      "node"
    ],
    "visit_symbol_node_in": [
      "self",
      "node"
    ],
    "visit_symbol_node_out": [
      "self",
      "node"
    ],
    "visit_packed_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_out": [
      "self",
      "node"
    ],
    "on_cycle": [
      "self",
      "node",
      "path"
    ],
    "get_cycle_in_path": [
      "self",
      "node",
      "path"
    ],
    "visit": [
      "self",
      "root"
    ]
  },
  "ForestTransformer": {
    "__init__": [
      "self"
    ],
    "transform": [
      "self",
      "root"
    ],
    "transform_symbol_node": [
      "self",
      "node",
      "data"
    ],
    "transform_intermediate_node": [
      "self",
      "node",
      "data"
    ],
    "transform_packed_node": [
      "self",
      "node",
      "data"
    ],
    "transform_token_node": [
      "self",
      "node"
    ],
    "visit_symbol_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_in": [
      "self",
      "node"
    ],
    "visit_token_node": [
      "self",
      "node"
    ],
    "_visit_node_out_helper": [
      "self",
      "node",
      "method"
    ],
    "visit_symbol_node_out": [
      "self",
      "node"
    ],
    "visit_intermediate_node_out": [
      "self",
      "node"
    ],
    "visit_packed_node_out": [
      "self",
      "node"
    ]
  },
  "ForestSumVisitor": {
    "__init__": [
      "self"
    ],
    "visit_packed_node_in": [
      "self",
      "node"
    ],
    "visit_symbol_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_out": [
      "self",
      "node"
    ],
    "visit_symbol_node_out": [
      "self",
      "node"
    ]
  },
  "PackedData": {
    "NO_DATA": [],
    "__init__": [
      "self",
      "node",
      "data"
    ]
  },
  "ForestToParseTree": {
    "__init__": [
      "self",
      "tree_class",
      "callbacks",
      "prioritizer",
      "resolve_ambiguity",
      "use_cache"
    ],
    "visit": [
      "self",
      "root"
    ],
    "on_cycle": [
      "self",
      "node",
      "path"
    ],
    "_check_cycle": [
      "self",
      "node"
    ],
    "_collapse_ambig": [
      "self",
      "children"
    ],
    "_call_rule_func": [
      "self",
      "node",
      "data"
    ],
    "_call_ambig_func": [
      "self",
      "node",
      "data"
    ],
    "transform_symbol_node": [
      "self",
      "node",
      "data"
    ],
    "transform_intermediate_node": [
      "self",
      "node",
      "data"
    ],
    "transform_packed_node": [
      "self",
      "node",
      "data"
    ],
    "visit_symbol_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_out": [
      "self",
      "node"
    ]
  },
  "handles_ambiguity": [
    "func"
  ],
  "TreeForestTransformer": {
    "__init__": [
      "self",
      "tree_class",
      "prioritizer",
      "resolve_ambiguity",
      "use_cache"
    ],
    "__default__": [
      "self",
      "name",
      "data"
    ],
    "__default_ambig__": [
      "self",
      "name",
      "data"
    ],
    "__default_token__": [
      "self",
      "node"
    ],
    "transform_token_node": [
      "self",
      "node"
    ],
    "_call_rule_func": [
      "self",
      "node",
      "data"
    ],
    "_call_ambig_func": [
      "self",
      "node",
      "data"
    ]
  },
  "ForestToPyDotVisitor": {
    "__init__": [
      "self",
      "rankdir"
    ],
    "visit": [
      "self",
      "root",
      "filename"
    ],
    "visit_token_node": [
      "self",
      "node"
    ],
    "visit_packed_node_in": [
      "self",
      "node"
    ],
    "visit_packed_node_out": [
      "self",
      "node"
    ],
    "visit_symbol_node_in": [
      "self",
      "node"
    ],
    "visit_symbol_node_out": [
      "self",
      "node"
    ]
  },
  "RulePtr": {
    "__slots__": [],
    "__init__": [
      "self",
      "rule",
      "index"
    ],
    "__repr__": [
      "self"
    ],
    "next": [
      "self"
    ],
    "advance": [
      "self",
      "sym"
    ],
    "is_satisfied": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "State": [],
  "LR0ItemSet": {
    "__slots__": [],
    "__init__": [
      "self",
      "kernel",
      "closure"
    ],
    "__repr__": [
      "self"
    ]
  },
  "update_set": [
    "set1",
    "set2"
  ],
  "calculate_sets": [
    "rules"
  ],
  "GrammarAnalyzer": {
    "__init__": [
      "self",
      "parser_conf",
      "debug",
      "strict"
    ],
    "expand_rule": [
      "self",
      "source_rule",
      "rules_by_origin"
    ]
  },
  "LALR_Parser": {
    "__init__": [
      "self",
      "parser_conf",
      "debug",
      "strict"
    ],
    "deserialize": [
      "cls",
      "data",
      "memo",
      "callbacks",
      "debug"
    ],
    "serialize": [
      "self",
      "memo"
    ],
    "parse_interactive": [
      "self",
      "lexer",
      "start"
    ],
    "parse": [
      "self",
      "lexer",
      "start",
      "on_error"
    ]
  },
  "_Parser": {
    "__init__": [
      "self",
      "parse_table",
      "callbacks",
      "debug"
    ],
    "parse": [
      "self",
      "lexer",
      "start",
      "value_stack",
      "state_stack",
      "start_interactive"
    ],
    "parse_from_state": [
      "self",
      "state",
      "last_token"
    ]
  },
  "lalr_argparser": [],
  "flags": [],
  "options": [],
  "build_lalr": [
    "namespace"
  ],
  "showwarning_as_comment": [
    "message",
    "category",
    "filename",
    "lineno",
    "file",
    "line"
  ],
  "make_warnings_comments": [],
  "_dir": [],
  "_larkdir": [],
  "EXTRACT_STANDALONE_FILES": [],
  "extract_sections": [
    "lines"
  ],
  "strip_docstrings": [
    "line_gen"
  ],
  "gen_standalone": [
    "lark_inst",
    "output",
    "out",
    "compress"
  ],
  "main": [],
  "nearley_grammar": [],
  "nearley_grammar_parser": [],
  "_get_rulename": [
    "name"
  ],
  "NearleyToLark": {
    "__init__": [
      "self"
    ],
    "_new_function": [
      "self",
      "code"
    ],
    "_extra_rule": [
      "self",
      "rule"
    ],
    "rule": [
      "self",
      "name"
    ],
    "ruledef": [
      "self",
      "name",
      "exps"
    ],
    "expr": [
      "self",
      "item",
      "op"
    ],
    "regexp": [
      "self",
      "r"
    ],
    "null": [
      "self"
    ],
    "string": [
      "self",
      "s"
    ],
    "expansion": [
      "self"
    ],
    "expansions": [
      "self"
    ],
    "start": [
      "self"
    ]
  },
  "_nearley_to_lark": [
    "g",
    "builtin_path",
    "n2l",
    "js_code",
    "folder_path",
    "includes"
  ],
  "create_code_for_nearley_grammar": [
    "g",
    "start",
    "builtin_path",
    "folder_path",
    "es6"
  ],
  "get_arg_parser": [],
  "argparser": [],
  "serialize": [
    "lark_inst",
    "outfile"
  ]
}