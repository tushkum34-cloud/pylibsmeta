{
  "parse_args": [],
  "main": [],
  "logger": [],
  "plot_anoms": [
    "ax",
    "anomaly_labels"
  ],
  "plot_anoms_plotly": [
    "fig",
    "anomaly_labels"
  ],
  "Figure": {
    "_default_label_alias": [],
    "__init__": [
      "self",
      "y",
      "anom",
      "yhat",
      "yhat_lb",
      "yhat_ub",
      "y_prev",
      "yhat_prev",
      "yhat_prev_lb",
      "yhat_prev_ub",
      "yhat_color"
    ],
    "t0": [
      "self"
    ],
    "tf": [
      "self"
    ],
    "t_split": [
      "self"
    ],
    "get_y": [
      "self"
    ],
    "get_yhat": [
      "self"
    ],
    "get_yhat_iqr": [
      "self"
    ],
    "plot": [
      "self",
      "title",
      "metric_name",
      "figsize",
      "ax",
      "label_alias"
    ],
    "plot_plotly": [
      "self",
      "title",
      "metric_name",
      "figsize",
      "label_alias"
    ]
  },
  "MTSFigure": {
    "__init__": [
      "self",
      "y",
      "anom",
      "yhat",
      "yhat_lb",
      "yhat_ub",
      "y_prev",
      "yhat_prev",
      "yhat_prev_lb",
      "yhat_prev_ub",
      "yhat_color"
    ],
    "t0": [
      "self"
    ],
    "tf": [
      "self"
    ],
    "t_split": [
      "self"
    ],
    "_combine_prev": [
      "x",
      "x_prev"
    ],
    "get_y": [
      "self"
    ],
    "get_yhat": [
      "self"
    ],
    "get_yhat_iqr": [
      "self"
    ],
    "_get_layout": [
      "title",
      "figsize"
    ],
    "plot_plotly": [
      "self",
      "title",
      "figsize"
    ]
  },
  "TABLE_HEADER_COLOR": [],
  "TABLE_DATA_COLOR": [],
  "app": [],
  "server": [],
  "_display_page": [
    "pathname"
  ],
  "_click_tab": [
    "tab",
    "data_state",
    "anomaly_state",
    "forecasting_state"
  ],
  "DashLogger": {
    "__init__": [
      "self",
      "stream"
    ],
    "emit": [
      "self",
      "record"
    ]
  },
  "SingletonClass": {
    "__new__": [
      "cls"
    ]
  },
  "FileManager": {
    "__init__": [
      "self",
      "directory"
    ],
    "save_file": [
      "self",
      "name",
      "content"
    ],
    "uploaded_files": [
      "self"
    ],
    "get_model_download_path": [
      "self",
      "model_name"
    ],
    "get_model_list": [
      "self"
    ],
    "base_directory": [
      "self"
    ],
    "data_directory": [
      "self"
    ],
    "model_directory": [
      "self"
    ],
    "get_long_callback_manager": [
      "self"
    ]
  },
  "tab_style": [],
  "tab_selected_style": [],
  "create_banner": [
    "app"
  ],
  "create_layout": [],
  "data_table": [
    "df",
    "n",
    "page_size"
  ],
  "plot_timeseries": [
    "ts",
    "figure_height"
  ],
  "file_manager": [],
  "update_select_file_dropdown": [
    "n_clicks",
    "filename",
    "features",
    "label"
  ],
  "update_select_test_file_dropdown": [
    "n_clicks"
  ],
  "select_features": [
    "n_clicks",
    "train_file",
    "test_file",
    "label_name"
  ],
  "select_label": [
    "n_clicks",
    "train_file",
    "test_file",
    "features"
  ],
  "select_algorithm_parent": [
    "n_clicks",
    "selected_metrics"
  ],
  "select_algorithm": [
    "algorithm"
  ],
  "select_threshold_parent": [
    "n_clicks"
  ],
  "select_threshold": [
    "threshold"
  ],
  "click_train_test": [
    "set_progress",
    "train_clicks",
    "test_clicks",
    "modal_close",
    "train_filename",
    "test_filename",
    "columns",
    "algorithm",
    "label_column",
    "param_table",
    "threshold_class",
    "threshold_table",
    "train_percentage",
    "train_metrics",
    "file_mode"
  ],
  "set_file_mode": [
    "value"
  ],
  "select_target": [
    "n_clicks",
    "filename",
    "feat_names",
    "exog_names"
  ],
  "select_exog": [
    "n_clicks",
    "filename",
    "target_name",
    "feat_names"
  ],
  "DefaultEncoder": {
    "default": [
      "self",
      "obj"
    ]
  },
  "upload_file": [
    "filenames",
    "contents"
  ],
  "click_run": [
    "btn_click",
    "modal_close",
    "model"
  ],
  "update_metric_dropdown": [
    "n_clicks",
    "data"
  ],
  "update_metric_table": [
    "column",
    "data"
  ],
  "select_download_parent": [
    "n_clicks"
  ],
  "dash_logger": [],
  "AnomalyModel": {
    "univariate_algorithms": [],
    "multivariate_algorithms": [],
    "thresholds": [],
    "__init__": [
      "self"
    ],
    "get_available_algorithms": [
      "num_input_metrics"
    ],
    "get_available_thresholds": [],
    "get_threshold_info": [
      "threshold"
    ],
    "_compute_metrics": [
      "labels",
      "predictions"
    ],
    "_plot_anomalies": [
      "model",
      "ts",
      "scores",
      "labels"
    ],
    "_check": [
      "df",
      "columns",
      "label_column",
      "is_train"
    ],
    "train": [
      "self",
      "algorithm",
      "train_df",
      "test_df",
      "columns",
      "label_column",
      "params",
      "threshold_params",
      "set_progress"
    ],
    "test": [
      "self",
      "model",
      "df",
      "columns",
      "label_column",
      "threshold_params",
      "set_progress"
    ]
  },
  "DataMixin": {
    "load_data": [
      "self",
      "file_path",
      "nrows"
    ]
  },
  "ModelMixin": {
    "get_parameter_info": [
      "algorithm"
    ],
    "_param_info": [
      "function"
    ],
    "parse_parameters": [
      "param_info",
      "params"
    ],
    "save_model": [
      "directory",
      "model",
      "algorithm"
    ],
    "load_model": [
      "directory",
      "algorithm"
    ]
  },
  "ForecastModel": {
    "algorithms": [],
    "__init__": [
      "self"
    ],
    "get_available_algorithms": [],
    "_compute_metrics": [
      "evaluator",
      "ts",
      "predictions"
    ],
    "train": [
      "self",
      "algorithm",
      "train_df",
      "test_df",
      "target_column",
      "feature_columns",
      "exog_columns",
      "params",
      "set_progress"
    ]
  },
  "DataAnalyzer": {
    "__init__": [
      "self"
    ],
    "get_stats": [
      "df"
    ],
    "get_data_table": [
      "df"
    ],
    "get_data_figure": [
      "df"
    ]
  },
  "create_control_panel": [],
  "create_right_column": [],
  "create_anomaly_layout": [],
  "styles": [],
  "create_modal": [
    "modal_id",
    "header",
    "content",
    "content_id",
    "button_id"
  ],
  "create_param_table": [
    "params",
    "height"
  ],
  "create_metric_table": [
    "metrics"
  ],
  "create_empty_figure": [],
  "create_forecasting_layout": [],
  "create_stats_table": [
    "data_stats"
  ],
  "create_metric_stats_table": [
    "metric_stats",
    "column"
  ],
  "create_data_layout": [],
  "TimeSeriesGenerator": {
    "__init__": [
      "self",
      "f",
      "n",
      "x0",
      "step",
      "scale",
      "noise",
      "distort",
      "name",
      "t0",
      "tdelta"
    ],
    "n": [
      "self",
      "n"
    ],
    "x0": [
      "self",
      "x"
    ],
    "step": [
      "self",
      "step"
    ],
    "_update_steps": [
      "self"
    ],
    "y": [
      "self",
      "x"
    ],
    "generate": [
      "self",
      "return_ts"
    ],
    "_generate": [
      "self"
    ]
  },
  "GeneratorComposer": {
    "__init__": [
      "self",
      "generators",
      "per_generator_noise"
    ],
    "generators": [
      "self",
      "generators"
    ]
  },
  "GeneratorConcatenator": {
    "__init__": [
      "self",
      "string_outputs"
    ],
    "generators": [
      "self",
      "generators"
    ],
    "y": [
      "self",
      "x"
    ],
    "_generate": [
      "self"
    ]
  },
  "AlignPolicy": {
    "OuterJoin": [],
    "InnerJoin": [],
    "FixedReference": [],
    "FixedGranularity": []
  },
  "AggregationPolicy": {
    "Mean": [],
    "Sum": [],
    "Median": [],
    "First": [],
    "Last": [],
    "Min": [],
    "Max": []
  },
  "MissingValuePolicy": {
    "FFill": [],
    "BFill": [],
    "Nearest": [],
    "Interpolate": [],
    "ZFill": []
  },
  "to_pd_datetime": [
    "timestamp"
  ],
  "to_offset": [
    "dt"
  ],
  "to_timestamp": [
    "t"
  ],
  "granularity_str_to_seconds": [
    "granularity"
  ],
  "get_date_offset": [
    "time_stamps",
    "reference"
  ],
  "infer_granularity": [
    "time_stamps",
    "return_offset"
  ],
  "reindex_df": [
    "df",
    "reference",
    "missing_value_policy"
  ],
  "IStat": {
    "__init__": [
      "self",
      "value",
      "n"
    ],
    "n": [
      "self",
      "n"
    ],
    "value": [
      "self",
      "value"
    ],
    "add": [
      "self",
      "x"
    ],
    "drop": [
      "self",
      "x"
    ],
    "add_batch": [
      "self",
      "batch"
    ],
    "drop_batch": [
      "self",
      "batch"
    ]
  },
  "Mean": {
    "__init__": [
      "self",
      "value",
      "n"
    ],
    "value": [
      "self"
    ],
    "add": [
      "self",
      "x"
    ],
    "_add_first": [
      "self",
      "x"
    ],
    "_add": [
      "self",
      "x"
    ],
    "drop": [
      "self",
      "x"
    ]
  },
  "Variance": {
    "mean_class": [],
    "__init__": [
      "self",
      "ex_value",
      "ex2_value",
      "n",
      "ddof"
    ],
    "add": [
      "self",
      "x"
    ],
    "drop": [
      "self",
      "x"
    ],
    "true_value": [
      "self"
    ],
    "corrected_value": [
      "self"
    ],
    "value": [
      "self"
    ],
    "sd": [
      "self"
    ],
    "se": [
      "self"
    ]
  },
  "ExponentialMovingAverage": {
    "__init__": [
      "self",
      "recency_weight"
    ],
    "recency_weight": [
      "self",
      "weight"
    ],
    "value": [
      "self"
    ],
    "_add_first": [
      "self",
      "x"
    ],
    "_add": [
      "self",
      "x"
    ],
    "drop": [
      "self",
      "x"
    ]
  },
  "RecencyWeightedVariance": {
    "mean_class": [],
    "__init__": [
      "self",
      "recency_weight"
    ],
    "recency_weight": [
      "self",
      "weight"
    ],
    "drop": [
      "self",
      "x"
    ]
  },
  "_time_col_name": [],
  "UnivariateTimeSeries": {
    "__init__": [
      "self",
      "time_stamps",
      "values",
      "name",
      "freq"
    ],
    "np_time_stamps": [
      "self"
    ],
    "np_values": [
      "self"
    ],
    "time_stamps": [
      "self"
    ],
    "values": [
      "self"
    ],
    "t0": [
      "self"
    ],
    "tf": [
      "self"
    ],
    "is_empty": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "copy": [
      "self",
      "deep"
    ],
    "concat": [
      "self",
      "other"
    ],
    "bisect": [
      "self",
      "t",
      "t_in_left"
    ],
    "window": [
      "self",
      "t0",
      "tf",
      "include_tf"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "obj",
      "name"
    ],
    "to_pd": [
      "self"
    ],
    "from_pd": [
      "cls",
      "series",
      "name",
      "freq"
    ],
    "to_ts": [
      "self",
      "name"
    ],
    "empty": [
      "cls",
      "name"
    ]
  },
  "TimeSeries": {
    "__init__": [
      "self",
      "univariates"
    ],
    "names": [
      "self"
    ],
    "items": [
      "self"
    ],
    "dim": [
      "self"
    ],
    "rename": [
      "self",
      "mapper"
    ],
    "is_aligned": [
      "self"
    ],
    "index": [
      "self"
    ],
    "np_time_stamps": [
      "self"
    ],
    "time_stamps": [
      "self"
    ],
    "t0": [
      "self"
    ],
    "tf": [
      "self"
    ],
    "_txs_to_vec": [
      "txs"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ],
    "is_empty": [
      "self"
    ],
    "squeeze": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "concat": [
      "self",
      "other",
      "axis"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "bisect": [
      "self",
      "t",
      "t_in_left"
    ],
    "window": [
      "self",
      "t0",
      "tf",
      "include_tf"
    ],
    "to_pd": [
      "self"
    ],
    "to_csv": [
      "self",
      "file_name"
    ],
    "from_pd": [
      "cls",
      "df",
      "check_times",
      "drop_nan",
      "freq"
    ],
    "from_ts_list": [
      "cls",
      "ts_list"
    ],
    "align": [
      "self"
    ]
  },
  "assert_equal_timedeltas": [
    "time_series",
    "granularity",
    "offset"
  ],
  "_epsilon": [],
  "_log_pdet": [
    "a"
  ],
  "ConjPrior": {
    "__init__": [
      "self",
      "sample"
    ],
    "to_dict": [
      "self"
    ],
    "n_params": [
      "self"
    ],
    "from_dict": [
      "cls",
      "state_dict"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ],
    "get_time_series_values": [
      "x"
    ],
    "process_time_series": [
      "self",
      "x"
    ],
    "_process_return": [
      "x",
      "rv",
      "return_rv",
      "log"
    ],
    "posterior": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "update": [
      "self",
      "x"
    ],
    "forecast": [
      "self",
      "time_stamps"
    ]
  },
  "ScalarConjPrior": {
    "__init__": [
      "self",
      "sample"
    ],
    "process_time_series": [
      "self",
      "x"
    ],
    "get_time_series_values": [
      "x"
    ]
  },
  "BetaBernoulli": {
    "__init__": [
      "self",
      "sample"
    ],
    "n_params": [
      "self"
    ],
    "posterior": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "theta_posterior": [
      "self",
      "theta",
      "return_rv",
      "log"
    ],
    "update": [
      "self",
      "x"
    ],
    "forecast": [
      "self",
      "time_stamps"
    ]
  },
  "NormInvGamma": {
    "__init__": [
      "self",
      "sample"
    ],
    "n_params": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "mu_posterior": [
      "self",
      "mu",
      "return_rv",
      "log"
    ],
    "sigma2_posterior": [
      "self",
      "sigma2",
      "return_rv",
      "log"
    ],
    "posterior": [
      "self",
      "x",
      "log",
      "return_rv",
      "return_updated"
    ],
    "forecast": [
      "self",
      "time_stamps"
    ]
  },
  "MVNormInvWishart": {
    "__init__": [
      "self",
      "sample"
    ],
    "n_params": [
      "self"
    ],
    "process_time_series": [
      "self",
      "x"
    ],
    "update": [
      "self",
      "x"
    ],
    "mu_posterior": [
      "self",
      "mu",
      "return_rv",
      "log"
    ],
    "Sigma_posterior": [
      "self",
      "sigma2",
      "return_rv",
      "log"
    ],
    "posterior": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "forecast": [
      "self",
      "time_stamps",
      "name"
    ]
  },
  "BayesianLinReg": {
    "__init__": [
      "self",
      "sample"
    ],
    "n_params": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "posterior_explicit": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "posterior": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "forecast": [
      "self",
      "time_stamps"
    ]
  },
  "BayesianMVLinReg": {
    "__init__": [
      "self",
      "sample"
    ],
    "n_params": [
      "self"
    ],
    "process_time_series": [
      "self",
      "x"
    ],
    "update": [
      "self",
      "x"
    ],
    "posterior_explicit": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "posterior": [
      "self",
      "x",
      "return_rv",
      "log",
      "return_updated"
    ],
    "forecast": [
      "self",
      "time_stamps"
    ]
  },
  "minT_reconciliation": [
    "forecasts",
    "errs",
    "sum_matrix",
    "n_leaves"
  ],
  "AutodocABCMeta": {
    "__new__": [
      "mcs",
      "classname",
      "bases",
      "cls_dict"
    ]
  },
  "ModelConfigMeta": {
    "__new__": [
      "mcs",
      "classname",
      "bases",
      "cls_dict"
    ]
  },
  "combine_signatures": [
    "sig1",
    "sig2"
  ],
  "parse_basic_docstring": [
    "docstring"
  ],
  "ValIterOrderedDict": {
    "__iter__": [
      "self"
    ]
  },
  "dynamic_import": [
    "import_path",
    "alias"
  ],
  "call_with_accepted_kwargs": [
    "fn"
  ],
  "initializer": [
    "func"
  ],
  "ProgressBar": {
    "__init__": [
      "self",
      "total",
      "length",
      "decimals",
      "fill"
    ],
    "print": [
      "self",
      "iteration",
      "prefix",
      "suffix",
      "end"
    ]
  },
  "df_to_time_series": [
    "df",
    "time_col",
    "timestamp_unit",
    "data_cols"
  ],
  "data_io_decorator": [
    "func"
  ],
  "csv_to_time_series": [
    "file_name"
  ],
  "import_alias": [],
  "PostRuleFactory": {
    "get_post_rule_class": [
      "cls",
      "name"
    ],
    "create": [
      "cls",
      "name"
    ]
  },
  "PostRuleBase": {
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "state_dict"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ],
    "__repr__": [
      "self"
    ],
    "train": [
      "self",
      "anomaly_scores"
    ],
    "__call__": [
      "self",
      "anomaly_scores"
    ]
  },
  "AnomScoreCalibrator": {
    "__init__": [
      "self",
      "max_score",
      "abs_score",
      "anchors"
    ],
    "anchors": [
      "self",
      "anchors"
    ],
    "train": [
      "self",
      "anomaly_scores",
      "retrain_calibrator"
    ],
    "expected_max": [
      "n",
      "ub"
    ],
    "__call__": [
      "self",
      "anomaly_scores"
    ]
  },
  "PostRuleSequence": {
    "__init__": [
      "self",
      "post_rules"
    ],
    "train": [
      "self",
      "anomaly_scores"
    ],
    "__call__": [
      "self",
      "anomaly_scores"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "state_dict"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Threshold": {
    "__init__": [
      "self",
      "alm_threshold",
      "abs_score"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "train": [
      "self",
      "anomaly_scores",
      "anomaly_labels",
      "metric",
      "unsup_quantile",
      "max_early_sec",
      "max_delay_sec",
      "min_allowed_score"
    ],
    "to_simple_threshold": [
      "self"
    ]
  },
  "AggregateAlarms": {
    "threshold_class": [],
    "__init__": [
      "self",
      "alm_threshold",
      "abs_score",
      "min_alm_in_window",
      "alm_window_minutes",
      "alm_suppress_minutes"
    ],
    "alm_threshold": [
      "self",
      "x"
    ],
    "abs_score": [
      "self",
      "x"
    ],
    "window_secs": [
      "self"
    ],
    "suppress_secs": [
      "self"
    ],
    "filter": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "train": [
      "self",
      "anomaly_scores",
      "anomaly_labels",
      "metric",
      "unsup_quantile",
      "max_early_sec",
      "max_delay_sec",
      "min_allowed_score"
    ],
    "to_simple_threshold": [
      "self"
    ]
  },
  "get_adaptive_thres": [
    "x",
    "hist_gap_thres",
    "bin_sz"
  ],
  "AdaptiveThreshold": {
    "__init__": [
      "self",
      "alm_threshold",
      "abs_score",
      "bin_sz",
      "default_hist_gap_thres"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "train": [
      "self",
      "anomaly_scores",
      "anomaly_labels",
      "metric",
      "unsup_quantile",
      "max_early_sec",
      "max_delay_sec",
      "min_allowed_score"
    ]
  },
  "AdaptiveAggregateAlarms": {
    "threshold_class": [],
    "__init__": [
      "self",
      "alm_threshold",
      "abs_score",
      "min_alm_in_window",
      "alm_window_minutes",
      "alm_suppress_minutes",
      "bin_sz",
      "default_hist_gap_thres"
    ],
    "bin_sz": [
      "self",
      "x"
    ],
    "default_hist_gap_thres": [
      "self",
      "x"
    ]
  },
  "AbsVal": {
    "requires_inversion_state": [
      "self"
    ],
    "identity_inversion": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ]
  },
  "Rescale": {
    "__init__": [
      "self",
      "bias",
      "scale",
      "normalize_bias",
      "normalize_scale"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "is_trained": [
      "self"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "MeanVarNormalize": {
    "__init__": [
      "self",
      "bias",
      "scale",
      "normalize_bias",
      "normalize_scale"
    ],
    "train": [
      "self",
      "time_series"
    ]
  },
  "MinMaxNormalize": {
    "__init__": [
      "self",
      "bias",
      "scale",
      "normalize_bias",
      "normalize_scale"
    ],
    "train": [
      "self",
      "time_series"
    ]
  },
  "BoxCoxTransform": {
    "__init__": [
      "self",
      "lmbda",
      "offset"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "TransformFactory": {
    "get_transform_class": [
      "cls",
      "name"
    ],
    "create": [
      "cls",
      "name"
    ]
  },
  "TemporalResample": {
    "__init__": [
      "self",
      "granularity",
      "origin",
      "trainable_granularity",
      "remove_non_overlapping",
      "aggregation_policy",
      "missing_value_policy"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "proper_inversion": [
      "self"
    ],
    "granularity": [
      "self",
      "granularity"
    ],
    "aggregation_policy": [
      "self",
      "agg"
    ],
    "missing_value_policy": [
      "self",
      "mv"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ]
  },
  "Shingle": {
    "__init__": [
      "self",
      "size",
      "stride",
      "multivar_skip"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "TransformBase": {
    "__init__": [
      "self"
    ],
    "proper_inversion": [
      "self"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "identity_inversion": [
      "self"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "state"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "invert": [
      "self",
      "time_series",
      "retain_inversion_state"
    ],
    "_invert": [
      "self",
      "time_series"
    ],
    "__repr__": [
      "self"
    ]
  },
  "InvertibleTransformBase": {
    "proper_inversion": [
      "self"
    ],
    "identity_inversion": [
      "self"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "Identity": {
    "__init__": [
      "self"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "identity_inversion": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "LowerUpperClip": {
    "__init__": [
      "self",
      "lower",
      "upper"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ]
  },
  "TransformSequence": {
    "__init__": [
      "self",
      "transforms"
    ],
    "_extract_nontrivial_transforms": [
      "self",
      "transform"
    ],
    "proper_inversion": [
      "self"
    ],
    "identity_inversion": [
      "self"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "to_dict": [
      "self"
    ],
    "append": [
      "self",
      "transform"
    ],
    "from_dict": [
      "cls",
      "state"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "invert": [
      "self",
      "time_series",
      "retain_inversion_state"
    ],
    "_invert": [
      "self",
      "time_series"
    ],
    "__repr__": [
      "self"
    ]
  },
  "TransformStack": {
    "__init__": [
      "self",
      "transforms"
    ],
    "proper_inversion": [
      "self"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "invert": [
      "self",
      "time_series",
      "retain_inversion_state"
    ],
    "_invert": [
      "self",
      "time_series"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MovingAverage": {
    "__init__": [
      "self",
      "n_steps",
      "weights"
    ],
    "requires_inversion_state": [
      "self"
    ],
    "_n_pad": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "MovingPercentile": {
    "__init__": [
      "self",
      "n_steps",
      "q"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ]
  },
  "DifferenceTransform": {
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ]
  },
  "LagTransform": {
    "__init__": [
      "self",
      "k",
      "pad"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "__call__": [
      "self",
      "time_series"
    ],
    "_invert": [
      "self",
      "time_series"
    ],
    "compute_lag": [
      "self",
      "var"
    ]
  },
  "Anomalize": {
    "__init__": [
      "self",
      "anom_prob",
      "natural_bounds"
    ],
    "natural_bounds": [
      "self",
      "bounds"
    ],
    "is_trained": [
      "self"
    ],
    "random_is_anom": [
      "self"
    ],
    "__call__": [
      "self",
      "time_series",
      "label_anoms"
    ],
    "_anomalize_univariate": [
      "self",
      "var"
    ]
  },
  "Shock": {
    "__init__": [
      "self",
      "alpha",
      "pos_prob",
      "sd_range",
      "anom_width_range",
      "persist_shock"
    ],
    "anom_width_range": [
      "self",
      "range"
    ],
    "sd_range": [
      "self",
      "range"
    ],
    "random_sd_units": [
      "self"
    ],
    "random_anom_width": [
      "self"
    ],
    "random_is_anom": [
      "self"
    ],
    "train": [
      "self",
      "time_series"
    ],
    "_anomalize_univariate": [
      "self",
      "var"
    ]
  },
  "LevelShift": {
    "__init__": [
      "self"
    ]
  },
  "TrendChange": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "pos_prob",
      "scale_range"
    ],
    "scale_range": [
      "self",
      "scale_range"
    ],
    "random_scale": [
      "self"
    ],
    "_anomalize_univariate": [
      "self",
      "var"
    ],
    "train": [
      "self",
      "time_series"
    ]
  },
  "ModelFactory": {
    "get_model_class": [
      "cls",
      "name"
    ],
    "create": [
      "cls",
      "name",
      "return_unused_kwargs"
    ],
    "load": [
      "cls",
      "name",
      "model_path"
    ],
    "load_bytes": [
      "cls",
      "obj"
    ]
  },
  "instantiate_or_copy_model": [
    "model"
  ],
  "Config": {
    "filename": [],
    "_default_transform": [],
    "__init__": [
      "self",
      "transform"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "from_dict": [
      "cls",
      "config_dict",
      "return_unused_kwargs",
      "dim"
    ],
    "__reduce__": [
      "self"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ],
    "get_unused_kwargs": [
      "self"
    ]
  },
  "NormalizingConfig": {
    "__init__": [
      "self",
      "normalize"
    ],
    "full_transform": [
      "self"
    ],
    "transform": [
      "self",
      "transform"
    ]
  },
  "ModelBase": {
    "filename": [],
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "reset": [
      "self"
    ],
    "base_model": [
      "self"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "auto_align": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "supports_exog": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "__reduce__": [
      "self"
    ],
    "dim": [
      "self"
    ],
    "transform": [
      "self",
      "transform"
    ],
    "timedelta": [
      "self",
      "timedelta"
    ],
    "last_train_time": [
      "self",
      "last_train_time"
    ],
    "_pandas_train": [
      "self"
    ],
    "train_pre_process": [
      "self",
      "train_data"
    ],
    "transform_time_series": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "train_post_process": [
      "self",
      "train_result"
    ],
    "_save_state": [
      "self",
      "state_dict",
      "filename"
    ],
    "save": [
      "self",
      "dirname"
    ],
    "_load_state": [
      "self",
      "state_dict"
    ],
    "_load_state_dict": [
      "cls",
      "model_path"
    ],
    "load": [
      "cls",
      "dirname"
    ],
    "_from_config_state_dicts": [
      "cls",
      "config_dict",
      "state_dict"
    ],
    "to_bytes": [
      "self"
    ],
    "_to_serializable_comps": [
      "self"
    ],
    "from_bytes": [
      "cls",
      "obj"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ]
  },
  "MultipleTimeseriesModelMixin": {
    "train_multiple": [
      "self",
      "multiple_train_data",
      "train_config"
    ]
  },
  "_DETECTOR_MEMBERS": [],
  "_FORECASTER_MEMBERS": [],
  "_FORECASTER_EXOG_MEMBERS": [],
  "_is_detector_attr": [
    "base_model",
    "attr"
  ],
  "_is_forecaster_attr": [
    "base_model",
    "attr"
  ],
  "LayeredModelConfig": {
    "__init__": [
      "self",
      "model",
      "model_kwargs"
    ],
    "base_model": [
      "self"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "from_dict": [
      "cls",
      "config_dict",
      "return_unused_kwargs",
      "dim"
    ],
    "_remove_used_kwargs": [
      "config_dict",
      "kwargs"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ],
    "__getattr__": [
      "self",
      "item"
    ],
    "__setattr__": [
      "self",
      "key",
      "value"
    ],
    "get_unused_kwargs": [
      "self"
    ]
  },
  "_LAYERED_MEMBERS": [],
  "LayeredModel": {
    "config_class": [],
    "__new__": [
      "cls",
      "config",
      "model"
    ],
    "__init__": [
      "self",
      "config",
      "model"
    ],
    "_resolve_args": [
      "cls",
      "config",
      "model"
    ],
    "_pandas_train": [
      "self"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "model": [
      "self",
      "model"
    ],
    "base_model": [
      "self"
    ],
    "train_data": [
      "self",
      "train_data"
    ],
    "_default_train_config": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "__reduce__": [
      "self"
    ],
    "_save_state": [
      "self",
      "state_dict",
      "filename"
    ],
    "__getattr__": [
      "self",
      "item"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "train_pre_process": [
      "self",
      "train_data"
    ],
    "train_post_process": [
      "self",
      "train_result"
    ]
  },
  "LayeredDetector": {
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "LayeredForecaster": {
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ],
    "forecast": [
      "self",
      "time_stamps",
      "time_series_prev"
    ]
  },
  "LayeredForecastingDetector": {},
  "Optimizer": {
    "Adam": [],
    "AdamW": [],
    "SGD": [],
    "Adagrad": [],
    "RMSprop": []
  },
  "LossFunction": {
    "mse": [],
    "l1": [],
    "huber": [],
    "guassian_nll": []
  },
  "DeepConfig": {
    "__init__": [
      "self",
      "batch_size",
      "num_epochs",
      "optimizer",
      "loss_fn",
      "clip_gradient",
      "use_gpu",
      "ts_encoding",
      "lr",
      "weight_decay",
      "valid_fraction",
      "early_stop_patience"
    ],
    "optimizer": [
      "self",
      "optimizer"
    ],
    "loss_fn": [
      "self",
      "loss_fn"
    ]
  },
  "TorchModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp"
    ],
    "device": [
      "self"
    ]
  },
  "DeepModelBase": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "_create_model": [
      "self"
    ],
    "_get_batch_model_loss_and_outputs": [
      "self",
      "batch"
    ],
    "to_gpu": [
      "self"
    ],
    "to_cpu": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "DefaultDetectorConfig": {
    "__init__": [
      "self",
      "model",
      "granularity",
      "n_threads"
    ]
  },
  "DefaultDetector": {
    "config_class": [],
    "_default_post_rule_train_config": [
      "self"
    ],
    "granularity": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "anomaly_labels",
      "post_rule_train_config"
    ]
  },
  "DefaultForecasterConfig": {
    "__init__": [
      "self",
      "model",
      "max_forecast_steps",
      "target_seq_index",
      "granularity"
    ]
  },
  "DefaultForecaster": {
    "config_class": [],
    "supports_exog": [
      "self"
    ],
    "granularity": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ]
  },
  "DetectorConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "max_score",
      "threshold",
      "enable_calibrator",
      "enable_threshold"
    ],
    "post_rule": [
      "self"
    ],
    "from_dict": [
      "cls",
      "config_dict",
      "return_unused_kwargs",
      "calibrator"
    ]
  },
  "NoCalibrationDetectorConfig": {
    "__init__": [
      "self",
      "enable_calibrator"
    ],
    "calibrator": [
      "self",
      "calibrator"
    ],
    "enable_calibrator": [
      "self",
      "e"
    ]
  },
  "DetectorBase": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "_default_post_rule_train_config": [
      "self"
    ],
    "threshold": [
      "self",
      "threshold"
    ],
    "calibrator": [
      "self"
    ],
    "post_rule": [
      "self"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "anomaly_labels",
      "post_rule_train_config"
    ],
    "train_post_process": [
      "self",
      "train_result",
      "anomaly_labels",
      "post_rule_train_config"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_anomaly_label": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_figure": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "plot_anomaly": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "plot_anomaly_plotly": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "MultipleTimeseriesDetectorMixin": {
    "train_multiple": [
      "self",
      "multiple_train_data",
      "train_config",
      "anomaly_labels",
      "post_rule_train_config"
    ]
  },
  "StatThresholdConfig": {
    "__init__": [
      "self",
      "target_seq_index"
    ]
  },
  "StatThreshold": {
    "config_class": [],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "param_init": [
    "module",
    "init"
  ],
  "MLPNet": {
    "__init__": [
      "self",
      "dim_inp",
      "dim_out",
      "nhiddens",
      "bn"
    ],
    "forward": [
      "self",
      "x",
      "logit"
    ]
  },
  "get_dnn_loss_as_anomaly_score": [
    "tensor_x",
    "tensor_y",
    "use_cuda"
  ],
  "normalize_data": [
    "x"
  ],
  "DeepPointAnomalyDetectorConfig": {
    "_default_transform": [],
    "_default_threshold": []
  },
  "DeepPointAnomalyDetector": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_preprocess": [
      "self",
      "x"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "JVMSingleton": {
    "_gateway": [],
    "gateway": [
      "cls"
    ]
  },
  "RandomCutForestConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "n_estimators",
      "parallel",
      "seed",
      "max_n_samples",
      "thread_pool_size",
      "online_updates"
    ],
    "_default_threshold": [
      "self"
    ],
    "java_params": [
      "self"
    ]
  },
  "RandomCutForest": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "online_updates": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "_forest_predict": [
      "self",
      "data",
      "online_updates"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "SpectralResidualConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "local_wind_sz",
      "q",
      "estimated_points",
      "predicting_points",
      "target_seq_index"
    ]
  },
  "SpectralResidual": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "target_seq_index": [
      "self"
    ],
    "_get_saliency_map": [
      "self",
      "values"
    ],
    "_compute_grad": [
      "self",
      "values"
    ],
    "_pad": [
      "self",
      "values"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ]
  },
  "LSTMEDConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "hidden_size",
      "sequence_len",
      "n_layers",
      "dropout",
      "lr",
      "batch_size",
      "num_epochs"
    ]
  },
  "LSTMED": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_build_model": [
      "self",
      "dim"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "LSTMEDModule": {
    "__init__": [
      "self",
      "n_features",
      "hidden_size",
      "n_layers",
      "dropout",
      "device"
    ],
    "init_hidden_state": [
      "self",
      "batch_size"
    ],
    "forward": [
      "self",
      "x",
      "return_latent"
    ]
  },
  "IsolationForestConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "max_n_samples",
      "n_estimators",
      "n_jobs"
    ]
  },
  "IsolationForest": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "MonthlyWindStatsConfig": {
    "_default_transform": [],
    "_default_threshold": [
      "self"
    ],
    "__init__": [
      "self",
      "wind_sz",
      "max_day"
    ]
  },
  "MonthlyWindStats": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_post_rule_train_config": [
      "self"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ]
  },
  "ZMSConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "base",
      "n_lags",
      "lag_inflation"
    ],
    "full_transform": [
      "self"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "n_lags": [
      "self",
      "n"
    ]
  },
  "ZMS": {
    "config_class": [],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "n_lags": [
      "self",
      "n_lags"
    ],
    "lag_scales": [
      "self"
    ],
    "lag_inflation": [
      "self"
    ],
    "adjust_z_scores": [
      "self"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "anomaly_labels",
      "post_rule_train_config"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "RunWindStats": {
    "__init__": [
      "self",
      "threshold",
      "enable_weekly",
      "enable_monthly",
      "post_rule_on_anom_score",
      "WeeklyWindStatsConfig",
      "MonthlyWindStatsConfig",
      "return_score"
    ],
    "anomalyByScore": [
      "self",
      "scores",
      "threshold"
    ],
    "get_anomaly_label": [
      "self",
      "model",
      "ts"
    ],
    "run": [
      "self",
      "ts"
    ]
  },
  "WindStatsConfig": {
    "_default_transform": [],
    "_default_threshold": [
      "self"
    ],
    "__init__": [
      "self",
      "wind_sz",
      "max_day"
    ]
  },
  "WindStats": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_post_rule_train_config": [
      "self"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ]
  },
  "AutoEncoderConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "hidden_size",
      "layer_sizes",
      "sequence_len",
      "lr",
      "batch_size",
      "num_epochs"
    ]
  },
  "AutoEncoder": {
    "config_class": [],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "__init__": [
      "self",
      "config"
    ],
    "_build_model": [
      "self",
      "dim"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "AEModule": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "layer_sizes",
      "activation",
      "dropout_prob"
    ],
    "forward": [
      "self",
      "x"
    ],
    "loss": [
      "self",
      "x"
    ]
  },
  "MLP": {
    "__init__": [
      "self",
      "input_size",
      "output_size",
      "layer_sizes",
      "activation",
      "last_layer_activation",
      "dropout_prob"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "LOFConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "n_neighbors",
      "algorithm",
      "leaf_size",
      "metric",
      "p",
      "metric_params",
      "contamination",
      "n_jobs",
      "novelty"
    ]
  },
  "LOF": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "DAGMMConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "gmm_k",
      "hidden_size",
      "sequence_len",
      "lambda_energy",
      "lambda_cov_diag",
      "lr",
      "batch_size",
      "num_epochs"
    ]
  },
  "DAGMM": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "_build_model": [
      "self",
      "dim"
    ],
    "_step": [
      "self",
      "input_data",
      "max_grad_norm"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "train_multiple": [
      "self",
      "multiple_train_data",
      "train_config",
      "anomaly_labels",
      "post_rule_train_config"
    ]
  },
  "DAGMMModule": {
    "__init__": [
      "self",
      "autoencoder",
      "n_gmm",
      "latent_dim",
      "device"
    ],
    "relative_euclidean_distance": [
      "a",
      "b",
      "dim"
    ],
    "forward": [
      "self",
      "x"
    ],
    "compute_gmms": [
      "self",
      "z",
      "gamma"
    ],
    "compute_energy": [
      "self",
      "z",
      "phi",
      "mu",
      "cov",
      "size_average",
      "eps"
    ],
    "loss_func": [
      "self",
      "x",
      "recon_x",
      "z",
      "gamma",
      "lambda_energy",
      "lambda_cov_diag"
    ]
  },
  "DynamicBaselineConfig": {
    "_default_trends": [],
    "__init__": [
      "self",
      "fixed_period",
      "train_window",
      "wind_sz",
      "trends"
    ],
    "fixed_period": [
      "self",
      "period"
    ],
    "trends": [
      "self",
      "trends"
    ],
    "determine_train_window": [
      "self"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ]
  },
  "DynamicBaseline": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_post_rule_train_config": [
      "self"
    ],
    "train_window": [
      "self"
    ],
    "fixed_period": [
      "self"
    ],
    "has_fixed_period": [
      "self"
    ],
    "data": [
      "self",
      "data"
    ],
    "get_relevant": [
      "self",
      "data"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_baseline": [
      "self",
      "time_stamps"
    ],
    "update": [
      "self",
      "new_data"
    ],
    "get_baseline_figure": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "Trend": {
    "daily": [],
    "weekly": [],
    "monthly": []
  },
  "Segment": {
    "__init__": [
      "self",
      "key"
    ],
    "add": [
      "self",
      "x"
    ],
    "drop": [
      "self",
      "x"
    ],
    "score": [
      "self",
      "x"
    ]
  },
  "Segmenter": {
    "day_delta": [],
    "hour_delta": [],
    "min_delta": [],
    "zero_delta": [],
    "__init__": [
      "self",
      "trends",
      "wind_sz"
    ],
    "reset": [
      "self"
    ],
    "wind_delta": [
      "self"
    ],
    "trends": [
      "self"
    ],
    "trend": [
      "self",
      "trends"
    ],
    "window_key": [
      "self",
      "t"
    ],
    "weekday_key": [
      "self",
      "t"
    ],
    "day_key": [
      "self",
      "t"
    ],
    "segment_key": [
      "self",
      "timestamp"
    ],
    "add": [
      "self",
      "t",
      "x"
    ],
    "drop": [
      "self",
      "t",
      "x"
    ],
    "score": [
      "self",
      "t",
      "x"
    ],
    "get_baseline": [
      "self",
      "t"
    ]
  },
  "VAEConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "encoder_hidden_sizes",
      "decoder_hidden_sizes",
      "latent_size",
      "sequence_len",
      "kld_weight",
      "dropout_rate",
      "num_eval_samples",
      "lr",
      "batch_size",
      "num_epochs"
    ]
  },
  "VAE": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_build_model": [
      "self",
      "dim"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "CVAE": {
    "__init__": [
      "self",
      "x_dim",
      "c_dim",
      "encoder_hidden_sizes",
      "decoder_hidden_sizes",
      "latent_size",
      "dropout_rate",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "c"
    ],
    "reparameterize": [
      "self",
      "mu",
      "log_var"
    ],
    "inference": [
      "self",
      "z",
      "c"
    ]
  },
  "Encoder": {
    "__init__": [
      "self",
      "x_dim",
      "c_dim",
      "hidden_sizes",
      "latent_size",
      "dropout_rate",
      "activation"
    ],
    "_init_log_var_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "c"
    ]
  },
  "Decoder": {
    "__init__": [
      "self",
      "x_dim",
      "c_dim",
      "hidden_sizes",
      "latent_size",
      "dropout_rate",
      "activation"
    ],
    "forward": [
      "self",
      "z",
      "c"
    ]
  },
  "build_hidden_layers": [
    "input_size",
    "hidden_sizes",
    "dropout_rate",
    "activation"
  ],
  "ChangeKind": {
    "Auto": [],
    "LevelShift": [],
    "TrendChange": []
  },
  "_PosteriorBeam": {
    "__init__": [
      "self",
      "run_length",
      "posterior",
      "cp_prior",
      "logp"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "BOCPDConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "change_kind",
      "cp_prior",
      "lag",
      "min_likelihood",
      "max_forecast_steps"
    ],
    "change_kind": [
      "self",
      "change_kind"
    ]
  },
  "BOCPD": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "_pandas_train": [
      "self"
    ],
    "_online_model": [
      "self"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "last_train_time": [
      "self",
      "t"
    ],
    "n_seen": [
      "self"
    ],
    "change_kind": [
      "self"
    ],
    "cp_prior": [
      "self"
    ],
    "lag": [
      "self"
    ],
    "min_likelihood": [
      "self"
    ],
    "_create_posterior": [
      "self",
      "logp"
    ],
    "_get_anom_scores": [
      "self",
      "time_stamps"
    ],
    "_update_model": [
      "self",
      "timestamps"
    ],
    "train_pre_process": [
      "self",
      "train_data",
      "exog_data",
      "return_exog"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ],
    "update": [
      "self",
      "time_series"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_figure": [
      "self"
    ]
  },
  "ProphetDetectorConfig": {
    "_default_threshold": []
  },
  "ProphetDetector": {
    "config_class": []
  },
  "ForecastingDetectorBase": {
    "_default_post_rule_train_config": [
      "self"
    ],
    "forecast_to_anom_score": [
      "self",
      "time_series",
      "forecast",
      "stderr"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "exog_data",
      "anomaly_labels",
      "post_rule_train_config"
    ],
    "train_post_process": [
      "self",
      "train_result",
      "anomaly_labels",
      "post_rule_train_config"
    ],
    "get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ],
    "get_anomaly_label": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "get_figure": [
      "self"
    ],
    "plot_anomaly": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "plot_anomaly_plotly": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "plot_forecast": [
      "self"
    ],
    "plot_forecast_plotly": [
      "self"
    ]
  },
  "MSESDetectorConfig": {
    "_default_threshold": [],
    "__init__": [
      "self",
      "max_forecast_steps",
      "online_updates"
    ]
  },
  "MSESDetector": {
    "config_class": [],
    "online_updates": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ]
  },
  "ArimaDetectorConfig": {
    "_default_threshold": []
  },
  "ArimaDetector": {
    "config_class": []
  },
  "ETSDetectorConfig": {
    "_default_threshold": []
  },
  "ETSDetector": {
    "config_class": []
  },
  "SarimaDetectorConfig": {
    "_default_threshold": []
  },
  "SarimaDetector": {
    "config_class": []
  },
  "_TreeEnsembleForecasterConfig": {
    "__init__": [
      "self",
      "n_estimators",
      "max_depth",
      "random_state"
    ]
  },
  "RandomForestForecasterConfig": {
    "__init__": [
      "self",
      "min_samples_split"
    ]
  },
  "RandomForestForecaster": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "ExtraTreesForecasterConfig": {
    "__init__": [
      "self",
      "min_samples_split"
    ]
  },
  "ExtraTreesForecaster": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "LGBMForecasterConfig": {
    "__init__": [
      "self",
      "learning_rate",
      "n_jobs"
    ]
  },
  "LGBMForecaster": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "_suppress_stdout_stderr": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "ProphetConfig": {
    "__init__": [
      "self",
      "max_forecast_steps",
      "target_seq_index",
      "yearly_seasonality",
      "weekly_seasonality",
      "daily_seasonality",
      "seasonality_mode",
      "holidays",
      "uncertainty_samples"
    ]
  },
  "Prophet": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "yearly_seasonality": [
      "self"
    ],
    "weekly_seasonality": [
      "self"
    ],
    "daily_seasonality": [
      "self"
    ],
    "add_seasonality": [
      "self"
    ],
    "seasonality_mode": [
      "self"
    ],
    "holidays": [
      "self"
    ],
    "uncertainty_samples": [
      "self"
    ],
    "set_seasonality": [
      "self",
      "theta",
      "train_data"
    ],
    "_add_exog_data": [
      "self",
      "data",
      "exog_data"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ]
  },
  "MSESConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "max_forecast_steps",
      "max_backstep",
      "recency_weight",
      "accel_weight",
      "optimize_acc",
      "eta",
      "rho",
      "phi",
      "inflation"
    ],
    "max_scale": [
      "self"
    ],
    "backsteps": [
      "self"
    ]
  },
  "MSESTrainConfig": {
    "__init__": [
      "self",
      "incremental",
      "process_losses",
      "tune_recency_weights",
      "init_batch_sz",
      "train_cadence"
    ]
  },
  "MSES": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "_pandas_train": [
      "self"
    ],
    "rho": [
      "self"
    ],
    "backsteps": [
      "self"
    ],
    "max_horizon": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_incremental_train": [
      "self",
      "train_data",
      "train_cadence",
      "process_losses",
      "tune_recency_weights"
    ],
    "update": [
      "self",
      "new_data",
      "tune_recency_weights",
      "train_cadence"
    ],
    "_compute_losses": [
      "self",
      "data",
      "return_forecast"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ],
    "_forecast_hb": [
      "self",
      "horizon",
      "backstep"
    ],
    "xhat_h": [
      "self",
      "horizon"
    ],
    "marginalize_xhat_h": [
      "self",
      "horizon",
      "xhat_h"
    ]
  },
  "DeltaStats": {
    "__init__": [
      "self",
      "scale",
      "recency_weight"
    ],
    "lag": [
      "self"
    ],
    "update_velocity": [
      "self",
      "vels"
    ],
    "update_acceleration": [
      "self",
      "accs"
    ],
    "update_loss": [
      "self",
      "losses"
    ],
    "tune": [
      "self",
      "losses",
      "eta"
    ]
  },
  "DeltaEstimator": {
    "__init__": [
      "self",
      "max_scale",
      "recency_weight",
      "accel_weight",
      "optimize_acc",
      "eta",
      "phi",
      "data",
      "stats"
    ],
    "max_scale": [
      "self",
      "scale"
    ],
    "acc_max_scale": [
      "self"
    ],
    "data": [
      "self",
      "data"
    ],
    "x": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "train": [
      "self",
      "new_data"
    ],
    "process_losses": [
      "self",
      "scale_losses",
      "tune_recency_weights"
    ],
    "velocity": [
      "self",
      "scale"
    ],
    "acceleration": [
      "self",
      "scale"
    ],
    "vel_err": [
      "self",
      "scale"
    ],
    "pos_err": [
      "self",
      "scale"
    ],
    "neg_err": [
      "self",
      "scale"
    ],
    "loss_err": [
      "self",
      "scale"
    ],
    "delta_hat": [
      "self",
      "scale"
    ]
  },
  "ForecasterConfig": {
    "__init__": [
      "self",
      "max_forecast_steps",
      "target_seq_index",
      "invert_transform"
    ]
  },
  "ForecasterBase": {
    "config_class": [],
    "target_name": [],
    "__init__": [
      "self",
      "config"
    ],
    "max_forecast_steps": [
      "self"
    ],
    "target_seq_index": [
      "self"
    ],
    "invert_transform": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "support_multivariate_output": [
      "self"
    ],
    "resample_time_stamps": [
      "self",
      "time_stamps",
      "time_series_prev"
    ],
    "train_pre_process": [
      "self",
      "train_data",
      "exog_data",
      "return_exog"
    ],
    "train": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "train_post_process": [
      "self",
      "train_result"
    ],
    "transform_exog_data": [
      "self",
      "exog_data",
      "time_stamps",
      "time_series_prev"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "exog_data",
      "return_iqr",
      "return_prev"
    ],
    "_process_forecast": [
      "self",
      "forecast",
      "err",
      "time_series_prev",
      "return_prev",
      "return_iqr"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ],
    "batch_forecast": [
      "self",
      "time_stamps_list",
      "time_series_prev_list",
      "return_iqr",
      "return_prev"
    ],
    "get_figure": [
      "self"
    ],
    "plot_forecast": [
      "self"
    ],
    "plot_forecast_plotly": [
      "self"
    ]
  },
  "ForecasterExogConfig": {
    "_default_exog_transform": [],
    "__init__": [
      "self",
      "exog_transform",
      "exog_aggregation_policy",
      "exog_missing_value_policy"
    ],
    "exog_aggregation_policy": [
      "self",
      "agg"
    ],
    "exog_missing_value_policy": [
      "self",
      "mv"
    ]
  },
  "ForecasterExogBase": {
    "supports_exog": [
      "self"
    ],
    "exog_transform": [
      "self"
    ],
    "exog_aggregation_policy": [
      "self"
    ],
    "exog_missing_value_policy": [
      "self"
    ],
    "transform_exog_data": [
      "self",
      "exog_data",
      "time_stamps",
      "time_series_prev"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ]
  },
  "DeepARConfig": {
    "__init__": [
      "self",
      "n_past",
      "max_forecast_steps",
      "hidden_size",
      "num_hidden_layers",
      "lags_seq",
      "num_prediction_samples",
      "loss_fn"
    ]
  },
  "DeepARModel": {
    "__init__": [
      "self",
      "config"
    ],
    "get_lagged_subsequences": [
      "sequence",
      "sequence_length",
      "indices",
      "subsequences_length"
    ],
    "unroll_encoder": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "future"
    ],
    "calculate_loss": [
      "self",
      "past",
      "past_timestamp",
      "future",
      "future_timestamp"
    ],
    "sampling_decoder": [
      "self",
      "past",
      "time_features",
      "begin_states"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "mean_samples"
    ]
  },
  "DeepARForecaster": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "_get_batch_model_loss_and_outputs": [
      "self",
      "batch"
    ]
  },
  "TransformerConfig": {
    "__init__": [
      "self",
      "n_past",
      "max_forecast_steps",
      "encoder_input_size",
      "decoder_input_size",
      "num_encoder_layers",
      "num_decoder_layers",
      "start_token_len",
      "factor",
      "model_dim",
      "embed",
      "dropout",
      "activation",
      "n_heads",
      "fcn_dim",
      "distil"
    ]
  },
  "TransformerModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "enc_self_mask",
      "dec_self_mask",
      "dec_enc_mask"
    ]
  },
  "TransformerForecaster": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "SKLearnForecasterConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "maxlags",
      "max_forecast_steps",
      "target_seq_index",
      "prediction_stride"
    ]
  },
  "SKLearnForecaster": {
    "config_class": [],
    "model": [],
    "__init__": [
      "self",
      "config"
    ],
    "maxlags": [
      "self"
    ],
    "prediction_stride": [
      "self"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "_set_params": [
      "self",
      "train_data",
      "fit"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ],
    "_predict": [
      "self",
      "prev",
      "exog_data",
      "n_steps"
    ],
    "_hybrid_forecast": [
      "self",
      "inputs",
      "exog_data",
      "steps"
    ],
    "_autoregressive_forecast": [
      "self",
      "inputs",
      "exog_data",
      "steps"
    ],
    "_update_prior": [
      "self",
      "prior",
      "next_forecast",
      "for_univariate"
    ],
    "_get_immedidate_forecasting_prior": [
      "self",
      "data"
    ]
  },
  "ArimaConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "order",
      "seasonal_order"
    ],
    "seasonal_order": [
      "self",
      "seasonal_order"
    ]
  },
  "Arima": {
    "config_class": []
  },
  "ETSConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "max_forecast_steps",
      "target_seq_index",
      "error",
      "trend",
      "damped_trend",
      "seasonal",
      "seasonal_periods",
      "refit"
    ]
  },
  "ETS": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "error": [
      "self"
    ],
    "trend": [
      "self"
    ],
    "damped_trend": [
      "self"
    ],
    "seasonal": [
      "self"
    ],
    "seasonal_periods": [
      "self"
    ],
    "set_seasonality": [
      "self",
      "theta",
      "train_data"
    ],
    "_max_lookback": [
      "self"
    ],
    "_instantiate_model": [
      "self",
      "data"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ]
  },
  "DeepForecasterConfig": {
    "__init__": [
      "self",
      "n_past"
    ]
  },
  "DeepForecaster": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "_get_np_loss_and_prediction": [
      "self",
      "eval_dataset"
    ],
    "support_multivariate_output": [
      "self"
    ],
    "_convert_batch_to_tensors": [
      "self",
      "batch"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "_get_batch_model_loss_and_outputs": [
      "self",
      "batch"
    ],
    "require_even_sampling": [
      "self"
    ],
    "_forecast": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev"
    ]
  },
  "VectorARConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "maxlags",
      "target_seq_index"
    ]
  },
  "VectorAR": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "maxlags": [
      "self"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ]
  },
  "ETSformerConfig": {
    "__init__": [
      "self",
      "n_past",
      "max_forecast_steps",
      "encoder_input_size",
      "decoder_input_size",
      "num_encoder_layers",
      "num_decoder_layers",
      "model_dim",
      "dropout",
      "n_heads",
      "fcn_dim",
      "top_K",
      "sigma"
    ]
  },
  "ETSformerModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "enc_self_mask",
      "dec_self_mask",
      "dec_enc_mask",
      "attention"
    ],
    "transform": [
      "self",
      "x"
    ],
    "jitter": [
      "self",
      "x"
    ],
    "scale": [
      "self",
      "x"
    ],
    "shift": [
      "self",
      "x"
    ]
  },
  "ETSformerForecaster": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "AutoformerConfig": {
    "__init__": [
      "self",
      "n_past",
      "max_forecast_steps",
      "moving_avg",
      "encoder_input_size",
      "decoder_input_size",
      "num_encoder_layers",
      "num_decoder_layers",
      "start_token_len",
      "factor",
      "model_dim",
      "embed",
      "dropout",
      "activation",
      "n_heads",
      "fcn_dim"
    ]
  },
  "AutoformerModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "enc_self_mask",
      "dec_self_mask",
      "dec_enc_mask"
    ]
  },
  "AutoformerForecaster": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "SarimaConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "order",
      "seasonal_order"
    ]
  },
  "Sarima": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "require_even_sampling": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "order": [
      "self"
    ],
    "seasonal_order": [
      "self"
    ],
    "_max_lookback": [
      "self"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ],
    "set_seasonality": [
      "self",
      "theta",
      "train_data"
    ]
  },
  "InformerConfig": {
    "__init__": [
      "self",
      "n_past",
      "max_forecast_steps",
      "encoder_input_size",
      "decoder_input_size",
      "num_encoder_layers",
      "num_decoder_layers",
      "start_token_len",
      "factor",
      "model_dim",
      "embed",
      "dropout",
      "activation",
      "n_heads",
      "fcn_dim",
      "distil"
    ]
  },
  "InformerModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past",
      "past_timestamp",
      "future_timestamp",
      "enc_self_mask",
      "dec_self_mask",
      "dec_enc_mask"
    ]
  },
  "InformerForecaster": {
    "config_class": [],
    "deep_model_class": [],
    "__init__": [
      "self",
      "config"
    ]
  },
  "_model_name": [
    "model_spec"
  ],
  "diff": [
    "x",
    "lag",
    "differences"
  ],
  "_root_test": [
    "model_fit",
    "ic"
  ],
  "_fit_sarima_model": [
    "y",
    "order",
    "seasonal_order",
    "trend",
    "method",
    "maxiter",
    "information_criterion",
    "exog"
  ],
  "_refit_sarima_model": [
    "model_fitted",
    "approx_ic",
    "method",
    "inititer",
    "maxiter",
    "information_criterion"
  ],
  "detect_maxiter_sarima_model": [
    "y",
    "d",
    "D",
    "m",
    "method",
    "information_criterion",
    "exog"
  ],
  "seas_seasonalstationaritytest": [
    "x",
    "m"
  ],
  "nsdiffs": [
    "x",
    "m",
    "max_D",
    "test"
  ],
  "KPSS_stationaritytest": [
    "xx",
    "alpha"
  ],
  "ndiffs": [
    "x",
    "alpha",
    "max_d",
    "test"
  ],
  "_StepwiseFitWrapper": {
    "__init__": [
      "self",
      "y",
      "p",
      "d",
      "q",
      "P",
      "D",
      "Q",
      "m",
      "max_p",
      "max_q",
      "max_P",
      "max_Q",
      "trend",
      "method",
      "maxiter",
      "information_criterion",
      "relative_improve",
      "max_k",
      "max_dur",
      "exog"
    ],
    "_do_fit": [
      "self",
      "order",
      "seasonal_order",
      "trend"
    ],
    "stepwisesearch": [
      "self"
    ]
  },
  "TimeFeature": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "index"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SecondOfMinute": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MinuteOfHour": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "HourOfDay": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfWeek": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfMonth": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MonthOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "WeekOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "time_features_from_frequency_str": [
    "freq_str"
  ],
  "get_time_features": [
    "dates",
    "ts_encoding"
  ],
  "RollingWindowDataset": {
    "__init__": [
      "self",
      "data",
      "target_seq_index",
      "n_past",
      "n_future",
      "exog_data",
      "shuffle",
      "ts_index",
      "batch_size",
      "flatten",
      "ts_encoding",
      "valid_fraction",
      "validation",
      "seed"
    ],
    "validation": [
      "self",
      "valid"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "n_windows": [
      "self"
    ],
    "n_valid": [
      "self"
    ],
    "n_train": [
      "self"
    ],
    "n_points": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "collate_batch": [
      "self",
      "batch"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "EarlyStopping": {
    "__init__": [
      "self",
      "patience",
      "delta"
    ],
    "__call__": [
      "self",
      "val_loss",
      "model"
    ],
    "save_best_state_and_dict": [
      "self",
      "val_loss",
      "model"
    ],
    "load_best_model": [
      "self",
      "model"
    ]
  },
  "AutoCorrelation": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "time_delay_agg_training": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_inference": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_full": [
      "self",
      "values",
      "corr"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "TriangularCausalMask": {
    "__init__": [
      "self",
      "B",
      "L",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "ProbMask": {
    "__init__": [
      "self",
      "B",
      "H",
      "L",
      "index",
      "scores",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "FullAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "ProbAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "_prob_QK": [
      "self",
      "Q",
      "K",
      "sample_k",
      "n_top"
    ],
    "_get_initial_context": [
      "self",
      "V",
      "L_Q"
    ],
    "_update_context": [
      "self",
      "context_in",
      "V",
      "scores",
      "index",
      "L_Q",
      "attn_mask"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "SeasonalLayernorm": {
    "__init__": [
      "self",
      "channels"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MovingAverageBlock": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SeriesDecomposeBlock": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "conv1d_fft": [
    "f",
    "g",
    "dim"
  ],
  "ExponentialSmoothing": {
    "__init__": [
      "self",
      "dim",
      "nhead",
      "dropout",
      "aux"
    ],
    "forward": [
      "self",
      "values",
      "aux_values"
    ],
    "get_exponential_weight": [
      "self",
      "T"
    ],
    "weight": [
      "self"
    ]
  },
  "EncoderLayer": {
    "__init__": [
      "self",
      "attention",
      "d_model",
      "d_ff",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "DecoderLayer": {
    "__init__": [
      "self",
      "self_attention",
      "cross_attention",
      "d_model",
      "d_ff",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask"
    ]
  },
  "ConvLayer": {
    "__init__": [
      "self",
      "c_in"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MLPLayer": {
    "__init__": [
      "self",
      "d_model",
      "dim_feedforward",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "AutoCorrelationLayer": {
    "__init__": [
      "self",
      "correlation",
      "d_model",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "AttentionLayer": {
    "__init__": [
      "self",
      "attention",
      "d_model",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "GrowthLayer": {
    "__init__": [
      "self",
      "d_model",
      "nhead",
      "d_head",
      "dropout",
      "output_attention"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "FourierLayer": {
    "__init__": [
      "self",
      "d_model",
      "pred_len",
      "k",
      "low_freq",
      "output_attention"
    ],
    "forward": [
      "self",
      "x"
    ],
    "extrapolate": [
      "self",
      "x_freq",
      "f",
      "t"
    ],
    "topk_freq": [
      "self",
      "x_freq"
    ],
    "dft_forward": [
      "self",
      "x"
    ]
  },
  "LevelLayer": {
    "__init__": [
      "self",
      "d_model",
      "c_out",
      "dropout"
    ],
    "forward": [
      "self",
      "level",
      "growth",
      "season"
    ]
  },
  "DampingLayer": {
    "__init__": [
      "self",
      "pred_len",
      "nhead",
      "dropout",
      "output_attention"
    ],
    "forward": [
      "self",
      "x"
    ],
    "damping_factor": [
      "self"
    ]
  },
  "PositionalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TokenEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FixedEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeFeatureEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DataEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "DataEmbeddingWoPos": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "ETSEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "AutoETSConfig": {
    "__init__": [
      "self",
      "model",
      "auto_seasonality",
      "auto_error",
      "auto_trend",
      "auto_seasonal",
      "auto_damped",
      "periodicity_strategy",
      "information_criterion",
      "additive_only",
      "allow_multiplicative_trend",
      "restrict"
    ]
  },
  "AutoETS": {
    "config_class": [],
    "__init__": [
      "self",
      "config"
    ],
    "generate_theta": [
      "self",
      "train_data"
    ],
    "set_theta": [
      "self",
      "model",
      "theta",
      "train_data"
    ],
    "_model_name": [
      "self",
      "theta"
    ],
    "get_ic": [
      "self",
      "model",
      "train_data",
      "train_result"
    ]
  },
  "AutoProphetConfig": {
    "__init__": [
      "self",
      "model",
      "periodicity_strategy",
      "information_criterion"
    ],
    "multi_seasonality": [
      "self"
    ]
  },
  "AutoProphet": {
    "config_class": [],
    "supports_exog": [
      "self"
    ],
    "generate_theta": [
      "self",
      "train_data"
    ],
    "set_theta": [
      "self",
      "model",
      "theta",
      "train_data"
    ],
    "_model_name": [
      "self",
      "theta"
    ],
    "get_ic": [
      "self",
      "model",
      "train_data",
      "train_result"
    ]
  },
  "AutoMLMixIn": {
    "_pandas_train": [
      "self"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config"
    ],
    "generate_theta": [
      "self",
      "train_data"
    ],
    "evaluate_theta": [
      "self",
      "thetas",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "set_theta": [
      "self",
      "model",
      "theta",
      "train_data"
    ]
  },
  "InformationCriterion": {
    "AIC": [],
    "BIC": [],
    "AICc": []
  },
  "ICConfig": {
    "__init__": [
      "self",
      "information_criterion"
    ],
    "information_criterion": [
      "self",
      "ic"
    ]
  },
  "ICAutoMLForecaster": {
    "config_class": [],
    "information_criterion": [
      "self"
    ],
    "get_ic": [
      "self",
      "model",
      "train_data",
      "train_result"
    ],
    "_model_name": [
      "self",
      "theta"
    ],
    "evaluate_theta": [
      "self",
      "thetas",
      "train_data",
      "train_config",
      "exog_data"
    ]
  },
  "GridSearch": {
    "__init__": [
      "self",
      "param_values",
      "restrictions"
    ],
    "__iter__": [
      "self"
    ]
  },
  "AutoSarimaConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "model",
      "auto_seasonality",
      "periodicity_strategy",
      "auto_pqPQ",
      "auto_d",
      "auto_D",
      "maxiter",
      "max_k",
      "max_dur",
      "approximation",
      "approx_iter"
    ],
    "order": [
      "self"
    ],
    "seasonal_order": [
      "self"
    ]
  },
  "AutoSarima": {
    "config_class": [],
    "supports_exog": [
      "self"
    ],
    "_generate_sarima_parameters": [
      "self",
      "train_data"
    ],
    "generate_theta": [
      "self",
      "train_data"
    ],
    "evaluate_theta": [
      "self",
      "thetas",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "set_theta": [
      "self",
      "model",
      "theta",
      "train_data"
    ]
  },
  "PeriodicityStrategy": {
    "ACF": [],
    "Min": [],
    "Max": [],
    "All": []
  },
  "SeasonalityModel": {
    "set_seasonality": [
      "self",
      "theta",
      "train_data"
    ]
  },
  "SeasonalityConfig": {
    "_default_transform": [],
    "__init__": [
      "self",
      "model",
      "periodicity_strategy",
      "pval",
      "max_lag"
    ],
    "multi_seasonality": [
      "self"
    ],
    "periodicity_strategy": [
      "self",
      "p"
    ]
  },
  "SeasonalityLayer": {
    "config_class": [],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "multi_seasonality": [
      "self"
    ],
    "periodicity_strategy": [
      "self"
    ],
    "pval": [
      "self"
    ],
    "max_lag": [
      "self"
    ],
    "detect_seasonality": [
      "x",
      "max_lag",
      "pval",
      "periodicity_strategy"
    ],
    "set_theta": [
      "self",
      "model",
      "theta",
      "train_data"
    ],
    "evaluate_theta": [
      "self",
      "thetas",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "generate_theta": [
      "self",
      "train_data"
    ]
  },
  "_align_outputs": [
    "all_model_outs",
    "target"
  ],
  "CombinerBase": {
    "__init__": [
      "self",
      "abs_score"
    ],
    "reset": [
      "self"
    ],
    "requires_training": [
      "self"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "from_dict": [
      "cls",
      "state"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ],
    "_combine_univariates": [
      "self",
      "univariates"
    ],
    "set_model_used": [
      "self",
      "i",
      "used"
    ],
    "get_model_used": [
      "self",
      "i"
    ],
    "models_used": [
      "self"
    ],
    "_models_used": [
      "self"
    ],
    "train": [
      "self",
      "all_model_outs",
      "target"
    ],
    "__call__": [
      "self",
      "all_model_outs",
      "target",
      "_check_dim"
    ]
  },
  "Median": {
    "_combine_univariates": [
      "self",
      "univariates"
    ]
  },
  "Max": {
    "_combine_univariates": [
      "self",
      "univariates"
    ]
  },
  "ModelSelector": {
    "__init__": [
      "self",
      "metric",
      "abs_score"
    ],
    "invert": [
      "self"
    ],
    "requires_training": [
      "self"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "from_dict": [
      "cls",
      "state"
    ],
    "_models_used": [
      "self"
    ],
    "train": [
      "self",
      "all_model_outs",
      "target"
    ]
  },
  "MetricWeightedMean": {
    "_models_used": [
      "self"
    ],
    "weights": [
      "self"
    ]
  },
  "CombinerFactory": {
    "create": [
      "cls",
      "name"
    ]
  },
  "EnsembleConfig": {
    "_default_combiner": [],
    "__init__": [
      "self",
      "models",
      "combiner"
    ],
    "to_dict": [
      "self",
      "_skipped_keys"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memodict"
    ]
  },
  "EnsembleTrainConfig": {
    "__init__": [
      "self",
      "valid_frac",
      "per_model_train_configs"
    ]
  },
  "EnsembleBase": {
    "config_class": [],
    "__init__": [
      "self",
      "config",
      "models"
    ],
    "models": [
      "self"
    ],
    "combiner": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "models_used": [
      "self"
    ],
    "_pandas_train": [
      "self"
    ],
    "train_valid_split": [
      "self",
      "transformed_train_data",
      "train_config"
    ],
    "get_max_common_horizon": [
      "self",
      "train_data"
    ],
    "train_combiner": [
      "self",
      "all_model_outs",
      "target"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "save": [
      "self",
      "dirname",
      "save_only_used_models"
    ],
    "_save_state": [
      "self",
      "state_dict",
      "filename",
      "save_only_used_models"
    ],
    "to_bytes": [
      "self",
      "save_only_used_models"
    ]
  },
  "DetectorEnsembleConfig": {
    "_default_combiner": [],
    "_default_threshold": [
      "self"
    ],
    "per_model_threshold": [
      "self"
    ],
    "__init__": [
      "self",
      "enable_calibrator"
    ]
  },
  "DetectorEnsembleTrainConfig": {
    "__init__": [
      "self",
      "valid_frac",
      "per_model_train_configs",
      "per_model_post_rule_train_configs"
    ]
  },
  "DetectorEnsemble": {
    "config_class": [],
    "__init__": [
      "self",
      "config",
      "models"
    ],
    "require_even_sampling": [
      "self"
    ],
    "require_univariate": [
      "self"
    ],
    "_default_post_rule_train_config": [
      "self"
    ],
    "_default_train_config": [
      "self"
    ],
    "per_model_threshold": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "train_config",
      "anomaly_labels"
    ],
    "_get_anomaly_score": [
      "self",
      "time_series",
      "time_series_prev"
    ]
  },
  "ForecasterEnsembleConfig": {
    "_default_combiner": [],
    "__init__": [
      "self",
      "max_forecast_steps",
      "target_seq_index",
      "verbose"
    ],
    "target_seq_index": [
      "self",
      "target_seq_index"
    ]
  },
  "ForecasterEnsemble": {
    "config_class": [],
    "_default_train_config": [
      "self"
    ],
    "require_even_sampling": [
      "self"
    ],
    "__init__": [
      "self",
      "config",
      "models"
    ],
    "train_pre_process": [
      "self",
      "train_data",
      "exog_data",
      "return_exog"
    ],
    "resample_time_stamps": [
      "self",
      "time_stamps",
      "time_series_prev"
    ],
    "train_combiner": [
      "self",
      "all_model_outs",
      "target"
    ],
    "_train_with_exog": [
      "self",
      "train_data",
      "train_config",
      "exog_data"
    ],
    "_forecast_with_exog": [
      "self",
      "time_stamps",
      "time_series_prev",
      "return_prev",
      "exog_data",
      "exog_data_prev"
    ]
  },
  "EvaluatorConfig": {
    "_timedelta_keys": [],
    "__init__": [
      "self",
      "train_window",
      "retrain_freq",
      "cadence"
    ],
    "train_window": [
      "self",
      "train_window"
    ],
    "retrain_freq": [
      "self",
      "retrain_freq"
    ],
    "cadence": [
      "self",
      "cadence"
    ],
    "horizon": [
      "self"
    ],
    "to_dict": [
      "self"
    ]
  },
  "EvaluatorBase": {
    "config_class": [],
    "__init__": [
      "self",
      "model",
      "config"
    ],
    "train_window": [
      "self"
    ],
    "retrain_freq": [
      "self"
    ],
    "cadence": [
      "self"
    ],
    "horizon": [
      "self"
    ],
    "_call_model": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "_train_model": [
      "self",
      "train_vals"
    ],
    "default_train_kwargs": [
      "self"
    ],
    "default_retrain_kwargs": [
      "self"
    ],
    "_concat_result": [
      "self"
    ],
    "get_predict": [
      "self",
      "train_vals",
      "test_vals",
      "exog_data",
      "train_kwargs",
      "retrain_kwargs"
    ],
    "evaluate": [
      "self",
      "ground_truth",
      "predict",
      "metric"
    ]
  },
  "scaled_sigmoid": [
    "x",
    "scale"
  ],
  "ScoreType": {
    "Pointwise": [],
    "PointAdjusted": [],
    "RevisedPointAdjusted": []
  },
  "TSADScoreAccumulator": {
    "__init__": [
      "self",
      "num_tp_anom",
      "num_tp_pointwise",
      "num_tp_point_adj",
      "num_fn_anom",
      "num_fn_pointwise",
      "num_fn_point_adj",
      "num_fp",
      "num_tn",
      "tp_score",
      "fp_score",
      "tp_detection_delays",
      "tp_anom_durations",
      "anom_durations"
    ],
    "__add__": [
      "self",
      "acc"
    ],
    "precision": [
      "self",
      "score_type"
    ],
    "recall": [
      "self",
      "score_type"
    ],
    "f1": [
      "self",
      "score_type"
    ],
    "f_beta": [
      "self",
      "score_type",
      "beta"
    ],
    "mean_time_to_detect": [
      "self"
    ],
    "mean_detected_anomaly_duration": [
      "self"
    ],
    "mean_anomaly_duration": [
      "self"
    ],
    "nab_score": [
      "self",
      "tp_weight",
      "fp_weight",
      "fn_weight",
      "tn_weight"
    ]
  },
  "accumulate_tsad_score": [
    "ground_truth",
    "predict",
    "max_early_sec",
    "max_delay_sec",
    "metric"
  ],
  "TSADMetric": {
    "MeanTimeToDetect": [],
    "F1": [],
    "Precision": [],
    "Recall": [],
    "PointwiseF1": [],
    "PointwisePrecision": [],
    "PointwiseRecall": [],
    "PointAdjustedF1": [],
    "PointAdjustedPrecision": [],
    "PointAdjustedRecall": [],
    "NABScore": [],
    "NABScoreLowFN": [],
    "NABScoreLowFP": [],
    "F2": [],
    "F5": []
  },
  "TSADEvaluatorConfig": {
    "__init__": [
      "self",
      "max_early_sec",
      "max_delay_sec"
    ]
  },
  "TSADEvaluator": {
    "config_class": [],
    "__init__": [
      "self",
      "model",
      "config"
    ],
    "max_early_sec": [
      "self"
    ],
    "max_delay_sec": [
      "self"
    ],
    "_call_model": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data"
    ],
    "default_retrain_kwargs": [
      "self"
    ],
    "get_predict": [
      "self",
      "train_vals",
      "test_vals",
      "exog_data",
      "train_kwargs",
      "retrain_kwargs",
      "post_process"
    ],
    "evaluate": [
      "self",
      "ground_truth",
      "predict",
      "metric"
    ]
  },
  "ForecastScoreAccumulator": {
    "__init__": [
      "self",
      "ground_truth",
      "predict",
      "insample",
      "periodicity",
      "ub",
      "lb",
      "target_seq_index"
    ],
    "check_before_eval": [
      "self"
    ],
    "mae": [
      "self"
    ],
    "marre": [
      "self"
    ],
    "rmse": [
      "self"
    ],
    "smape": [
      "self"
    ],
    "rmspe": [
      "self"
    ],
    "mase": [
      "self"
    ],
    "msis": [
      "self"
    ]
  },
  "accumulate_forecast_score": [
    "ground_truth",
    "predict",
    "insample",
    "periodicity",
    "ub",
    "lb",
    "metric",
    "target_seq_index"
  ],
  "ForecastMetric": {
    "MAE": [],
    "MARRE": [],
    "RMSE": [],
    "sMAPE": [],
    "RMSPE": [],
    "MASE": [],
    "MSIS": []
  },
  "ForecastEvaluatorConfig": {
    "_timedelta_keys": [],
    "__init__": [
      "self",
      "horizon"
    ],
    "horizon": [
      "self",
      "horizon"
    ],
    "cadence": [
      "self",
      "cadence"
    ]
  },
  "ForecastEvaluator": {
    "config_class": [],
    "__init__": [
      "self",
      "model",
      "config"
    ],
    "horizon": [
      "self"
    ],
    "cadence": [
      "self"
    ],
    "_call_model": [
      "self",
      "time_series",
      "time_series_prev",
      "exog_data",
      "return_err"
    ],
    "evaluate": [
      "self",
      "ground_truth",
      "predict",
      "metric"
    ]
  },
  "TSID_COL_NAME": [],
  "read_dataset": [
    "spark",
    "path",
    "file_format",
    "time_col",
    "index_cols",
    "data_cols"
  ],
  "write_dataset": [
    "df",
    "time_col",
    "path",
    "file_format"
  ],
  "create_hier_dataset": [
    "spark",
    "df",
    "time_col",
    "index_cols",
    "agg_dict"
  ],
  "add_tsid_column": [
    "spark",
    "df",
    "index_cols"
  ],
  "forecast": [
    "pdf",
    "index_cols",
    "time_col",
    "target_col",
    "time_stamps",
    "model",
    "predict_on_train",
    "agg_dict"
  ],
  "anomaly": [
    "pdf",
    "index_cols",
    "time_col",
    "train_test_split",
    "model",
    "predict_on_train"
  ],
  "reconciliation": [
    "pdf",
    "hier_matrix",
    "target_col"
  ]
}