{
  "__all__": [],
  "_insample_times": [
    "times",
    "uids",
    "indptr",
    "h",
    "freq",
    "step_size",
    "id_col",
    "time_col"
  ],
  "MODEL_FILENAME_DICT": [],
  "_type2scaler": [],
  "NeuralForecast": {
    "__init__": [
      "self",
      "models",
      "freq",
      "local_scaler_type",
      "local_static_scaler_type"
    ],
    "_scalers_fit_transform": [
      "self",
      "dataset"
    ],
    "_scalers_transform": [
      "self",
      "dataset"
    ],
    "_scalers_target_inverse_transform": [
      "self",
      "data",
      "indptr"
    ],
    "_prepare_fit": [
      "self",
      "df",
      "static_df",
      "predict_only",
      "id_col",
      "time_col",
      "target_col"
    ],
    "_check_nan": [
      "self",
      "df",
      "static_df",
      "id_col",
      "time_col",
      "target_col"
    ],
    "_prepare_fit_distributed": [
      "self",
      "df",
      "static_df",
      "id_col",
      "time_col",
      "target_col",
      "distributed_config"
    ],
    "_prepare_fit_for_local_files": [
      "self",
      "files_list",
      "static_df",
      "id_col",
      "time_col",
      "target_col"
    ],
    "fit": [
      "self",
      "df",
      "static_df",
      "val_size",
      "use_init_models",
      "verbose",
      "id_col",
      "time_col",
      "target_col",
      "distributed_config",
      "prediction_intervals"
    ],
    "make_future_dataframe": [
      "self",
      "df",
      "h"
    ],
    "get_missing_future": [
      "self",
      "futr_df",
      "df",
      "h"
    ],
    "_get_needed_futr_exog": [
      "self"
    ],
    "_get_needed_exog": [
      "self"
    ],
    "_get_model_names": [
      "self",
      "add_level"
    ],
    "_predict_distributed": [
      "self",
      "df",
      "static_df",
      "futr_df",
      "engine",
      "h"
    ],
    "predict": [
      "self",
      "df",
      "static_df",
      "futr_df",
      "verbose",
      "engine",
      "level",
      "quantiles",
      "h"
    ],
    "explain": [
      "self",
      "horizons",
      "outputs",
      "explainer",
      "df",
      "static_df",
      "futr_df",
      "h",
      "verbose",
      "engine",
      "level",
      "quantiles"
    ],
    "_reset_models": [
      "self"
    ],
    "_no_refit_cross_validation": [
      "self",
      "df",
      "static_df",
      "n_windows",
      "step_size",
      "val_size",
      "test_size",
      "verbose",
      "id_col",
      "time_col",
      "target_col",
      "h"
    ],
    "cross_validation": [
      "self",
      "df",
      "static_df",
      "n_windows",
      "step_size",
      "val_size",
      "test_size",
      "use_init_models",
      "verbose",
      "refit",
      "id_col",
      "time_col",
      "target_col",
      "prediction_intervals",
      "level",
      "quantiles",
      "h"
    ],
    "predict_insample": [
      "self",
      "step_size",
      "level",
      "quantiles"
    ],
    "save": [
      "self",
      "path",
      "model_index",
      "save_dataset",
      "overwrite"
    ],
    "load": [
      "path",
      "verbose"
    ],
    "_conformity_scores": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col",
      "static_df"
    ],
    "_generate_forecasts": [
      "self",
      "dataset",
      "uids",
      "h",
      "quantiles_",
      "level_",
      "has_level"
    ],
    "_get_column_name": [
      "model_name",
      "quantile",
      "has_level"
    ]
  },
  "generate_series": [
    "n_series",
    "freq",
    "min_length",
    "max_length",
    "n_temporal_features",
    "n_static_features",
    "equal_ends",
    "seed"
  ],
  "AirPassengers": [],
  "AirPassengersDF": [],
  "unique_id": [],
  "ds": [],
  "y": [],
  "AirPassengersPanel": [],
  "snaive": [],
  "airline1_dummy": [],
  "airline2_dummy": [],
  "AirPassengersStatic": [],
  "TimeFeature": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "index"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SecondOfMinute": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MinuteOfHour": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "HourOfDay": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfWeek": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfMonth": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MonthOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "WeekOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "time_features_from_frequency_str": [
    "freq_str"
  ],
  "augment_calendar_df": [
    "df",
    "freq"
  ],
  "get_indexer_raise_missing": [
    "idx",
    "vals"
  ],
  "PredictionIntervals": {
    "__init__": [
      "self",
      "n_windows",
      "method"
    ],
    "__repr__": [
      "self"
    ]
  },
  "add_conformal_distribution_intervals": [
    "model_fcsts",
    "cs_df",
    "model",
    "cs_n_windows",
    "n_series",
    "horizon",
    "level",
    "quantiles"
  ],
  "add_conformal_error_intervals": [
    "model_fcsts",
    "cs_df",
    "model",
    "cs_n_windows",
    "n_series",
    "horizon",
    "level",
    "quantiles"
  ],
  "get_prediction_interval_method": [
    "method"
  ],
  "level_to_quantiles": [
    "level"
  ],
  "quantiles_to_level": [
    "quantiles"
  ],
  "AutoRNN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoLSTM": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoGRU": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTCN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoDeepAR": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoDilatedRNN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoBiTCN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoxLSTM": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoMLP": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoNBEATS": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoNBEATSx": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoNHITS": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoDLinear": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoNLinear": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTiDE": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoDeepNPTS": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoKAN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTFT": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoVanillaTransformer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoInformer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoAutoformer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoFEDformer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoPatchTST": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoiTransformer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTimeXer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTimesNet": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoStemGNN": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoHINT": {
    "__init__": [
      "self",
      "cls_model",
      "h",
      "loss",
      "valid_loss",
      "S",
      "config",
      "search_alg",
      "num_samples",
      "cpus",
      "gpus",
      "refit_with_val",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "_fit_model": [
      "self",
      "cls_model",
      "config",
      "dataset",
      "val_size",
      "test_size",
      "distributed_config"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTSMixer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTSMixerx": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoMLPMultivariate": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoSOFTS": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoTimeMixer": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "AutoRMoK": {
    "default_config": [],
    "__init__": [
      "self",
      "h",
      "n_series",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "refit_with_val",
      "cpus",
      "gpus",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "get_default_config": [
      "cls",
      "h",
      "backend",
      "n_series"
    ]
  },
  "__version__": [],
  "TimeSeriesLoader": {
    "__init__": [
      "self",
      "dataset"
    ],
    "_collate_fn": [
      "self",
      "batch"
    ]
  },
  "BaseTimeSeriesDataset": {
    "__init__": [
      "self",
      "temporal_cols",
      "max_size",
      "min_size",
      "y_idx",
      "static",
      "static_cols"
    ],
    "__len__": [
      "self"
    ],
    "_as_torch_copy": [
      "self",
      "x",
      "dtype"
    ],
    "_ensure_available_mask": [
      "data",
      "temporal_cols"
    ],
    "_extract_static_features": [
      "static_df",
      "id_col"
    ]
  },
  "TimeSeriesDataset": {
    "__init__": [
      "self",
      "temporal",
      "temporal_cols",
      "indptr",
      "y_idx",
      "static",
      "static_cols"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__repr__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "align": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col"
    ],
    "append": [
      "self",
      "futr_dataset"
    ],
    "update_dataset": [
      "dataset",
      "futr_df",
      "id_col",
      "time_col",
      "target_col"
    ],
    "trim_dataset": [
      "dataset",
      "left_trim",
      "right_trim"
    ],
    "from_df": [
      "df",
      "static_df",
      "id_col",
      "time_col",
      "target_col"
    ]
  },
  "_FilesDataset": {
    "__init__": [
      "self",
      "files",
      "temporal_cols",
      "id_col",
      "time_col",
      "target_col",
      "min_size",
      "static_cols"
    ]
  },
  "LocalFilesTimeSeriesDataset": {
    "__init__": [
      "self",
      "files_ds",
      "temporal_cols",
      "id_col",
      "time_col",
      "target_col",
      "last_times",
      "indices",
      "max_size",
      "min_size",
      "y_idx",
      "static",
      "static_cols"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "from_data_directories": [
      "directories",
      "static_df",
      "exogs",
      "id_col",
      "time_col",
      "target_col"
    ]
  },
  "TimeSeriesDataModule": {
    "__init__": [
      "self",
      "dataset",
      "batch_size",
      "valid_batch_size",
      "drop_last",
      "shuffle_train"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "predict_dataloader": [
      "self"
    ]
  },
  "_DistributedTimeSeriesDataModule": {
    "__init__": [
      "self",
      "dataset",
      "batch_size",
      "valid_batch_size",
      "drop_last",
      "shuffle_train"
    ],
    "setup": [
      "self",
      "stage"
    ]
  },
  "seed": [],
  "test_size": [],
  "FREQ": [],
  "N_SERIES_1": [],
  "df": [],
  "max_ds": [],
  "Y_TRAIN_DF_1": [],
  "Y_TEST_DF_1": [],
  "N_SERIES_2": [],
  "Y_TRAIN_DF_2": [],
  "Y_TEST_DF_2": [],
  "N_SERIES_3": [],
  "Y_TRAIN_DF_3": [],
  "Y_TEST_DF_3": [],
  "N_SERIES_4": [],
  "Y_TRAIN_DF_4": [],
  "Y_TEST_DF_4": [],
  "_run_model_tests": [
    "model_class",
    "config"
  ],
  "check_loss_functions": [
    "model_class"
  ],
  "check_airpassengers": [
    "model_class"
  ],
  "check_model": [
    "model_class",
    "checks"
  ],
  "ACTIVATIONS": [],
  "MLP": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "activation",
      "hidden_size",
      "num_layers",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "Chomp1d": {
    "__init__": [
      "self",
      "horizon"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CausalConv1d": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "padding",
      "dilation",
      "activation",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalConvolutionEncoder": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "dilations",
      "activation"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TransEncoderLayer": {
    "__init__": [
      "self",
      "attention",
      "hidden_size",
      "conv_hidden_size",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "TransEncoder": {
    "__init__": [
      "self",
      "attn_layers",
      "conv_layers",
      "norm_layer"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "TransDecoderLayer": {
    "__init__": [
      "self",
      "self_attention",
      "cross_attention",
      "hidden_size",
      "conv_hidden_size",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask"
    ]
  },
  "TransDecoder": {
    "__init__": [
      "self",
      "layers",
      "norm_layer",
      "projection"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask"
    ]
  },
  "AttentionLayer": {
    "__init__": [
      "self",
      "attention",
      "hidden_size",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask",
      "tau",
      "delta"
    ]
  },
  "TriangularCausalMask": {
    "__init__": [
      "self",
      "B",
      "L",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "FullAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask",
      "tau",
      "delta"
    ]
  },
  "PositionalEmbedding": {
    "__init__": [
      "self",
      "hidden_size",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TokenEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "hidden_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeFeatureEmbedding": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FixedEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DataEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "exog_input_size",
      "hidden_size",
      "pos_embedding",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "DataEmbedding_inverted": {
    "__init__": [
      "self",
      "c_in",
      "hidden_size",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "MovingAvg": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SeriesDecomp": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RevIN": {
    "__init__": [
      "self",
      "num_features",
      "eps",
      "affine",
      "subtract_last",
      "non_norm"
    ],
    "forward": [
      "self",
      "x",
      "mode"
    ],
    "_init_params": [
      "self"
    ],
    "_get_statistics": [
      "self",
      "x"
    ],
    "_normalize": [
      "self",
      "x"
    ],
    "_denormalize": [
      "self",
      "x"
    ]
  },
  "RevINMultivariate": {
    "__init__": [
      "self",
      "num_features",
      "eps",
      "affine",
      "subtract_last",
      "non_norm"
    ],
    "forward": [
      "self",
      "x",
      "mode"
    ],
    "_init_params": [
      "self"
    ],
    "_normalize": [
      "self",
      "x"
    ],
    "_denormalize": [
      "self",
      "x"
    ]
  },
  "DISTRIBUTION_LOSSES": [],
  "MULTIQUANTILE_LOSSES": [],
  "DistributedConfig": {},
  "_disable_torch_init": [],
  "tensor_to_numpy": [
    "tensor"
  ],
  "BaseModel": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "loss",
      "valid_loss",
      "learning_rate",
      "max_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "n_series",
      "n_samples",
      "h_train",
      "inference_input_size",
      "step_size",
      "num_lr_decays",
      "early_stop_patience_steps",
      "scaler_type",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "drop_last_loader",
      "random_seed",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "__repr__": [
      "self"
    ],
    "_check_exog": [
      "self",
      "dataset"
    ],
    "_restart_seed": [
      "self",
      "random_seed"
    ],
    "_get_temporal_exogenous_cols": [
      "self",
      "temporal_cols"
    ],
    "_set_quantiles": [
      "self",
      "quantiles"
    ],
    "_fit_distributed": [
      "self",
      "distributed_config",
      "datamodule",
      "val_size",
      "test_size"
    ],
    "_fit": [
      "self",
      "dataset",
      "batch_size",
      "valid_batch_size",
      "val_size",
      "test_size",
      "random_seed",
      "shuffle_train",
      "distributed_config"
    ],
    "on_fit_start": [
      "self"
    ],
    "configure_optimizers": [
      "self"
    ],
    "get_test_size": [
      "self"
    ],
    "set_test_size": [
      "self",
      "test_size"
    ],
    "on_validation_epoch_end": [
      "self"
    ],
    "save": [
      "self",
      "path"
    ],
    "load": [
      "cls",
      "path"
    ],
    "_create_windows": [
      "self",
      "batch",
      "step"
    ],
    "_normalization": [
      "self",
      "windows",
      "y_idx"
    ],
    "_inv_normalization": [
      "self",
      "y_hat",
      "y_idx"
    ],
    "_sample_windows": [
      "self",
      "windows_temporal",
      "static",
      "static_cols",
      "temporal_cols",
      "w_idxs",
      "final_condition"
    ],
    "_parse_windows": [
      "self",
      "batch",
      "windows"
    ],
    "_get_loc_scale": [
      "self",
      "y_idx",
      "add_channel_dim"
    ],
    "_compute_valid_loss": [
      "self",
      "insample_y",
      "outsample_y",
      "output",
      "outsample_mask",
      "y_idx"
    ],
    "_validate_step_recurrent_batch": [
      "self",
      "insample_y",
      "insample_mask",
      "futr_exog",
      "hist_exog",
      "stat_exog",
      "y_idx"
    ],
    "_validate_step_recurrent_single": [
      "self",
      "insample_y",
      "insample_mask",
      "hist_exog",
      "futr_exog",
      "stat_exog",
      "y_idx"
    ],
    "_predict_step_recurrent_batch": [
      "self",
      "insample_y",
      "insample_mask",
      "futr_exog",
      "hist_exog",
      "stat_exog",
      "y_idx"
    ],
    "_predict_step_recurrent_single": [
      "self",
      "insample_y",
      "insample_mask",
      "hist_exog",
      "futr_exog",
      "stat_exog",
      "y_idx"
    ],
    "_predict_step_direct_batch": [
      "self",
      "insample_y",
      "insample_mask",
      "hist_exog",
      "futr_exog",
      "stat_exog",
      "y_idx"
    ],
    "_predict_step_recurrent": [
      "self",
      "batch",
      "batch_idx"
    ],
    "_compute_explanations_for_step": [
      "self",
      "batch",
      "temporal_cols",
      "y_idx",
      "recursive_step",
      "y_hat_shape"
    ],
    "_predict_step_direct": [
      "self",
      "batch",
      "batch_idx",
      "recursive"
    ],
    "_maybe_get_quantile_idx": [
      "self",
      "quantile"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "fit": [
      "self",
      "dataset",
      "val_size",
      "test_size",
      "random_seed",
      "distributed_config"
    ],
    "predict": [
      "self",
      "dataset",
      "test_size",
      "step_size",
      "random_seed",
      "quantiles",
      "h",
      "explainer_config"
    ],
    "decompose": [
      "self",
      "dataset",
      "step_size",
      "random_seed",
      "quantiles"
    ],
    "_predict_step_wrapper": [
      "self",
      "insample_y",
      "insample_mask",
      "futr_exog",
      "hist_exog",
      "stat_exog",
      "y_idx",
      "output_horizon",
      "output_series",
      "output_index"
    ],
    "_explain_batch": [
      "self",
      "insample_y",
      "insample_mask",
      "futr_exog",
      "hist_exog",
      "stat_exog",
      "y_idx",
      "y_hat_shape",
      "recursive_step"
    ]
  },
  "masked_median": [
    "x",
    "mask",
    "dim",
    "keepdim"
  ],
  "masked_mean": [
    "x",
    "mask",
    "dim",
    "keepdim"
  ],
  "minmax_statistics": [
    "x",
    "mask",
    "eps",
    "dim"
  ],
  "minmax_scaler": [
    "x",
    "x_min",
    "x_range"
  ],
  "inv_minmax_scaler": [
    "z",
    "x_min",
    "x_range"
  ],
  "minmax1_statistics": [
    "x",
    "mask",
    "eps",
    "dim"
  ],
  "minmax1_scaler": [
    "x",
    "x_min",
    "x_range"
  ],
  "inv_minmax1_scaler": [
    "z",
    "x_min",
    "x_range"
  ],
  "std_statistics": [
    "x",
    "mask",
    "dim",
    "eps"
  ],
  "std_scaler": [
    "x",
    "x_means",
    "x_stds"
  ],
  "inv_std_scaler": [
    "z",
    "x_mean",
    "x_std"
  ],
  "robust_statistics": [
    "x",
    "mask",
    "dim",
    "eps"
  ],
  "robust_scaler": [
    "x",
    "x_median",
    "x_mad"
  ],
  "inv_robust_scaler": [
    "z",
    "x_median",
    "x_mad"
  ],
  "invariant_statistics": [
    "x",
    "mask",
    "dim",
    "eps"
  ],
  "invariant_scaler": [
    "x",
    "x_median",
    "x_mad"
  ],
  "inv_invariant_scaler": [
    "z",
    "x_median",
    "x_mad"
  ],
  "identity_statistics": [
    "x",
    "mask",
    "dim",
    "eps"
  ],
  "identity_scaler": [
    "x",
    "x_shift",
    "x_scale"
  ],
  "inv_identity_scaler": [
    "z",
    "x_shift",
    "x_scale"
  ],
  "TemporalNorm": {
    "__init__": [
      "self",
      "scaler_type",
      "dim",
      "eps",
      "num_features"
    ],
    "_init_params": [
      "self",
      "num_features"
    ],
    "transform": [
      "self",
      "x",
      "mask"
    ],
    "inverse_transform": [
      "self",
      "z",
      "x_shift",
      "x_scale"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeSeriesDatasetEnum": {
    "Datetime": [],
    "UniqueId": [],
    "Target": []
  },
  "ExplainerEnum": {
    "IntegratedGradients": [],
    "ShapleyValueSampling": [],
    "InputXGradient": [],
    "AdditiveExplainers": [],
    "AllExplainers": []
  },
  "MockTrial": {
    "suggest_int": [],
    "suggest_categorical": [
      "self",
      "name",
      "choices"
    ],
    "suggest_uniform": [],
    "suggest_loguniform": [],
    "suggest_float": []
  },
  "BaseAuto": {
    "__init__": [
      "self",
      "cls_model",
      "h",
      "loss",
      "valid_loss",
      "config",
      "search_alg",
      "num_samples",
      "cpus",
      "gpus",
      "refit_with_val",
      "verbose",
      "alias",
      "backend",
      "callbacks"
    ],
    "__repr__": [
      "self"
    ],
    "_train_tune": [
      "self",
      "config_step",
      "cls_model",
      "dataset",
      "val_size",
      "test_size"
    ],
    "_tune_model": [
      "self",
      "cls_model",
      "dataset",
      "val_size",
      "test_size",
      "cpus",
      "gpus",
      "verbose",
      "num_samples",
      "search_alg",
      "config"
    ],
    "_ray_config_to_optuna": [
      "ray_config"
    ],
    "_optuna_tune_model": [
      "self",
      "cls_model",
      "dataset",
      "val_size",
      "test_size",
      "verbose",
      "num_samples",
      "search_alg",
      "config",
      "distributed_config"
    ],
    "_fit_model": [
      "self",
      "cls_model",
      "config",
      "dataset",
      "val_size",
      "test_size",
      "distributed_config"
    ],
    "fit": [
      "self",
      "dataset",
      "val_size",
      "test_size",
      "random_seed",
      "distributed_config"
    ],
    "predict": [
      "self",
      "dataset",
      "step_size",
      "h"
    ],
    "set_test_size": [
      "self",
      "test_size"
    ],
    "get_test_size": [
      "self"
    ],
    "save": [
      "self",
      "path"
    ]
  },
  "_divide_no_nan": [
    "a",
    "b"
  ],
  "_metric_protections": [
    "y",
    "y_hat",
    "weights"
  ],
  "mae": [
    "y",
    "y_hat",
    "weights",
    "axis"
  ],
  "mse": [
    "y",
    "y_hat",
    "weights",
    "axis"
  ],
  "rmse": [
    "y",
    "y_hat",
    "weights",
    "axis"
  ],
  "mape": [
    "y",
    "y_hat",
    "weights",
    "axis"
  ],
  "smape": [
    "y",
    "y_hat",
    "weights",
    "axis"
  ],
  "mase": [
    "y",
    "y_hat",
    "y_train",
    "seasonality",
    "weights",
    "axis"
  ],
  "rmae": [
    "y",
    "y_hat1",
    "y_hat2",
    "weights",
    "axis"
  ],
  "quantile_loss": [
    "y",
    "y_hat",
    "q",
    "weights",
    "axis"
  ],
  "mqloss": [
    "y",
    "y_hat",
    "quantiles",
    "weights",
    "axis"
  ],
  "_weighted_mean": [
    "losses",
    "weights"
  ],
  "BasePointLoss": {
    "__init__": [
      "self",
      "horizon_weight",
      "outputsize_multiplier",
      "output_names"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ],
    "_compute_weights": [
      "self",
      "y",
      "mask"
    ]
  },
  "MAE": {
    "__init__": [
      "self",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "mask",
      "y_insample"
    ]
  },
  "MSE": {
    "__init__": [
      "self",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "RMSE": {
    "__init__": [
      "self",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "mask",
      "y_insample"
    ]
  },
  "MAPE": {
    "__init__": [
      "self",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "SMAPE": {
    "__init__": [
      "self",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "mask",
      "y_insample"
    ]
  },
  "MASE": {
    "__init__": [
      "self",
      "seasonality",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "relMSE": {
    "__init__": [
      "self",
      "y_train",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_benchmark",
      "mask"
    ]
  },
  "QuantileLoss": {
    "__init__": [
      "self",
      "q",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "level_to_outputs": [
    "level"
  ],
  "quantiles_to_outputs": [
    "quantiles"
  ],
  "MQLoss": {
    "__init__": [
      "self",
      "level",
      "quantiles",
      "horizon_weight"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ],
    "_compute_weights": [
      "self",
      "y",
      "mask"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "QuantileLayer": {
    "__init__": [
      "self",
      "num_output",
      "cos_embedding_dim"
    ],
    "forward": [
      "self",
      "tau"
    ]
  },
  "IQLoss": {
    "__init__": [
      "self",
      "cos_embedding_dim",
      "concentration0",
      "concentration1",
      "horizon_weight"
    ],
    "_sample_quantiles": [
      "self",
      "sample_size",
      "device"
    ],
    "_init_sampling_distribution": [
      "self",
      "device"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ]
  },
  "weighted_average": [
    "x",
    "weights",
    "dim"
  ],
  "bernoulli_scale_decouple": [
    "output",
    "loc",
    "scale"
  ],
  "student_scale_decouple": [
    "output",
    "loc",
    "scale",
    "eps"
  ],
  "normal_scale_decouple": [
    "output",
    "loc",
    "scale",
    "eps"
  ],
  "poisson_scale_decouple": [
    "output",
    "loc",
    "scale"
  ],
  "nbinomial_scale_decouple": [
    "output",
    "loc",
    "scale"
  ],
  "est_lambda": [
    "mu",
    "rho"
  ],
  "est_alpha": [
    "rho"
  ],
  "est_beta": [
    "mu",
    "rho"
  ],
  "Tweedie": {
    "arg_constraints": [],
    "support": [],
    "__init__": [
      "self",
      "log_mu",
      "rho",
      "validate_args"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "log_prob": [
      "self",
      "y_true"
    ]
  },
  "tweedie_domain_map": [
    "input",
    "rho"
  ],
  "tweedie_scale_decouple": [
    "output",
    "loc",
    "scale"
  ],
  "ISQF": {
    "__init__": [
      "self",
      "spline_knots",
      "spline_heights",
      "beta_l",
      "beta_r",
      "qk_y",
      "qk_x",
      "loc",
      "scale",
      "validate_args"
    ],
    "crps": [
      "self",
      "y"
    ],
    "mean": [
      "self"
    ]
  },
  "BaseISQF": {
    "__init__": [
      "self",
      "spline_knots",
      "spline_heights",
      "beta_l",
      "beta_r",
      "qk_y",
      "qk_x",
      "tol",
      "validate_args"
    ],
    "parameterize_qk": [
      "quantile_knots"
    ],
    "parameterize_spline": [
      "spline_knots",
      "qk",
      "qk_plus",
      "tol"
    ],
    "parameterize_tail": [
      "beta",
      "qk_x",
      "qk_y"
    ],
    "quantile": [
      "self",
      "alpha"
    ],
    "quantile_internal": [
      "self",
      "alpha",
      "dim"
    ],
    "quantile_spline": [
      "self",
      "alpha",
      "dim"
    ],
    "quantile_tail": [
      "self",
      "alpha",
      "dim",
      "left_tail"
    ],
    "cdf_spline": [
      "self",
      "z"
    ],
    "cdf_tail": [
      "self",
      "z",
      "left_tail"
    ],
    "crps_tail": [
      "self",
      "z",
      "left_tail"
    ],
    "crps_spline": [
      "self",
      "z"
    ],
    "loss": [
      "self",
      "z"
    ],
    "log_prob": [
      "self",
      "z"
    ],
    "crps": [
      "self",
      "z"
    ],
    "cdf": [
      "self",
      "z"
    ],
    "rsample": [
      "self",
      "sample_shape"
    ],
    "batch_shape": [
      "self"
    ]
  },
  "isqf_domain_map": [
    "input",
    "tol",
    "quantiles",
    "num_pieces"
  ],
  "isqf_scale_decouple": [
    "output",
    "loc",
    "scale"
  ],
  "DistributionLoss": {
    "__init__": [
      "self",
      "distribution",
      "level",
      "quantiles",
      "num_samples",
      "return_params",
      "horizon_weight"
    ],
    "_domain_map": [
      "self",
      "input"
    ],
    "get_distribution": [
      "self",
      "distr_args"
    ],
    "sample": [
      "self",
      "distr_args",
      "num_samples"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "_compute_weights": [
      "self",
      "y",
      "mask"
    ],
    "__call__": [
      "self",
      "y",
      "distr_args",
      "mask"
    ]
  },
  "PMM": {
    "__init__": [
      "self",
      "n_components",
      "level",
      "quantiles",
      "num_samples",
      "return_params",
      "batch_correlation",
      "horizon_correlation",
      "weighted"
    ],
    "domain_map": [
      "self",
      "output"
    ],
    "scale_decouple": [
      "self",
      "output",
      "loc",
      "scale"
    ],
    "get_distribution": [
      "self",
      "distr_args"
    ],
    "sample": [
      "self",
      "distr_args",
      "num_samples"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "__call__": [
      "self",
      "y",
      "distr_args",
      "mask"
    ]
  },
  "GMM": {
    "__init__": [
      "self",
      "n_components",
      "level",
      "quantiles",
      "num_samples",
      "return_params",
      "batch_correlation",
      "horizon_correlation",
      "weighted"
    ],
    "domain_map": [
      "self",
      "output"
    ],
    "scale_decouple": [
      "self",
      "output",
      "loc",
      "scale",
      "eps"
    ],
    "get_distribution": [
      "self",
      "distr_args"
    ],
    "sample": [
      "self",
      "distr_args",
      "num_samples"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "__call__": [
      "self",
      "y",
      "distr_args",
      "mask"
    ]
  },
  "NBMM": {
    "__init__": [
      "self",
      "n_components",
      "level",
      "quantiles",
      "num_samples",
      "return_params",
      "weighted"
    ],
    "domain_map": [
      "self",
      "output"
    ],
    "scale_decouple": [
      "self",
      "output",
      "loc",
      "scale",
      "eps"
    ],
    "get_distribution": [
      "self",
      "distr_args"
    ],
    "sample": [
      "self",
      "distr_args",
      "num_samples"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "__call__": [
      "self",
      "y",
      "distr_args",
      "mask"
    ]
  },
  "HuberLoss": {
    "__init__": [
      "self",
      "delta",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "TukeyLoss": {
    "__init__": [
      "self",
      "c",
      "normalize"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ],
    "masked_mean": [
      "self",
      "x",
      "mask",
      "dim"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "HuberQLoss": {
    "__init__": [
      "self",
      "q",
      "delta",
      "horizon_weight"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "HuberMQLoss": {
    "__init__": [
      "self",
      "level",
      "quantiles",
      "delta",
      "horizon_weight"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ],
    "_compute_weights": [
      "self",
      "y",
      "mask"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "HuberIQLoss": {
    "__init__": [
      "self",
      "cos_embedding_dim",
      "concentration0",
      "concentration1",
      "delta",
      "horizon_weight"
    ],
    "_sample_quantiles": [
      "self",
      "sample_size",
      "device"
    ],
    "_init_sampling_distribution": [
      "self",
      "device"
    ],
    "update_quantile": [
      "self",
      "q"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ]
  },
  "Accuracy": {
    "__init__": [
      "self"
    ],
    "domain_map": [
      "self",
      "y_hat"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "sCRPS": {
    "__init__": [
      "self",
      "level",
      "quantiles"
    ],
    "__call__": [
      "self",
      "y",
      "y_hat",
      "y_insample",
      "mask"
    ]
  },
  "DataEmbedding_wo_pos": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "dropout",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "DFT_series_decomp": {
    "__init__": [
      "self",
      "top_k"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MultiScaleSeasonMixing": {
    "__init__": [
      "self",
      "seq_len",
      "down_sampling_window",
      "down_sampling_layers"
    ],
    "forward": [
      "self",
      "season_list"
    ]
  },
  "MultiScaleTrendMixing": {
    "__init__": [
      "self",
      "seq_len",
      "down_sampling_window",
      "down_sampling_layers"
    ],
    "forward": [
      "self",
      "trend_list"
    ]
  },
  "PastDecomposableMixing": {
    "__init__": [
      "self",
      "seq_len",
      "pred_len",
      "down_sampling_window",
      "down_sampling_layers",
      "d_model",
      "dropout",
      "channel_independence",
      "decomp_method",
      "d_ff",
      "moving_avg",
      "top_k"
    ],
    "forward": [
      "self",
      "x_list"
    ]
  },
  "TimeMixer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "d_model",
      "d_ff",
      "dropout",
      "e_layers",
      "top_k",
      "decomp_method",
      "moving_avg",
      "channel_independence",
      "down_sampling_layers",
      "down_sampling_window",
      "down_sampling_method",
      "use_norm",
      "decoder_input_size_multiplier",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "out_projection": [
      "self",
      "dec_out",
      "i",
      "out_res"
    ],
    "pre_enc": [
      "self",
      "x_list"
    ],
    "__multi_scale_process_inputs": [
      "self",
      "x_enc",
      "x_mark_enc"
    ],
    "forecast": [
      "self",
      "x_enc",
      "x_mark_enc",
      "x_mark_dec"
    ],
    "future_multi_mixing": [
      "self",
      "B",
      "enc_out_list",
      "x_list"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "Inception_Block_V1": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "num_kernels",
      "init_weight"
    ],
    "_initialize_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FFT_for_Period": [
    "x",
    "k"
  ],
  "TimesBlock": {
    "__init__": [
      "self",
      "input_size",
      "h",
      "k",
      "hidden_size",
      "conv_hidden_size",
      "num_kernels"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimesNet": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "hidden_size",
      "dropout",
      "conv_hidden_size",
      "top_k",
      "num_kernels",
      "encoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "_IdentityBasis": {
    "__init__": [
      "self",
      "backcast_size",
      "forecast_size",
      "interpolation_mode",
      "out_features"
    ],
    "forward": [
      "self",
      "theta"
    ]
  },
  "POOLING": [],
  "NHITSBlock": {
    "__init__": [
      "self",
      "input_size",
      "h",
      "n_theta",
      "mlp_units",
      "basis",
      "futr_input_size",
      "hist_input_size",
      "stat_input_size",
      "n_pool_kernel_size",
      "pooling_mode",
      "dropout_prob",
      "activation"
    ],
    "forward": [
      "self",
      "insample_y",
      "futr_exog",
      "hist_exog",
      "stat_exog"
    ]
  },
  "NHITS": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "stack_types",
      "n_blocks",
      "mlp_units",
      "n_pool_kernel_size",
      "n_freq_downsample",
      "pooling_mode",
      "interpolation_mode",
      "dropout_prob_theta",
      "activation",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "create_stack": [
      "self",
      "h",
      "input_size",
      "stack_types",
      "n_blocks",
      "mlp_units",
      "n_pool_kernel_size",
      "n_freq_downsample",
      "pooling_mode",
      "interpolation_mode",
      "dropout_prob_theta",
      "activation",
      "futr_input_size",
      "hist_input_size",
      "stat_input_size"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "STAD": {
    "__init__": [
      "self",
      "d_series",
      "d_core"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "SOFTS": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "hidden_size",
      "d_core",
      "e_layers",
      "d_ff",
      "dropout",
      "use_norm",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forecast": [
      "self",
      "x_enc"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "TemporalMixing": {
    "__init__": [
      "self",
      "n_series",
      "input_size",
      "dropout"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "FeatureMixing": {
    "__init__": [
      "self",
      "n_series",
      "input_size",
      "dropout",
      "ff_dim"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "MixingLayer": {
    "__init__": [
      "self",
      "n_series",
      "input_size",
      "dropout",
      "ff_dim"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "TSMixer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "n_block",
      "ff_dim",
      "dropout",
      "revin",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "Decoder": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "hidden_size",
      "hidden_layers"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DeepAR": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "h_train",
      "lstm_n_layers",
      "lstm_hidden_size",
      "lstm_dropout",
      "decoder_hidden_layers",
      "decoder_hidden_size",
      "trajectory_samples",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "get_activation_fn": [
    "activation_str"
  ],
  "MaybeLayerNorm": {
    "__init__": [
      "self",
      "output_size",
      "hidden_size",
      "eps"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "GLU": {
    "__init__": [
      "self",
      "hidden_size",
      "output_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "GRN": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "output_size",
      "context_hidden_size",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "a",
      "c"
    ]
  },
  "TFTEmbedding": {
    "__init__": [
      "self",
      "hidden_size",
      "stat_input_size",
      "futr_input_size",
      "hist_input_size",
      "tgt_size"
    ],
    "_apply_embedding": [
      "self",
      "cont",
      "cont_emb",
      "cont_bias"
    ],
    "forward": [
      "self",
      "target_inp",
      "stat_exog",
      "futr_exog",
      "hist_exog"
    ]
  },
  "VariableSelectionNetwork": {
    "__init__": [
      "self",
      "hidden_size",
      "num_inputs",
      "dropout",
      "grn_activation"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ]
  },
  "InterpretableMultiHeadAttention": {
    "__init__": [
      "self",
      "n_head",
      "hidden_size",
      "example_length",
      "attn_dropout",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "mask_future_timesteps"
    ]
  },
  "StaticCovariateEncoder": {
    "__init__": [
      "self",
      "hidden_size",
      "num_static_vars",
      "dropout",
      "grn_activation",
      "rnn_type",
      "n_rnn_layers",
      "one_rnn_initial_state"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalCovariateEncoder": {
    "__init__": [
      "self",
      "hidden_size",
      "num_historic_vars",
      "num_future_vars",
      "dropout",
      "grn_activation",
      "rnn_type",
      "n_rnn_layers"
    ],
    "forward": [
      "self",
      "historical_inputs",
      "future_inputs",
      "cs",
      "ch",
      "cc"
    ]
  },
  "TemporalFusionDecoder": {
    "__init__": [
      "self",
      "n_head",
      "hidden_size",
      "example_length",
      "encoder_length",
      "attn_dropout",
      "dropout",
      "grn_activation"
    ],
    "forward": [
      "self",
      "temporal_features",
      "ce"
    ]
  },
  "TFT": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "tgt_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "hidden_size",
      "n_head",
      "attn_dropout",
      "grn_activation",
      "n_rnn_layers",
      "rnn_type",
      "one_rnn_initial_state",
      "dropout",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ],
    "mean_on_batch": [
      "self",
      "tensor"
    ],
    "feature_importances": [
      "self"
    ],
    "attention_weights": [
      "self"
    ],
    "feature_importance_correlations": [
      "self"
    ]
  },
  "get_bottomup_P": [
    "S"
  ],
  "get_mintrace_ols_P": [
    "S"
  ],
  "get_mintrace_wls_P": [
    "S"
  ],
  "get_identity_P": [
    "S"
  ],
  "HINT": {
    "__init__": [
      "self",
      "h",
      "S",
      "model",
      "reconciliation",
      "alias"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "dataset",
      "val_size",
      "test_size",
      "random_seed",
      "distributed_config"
    ],
    "predict": [
      "self",
      "dataset",
      "step_size",
      "random_seed"
    ],
    "set_test_size": [
      "self",
      "test_size"
    ],
    "get_test_size": [
      "self"
    ],
    "save": [
      "self",
      "path"
    ]
  },
  "LSTMCell": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "dropout"
    ],
    "forward": [
      "self",
      "inputs",
      "hidden"
    ]
  },
  "ResLSTMCell": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "dropout"
    ],
    "forward": [
      "self",
      "inputs",
      "hidden"
    ]
  },
  "ResLSTMLayer": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "dropout"
    ],
    "forward": [
      "self",
      "inputs",
      "hidden"
    ]
  },
  "AttentiveLSTMLayer": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "dropout"
    ],
    "forward": [
      "self",
      "inputs",
      "hidden"
    ]
  },
  "DRNN": {
    "__init__": [
      "self",
      "n_input",
      "n_hidden",
      "n_layers",
      "dilations",
      "dropout",
      "cell_type",
      "batch_first"
    ],
    "forward": [
      "self",
      "inputs",
      "hidden"
    ],
    "drnn_layer": [
      "self",
      "cell",
      "inputs",
      "rate",
      "hidden"
    ],
    "_apply_cell": [
      "self",
      "dilated_inputs",
      "cell",
      "batch_size",
      "rate",
      "hidden_size",
      "hidden"
    ],
    "_unpad_outputs": [
      "self",
      "splitted_outputs",
      "n_steps"
    ],
    "_split_outputs": [
      "self",
      "dilated_outputs",
      "rate"
    ],
    "_pad_inputs": [
      "self",
      "inputs",
      "n_steps",
      "rate"
    ],
    "_prepare_inputs": [
      "self",
      "inputs",
      "rate"
    ]
  },
  "DilatedRNN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "cell_type",
      "dilations",
      "encoder_hidden_size",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "generate_legendre_basis": [
    "length",
    "n_basis"
  ],
  "generate_polynomial_basis": [
    "length",
    "n_basis"
  ],
  "generate_changepoint_basis": [
    "length",
    "n_basis"
  ],
  "generate_piecewise_linear_basis": [
    "length",
    "n_basis"
  ],
  "generate_linear_hat_basis": [
    "length",
    "n_basis"
  ],
  "generate_spline_basis": [
    "length",
    "n_basis"
  ],
  "generate_chebyshev_basis": [
    "length",
    "n_basis"
  ],
  "get_basis": [
    "length",
    "n_basis",
    "basis"
  ],
  "IdentityBasis": {
    "__init__": [
      "self",
      "backcast_size",
      "forecast_size",
      "out_features"
    ],
    "forward": [
      "self",
      "theta"
    ]
  },
  "TrendBasis": {
    "__init__": [
      "self",
      "n_basis",
      "backcast_size",
      "forecast_size",
      "out_features",
      "basis"
    ],
    "forward": [
      "self",
      "theta"
    ]
  },
  "SeasonalityBasis": {
    "__init__": [
      "self",
      "harmonics",
      "backcast_size",
      "forecast_size",
      "out_features"
    ],
    "forward": [
      "self",
      "theta"
    ]
  },
  "NBEATSBlock": {
    "__init__": [
      "self",
      "input_size",
      "n_theta",
      "mlp_units",
      "basis",
      "dropout_prob",
      "activation"
    ],
    "forward": [
      "self",
      "insample_y"
    ]
  },
  "NBEATS": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_harmonics",
      "n_polynomials",
      "n_basis",
      "basis",
      "stack_types",
      "n_blocks",
      "mlp_units",
      "dropout_prob_theta",
      "activation",
      "shared_weights",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "create_stack": [
      "self",
      "stack_types",
      "n_blocks",
      "input_size",
      "h",
      "mlp_units",
      "dropout_prob_theta",
      "activation",
      "shared_weights",
      "n_harmonics",
      "n_basis",
      "basis_type"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "Transpose": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "PositionalEncoding": [
    "q_len",
    "hidden_size",
    "normalize"
  ],
  "SinCosPosEncoding": [],
  "Coord2dPosEncoding": [
    "q_len",
    "hidden_size",
    "exponential",
    "normalize",
    "eps"
  ],
  "Coord1dPosEncoding": [
    "q_len",
    "exponential",
    "normalize"
  ],
  "positional_encoding": [
    "pe",
    "learn_pe",
    "q_len",
    "hidden_size"
  ],
  "PatchTST_backbone": {
    "__init__": [
      "self",
      "c_in",
      "c_out",
      "input_size",
      "h",
      "patch_len",
      "stride",
      "max_seq_len",
      "n_layers",
      "hidden_size",
      "n_heads",
      "d_k",
      "d_v",
      "linear_hidden_size",
      "norm",
      "attn_dropout",
      "dropout",
      "act",
      "key_padding_mask",
      "padding_var",
      "attn_mask",
      "res_attention",
      "pre_norm",
      "store_attn",
      "pe",
      "learn_pe",
      "fc_dropout",
      "head_dropout",
      "padding_patch",
      "pretrain_head",
      "head_type",
      "individual",
      "revin",
      "affine",
      "subtract_last"
    ],
    "forward": [
      "self",
      "z"
    ],
    "create_pretrain_head": [
      "self",
      "head_nf",
      "vars",
      "dropout"
    ]
  },
  "Flatten_Head": {
    "__init__": [
      "self",
      "individual",
      "n_vars",
      "nf",
      "h",
      "c_out",
      "head_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TSTiEncoder": {
    "__init__": [
      "self",
      "c_in",
      "patch_num",
      "patch_len",
      "max_seq_len",
      "n_layers",
      "hidden_size",
      "n_heads",
      "d_k",
      "d_v",
      "linear_hidden_size",
      "norm",
      "attn_dropout",
      "dropout",
      "act",
      "store_attn",
      "key_padding_mask",
      "padding_var",
      "attn_mask",
      "res_attention",
      "pre_norm",
      "pe",
      "learn_pe"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TSTEncoder": {
    "__init__": [
      "self",
      "q_len",
      "hidden_size",
      "n_heads",
      "d_k",
      "d_v",
      "linear_hidden_size",
      "norm",
      "attn_dropout",
      "dropout",
      "activation",
      "res_attention",
      "n_layers",
      "pre_norm",
      "store_attn"
    ],
    "forward": [
      "self",
      "src",
      "key_padding_mask",
      "attn_mask"
    ]
  },
  "TSTEncoderLayer": {
    "__init__": [
      "self",
      "q_len",
      "hidden_size",
      "n_heads",
      "d_k",
      "d_v",
      "linear_hidden_size",
      "store_attn",
      "norm",
      "attn_dropout",
      "dropout",
      "bias",
      "activation",
      "res_attention",
      "pre_norm"
    ],
    "forward": [
      "self",
      "src",
      "prev",
      "key_padding_mask",
      "attn_mask"
    ]
  },
  "_MultiheadAttention": {
    "__init__": [
      "self",
      "hidden_size",
      "n_heads",
      "d_k",
      "d_v",
      "res_attention",
      "attn_dropout",
      "proj_dropout",
      "qkv_bias",
      "lsa"
    ],
    "forward": [
      "self",
      "Q",
      "K",
      "V",
      "prev",
      "key_padding_mask",
      "attn_mask"
    ]
  },
  "_ScaledDotProductAttention": {
    "__init__": [
      "self",
      "hidden_size",
      "n_heads",
      "attn_dropout",
      "res_attention",
      "lsa"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "prev",
      "key_padding_mask",
      "attn_mask"
    ]
  },
  "PatchTST": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "encoder_layers",
      "n_heads",
      "hidden_size",
      "linear_hidden_size",
      "dropout",
      "fc_dropout",
      "head_dropout",
      "attn_dropout",
      "patch_len",
      "stride",
      "revin",
      "revin_affine",
      "revin_subtract_last",
      "activation",
      "res_attention",
      "batch_normalization",
      "learn_pos_embed",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "WaveKANLayer": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "wavelet_type",
      "with_bn",
      "device"
    ],
    "wavelet_transform": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TaylorKANLayer": {
    "__init__": [
      "self",
      "input_dim",
      "out_dim",
      "order",
      "addbias"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "JacobiKANLayer": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "degree",
      "a",
      "b"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RMoK": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "taylor_order",
      "jacobi_degree",
      "wavelet_function",
      "dropout",
      "revin_affine",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "StockBlockLayer": {
    "__init__": [
      "self",
      "time_step",
      "unit",
      "multi_layer",
      "stack_cnt"
    ],
    "spe_seq_cell": [
      "self",
      "input"
    ],
    "forward": [
      "self",
      "x",
      "mul_L"
    ]
  },
  "StemGNN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "n_stacks",
      "multi_layer",
      "dropout_rate",
      "leaky_rate",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "get_laplacian": [
      "self",
      "graph",
      "normalize"
    ],
    "cheb_polynomial": [
      "self",
      "laplacian"
    ],
    "latent_correlation_layer": [
      "self",
      "x"
    ],
    "self_graph_attention": [
      "self",
      "input"
    ],
    "graph_fft": [
      "self",
      "input",
      "eigenvectors"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "NLinear": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "DLinear": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "moving_avg_window",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "ExogenousBasis": {
    "__init__": [
      "self",
      "forecast_size"
    ],
    "forward": [
      "self",
      "theta",
      "futr_exog"
    ]
  },
  "NBEATSx": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "n_harmonics",
      "n_polynomials",
      "stack_types",
      "n_blocks",
      "mlp_units",
      "dropout_prob_theta",
      "activation",
      "shared_weights",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "create_stack": [
      "self",
      "h",
      "input_size",
      "stack_types",
      "n_blocks",
      "mlp_units",
      "dropout_prob_theta",
      "activation",
      "shared_weights",
      "n_polynomials",
      "n_harmonics",
      "futr_input_size",
      "hist_input_size",
      "stat_input_size"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "xLSTM": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "h_train",
      "encoder_n_blocks",
      "encoder_hidden_size",
      "encoder_bias",
      "encoder_dropout",
      "decoder_hidden_size",
      "decoder_layers",
      "decoder_dropout",
      "decoder_activation",
      "backbone",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "recurrent",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "MixingLayerWithStaticExogenous": {
    "__init__": [
      "self",
      "h",
      "dropout",
      "ff_dim",
      "stat_input_size"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "ReversibleInstanceNorm1d": {
    "__init__": [
      "self",
      "n_series",
      "eps"
    ],
    "forward": [
      "self",
      "x"
    ],
    "reverse": [
      "self",
      "x"
    ]
  },
  "TSMixerx": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "n_block",
      "ff_dim",
      "dropout",
      "revin",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "LSTM": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "h_train",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "recurrent",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "RNN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "h_train",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_activation",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "recurrent",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "iTransformer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "hidden_size",
      "n_heads",
      "e_layers",
      "d_layers",
      "d_ff",
      "factor",
      "dropout",
      "use_norm",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forecast": [
      "self",
      "x_enc"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "DeepNPTS": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "hidden_size",
      "batch_norm",
      "dropout",
      "n_layers",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "MLPResidual": {
    "__init__": [
      "self",
      "input_dim",
      "hidden_size",
      "output_dim",
      "dropout",
      "layernorm"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "TiDE": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "hidden_size",
      "decoder_output_dim",
      "temporal_decoder_dim",
      "dropout",
      "layernorm",
      "num_encoder_layers",
      "num_decoder_layers",
      "temporal_width",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "LayerNorm": {
    "__init__": [
      "self",
      "channels"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "AutoCorrelationLayer": {
    "__init__": [
      "self",
      "correlation",
      "hidden_size",
      "n_head",
      "d_keys",
      "d_values"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "EncoderLayer": {
    "__init__": [
      "self",
      "attention",
      "hidden_size",
      "conv_hidden_size",
      "MovingAvg",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "Encoder": {
    "__init__": [
      "self",
      "attn_layers",
      "conv_layers",
      "norm_layer"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "DecoderLayer": {
    "__init__": [
      "self",
      "self_attention",
      "cross_attention",
      "hidden_size",
      "c_out",
      "conv_hidden_size",
      "MovingAvg",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask"
    ]
  },
  "get_frequency_modes": [
    "seq_len",
    "modes",
    "mode_select_method"
  ],
  "FourierBlock": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "seq_len",
      "modes",
      "mode_select_method"
    ],
    "compl_mul1d": [
      "self",
      "input",
      "weights"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "mask"
    ]
  },
  "FourierCrossAttention": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "seq_len_q",
      "seq_len_kv",
      "modes",
      "mode_select_method",
      "activation",
      "policy"
    ],
    "compl_mul1d": [
      "self",
      "input",
      "weights"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "mask"
    ]
  },
  "FEDformer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "decoder_input_size_multiplier",
      "version",
      "modes",
      "mode_select",
      "hidden_size",
      "dropout",
      "n_head",
      "conv_hidden_size",
      "activation",
      "encoder_layers",
      "decoder_layers",
      "MovingAvg_window",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "FlattenHead": {
    "__init__": [
      "self",
      "n_vars",
      "nf",
      "target_window",
      "head_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "EnEmbedding": {
    "__init__": [
      "self",
      "n_vars",
      "d_model",
      "patch_len",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeXer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "patch_len",
      "hidden_size",
      "n_heads",
      "e_layers",
      "d_ff",
      "factor",
      "dropout",
      "use_norm",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forecast": [
      "self",
      "x_enc",
      "x_mark_enc"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "GRU": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "h_train",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_activation",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "recurrent",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "ReplicationPad1d": {
    "__init__": [
      "self",
      "padding"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "PatchEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "patch_len",
      "stride",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ReprogrammingLayer": {
    "__init__": [
      "self",
      "d_model",
      "n_heads",
      "d_keys",
      "d_llm",
      "attention_dropout"
    ],
    "forward": [
      "self",
      "target_embedding",
      "source_embedding",
      "value_embedding"
    ],
    "reprogramming": [
      "self",
      "target_embedding",
      "source_embedding",
      "value_embedding"
    ]
  },
  "TimeLLM": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "patch_len",
      "stride",
      "d_ff",
      "top_k",
      "d_llm",
      "d_model",
      "n_heads",
      "enc_in",
      "dec_in",
      "llm",
      "llm_config",
      "llm_tokenizer",
      "llm_num_hidden_layers",
      "llm_output_attention",
      "llm_output_hidden_states",
      "prompt_prefix",
      "dropout",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "loss",
      "valid_loss",
      "learning_rate",
      "max_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "num_lr_decays",
      "early_stop_patience_steps",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forecast": [
      "self",
      "x_enc"
    ],
    "calcute_lags": [
      "self",
      "x_enc"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "MLPMultivariate": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "n_series",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "num_layers",
      "hidden_size",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "TCN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "inference_input_size",
      "kernel_size",
      "dilations",
      "encoder_hidden_size",
      "encoder_activation",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "VanillaTransformer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "decoder_input_size_multiplier",
      "hidden_size",
      "dropout",
      "n_head",
      "conv_hidden_size",
      "activation",
      "encoder_layers",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "AutoCorrelation": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "time_delay_agg_training": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_inference": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_full": [
      "self",
      "values",
      "corr"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "Autoformer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "decoder_input_size_multiplier",
      "hidden_size",
      "dropout",
      "factor",
      "n_head",
      "conv_hidden_size",
      "activation",
      "encoder_layers",
      "decoder_layers",
      "MovingAvg_window",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "ConvLayer": {
    "__init__": [
      "self",
      "c_in"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ProbMask": {
    "__init__": [
      "self",
      "B",
      "H",
      "L",
      "index",
      "scores",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "ProbAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "_prob_QK": [
      "self",
      "Q",
      "K",
      "sample_k",
      "n_top"
    ],
    "_get_initial_context": [
      "self",
      "V",
      "L_Q"
    ],
    "_update_context": [
      "self",
      "context_in",
      "V",
      "scores",
      "index",
      "L_Q",
      "attn_mask"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask",
      "tau",
      "delta"
    ]
  },
  "Informer": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "decoder_input_size_multiplier",
      "hidden_size",
      "dropout",
      "factor",
      "n_head",
      "conv_hidden_size",
      "activation",
      "encoder_layers",
      "decoder_layers",
      "distil",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  },
  "KANLinear": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "grid_size",
      "spline_order",
      "scale_noise",
      "scale_base",
      "scale_spline",
      "enable_standalone_scale_spline",
      "base_activation",
      "grid_eps",
      "grid_range"
    ],
    "reset_parameters": [
      "self"
    ],
    "b_splines": [
      "self",
      "x"
    ],
    "curve2coeff": [
      "self",
      "x",
      "y"
    ],
    "scaled_spline_weight": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ],
    "update_grid": [
      "self",
      "x",
      "margin"
    ],
    "regularization_loss": [
      "self",
      "regularize_activation",
      "regularize_entropy"
    ]
  },
  "KAN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "grid_size",
      "spline_order",
      "scale_noise",
      "scale_base",
      "scale_spline",
      "enable_standalone_scale_spline",
      "grid_eps",
      "grid_range",
      "n_hidden_layers",
      "hidden_size",
      "stat_exog_list",
      "hist_exog_list",
      "futr_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "dataloader_kwargs"
    ],
    "regularization_loss": [
      "self",
      "regularize_activation",
      "regularize_entropy"
    ],
    "forward": [
      "self",
      "windows_batch",
      "update_grid"
    ]
  },
  "CustomConv1d": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "padding",
      "dilation",
      "mode",
      "groups"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TCNCell": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "padding",
      "dilation",
      "mode",
      "groups",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "BiTCN": {
    "EXOGENOUS_FUTR": [],
    "EXOGENOUS_HIST": [],
    "EXOGENOUS_STAT": [],
    "MULTIVARIATE": [],
    "RECURRENT": [],
    "__init__": [
      "self",
      "h",
      "input_size",
      "hidden_size",
      "dropout",
      "futr_exog_list",
      "hist_exog_list",
      "stat_exog_list",
      "exclude_insample_y",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "windows_batch_size",
      "inference_windows_batch_size",
      "start_padding_enabled",
      "training_data_availability_threshold",
      "step_size",
      "scaler_type",
      "random_seed",
      "drop_last_loader",
      "alias",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "dataloader_kwargs"
    ],
    "forward": [
      "self",
      "windows_batch"
    ]
  }
}