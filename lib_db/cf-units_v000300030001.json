{
  "__all__": [],
  "EPOCH": [],
  "_UNKNOWN_UNIT_STRING": [],
  "_UNKNOWN_UNIT_SYMBOL": [],
  "_UNKNOWN_UNIT": [],
  "_NO_UNIT_STRING": [],
  "_NO_UNIT_SYMBOL": [],
  "_NO_UNIT": [],
  "_UNIT_DIMENSIONLESS": [],
  "_OP_SINCE": [],
  "UT_FORMATS": [],
  "CALENDAR_STANDARD": [],
  "CALENDAR_GREGORIAN": [],
  "CALENDAR_PROLEPTIC_GREGORIAN": [],
  "CALENDAR_NO_LEAP": [],
  "CALENDAR_JULIAN": [],
  "CALENDAR_ALL_LEAP": [],
  "CALENDAR_365_DAY": [],
  "CALENDAR_366_DAY": [],
  "CALENDAR_360_DAY": [],
  "CALENDARS": [],
  "CALENDAR_ALIASES": [],
  "FLOAT32": [],
  "FLOAT64": [],
  "_cv_convert_scalar": [],
  "_cv_convert_array": [],
  "_encoding_lookup": [],
  "suppress_errors": [],
  "LOCALE_LOCK": [],
  "c_locale": [],
  "encode_time": [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second"
  ],
  "encode_date": [
    "year",
    "month",
    "day"
  ],
  "encode_clock": [
    "hour",
    "minute",
    "second"
  ],
  "decode_time": [
    "time"
  ],
  "date2num": [
    "date",
    "unit",
    "calendar"
  ],
  "num2date": [
    "time_value",
    "unit",
    "calendar",
    "only_use_cftime_datetimes",
    "only_use_python_datetimes"
  ],
  "num2pydate": [
    "time_value",
    "unit",
    "calendar"
  ],
  "_CACHE": [],
  "as_unit": [
    "unit"
  ],
  "is_time": [
    "unit"
  ],
  "is_vertical": [
    "unit"
  ],
  "_ud_value_error": [
    "ud_err",
    "message"
  ],
  "Unit": {
    "_init_from_tuple": [
      "self",
      "values"
    ],
    "_identity": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__setattr__": [
      "self",
      "name",
      "value"
    ],
    "__delattr__": [
      "self",
      "name"
    ],
    "_names": [],
    "category": [],
    "ut_unit": [],
    "calendar": [],
    "origin": [],
    "__slots__": [],
    "__init__": [
      "self",
      "unit",
      "calendar"
    ],
    "_new_from_existing_ut": [
      "cls",
      "category",
      "ut_unit",
      "calendar",
      "origin"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "__copy__": [
      "self"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "is_time": [
      "self"
    ],
    "is_vertical": [
      "self"
    ],
    "is_udunits": [
      "self"
    ],
    "is_time_reference": [
      "self"
    ],
    "is_long_time_interval": [
      "self"
    ],
    "title": [
      "self",
      "value"
    ],
    "modulus": [
      "self"
    ],
    "is_convertible": [
      "self",
      "other"
    ],
    "is_dimensionless": [
      "self"
    ],
    "is_unknown": [
      "self"
    ],
    "is_no_unit": [
      "self"
    ],
    "format": [
      "self",
      "option"
    ],
    "name": [
      "self"
    ],
    "symbol": [
      "self"
    ],
    "definition": [
      "self"
    ],
    "offset_by_time": [
      "self",
      "origin"
    ],
    "invert": [
      "self"
    ],
    "root": [
      "self",
      "root"
    ],
    "log": [
      "self",
      "base"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_offset_common": [
      "self",
      "offset"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ],
    "_op_common": [
      "self",
      "other",
      "op_func"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__div__": [
      "self",
      "other"
    ],
    "__truediv__": [
      "self",
      "other"
    ],
    "__pow__": [
      "self",
      "power"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "change_calendar": [
      "self",
      "calendar"
    ],
    "convert": [
      "self",
      "value",
      "other",
      "ctype",
      "inplace"
    ],
    "cftime_unit": [
      "self"
    ],
    "date2num": [
      "self",
      "date"
    ],
    "num2date": [
      "self",
      "time_value",
      "only_use_cftime_datetimes",
      "only_use_python_datetimes"
    ],
    "num2pydate": [
      "self",
      "time_value"
    ]
  },
  "get_option": [
    "section",
    "option",
    "default"
  ],
  "get_xml_path": [],
  "ROOT_PATH": [],
  "CONFIG_PATH": [],
  "SITE_PATH": [],
  "config": [],
  "xml_database": [],
  "approx_equal": [
    "a",
    "b",
    "max_absolute_error",
    "max_relative_error"
  ],
  "_MetaOrderedHashable": {
    "__new__": [
      "cls",
      "name",
      "bases",
      "namespace"
    ]
  },
  "_OrderedHashable": {},
  "TeXVisitor": {
    "_format": [
      "self",
      "fmt",
      "lhs",
      "rhs"
    ],
    "visit_Identifier": [
      "self",
      "node"
    ],
    "visit_Raise": [
      "self",
      "node"
    ],
    "visit_Multiply": [
      "self",
      "node"
    ],
    "visit_Divide": [
      "self",
      "node"
    ],
    "visit_Shift": [
      "self",
      "node"
    ],
    "generic_visit": [
      "self",
      "node"
    ]
  },
  "tex": [
    "unit_str"
  ],
  "TYPE_CHECKING": [],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "__commit_id__": [],
  "commit_id": [],
  "test_basic": [],
  "test_identifier_micro": [],
  "test_raise": [],
  "test_multiply": [],
  "test_divide": [],
  "test_shift": [],
  "test_complex": [],
  "LICENSE_TEMPLATE": [],
  "REPO_DIR": [],
  "DOCS_DIR": [],
  "exclusion": [],
  "DOCS_DIRS": [],
  "IS_GIT_REPO": [],
  "TestLicenseHeaders": {
    "all_git_filepaths": [
      "cls"
    ],
    "test_license_headers": [
      "self"
    ]
  },
  "test_python_versions": [],
  "Test_unit__creation": {
    "test_is_valid_unit_string": [
      "self"
    ],
    "test_not_valid_unit_str": [
      "self"
    ],
    "test_calendar": [
      "self"
    ],
    "test_calendar_alias": [
      "self"
    ],
    "test_no_calendar": [
      "self"
    ],
    "test_unsupported_calendar": [
      "self"
    ],
    "test_calendar_w_unicode": [
      "self"
    ],
    "test_unicode_valid": [
      "self"
    ],
    "test_py2k_unicode": [
      "self"
    ],
    "test_unicode_invalid": [
      "self"
    ]
  },
  "Test_modulus": {
    "test_modulus__degrees": [
      "self"
    ],
    "test_modulus__radians": [
      "self"
    ],
    "test_no_modulus": [
      "self"
    ]
  },
  "Test_is_convertible": {
    "test_convert_distance_to_force": [
      "self"
    ],
    "test_convert_distance_units": [
      "self"
    ],
    "test_convert_to_unknown": [
      "self"
    ],
    "test_convert_to_no_unit": [
      "self"
    ],
    "test_convert_unknown_to_no_unit": [
      "self"
    ]
  },
  "Test_is_dimensionless": {
    "test_dimensionless": [
      "self"
    ],
    "test_distance_dimensionless": [
      "self"
    ],
    "test_unknown_dimensionless": [
      "self"
    ],
    "test_no_unit_dimensionless": [
      "self"
    ]
  },
  "Test_format": {
    "test_basic": [
      "self"
    ],
    "test_format_ascii": [
      "self"
    ],
    "test_format_ut_names": [
      "self"
    ],
    "test_format_unit_definition": [
      "self"
    ],
    "test_format_multiple_options": [
      "self"
    ],
    "test_format_multiple_options_utf8": [
      "self"
    ],
    "test_format_unknown": [
      "self"
    ],
    "test_format_no_unit": [
      "self"
    ],
    "test_format_names_utf8": [
      "self"
    ],
    "test_format_latin1": [
      "self"
    ]
  },
  "Test_name": {
    "test_basic": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_symbol": {
    "test_basic": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_definition": {
    "test_basic": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test__apply_offset": {
    "test_add_integer_offset": [
      "self"
    ],
    "test_add_float_offset": [
      "self"
    ],
    "test_not_numerical_offset": [
      "self"
    ],
    "test_unit_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_offset_by_time": {
    "test_offset": [
      "self"
    ],
    "test_not_numerical_offset": [
      "self"
    ],
    "test_not_time_unit": [
      "self"
    ],
    "test_unit_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_invert": {
    "test_basic": [
      "self"
    ],
    "test_double_invert": [
      "self"
    ],
    "test_invert_unknown": [
      "self"
    ],
    "test_invert_no_unit": [
      "self"
    ]
  },
  "Test_root": {
    "test_square_root": [
      "self"
    ],
    "test_square_root_integer_float": [
      "self"
    ],
    "test_not_numeric": [
      "self"
    ],
    "test_not_integer": [
      "self"
    ],
    "test_meaningless_operation": [
      "self"
    ],
    "test_unit_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_log": {
    "test_base_2": [
      "self"
    ],
    "test_base_10": [
      "self"
    ],
    "test_negative": [
      "self"
    ],
    "test_not_numeric": [
      "self"
    ],
    "test_unit_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_multiply": {
    "test_multiply_by_int": [
      "self"
    ],
    "test_multiply_by_float": [
      "self"
    ],
    "test_multiply_electrical_units": [
      "self"
    ],
    "test_multiply_not_numeric": [
      "self"
    ],
    "test_multiply_with_unknown_unit": [
      "self"
    ],
    "test_multiply_with_no_unit": [
      "self"
    ],
    "test_multiply_unknown_and_no_unit": [
      "self"
    ]
  },
  "Test_divide": {
    "test_divide_by_int": [
      "self"
    ],
    "test_divide_by_float": [
      "self"
    ],
    "test_divide_electrical_units": [
      "self"
    ],
    "test_divide_not_numeric": [
      "self"
    ],
    "test_divide_with_unknown_unit": [
      "self"
    ],
    "test_divide_with_no_unit": [
      "self"
    ],
    "test_divide_unknown_and_no_unit": [
      "self"
    ]
  },
  "Test_invalid_origin_post_operation": {
    "test_unit_1_multiply": [
      "self"
    ],
    "test_unit_1_divide": [
      "self"
    ],
    "test_unit_1_power": [
      "self"
    ]
  },
  "Test_pickle_with_unit_operations": {
    "test_pickle_unit": [
      "self"
    ],
    "test_pickle_unit_operation_unit_1": [
      "self"
    ],
    "test_pickle_unit_operation_unit": [
      "self"
    ]
  },
  "Test_power": {
    "test_basic": [
      "self"
    ],
    "test_integer_power": [
      "self"
    ],
    "test_float_power": [
      "self"
    ],
    "test_dimensionless": [
      "self"
    ],
    "test_power": [
      "self"
    ],
    "test_not_numeric": [
      "self"
    ],
    "test_bad_power": [
      "self"
    ],
    "test_unit_power": [
      "self"
    ]
  },
  "Test_power__unknown": {
    "setup_method": [
      "self"
    ],
    "test_integer_power": [
      "self"
    ],
    "test_float_power": [
      "self"
    ],
    "test_not_numeric": [
      "self"
    ],
    "test_bad_power": [
      "self"
    ],
    "test_unit_power": [
      "self"
    ]
  },
  "Test_power__no_unit": {
    "setup_method": [
      "self"
    ],
    "test_integer_power": [
      "self"
    ],
    "test_float_power": [
      "self"
    ],
    "test_not_numeric": [
      "self"
    ],
    "test_bad_power": [
      "self"
    ],
    "test_unit_power": [
      "self"
    ]
  },
  "Test_copy": {
    "test_basic": [
      "self"
    ],
    "test_unit_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_stringify": {
    "test___str__": [
      "self"
    ],
    "test___repr___basic": [
      "self"
    ],
    "test___repr___time_unit": [
      "self"
    ]
  },
  "Test_equality": {
    "test_basic": [
      "self"
    ],
    "test_equivalent_units": [
      "self"
    ],
    "test_non_equivalent_units": [
      "self"
    ],
    "test_eq_cross_category": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ],
    "test_unknown_no_unit": [
      "self"
    ],
    "test_not_implemented": [
      "self"
    ]
  },
  "Test_non_equality": {
    "test_basic": [
      "self"
    ],
    "test_non_equivalent_units": [
      "self"
    ],
    "test_ne_cross_category": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ],
    "test_not_implemented": [
      "self"
    ]
  },
  "Test_convert": {
    "test_convert_float": [
      "self"
    ],
    "test_convert_int": [
      "self"
    ],
    "test_convert_array": [
      "self"
    ],
    "test_convert_array_multidim": [
      "self"
    ],
    "test_incompatible_units": [
      "self"
    ],
    "test_unknown_units": [
      "self"
    ],
    "test_no_units": [
      "self"
    ],
    "test_convert_time_units": [
      "self"
    ],
    "test_incompatible_time_units": [
      "self"
    ]
  },
  "Test_order": {
    "test": [
      "self"
    ]
  },
  "Test_is_unknown": {
    "_check": [
      "self",
      "unknown_str"
    ],
    "test_unknown_representations": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ],
    "test_known_unit": [
      "self"
    ],
    "test_no_ut_pointer": [
      "self"
    ]
  },
  "Test_is_no_unit": {
    "_check": [
      "self",
      "no_unit_str"
    ],
    "test_no_unit_representations": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_known_unit": [
      "self"
    ]
  },
  "Test_is_udunits": {
    "test_basic": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_is_time_reference": {
    "test_basic": [
      "self"
    ],
    "test_not_time_reference": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_title": {
    "test_basic": [
      "self"
    ],
    "test_time_unit": [
      "self"
    ]
  },
  "Test__immutable": {
    "_set_attr": [
      "self",
      "unit",
      "name"
    ],
    "test_immutable": [
      "self"
    ],
    "test_common_hash": [
      "self"
    ]
  },
  "Test__inplace": {
    "test": [
      "self"
    ],
    "test_multidim_masked": [
      "self"
    ],
    "test_foreign_endian": [
      "self"
    ]
  },
  "TestTimeEncoding": {
    "test_encode_time": [
      "self"
    ],
    "test_encode_date": [
      "self"
    ],
    "test_encode_clock": [
      "self"
    ],
    "test_decode_time": [
      "self"
    ]
  },
  "TestNumsAndDates": {
    "test_num2date": [
      "self"
    ],
    "test_num2date_py_datetime_type": [
      "self"
    ],
    "test_num2date_wrong_calendar": [
      "self"
    ],
    "test_date2num": [
      "self"
    ],
    "test_num2pydate_simple": [
      "self"
    ],
    "test_num2pydate_wrong_calendar": [
      "self"
    ]
  },
  "Test_as_unit": {
    "test_already_unit": [
      "self"
    ],
    "test_known_unit_str": [
      "self"
    ],
    "test_not_unit_str": [
      "self"
    ],
    "test_unknown_str": [
      "self"
    ],
    "test_no_unit_str": [
      "self"
    ]
  },
  "Test_is_time": {
    "test_basic": [
      "self"
    ],
    "test_not_time_unit": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_is_vertical": {
    "test_pressure_unit": [
      "self"
    ],
    "test_length_unit": [
      "self"
    ],
    "test_not_vertical_unit": [
      "self"
    ],
    "test_unknown": [
      "self"
    ],
    "test_no_unit": [
      "self"
    ]
  },
  "Test_get_system": {
    "test_read_xml": [
      "self"
    ],
    "test_read_xml_invalid_path": [
      "self"
    ]
  },
  "Test_system": {
    "setup_method": [
      "self"
    ],
    "test_get_unit_by_name": [
      "self"
    ],
    "test_get_unit_by_name_invalid_unit": [
      "self"
    ],
    "test_parse": [
      "self"
    ],
    "test_parse_latin1": [
      "self"
    ],
    "test_parse_ISO_8859_1": [
      "self"
    ],
    "test_parse_UTF8": [
      "self"
    ],
    "test_parse_invalid_unit": [
      "self"
    ]
  },
  "Test_unit": {
    "setup_method": [
      "self"
    ],
    "test_clone": [
      "self"
    ],
    "test_is_dimensionless_true": [
      "self"
    ],
    "test_is_dimensionless_false": [
      "self"
    ],
    "test_compare_same_unit": [
      "self"
    ],
    "test_compare_diff_unit": [
      "self"
    ],
    "test_are_convertible_true": [
      "self"
    ],
    "test_are_convertible_false": [
      "self"
    ],
    "test_get_converter_valid": [
      "self"
    ],
    "test_get_converter_invalid": [
      "self"
    ],
    "test_scale": [
      "self"
    ],
    "test_offset": [
      "self"
    ],
    "test_offset_by_time_valid": [
      "self"
    ],
    "test_offset_by_time_invalid": [
      "self"
    ],
    "test_multiply": [
      "self"
    ],
    "test_invert": [
      "self"
    ],
    "test_divide": [
      "self"
    ],
    "test_raise_": [
      "self"
    ],
    "test_root": [
      "self"
    ],
    "test_log": [
      "self"
    ],
    "test_format": [
      "self"
    ]
  },
  "Test_time_encoding": {
    "setup_method": [
      "self"
    ],
    "test_encode_date": [
      "self"
    ],
    "test_encode_clock": [
      "self"
    ],
    "test_encode_time": [
      "self"
    ],
    "test_decode_time": [
      "self"
    ]
  },
  "StubUnit": {
    "__init__": [
      "self",
      "calendar"
    ],
    "__str__": [
      "self"
    ]
  },
  "TestAll": {
    "_assert_unit_equal": [
      "self",
      "unit1",
      "unit2"
    ],
    "test_cf_unit": [
      "self"
    ],
    "test_non_cf_unit_no_calendar": [
      "self"
    ],
    "test_non_cf_unit_with_calendar": [
      "self"
    ]
  },
  "Test___init__": {
    "test_capitalised_calendar": [
      "self"
    ],
    "test_not_basestring_calendar": [
      "self"
    ],
    "test_hash_replacement": [
      "self"
    ]
  },
  "Test_change_calendar": {
    "test_modern_standard_to_proleptic_gregorian": [
      "self"
    ],
    "test_ancient_standard_to_proleptic_gregorian": [
      "self"
    ],
    "test_no_change": [
      "self"
    ],
    "test_wrong_calendar": [
      "self"
    ],
    "test_non_time_unit": [
      "self"
    ]
  },
  "Test_convert__calendar": {
    "gregorian_calendar_conversion_setup": [
      "self"
    ],
    "test_gregorian_calendar_conversion_array": [
      "self"
    ],
    "test_gregorian_calendar_conversion_dtype": [
      "self"
    ],
    "test_gregorian_calendar_conversion_shape": [
      "self"
    ],
    "test_non_gregorian_calendar_conversion_dtype": [
      "self"
    ]
  },
  "Test_convert__endianness_time": {
    "setup_method": [
      "self"
    ],
    "test_no_endian": [
      "self"
    ],
    "test_little_endian": [
      "self"
    ],
    "test_big_endian": [
      "self"
    ]
  },
  "Test_convert__endianness_deg_to_rad": {
    "setup_method": [
      "self"
    ],
    "test_no_endian": [
      "self"
    ],
    "test_little_endian": [
      "self"
    ],
    "test_big_endian": [
      "self"
    ]
  },
  "Test_convert__endianness_degC_to_kelvin": {
    "setup_method": [
      "self"
    ],
    "test_no_endian": [
      "self"
    ],
    "test_little_endian": [
      "self"
    ],
    "test_big_endian": [
      "self"
    ]
  },
  "Test_convert__result_ctype": {
    "setup_method": [
      "self"
    ],
    "test_default": [
      "self"
    ],
    "test_integer_ctype_default": [
      "self"
    ],
    "test_integer_ctype_specified": [
      "self"
    ]
  },
  "Test_convert__masked_array": {
    "setup_method": [
      "self"
    ],
    "test_no_type_conversion": [
      "self"
    ],
    "test_type_conversion": [
      "self"
    ]
  },
  "Test_is_long_time_interval": {
    "test_deprecated": [],
    "test_short_time_interval": [
      "self"
    ],
    "test_long_time_interval": [
      "self"
    ],
    "test_calendar": [
      "self"
    ],
    "test_not_time_unit": [
      "self"
    ]
  },
  "Test": {
    "test_num2date_wrong_calendar": [
      "self"
    ]
  },
  "CALENDAR_CONSTANTS": [],
  "CALENDAR_STRINGS": [],
  "test_fractional_second": [
    "calendar_const",
    "calendar_str"
  ],
  "testdata": [],
  "invalid": [],
  "test_normed_units_equivalent": [
    "_",
    "unit_str"
  ],
  "udunits_bugs": [],
  "test_invalid_units": [
    "_",
    "unit_str"
  ],
  "multi_enumerate": [
    "items"
  ],
  "not_udunits": [],
  "test_invalid_in_udunits_but_still_parses": [
    "_",
    "unit_str",
    "expected"
  ],
  "known_issues": [],
  "test_known_issues": [
    "_",
    "unit_str",
    "expected"
  ],
  "test_syntax_parse_error_quality": [],
  "test_unknown_symbol_error": [],
  "not_allowed": [],
  "test_invalid_syntax_units": [
    "_",
    "unit_str"
  ],
  "test_Node_attributes": [],
  "test_Node_str": [],
  "test_Node_children": [],
  "test_large_graph": [],
  "Node": {
    "__init__": [
      "self"
    ],
    "children": [
      "self"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "_repr_ctx": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Terminal": {
    "__init__": [
      "self",
      "content"
    ],
    "children": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "Operand": {},
  "Number": {},
  "Identifier": {},
  "BinaryOp": {
    "__init__": [
      "self",
      "lhs",
      "rhs"
    ]
  },
  "Raise": {
    "__str__": [
      "self"
    ]
  },
  "Multiply": {
    "__str__": [
      "self"
    ]
  },
  "Divide": {
    "__str__": [
      "self"
    ]
  },
  "Shift": {
    "__init__": [
      "self",
      "unit",
      "shift_from"
    ],
    "__str__": [
      "self"
    ]
  },
  "Timestamp": {},
  "Visitor": {
    "visit": [
      "self",
      "node"
    ],
    "generic_visit": [
      "self",
      "node"
    ]
  },
  "TOKEN_ID_NAMES": [],
  "handle_UNICODE_EXPONENT": [
    "string"
  ],
  "UnitParseVisitor": {
    "TERM_HANDLERS": [],
    "defaultResult": [
      "self"
    ],
    "aggregateResult": [
      "self",
      "aggregate",
      "nextResult"
    ],
    "visitChildren": [
      "self",
      "node"
    ],
    "visitTerminal": [
      "self",
      "ctx"
    ],
    "visitProduct": [
      "self",
      "ctx"
    ],
    "visitTimestamp": [
      "self",
      "ctx"
    ],
    "visitPower": [
      "self",
      "ctx"
    ],
    "visitShift_spec": [
      "self",
      "ctx"
    ],
    "visitUnit_spec": [
      "self",
      "ctx"
    ]
  },
  "SyntaxErrorRaiser": {
    "__init__": [
      "self",
      "unit_string"
    ],
    "syntaxError": [
      "self",
      "recognizer",
      "offendingSymbol",
      "line",
      "column",
      "msg",
      "e"
    ]
  },
  "_debug_tokens": [
    "unit_string"
  ],
  "normalize": [
    "unit_string"
  ],
  "parse": [
    "unit_str"
  ],
  "ANTLR_VERSION": [],
  "JAR_NAME": [],
  "JAR_URL": [],
  "HERE": [],
  "JAR": [],
  "LEXER": [],
  "PARSER": [],
  "expand_lexer": [
    "source",
    "target"
  ],
  "fixup_antlr_imports": [
    "antlr_file_path",
    "contents"
  ],
  "vendor_antlr4_runtime": [
    "udunits2_parser_dir"
  ],
  "main": [],
  "serializedATN": [],
  "udunits2Parser": {
    "grammarFileName": [],
    "atn": [],
    "decisionsToDFA": [],
    "sharedContextCache": [],
    "literalNames": [],
    "symbolicNames": [],
    "RULE_unit_spec": [],
    "RULE_shift_spec": [],
    "RULE_product": [],
    "RULE_power": [],
    "RULE_basic_spec": [],
    "RULE_integer": [],
    "RULE_number": [],
    "RULE_timestamp": [],
    "RULE_signed_clock": [],
    "RULE_timezone_offset": [],
    "ruleNames": [],
    "EOF": [],
    "SIGNED_INT": [],
    "PLUS": [],
    "MULTIPLY": [],
    "DIVIDE": [],
    "PERIOD": [],
    "OPEN_PAREN": [],
    "CLOSE_PAREN": [],
    "SEMICOLON": [],
    "INT": [],
    "E_POWER": [],
    "FLOAT": [],
    "SHIFT_OP": [],
    "UNICODE_EXPONENT": [],
    "RAISE": [],
    "LOG": [],
    "LOGREF": [],
    "ID": [],
    "LATIN_SUBSET": [],
    "WS": [],
    "ERRORCHARACTER": [],
    "TIMEZONE": [],
    "HOUR_MINUTE_SECOND": [],
    "HOUR_MINUTE": [],
    "M_MINUS": [],
    "DATE": [],
    "TIMESTAMP": [],
    "DT_T_CLOCK": [],
    "__init__": [
      "self",
      "input",
      "output"
    ],
    "unit_spec": [
      "self"
    ],
    "shift_spec": [
      "self"
    ],
    "product": [
      "self",
      "_p"
    ],
    "power": [
      "self"
    ],
    "basic_spec": [
      "self"
    ],
    "integer": [
      "self"
    ],
    "number": [
      "self"
    ],
    "timestamp": [
      "self"
    ],
    "signed_clock": [
      "self"
    ],
    "timezone_offset": [
      "self"
    ],
    "sempred": [
      "self",
      "localctx",
      "ruleIndex",
      "predIndex"
    ],
    "product_sempred": [
      "self",
      "localctx",
      "predIndex"
    ]
  },
  "udunits2ParserVisitor": {
    "visitUnit_spec": [
      "self",
      "ctx"
    ],
    "visitShift_spec": [
      "self",
      "ctx"
    ],
    "visitProduct": [
      "self",
      "ctx"
    ],
    "visitPower": [
      "self",
      "ctx"
    ],
    "visitBasic_spec": [
      "self",
      "ctx"
    ],
    "visitInteger": [
      "self",
      "ctx"
    ],
    "visitNumber": [
      "self",
      "ctx"
    ],
    "visitTimestamp": [
      "self",
      "ctx"
    ],
    "visitSigned_clock": [
      "self",
      "ctx"
    ],
    "visitTimezone_offset": [
      "self",
      "ctx"
    ]
  },
  "udunits2Lexer": {
    "atn": [],
    "decisionsToDFA": [],
    "SHIFT_MODE": [],
    "ID_SEEN": [],
    "SIGNED_INT": [],
    "PLUS": [],
    "MULTIPLY": [],
    "DIVIDE": [],
    "PERIOD": [],
    "OPEN_PAREN": [],
    "CLOSE_PAREN": [],
    "SEMICOLON": [],
    "INT": [],
    "E_POWER": [],
    "FLOAT": [],
    "SHIFT_OP": [],
    "UNICODE_EXPONENT": [],
    "RAISE": [],
    "LOG": [],
    "LOGREF": [],
    "ID": [],
    "LATIN_SUBSET": [],
    "WS": [],
    "ERRORCHARACTER": [],
    "TIMEZONE": [],
    "HOUR_MINUTE_SECOND": [],
    "HOUR_MINUTE": [],
    "M_MINUS": [],
    "DATE": [],
    "TIMESTAMP": [],
    "DT_T_CLOCK": [],
    "channelNames": [],
    "modeNames": [],
    "literalNames": [],
    "symbolicNames": [],
    "ruleNames": [],
    "grammarFileName": [],
    "__init__": [
      "self",
      "input",
      "output"
    ]
  },
  "InputStream": {
    "__slots__": [],
    "__init__": [
      "self",
      "data"
    ],
    "_loadString": [
      "self"
    ],
    "index": [
      "self"
    ],
    "size": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "consume": [
      "self"
    ],
    "LA": [
      "self",
      "offset"
    ],
    "LT": [
      "self",
      "offset"
    ],
    "mark": [
      "self"
    ],
    "release": [
      "self",
      "marker"
    ],
    "seek": [
      "self",
      "_index"
    ],
    "getText": [
      "self",
      "start",
      "stop"
    ],
    "__str__": [
      "self"
    ]
  },
  "Token": {
    "__slots__": [],
    "INVALID_TYPE": [],
    "EPSILON": [],
    "MIN_USER_TOKEN_TYPE": [],
    "EOF": [],
    "DEFAULT_CHANNEL": [],
    "HIDDEN_CHANNEL": [],
    "__init__": [
      "self"
    ],
    "text": [
      "self",
      "text"
    ],
    "getTokenSource": [
      "self"
    ],
    "getInputStream": [
      "self"
    ]
  },
  "CommonToken": {
    "EMPTY_SOURCE": [],
    "__init__": [
      "self",
      "source",
      "type",
      "channel",
      "start",
      "stop"
    ],
    "clone": [
      "self"
    ],
    "text": [
      "self",
      "text"
    ],
    "__str__": [
      "self"
    ]
  },
  "Lexer": [],
  "TokenStream": {},
  "BufferedTokenStream": {
    "__slots__": [],
    "__init__": [
      "self",
      "tokenSource"
    ],
    "mark": [
      "self"
    ],
    "release": [
      "self",
      "marker"
    ],
    "reset": [
      "self"
    ],
    "seek": [
      "self",
      "index"
    ],
    "get": [
      "self",
      "index"
    ],
    "consume": [
      "self"
    ],
    "sync": [
      "self",
      "i"
    ],
    "fetch": [
      "self",
      "n"
    ],
    "getTokens": [
      "self",
      "start",
      "stop",
      "types"
    ],
    "LA": [
      "self",
      "i"
    ],
    "LB": [
      "self",
      "k"
    ],
    "LT": [
      "self",
      "k"
    ],
    "adjustSeekIndex": [
      "self",
      "i"
    ],
    "lazyInit": [
      "self"
    ],
    "setup": [
      "self"
    ],
    "setTokenSource": [
      "self",
      "tokenSource"
    ],
    "nextTokenOnChannel": [
      "self",
      "i",
      "channel"
    ],
    "previousTokenOnChannel": [
      "self",
      "i",
      "channel"
    ],
    "getHiddenTokensToRight": [
      "self",
      "tokenIndex",
      "channel"
    ],
    "getHiddenTokensToLeft": [
      "self",
      "tokenIndex",
      "channel"
    ],
    "filterForChannel": [
      "self",
      "left",
      "right",
      "channel"
    ],
    "getSourceName": [
      "self"
    ],
    "getText": [
      "self",
      "start",
      "stop"
    ],
    "fill": [
      "self"
    ]
  },
  "LL1Analyzer": {
    "__slots__": [],
    "HIT_PRED": [],
    "__init__": [
      "self",
      "atn"
    ],
    "getDecisionLookahead": [
      "self",
      "s"
    ],
    "LOOK": [
      "self",
      "s",
      "stopState",
      "ctx"
    ],
    "_LOOK": [
      "self",
      "s",
      "stopState",
      "ctx",
      "look",
      "lookBusy",
      "calledRuleStack",
      "seeThruPreds",
      "addEOF"
    ]
  },
  "ParserInterpreter": {
    "__slots__": [],
    "__init__": [
      "self",
      "grammarFileName",
      "tokenNames",
      "ruleNames",
      "atn",
      "input"
    ],
    "parse": [
      "self",
      "startRuleIndex"
    ],
    "enterRecursionRule": [
      "self",
      "localctx",
      "state",
      "ruleIndex",
      "precedence"
    ],
    "getATNState": [
      "self"
    ],
    "visitState": [
      "self",
      "p"
    ],
    "visitRuleStopState": [
      "self",
      "p"
    ]
  },
  "PredictionContext": {
    "EMPTY": [],
    "EMPTY_RETURN_STATE": [],
    "globalNodeCount": [],
    "id": [],
    "__init__": [
      "self",
      "cachedHashCode"
    ],
    "__len__": [
      "self"
    ],
    "isEmpty": [
      "self"
    ],
    "hasEmptyPath": [
      "self"
    ],
    "getReturnState": [
      "self",
      "index"
    ],
    "__hash__": [
      "self"
    ]
  },
  "calculateHashCode": [
    "parent",
    "returnState"
  ],
  "calculateListsHashCode": [
    "parents",
    "returnStates"
  ],
  "PredictionContextCache": {
    "__init__": [
      "self"
    ],
    "add": [
      "self",
      "ctx"
    ],
    "get": [
      "self",
      "ctx"
    ],
    "__len__": [
      "self"
    ]
  },
  "SingletonPredictionContext": {
    "create": [
      "parent",
      "returnState"
    ],
    "__init__": [
      "self",
      "parent",
      "returnState"
    ],
    "__len__": [
      "self"
    ],
    "getParent": [
      "self",
      "index"
    ],
    "getReturnState": [
      "self",
      "index"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "EmptyPredictionContext": {
    "__init__": [
      "self"
    ],
    "isEmpty": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ArrayPredictionContext": {
    "__init__": [
      "self",
      "parents",
      "returnStates"
    ],
    "isEmpty": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "getParent": [
      "self",
      "index"
    ],
    "getReturnState": [
      "self",
      "index"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ],
    "__hash__": [
      "self"
    ]
  },
  "PredictionContextFromRuleContext": [
    "atn",
    "outerContext"
  ],
  "merge": [
    "a",
    "b",
    "rootIsWildcard",
    "mergeCache"
  ],
  "mergeSingletons": [
    "a",
    "b",
    "rootIsWildcard",
    "mergeCache"
  ],
  "mergeRoot": [
    "a",
    "b",
    "rootIsWildcard"
  ],
  "mergeArrays": [
    "a",
    "b",
    "rootIsWildcard",
    "mergeCache"
  ],
  "combineCommonParents": [
    "parents"
  ],
  "getCachedPredictionContext": [
    "context",
    "contextCache",
    "visited"
  ],
  "getAllContextNodes": [
    "context",
    "nodes",
    "visited"
  ],
  "TokenFactory": {},
  "CommonTokenFactory": {
    "__slots__": [],
    "DEFAULT": [],
    "__init__": [
      "self",
      "copyText"
    ],
    "create": [
      "self",
      "source",
      "type",
      "text",
      "channel",
      "start",
      "stop",
      "line",
      "column"
    ],
    "createThin": [
      "self",
      "type",
      "text"
    ]
  },
  "IntervalSet": {
    "__slots__": [],
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "addOne": [
      "self",
      "v"
    ],
    "addRange": [
      "self",
      "v"
    ],
    "addSet": [
      "self",
      "other"
    ],
    "reduce": [
      "self",
      "k"
    ],
    "complement": [
      "self",
      "start",
      "stop"
    ],
    "__contains__": [
      "self",
      "item"
    ],
    "__len__": [
      "self"
    ],
    "removeRange": [
      "self",
      "v"
    ],
    "removeOne": [
      "self",
      "v"
    ],
    "toString": [
      "self",
      "literalNames",
      "symbolicNames"
    ],
    "elementName": [
      "self",
      "literalNames",
      "symbolicNames",
      "a"
    ]
  },
  "RecognitionException": [],
  "Recognizer": {
    "__slots__": [],
    "tokenTypeMapCache": [],
    "ruleIndexMapCache": [],
    "__init__": [
      "self"
    ],
    "extractVersion": [
      "self",
      "version"
    ],
    "checkVersion": [
      "self",
      "toolVersion"
    ],
    "addErrorListener": [
      "self",
      "listener"
    ],
    "removeErrorListener": [
      "self",
      "listener"
    ],
    "removeErrorListeners": [
      "self"
    ],
    "getTokenTypeMap": [
      "self"
    ],
    "getRuleIndexMap": [
      "self"
    ],
    "getTokenType": [
      "self",
      "tokenName"
    ],
    "getErrorHeader": [
      "self",
      "e"
    ],
    "getTokenErrorDisplay": [
      "self",
      "t"
    ],
    "getErrorListenerDispatch": [
      "self"
    ],
    "sempred": [
      "self",
      "localctx",
      "ruleIndex",
      "actionIndex"
    ],
    "precpred": [
      "self",
      "localctx",
      "precedence"
    ],
    "state": [
      "self",
      "atnState"
    ]
  },
  "TokenSource": {},
  "ListTokenSource": {
    "__slots__": [],
    "__init__": [
      "self",
      "tokens",
      "sourceName"
    ],
    "column": [
      "self"
    ],
    "nextToken": [
      "self"
    ],
    "line": [
      "self"
    ],
    "getInputStream": [
      "self"
    ],
    "getSourceName": [
      "self"
    ]
  },
  "RuleContext": {
    "__slots__": [],
    "EMPTY": [],
    "__init__": [
      "self",
      "parent",
      "invokingState"
    ],
    "depth": [
      "self"
    ],
    "isEmpty": [
      "self"
    ],
    "getSourceInterval": [
      "self"
    ],
    "getRuleContext": [
      "self"
    ],
    "getPayload": [
      "self"
    ],
    "getText": [
      "self"
    ],
    "getRuleIndex": [
      "self"
    ],
    "getAltNumber": [
      "self"
    ],
    "setAltNumber": [
      "self",
      "altNumber"
    ],
    "getChild": [
      "self",
      "i"
    ],
    "getChildCount": [
      "self"
    ],
    "getChildren": [
      "self"
    ],
    "accept": [
      "self",
      "visitor"
    ],
    "toStringTree": [
      "self",
      "ruleNames",
      "recog"
    ],
    "__str__": [
      "self"
    ],
    "toString": [
      "self",
      "ruleNames",
      "stop"
    ]
  },
  "Parser": [],
  "FileStream": {
    "__slots__": [],
    "__init__": [
      "self",
      "fileName",
      "encoding",
      "errors"
    ],
    "readDataFrom": [
      "self",
      "fileName",
      "encoding",
      "errors"
    ]
  },
  "TokenStreamRewriter": {
    "__slots__": [],
    "DEFAULT_PROGRAM_NAME": [],
    "PROGRAM_INIT_SIZE": [],
    "MIN_TOKEN_INDEX": [],
    "__init__": [
      "self",
      "tokens"
    ],
    "getTokenStream": [
      "self"
    ],
    "rollback": [
      "self",
      "instruction_index",
      "program_name"
    ],
    "deleteProgram": [
      "self",
      "program_name"
    ],
    "insertAfterToken": [
      "self",
      "token",
      "text",
      "program_name"
    ],
    "insertAfter": [
      "self",
      "index",
      "text",
      "program_name"
    ],
    "insertBeforeIndex": [
      "self",
      "index",
      "text"
    ],
    "insertBeforeToken": [
      "self",
      "token",
      "text",
      "program_name"
    ],
    "insertBefore": [
      "self",
      "program_name",
      "index",
      "text"
    ],
    "replaceIndex": [
      "self",
      "index",
      "text"
    ],
    "replaceRange": [
      "self",
      "from_idx",
      "to_idx",
      "text"
    ],
    "replaceSingleToken": [
      "self",
      "token",
      "text"
    ],
    "replaceRangeTokens": [
      "self",
      "from_token",
      "to_token",
      "text",
      "program_name"
    ],
    "replace": [
      "self",
      "program_name",
      "from_idx",
      "to_idx",
      "text"
    ],
    "deleteToken": [
      "self",
      "token"
    ],
    "deleteIndex": [
      "self",
      "index"
    ],
    "delete": [
      "self",
      "program_name",
      "from_idx",
      "to_idx"
    ],
    "lastRewriteTokenIndex": [
      "self",
      "program_name"
    ],
    "setLastRewriteTokenIndex": [
      "self",
      "program_name",
      "i"
    ],
    "getProgram": [
      "self",
      "program_name"
    ],
    "getDefaultText": [
      "self"
    ],
    "getText": [
      "self",
      "program_name",
      "start",
      "stop"
    ],
    "_reduceToSingleOperationPerIndex": [
      "self",
      "rewrites"
    ]
  },
  "ParserRuleContext": {
    "__slots__": [],
    "__init__": [
      "self",
      "parent",
      "invokingStateNumber"
    ],
    "copyFrom": [
      "self",
      "ctx"
    ],
    "enterRule": [
      "self",
      "listener"
    ],
    "exitRule": [
      "self",
      "listener"
    ],
    "addChild": [
      "self",
      "child"
    ],
    "removeLastChild": [
      "self"
    ],
    "addTokenNode": [
      "self",
      "token"
    ],
    "addErrorNode": [
      "self",
      "badToken"
    ],
    "getChild": [
      "self",
      "i",
      "ttype"
    ],
    "getChildren": [
      "self",
      "predicate"
    ],
    "getToken": [
      "self",
      "ttype",
      "i"
    ],
    "getTokens": [
      "self",
      "ttype"
    ],
    "getTypedRuleContext": [
      "self",
      "ctxType",
      "i"
    ],
    "getTypedRuleContexts": [
      "self",
      "ctxType"
    ],
    "getChildCount": [
      "self"
    ],
    "getSourceInterval": [
      "self"
    ]
  },
  "InterpreterRuleContext": {
    "__init__": [
      "self",
      "parent",
      "invokingStateNumber",
      "ruleIndex"
    ]
  },
  "TraceListener": {
    "__slots__": [],
    "__init__": [
      "self",
      "parser"
    ],
    "enterEveryRule": [
      "self",
      "ctx"
    ],
    "visitTerminal": [
      "self",
      "node"
    ],
    "visitErrorNode": [
      "self",
      "node"
    ],
    "exitEveryRule": [
      "self",
      "ctx"
    ]
  },
  "StdinStream": {
    "__init__": [
      "self",
      "encoding",
      "errors"
    ]
  },
  "str_list": [
    "val"
  ],
  "escapeWhitespace": [
    "s",
    "escapeSpaces"
  ],
  "CommonTokenStream": {
    "__slots__": [],
    "__init__": [
      "self",
      "lexer",
      "channel"
    ],
    "adjustSeekIndex": [
      "self",
      "i"
    ],
    "LB": [
      "self",
      "k"
    ],
    "LT": [
      "self",
      "k"
    ],
    "getNumberOfOnChannelTokens": [
      "self"
    ]
  },
  "XPath": {
    "WILDCARD": [],
    "NOT": [],
    "__init__": [
      "self",
      "parser",
      "path"
    ],
    "split": [
      "self",
      "path"
    ],
    "getXPathElement": [
      "self",
      "wordToken",
      "anywhere"
    ],
    "findAll": [
      "tree",
      "xpath",
      "parser"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathElement": {
    "__init__": [
      "self",
      "nodeName"
    ],
    "__str__": [
      "self"
    ]
  },
  "XPathRuleAnywhereElement": {
    "__init__": [
      "self",
      "ruleName",
      "ruleIndex"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathRuleElement": {
    "__init__": [
      "self",
      "ruleName",
      "ruleIndex"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathTokenAnywhereElement": {
    "__init__": [
      "self",
      "ruleName",
      "tokenType"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathTokenElement": {
    "__init__": [
      "self",
      "ruleName",
      "tokenType"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathWildcardAnywhereElement": {
    "__init__": [
      "self"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "XPathWildcardElement": {
    "__init__": [
      "self"
    ],
    "evaluate": [
      "self",
      "t"
    ]
  },
  "__author__": [],
  "XPathLexer": {
    "atn": [],
    "decisionsToDFA": [],
    "TOKEN_REF": [],
    "RULE_REF": [],
    "ANYWHERE": [],
    "ROOT": [],
    "WILDCARD": [],
    "BANG": [],
    "ID": [],
    "STRING": [],
    "channelNames": [],
    "modeNames": [],
    "literalNames": [],
    "symbolicNames": [],
    "ruleNames": [],
    "grammarFileName": [],
    "__init__": [
      "self",
      "input",
      "output"
    ],
    "action": [
      "self",
      "localctx",
      "ruleIndex",
      "actionIndex"
    ],
    "ID_action": [
      "self",
      "localctx",
      "actionIndex"
    ]
  },
  "RuleTagToken": {
    "__slots__": [],
    "__init__": [
      "self",
      "ruleName",
      "bypassTokenType",
      "label"
    ],
    "getText": [
      "self"
    ]
  },
  "INVALID_INTERVAL": [],
  "Tree": {},
  "SyntaxTree": {},
  "ParseTree": {},
  "RuleNode": {},
  "TerminalNode": {},
  "ErrorNode": {},
  "ParseTreeVisitor": {
    "visit": [
      "self",
      "tree"
    ],
    "visitChildren": [
      "self",
      "node"
    ],
    "visitTerminal": [
      "self",
      "node"
    ],
    "visitErrorNode": [
      "self",
      "node"
    ],
    "defaultResult": [
      "self"
    ],
    "aggregateResult": [
      "self",
      "aggregate",
      "nextResult"
    ],
    "shouldVisitNextChild": [
      "self",
      "node",
      "currentResult"
    ]
  },
  "ParseTreeListener": {
    "visitTerminal": [
      "self",
      "node"
    ],
    "visitErrorNode": [
      "self",
      "node"
    ],
    "enterEveryRule": [
      "self",
      "ctx"
    ],
    "exitEveryRule": [
      "self",
      "ctx"
    ]
  },
  "TerminalNodeImpl": {
    "__slots__": [],
    "__init__": [
      "self",
      "symbol"
    ],
    "__setattr__": [
      "self",
      "key",
      "value"
    ],
    "getChild": [
      "self",
      "i"
    ],
    "getSymbol": [
      "self"
    ],
    "getParent": [
      "self"
    ],
    "getPayload": [
      "self"
    ],
    "getSourceInterval": [
      "self"
    ],
    "getChildCount": [
      "self"
    ],
    "accept": [
      "self",
      "visitor"
    ],
    "getText": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ErrorNodeImpl": {
    "__init__": [
      "self",
      "token"
    ],
    "accept": [
      "self",
      "visitor"
    ]
  },
  "ParseTreeWalker": {
    "DEFAULT": [],
    "walk": [
      "self",
      "listener",
      "t"
    ],
    "enterRule": [
      "self",
      "listener",
      "r"
    ],
    "exitRule": [
      "self",
      "listener",
      "r"
    ]
  },
  "ParseTreePattern": {
    "__slots__": [],
    "__init__": [
      "self",
      "matcher",
      "pattern",
      "patternRuleIndex",
      "patternTree"
    ],
    "match": [
      "self",
      "tree"
    ],
    "matches": [
      "self",
      "tree"
    ],
    "findAll": [
      "self",
      "tree",
      "xpath"
    ]
  },
  "Chunk": {},
  "TagChunk": {
    "__slots__": [],
    "__init__": [
      "self",
      "tag",
      "label"
    ],
    "__str__": [
      "self"
    ]
  },
  "TextChunk": {
    "__slots__": [],
    "__init__": [
      "self",
      "text"
    ],
    "__str__": [
      "self"
    ]
  },
  "TokenTagToken": {
    "__slots__": [],
    "__init__": [
      "self",
      "tokenName",
      "type",
      "label"
    ],
    "getText": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "CannotInvokeStartRule": {
    "__init__": [
      "self",
      "e"
    ]
  },
  "StartRuleDoesNotConsumeFullPattern": {},
  "ParseTreePatternMatcher": {
    "__slots__": [],
    "__init__": [
      "self",
      "lexer",
      "parser"
    ],
    "setDelimiters": [
      "self",
      "start",
      "stop",
      "escapeLeft"
    ],
    "matchesRuleIndex": [
      "self",
      "tree",
      "pattern",
      "patternRuleIndex"
    ],
    "matchesPattern": [
      "self",
      "tree",
      "pattern"
    ],
    "matchRuleIndex": [
      "self",
      "tree",
      "pattern",
      "patternRuleIndex"
    ],
    "matchPattern": [
      "self",
      "tree",
      "pattern"
    ],
    "compileTreePattern": [
      "self",
      "pattern",
      "patternRuleIndex"
    ],
    "matchImpl": [
      "self",
      "tree",
      "patternTree",
      "labels"
    ],
    "map": [
      "self",
      "labels",
      "label",
      "tree"
    ],
    "getRuleTagToken": [
      "self",
      "tree"
    ],
    "tokenize": [
      "self",
      "pattern"
    ],
    "split": [
      "self",
      "pattern"
    ]
  },
  "ParseTreeMatch": {
    "__slots__": [],
    "__init__": [
      "self",
      "tree",
      "pattern",
      "labels",
      "mismatchedNode"
    ],
    "get": [
      "self",
      "label"
    ],
    "getAll": [
      "self",
      "label"
    ],
    "succeeded": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "Trees": {
    "toStringTree": [
      "cls",
      "t",
      "ruleNames",
      "recog"
    ],
    "getNodeText": [
      "cls",
      "t",
      "ruleNames",
      "recog"
    ],
    "getChildren": [
      "cls",
      "t"
    ],
    "getAncestors": [
      "cls",
      "t"
    ],
    "findAllTokenNodes": [
      "cls",
      "t",
      "ttype"
    ],
    "findAllRuleNodes": [
      "cls",
      "t",
      "ruleIndex"
    ],
    "findAllNodes": [
      "cls",
      "t",
      "index",
      "findTokens"
    ],
    "_findAllNodes": [
      "cls",
      "t",
      "index",
      "findTokens",
      "nodes"
    ],
    "descendants": [
      "cls",
      "t"
    ]
  },
  "DFASerializer": {
    "__slots__": [],
    "__init__": [
      "self",
      "dfa",
      "literalNames",
      "symbolicNames"
    ],
    "__str__": [
      "self"
    ],
    "getEdgeLabel": [
      "self",
      "i"
    ],
    "getStateString": [
      "self",
      "s"
    ]
  },
  "LexerDFASerializer": {
    "__init__": [
      "self",
      "dfa"
    ],
    "getEdgeLabel": [
      "self",
      "i"
    ]
  },
  "DFA": {
    "__slots__": [],
    "__init__": [
      "self",
      "atnStartState",
      "decision"
    ],
    "getPrecedenceStartState": [
      "self",
      "precedence"
    ],
    "setPrecedenceStartState": [
      "self",
      "precedence",
      "startState"
    ],
    "setPrecedenceDfa": [
      "self",
      "precedenceDfa"
    ],
    "states": [
      "self"
    ],
    "sortedStates": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "toString": [
      "self",
      "literalNames",
      "symbolicNames"
    ],
    "toLexerString": [
      "self"
    ]
  },
  "PredPrediction": {
    "__slots__": [],
    "__init__": [
      "self",
      "pred",
      "alt"
    ],
    "__str__": [
      "self"
    ]
  },
  "DFAState": {
    "__slots__": [],
    "__init__": [
      "self",
      "stateNumber",
      "configs"
    ],
    "getAltSet": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "DiagnosticErrorListener": {
    "__init__": [
      "self",
      "exactOnly"
    ],
    "reportAmbiguity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "exact",
      "ambigAlts",
      "configs"
    ],
    "reportAttemptingFullContext": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "conflictingAlts",
      "configs"
    ],
    "reportContextSensitivity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "prediction",
      "configs"
    ],
    "getDecisionDescription": [
      "self",
      "recognizer",
      "dfa"
    ],
    "getConflictingAlts": [
      "self",
      "reportedAlts",
      "configs"
    ]
  },
  "ErrorListener": {
    "syntaxError": [
      "self",
      "recognizer",
      "offendingSymbol",
      "line",
      "column",
      "msg",
      "e"
    ],
    "reportAmbiguity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "exact",
      "ambigAlts",
      "configs"
    ],
    "reportAttemptingFullContext": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "conflictingAlts",
      "configs"
    ],
    "reportContextSensitivity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "prediction",
      "configs"
    ]
  },
  "ConsoleErrorListener": {
    "INSTANCE": [],
    "syntaxError": [
      "self",
      "recognizer",
      "offendingSymbol",
      "line",
      "column",
      "msg",
      "e"
    ]
  },
  "ProxyErrorListener": {
    "__init__": [
      "self",
      "delegates"
    ],
    "syntaxError": [
      "self",
      "recognizer",
      "offendingSymbol",
      "line",
      "column",
      "msg",
      "e"
    ],
    "reportAmbiguity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "exact",
      "ambigAlts",
      "configs"
    ],
    "reportAttemptingFullContext": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "conflictingAlts",
      "configs"
    ],
    "reportContextSensitivity": [
      "self",
      "recognizer",
      "dfa",
      "startIndex",
      "stopIndex",
      "prediction",
      "configs"
    ]
  },
  "ErrorStrategy": {
    "reset": [
      "self",
      "recognizer"
    ],
    "recoverInline": [
      "self",
      "recognizer"
    ],
    "recover": [
      "self",
      "recognizer",
      "e"
    ],
    "sync": [
      "self",
      "recognizer"
    ],
    "inErrorRecoveryMode": [
      "self",
      "recognizer"
    ],
    "reportError": [
      "self",
      "recognizer",
      "e"
    ]
  },
  "DefaultErrorStrategy": {
    "__init__": [
      "self"
    ],
    "reset": [
      "self",
      "recognizer"
    ],
    "beginErrorCondition": [
      "self",
      "recognizer"
    ],
    "inErrorRecoveryMode": [
      "self",
      "recognizer"
    ],
    "endErrorCondition": [
      "self",
      "recognizer"
    ],
    "reportMatch": [
      "self",
      "recognizer"
    ],
    "reportError": [
      "self",
      "recognizer",
      "e"
    ],
    "recover": [
      "self",
      "recognizer",
      "e"
    ],
    "sync": [
      "self",
      "recognizer"
    ],
    "reportNoViableAlternative": [
      "self",
      "recognizer",
      "e"
    ],
    "reportInputMismatch": [
      "self",
      "recognizer",
      "e"
    ],
    "reportFailedPredicate": [
      "self",
      "recognizer",
      "e"
    ],
    "reportUnwantedToken": [
      "self",
      "recognizer"
    ],
    "reportMissingToken": [
      "self",
      "recognizer"
    ],
    "recoverInline": [
      "self",
      "recognizer"
    ],
    "singleTokenInsertion": [
      "self",
      "recognizer"
    ],
    "singleTokenDeletion": [
      "self",
      "recognizer"
    ],
    "getMissingSymbol": [
      "self",
      "recognizer"
    ],
    "getExpectedTokens": [
      "self",
      "recognizer"
    ],
    "getTokenErrorDisplay": [
      "self",
      "t"
    ],
    "escapeWSAndQuote": [
      "self",
      "s"
    ],
    "getErrorRecoverySet": [
      "self",
      "recognizer"
    ],
    "consumeUntil": [
      "self",
      "recognizer",
      "set_"
    ]
  },
  "BailErrorStrategy": {
    "recover": [
      "self",
      "recognizer",
      "e"
    ],
    "recoverInline": [
      "self",
      "recognizer"
    ],
    "sync": [
      "self",
      "recognizer"
    ]
  },
  "ATNConfigSet": [],
  "ParserRulecontext": [],
  "PredicateTransition": [],
  "UnsupportedOperationException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "IllegalStateException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "CancellationException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "LexerNoViableAltException": {
    "__init__": [
      "self",
      "lexer",
      "input",
      "startIndex",
      "deadEndConfigs"
    ],
    "__str__": [
      "self"
    ]
  },
  "NoViableAltException": {
    "__init__": [
      "self",
      "recognizer",
      "input",
      "startToken",
      "offendingToken",
      "deadEndConfigs",
      "ctx"
    ]
  },
  "InputMismatchException": {
    "__init__": [
      "self",
      "recognizer"
    ]
  },
  "FailedPredicateException": {
    "__init__": [
      "self",
      "recognizer",
      "predicate",
      "message"
    ],
    "formatMessage": [
      "self",
      "predicate",
      "message"
    ]
  },
  "ParseCancellationException": {},
  "SimState": {
    "__slots__": [],
    "__init__": [
      "self"
    ],
    "reset": [
      "self"
    ]
  },
  "LexerATNSimulator": {
    "__slots__": [],
    "debug": [],
    "dfa_debug": [],
    "MIN_DFA_EDGE": [],
    "MAX_DFA_EDGE": [],
    "ERROR": [],
    "__init__": [
      "self",
      "recog",
      "atn",
      "decisionToDFA",
      "sharedContextCache"
    ],
    "copyState": [
      "self",
      "simulator"
    ],
    "match": [
      "self",
      "input",
      "mode"
    ],
    "reset": [
      "self"
    ],
    "matchATN": [
      "self",
      "input"
    ],
    "execATN": [
      "self",
      "input",
      "ds0"
    ],
    "getExistingTargetState": [
      "self",
      "s",
      "t"
    ],
    "computeTargetState": [
      "self",
      "input",
      "s",
      "t"
    ],
    "failOrAccept": [
      "self",
      "prevAccept",
      "input",
      "reach",
      "t"
    ],
    "getReachableConfigSet": [
      "self",
      "input",
      "closure",
      "reach",
      "t"
    ],
    "accept": [
      "self",
      "input",
      "lexerActionExecutor",
      "startIndex",
      "index",
      "line",
      "charPos"
    ],
    "getReachableTarget": [
      "self",
      "trans",
      "t"
    ],
    "computeStartState": [
      "self",
      "input",
      "p"
    ],
    "closure": [
      "self",
      "input",
      "config",
      "configs",
      "currentAltReachedAcceptState",
      "speculative",
      "treatEofAsEpsilon"
    ],
    "getEpsilonTarget": [
      "self",
      "input",
      "config",
      "t",
      "configs",
      "speculative",
      "treatEofAsEpsilon"
    ],
    "evaluatePredicate": [
      "self",
      "input",
      "ruleIndex",
      "predIndex",
      "speculative"
    ],
    "captureSimState": [
      "self",
      "settings",
      "input",
      "dfaState"
    ],
    "addDFAEdge": [
      "self",
      "from_",
      "tk",
      "to",
      "cfgs"
    ],
    "addDFAState": [
      "self",
      "configs"
    ],
    "getDFA": [
      "self",
      "mode"
    ],
    "getText": [
      "self",
      "input"
    ],
    "consume": [
      "self",
      "input"
    ],
    "getTokenName": [
      "self",
      "t"
    ]
  },
  "ATNSimulator": {
    "__slots__": [],
    "ERROR": [],
    "__init__": [
      "self",
      "atn",
      "sharedContextCache"
    ],
    "getCachedContext": [
      "self",
      "context"
    ]
  },
  "LexerActionExecutor": {
    "__slots__": [],
    "__init__": [
      "self",
      "lexerActions"
    ],
    "append": [
      "lexerActionExecutor",
      "lexerAction"
    ],
    "fixOffsetBeforeMatch": [
      "self",
      "offset"
    ],
    "execute": [
      "self",
      "lexer",
      "input",
      "startIndex"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "PredictionMode": {
    "SLL": [],
    "LL": [],
    "LL_EXACT_AMBIG_DETECTION": [],
    "hasSLLConflictTerminatingPrediction": [
      "cls",
      "mode",
      "configs"
    ],
    "hasConfigInRuleStopState": [
      "cls",
      "configs"
    ],
    "allConfigsInRuleStopStates": [
      "cls",
      "configs"
    ],
    "resolvesToJustOneViableAlt": [
      "cls",
      "altsets"
    ],
    "allSubsetsConflict": [
      "cls",
      "altsets"
    ],
    "hasNonConflictingAltSet": [
      "cls",
      "altsets"
    ],
    "hasConflictingAltSet": [
      "cls",
      "altsets"
    ],
    "allSubsetsEqual": [
      "cls",
      "altsets"
    ],
    "getUniqueAlt": [
      "cls",
      "altsets"
    ],
    "getAlts": [
      "cls",
      "altsets"
    ],
    "getConflictingAltSubsets": [
      "cls",
      "configs"
    ],
    "getStateToAltMap": [
      "cls",
      "configs"
    ],
    "hasStateAssociatedWithOneAlt": [
      "cls",
      "configs"
    ],
    "getSingleViableAlt": [
      "cls",
      "altsets"
    ]
  },
  "LexerActionType": {
    "CHANNEL": [],
    "CUSTOM": [],
    "MODE": [],
    "MORE": [],
    "POP_MODE": [],
    "PUSH_MODE": [],
    "SKIP": [],
    "TYPE": []
  },
  "LexerAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "action"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "LexerSkipAction": {
    "INSTANCE": [],
    "__init__": [
      "self"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerTypeAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "type"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerPushModeAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "mode"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerPopModeAction": {
    "INSTANCE": [],
    "__init__": [
      "self"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerMoreAction": {
    "INSTANCE": [],
    "__init__": [
      "self"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerModeAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "mode"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerCustomAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "ruleIndex",
      "actionIndex"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "LexerChannelAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "channel"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerIndexedCustomAction": {
    "__slots__": [],
    "__init__": [
      "self",
      "offset",
      "action"
    ],
    "execute": [
      "self",
      "lexer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "ATNConfig": {
    "__slots__": [],
    "__init__": [
      "self",
      "state",
      "alt",
      "context",
      "semantic",
      "config"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "hashCodeForConfigSet": [
      "self"
    ],
    "equalsForConfigSet": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "LexerATNConfig": {
    "__slots__": [],
    "__init__": [
      "self",
      "state",
      "alt",
      "context",
      "semantic",
      "lexerActionExecutor",
      "config"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "hashCodeForConfigSet": [
      "self"
    ],
    "equalsForConfigSet": [
      "self",
      "other"
    ],
    "checkNonGreedyDecision": [
      "self",
      "source",
      "target"
    ]
  },
  "ParserATNSimulator": {
    "__slots__": [],
    "debug": [],
    "debug_list_atn_decisions": [],
    "dfa_debug": [],
    "retry_debug": [],
    "__init__": [
      "self",
      "parser",
      "atn",
      "decisionToDFA",
      "sharedContextCache"
    ],
    "reset": [
      "self"
    ],
    "adaptivePredict": [
      "self",
      "input",
      "decision",
      "outerContext"
    ],
    "execATN": [
      "self",
      "dfa",
      "s0",
      "input",
      "startIndex",
      "outerContext"
    ],
    "getExistingTargetState": [
      "self",
      "previousD",
      "t"
    ],
    "computeTargetState": [
      "self",
      "dfa",
      "previousD",
      "t"
    ],
    "predicateDFAState": [
      "self",
      "dfaState",
      "decisionState"
    ],
    "execATNWithFullContext": [
      "self",
      "dfa",
      "D",
      "s0",
      "input",
      "startIndex",
      "outerContext"
    ],
    "computeReachSet": [
      "self",
      "closure",
      "t",
      "fullCtx"
    ],
    "removeAllConfigsNotInRuleStopState": [
      "self",
      "configs",
      "lookToEndOfRule"
    ],
    "computeStartState": [
      "self",
      "p",
      "ctx",
      "fullCtx"
    ],
    "applyPrecedenceFilter": [
      "self",
      "configs"
    ],
    "getReachableTarget": [
      "self",
      "trans",
      "ttype"
    ],
    "getPredsForAmbigAlts": [
      "self",
      "ambigAlts",
      "configs",
      "nalts"
    ],
    "getPredicatePredictions": [
      "self",
      "ambigAlts",
      "altToPred"
    ],
    "getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule": [
      "self",
      "configs",
      "outerContext"
    ],
    "getAltThatFinishedDecisionEntryRule": [
      "self",
      "configs"
    ],
    "splitAccordingToSemanticValidity": [
      "self",
      "configs",
      "outerContext"
    ],
    "evalSemanticContext": [
      "self",
      "predPredictions",
      "outerContext",
      "complete"
    ],
    "closure": [
      "self",
      "config",
      "configs",
      "closureBusy",
      "collectPredicates",
      "fullCtx",
      "treatEofAsEpsilon"
    ],
    "closureCheckingStopState": [
      "self",
      "config",
      "configs",
      "closureBusy",
      "collectPredicates",
      "fullCtx",
      "depth",
      "treatEofAsEpsilon"
    ],
    "closure_": [
      "self",
      "config",
      "configs",
      "closureBusy",
      "collectPredicates",
      "fullCtx",
      "depth",
      "treatEofAsEpsilon"
    ],
    "canDropLoopEntryEdgeInLeftRecursiveRule": [
      "self",
      "config"
    ],
    "getRuleName": [
      "self",
      "index"
    ],
    "epsilonTargetMethods": [],
    "getEpsilonTarget": [
      "self",
      "config",
      "t",
      "collectPredicates",
      "inContext",
      "fullCtx",
      "treatEofAsEpsilon"
    ],
    "actionTransition": [
      "self",
      "config",
      "t"
    ],
    "precedenceTransition": [
      "self",
      "config",
      "pt",
      "collectPredicates",
      "inContext",
      "fullCtx"
    ],
    "predTransition": [
      "self",
      "config",
      "pt",
      "collectPredicates",
      "inContext",
      "fullCtx"
    ],
    "ruleTransition": [
      "self",
      "config",
      "t"
    ],
    "getConflictingAlts": [
      "self",
      "configs"
    ],
    "getConflictingAltsOrUniqueAlt": [
      "self",
      "configs"
    ],
    "getTokenName": [
      "self",
      "t"
    ],
    "getLookaheadName": [
      "self",
      "input"
    ],
    "dumpDeadEndConfigs": [
      "self",
      "nvae"
    ],
    "noViableAlt": [
      "self",
      "input",
      "outerContext",
      "configs",
      "startIndex"
    ],
    "getUniqueAlt": [
      "self",
      "configs"
    ],
    "addDFAEdge": [
      "self",
      "dfa",
      "from_",
      "t",
      "to"
    ],
    "addDFAState": [
      "self",
      "dfa",
      "D"
    ],
    "reportAttemptingFullContext": [
      "self",
      "dfa",
      "conflictingAlts",
      "configs",
      "startIndex",
      "stopIndex"
    ],
    "reportContextSensitivity": [
      "self",
      "dfa",
      "prediction",
      "configs",
      "startIndex",
      "stopIndex"
    ],
    "reportAmbiguity": [
      "self",
      "dfa",
      "D",
      "startIndex",
      "stopIndex",
      "exact",
      "ambigAlts",
      "configs"
    ]
  },
  "ATN": {
    "__slots__": [],
    "INVALID_ALT_NUMBER": [],
    "__init__": [
      "self",
      "grammarType",
      "maxTokenType"
    ],
    "nextTokensInContext": [
      "self",
      "s",
      "ctx"
    ],
    "nextTokensNoContext": [
      "self",
      "s"
    ],
    "nextTokens": [
      "self",
      "s",
      "ctx"
    ],
    "addState": [
      "self",
      "state"
    ],
    "removeState": [
      "self",
      "state"
    ],
    "defineDecisionState": [
      "self",
      "s"
    ],
    "getDecisionState": [
      "self",
      "decision"
    ],
    "getExpectedTokens": [
      "self",
      "stateNumber",
      "ctx"
    ]
  },
  "ATNType": {
    "LEXER": [],
    "PARSER": [],
    "fromOrdinal": [
      "cls",
      "i"
    ]
  },
  "ATNDeserializationOptions": {
    "__slots__": [],
    "defaultOptions": [],
    "__init__": [
      "self",
      "copyFrom"
    ],
    "__setattr__": [
      "self",
      "key",
      "value"
    ]
  },
  "OrderedATNConfigSet": {
    "__init__": [
      "self"
    ]
  },
  "SemanticContext": {
    "NONE": [],
    "eval": [
      "self",
      "parser",
      "outerContext"
    ],
    "evalPrecedence": [
      "self",
      "parser",
      "outerContext"
    ]
  },
  "AND": {
    "__slots__": [],
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "eval": [
      "self",
      "parser",
      "outerContext"
    ],
    "evalPrecedence": [
      "self",
      "parser",
      "outerContext"
    ],
    "__str__": [
      "self"
    ]
  },
  "andContext": [
    "a",
    "b"
  ],
  "OR": {
    "__slots__": [],
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "eval": [
      "self",
      "parser",
      "outerContext"
    ],
    "evalPrecedence": [
      "self",
      "parser",
      "outerContext"
    ],
    "__str__": [
      "self"
    ]
  },
  "orContext": [
    "a",
    "b"
  ],
  "filterPrecedencePredicates": [
    "collection"
  ],
  "EmptySemanticContext": {},
  "Predicate": {
    "__slots__": [],
    "__init__": [
      "self",
      "ruleIndex",
      "predIndex",
      "isCtxDependent"
    ],
    "eval": [
      "self",
      "parser",
      "outerContext"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "PrecedencePredicate": {
    "__init__": [
      "self",
      "precedence"
    ],
    "eval": [
      "self",
      "parser",
      "outerContext"
    ],
    "evalPrecedence": [
      "self",
      "parser",
      "outerContext"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "SERIALIZED_VERSION": [],
  "ATNDeserializer": {
    "__slots__": [],
    "__init__": [
      "self",
      "options"
    ],
    "deserialize": [
      "self",
      "data"
    ],
    "checkVersion": [
      "self"
    ],
    "readATN": [
      "self"
    ],
    "readStates": [
      "self",
      "atn"
    ],
    "readRules": [
      "self",
      "atn"
    ],
    "readModes": [
      "self",
      "atn"
    ],
    "readSets": [
      "self",
      "atn",
      "sets"
    ],
    "readEdges": [
      "self",
      "atn",
      "sets"
    ],
    "readDecisions": [
      "self",
      "atn"
    ],
    "readLexerActions": [
      "self",
      "atn"
    ],
    "generateRuleBypassTransitions": [
      "self",
      "atn"
    ],
    "generateRuleBypassTransition": [
      "self",
      "atn",
      "idx"
    ],
    "stateIsEndStateFor": [
      "self",
      "state",
      "idx"
    ],
    "markPrecedenceDecisions": [
      "self",
      "atn"
    ],
    "verifyATN": [
      "self",
      "atn"
    ],
    "checkCondition": [
      "self",
      "condition",
      "message"
    ],
    "readInt": [
      "self"
    ],
    "edgeFactories": [],
    "edgeFactory": [
      "self",
      "atn",
      "type",
      "src",
      "trg",
      "arg1",
      "arg2",
      "arg3",
      "sets"
    ],
    "stateFactories": [],
    "stateFactory": [
      "self",
      "type",
      "ruleIndex"
    ],
    "CHANNEL": [],
    "CUSTOM": [],
    "MODE": [],
    "MORE": [],
    "POP_MODE": [],
    "PUSH_MODE": [],
    "SKIP": [],
    "TYPE": [],
    "actionFactories": [],
    "lexerActionFactory": [
      "self",
      "type",
      "data1",
      "data2"
    ]
  },
  "INITIAL_NUM_TRANSITIONS": [],
  "ATNState": {
    "__slots__": [],
    "INVALID_TYPE": [],
    "BASIC": [],
    "RULE_START": [],
    "BLOCK_START": [],
    "PLUS_BLOCK_START": [],
    "STAR_BLOCK_START": [],
    "TOKEN_START": [],
    "RULE_STOP": [],
    "BLOCK_END": [],
    "STAR_LOOP_BACK": [],
    "STAR_LOOP_ENTRY": [],
    "PLUS_LOOP_BACK": [],
    "LOOP_END": [],
    "serializationNames": [],
    "INVALID_STATE_NUMBER": [],
    "__init__": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "onlyHasEpsilonTransitions": [
      "self"
    ],
    "isNonGreedyExitState": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "addTransition": [
      "self",
      "trans",
      "index"
    ]
  },
  "BasicState": {
    "__init__": [
      "self"
    ]
  },
  "DecisionState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "BlockStartState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "BasicBlockStartState": {
    "__init__": [
      "self"
    ]
  },
  "BlockEndState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "RuleStopState": {
    "__init__": [
      "self"
    ]
  },
  "RuleStartState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "PlusLoopbackState": {
    "__init__": [
      "self"
    ]
  },
  "PlusBlockStartState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "StarBlockStartState": {
    "__init__": [
      "self"
    ]
  },
  "StarLoopbackState": {
    "__init__": [
      "self"
    ]
  },
  "StarLoopEntryState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "LoopEndState": {
    "__slots__": [],
    "__init__": [
      "self"
    ]
  },
  "TokensStartState": {
    "__init__": [
      "self"
    ]
  },
  "Transition": {
    "__slots__": [],
    "EPSILON": [],
    "RANGE": [],
    "RULE": [],
    "PREDICATE": [],
    "ATOM": [],
    "ACTION": [],
    "SET": [],
    "NOT_SET": [],
    "WILDCARD": [],
    "PRECEDENCE": [],
    "serializationNames": [],
    "serializationTypes": [],
    "__init__": [
      "self",
      "target"
    ]
  },
  "AtomTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "label"
    ],
    "makeLabel": [
      "self"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "RuleTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "ruleStart",
      "ruleIndex",
      "precedence",
      "followState"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ]
  },
  "EpsilonTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "outermostPrecedenceReturn"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "RangeTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "start",
      "stop"
    ],
    "makeLabel": [
      "self"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "AbstractPredicateTransition": {
    "__init__": [
      "self",
      "target"
    ]
  },
  "ActionTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "ruleIndex",
      "actionIndex",
      "isCtxDependent"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "SetTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "set"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "NotSetTransition": {
    "__init__": [
      "self",
      "target",
      "set"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "WildcardTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "__str__": [
      "self"
    ]
  },
  "PrecedencePredicateTransition": {
    "__slots__": [],
    "__init__": [
      "self",
      "target",
      "precedence"
    ],
    "matches": [
      "self",
      "symbol",
      "minVocabSymbol",
      "maxVocabSymbol"
    ],
    "getPredicate": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  }
}