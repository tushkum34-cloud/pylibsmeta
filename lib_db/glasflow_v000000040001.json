{
  "get_torch_size": [
    "shape"
  ],
  "logger": [],
  "_import_submodules": [
    "module"
  ],
  "USE_NFLOWS": [],
  "__all__": [],
  "MLP": {
    "__init__": [
      "self",
      "input_shape",
      "output_shape",
      "n_neurons_per_layer",
      "activation_fn",
      "activate_output",
      "dropout_probability"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "ResampledGaussian": {
    "__init__": [
      "self",
      "shape",
      "acceptance_fn",
      "eps",
      "truncation",
      "trainable"
    ],
    "_log_prob_gaussian": [
      "self",
      "norm_inputs"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "estimate_normalisation_constant": [
      "self",
      "n_samples",
      "n_batches"
    ]
  },
  "MultivariateUniform": {
    "__init__": [
      "self",
      "low",
      "high"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ]
  },
  "AffineCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "unconditional_transform",
      "scaling_method",
      "scale_activation"
    ]
  },
  "SCALE_ACTIVATIONS": [],
  "get_scale_activation": [
    "activation"
  ],
  "CouplingFlow": {
    "__init__": [
      "self",
      "transform_class",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "linear_transform",
      "distribution",
      "mask"
    ],
    "validate_mask": [
      "mask",
      "n_inputs",
      "n_transforms"
    ]
  },
  "Flow": {
    "__init__": [
      "self",
      "transform",
      "distribution"
    ],
    "forward": [
      "self",
      "x",
      "conditional"
    ],
    "inverse": [
      "self",
      "z",
      "conditional"
    ],
    "sample": [
      "self",
      "num_samples",
      "conditional"
    ],
    "log_prob": [
      "self",
      "inputs",
      "conditional"
    ],
    "base_distribution_log_prob": [
      "self",
      "z"
    ],
    "forward_and_log_prob": [
      "self",
      "x",
      "conditional"
    ],
    "sample_and_log_prob": [
      "self",
      "N",
      "conditional"
    ]
  },
  "CouplingNSF": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "linear_transform",
      "distribution",
      "mask",
      "num_bins",
      "tail_type",
      "tail_bound"
    ]
  },
  "RealNVP": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "linear_transform",
      "distribution",
      "mask",
      "volume_preserving"
    ]
  },
  "MaskedAutoregressiveFlow": {
    "__init__": [
      "self",
      "transform_class",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution"
    ]
  },
  "MaskedAffineAutoregressiveFlow": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution"
    ]
  },
  "MaskedPiecewiseLinearAutoregressiveFlow": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution",
      "num_bins"
    ]
  },
  "MaskedPiecewiseQuadraticAutoregressiveFlow": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution",
      "num_bins"
    ]
  },
  "MaskedPiecewiseCubicAutoregressiveAutoregressiveFlow": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution",
      "num_bins"
    ]
  },
  "MaskedPiecewiseRationalQuadraticAutoregressiveFlow": {
    "__init__": [
      "self",
      "n_inputs",
      "n_transforms",
      "n_conditional_inputs",
      "n_neurons",
      "n_blocks_per_transform",
      "batch_norm_within_blocks",
      "batch_norm_between_transforms",
      "activation",
      "dropout_probability",
      "use_random_permutations",
      "use_random_masks",
      "distribution",
      "num_bins"
    ]
  },
  "__version__": [],
  "VERSION": [],
  "ResidualBlock": {
    "__init__": [
      "self",
      "features",
      "context_features",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "zero_initialization"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "ResidualNet": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "activation",
      "dropout_probability",
      "use_batch_norm"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "ConvResidualBlock": {
    "__init__": [
      "self",
      "channels",
      "context_channels",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "zero_initialization"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "ConvResidualNet": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "hidden_channels",
      "context_channels",
      "num_blocks",
      "activation",
      "dropout_probability",
      "use_batch_norm"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "main": [],
  "_get_input_degrees": [
    "in_features"
  ],
  "MaskedLinear": {
    "__init__": [
      "self",
      "in_degrees",
      "out_features",
      "autoregressive_features",
      "random_mask",
      "is_output",
      "bias"
    ],
    "_get_mask_and_degrees": [
      "cls",
      "in_degrees",
      "out_features",
      "autoregressive_features",
      "random_mask",
      "is_output"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MaskedFeedforwardBlock": {
    "__init__": [
      "self",
      "in_degrees",
      "autoregressive_features",
      "context_features",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "zero_initialization"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "MaskedResidualBlock": {
    "__init__": [
      "self",
      "in_degrees",
      "autoregressive_features",
      "context_features",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "zero_initialization"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "MADE": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "output_multiplier",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "MixtureOfGaussiansMADE": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "num_mixture_components",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "epsilon",
      "custom_initialization"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_initialize": [
      "self"
    ]
  },
  "is_bool": [
    "x"
  ],
  "is_int": [
    "x"
  ],
  "is_positive_int": [
    "x"
  ],
  "is_nonnegative_int": [
    "x"
  ],
  "is_power_of_two": [
    "n"
  ],
  "tile": [
    "x",
    "n"
  ],
  "sum_except_batch": [
    "x",
    "num_batch_dims"
  ],
  "split_leading_dim": [
    "x",
    "shape"
  ],
  "merge_leading_dims": [
    "x",
    "num_dims"
  ],
  "repeat_rows": [
    "x",
    "num_reps"
  ],
  "tensor2numpy": [
    "x"
  ],
  "logabsdet": [
    "x"
  ],
  "random_orthogonal": [
    "size"
  ],
  "get_num_parameters": [
    "model"
  ],
  "create_alternating_binary_mask": [
    "features",
    "even"
  ],
  "create_mid_split_binary_mask": [
    "features"
  ],
  "create_random_binary_mask": [
    "features"
  ],
  "searchsorted": [
    "bin_locations",
    "inputs",
    "eps"
  ],
  "cbrt": [
    "x"
  ],
  "get_temperature": [
    "max_value",
    "bound"
  ],
  "gaussian_kde_log_eval": [
    "samples",
    "query"
  ],
  "MADEMoG": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "num_mixture_components",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "custom_initialization"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ]
  },
  "NoMeanException": {},
  "Distribution": {
    "forward": [
      "self"
    ],
    "log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "sample": [
      "self",
      "num_samples",
      "context",
      "batch_size"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "sample_and_log_prob": [
      "self",
      "num_samples",
      "context"
    ],
    "mean": [
      "self",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "StandardNormal": {
    "__init__": [
      "self",
      "shape"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "ConditionalDiagonalNormal": {
    "__init__": [
      "self",
      "shape",
      "context_encoder"
    ],
    "_compute_params": [
      "self",
      "context"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "DiagonalNormal": {
    "__init__": [
      "self",
      "shape"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "ConditionalIndependentBernoulli": {
    "__init__": [
      "self",
      "shape",
      "context_encoder"
    ],
    "_compute_params": [
      "self",
      "context"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "BoxUniform": {
    "__init__": [
      "self",
      "low",
      "high",
      "reinterpreted_batch_ndims"
    ]
  },
  "MG1Uniform": {
    "log_prob": [
      "self",
      "value"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "_to_parameters": [
      "self",
      "noise"
    ],
    "_to_noise": [
      "self",
      "parameters"
    ]
  },
  "LotkaVolterraOscillating": {
    "__init__": [
      "self"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "sample": [
      "self",
      "sample_shape"
    ]
  },
  "LULinear": {
    "__init__": [
      "self",
      "features",
      "using_cache",
      "identity_init",
      "eps"
    ],
    "_initialize": [
      "self",
      "identity_init"
    ],
    "_create_lower_upper": [
      "self"
    ],
    "forward_no_cache": [
      "self",
      "inputs"
    ],
    "inverse_no_cache": [
      "self",
      "inputs"
    ],
    "weight": [
      "self"
    ],
    "weight_inverse": [
      "self"
    ],
    "upper_diag": [
      "self"
    ],
    "logabsdet": [
      "self"
    ]
  },
  "CouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "unconditional_transform"
    ],
    "num_identity_features": [
      "self"
    ],
    "num_transform_features": [
      "self"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_coupling_transform_forward": [
      "self",
      "inputs",
      "transform_params"
    ],
    "_coupling_transform_inverse": [
      "self",
      "inputs",
      "transform_params"
    ]
  },
  "AdditiveCouplingTransform": {
    "_transform_dim_multiplier": [
      "self"
    ],
    "_scale_and_shift": [
      "self",
      "transform_params"
    ]
  },
  "PiecewiseCouplingTransform": {
    "_coupling_transform_forward": [
      "self",
      "inputs",
      "transform_params"
    ],
    "_coupling_transform_inverse": [
      "self",
      "inputs",
      "transform_params"
    ],
    "_coupling_transform": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ],
    "_piecewise_cdf": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ]
  },
  "PiecewiseLinearCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "num_bins",
      "tails",
      "tail_bound",
      "apply_unconditional_transform",
      "img_shape"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_piecewise_cdf": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ]
  },
  "PiecewiseQuadraticCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "num_bins",
      "tails",
      "tail_bound",
      "apply_unconditional_transform",
      "img_shape",
      "min_bin_width",
      "min_bin_height"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_piecewise_cdf": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ]
  },
  "PiecewiseCubicCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "num_bins",
      "tails",
      "tail_bound",
      "apply_unconditional_transform",
      "img_shape",
      "min_bin_width",
      "min_bin_height"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_piecewise_cdf": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ]
  },
  "PiecewiseRationalQuadraticCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "num_bins",
      "tails",
      "tail_bound",
      "apply_unconditional_transform",
      "img_shape",
      "min_bin_width",
      "min_bin_height",
      "min_derivative"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_piecewise_cdf": [
      "self",
      "inputs",
      "transform_params",
      "inverse"
    ]
  },
  "OneByOneConvolution": {
    "__init__": [
      "self",
      "num_channels",
      "using_cache",
      "identity_init"
    ],
    "_lu_forward_inverse": [
      "self",
      "inputs",
      "inverse"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "InverseNotAvailable": {},
  "InputOutsideDomain": {},
  "Transform": {
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "CompositeTransform": {
    "__init__": [
      "self",
      "transforms"
    ],
    "_cascade": [
      "inputs",
      "funcs",
      "context"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "MultiscaleCompositeTransform": {
    "__init__": [
      "self",
      "num_transforms",
      "split_dim"
    ],
    "add_transform": [
      "self",
      "transform",
      "transform_output_shape"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "InverseTransform": {
    "__init__": [
      "self",
      "transform"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "Permutation": {
    "__init__": [
      "self",
      "permutation",
      "dim"
    ],
    "_inverse_permutation": [
      "self"
    ],
    "_permute": [
      "inputs",
      "permutation",
      "dim"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "RandomPermutation": {
    "__init__": [
      "self",
      "features",
      "dim"
    ]
  },
  "ReversePermutation": {
    "__init__": [
      "self",
      "features",
      "dim"
    ]
  },
  "QRLinear": {
    "__init__": [
      "self",
      "features",
      "num_householder",
      "using_cache"
    ],
    "_initialize": [
      "self"
    ],
    "_create_upper": [
      "self"
    ],
    "forward_no_cache": [
      "self",
      "inputs"
    ],
    "inverse_no_cache": [
      "self",
      "inputs"
    ],
    "weight": [
      "self"
    ],
    "weight_inverse": [
      "self"
    ],
    "logabsdet": [
      "self"
    ]
  },
  "IdentityTransform": {
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "PointwiseAffineTransform": {
    "__init__": [
      "self",
      "shift",
      "scale"
    ],
    "_log_scale": [
      "self"
    ],
    "_batch_logabsdet": [
      "self",
      "batch_shape"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "AffineTransform": {
    "__init__": [
      "self",
      "shift",
      "scale"
    ]
  },
  "AffineScalarTransform": [],
  "BatchNorm": {
    "__init__": [
      "self",
      "features",
      "eps",
      "momentum",
      "affine"
    ],
    "weight": [
      "self"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "ActNorm": {
    "__init__": [
      "self",
      "features"
    ],
    "scale": [
      "self"
    ],
    "_broadcastable_scale_shift": [
      "self",
      "inputs"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ],
    "_initialize": [
      "self",
      "inputs"
    ]
  },
  "HouseholderSequence": {
    "__init__": [
      "self",
      "features",
      "num_transforms"
    ],
    "_apply_transforms": [
      "inputs",
      "q_vectors"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ],
    "matrix": [
      "self"
    ]
  },
  "SVDLinear": {
    "__init__": [
      "self",
      "features",
      "num_householder",
      "using_cache",
      "identity_init",
      "eps"
    ],
    "diagonal": [
      "self"
    ],
    "log_diagonal": [
      "self"
    ],
    "_initialize": [
      "self"
    ],
    "forward_no_cache": [
      "self",
      "inputs"
    ],
    "inverse_no_cache": [
      "self",
      "inputs"
    ],
    "weight": [
      "self"
    ],
    "weight_inverse": [
      "self"
    ],
    "logabsdet": [
      "self"
    ]
  },
  "AutoregressiveTransform": {
    "__init__": [
      "self",
      "autoregressive_net"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "MaskedAffineAutoregressiveTransform": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "scale_activation"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_unconstrained_scale_and_shift": [
      "self",
      "autoregressive_params"
    ]
  },
  "MaskedPiecewiseLinearAutoregressiveTransform": {
    "__init__": [
      "self",
      "num_bins",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise": [
      "self",
      "inputs",
      "autoregressive_params",
      "inverse"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "MaskedPiecewiseQuadraticAutoregressiveTransform": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_bins",
      "num_blocks",
      "tails",
      "tail_bound",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "min_bin_width",
      "min_bin_height",
      "min_derivative"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise": [
      "self",
      "inputs",
      "autoregressive_params",
      "inverse"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "MaskedPiecewiseCubicAutoregressiveTransform": {
    "__init__": [
      "self",
      "num_bins",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise": [
      "self",
      "inputs",
      "autoregressive_params",
      "inverse"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "MaskedPiecewiseRationalQuadraticAutoregressiveTransform": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_bins",
      "tails",
      "tail_bound",
      "num_blocks",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "min_bin_width",
      "min_bin_height",
      "min_derivative"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise": [
      "self",
      "inputs",
      "autoregressive_params",
      "inverse"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "Tanh": {
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "LogTanh": {
    "__init__": [
      "self",
      "cut_point"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "LeakyReLU": {
    "__init__": [
      "self",
      "negative_slope"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "Sigmoid": {
    "__init__": [
      "self",
      "temperature",
      "eps",
      "learn_temperature"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "Logit": {
    "__init__": [
      "self",
      "temperature",
      "eps"
    ]
  },
  "GatedLinearUnit": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "CauchyCDF": {
    "__init__": [
      "self",
      "location",
      "scale",
      "features"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "CauchyCDFInverse": {
    "__init__": [
      "self",
      "location",
      "scale",
      "features"
    ]
  },
  "CompositeCDFTransform": {
    "__init__": [
      "self",
      "squashing_transform",
      "cdf_transform"
    ]
  },
  "_share_across_batch": [
    "params",
    "batch_size"
  ],
  "PiecewiseLinearCDF": {
    "__init__": [
      "self",
      "shape",
      "num_bins",
      "tails",
      "tail_bound"
    ],
    "_spline": [
      "self",
      "inputs",
      "inverse"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "PiecewiseQuadraticCDF": {
    "__init__": [
      "self",
      "shape",
      "num_bins",
      "tails",
      "tail_bound",
      "min_bin_width",
      "min_bin_height"
    ],
    "_spline": [
      "self",
      "inputs",
      "inverse"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "PiecewiseCubicCDF": {
    "__init__": [
      "self",
      "shape",
      "num_bins",
      "tails",
      "tail_bound",
      "min_bin_width",
      "min_bin_height"
    ],
    "_spline": [
      "self",
      "inputs",
      "inverse"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "PiecewiseRationalQuadraticCDF": {
    "__init__": [
      "self",
      "shape",
      "num_bins",
      "tails",
      "tail_bound",
      "identity_init",
      "min_bin_width",
      "min_bin_height",
      "min_derivative"
    ],
    "_spline": [
      "self",
      "inputs",
      "inverse"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "SqueezeTransform": {
    "__init__": [
      "self",
      "factor"
    ],
    "get_output_shape": [
      "self",
      "c",
      "h",
      "w"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ]
  },
  "LinearCache": {
    "__init__": [
      "self"
    ],
    "invalidate": [
      "self"
    ]
  },
  "Linear": {
    "__init__": [
      "self",
      "features",
      "using_cache"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ],
    "_check_forward_cache": [
      "self"
    ],
    "inverse": [
      "self",
      "inputs",
      "context"
    ],
    "_check_inverse_cache": [
      "self"
    ],
    "train": [
      "self",
      "mode"
    ],
    "use_cache": [
      "self",
      "mode"
    ],
    "weight_and_logabsdet": [
      "self"
    ],
    "weight_inverse_and_logabsdet": [
      "self"
    ],
    "forward_no_cache": [
      "self",
      "inputs"
    ],
    "inverse_no_cache": [
      "self",
      "inputs"
    ],
    "weight": [
      "self"
    ],
    "weight_inverse": [
      "self"
    ],
    "logabsdet": [
      "self"
    ]
  },
  "NaiveLinear": {
    "__init__": [
      "self",
      "features",
      "orthogonal_initialization",
      "using_cache"
    ],
    "forward_no_cache": [
      "self",
      "inputs"
    ],
    "inverse_no_cache": [
      "self",
      "inputs"
    ],
    "weight": [
      "self"
    ],
    "weight_inverse": [
      "self"
    ],
    "weight_inverse_and_logabsdet": [
      "self"
    ],
    "logabsdet": [
      "self"
    ]
  },
  "DEFAULT_MIN_BIN_WIDTH": [],
  "DEFAULT_MIN_BIN_HEIGHT": [],
  "DEFAULT_MIN_DERIVATIVE": [],
  "unconstrained_rational_quadratic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "unnormalized_derivatives",
    "inverse",
    "tails",
    "tail_bound",
    "min_bin_width",
    "min_bin_height",
    "min_derivative"
  ],
  "rational_quadratic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "unnormalized_derivatives",
    "inverse",
    "left",
    "right",
    "bottom",
    "top",
    "min_bin_width",
    "min_bin_height",
    "min_derivative"
  ],
  "apply_spline_at_mask": [
    "func"
  ],
  "DEFAULT_EPS": [],
  "DEFAULT_QUADRATIC_THRESHOLD": [],
  "unconstrained_cubic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "unnorm_derivatives_left",
    "unnorm_derivatives_right",
    "inverse",
    "tail_bound",
    "tails",
    "min_bin_width",
    "min_bin_height",
    "eps",
    "quadratic_threshold"
  ],
  "cubic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "unnorm_derivatives_left",
    "unnorm_derivatives_right",
    "inverse",
    "left",
    "right",
    "bottom",
    "top",
    "min_bin_width",
    "min_bin_height",
    "eps",
    "quadratic_threshold"
  ],
  "unconstrained_quadratic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "inverse",
    "tail_bound",
    "tails",
    "min_bin_width",
    "min_bin_height"
  ],
  "quadratic_spline": [
    "inputs",
    "unnormalized_widths",
    "unnormalized_heights",
    "inverse",
    "left",
    "right",
    "bottom",
    "top",
    "min_bin_width",
    "min_bin_height"
  ],
  "unconstrained_linear_spline": [
    "inputs",
    "unnormalized_pdf",
    "inverse",
    "tail_bound",
    "tails"
  ],
  "linear_spline": [
    "inputs",
    "unnormalized_pdf",
    "inverse",
    "left",
    "right",
    "bottom",
    "top"
  ],
  "UMNNCouplingTransform": {
    "__init__": [
      "self",
      "mask",
      "transform_net_create_fn",
      "integrand_net_layers",
      "cond_size",
      "nb_steps",
      "solver",
      "apply_unconditional_transform"
    ],
    "_transform_dim_multiplier": [
      "self"
    ],
    "_coupling_transform_forward": [
      "self",
      "inputs",
      "transform_params"
    ],
    "_coupling_transform_inverse": [
      "self",
      "inputs",
      "transform_params"
    ]
  },
  "MaskedUMNNAutoregressiveTransform": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "context_features",
      "num_blocks",
      "use_residual_blocks",
      "random_mask",
      "activation",
      "dropout_probability",
      "use_batch_norm",
      "integrand_net_layers",
      "cond_size",
      "nb_steps",
      "solver"
    ],
    "_output_dim_multiplier": [
      "self"
    ],
    "_elementwise_forward": [
      "self",
      "inputs",
      "autoregressive_params"
    ],
    "_elementwise_inverse": [
      "self",
      "inputs",
      "autoregressive_params"
    ]
  },
  "_flatten": [
    "sequence"
  ],
  "ELUPlus": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "IntegrandNet": {
    "__init__": [
      "self",
      "hidden",
      "cond_in"
    ],
    "forward": [
      "self",
      "x",
      "h"
    ]
  },
  "MonotonicNormalizer": {
    "__init__": [
      "self",
      "integrand_net",
      "cond_size",
      "nb_steps",
      "solver"
    ],
    "forward": [
      "self",
      "x",
      "h",
      "context"
    ],
    "inverse_transform": [
      "self",
      "z",
      "h",
      "context"
    ]
  },
  "SimpleRealNVP": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "num_layers",
      "num_blocks_per_layer",
      "use_volume_preserving",
      "activation",
      "dropout_probability",
      "batch_norm_within_layers",
      "batch_norm_between_layers"
    ]
  }
}