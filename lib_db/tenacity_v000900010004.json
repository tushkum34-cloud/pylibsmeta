{
  "MAX_WAIT": [],
  "LoggerProtocol": {
    "log": []
  },
  "find_ordinal": [
    "pos_num"
  ],
  "to_ordinal": [
    "pos_num"
  ],
  "get_callback_name": [
    "cb"
  ],
  "time_unit_type": [],
  "to_seconds": [
    "time_unit"
  ],
  "is_coroutine_callable": [
    "call"
  ],
  "wrap_to_async_func": [
    "call"
  ],
  "sleep": [
    "seconds"
  ],
  "sleep_using_event": {
    "__init__": [
      "self",
      "event"
    ],
    "__call__": [
      "self",
      "timeout"
    ]
  },
  "stop_base": {
    "__call__": [
      "self",
      "retry_state"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ]
  },
  "StopBaseT": [],
  "stop_any": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "stop_all": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "_stop_never": {
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "stop_never": [],
  "stop_when_event_set": {
    "__init__": [
      "self",
      "event"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "stop_after_attempt": {
    "__init__": [
      "self",
      "max_attempt_number"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "stop_after_delay": {
    "__init__": [
      "self",
      "max_delay"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "stop_before_delay": {
    "__init__": [
      "self",
      "max_delay"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_base": {
    "__call__": [
      "self",
      "retry_state"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ]
  },
  "WaitBaseT": [],
  "wait_fixed": {
    "__init__": [
      "self",
      "wait"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_none": {
    "__init__": [
      "self"
    ]
  },
  "wait_random": {
    "__init__": [
      "self",
      "min",
      "max"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_combine": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_chain": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_exception": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_incrementing": {
    "__init__": [
      "self",
      "start",
      "increment",
      "max"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_exponential": {
    "__init__": [
      "self",
      "multiplier",
      "max",
      "exp_base",
      "min"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_random_exponential": {
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "wait_exponential_jitter": {
    "__init__": [
      "self",
      "initial",
      "max",
      "exp_base",
      "jitter"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "before_nothing": [
    "retry_state"
  ],
  "before_log": [
    "logger",
    "log_level"
  ],
  "after_nothing": [
    "retry_state"
  ],
  "after_log": [
    "logger",
    "log_level",
    "sec_format"
  ],
  "WrappedFnReturnT": [],
  "WrappedFn": [],
  "P": [],
  "R": [],
  "IterState": {
    "reset": [
      "self"
    ]
  },
  "TryAgain": {},
  "NO_RESULT": [],
  "DoAttempt": {},
  "DoSleep": {},
  "BaseAction": {
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "RetryAction": {
    "REPR_FIELDS": [],
    "NAME": [],
    "__init__": [
      "self",
      "sleep"
    ]
  },
  "_unset": [],
  "_first_set": [
    "first",
    "second"
  ],
  "RetryError": {
    "__init__": [
      "self",
      "last_attempt"
    ],
    "reraise": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "AttemptManager": {
    "__init__": [
      "self",
      "retry_state"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "traceback"
    ]
  },
  "BaseRetrying": {
    "__init__": [
      "self",
      "sleep",
      "stop",
      "wait",
      "retry",
      "before",
      "after",
      "before_sleep",
      "reraise",
      "retry_error_cls",
      "retry_error_callback"
    ],
    "copy": [
      "self",
      "sleep",
      "stop",
      "wait",
      "retry",
      "before",
      "after",
      "before_sleep",
      "reraise",
      "retry_error_cls",
      "retry_error_callback"
    ],
    "__repr__": [
      "self"
    ],
    "statistics": [
      "self"
    ],
    "iter_state": [
      "self"
    ],
    "wraps": [
      "self",
      "f"
    ],
    "begin": [
      "self"
    ],
    "_add_action_func": [
      "self",
      "fn"
    ],
    "_run_retry": [
      "self",
      "retry_state"
    ],
    "_run_wait": [
      "self",
      "retry_state"
    ],
    "_run_stop": [
      "self",
      "retry_state"
    ],
    "iter": [
      "self",
      "retry_state"
    ],
    "_begin_iter": [
      "self",
      "retry_state"
    ],
    "_post_retry_check_actions": [
      "self",
      "retry_state"
    ],
    "_post_stop_check_actions": [
      "self",
      "retry_state"
    ],
    "__iter__": [
      "self"
    ],
    "__call__": [
      "self",
      "fn"
    ]
  },
  "Retrying": {
    "__call__": [
      "self",
      "fn"
    ]
  },
  "Future": {
    "__init__": [
      "self",
      "attempt_number"
    ],
    "failed": [
      "self"
    ],
    "construct": [
      "cls",
      "attempt_number",
      "value",
      "has_exception"
    ]
  },
  "RetryCallState": {
    "__init__": [
      "self",
      "retry_object",
      "fn",
      "args",
      "kwargs"
    ],
    "seconds_since_start": [
      "self"
    ],
    "prepare_for_next_attempt": [
      "self"
    ],
    "set_result": [
      "self",
      "val"
    ],
    "set_exception": [
      "self",
      "exc_info"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_AsyncRetryDecorator": {
    "__call__": [
      "self",
      "fn"
    ]
  },
  "retry": [],
  "__all__": [],
  "_RetValT": [],
  "TornadoRetrying": {
    "__init__": [
      "self",
      "sleep"
    ],
    "__call__": [
      "self",
      "fn"
    ]
  },
  "retry_base": {
    "__call__": [
      "self",
      "retry_state"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__rand__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ]
  },
  "RetryBaseT": [],
  "_retry_never": {
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_never": [],
  "_retry_always": {
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_always": [],
  "retry_if_exception": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_if_exception_type": {
    "__init__": [
      "self",
      "exception_types"
    ]
  },
  "retry_if_not_exception_type": {
    "__init__": [
      "self",
      "exception_types"
    ]
  },
  "retry_unless_exception_type": {
    "__init__": [
      "self",
      "exception_types"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_if_exception_cause_type": {
    "__init__": [
      "self",
      "exception_types"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_if_result": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_if_not_result": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_if_exception_message": {
    "__init__": [
      "self",
      "message",
      "match"
    ]
  },
  "retry_if_not_exception_message": {
    "__init__": [
      "self",
      "message",
      "match"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_any": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "retry_all": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "retry_state"
    ]
  },
  "before_sleep_nothing": [
    "retry_state"
  ],
  "before_sleep_log": [
    "logger",
    "log_level",
    "exc_info",
    "sec_format"
  ],
  "_portable_async_sleep": [
    "seconds"
  ],
  "AsyncRetrying": {
    "__init__": [
      "self",
      "sleep",
      "stop",
      "wait",
      "retry",
      "before",
      "after",
      "before_sleep",
      "reraise",
      "retry_error_cls",
      "retry_error_callback"
    ],
    "__call__": [
      "self",
      "fn"
    ],
    "_add_action_func": [
      "self",
      "fn"
    ],
    "_run_retry": [
      "self",
      "retry_state"
    ],
    "_run_wait": [
      "self",
      "retry_state"
    ],
    "_run_stop": [
      "self",
      "retry_state"
    ],
    "iter": [
      "self",
      "retry_state"
    ],
    "__iter__": [
      "self"
    ],
    "__aiter__": [
      "self"
    ],
    "__anext__": [
      "self"
    ],
    "wraps": [
      "self",
      "fn"
    ]
  },
  "async_retry_base": {
    "__call__": [
      "self",
      "retry_state"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__rand__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ]
  }
}