{
  "Xdawn": {
    "__init__": [
      "self",
      "nfilter",
      "classes",
      "estimator",
      "baseline_cov"
    ],
    "estimator_fn": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "BilinearFilter": {
    "__init__": [
      "self",
      "filters",
      "log"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "CSP": {
    "__init__": [
      "self",
      "nfilter",
      "metric",
      "log",
      "ajd_method"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "SPoC": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "AJDC": {
    "__init__": [
      "self",
      "window",
      "overlap",
      "fmin",
      "fmax",
      "fs",
      "dim_red",
      "verbose"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X",
      "supp"
    ],
    "get_src_expl_var": [
      "self",
      "X"
    ]
  },
  "ElectrodeSelection": {
    "__init__": [
      "self",
      "nelec",
      "metric",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "FlatChannelRemover": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "SpectralEmbedding": {
    "__init__": [
      "self",
      "n_components",
      "metric",
      "eps"
    ],
    "_get_affinity_matrix": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "LocallyLinearEmbedding": {
    "__init__": [
      "self",
      "n_components",
      "n_neighbors",
      "metric",
      "kernel",
      "reg"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TSNE": {
    "__init__": [
      "self",
      "n_components",
      "perplexity",
      "metric",
      "max_iter",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "barycenter_weights": [
    "X",
    "Y",
    "indices",
    "metric",
    "kernel",
    "reg"
  ],
  "locally_linear_embedding": [
    "X"
  ],
  "_compute_condprob_gaussian": [
    "X",
    "metric",
    "perplexity"
  ],
  "_compute_jointprob_student": [
    "X",
    "metric"
  ],
  "_check_dimensions": [
    "X",
    "Y",
    "n_components",
    "n_neighbors"
  ],
  "multiset_perm_number": [
    "y"
  ],
  "unique_permutations": [
    "elements"
  ],
  "BasePermutation": {
    "test": [
      "self",
      "X",
      "y",
      "groups",
      "verbose"
    ],
    "_print_progress": [
      "self",
      "ii"
    ],
    "_initial_transform": [
      "self",
      "X"
    ],
    "_shuffle": [
      "self",
      "y",
      "groups",
      "rs"
    ],
    "plot": [
      "self",
      "nbins",
      "range",
      "axes"
    ]
  },
  "PermutationModel": {
    "__init__": [
      "self",
      "n_perms",
      "model",
      "cv",
      "scoring",
      "n_jobs",
      "random_state"
    ],
    "score": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "PermutationDistance": {
    "__init__": [
      "self",
      "n_perms",
      "metric",
      "mode",
      "n_jobs",
      "random_state",
      "estimator"
    ],
    "score": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_initial_transform": [
      "self",
      "X"
    ],
    "__init_transform": [
      "self",
      "X"
    ],
    "_score_ftest": [
      "self",
      "X",
      "y"
    ],
    "_score_ttest": [
      "self",
      "X",
      "y"
    ],
    "_score_pairwise": [
      "self",
      "X",
      "y"
    ]
  },
  "SpdTransfMixin": {
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "SpdClassifMixin": {
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "SpdClustMixin": {
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "TangentSpace": {
    "__init__": [
      "self",
      "metric",
      "tsupdate"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_check_data_dim": [
      "self",
      "X"
    ],
    "_check_reference_points": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "FGDA": {
    "__init__": [
      "self",
      "metric",
      "tsupdate"
    ],
    "_fit_lda": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_retro_project": [
      "self",
      "ts"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "__all__": [],
  "_mode_1d": [
    "X"
  ],
  "_mode_2d": [
    "X",
    "axis"
  ],
  "MDM": {
    "__init__": [
      "self",
      "metric",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_predict_distances": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "FgMDM": {
    "__init__": [
      "self",
      "metric",
      "tsupdate",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "TSClassifier": {
    "__init__": [
      "self",
      "metric",
      "tsupdate",
      "clf"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "KNearestNeighbor": {
    "__init__": [
      "self",
      "n_neighbors",
      "metric",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "SVC": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_set_cref": [
      "self",
      "X"
    ],
    "_set_kernel": [
      "self"
    ]
  },
  "MeanField": {
    "__init__": [
      "self",
      "power_list",
      "method_label",
      "method_combination",
      "metric",
      "n_jobs"
    ],
    "_deprecate_method_label": [
      "self",
      "method_label",
      "method_combination"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_compute_distances": [
      "self",
      "X"
    ],
    "_predict_distances": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "NearestConvexHull": {
    "__init__": [
      "self",
      "metric",
      "n_jobs",
      "method"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_predict_distances": [
      "self",
      "X"
    ],
    "_predict_distance": [
      "self",
      "A",
      "B"
    ],
    "_find_weights_to_convex_hull": [
      "self",
      "D1",
      "d2"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "class_distinctiveness": [
    "X",
    "y",
    "exponent",
    "metric",
    "return_num_denom"
  ],
  "_get_within": [
    "X",
    "y",
    "means",
    "classes",
    "exponent",
    "metric"
  ],
  "_init_centroids": [
    "X",
    "n_clusters",
    "init",
    "random_state",
    "x_squared_norms"
  ],
  "_fit_single": [
    "X",
    "y",
    "n_clusters",
    "init",
    "random_state",
    "metric",
    "max_iter",
    "tol",
    "n_jobs"
  ],
  "Kmeans": {
    "__init__": [
      "self",
      "n_clusters",
      "max_iter",
      "metric",
      "random_state",
      "init",
      "n_init",
      "n_jobs",
      "tol"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "centroids": [
      "self"
    ]
  },
  "KmeansPerClassTransform": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "kernel_normal": [
    "x"
  ],
  "kernel_uniform": [
    "x"
  ],
  "ker_clust_functions": [],
  "MeanShift": {
    "__init__": [
      "self",
      "kernel",
      "bandwidth",
      "metric",
      "tol",
      "max_iter",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_estimate_bandwidth": [
      "self",
      "X",
      "quantile"
    ],
    "_seek_mode": [
      "self",
      "X",
      "mean"
    ],
    "_fuse_mode": [
      "self",
      "in_modes"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "Potato": {
    "__init__": [
      "self",
      "metric",
      "threshold",
      "n_iter_max",
      "pos_label",
      "neg_label"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_check_labels": [
      "self",
      "X",
      "y"
    ],
    "_get_z_score": [
      "self",
      "d"
    ],
    "_get_proba": [
      "self",
      "z"
    ]
  },
  "_check_n_matrices": [
    "X",
    "n_matrices"
  ],
  "PotatoField": {
    "__init__": [
      "self",
      "n_potatoes",
      "p_threshold",
      "z_threshold",
      "metric",
      "n_iter_max",
      "pos_label",
      "neg_label"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_check_length": [
      "self",
      "X"
    ],
    "_get_proba": [
      "self",
      "q"
    ]
  },
  "SVR": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_set_cref": [
      "self",
      "X"
    ],
    "_set_kernel": [
      "self"
    ]
  },
  "KNearestNeighborRegressor": {
    "__init__": [
      "self",
      "n_neighbors",
      "metric"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "Whitening": {
    "__init__": [
      "self",
      "metric",
      "dim_red",
      "verbose"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_get_eig": [
      "self"
    ],
    "_get_n_components": [
      "self",
      "X"
    ],
    "_reduce_and_whiten": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "_nextpow2": [
    "i"
  ],
  "Covariances": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ERPCovariances": {
    "__init__": [
      "self",
      "classes",
      "estimator",
      "svd"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "XdawnCovariances": {
    "__init__": [
      "self",
      "nfilter",
      "applyfilters",
      "classes",
      "estimator",
      "xdawn_estimator",
      "baseline_cov"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "BlockCovariances": {
    "__init__": [
      "self",
      "block_size",
      "estimator"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_check_block_size": [
      "block_size",
      "n_channels"
    ]
  },
  "CrossSpectra": {
    "__init__": [
      "self",
      "window",
      "overlap",
      "fmin",
      "fmax",
      "fs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "CoSpectra": {
    "transform": [
      "self",
      "X"
    ]
  },
  "Coherences": {
    "__init__": [
      "self",
      "window",
      "overlap",
      "fmin",
      "fmax",
      "fs",
      "coh"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "TimeDelayCovariances": {
    "__init__": [
      "self",
      "delays",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ker_est_functions": [],
  "Kernels": {
    "__init__": [
      "self",
      "metric",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "Shrinkage": {
    "__init__": [
      "self",
      "shrinkage"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "__version__": [],
  "_pdf_r": [
    "r",
    "sigma"
  ],
  "_rejection_sampling_2D_gfunction_plus": [
    "sigma",
    "r_sample"
  ],
  "_rejection_sampling_2D_gfunction_minus": [
    "sigma",
    "r_sample"
  ],
  "_rejection_sampling_2D": [
    "n_samples",
    "sigma",
    "random_state",
    "return_acceptance_rate"
  ],
  "_slice_one_sample": [
    "ptarget",
    "x0",
    "w",
    "rs"
  ],
  "_slice_sampling": [
    "ptarget",
    "n_samples",
    "x0",
    "n_burnin",
    "thin",
    "random_state",
    "n_jobs"
  ],
  "_sample_parameter_r": [
    "n_samples",
    "n_dim",
    "sigma",
    "random_state",
    "n_jobs",
    "sampling_method"
  ],
  "_sample_parameter_U": [
    "n_samples",
    "n_dim",
    "random_state"
  ],
  "_sample_gaussian_spd_centered": [
    "n_matrices",
    "n_dim",
    "sigma",
    "random_state",
    "n_jobs",
    "sampling_method"
  ],
  "sample_gaussian_spd": [
    "n_matrices",
    "mean",
    "sigma",
    "random_state",
    "n_jobs",
    "sampling_method"
  ],
  "RandomOverSampler": {
    "__init__": [
      "self",
      "metric",
      "sampling_strategy",
      "random_state",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_resample": [
      "self",
      "X",
      "y"
    ],
    "_check_sampling_strategy": [
      "self",
      "y"
    ],
    "_resample": [
      "self",
      "X",
      "y",
      "n_mats"
    ]
  },
  "_make_eyes": [
    "n_matrices",
    "n_dim"
  ],
  "mat_kinds": [],
  "make_matrices": [
    "n_matrices",
    "n_dim",
    "kind",
    "rs",
    "return_params",
    "evals_low",
    "evals_high",
    "eigvecs_same",
    "eigvecs_mean",
    "eigvecs_std"
  ],
  "make_masks": [
    "n_masks",
    "n_dim0",
    "n_dim1_min",
    "rs"
  ],
  "make_gaussian_blobs": [
    "n_matrices",
    "n_dim",
    "class_sep",
    "class_disp",
    "return_centers",
    "center_dataset",
    "random_state",
    "centers"
  ],
  "make_outliers": [
    "n_matrices",
    "mean",
    "sigma",
    "outlier_coeff",
    "random_state"
  ],
  "make_classification_transfer": [
    "n_matrices",
    "class_sep",
    "class_disp",
    "domain_sep",
    "theta",
    "stretch",
    "random_state",
    "class_names",
    "domain_names"
  ],
  "deprecated": {
    "__init__": [
      "self",
      "extra"
    ],
    "__call__": [
      "self",
      "obj"
    ],
    "_decorate_class": [
      "self",
      "cls"
    ],
    "_decorate_fun": [
      "self",
      "fun"
    ],
    "_update_doc": [
      "self",
      "olddoc"
    ]
  },
  "_complex_estimator": [
    "func"
  ],
  "_lwf": [
    "X"
  ],
  "_mcd": [
    "X"
  ],
  "_oas": [
    "X"
  ],
  "_hub": [
    "X"
  ],
  "_stu": [
    "X"
  ],
  "_tyl": [
    "X"
  ],
  "covariance_mest": [
    "X",
    "m_estimator"
  ],
  "covariance_sch": [
    "X"
  ],
  "covariance_scm": [
    "X"
  ],
  "cov_est_functions": [],
  "covariances": [
    "X",
    "estimator"
  ],
  "covariances_EP": [
    "X",
    "P",
    "estimator"
  ],
  "covariances_X": [
    "X",
    "estimator",
    "alpha"
  ],
  "block_covariances": [
    "X",
    "blocks",
    "estimator"
  ],
  "eegtocov": [
    "sig",
    "window",
    "overlapp",
    "padding",
    "estimator"
  ],
  "cross_spectrum": [
    "X",
    "window",
    "overlap",
    "fmin",
    "fmax",
    "fs"
  ],
  "cospectrum": [
    "X",
    "window",
    "overlap",
    "fmin",
    "fmax",
    "fs"
  ],
  "coherence": [
    "X",
    "window",
    "overlap",
    "fmin",
    "fmax",
    "fs",
    "coh"
  ],
  "normalize": [
    "X",
    "norm"
  ],
  "get_nondiag_weight": [
    "X"
  ],
  "_get_eigenvals": [
    "X"
  ],
  "is_square": [
    "X"
  ],
  "is_sym": [
    "X"
  ],
  "is_skew_sym": [
    "X"
  ],
  "is_hankel": [
    "X"
  ],
  "is_real": [
    "X"
  ],
  "is_real_type": [
    "X"
  ],
  "is_hermitian": [
    "X"
  ],
  "is_pos_def": [
    "X",
    "tol",
    "fast_mode"
  ],
  "is_pos_semi_def": [
    "X"
  ],
  "is_sym_pos_def": [
    "X",
    "tol"
  ],
  "is_sym_pos_semi_def": [
    "X"
  ],
  "is_herm_pos_def": [
    "X",
    "tol"
  ],
  "is_herm_pos_semi_def": [
    "X"
  ],
  "kernel_euclid": [
    "X",
    "Y"
  ],
  "kernel_logeuclid": [
    "X",
    "Y"
  ],
  "kernel_riemann": [
    "X",
    "Y"
  ],
  "_check_xy": [
    "X",
    "Y"
  ],
  "_check_cref": [
    "X",
    "Cref"
  ],
  "_apply_matrix_kernel": [
    "Xt",
    "Y",
    "are_xy_equal",
    "reg"
  ],
  "kernel_functions": [],
  "kernel": [
    "X",
    "Y"
  ],
  "ctranspose": [
    "X"
  ],
  "_recursive": [
    "fun",
    "A",
    "B"
  ],
  "_matrix_operator": [
    "X",
    "operator"
  ],
  "expm": [
    "C"
  ],
  "invsqrtm": [
    "C"
  ],
  "logm": [
    "C"
  ],
  "powm": [
    "C",
    "alpha"
  ],
  "sqrtm": [
    "C"
  ],
  "_nearest_sym_pos_def": [
    "S",
    "reg"
  ],
  "nearest_sym_pos_def": [
    "X",
    "reg"
  ],
  "_first_divided_difference": [
    "d",
    "fct",
    "fctder",
    "atol",
    "rtol"
  ],
  "ddexpm": [
    "X",
    "Cref"
  ],
  "ddlogm": [
    "X",
    "Cref"
  ],
  "rjd": [
    "X"
  ],
  "ajd_pham": [
    "X"
  ],
  "uwedge": [
    "X"
  ],
  "ajd_functions": [],
  "ajd": [
    "X",
    "method",
    "init",
    "eps",
    "n_iter_max"
  ],
  "_check_inputs": [
    "A",
    "B"
  ],
  "distance_chol": [
    "A",
    "B",
    "squared"
  ],
  "distance_euclid": [
    "A",
    "B",
    "squared"
  ],
  "distance_harmonic": [
    "A",
    "B",
    "squared"
  ],
  "distance_kullback": [
    "A",
    "B",
    "squared"
  ],
  "distance_kullback_right": [
    "A",
    "B",
    "squared"
  ],
  "distance_kullback_sym": [
    "A",
    "B",
    "squared"
  ],
  "distance_logchol": [
    "A",
    "B",
    "squared"
  ],
  "distance_logdet": [
    "A",
    "B",
    "squared"
  ],
  "distance_logeuclid": [
    "A",
    "B",
    "squared"
  ],
  "distance_poweuclid": [
    "A",
    "B",
    "p",
    "squared"
  ],
  "distance_riemann": [
    "A",
    "B",
    "squared"
  ],
  "distance_thompson": [
    "A",
    "B",
    "squared"
  ],
  "distance_wasserstein": [
    "A",
    "B",
    "squared"
  ],
  "distance_functions": [],
  "distance": [
    "A",
    "B",
    "metric",
    "squared"
  ],
  "_euclidean_distances": [
    "X",
    "Y",
    "squared"
  ],
  "_pairwise_distance_euclid": [
    "X",
    "Y",
    "squared"
  ],
  "_pairwise_distance_harmonic": [
    "X",
    "Y",
    "squared"
  ],
  "_pairwise_distance_logchol": [
    "X",
    "Y",
    "squared"
  ],
  "_pairwise_distance_logeuclid": [
    "X",
    "Y",
    "squared"
  ],
  "_pairwise_distance_riemann": [
    "X",
    "Y",
    "squared"
  ],
  "pairwise_distance": [
    "X",
    "Y",
    "metric",
    "squared"
  ],
  "distance_mahalanobis": [
    "X",
    "cov",
    "mean",
    "squared"
  ],
  "check_weights": [
    "weights",
    "n_weights"
  ],
  "check_metric": [
    "metric",
    "expected_keys"
  ],
  "check_function": [
    "fun",
    "functions"
  ],
  "check_init": [
    "init",
    "n"
  ],
  "mean_ale": [
    "X"
  ],
  "mean_alm": [
    "X"
  ],
  "mean_chol": [
    "X",
    "sample_weight"
  ],
  "mean_euclid": [
    "X",
    "sample_weight"
  ],
  "mean_harmonic": [
    "X",
    "sample_weight"
  ],
  "mean_identity": [
    "X",
    "sample_weight"
  ],
  "mean_kullback_sym": [
    "X",
    "sample_weight"
  ],
  "mean_logchol": [
    "X",
    "sample_weight"
  ],
  "mean_logdet": [
    "X"
  ],
  "mean_logeuclid": [
    "X",
    "sample_weight"
  ],
  "mean_power": [
    "X",
    "p"
  ],
  "mean_poweuclid": [
    "X",
    "p"
  ],
  "mean_riemann": [
    "X"
  ],
  "mean_thompson": [
    "X"
  ],
  "mean_wasserstein": [
    "X",
    "tol",
    "maxiter",
    "init",
    "sample_weight"
  ],
  "mean_functions": [],
  "mean_covariance": [
    "X"
  ],
  "_get_mask_from_nan": [
    "X"
  ],
  "_get_masks_from_nan": [
    "X"
  ],
  "_apply_masks": [
    "X",
    "masks"
  ],
  "maskedmean_riemann": [
    "X",
    "masks"
  ],
  "nanmean_riemann": [
    "X",
    "tol",
    "maxiter",
    "init",
    "sample_weight"
  ],
  "exp_map_euclid": [
    "X",
    "Cref"
  ],
  "exp_map_logchol": [
    "X",
    "Cref"
  ],
  "exp_map_logeuclid": [
    "X",
    "Cref"
  ],
  "exp_map_riemann": [
    "X",
    "Cref",
    "Cm12"
  ],
  "exp_map_wasserstein": [
    "X",
    "Cref"
  ],
  "exp_map_functions": [],
  "exp_map": [
    "X",
    "Cref"
  ],
  "log_map_euclid": [
    "X",
    "Cref"
  ],
  "log_map_logchol": [
    "X",
    "Cref"
  ],
  "log_map_logeuclid": [
    "X",
    "Cref"
  ],
  "log_map_riemann": [
    "X",
    "Cref",
    "C12"
  ],
  "log_map_wasserstein": [
    "X",
    "Cref"
  ],
  "log_map_functions": [],
  "log_map": [
    "X",
    "Cref"
  ],
  "upper": [
    "X"
  ],
  "unupper": [
    "T"
  ],
  "tangent_space": [
    "X",
    "Cref"
  ],
  "untangent_space": [
    "T",
    "Cref"
  ],
  "transport_euclid": [
    "X",
    "A",
    "B"
  ],
  "transport_logchol": [
    "X",
    "A",
    "B"
  ],
  "transport_logeuclid": [
    "X",
    "A",
    "B"
  ],
  "transport_riemann": [
    "X",
    "A",
    "B"
  ],
  "transport_functions": [],
  "transport": [
    "X",
    "A",
    "B",
    "metric"
  ],
  "median_euclid": [
    "X"
  ],
  "median_riemann": [
    "X"
  ],
  "logger": [],
  "geodesic_chol": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_euclid": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_logchol": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_logeuclid": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_riemann": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_thompson": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_wasserstein": [
    "A",
    "B",
    "alpha"
  ],
  "geodesic_functions": [],
  "geodesic": [
    "A",
    "B",
    "alpha",
    "metric"
  ],
  "plot_embedding": [
    "X",
    "y"
  ],
  "plot_cospectra": [
    "X",
    "freqs"
  ],
  "plot_waveforms": [
    "X",
    "display"
  ],
  "_add_alpha": [
    "colors",
    "alphas"
  ],
  "plot_cov_ellipse": [
    "ax",
    "X",
    "n_std"
  ],
  "plot_bihist": [
    "X",
    "y",
    "n_bins",
    "title"
  ],
  "plot_biscatter": [
    "X",
    "y"
  ],
  "TLDummy": {
    "fit": [
      "self",
      "X",
      "y_enc"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y_enc"
    ]
  },
  "TLCenter": {
    "__init__": [
      "self",
      "target_domain",
      "metric"
    ],
    "fit": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ]
  },
  "TLScale": {
    "__init__": [
      "self",
      "target_domain",
      "final_dispersion",
      "centered_data",
      "metric"
    ],
    "fit": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ],
    "_center": [
      "self",
      "X",
      "mean"
    ],
    "_uncenter": [
      "self",
      "X",
      "mean"
    ],
    "_strech": [
      "self",
      "X",
      "dispersion_in",
      "dispersion_out"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ]
  },
  "TLRotate": {
    "__init__": [
      "self",
      "target_domain",
      "weights",
      "metric",
      "n_jobs",
      "expl_var",
      "n_components",
      "n_clusters",
      "tol_step",
      "maxiter"
    ],
    "fit": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ],
    "_fit_manifold": [
      "self",
      "X",
      "y_enc",
      "domains",
      "sample_weight"
    ],
    "_fit_tangentspace": [
      "self",
      "X",
      "y_enc",
      "domains",
      "sample_weight"
    ],
    "_get_anchors": [
      "self",
      "X",
      "y",
      "sample_weight",
      "fit_pca"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ]
  },
  "TLEstimator": {
    "__init__": [
      "self",
      "target_domain",
      "estimator",
      "domain_weight"
    ],
    "fit": [
      "self",
      "X",
      "y_enc"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "TLClassifier": {
    "fit": [
      "self",
      "X",
      "y_enc"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y_enc"
    ]
  },
  "TLRegressor": {
    "fit": [
      "self",
      "X",
      "y_enc"
    ],
    "score": [
      "self",
      "X",
      "y_enc"
    ]
  },
  "MDWM": {
    "__init__": [
      "self",
      "domain_tradeoff",
      "target_domain",
      "metric",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ],
    "score": [
      "self",
      "X",
      "y_enc",
      "sample_weight"
    ]
  },
  "encode_domains": [
    "X",
    "y",
    "domain"
  ],
  "decode_domains": [
    "X_enc",
    "y_enc"
  ],
  "TLSplitter": {
    "__init__": [
      "self",
      "target_domain",
      "cv"
    ],
    "split": [
      "self",
      "X",
      "y"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y"
    ]
  },
  "_project": [
    "X",
    "U"
  ],
  "_retract": [
    "X",
    "v"
  ],
  "_loss": [
    "Q",
    "X",
    "Y",
    "weights",
    "metric"
  ],
  "_grad": [
    "Q",
    "X",
    "Y",
    "weights",
    "metric"
  ],
  "_warm_start": [
    "X",
    "Y",
    "weights",
    "metric"
  ],
  "_run_minimization": [
    "Q_ini",
    "X_source",
    "X_target",
    "weights",
    "metric",
    "tol_step",
    "maxiter",
    "maxiter_linesearch"
  ],
  "_get_rotation_manifold": [
    "X_source",
    "X_target",
    "weights",
    "metric",
    "tol_step",
    "maxiter",
    "maxiter_linesearch"
  ],
  "_get_rotation_tangentspace": [
    "X_source",
    "X_target",
    "expl_var"
  ],
  "_symmetrize": [
    "X"
  ],
  "_retraction": [
    "point",
    "tangent_vector",
    "metric"
  ],
  "_norm": [
    "point",
    "tangent_vector",
    "metric"
  ],
  "_riemannian_gradient": [
    "Y",
    "P",
    "Q",
    "Dsq",
    "metric"
  ],
  "_get_initial_solution": [
    "n_matrices",
    "n_components",
    "random_state"
  ],
  "_get_tsne_embedding": [
    "P",
    "n_components",
    "metric",
    "max_iter",
    "random_state",
    "compute_low_affinities"
  ]
}