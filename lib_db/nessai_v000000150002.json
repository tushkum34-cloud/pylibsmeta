{
  "logger": [],
  "logsubexp": [
    "x",
    "y"
  ],
  "log_integrate_log_trap": [
    "log_func",
    "log_support"
  ],
  "_BaseNSIntegralState": {
    "log_evidence": [
      "self"
    ],
    "log_evidence_error": [
      "self"
    ],
    "log_posterior_weights": [
      "self"
    ],
    "effective_n_posterior_samples": [
      "self"
    ],
    "ess": []
  },
  "_NSIntegralState": {
    "__init__": [
      "self",
      "nlive",
      "track_gradients",
      "expectation"
    ],
    "log_evidence": [
      "self"
    ],
    "log_evidence_error": [
      "self"
    ],
    "increment": [
      "self",
      "logL",
      "nlive"
    ],
    "get_logx_live_points": [
      "self",
      "nlive"
    ],
    "finalise": [
      "self"
    ],
    "plot": [
      "self",
      "filename"
    ],
    "log_posterior_weights": [
      "self"
    ]
  },
  "_INSIntegralState": {
    "__init__": [
      "self"
    ],
    "logZ": [
      "self"
    ],
    "log_evidence": [],
    "log_evidence_error": [
      "self"
    ],
    "evidence": [
      "self"
    ],
    "evidence_error": [
      "self"
    ],
    "log_evidence_live_points": [
      "self"
    ],
    "log_evidence_nested_samples": [
      "self"
    ],
    "fractional_error": [
      "self"
    ],
    "difference_log_evidence": [
      "self"
    ],
    "log_posterior_weights": [
      "self"
    ],
    "log_evidence_ratio": [
      "self"
    ],
    "log_evidence_ratio_nested_samples": [
      "self"
    ],
    "update_evidence": [
      "self",
      "nested_samples",
      "live_points"
    ],
    "compute_log_evidence_ratio": [
      "self",
      "ns_only"
    ],
    "compute_evidence_ratio": [
      "self",
      "ns_only"
    ],
    "compute_uncertainty": [
      "self",
      "log_evidence"
    ]
  },
  "log_evidence_from_ins_samples": [
    "samples"
  ],
  "msg": [],
  "_rcparams": [],
  "nessai_style": [
    "line_styles"
  ],
  "sanitise_array": [
    "a_min",
    "a_max"
  ],
  "plot_live_points": [
    "live_points",
    "filename",
    "bounds",
    "c"
  ],
  "plot_1d_comparison": [],
  "plot_indices": [
    "indices",
    "nlive",
    "filename",
    "ks_test_mode",
    "confidence_intervals",
    "plot_breakdown",
    "n_breakdown",
    "cmap"
  ],
  "plot_loss": [
    "epoch",
    "history",
    "filename"
  ],
  "plot_trace": [
    "log_x",
    "nested_samples",
    "parameters",
    "live_points",
    "log_x_live_points",
    "labels",
    "filename"
  ],
  "plot_histogram": [
    "samples",
    "label",
    "filename"
  ],
  "corner_plot": [
    "array",
    "include",
    "exclude",
    "labels",
    "truths",
    "filename"
  ],
  "COMPARISON_OPERATORS": [],
  "StoppingCriterionRegistry": {
    "_registry": [],
    "register": [
      "cls"
    ],
    "get": [
      "cls",
      "name"
    ],
    "list_available": [
      "cls"
    ]
  },
  "StoppingCriterion": {
    "__post_init__": [
      "self"
    ],
    "is_met": [
      "self",
      "value"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ]
  },
  "CriterionGroup": {
    "is_met": [
      "self",
      "values"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "names": [
      "self"
    ],
    "tolerances": [
      "self"
    ]
  },
  "ESS": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "LogEvidenceRatio": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "LogEvidenceRatioNestedSamples": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "EvidenceError": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "DifferenceLogEvidence": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "FractionalError": {
    "__init__": [
      "self",
      "tolerance"
    ]
  },
  "compute_weights": [
    "samples",
    "nlive",
    "expectation"
  ],
  "draw_posterior_samples": [
    "nested_samples",
    "nlive",
    "n",
    "log_w",
    "method",
    "return_indices",
    "expectation",
    "rng"
  ],
  "FlowSampler": {
    "__init__": [
      "self",
      "model",
      "output",
      "importance_nested_sampler",
      "resume",
      "resume_file",
      "resume_data",
      "weights_file",
      "weights_path",
      "signal_handling",
      "exit_code",
      "pytorch_threads",
      "close_pool",
      "eps",
      "torch_dtype",
      "disable_vectorisation",
      "likelihood_chunksize",
      "allow_multi_valued_likelihood",
      "parallelise_prior",
      "result_extension"
    ],
    "check_resume": [
      "self",
      "resume_file",
      "resume_data"
    ],
    "_resume_from_file": [
      "self",
      "SamplerClass",
      "resume_file",
      "model",
      "weights_path",
      "flow_config"
    ],
    "_resume_from_data": [
      "self",
      "SamplerClass",
      "resume_data",
      "model",
      "weights_path",
      "flow_config"
    ],
    "log_evidence": [
      "self"
    ],
    "log_evidence_error": [
      "self"
    ],
    "nested_samples": [
      "self"
    ],
    "rng": [
      "self"
    ],
    "run": [
      "self",
      "plot",
      "save",
      "posterior_sampling_method",
      "close_pool"
    ],
    "run_standard_sampler": [
      "self",
      "plot",
      "plot_indices",
      "plot_posterior",
      "plot_logXlogL",
      "save",
      "posterior_sampling_method",
      "close_pool"
    ],
    "run_importance_nested_sampler": [
      "self",
      "plot",
      "plot_posterior",
      "save",
      "posterior_sampling_method",
      "redraw_samples",
      "n_posterior_samples",
      "compute_initial_posterior",
      "close_pool"
    ],
    "save_kwargs": [
      "self",
      "kwargs"
    ],
    "save_results": [
      "self",
      "filename",
      "extension"
    ],
    "terminate_run": [
      "self",
      "code"
    ],
    "safe_exit": [
      "self",
      "signum",
      "frame"
    ]
  },
  "ModelError": {},
  "OneDimensionalModelError": {},
  "Model": {
    "_names": [],
    "_bounds": [],
    "_dtype": [],
    "reparameterisations": [],
    "likelihood_evaluations": [],
    "likelihood_evaluation_time": [],
    "_lower": [],
    "_upper": [],
    "pool": [],
    "allow_vectorised_prior": [],
    "allow_vectorised": [],
    "likelihood_chunksize": [],
    "allow_multi_valued_likelihood": [],
    "parallelise_prior": [],
    "_vectorised_likelihood": [],
    "_vectorised_prior": [],
    "_vectorised_prior_unit_hypercube": [],
    "_pool_configured": [],
    "n_pool": [],
    "_discrete_parameters": [],
    "rng": [],
    "set_rng": [
      "self",
      "rng"
    ],
    "names": [
      "self",
      "names"
    ],
    "bounds": [
      "self",
      "bounds"
    ],
    "dims": [
      "self"
    ],
    "discrete_parameters": [
      "self",
      "parameters"
    ],
    "has_discrete_parameters": [
      "self"
    ],
    "_set_upper_lower": [
      "self"
    ],
    "lower_bounds": [
      "self"
    ],
    "upper_bounds": [
      "self"
    ],
    "vectorised_likelihood": [
      "self",
      "value"
    ],
    "vectorised_prior": [
      "self",
      "value"
    ],
    "vectorised_prior_unit_hypercube": [
      "self",
      "value"
    ],
    "_view_dtype": [
      "self"
    ],
    "configure_pool": [
      "self",
      "pool",
      "n_pool"
    ],
    "close_pool": [
      "self",
      "code"
    ],
    "new_point": [
      "self",
      "N"
    ],
    "new_point_log_prob": [
      "self",
      "x"
    ],
    "_single_new_point": [
      "self"
    ],
    "_multiple_new_points": [
      "self",
      "N"
    ],
    "in_bounds": [
      "self",
      "x"
    ],
    "in_unit_hypercube": [
      "self",
      "x"
    ],
    "sample_parameter": [
      "self",
      "name",
      "n"
    ],
    "parameter_in_bounds": [
      "self",
      "x",
      "name"
    ],
    "sample_unit_hypercube": [
      "self",
      "n"
    ],
    "log_prior_unit_hypercube": [
      "self",
      "x"
    ],
    "from_unit_hypercube": [
      "self",
      "x"
    ],
    "to_unit_hypercube": [
      "self",
      "x"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "log_likelihood": [
      "self",
      "x"
    ],
    "evaluate_log_likelihood": [
      "self",
      "x"
    ],
    "batch_evaluate_log_likelihood": [
      "self",
      "x",
      "unit_hypercube"
    ],
    "batch_evaluate_log_prior": [
      "self",
      "x",
      "unit_hypercube"
    ],
    "batch_evaluate_log_prior_unit_hypercube": [
      "self",
      "x"
    ],
    "unstructured_view": [
      "self",
      "x"
    ],
    "check_new_point_methods": [
      "cls"
    ],
    "verify_model": [
      "self"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "log_uniform_prior": [
    "x",
    "xmin",
    "xmax"
  ],
  "log_2d_cartesian_prior": [
    "x",
    "y",
    "k"
  ],
  "log_2d_cartesian_prior_sine": [
    "x",
    "y",
    "k"
  ],
  "log_3d_cartesian_prior": [
    "x",
    "y",
    "z"
  ],
  "_BaseConfig": {
    "asdict": [
      "self"
    ]
  },
  "LivepointsConfig": {
    "core_parameters_dtype": [
      "self"
    ],
    "core_parameters_defaults": [
      "self"
    ],
    "non_sampling_parameters": [
      "self"
    ],
    "non_sampling_defaults": [
      "self"
    ],
    "non_sampling_dtype": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "reset_properties": [
      "self"
    ]
  },
  "PlottingConfig": {},
  "GeneralConfig": {},
  "livepoints": [],
  "plotting": [],
  "general": [],
  "add_extra_parameters_to_live_points": [
    "parameters",
    "default_values"
  ],
  "reset_extra_live_points_parameters": [],
  "get_dtype": [
    "names",
    "array_dtype",
    "non_sampling_parameters"
  ],
  "empty_structured_array": [
    "n",
    "names",
    "dtype",
    "non_sampling_parameters"
  ],
  "live_points_to_array": [
    "live_points",
    "names",
    "copy"
  ],
  "parameters_to_live_point": [
    "parameters",
    "names",
    "non_sampling_parameters"
  ],
  "numpy_array_to_live_points": [
    "array",
    "names",
    "non_sampling_parameters"
  ],
  "dict_to_live_points": [
    "d",
    "non_sampling_parameters"
  ],
  "live_points_to_dict": [
    "live_points",
    "names"
  ],
  "dataframe_to_live_points": [
    "df",
    "non_sampling_parameters"
  ],
  "_unstructured_view_dtype": [
    "x",
    "names"
  ],
  "unstructured_view": [
    "x",
    "names",
    "dtype"
  ],
  "sort_reparameterisations": [
    "reparameterisations",
    "existing_parameters",
    "known_parameters",
    "initial_sort"
  ],
  "get_entry_points": [
    "group"
  ],
  "compute_radius": [
    "n",
    "q"
  ],
  "draw_surface_nsphere": [
    "dims",
    "r",
    "N",
    "rng"
  ],
  "draw_nsphere": [
    "dims",
    "r",
    "N",
    "fuzz",
    "rng"
  ],
  "draw_uniform": [
    "dims",
    "r",
    "N",
    "fuzz",
    "rng"
  ],
  "draw_gaussian": [
    "dims",
    "r",
    "N",
    "fuzz",
    "rng",
    "temperature"
  ],
  "draw_truncated_gaussian": [
    "dims",
    "r",
    "N",
    "fuzz",
    "var",
    "rng"
  ],
  "NDimensionalTruncatedGaussian": {
    "__init__": [
      "self",
      "dims",
      "radius",
      "fuzz",
      "rng"
    ],
    "sample": [
      "self",
      "N"
    ]
  },
  "differential_entropy": [
    "log_p"
  ],
  "optimise_meta_proposal_weights": [
    "samples",
    "log_q",
    "method",
    "options",
    "initial_weights"
  ],
  "_get_kwargs": [
    "func"
  ],
  "_get_all_kwargs": [
    "callable"
  ],
  "_get_standard_methods": [],
  "_get_importance_methods": [],
  "get_all_kwargs": [
    "importance_nested_sampler",
    "split_kwargs"
  ],
  "get_run_kwargs_list": [
    "importance_nested_sampler"
  ],
  "_hist_bin_fd": [
    "x"
  ],
  "_hist_bin_sturges": [
    "x"
  ],
  "auto_bins": [
    "x",
    "max_bins"
  ],
  "dtype_mapping": [],
  "set_torch_default_dtype": [
    "dtype"
  ],
  "rescale_zero_to_one": [
    "x",
    "xmin",
    "xmax"
  ],
  "inverse_rescale_zero_to_one": [
    "x",
    "xmin",
    "xmax"
  ],
  "rescale_minus_one_to_one": [
    "x",
    "xmin",
    "xmax"
  ],
  "inverse_rescale_minus_one_to_one": [
    "x",
    "xmin",
    "xmax"
  ],
  "detect_edge": [
    "x",
    "x_range",
    "percent",
    "cutoff",
    "nbins",
    "allow_both",
    "allow_none",
    "allowed_bounds",
    "test"
  ],
  "configure_edge_detection": [
    "d",
    "detect_edges"
  ],
  "determine_rescaled_bounds": [
    "prior_min",
    "prior_max",
    "x_min",
    "x_max",
    "invert",
    "inversion",
    "offset",
    "rescale_bounds"
  ],
  "logit": [
    "x",
    "eps"
  ],
  "sigmoid": [
    "x"
  ],
  "logistic_function": [
    "x",
    "x0",
    "k"
  ],
  "log_with_log_jacobian": [
    "x"
  ],
  "exp_with_log_jacobian": [
    "x"
  ],
  "gaussian_cdf": [
    "x"
  ],
  "inverse_gaussian_cdf": [
    "x"
  ],
  "rescaling_functions": [],
  "effective_sample_size": [
    "log_w"
  ],
  "rolling_mean": [
    "x",
    "N"
  ],
  "weighted_quantile": [
    "values",
    "quantiles",
    "log_weights",
    "values_sorted"
  ],
  "replace_in_list": [
    "target_list",
    "targets",
    "replacements"
  ],
  "get_subset_arrays": [
    "indices"
  ],
  "isfinite_struct": [
    "x",
    "names"
  ],
  "array_split_chunksize": [
    "x",
    "chunksize"
  ],
  "get_inverse_indices": [
    "n",
    "indices"
  ],
  "get_uniform_distribution": [
    "dims",
    "r",
    "device"
  ],
  "get_multivariate_normal": [
    "dims",
    "var",
    "device"
  ],
  "IntegrationTestModel": {
    "__init__": [
      "self",
      "dims"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "log_likelihood": [
      "self",
      "x"
    ],
    "to_unit_hypercube": [
      "self",
      "x"
    ],
    "from_unit_hypercube": [
      "self",
      "x"
    ]
  },
  "assert_structured_arrays_equal": [
    "x",
    "y",
    "atol",
    "rtol"
  ],
  "configure_logger": [
    "output",
    "label",
    "log_level",
    "filehandler_kwargs",
    "include_logger_name",
    "stream"
  ],
  "setup_logger": [],
  "configure_threads": [
    "pytorch_threads"
  ],
  "__all__": [],
  "_model": [],
  "get_n_pool": [
    "pool"
  ],
  "check_multiprocessing_start_method": [],
  "initialise_pool_variables": [
    "model"
  ],
  "log_likelihood_wrapper": [
    "x"
  ],
  "log_prior_wrapper": [
    "x"
  ],
  "log_prior_unit_hypercube_wrapper": [
    "x"
  ],
  "batch_evaluate_function": [
    "func",
    "x",
    "vectorised",
    "chunksize",
    "pool",
    "n_pool",
    "func_wrapper"
  ],
  "check_vectorised_function": [
    "func",
    "x",
    "dtype",
    "atol",
    "rtol"
  ],
  "RNGError": {},
  "RNGNotSetError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "RNGSetError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "is_jsonable": [
    "x"
  ],
  "NessaiJSONEncoder": {
    "default": [
      "self",
      "obj"
    ]
  },
  "save_to_json": [
    "d",
    "filename"
  ],
  "safe_file_dump": [
    "data",
    "filename",
    "module",
    "save_existing"
  ],
  "save_live_points": [
    "live_points",
    "filename"
  ],
  "encode_for_hdf5": [
    "value"
  ],
  "add_dict_to_hdf5_file": [
    "hdf5_file",
    "path",
    "d"
  ],
  "save_dict_to_hdf5": [
    "d",
    "filename"
  ],
  "compute_indices_ks_test": [
    "indices",
    "nlive",
    "mode"
  ],
  "bonferroni_correction": [
    "p_values",
    "alpha"
  ],
  "compute_minimum_distances": [
    "samples",
    "metric"
  ],
  "get_gw_reparameterisation": [
    "reparameterisation"
  ],
  "DistanceReparameterisation": {
    "requires_bounded_prior": [],
    "__init__": [
      "self",
      "parameters",
      "allowed_bounds",
      "allow_both",
      "converter_kwargs",
      "prior",
      "prior_bounds"
    ]
  },
  "DeltaPhaseReparameterisation": {
    "__init__": [
      "self",
      "parameters",
      "prior_bounds"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ]
  },
  "default_gw": [],
  "DistanceConverter": {
    "has_conversion": [],
    "has_jacobian": [],
    "to_uniform_parameter": [
      "self",
      "d"
    ],
    "from_uniform_parameter": [
      "self",
      "d"
    ]
  },
  "NullDistanceConverter": {
    "has_jacobian": [],
    "__init__": [
      "self"
    ],
    "to_uniform_parameter": [
      "self",
      "d"
    ],
    "from_uniform_parameter": [
      "self",
      "d"
    ]
  },
  "PowerLawConverter": {
    "has_conversion": [],
    "has_jacobian": [],
    "__init__": [
      "self",
      "power",
      "scale"
    ],
    "_log_jacobian": [
      "self",
      "d"
    ],
    "_log_jacobian_inv": [
      "self",
      "d"
    ],
    "to_uniform_parameter": [
      "self",
      "d"
    ],
    "from_uniform_parameter": [
      "self",
      "d"
    ]
  },
  "ComovingDistanceConverter": {
    "has_conversion": [],
    "has_jacobian": [],
    "__init__": [
      "self",
      "d_min",
      "d_max",
      "units",
      "cosmology",
      "scale",
      "pad",
      "n_interp"
    ],
    "to_uniform_parameter": [
      "self",
      "d"
    ],
    "from_uniform_parameter": [
      "self",
      "d"
    ]
  },
  "get_distance_converter": [
    "prior"
  ],
  "GWFlowProposal": {
    "aliases": [],
    "use_default_reparameterisations": [],
    "get_reparameterisation": [
      "self",
      "reparameterisation"
    ],
    "add_default_reparameterisations": [
      "self"
    ]
  },
  "AugmentedGWFlowProposal": {},
  "MLP": {
    "__init__": [
      "self",
      "in_shape",
      "out_shape",
      "hidden_sizes",
      "activation",
      "activate_output",
      "dropout_probability"
    ],
    "forward": [
      "self",
      "inputs",
      "context"
    ]
  },
  "silu": [
    "x"
  ],
  "get_base_distribution": [
    "n_inputs",
    "distribution"
  ],
  "get_n_neurons": [
    "n_neurons",
    "n_inputs",
    "default"
  ],
  "get_native_flow_class": [
    "name"
  ],
  "get_flow_class": [
    "name"
  ],
  "get_activation_function": [
    "name"
  ],
  "configure_model": [
    "config"
  ],
  "reset_weights": [
    "module"
  ],
  "reset_permutations": [
    "module"
  ],
  "create_linear_transform": [
    "linear_transform",
    "features"
  ],
  "create_pre_transform": [
    "pre_transform",
    "features"
  ],
  "NeuralSplineFlow": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "num_layers",
      "num_blocks_per_layer",
      "num_bins",
      "context_features",
      "activation",
      "dropout_probability",
      "batch_norm_within_layers",
      "batch_norm_between_layers",
      "apply_unconditional_transform",
      "linear_transform",
      "tails",
      "tail_bound",
      "distribution"
    ]
  },
  "LULinear": {
    "msg": []
  },
  "MaskedAutoregressiveFlow": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "num_layers",
      "num_blocks_per_layer",
      "context_features",
      "use_residual_blocks",
      "use_random_masks",
      "use_random_permutations",
      "activation",
      "dropout_probability",
      "batch_norm_within_layers",
      "batch_norm_between_layers"
    ]
  },
  "MultivariateNormal": {
    "__init__": [
      "self",
      "shape",
      "var"
    ],
    "_log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "_sample": [
      "self",
      "num_samples",
      "context"
    ],
    "_mean": [
      "self",
      "context"
    ]
  },
  "ResampledGaussian": {
    "end_iteration": [],
    "finalise": [
      "self",
      "n_samples",
      "n_batches"
    ]
  },
  "RealNVP": {
    "__init__": [
      "self",
      "features",
      "hidden_features",
      "num_layers",
      "num_blocks_per_layer",
      "mask",
      "context_features",
      "net",
      "use_volume_preserving",
      "activation",
      "dropout_probability",
      "batch_norm_within_layers",
      "batch_norm_between_layers",
      "linear_transform",
      "pre_transform",
      "pre_transform_kwargs",
      "actnorm",
      "distribution"
    ]
  },
  "BaseFlow": {
    "device": [],
    "to": [
      "self",
      "device"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ],
    "inverse": [
      "self",
      "z",
      "context"
    ],
    "sample": [
      "self",
      "n",
      "context"
    ],
    "log_prob": [
      "self",
      "x",
      "context"
    ],
    "sample_latent_distribution": [
      "self",
      "n",
      "context"
    ],
    "base_distribution_log_prob": [
      "self",
      "z",
      "context"
    ],
    "forward_and_log_prob": [
      "self",
      "x",
      "context"
    ],
    "sample_and_log_prob": [
      "self",
      "n",
      "context"
    ],
    "finalise": [
      "self"
    ],
    "end_iteration": [
      "self"
    ],
    "freeze_transform": [
      "self"
    ],
    "unfreeze_transform": [
      "self"
    ]
  },
  "NFlow": {
    "__init__": [
      "self",
      "transform",
      "distribution"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ],
    "inverse": [
      "self",
      "z",
      "context"
    ],
    "sample": [
      "self",
      "num_samples",
      "context"
    ],
    "log_prob": [
      "self",
      "inputs",
      "context"
    ],
    "sample_latent_distribution": [
      "self",
      "n",
      "context"
    ],
    "base_distribution_log_prob": [
      "self",
      "z",
      "context"
    ],
    "forward_and_log_prob": [
      "self",
      "x",
      "context"
    ],
    "sample_and_log_prob": [
      "self",
      "N",
      "context"
    ],
    "finalise": [
      "self"
    ],
    "end_iteration": [
      "self"
    ],
    "freeze_transform": [
      "self"
    ],
    "unfreeze_transform": [
      "self"
    ]
  },
  "OrderedSamples": {
    "__init__": [
      "self",
      "strict_threshold",
      "replace_all",
      "save_log_q"
    ],
    "live_points": [
      "self",
      "value"
    ],
    "nested_samples": [
      "self"
    ],
    "update_log_likelihood_threshold": [
      "self",
      "threshold"
    ],
    "sort_samples": [
      "self",
      "samples"
    ],
    "add_initial_samples": [
      "self",
      "samples",
      "log_q"
    ],
    "add_samples": [
      "self",
      "samples",
      "log_q"
    ],
    "add_to_nested_samples": [
      "self",
      "indices"
    ],
    "remove_samples": [
      "self"
    ],
    "update_evidence": [
      "self"
    ],
    "finalise": [
      "self"
    ],
    "compute_importance": [
      "self",
      "importance_ratio"
    ],
    "compute_evidence_ratio": [
      "self",
      "threshold"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "ImportanceNestedSampler": {
    "__init__": [
      "self",
      "model",
      "nlive",
      "n_initial",
      "output",
      "seed",
      "rng",
      "checkpointing",
      "checkpoint_interval",
      "checkpoint_on_iteration",
      "checkpoint_callback",
      "save_existing_checkpoint",
      "save_log_q",
      "logging_interval",
      "log_on_iteration",
      "resume_file",
      "plot",
      "plotting_frequency",
      "min_iteration",
      "max_iteration",
      "min_samples",
      "min_remove",
      "max_samples",
      "stopping_criterion",
      "tolerance",
      "n_update",
      "plot_pool",
      "plot_level_cdf",
      "plot_trace",
      "plot_likelihood_levels",
      "plot_training_data",
      "plot_extra_state",
      "trace_plot_kwargs",
      "replace_all",
      "threshold_method",
      "threshold_kwargs",
      "n_pool",
      "pool",
      "check_criteria",
      "weighted_kl",
      "draw_constant",
      "train_final_flow",
      "bootstrap",
      "close_pool",
      "strict_threshold",
      "draw_iid_live"
    ],
    "log_evidence": [
      "self"
    ],
    "log_evidence_error": [
      "self"
    ],
    "final_log_evidence": [
      "self"
    ],
    "final_log_evidence_error": [
      "self"
    ],
    "final_log_posterior_weights": [
      "self"
    ],
    "posterior_effective_sample_size": [
      "self"
    ],
    "samples_entropy": [
      "self"
    ],
    "current_proposal_entropy": [
      "self"
    ],
    "_ordered_samples": [
      "self"
    ],
    "samples_unit": [
      "self"
    ],
    "samples": [
      "self"
    ],
    "log_posterior_weights": [
      "self"
    ],
    "log_q": [
      "self"
    ],
    "live_points_unit": [
      "self",
      "samples"
    ],
    "live_points": [
      "self",
      "samples"
    ],
    "nested_samples_unit": [
      "self"
    ],
    "nested_samples": [
      "self"
    ],
    "state": [
      "self"
    ],
    "final_samples_unit": [
      "self"
    ],
    "final_samples": [
      "self"
    ],
    "final_state": [
      "self"
    ],
    "reached_tolerance": [
      "self"
    ],
    "stopping_criteria": [
      "self"
    ],
    "add_fields": [],
    "configure_stopping_criterion": [
      "self",
      "stopping_criterion",
      "tolerance",
      "check_criteria"
    ],
    "get_proposal": [
      "self",
      "subdir"
    ],
    "update_output": [
      "self",
      "output"
    ],
    "configure_iterations": [
      "self",
      "min_iteration",
      "max_iteration"
    ],
    "check_configuration": [
      "self"
    ],
    "populate_live_points": [
      "self"
    ],
    "initialise": [
      "self"
    ],
    "initialise_history": [
      "self"
    ],
    "update_history": [
      "self"
    ],
    "determine_threshold_quantile": [
      "self",
      "samples",
      "q",
      "include_likelihood"
    ],
    "determine_threshold_entropy": [
      "self",
      "samples",
      "q",
      "include_likelihood",
      "use_log_weights"
    ],
    "plot_level_cdf": [
      "self",
      "log_likelihood_values",
      "cdf",
      "threshold",
      "q",
      "filename"
    ],
    "determine_log_likelihood_threshold": [
      "self",
      "samples",
      "method"
    ],
    "update_log_likelihood_threshold": [
      "self",
      "threshold"
    ],
    "add_new_proposal": [
      "self"
    ],
    "draw_n_samples": [
      "self",
      "n"
    ],
    "compute_leakage": [
      "self",
      "samples",
      "weights"
    ],
    "add_and_update_points": [
      "self",
      "n"
    ],
    "remove_samples": [
      "self"
    ],
    "adjust_final_samples": [
      "self",
      "n_batches"
    ],
    "finalise": [
      "self"
    ],
    "add_level_post_sampling": [
      "self",
      "samples",
      "n"
    ],
    "compute_stopping_criterion": [
      "self"
    ],
    "checkpoint": [
      "self",
      "periodic",
      "force"
    ],
    "_compute_gradient": [
      "self"
    ],
    "log_state": [
      "self"
    ],
    "update_evidence": [
      "self"
    ],
    "compute_importance": [
      "self"
    ],
    "update_proposal_weights": [
      "self"
    ],
    "update_sample_counts": [
      "self"
    ],
    "add_new_proposal_weight": [
      "self",
      "iteration",
      "n_new"
    ],
    "nested_sampling_loop": [
      "self"
    ],
    "draw_posterior_samples": [
      "self",
      "sampling_method",
      "n",
      "use_final_samples"
    ],
    "kl_divergence": [
      "samples"
    ],
    "draw_more_nested_samples": [
      "self",
      "n"
    ],
    "draw_final_samples": [
      "self",
      "n_post",
      "n_draw",
      "max_its",
      "max_batch_size",
      "max_samples_ratio",
      "use_counts",
      "optimise_weights",
      "optimise_kwargs",
      "optimisation_method"
    ],
    "train_final_flow": [
      "self"
    ],
    "plot_state": [
      "self",
      "filename"
    ],
    "plot_extra_state": [
      "self",
      "filename"
    ],
    "plot_trace": [
      "self",
      "enable_colours",
      "filename"
    ],
    "plot_likelihood_levels": [
      "self",
      "filename",
      "cmap",
      "max_bins"
    ],
    "produce_plots": [
      "self",
      "override"
    ],
    "get_result_dictionary": [
      "self"
    ],
    "resume_from_pickled_sampler": [
      "cls",
      "sampler",
      "model",
      "flow_config",
      "weights_path"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "NestedSampler": {
    "__init__": [
      "self",
      "model",
      "nlive",
      "output",
      "stopping",
      "max_iteration",
      "checkpointing",
      "checkpoint_interval",
      "checkpoint_on_iteration",
      "checkpoint_on_training",
      "checkpoint_callback",
      "logging_interval",
      "log_on_iteration",
      "resume_file",
      "seed",
      "rng",
      "pool",
      "close_pool",
      "n_pool",
      "plot",
      "proposal_plots",
      "prior_sampling",
      "analytic_priors",
      "maximum_uninformed",
      "uninformed_proposal",
      "uninformed_acceptance_threshold",
      "uninformed_proposal_kwargs",
      "flow_proposal_class",
      "flow_class",
      "flow_config",
      "training_frequency",
      "train_on_empty",
      "cooldown",
      "memory",
      "reset_weights",
      "reset_permutations",
      "reset_flow",
      "retrain_acceptance",
      "reset_acceptance",
      "acceptance_threshold",
      "shrinkage_expectation",
      "trace_parameters"
    ],
    "log_evidence": [
      "self"
    ],
    "log_evidence_error": [
      "self"
    ],
    "information": [
      "self"
    ],
    "proposal_population_time": [
      "self"
    ],
    "acceptance": [
      "self"
    ],
    "last_updated": [
      "self"
    ],
    "mean_acceptance": [
      "self"
    ],
    "posterior_effective_sample_size": [
      "self"
    ],
    "birth_log_likelihoods": [
      "self"
    ],
    "tolerance": [
      "self"
    ],
    "configure_max_iteration": [
      "self",
      "max_iteration"
    ],
    "configure_training_frequency": [
      "self",
      "training_frequency"
    ],
    "configure_uninformed_proposal": [
      "self",
      "uninformed_proposal",
      "analytic_priors",
      "maximum_uninformed",
      "uninformed_acceptance_threshold"
    ],
    "configure_flow_proposal": [
      "self",
      "flow_proposal_class",
      "flow_config",
      "proposal_plots"
    ],
    "configure_output": [
      "self",
      "output",
      "resume_file"
    ],
    "update_output": [
      "self",
      "output"
    ],
    "configure_flow_reset": [
      "self",
      "reset_weights",
      "reset_permutations",
      "reset_flow"
    ],
    "initialise_history": [
      "self"
    ],
    "update_history": [
      "self"
    ],
    "log_state": [
      "self"
    ],
    "check_insertion_indices": [
      "self",
      "rolling",
      "filename"
    ],
    "yield_sample": [
      "self",
      "oldparam"
    ],
    "insert_live_point": [
      "self",
      "live_point"
    ],
    "consume_sample": [
      "self"
    ],
    "populate_live_points": [
      "self"
    ],
    "initialise": [
      "self",
      "live_points"
    ],
    "check_proposal_switch": [
      "self",
      "force"
    ],
    "check_training": [
      "self"
    ],
    "check_flow_model_reset": [
      "self"
    ],
    "train_proposal": [
      "self",
      "force"
    ],
    "check_state": [
      "self",
      "force"
    ],
    "plot_state": [
      "self",
      "filename"
    ],
    "plot_trace": [
      "self",
      "filename"
    ],
    "plot_insertion_indices": [
      "self",
      "filename"
    ],
    "update_state": [
      "self",
      "force"
    ],
    "check_resume": [
      "self"
    ],
    "finalise": [
      "self"
    ],
    "nested_sampling_loop": [
      "self"
    ],
    "get_result_dictionary": [
      "self"
    ],
    "resume_from_pickled_sampler": [
      "cls",
      "sampler",
      "model",
      "flow_config",
      "weights_path"
    ]
  },
  "BaseNestedSampler": {
    "__init__": [
      "self",
      "model",
      "nlive",
      "output",
      "seed",
      "rng",
      "checkpointing",
      "checkpoint_interval",
      "checkpoint_on_iteration",
      "checkpoint_callback",
      "logging_interval",
      "log_on_iteration",
      "resume_file",
      "plot",
      "n_pool",
      "pool"
    ],
    "current_sampling_time": [
      "self"
    ],
    "likelihood_evaluation_time": [
      "self"
    ],
    "total_likelihood_evaluations": [
      "self"
    ],
    "likelihood_calls": [],
    "posterior_effective_sample_size": [
      "self"
    ],
    "configure_output": [
      "self",
      "output",
      "resume_file"
    ],
    "update_output": [
      "self",
      "output"
    ],
    "configure_rng": [
      "self",
      "seed",
      "rng"
    ],
    "configure_random_seed": [
      "self",
      "seed"
    ],
    "configure_periodic_logging": [
      "self",
      "logging_interval",
      "log_on_iteration"
    ],
    "log_state": [
      "self"
    ],
    "periodically_log_state": [
      "self"
    ],
    "initialise_history": [
      "self"
    ],
    "update_history": [
      "self"
    ],
    "checkpoint": [
      "self",
      "periodic",
      "force",
      "save_existing"
    ],
    "resume_from_pickled_sampler": [
      "cls",
      "sampler",
      "model",
      "output",
      "checkpoint_callback"
    ],
    "resume": [
      "cls",
      "filename",
      "model",
      "output"
    ],
    "nested_sampling_loop": [
      "self"
    ],
    "close_pool": [
      "self",
      "code"
    ],
    "get_result_dictionary": [
      "self"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "ClusteringGWFlowProposal": {},
  "known_flows": [],
  "GlasflowWrapper": {
    "__init__": [
      "self",
      "FlowClass",
      "n_inputs",
      "n_neurons",
      "n_blocks",
      "n_layers"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ],
    "inverse": [
      "self",
      "z",
      "context"
    ],
    "log_prob": [
      "self",
      "x",
      "context"
    ],
    "sample": [
      "self",
      "n",
      "context"
    ],
    "forward_and_log_prob": [
      "self",
      "x",
      "context"
    ],
    "sample_and_log_prob": [
      "self",
      "n",
      "context"
    ],
    "sample_latent_distribution": [
      "self",
      "n",
      "context"
    ],
    "base_distribution_log_prob": [
      "self",
      "z",
      "context"
    ],
    "freeze_transform": [
      "self"
    ],
    "unfreeze_transform": [
      "self"
    ]
  },
  "get_glasflow_class": [
    "name"
  ],
  "ClusteringFlowModel": {
    "__init__": [
      "self",
      "flow_config",
      "training_config",
      "output",
      "rng"
    ],
    "setup_from_input_dict": [
      "self",
      "flow_config",
      "training_config"
    ],
    "train_clustering": [
      "self",
      "samples"
    ],
    "get_cluster_labels": [
      "self",
      "samples",
      "clusterer"
    ],
    "sample_cluster_labels": [
      "self",
      "n"
    ],
    "train": [
      "self",
      "samples"
    ],
    "forward_and_log_prob": [
      "self",
      "x"
    ],
    "log_prob": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "n",
      "return_labels"
    ],
    "sample_and_log_prob": [
      "self",
      "N",
      "z",
      "alt_dist"
    ]
  },
  "silhouette_score": [
    "samples",
    "clusterer"
  ],
  "ClusteringFlowProposal": {
    "_FlowModelClass": [],
    "__init__": [
      "self",
      "model",
      "max_n_clusters"
    ],
    "_plot_training_data": [
      "self",
      "output"
    ]
  },
  "next_pow_two": [
    "n"
  ],
  "function_1d": [
    "x"
  ],
  "auto_window": [
    "taus",
    "c"
  ],
  "integrated_time": [
    "x",
    "c"
  ],
  "Step": {
    "__init__": [
      "self",
      "dims",
      "ensemble",
      "rng"
    ],
    "step": [
      "self",
      "z"
    ],
    "update_ensemble": [
      "self",
      "ensemble"
    ],
    "update_stats": [
      "self",
      "n_accept",
      "n_reject"
    ],
    "__call__": [
      "self"
    ]
  },
  "GaussianStep": {
    "__init__": [
      "self",
      "dims",
      "ensemble",
      "rng",
      "scale",
      "update_scale",
      "target_acceptance"
    ],
    "step": [
      "self",
      "z"
    ],
    "update_stats": [
      "self",
      "n_accept",
      "n_reject"
    ]
  },
  "_get_nondiagonal_pairs": [
    "n"
  ],
  "DifferentialEvolutionStep": {
    "__init__": [
      "self",
      "dims",
      "ensemble",
      "rng",
      "mix_fraction",
      "sigma"
    ],
    "update_ensemble": [
      "self",
      "ensemble"
    ],
    "step": [
      "self",
      "z"
    ]
  },
  "StretchStep": {
    "__init__": [
      "self",
      "dims",
      "ensemble",
      "rng",
      "scale"
    ],
    "step": [
      "self",
      "z"
    ]
  },
  "KNOWN_STEPS": [],
  "MCMCFlowProposal": {
    "__init__": [
      "self",
      "model",
      "n_steps",
      "n_accept",
      "step_type",
      "step_kwargs",
      "plot_chain",
      "plot_history",
      "enforce_likelihood_threshold",
      "ensemble_fraction"
    ],
    "initialise": [
      "self",
      "resumed"
    ],
    "plot_chain": [
      "self",
      "chains"
    ],
    "plot_history": [
      "self"
    ],
    "x_prime_log_prior": [
      "self",
      "x"
    ],
    "populate": [
      "self",
      "worst_point",
      "n_samples",
      "plot"
    ]
  },
  "ImportanceFlowModel": {
    "__init__": [
      "self",
      "flow_config",
      "training_config",
      "output",
      "rng"
    ],
    "model": [
      "self",
      "model"
    ],
    "n_models": [
      "self"
    ],
    "initialise": [
      "self"
    ],
    "reset_optimiser": [
      "self"
    ],
    "add_new_flow": [
      "self",
      "reset"
    ],
    "log_prob_ith": [
      "self",
      "x",
      "i"
    ],
    "log_prob_all": [
      "self",
      "x"
    ],
    "sample_ith": [
      "self",
      "i",
      "N"
    ],
    "save_weights": [
      "self",
      "weights_file"
    ],
    "load_all_weights": [
      "self"
    ],
    "update_weights_path": [
      "self",
      "weights_path",
      "n"
    ],
    "resume": [
      "self",
      "flow_config",
      "weights_path"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "update_flow_config": [
    "cfg"
  ],
  "update_model_config": [
    "cfg"
  ],
  "update_training_config": [
    "cfg"
  ],
  "update_config": [
    "flow_config",
    "training_config"
  ],
  "FlowConfig": {},
  "TrainingConfig": {},
  "flow": [],
  "training": [],
  "FlowModel": {
    "noise_scale": [],
    "noise_type": [],
    "__init__": [
      "self",
      "flow_config",
      "training_config",
      "output",
      "rng"
    ],
    "setup_from_input_dict": [
      "self",
      "flow_config",
      "training_config"
    ],
    "update_mask": [
      "self"
    ],
    "get_optimiser": [
      "self",
      "optimiser"
    ],
    "optimiser_kwargs": [
      "self"
    ],
    "optimiser": [
      "self"
    ],
    "initialise": [
      "self"
    ],
    "move_to": [
      "self",
      "device",
      "update_default"
    ],
    "check_batch_size": [
      "x",
      "batch_size",
      "min_fraction"
    ],
    "prep_data": [
      "self",
      "samples",
      "val_size",
      "batch_size",
      "weights",
      "use_dataloader",
      "conditional"
    ],
    "end_iteration": [
      "self"
    ],
    "_train": [
      "self",
      "train_data",
      "noise_scale",
      "is_dataloader",
      "weighted",
      "is_conditional"
    ],
    "_validate": [
      "self",
      "val_data",
      "is_dataloader",
      "weighted",
      "is_conditional"
    ],
    "finalise": [
      "self"
    ],
    "train": [
      "self",
      "samples",
      "weights",
      "conditional",
      "max_epochs",
      "patience",
      "output",
      "val_size",
      "plot"
    ],
    "save_weights": [
      "self",
      "weights_file"
    ],
    "load_weights": [
      "self",
      "weights_file"
    ],
    "reload_weights": [
      "self",
      "weights_file"
    ],
    "reset_model": [
      "self",
      "weights",
      "permutations"
    ],
    "numpy_array_to_tensor": [],
    "forward_and_log_prob": [
      "self",
      "x",
      "conditional"
    ],
    "inverse": [
      "self",
      "z",
      "conditional"
    ],
    "log_prob": [
      "self",
      "x",
      "conditional"
    ],
    "sample": [
      "self",
      "n",
      "conditional"
    ],
    "sample_latent_distribution": [
      "self",
      "n"
    ],
    "sample_and_log_prob": [
      "self",
      "N",
      "z",
      "alt_dist",
      "conditional"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "Angle": {
    "requires_bounded_prior": [],
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "scale",
      "prior",
      "rng"
    ],
    "angle": [
      "self"
    ],
    "radial": [
      "self"
    ],
    "radius": [
      "self"
    ],
    "x": [
      "self"
    ],
    "y": [
      "self"
    ],
    "_rescale_radial": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "_rescale_angle": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "_inverse_rescale_angle": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "x_prime_log_prior": [
      "self",
      "x_prime"
    ]
  },
  "ToCartesian": {
    "__init__": [
      "self",
      "mode",
      "scale",
      "rng"
    ],
    "_rescale_angle": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "compute_radius"
    ],
    "_inverse_rescale_angle": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ]
  },
  "AnglePair": {
    "requires_bounded_prior": [],
    "known_priors": [],
    "_conventions": [],
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "prior",
      "convention",
      "rng"
    ],
    "angles": [
      "self"
    ],
    "radial": [
      "self"
    ],
    "x": [
      "self"
    ],
    "y": [
      "self"
    ],
    "z": [
      "self"
    ],
    "_az_zen": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "r"
    ],
    "_ra_dec": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "r"
    ],
    "_inv_az_zen": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "_inv_ra_dec": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "x_prime_log_prior": [
      "self",
      "x_prime"
    ]
  },
  "ReparameterisationError": {},
  "KnownReparameterisation": {},
  "ReparameterisationDict": {
    "add_reparameterisation": [
      "self",
      "name",
      "class_fn",
      "keyword_arguments"
    ],
    "add_external_reparameterisations": [
      "self",
      "group"
    ]
  },
  "get_reparameterisation": [
    "reparameterisation",
    "defaults"
  ],
  "Dequantise": {
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "rescale_bounds",
      "update_bounds",
      "post_rescaling",
      "rng"
    ],
    "set_bounds": [
      "self",
      "prior_bounds"
    ],
    "pre_rescaling": [
      "self",
      "x"
    ],
    "pre_rescaling_inv": [
      "self",
      "x"
    ]
  },
  "CombinedReparameterisation": {
    "__init__": [
      "self",
      "reparameterisations",
      "reverse_order"
    ],
    "has_prime_prior": [
      "self"
    ],
    "requires_prime_prior": [
      "self"
    ],
    "one_to_one": [
      "self"
    ],
    "to_prime_order": [
      "self"
    ],
    "from_prime_order": [
      "self"
    ],
    "_add_reparameterisation": [
      "self",
      "reparameterisation"
    ],
    "add_reparameterisation": [
      "self",
      "reparameterisation"
    ],
    "add_reparameterisations": [
      "self",
      "reparameterisations"
    ],
    "check_order": [
      "self"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "update_bounds": [
      "self",
      "x"
    ],
    "reset_inversion": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "reset": [
      "self"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "x_prime_log_prior": [
      "self",
      "x_prime"
    ]
  },
  "PrePostRescalingMixin": {
    "has_pre_rescaling": [],
    "has_post_rescaling": [],
    "configure_pre_rescaling": [
      "self",
      "pre_rescaling"
    ],
    "configure_post_rescaling": [
      "self",
      "post_rescaling"
    ],
    "pre_rescaling": [
      "self",
      "x"
    ],
    "pre_rescaling_inv": [
      "self",
      "x"
    ],
    "post_rescaling": [
      "self",
      "x"
    ],
    "post_rescaling_inv": [
      "self",
      "x"
    ]
  },
  "ScaleAndShift": {
    "requires_bounded_prior": [],
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "scale",
      "shift",
      "estimate_scale",
      "estimate_shift",
      "pre_rescaling",
      "post_rescaling",
      "rng"
    ],
    "_check_value": [
      "self",
      "value",
      "name"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "update": [
      "self",
      "x"
    ],
    "reset": [
      "self"
    ]
  },
  "Rescale": {},
  "RescaleToBounds": {
    "requires_bounded_prior": [],
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "prior",
      "rescale_bounds",
      "boundary_inversion",
      "detect_edges",
      "inversion_type",
      "detect_edges_kwargs",
      "offset",
      "update_bounds",
      "pre_rescaling",
      "post_rescaling",
      "rng"
    ],
    "configure_post_rescaling": [
      "self",
      "post_rescaling"
    ],
    "pre_rescaling": [
      "self",
      "x"
    ],
    "pre_rescaling_inv": [
      "self",
      "x"
    ],
    "post_rescaling": [
      "self",
      "x"
    ],
    "post_rescaling_inv": [
      "self",
      "x"
    ],
    "_rescale_to_bounds": [
      "self",
      "x",
      "n"
    ],
    "_inverse_rescale_to_bounds": [
      "self",
      "x",
      "n"
    ],
    "_apply_inversion": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "p",
      "pp",
      "compute_radius",
      "test"
    ],
    "_reverse_inversion": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "p",
      "pp"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j",
      "compute_radius"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "reset_inversion": [
      "self"
    ],
    "set_bounds": [
      "self",
      "prior_bounds"
    ],
    "update_bounds": [
      "self",
      "x"
    ],
    "update_prime_prior_bounds": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "reset": [
      "self"
    ],
    "x_prime_log_prior": [
      "self",
      "x_prime"
    ]
  },
  "NullReparameterisation": {
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "rng"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ]
  },
  "default_reparameterisations": [],
  "Reparameterisation": {
    "_update": [],
    "has_prior": [],
    "has_prime_prior": [],
    "requires_prime_prior": [],
    "requires_bounded_prior": [],
    "prior_bounds": [],
    "prime_prior_bounds": [],
    "one_to_one": [],
    "__init__": [
      "self",
      "parameters",
      "prior_bounds",
      "rng"
    ],
    "name": [
      "self"
    ],
    "reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "inverse_reparameterise": [
      "self",
      "x",
      "x_prime",
      "log_j"
    ],
    "update": [
      "self",
      "x"
    ],
    "reset": [
      "self"
    ]
  },
  "ImportanceFlowProposal": {
    "__init__": [
      "self",
      "model",
      "output",
      "rng",
      "flow_config",
      "training_config",
      "reparameterisation",
      "weighted_kl",
      "reset_flow",
      "clip",
      "plot_training"
    ],
    "weights": [
      "self"
    ],
    "weights_array": [
      "self"
    ],
    "n_proposals": [
      "self"
    ],
    "flow_config": [
      "self",
      "config"
    ],
    "_reset_flow": [
      "self"
    ],
    "_check_fields": [],
    "initialise": [
      "self"
    ],
    "verify_rescaling": [
      "self",
      "n",
      "rtol",
      "atol"
    ],
    "to_prime": [
      "self",
      "x"
    ],
    "from_prime": [
      "self",
      "x_prime"
    ],
    "rescale": [
      "self",
      "x"
    ],
    "inverse_rescale": [
      "self",
      "x_prime"
    ],
    "update_proposal_weights": [
      "self",
      "weights"
    ],
    "train": [
      "self",
      "samples",
      "plot",
      "output",
      "weights"
    ],
    "compute_log_Q": [
      "self",
      "x_prime",
      "log_j"
    ],
    "draw": [
      "self",
      "n",
      "flow_number"
    ],
    "update_log_q": [
      "self",
      "samples",
      "log_q"
    ],
    "compute_meta_proposal_from_log_q": [
      "self",
      "log_q"
    ],
    "compute_meta_proposal_samples": [
      "self",
      "samples"
    ],
    "_log_prob_initial": [
      "self",
      "x"
    ],
    "get_proposal_log_prob": [
      "self",
      "it"
    ],
    "compute_kl_between_proposals": [
      "self",
      "x",
      "p_it",
      "q_it"
    ],
    "draw_from_prior": [
      "self",
      "n"
    ],
    "draw_from_flows": [
      "self",
      "n",
      "weights",
      "counts"
    ],
    "resume": [
      "self",
      "model",
      "flow_config",
      "weights_path"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "check_proposal_kwargs": [
    "ProposalClass",
    "kwargs",
    "strict"
  ],
  "available_base_flow_proposal_classes": [],
  "available_external_flow_proposal_classes": [
    "load"
  ],
  "get_flow_proposal_class": [
    "proposal_class"
  ],
  "get_region_sampler_proposal_class": [],
  "AugmentedFlowProposal": {
    "__init__": [
      "self",
      "model",
      "augment_dims",
      "generate_augment",
      "marginalise_augment",
      "n_marg"
    ],
    "set_rescaling": [
      "self"
    ],
    "update_flow_config": [
      "self"
    ],
    "_augmented_rescale": [
      "self",
      "x",
      "generate_augment",
      "compute_radius"
    ],
    "_augmented_inverse_rescale": [
      "self",
      "x_prime",
      "return_unit_hypercube"
    ],
    "augmented_prior": [
      "self",
      "x"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "x_prime_log_prior": [
      "self",
      "x"
    ],
    "_marginalise_augment": [
      "self",
      "x_prime"
    ],
    "backward_pass": [
      "self",
      "z",
      "rescale",
      "discard_nans",
      "return_unit_hypercube",
      "return_z"
    ]
  },
  "AnalyticProposal": {
    "__init__": [
      "self"
    ],
    "poolsize": [
      "self"
    ],
    "populate": [
      "self",
      "N"
    ],
    "draw": [
      "self",
      "old_sample"
    ]
  },
  "RejectionProposal": {
    "__init__": [
      "self"
    ],
    "draw_proposal": [
      "self",
      "N"
    ],
    "log_proposal": [
      "self",
      "x"
    ],
    "compute_weights": [
      "self",
      "x",
      "return_log_prior"
    ],
    "populate": [
      "self",
      "N"
    ]
  },
  "Proposal": {
    "__init__": [
      "self",
      "model",
      "rng"
    ],
    "initialised": [
      "self",
      "boolean"
    ],
    "initialise": [
      "self"
    ],
    "update_output": [
      "self",
      "output"
    ],
    "evaluate_likelihoods": [
      "self"
    ],
    "draw": [
      "self",
      "old_param"
    ],
    "train": [
      "self",
      "x"
    ],
    "resume": [
      "self",
      "model"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "FlowProposal": {
    "__init__": [
      "self",
      "model",
      "poolsize",
      "latent_prior",
      "latent_temperature",
      "constant_volume_mode",
      "volume_fraction",
      "fuzz",
      "fixed_radius",
      "drawsize",
      "truncate_log_q",
      "expansion_fraction",
      "min_radius",
      "max_radius",
      "compute_radius_with_all",
      "enforce_likelihood_threshold"
    ],
    "configure_population": [
      "self",
      "drawsize",
      "fuzz",
      "expansion_fraction",
      "latent_prior",
      "latent_temperature"
    ],
    "configure_latent_prior": [
      "self"
    ],
    "configure_fixed_radius": [
      "self",
      "fixed_radius"
    ],
    "configure_min_max_radius": [
      "self",
      "min_radius",
      "max_radius"
    ],
    "configure_constant_volume": [
      "self"
    ],
    "set_rescaling": [
      "self"
    ],
    "radius": [
      "self",
      "z"
    ],
    "prep_latent_prior": [
      "self"
    ],
    "draw_latent_prior": [
      "self",
      "n"
    ],
    "backward_pass": [
      "self",
      "z",
      "rescale",
      "discard_nans",
      "return_z",
      "return_unit_hypercube"
    ],
    "populate": [
      "self",
      "worst_point",
      "n_samples",
      "plot",
      "r",
      "max_samples"
    ],
    "get_alt_distribution": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "BaseFlowProposal": {
    "use_default_reparameterisations": [],
    "_FlowModelClass": [],
    "alt_dist": [],
    "__init__": [
      "self",
      "model",
      "rng",
      "flow_config",
      "training_config",
      "output",
      "poolsize",
      "plot",
      "check_acceptance",
      "max_poolsize_scale",
      "update_poolsize",
      "accumulate_weights",
      "save_training_data",
      "reparameterisations",
      "fallback_reparameterisation",
      "use_default_reparameterisations",
      "reverse_reparameterisations",
      "map_to_unit_hypercube"
    ],
    "poolsize": [
      "self"
    ],
    "flow_config": [
      "self",
      "config"
    ],
    "training_config": [
      "self",
      "config"
    ],
    "dims": [
      "self"
    ],
    "rescaled_dims": [
      "self"
    ],
    "x_dtype": [
      "self"
    ],
    "x_prime_dtype": [
      "self"
    ],
    "population_dtype": [
      "self"
    ],
    "prior_bounds": [
      "self"
    ],
    "configure_poolsize": [
      "self",
      "poolsize",
      "update_poolsize",
      "max_poolsize_scale"
    ],
    "configure_plotting": [
      "self",
      "plot"
    ],
    "update_flow_config": [
      "self"
    ],
    "initialise": [
      "self",
      "resumed"
    ],
    "update_poolsize_scale": [
      "self",
      "acceptance"
    ],
    "add_default_reparameterisations": [
      "self"
    ],
    "get_reparameterisation": [
      "self",
      "name"
    ],
    "configure_reparameterisations": [
      "self",
      "reparameterisations"
    ],
    "names": [
      "self"
    ],
    "rescaled_names": [
      "self"
    ],
    "update_bounds": [
      "self"
    ],
    "set_rescaling": [
      "self"
    ],
    "verify_rescaling": [
      "self"
    ],
    "rescale": [
      "self",
      "x"
    ],
    "inverse_rescale": [
      "self",
      "x_prime",
      "return_unit_hypercube"
    ],
    "check_state": [
      "self",
      "x"
    ],
    "_plot_training_data": [
      "self",
      "output"
    ],
    "train": [
      "self",
      "x",
      "plot"
    ],
    "reset_model_weights": [
      "self"
    ],
    "check_prior_bounds": [
      "self",
      "x"
    ],
    "forward_pass": [
      "self",
      "x",
      "rescale"
    ],
    "backward_pass": [
      "self",
      "z",
      "rescale"
    ],
    "log_prior": [
      "self",
      "x"
    ],
    "x_prime_log_prior": [
      "self",
      "x"
    ],
    "unit_hypercube_log_prior": [
      "self",
      "x"
    ],
    "compute_weights": [
      "self",
      "x",
      "log_q",
      "return_log_prior"
    ],
    "convert_to_samples": [
      "self",
      "x",
      "plot"
    ],
    "populate": [
      "self",
      "worst_point",
      "n_samples"
    ],
    "compute_acceptance": [
      "self",
      "logL"
    ],
    "draw": [
      "self",
      "worst_point"
    ],
    "plot_pool": [
      "self",
      "x"
    ],
    "resume": [
      "self",
      "model",
      "flow_config",
      "weights_file"
    ],
    "reset": [
      "self"
    ],
    "__getstate__": [
      "self"
    ]
  }
}