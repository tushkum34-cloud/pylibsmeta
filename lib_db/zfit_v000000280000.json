{
  "ScipyTrustConstrV1": [],
  "ScipyTrustNCGV1": [],
  "ScipyTrustKrylovV1": [],
  "ScipyDoglegV1": [],
  "ScipyCOBYLAV1": [],
  "ScipyLBFGSBV1": [],
  "ScipyPowellV1": [],
  "ScipySLSQPV1": [],
  "ScipyNewtonCGV1": [],
  "ScipyTruncNCV1": [],
  "ScipyNelderMeadV1": [],
  "NLoptLBFGSV1": [],
  "NLoptTruncNewtonV1": [],
  "NLoptSLSQPV1": [],
  "NLoptMMAV1": [],
  "NLoptCCSAQV1": [],
  "NLoptShiftVarV1": [],
  "NLoptMLSLV1": [],
  "NLoptStoGOV1": [],
  "NLoptESCHV1": [],
  "NLoptISRESV1": [],
  "NLoptSubplexV1": [],
  "NLoptBOBYQAV1": [],
  "NLoptCOBYLAV1": [],
  "IpyoptV1": [],
  "ScipyBaseMinimizerV1": [],
  "NLoptBaseMinimizerV1": [],
  "BaseMinimizerV1": [],
  "__all__": [],
  "ZfitObject": {},
  "ZfitDimensional": {
    "obs": [
      "self"
    ],
    "axes": [
      "self"
    ],
    "n_obs": [
      "self"
    ]
  },
  "ZfitOrderableDimensional": {
    "with_obs": [
      "self",
      "obs",
      "allow_superset",
      "allow_subset"
    ],
    "with_axes": [
      "self",
      "axes",
      "allow_superset",
      "allow_subset"
    ],
    "with_autofill_axes": [
      "self",
      "overwrite"
    ],
    "reorder_x": [
      "self",
      "x"
    ],
    "get_reorder_indices": [
      "self",
      "obs",
      "axes"
    ]
  },
  "ZfitData": {
    "value": [
      "self",
      "obs"
    ],
    "weights": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "samplesize": [
      "self"
    ],
    "num_entries": [
      "self"
    ],
    "to_binned": [
      "self",
      "binning"
    ]
  },
  "ZfitUnbinnedData": {
    "has_weights": [
      "self"
    ]
  },
  "ZfitLimit": {
    "rect_limits": [
      "self"
    ],
    "rect_limits_np": [
      "self"
    ],
    "rect_lower": [
      "self"
    ],
    "rect_upper": [
      "self"
    ],
    "rect_area": [
      "self"
    ],
    "inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "filter": [
      "self",
      "x",
      "guarantee_limits",
      "axis"
    ],
    "has_rect_limits": [
      "self"
    ],
    "rect_limits_are_tensors": [
      "self"
    ],
    "limits_are_set": [
      "self"
    ],
    "limits_are_false": [
      "self"
    ],
    "has_limits": [
      "self"
    ],
    "get_subspace": [
      "self"
    ],
    "n_obs": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "less_equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "get_sublimits": [
      "self"
    ],
    "__hash__": [
      "self"
    ]
  },
  "ZfitSpace": {
    "is_binned": [
      "self"
    ],
    "binning": [
      "self"
    ],
    "n_limits": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "_legacy_area": [
      "self"
    ],
    "with_limits": [
      "self",
      "limits",
      "rect_limits",
      "name"
    ],
    "with_binning": [
      "self",
      "binning"
    ],
    "get_subspace": [
      "self",
      "obs",
      "axes",
      "name"
    ],
    "with_coords": [
      "self",
      "coords",
      "allow_superset",
      "allow_subset"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "ZfitParametrized": {
    "get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "params": [
      "self"
    ]
  },
  "ZfitNumericParametrized": {
    "dtype": [
      "self"
    ]
  },
  "ZfitParameter": {
    "name": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "floating": [
      "self",
      "value"
    ],
    "value": [
      "self"
    ],
    "independent": [
      "self"
    ],
    "stepsize": [
      "self"
    ]
  },
  "ZfitIndependentParameter": {
    "randomize": [
      "self",
      "minval",
      "maxval",
      "sampler"
    ],
    "set_value": [
      "self",
      "value"
    ],
    "has_limits": [
      "self"
    ],
    "at_limit": [
      "self"
    ],
    "stepsize": [
      "self"
    ]
  },
  "ZfitLoss": {
    "gradient": [
      "self",
      "params"
    ],
    "value": [
      "self"
    ],
    "model": [
      "self"
    ],
    "data": [
      "self"
    ],
    "fit_range": [
      "self"
    ],
    "add_constraints": [
      "self",
      "constraints"
    ],
    "errordef": [
      "self"
    ],
    "hessian": [
      "self",
      "params"
    ],
    "value_gradient": [
      "self",
      "params"
    ],
    "value_gradient_hessian": [
      "self",
      "params",
      "hessian"
    ],
    "create_new": [
      "self"
    ],
    "is_weighted": [
      "self"
    ]
  },
  "ZfitModel": {
    "update_integration_options": [
      "self"
    ],
    "integrate": [
      "self",
      "limits",
      "norm"
    ],
    "register_analytic_integral": [
      "cls",
      "func",
      "limits",
      "priority"
    ],
    "partial_integrate": [
      "self",
      "x",
      "limits"
    ],
    "register_inverse_analytic_integral": [
      "cls",
      "func"
    ],
    "sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "ZfitFunc": {
    "func": [
      "self",
      "x",
      "name"
    ],
    "as_pdf": [
      "self"
    ]
  },
  "ZfitPDF": {
    "pdf": [
      "self",
      "x",
      "norm",
      "params"
    ],
    "is_extended": [
      "self"
    ],
    "set_norm_range": [
      "self"
    ],
    "create_extended": [
      "self",
      "yield_",
      "name"
    ],
    "get_yield": [
      "self"
    ],
    "normalization": [
      "self",
      "norm"
    ],
    "as_func": [
      "self",
      "norm"
    ],
    "plot": [
      "self"
    ]
  },
  "ZfitFunctorMixin": {
    "models": [
      "self"
    ],
    "get_models": [
      "self"
    ]
  },
  "ZfitConstraint": {
    "value": [
      "self"
    ]
  },
  "ZfitMinimalHist": {
    "kind": [
      "self"
    ],
    "values": [
      "self"
    ],
    "variances": [
      "self"
    ],
    "axes": [
      "self"
    ]
  },
  "ZfitBinnedData": {
    "variances": [
      "self"
    ],
    "with_obs": [
      "self",
      "obs"
    ],
    "binning": [
      "self"
    ],
    "to_hist": [
      "self"
    ]
  },
  "ZfitBinnedPDF": {
    "counts": [
      "self",
      "x",
      "norm"
    ],
    "rel_counts": [
      "self",
      "x",
      "norm"
    ]
  },
  "ZfitBinning": {},
  "ZfitRectBinning": {
    "get_edges": [
      "self"
    ]
  },
  "ZfitSampler": {
    "__init__": [
      "self",
      "name"
    ],
    "sample": [
      "self",
      "loss",
      "params",
      "n_samples",
      "n_warmup"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ZfitPrior": {
    "__init__": [
      "self",
      "pdf",
      "name"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "log_pdf": [
      "self",
      "value"
    ],
    "sample": [
      "self",
      "n"
    ],
    "__repr__": [
      "self"
    ],
    "_register_default_param": [
      "self",
      "param"
    ]
  },
  "run": [],
  "set_seed": [
    "seed",
    "numpy",
    "backend",
    "zfit"
  ],
  "generate_urandom_seed": [],
  "_verbosity": [],
  "set_verbosity": [
    "verbosity"
  ],
  "get_verbosity": [],
  "ztypes": [],
  "upcast_ztypes": [],
  "options": [],
  "advanced_warnings": [],
  "changed_warnings": [],
  "InvalidNameError": {},
  "NameAlreadyTakenError": {
    "__init__": [
      "self"
    ]
  },
  "IpyoptPicklingError": {},
  "OutsideLimitsError": {},
  "AutogradNotSupported": {},
  "__version__": [],
  "__license__": [],
  "__copyright__": [],
  "__status__": [],
  "__author__": [],
  "__maintainer__": [],
  "__email__": [],
  "__credits__": [],
  "_suppress_stderr": [],
  "_maybe_disable_warnings": [],
  "_maybe_disable_jit": [],
  "nll_gaussian": [
    "params",
    "observation",
    "uncertainty"
  ],
  "dumps": [
    "obj"
  ],
  "loads": [
    "string"
  ],
  "dump": [],
  "load": [],
  "from_numpy": [],
  "from_pandas": [],
  "from_root": [],
  "from_binned_tensor": [],
  "from_hist": [],
  "poisson": [
    "n",
    "pdfs"
  ],
  "_NONE": [],
  "ZfitDillDumpError": {},
  "ZfitDillLoadError": {},
  "__retry_with_gc": [
    "func",
    "kwargs"
  ],
  "__retry_with_graphclear": [
    "func",
    "kwargs",
    "max_retries",
    "_file_to_reset"
  ],
  "TYPE_CHECKING": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "__commit_id__": [],
  "commit_id": [],
  "Variable": {
    "__init__": [
      "self",
      "name"
    ],
    "name": [
      "self"
    ]
  },
  "SpaceV2": {
    "__init__": [
      "self",
      "axes"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__iter__": [
      "self"
    ],
    "names": [
      "self"
    ]
  },
  "to_var_str": [
    "value"
  ],
  "Axis": {
    "__init__": [
      "self",
      "name"
    ]
  },
  "UnbinnedAxis": {
    "__init__": [
      "self",
      "name",
      "lower",
      "upper"
    ]
  },
  "HashableAxisMixin": {
    "__init__": [
      "self"
    ],
    "__hash__": [
      "self"
    ]
  },
  "RegularBinning": {
    "__init__": [
      "self",
      "bins",
      "start",
      "stop"
    ]
  },
  "VariableBinning": {
    "__init__": [
      "self",
      "edges"
    ]
  },
  "Binnings": {},
  "HIST_BINNING_TYPES": [],
  "histaxis_to_axis": [
    "axis"
  ],
  "axis_to_histaxis": [
    "axis"
  ],
  "new_from_axis": [
    "axis"
  ],
  "histaxes_to_binning": [
    "binnings"
  ],
  "binning_to_histaxes": [
    "binnings"
  ],
  "VarSupports": {
    "__init__": [
      "self",
      "var"
    ]
  },
  "ZfitResult": {
    "hesse": [
      "self",
      "params",
      "method"
    ],
    "errors": [
      "self",
      "params",
      "method",
      "cl"
    ],
    "minimizer": [
      "self"
    ],
    "params": [
      "self"
    ],
    "fminopt": [
      "self"
    ],
    "loss": [
      "self"
    ]
  },
  "ZfitMinimizer": {
    "minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "step": [
      "self",
      "loss",
      "params"
    ],
    "tol": [
      "self"
    ]
  },
  "NewMinimum": {},
  "FailEvalLossNaN": {},
  "RootFound": {},
  "WeightCorr": {},
  "compute_errors": [
    "result",
    "params"
  ],
  "numerical_pdf_jacobian": [
    "func",
    "params"
  ],
  "autodiff_pdf_jacobian": [
    "func",
    "params"
  ],
  "covariance_with_weights": [
    "hinv",
    "result",
    "params"
  ],
  "dict_to_matrix": [
    "params",
    "matrix_dict"
  ],
  "matrix_to_dict": [
    "params",
    "matrix"
  ],
  "np_cache": [],
  "assign_values_func": [
    "params",
    "values"
  ],
  "check_derivative_none_raise": [
    "values",
    "params"
  ],
  "LossEval": {
    "__init__": [
      "self",
      "loss",
      "params",
      "strategy",
      "do_print",
      "maxiter",
      "grad_fn",
      "hesse_fn",
      "numpy_converter",
      "full"
    ],
    "niter": [
      "self"
    ],
    "maxiter_reached": [
      "self"
    ],
    "_check_maxiter_reached": [
      "self"
    ],
    "ignore_maxiter": [
      "self"
    ],
    "ignoring_maxiter": [
      "self"
    ],
    "nfunc_eval": [
      "self",
      "value"
    ],
    "ngrad_eval": [
      "self",
      "value"
    ],
    "nhess_eval": [
      "self",
      "value"
    ],
    "value_gradient": [
      "self",
      "values"
    ],
    "_assign_and_value": [
      "self",
      "values"
    ],
    "value": [
      "self",
      "values"
    ],
    "gradient": [
      "self",
      "values"
    ],
    "hessian": [
      "self",
      "values"
    ]
  },
  "print_params": [
    "params",
    "values",
    "loss"
  ],
  "print_gradient": [
    "params",
    "values",
    "gradient",
    "loss"
  ],
  "NLoptBaseMinimizer": {
    "_ALL_NLOPT_TOL": [],
    "__init__": [
      "self",
      "algorithm",
      "tol",
      "gradient",
      "hessian",
      "maxiter",
      "minimizer_options",
      "internal_tols",
      "verbosity",
      "strategy",
      "criterion",
      "name"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_set_tols_inplace": [
      "self",
      "minimizer",
      "internal_tol",
      "criterion_value"
    ]
  },
  "NLoptLBFGS": {
    "__init__": [
      "self",
      "tol",
      "maxcor",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptShiftVar": {
    "__init__": [
      "self",
      "tol",
      "maxcor",
      "rank",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptTruncNewton": {
    "__init__": [
      "self",
      "tol",
      "maxcor",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptSLSQP": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptBOBYQA": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptMMA": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptCCSAQ": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptCOBYLA": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptSubplex": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptMLSL": {
    "__init__": [
      "self",
      "tol",
      "population",
      "randomized",
      "local_minimizer",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptStoGO": {
    "__init__": [
      "self",
      "tol",
      "randomized",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptESCH": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "NLoptISRES": {
    "__init__": [
      "self",
      "tol",
      "population",
      "verbosity",
      "maxiter",
      "strategy",
      "criterion",
      "name"
    ]
  },
  "DefaultStrategy": [],
  "status_messages": [],
  "minimize_supports": [],
  "_Minimizer_CHECK_HAS_SUPPORT": [],
  "_Minimizer_register_check_support": [
    "has_support"
  ],
  "BaseMinimizer": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "criterion",
      "strategy",
      "minimizer_options",
      "maxiter",
      "name"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_subclass_check_support": [
      "cls",
      "methods_to_check",
      "wrapper_not_overwritten"
    ],
    "_check_convert_input": [
      "self",
      "loss",
      "params",
      "init",
      "floating"
    ],
    "_filter_floating_params": [
      "params"
    ],
    "tol": [
      "self",
      "tol"
    ],
    "minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_call_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_is_stateful": [
      "self"
    ],
    "_make_stateful": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "copy": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "get_maxiter": [
      "self",
      "n"
    ],
    "maxiter": [
      "self"
    ],
    "create_evaluator": [
      "self",
      "loss",
      "params",
      "numpy_converter",
      "strategy"
    ],
    "_update_tol_inplace": [
      "self",
      "criterion_value",
      "internal_tol"
    ],
    "create_criterion": [
      "self",
      "loss",
      "params"
    ],
    "_recover_result": [
      "self",
      "prelim_result"
    ]
  },
  "BaseStepMinimizer": {
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "step": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_step": [
      "self",
      "loss",
      "params",
      "init"
    ]
  },
  "NOT_SUPPORTED": {
    "__new__": [
      "cls"
    ]
  },
  "print_minimization_status": [
    "converged",
    "criterion",
    "evaluator",
    "i",
    "fminopt",
    "internal_tol"
  ],
  "OptimizeStop": {},
  "LevenbergMarquardt": {
    "_DEFAULT_name": [],
    "__init__": [
      "self",
      "tol",
      "mode",
      "rho_min",
      "rho_max",
      "verbosity",
      "options",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_damped_hess0": [
      "hess",
      "L"
    ],
    "_mode0_step": [
      "self",
      "loss",
      "params",
      "L"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ]
  },
  "BFGS": {
    "__init__": [
      "self",
      "strategy",
      "tol",
      "verbosity",
      "max_calls",
      "name",
      "options"
    ],
    "_minimize": [
      "self",
      "loss",
      "params"
    ]
  },
  "WrapOptimizer": {
    "__init__": [
      "self",
      "optimizer",
      "tol",
      "criterion",
      "strategy",
      "verbosity",
      "name"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_step": [
      "self",
      "loss",
      "params",
      "init"
    ]
  },
  "ConvergenceCriterion": {
    "__init__": [
      "self",
      "tol",
      "loss",
      "params",
      "name"
    ],
    "converged": [
      "self",
      "result"
    ],
    "calculate": [
      "self",
      "result"
    ],
    "_calculate": [
      "self",
      "result"
    ],
    "__repr__": [
      "self"
    ]
  },
  "calculate_edm": [
    "grad",
    "inv_hesse"
  ],
  "calculate_edm_hesse": [
    "grad",
    "hessian"
  ],
  "EDM": {
    "__init__": [
      "self",
      "tol",
      "loss",
      "params",
      "name"
    ],
    "_calculate": [
      "self",
      "result"
    ]
  },
  "CriterionNotAvailable": {
    "__bool__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__pow__": [
      "self",
      "power",
      "modulo"
    ],
    "__repr__": [
      "self"
    ],
    "__hash__": [
      "self"
    ]
  },
  "CRITERION_NOT_AVAILABLE": [],
  "Adam": {
    "_DEFAULT_name": [],
    "__init__": [
      "self",
      "tol",
      "learning_rate",
      "beta1",
      "beta2",
      "epsilon",
      "name"
    ]
  },
  "FailMinimizeNaN": {},
  "ZfitStrategy": {
    "minimize_nan": [
      "self",
      "loss",
      "params",
      "values"
    ],
    "callback": [
      "self",
      "value",
      "gradient",
      "hessian",
      "params",
      "loss"
    ]
  },
  "BaseStrategy": {
    "__init__": [
      "self"
    ],
    "minimize_nan": [
      "self",
      "loss",
      "params",
      "values"
    ],
    "callback": [
      "self",
      "value",
      "gradient",
      "hessian",
      "params",
      "loss"
    ],
    "__str__": [
      "self"
    ]
  },
  "ToyStrategyFail": {
    "__init__": [
      "self"
    ],
    "minimize_nan": [
      "self",
      "loss",
      "params",
      "values"
    ]
  },
  "make_pushback_strategy": [
    "nan_penalty",
    "nan_tol",
    "base"
  ],
  "PushbackStrategy": [],
  "DefaultToyStrategy": {},
  "ScipyBaseMinimizer": {
    "_VALID_SCIPY_GRADIENT": [],
    "_VALID_SCIPY_HESSIAN": [],
    "__init__": [
      "self",
      "method",
      "tol",
      "internal_tol",
      "gradient",
      "hessian",
      "maxiter",
      "minimizer_options",
      "verbosity",
      "strategy",
      "criterion",
      "minimize_func",
      "initializer",
      "verbosity_setter",
      "name"
    ],
    "_add_derivative_methods": [
      "cls",
      "gradient",
      "hessian"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_arguments_supports_bounds": [
      "self"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ]
  },
  "ScipyLBFGSB": {
    "__init__": [
      "self",
      "tol",
      "maxcor",
      "maxls",
      "verbosity",
      "gradient",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipyBFGS": {
    "__init__": [
      "self",
      "tol",
      "c1",
      "c2",
      "verbosity",
      "gradient",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_arguments_supports_bounds": [
      "self"
    ]
  },
  "ScipyTrustKrylov": {
    "__init__": [
      "self",
      "tol",
      "inexact",
      "gradient",
      "hessian",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_arguments_supports_bounds": [
      "self"
    ]
  },
  "ScipyTrustNCG": {
    "__init__": [
      "self",
      "tol",
      "init_trust_radius",
      "eta",
      "max_trust_radius",
      "gradient",
      "hessian",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_arguments_supports_bounds": [
      "self"
    ]
  },
  "ScipyTrustConstr": {
    "__init__": [
      "self",
      "tol",
      "init_trust_radius",
      "gradient",
      "hessian",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipyNewtonCG": {
    "__init__": [
      "self",
      "tol",
      "gradient",
      "hessian",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_arguments_supports_bounds": [
      "self"
    ]
  },
  "ScipyTruncNC": {
    "__init__": [
      "self",
      "tol",
      "maxcg",
      "maxls",
      "eta",
      "rescale",
      "gradient",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipyDogleg": {
    "__init__": [
      "self",
      "tol",
      "init_trust_radius",
      "eta",
      "max_trust_radius",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_arguments_supports_bounds": [
      "self"
    ]
  },
  "ScipyPowell": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipySLSQP": {
    "__init__": [
      "self",
      "tol",
      "gradient",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipyCOBYLA": {
    "__init__": [
      "self",
      "tol",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "ScipyNelderMead": {
    "__init__": [
      "self",
      "tol",
      "adaptive",
      "verbosity",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ]
  },
  "combine_optimize_results": [
    "results"
  ],
  "Minuit": {
    "_DEFAULT_name": [],
    "__init__": [
      "self",
      "tol",
      "mode",
      "gradient",
      "verbosity",
      "options",
      "maxiter",
      "criterion",
      "strategy",
      "name",
      "use_minuit_grad",
      "minuit_grad",
      "minimize_strategy",
      "ncall",
      "minimizer_options"
    ],
    "_use_tfgrad": [
      "self"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "_make_minuit": [
      "self",
      "loss",
      "params",
      "init"
    ],
    "copy": [
      "self"
    ]
  },
  "Ipyopt": {
    "_ALL_IPOPT_TOL": [],
    "__init__": [
      "self",
      "tol",
      "maxcor",
      "verbosity",
      "hessian",
      "options",
      "maxiter",
      "criterion",
      "strategy",
      "name"
    ],
    "_minimize": [
      "self",
      "loss",
      "params",
      "init"
    ]
  },
  "Approximations": {
    "__init__": [
      "self",
      "params",
      "gradient",
      "hessian",
      "inv_hessian"
    ],
    "params": [
      "self"
    ],
    "gradient": [
      "self",
      "params"
    ],
    "hessian": [
      "self",
      "invert"
    ],
    "inv_hessian": [
      "self",
      "invert"
    ],
    "freeze": [
      "self"
    ]
  },
  "_minos_minuit": [
    "result",
    "params",
    "cl"
  ],
  "_covariance_minuit": [
    "result",
    "params"
  ],
  "_covariance_np": [
    "result",
    "params"
  ],
  "_covariance_approx": [
    "result",
    "params"
  ],
  "ParamToNameGetitem": {
    "__slots__": [],
    "__getitem__": [
      "self",
      "item"
    ]
  },
  "NameToParamGetitem": {
    "__slots__": [],
    "__getitem__": [
      "self",
      "item"
    ],
    "__contains__": [
      "self",
      "item"
    ]
  },
  "OptimizeResultMixin": {
    "success": [
      "self"
    ],
    "fun": [
      "self"
    ],
    "jac": [
      "self"
    ],
    "hess": [
      "self"
    ],
    "hess_inv": [
      "self"
    ],
    "nfev": [
      "self"
    ],
    "njev": [
      "self"
    ],
    "nhev": [
      "self"
    ],
    "nit": [
      "self"
    ],
    "maxcv": [
      "self"
    ]
  },
  "FitResult": {
    "_default_hesse": [],
    "_default_error": [],
    "__init__": [
      "self",
      "loss",
      "params",
      "minimizer",
      "valid",
      "edm",
      "fminopt",
      "criterion",
      "status",
      "converged",
      "message",
      "info",
      "approx",
      "niter",
      "evaluator"
    ],
    "_input_convert_approx": [
      "self",
      "approx",
      "evaluator",
      "info",
      "params"
    ],
    "_input_convert_params": [
      "self",
      "params"
    ],
    "_check_get_uncached_params": [
      "self",
      "params",
      "method_name",
      "cl",
      "weightcorr"
    ],
    "_create_minuit_instance": [
      "self"
    ],
    "from_ipopt": [
      "cls",
      "loss",
      "params",
      "problem",
      "minimizer",
      "valid",
      "values",
      "message",
      "converged",
      "edm",
      "niter",
      "fminopt",
      "status",
      "criterion",
      "evaluator"
    ],
    "from_minuit": [
      "cls",
      "loss",
      "params",
      "minuit",
      "minimizer",
      "valid",
      "values",
      "message",
      "converged",
      "edm",
      "niter",
      "fminopt",
      "status",
      "criterion",
      "evaluator"
    ],
    "from_scipy": [
      "cls",
      "loss",
      "params",
      "result",
      "minimizer",
      "message",
      "valid",
      "criterion",
      "edm",
      "niter",
      "evaluator"
    ],
    "from_nlopt": [
      "cls",
      "loss",
      "opt",
      "params",
      "minimizer",
      "valid",
      "values",
      "message",
      "converged",
      "edm",
      "niter",
      "fminopt",
      "status",
      "criterion",
      "evaluator",
      "inv_hessian",
      "hessian"
    ],
    "approx": [
      "self"
    ],
    "params": [
      "self"
    ],
    "values": [
      "self"
    ],
    "criterion": [
      "self"
    ],
    "message": [
      "self"
    ],
    "edm": [
      "self"
    ],
    "minimizer": [
      "self"
    ],
    "loss": [
      "self"
    ],
    "fminopt": [
      "self"
    ],
    "fmin": [
      "self"
    ],
    "fminfull": [
      "self"
    ],
    "status": [
      "self"
    ],
    "info": [
      "self"
    ],
    "converged": [
      "self"
    ],
    "valid": [
      "self"
    ],
    "x": [
      "self"
    ],
    "params_at_limit": [
      "self"
    ],
    "_input_check_reset_params": [
      "self",
      "params"
    ],
    "_input_check_params": [
      "self",
      "params"
    ],
    "hesse": [
      "self",
      "params",
      "method"
    ],
    "_cache_errors": [
      "self",
      "name",
      "errors"
    ],
    "_hesse": [
      "self",
      "params",
      "method",
      "cl",
      "weightcorr"
    ],
    "error": [
      "self",
      "params",
      "method",
      "error_name",
      "sigma"
    ],
    "errors": [
      "self",
      "params",
      "method",
      "name",
      "cl"
    ],
    "_error": [
      "self",
      "params",
      "method",
      "cl"
    ],
    "covariance": [
      "self",
      "params",
      "method",
      "as_dict"
    ],
    "_covariance": [
      "self",
      "method"
    ],
    "correlation": [
      "self",
      "params",
      "method",
      "as_dict"
    ],
    "freeze": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_repr_pretty_": [
      "self",
      "p",
      "cycle"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "update_params": [
      "self"
    ]
  },
  "covariance_to_correlation": [
    "covariance"
  ],
  "format_value": [
    "value",
    "highprec"
  ],
  "color_on_bool": [
    "value",
    "on_true",
    "on_false"
  ],
  "ListWithKeys": {
    "__slots__": [],
    "__init__": [
      "self",
      "initdict"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "keys": [
      "self"
    ],
    "values": [
      "self"
    ],
    "items": [
      "self"
    ]
  },
  "ValuesHolder": {
    "__slots__": []
  },
  "ParamHolder": {
    "__str__": [
      "self"
    ]
  },
  "BaseMCMCSampler": {
    "__init__": [
      "self"
    ],
    "_print": [
      "self"
    ],
    "sample": [
      "self",
      "loss",
      "params",
      "n_samples",
      "n_warmup",
      "init"
    ],
    "_sample": [
      "self",
      "loss",
      "params",
      "n_samples",
      "n_warmup",
      "init"
    ]
  },
  "EmceeSampler": {
    "__init__": [
      "self",
      "nwalkers"
    ],
    "_sample": [
      "self",
      "loss",
      "params",
      "n_samples",
      "n_warmup",
      "init"
    ],
    "_adapt_walker_positions": [
      "self",
      "positions",
      "nwalkers",
      "n_dims"
    ],
    "_extract_positions_from_samples": [
      "self",
      "init",
      "params",
      "nwalkers",
      "n_dims"
    ]
  },
  "convert_hist2binneddata": [
    "data"
  ],
  "BinnedHolder": {
    "__init__": [
      "self",
      "space",
      "values",
      "variances"
    ],
    "_check_init_values": [
      "self",
      "space",
      "values",
      "variances"
    ],
    "from_hist": [
      "cls",
      "h"
    ],
    "with_obs": [
      "self",
      "obs"
    ],
    "with_variances": [
      "self",
      "variances"
    ]
  },
  "move_axis_obs": [
    "original",
    "target",
    "values",
    "variances"
  ],
  "flow": [],
  "BinnedData": {
    "USE_HASH": [],
    "__init__": [
      "self"
    ],
    "with_variances": [
      "self",
      "variances"
    ],
    "enable_hashing": [
      "self"
    ],
    "_using_hash": [
      "self"
    ],
    "from_tensor": [
      "cls",
      "space",
      "values",
      "variances",
      "name",
      "label",
      "use_hash"
    ],
    "from_unbinned": [
      "cls",
      "space",
      "data"
    ],
    "from_hist": [
      "cls",
      "h"
    ],
    "with_obs": [
      "self",
      "obs"
    ],
    "_update_hash": [
      "self"
    ],
    "hashint": [
      "self"
    ],
    "kind": [
      "self"
    ],
    "n_obs": [
      "self"
    ],
    "rank": [
      "self"
    ],
    "obs": [
      "self"
    ],
    "to_hist": [
      "self"
    ],
    "_to_boost_histogram_": [
      "self"
    ],
    "space": [
      "self"
    ],
    "axes": [
      "self"
    ],
    "binning": [
      "self"
    ],
    "values": [
      "self"
    ],
    "variances": [
      "self"
    ],
    "counts": [
      "self"
    ],
    "data_range": [
      "self"
    ],
    "num_entries": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "samplesize": [
      "self"
    ],
    "nevents": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "_approx_nevents": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "to_unbinned": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_repr_html_": [
      "self"
    ]
  },
  "BinnedSamplerData": {
    "_cache_counting": [],
    "__init__": [
      "self",
      "h"
    ],
    "fixed_params": [
      "self"
    ],
    "n_samples": [
      "self"
    ],
    "_approx_nevents": [
      "self"
    ],
    "hashint": [
      "self"
    ],
    "_update_hash": [
      "self"
    ],
    "get_cache_counting": [
      "cls"
    ],
    "from_sample": [
      "cls",
      "sample_func",
      "n",
      "obs",
      "fixed_params"
    ],
    "from_sampler": [
      "cls"
    ],
    "resample": [
      "self",
      "params"
    ],
    "update_data": [
      "self",
      "sample",
      "variances"
    ],
    "values": [
      "self"
    ],
    "variances": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "UnbinnedData": {
    "__init__": [
      "self",
      "data",
      "space",
      "weights"
    ],
    "is_binned": [
      "self"
    ],
    "is_unbinned": [
      "self"
    ],
    "space": [
      "self"
    ],
    "data": [
      "self"
    ],
    "weights": [
      "self"
    ],
    "values": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "has_weights": [
      "self"
    ]
  },
  "_spd_transform": [
    "values",
    "probs",
    "variances"
  ],
  "poisson_loss_calc": [
    "probs",
    "values",
    "log_offset",
    "variances"
  ],
  "BaseBinned": {
    "__init__": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ],
    "create_new": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ]
  },
  "ExtendedBinnedNLL": {
    "__init__": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ]
  },
  "BinnedNLL": {
    "__init__": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ]
  },
  "chi2_loss_calc": [
    "probs",
    "values",
    "variances",
    "log_offset",
    "ignore_empty"
  ],
  "_check_small_counts_chi2": [
    "data",
    "ignore_empty"
  ],
  "BinnedChi2": {
    "__init__": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ],
    "check_precompile": [
      "self"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ]
  },
  "ExtendedBinnedChi2": {
    "__init__": [
      "self",
      "model",
      "data",
      "constraints",
      "options"
    ],
    "check_precompile": [
      "self"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ]
  },
  "poly_complex": [],
  "numerical_gradient": [
    "func",
    "params"
  ],
  "numerical_value_gradient": [
    "func",
    "params"
  ],
  "numerical_value_gradients": [],
  "numerical_hessian": [
    "func",
    "params",
    "hessian"
  ],
  "numerical_value_gradient_hessian": [
    "func",
    "params",
    "gradient",
    "hessian"
  ],
  "numerical_value_gradients_hessian": [],
  "autodiff_gradient": [
    "func",
    "params"
  ],
  "_extract_tfparams": [
    "params"
  ],
  "autodiff_value_gradient": [
    "func",
    "params"
  ],
  "autodiff_value_gradients": [],
  "autodiff_hessian": [
    "func",
    "params",
    "hessian"
  ],
  "automatic_value_gradient_hessian": [
    "func",
    "params",
    "value_grad_func",
    "hessian"
  ],
  "automatic_value_gradients_hessian": [],
  "reduce_geometric_mean": [
    "input_tensor",
    "axis",
    "weights",
    "keepdims"
  ],
  "log": [
    "x"
  ],
  "weighted_quantile": [
    "x",
    "quantiles",
    "weights",
    "side"
  ],
  "SWITCH_ON": [],
  "is_tensor": [
    "x"
  ],
  "has_tensor": [
    "x"
  ],
  "allclose_anyaware": [
    "x",
    "y",
    "rtol",
    "atol"
  ],
  "broadcast_to": [
    "input",
    "shape"
  ],
  "expand_dims": [
    "input",
    "axis"
  ],
  "reduce_prod": [
    "input_tensor",
    "axis",
    "keepdims"
  ],
  "equal": [
    "x",
    "y"
  ],
  "reduce_all": [
    "input_tensor",
    "axis"
  ],
  "reduce_any": [
    "input_tensor",
    "axis"
  ],
  "logical_and": [
    "x",
    "y"
  ],
  "logical_or": [
    "x",
    "y"
  ],
  "less_equal": [
    "x",
    "y"
  ],
  "greater_equal": [
    "x",
    "y"
  ],
  "gather": [
    "x",
    "indices",
    "axis"
  ],
  "concat": [
    "values",
    "axis"
  ],
  "_try_convert_numpy": [
    "tensorlike"
  ],
  "linalg": {
    "inv": [],
    "det": [],
    "solve": []
  },
  "faddeeva_humlicek": [
    "z",
    "s"
  ],
  "constant": [
    "value",
    "dtype",
    "shape",
    "name",
    "verify_shape"
  ],
  "pi": [],
  "to_complex": [
    "number",
    "dtype"
  ],
  "to_real": [
    "x",
    "dtype"
  ],
  "abs_square": [
    "x"
  ],
  "nth_pow": [
    "x",
    "n"
  ],
  "unstack_x": [
    "value",
    "num",
    "axis",
    "always_list",
    "name"
  ],
  "stack_x": [
    "values",
    "axis",
    "name"
  ],
  "convert_to_tensor": [
    "value",
    "dtype",
    "name",
    "preferred_dtype"
  ],
  "safe_where": [
    "condition",
    "func",
    "safe_func",
    "values",
    "value_safer"
  ],
  "run_no_nan": [
    "func",
    "x"
  ],
  "DoNotCompile": {},
  "DEFAULT_XLAJIT_KWARGS": [],
  "DEFAULT_NOXLAJIT_KWARGS": [],
  "FunctionWrapperRegistry": {
    "registries": [],
    "allow_jit": [],
    "DEFAULT_CACHE_SIZE": [],
    "do_jit_types": [],
    "__init__": [
      "self",
      "wraps"
    ],
    "do_jit": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "set_graph_cache_size": [
      "self",
      "cachesize"
    ],
    "tf_function": [
      "self"
    ],
    "__call__": [
      "self",
      "func"
    ]
  },
  "function": [
    "func"
  ],
  "py_function": [
    "func",
    "inp",
    "Tout",
    "name"
  ],
  "Number": [],
  "TensorLike": [],
  "FloatTensorLike": [],
  "EPSILON": [],
  "_cross_squared_distance_matrix": [
    "x",
    "y"
  ],
  "_pairwise_squared_distance_matrix": [
    "x"
  ],
  "_solve_interpolation": [
    "train_points",
    "train_values",
    "order",
    "regularization_weight"
  ],
  "_apply_interpolation": [
    "query_points",
    "train_points",
    "w",
    "v",
    "order"
  ],
  "_phi": [
    "r",
    "order"
  ],
  "interpolate_spline": [
    "train_points",
    "train_values",
    "query_points",
    "order",
    "regularization_weight",
    "name"
  ],
  "_auto_upcast": [
    "tensor"
  ],
  "_get_ndims": [
    "x"
  ],
  "exp": [
    "x"
  ],
  "random_normal": [],
  "random_uniform": [],
  "random_poisson": [],
  "square": [
    "x",
    "name"
  ],
  "sqrt": [
    "x",
    "name"
  ],
  "pow": [
    "x",
    "y",
    "name"
  ],
  "complex": [
    "real",
    "imag",
    "name"
  ],
  "check_numerics": [
    "tensor",
    "message",
    "name"
  ],
  "assert_all_finite": [
    "t",
    "msg"
  ],
  "assert_positive": [
    "t",
    "msg"
  ],
  "assert_non_negative": [
    "t",
    "msg"
  ],
  "assert_equal": [
    "t1",
    "t2",
    "message"
  ],
  "assert_greater_equal": [
    "x",
    "y",
    "msg"
  ],
  "assert_greater": [
    "x",
    "y",
    "message"
  ],
  "assert_less": [
    "x",
    "y",
    "message"
  ],
  "reduce_sum": [],
  "generator": [],
  "get_prng": [],
  "sample_with_replacement": [
    "a",
    "axis",
    "sample_shape"
  ],
  "counts_multinomial": [
    "total_count",
    "probs",
    "logits",
    "dtype"
  ],
  "_wrapped_multinomial_func": [
    "dtype",
    "logits",
    "probs",
    "total_count"
  ],
  "normal": [
    "shape",
    "mean",
    "stddev",
    "dtype",
    "name"
  ],
  "uniform": [
    "shape",
    "minval",
    "maxval",
    "dtype",
    "name"
  ],
  "shuffle": [
    "value",
    "seed",
    "name"
  ],
  "extract_daughter_input_obs": [
    "obs",
    "spaces"
  ],
  "FunctorMixin": {
    "__init__": [
      "self",
      "models",
      "obs"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "models": [
      "self"
    ],
    "_model_same_obs": [
      "self"
    ],
    "get_models": [
      "self",
      "names"
    ],
    "_check_input_norm_default": [
      "self",
      "norm",
      "caller_name",
      "none_is_error"
    ]
  },
  "FunctorPDFRepr": {
    "_implementation": [],
    "validate_all_functor": [
      "cls",
      "values"
    ]
  },
  "_extract_common_obs": [
    "obs"
  ],
  "_preprocess_init_sum": [
    "fracs",
    "obs",
    "pdfs"
  ],
  "HistogramPDF": {
    "__init__": [
      "self",
      "data",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ]
  },
  "preprocess_pdf_or_hist": [
    "models"
  ],
  "BaseBinnedFunctorPDF": {
    "__init__": [
      "self",
      "models",
      "obs"
    ]
  },
  "BinnedSumPDF": {
    "__init__": [
      "self",
      "pdfs",
      "fracs",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ]
  },
  "PositivePDF": {
    "__init__": [
      "self",
      "pdf",
      "epsilon",
      "obs",
      "extended",
      "norm",
      "name"
    ],
    "_ensure_positive": [
      "self",
      "value"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "PositivePDFRepr": {
    "_implementation": []
  },
  "get_value": [
    "cache",
    "flag",
    "func"
  ],
  "CachedPDF": {
    "__init__": [
      "self",
      "pdf"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ]
  },
  "CachedPDFRepr": {
    "_implementation": [],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "Exponential": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "lam",
      "obs"
    ],
    "_unnormalized_pdf": [
      "self",
      "x",
      "params"
    ],
    "_shift_x": [
      "self",
      "x"
    ],
    "_set_numerics_data_shift": [
      "self",
      "limits"
    ],
    "_single_hook_integrate": [
      "self",
      "limits",
      "norm",
      "x",
      "options"
    ],
    "_single_hook_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_single_hook_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_single_hook_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_single_hook_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_single_hook_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_single_hook_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_single_hook_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_single_hook_sample": [
      "self",
      "n",
      "limits",
      "x"
    ]
  },
  "_exp_integral_from_any_to_any": [
    "limits",
    "params",
    "model"
  ],
  "_exp_integral_func_shifting": [
    "lambd",
    "lower",
    "upper",
    "model"
  ],
  "exp_icdf": [
    "x",
    "params",
    "model"
  ],
  "limits": [],
  "ExponentialPDFRepr": {
    "_implementation": []
  },
  "Voigt": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "m",
      "sigma",
      "gamma",
      "obs"
    ],
    "_unnormalized_pdf": [
      "self",
      "x",
      "params"
    ]
  },
  "_voigt_integral_from_inf_to_inf": [
    "limits",
    "params",
    "model"
  ],
  "VoigtPDFRepr": {
    "_implementation": []
  },
  "_powerlaw": [
    "x",
    "a",
    "k"
  ],
  "crystalball_func": [
    "x",
    "mu",
    "sigma",
    "alpha",
    "n"
  ],
  "double_crystalball_func": [
    "x",
    "mu",
    "sigma",
    "alphal",
    "nl",
    "alphar",
    "nr"
  ],
  "generalized_crystalball_func": [
    "x",
    "mu",
    "sigmal",
    "alphal",
    "nl",
    "sigmar",
    "alphar",
    "nr"
  ],
  "crystalball_integral": [
    "limits",
    "params",
    "model"
  ],
  "crystalball_integral_func": [
    "mu",
    "sigma",
    "alpha",
    "n",
    "lower",
    "upper"
  ],
  "double_crystalball_mu_integral": [
    "limits",
    "params",
    "model"
  ],
  "double_crystalball_mu_integral_func": [
    "mu",
    "sigma",
    "alphal",
    "nl",
    "alphar",
    "nr",
    "lower",
    "upper"
  ],
  "generalized_crystalball_mu_integral": [
    "limits",
    "params",
    "model"
  ],
  "generalized_crystalball_mu_integral_func": [
    "mu",
    "sigmal",
    "alphal",
    "nl",
    "sigmar",
    "alphar",
    "nr",
    "lower",
    "upper"
  ],
  "CrystalBall": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "alpha",
      "n",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "CrystalBallPDFRepr": {
    "_implementation": []
  },
  "crystalball_integral_limits": [],
  "DoubleCB": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "alphal",
      "nl",
      "alphar",
      "nr",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "DoubleCBPDFRepr": {
    "_implementation": []
  },
  "GeneralizedCB": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigmal",
      "alphal",
      "nl",
      "sigmar",
      "alphar",
      "nr",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "GeneralizedCBPDFRepr": {
    "_implementation": []
  },
  "gaussexptail_func": [
    "x",
    "mu",
    "sigma",
    "alpha"
  ],
  "generalized_gaussexptail_func": [
    "x",
    "mu",
    "sigmal",
    "alphal",
    "sigmar",
    "alphar"
  ],
  "gaussexptail_integral": [
    "limits",
    "params",
    "model"
  ],
  "gaussexptail_integral_func": [
    "mu",
    "sigma",
    "alpha",
    "lower",
    "upper"
  ],
  "generalized_gaussexptail_integral": [
    "limits",
    "params",
    "model"
  ],
  "generalized_gaussexptail_integral_func": [
    "mu",
    "sigmal",
    "alphal",
    "sigmar",
    "alphar",
    "lower",
    "upper"
  ],
  "GaussExpTail": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "alpha",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "GaussExpTailPDFRepr": {
    "_implementation": []
  },
  "gaussexptail_integral_limits": [],
  "GeneralizedGaussExpTail": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigmal",
      "alphal",
      "sigmar",
      "alphar",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "GeneralizedGaussExpTailPDFRepr": {
    "_implementation": []
  },
  "BaseFunctor": {
    "__init__": [
      "self",
      "pdfs",
      "name",
      "label"
    ],
    "_set_norm_from_daugthers": [
      "self"
    ],
    "pdfs_extended": [
      "self"
    ]
  },
  "SumPDF": {
    "__init__": [
      "self",
      "pdfs",
      "fracs",
      "obs",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "fracs": [
      "self"
    ],
    "_apply_yield": [
      "self",
      "value",
      "norm",
      "log"
    ],
    "_unnormalized_pdf": [
      "self",
      "x",
      "params"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_ext_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm",
      "options"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "SumPDFRepr": {
    "_implementation": [],
    "validate_all_sumpdf": [
      "cls",
      "values"
    ]
  },
  "ProductPDF": {
    "__init__": [
      "self",
      "pdfs",
      "obs",
      "extended",
      "norm",
      "name"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "ProductPDFRepr": {
    "_implementation": []
  },
  "rescale_minus_plus_one": [
    "x",
    "limits"
  ],
  "RecursivePolynomial": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_polynomials_rescale": [
      "self",
      "x"
    ],
    "apply_scaling": [
      "self"
    ],
    "degree": [
      "self"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "BaseRecursivePolynomialRepr": {
    "convert_params": [
      "cls",
      "values"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "create_poly": [
    "x",
    "polys",
    "coeffs",
    "recurrence"
  ],
  "do_recurrence": [
    "x",
    "polys",
    "degree",
    "recurrence"
  ],
  "legendre_polys": [],
  "legendre_recurrence": [
    "p1",
    "p2",
    "n",
    "x"
  ],
  "legendre_shape": [
    "x",
    "coeffs"
  ],
  "legendre_integral": [
    "limits",
    "norm",
    "params",
    "model"
  ],
  "Legendre": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "LegendreRepr": {
    "_implementation": []
  },
  "legendre_limits": [],
  "chebyshev_polys": [],
  "chebyshev_recurrence": [
    "p1",
    "p2",
    "_",
    "x"
  ],
  "chebyshev_shape": [
    "x",
    "coeffs"
  ],
  "Chebyshev": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "ChebyshevRepr": {
    "_implementation": []
  },
  "func_integral_chebyshev1": [
    "limits",
    "norm",
    "params",
    "model"
  ],
  "chebyshev1_limits_integral": [],
  "chebyshev2_polys": [],
  "chebyshev2_shape": [
    "x",
    "coeffs"
  ],
  "Chebyshev2": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "Chebyshev2Repr": {
    "_implementation": []
  },
  "func_integral_chebyshev2": [
    "limits",
    "norm",
    "params",
    "model"
  ],
  "chebyshev2_limits_integral": [],
  "generalized_laguerre_polys_factory": [
    "alpha"
  ],
  "laguerre_polys": [],
  "generalized_laguerre_recurrence_factory": [
    "alpha"
  ],
  "laguerre_recurrence": [],
  "generalized_laguerre_shape_factory": [
    "alpha"
  ],
  "laguerre_shape": [],
  "laguerre_shape_alpha_minusone": [],
  "Laguerre": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "LaguerreRepr": {
    "_implementation": []
  },
  "func_integral_laguerre": [
    "limits",
    "norm",
    "params",
    "model"
  ],
  "laguerre_limits_integral": [],
  "hermite_polys": [],
  "hermite_recurrence": [
    "p1",
    "p2",
    "n",
    "x"
  ],
  "hermite_shape": [
    "x",
    "coeffs"
  ],
  "Hermite": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling",
      "coeff0"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "HermiteRepr": {
    "_implementation": []
  },
  "func_integral_hermite": [
    "limits",
    "norm",
    "params",
    "model"
  ],
  "hermite_limits_integral": [],
  "rescale_zero_one": [
    "x",
    "limits"
  ],
  "de_casteljau": [
    "x",
    "coeffs"
  ],
  "bernstein_shape": [
    "x",
    "coeffs"
  ],
  "Bernstein": {
    "__init__": [
      "self",
      "obs",
      "coeffs",
      "apply_scaling"
    ],
    "_polynomials_rescale": [
      "self",
      "x"
    ],
    "apply_scaling": [
      "self"
    ],
    "degree": [
      "self"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ],
    "_poly_func": [
      "x",
      "params"
    ]
  },
  "BernsteinPDFRepr": {
    "_implementation": [],
    "convert_params": [
      "cls",
      "values"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "_coeffs_int": [
    "coeffs"
  ],
  "bernstein_integral_from_xmin_to_x": [
    "x",
    "coeffs",
    "limits"
  ],
  "func_integral_bernstein": [
    "limits",
    "params",
    "model"
  ],
  "bernstein_limits_integral": [],
  "convert_coeffs_dict_to_list": [
    "coeffs"
  ],
  "LimitsTypeInput": [],
  "FFTConvPDFV1": {
    "__init__": [
      "self",
      "func",
      "kernel",
      "n",
      "limits_func",
      "limits_kernel",
      "interpolation",
      "obs"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "conv_interpolation": [
      "self"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "FFTConvPDFV1Repr": {
    "_implementation": [],
    "validate_all": [
      "cls",
      "values"
    ]
  },
  "AddingSampleAndWeights": {
    "__init__": [
      "self",
      "func",
      "kernel",
      "limits_func",
      "limits_kernel"
    ],
    "__call__": [
      "self",
      "n_to_produce",
      "limits",
      "dtype"
    ]
  },
  "BinnedTemplatePDFV1": {
    "__init__": [
      "self",
      "data",
      "sysshape",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ]
  },
  "ConditionalPDFV1": {
    "__init__": [
      "self",
      "pdf",
      "cond"
    ],
    "cond": [
      "self"
    ],
    "_check_input_cond": [
      "self",
      "cond"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_single_hook_integrate": [
      "self",
      "limits",
      "norm",
      "x",
      "options"
    ],
    "_single_hook_sample": [
      "self",
      "n",
      "limits",
      "x"
    ],
    "copy": [
      "self"
    ]
  },
  "SimplePDF": {
    "__init__": [
      "self",
      "obs",
      "func",
      "name",
      "label",
      "norm",
      "extended"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "copy": [
      "self"
    ]
  },
  "SimpleFunctorPDF": {
    "__init__": [
      "self",
      "obs",
      "pdfs",
      "func",
      "name",
      "label",
      "norm",
      "extended"
    ]
  },
  "raise_error_if_norm_range": [
    "func"
  ],
  "ZPDF": {
    "__init__": [
      "self",
      "obs"
    ],
    "__init_subclass__": [
      "cls"
    ]
  },
  "SplinePDF": {
    "__init__": [
      "self",
      "pdf",
      "order",
      "obs"
    ],
    "order": [
      "self"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ]
  },
  "MapNotVectorized": {},
  "BinnedFromUnbinnedPDF": {
    "__init__": [
      "self",
      "pdf",
      "space"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "__str__": [
      "self"
    ]
  },
  "spline_interpolator": [
    "alpha",
    "alphas",
    "densities"
  ],
  "SplineMorphingPDF": {
    "_morphing_interpolator": [],
    "__init__": [
      "self",
      "alpha",
      "hists"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ]
  },
  "check_limits": [
    "limits",
    "obs"
  ],
  "check_overlap": [
    "limits"
  ],
  "TruncatedPDF": {
    "__init__": [
      "self",
      "pdf",
      "limits",
      "obs"
    ],
    "limits": [
      "self"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "TruncatedPDFRepr": {
    "_implementation": [],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "tfd_analytic_sample": [
    "n",
    "dist",
    "limits"
  ],
  "WrapDistribution": {
    "__init__": [
      "self",
      "distribution",
      "dist_params",
      "obs",
      "params",
      "dist_kwargs",
      "dtype",
      "name"
    ],
    "distribution": [
      "self"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_analytic_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "Gauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "obs"
    ]
  },
  "GaussPDFRepr": {
    "_implementation": []
  },
  "ExponentialTFP": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "tau",
      "obs",
      "name",
      "label"
    ]
  },
  "Uniform": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "low",
      "high",
      "obs"
    ]
  },
  "TruncatedGauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "low",
      "high",
      "obs"
    ]
  },
  "Cauchy": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "m",
      "gamma",
      "obs"
    ]
  },
  "CauchyPDFRepr": {
    "_implementation": []
  },
  "Poisson": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "lam",
      "obs"
    ]
  },
  "PoissonPDFRepr": {
    "_implementation": []
  },
  "LogNormal": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "obs"
    ]
  },
  "LogNormalPDFRepr": {
    "_implementation": []
  },
  "ChiSquared": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "ndof",
      "obs"
    ]
  },
  "ChiSquaredPDFRepr": {
    "_implementation": []
  },
  "StudentT": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "ndof",
      "mu",
      "sigma",
      "obs",
      "extended",
      "norm",
      "name",
      "label"
    ]
  },
  "StudentTPDFRepr": {
    "_implementation": []
  },
  "QGauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "q",
      "mu",
      "sigma",
      "obs"
    ]
  },
  "QGaussPDFRepr": {
    "_implementation": []
  },
  "BifurGauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigmal",
      "sigmar",
      "obs"
    ]
  },
  "BifurGaussPDFRepr": {
    "_implementation": []
  },
  "Gamma": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "gamma",
      "beta",
      "mu",
      "obs"
    ]
  },
  "GammaPDFRepr": {
    "_implementation": []
  },
  "JohnsonSU": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "lambd",
      "gamma",
      "delta",
      "obs"
    ]
  },
  "JohnsonSUPDFRepr": {
    "_implementation": []
  },
  "GeneralizedGauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "beta",
      "obs"
    ]
  },
  "GeneralizedGaussPDFRepr": {
    "_implementation": []
  },
  "ExpModGauss": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "lambd",
      "obs"
    ]
  },
  "ExpModGaussPDFRepr": {
    "_implementation": []
  },
  "Beta": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "alpha",
      "beta",
      "obs"
    ]
  },
  "BetaPDFRepr": {
    "_implementation": []
  },
  "BifurKappa": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "mu",
      "kappa",
      "obs"
    ]
  },
  "BifurKappaPDFRepr": {
    "_implementation": []
  },
  "bandwidth_rule_of_thumb": [
    "data",
    "weights",
    "factor"
  ],
  "bandwidth_silverman": [
    "data",
    "weights"
  ],
  "bandwidth_scott": [
    "data",
    "weights"
  ],
  "bandwidth_isj": [
    "data",
    "weights"
  ],
  "bandwidth_adaptive_geomV1": [
    "data",
    "func",
    "weights"
  ],
  "bandwidth_adaptive_zfitV1": [
    "data",
    "func",
    "weights"
  ],
  "bandwidth_adaptive_stdV1": [
    "data",
    "func",
    "weights"
  ],
  "adaptive_factory": [
    "func",
    "grid"
  ],
  "_adaptive_geom_bandwidth_grid_KDEV1": [],
  "_adaptive_geom_bandwidth_KDEV1": [],
  "_adaptive_std_bandwidth_grid_KDEV1": [],
  "_adaptive_std_bandwidth_KDEV1": [],
  "_adaptive_zfit_bandwidth_grid_KDEV1": [],
  "_adaptive_zfit_bandwidth_KDEV1": [],
  "_bandwidth_scott_KDEV1": [
    "data",
    "weights"
  ],
  "_bandwidth_silverman_KDEV1": [
    "data",
    "weights"
  ],
  "_bandwidth_isj_KDEV1": [
    "data",
    "weights"
  ],
  "check_bw_grid_shapes": [
    "bandwidth",
    "grid",
    "n_grid"
  ],
  "min_std_or_iqr": [
    "x",
    "weights"
  ],
  "calc_kernel_probs": [
    "size",
    "weights"
  ],
  "KDEHelper": {
    "_default_padding": [],
    "_default_num_grid_points": [],
    "_convert_init_data_weights_size": [
      "self",
      "data",
      "weights",
      "padding",
      "limits",
      "bandwidth"
    ],
    "_convert_input_bandwidth": [
      "self",
      "bandwidth",
      "data"
    ]
  },
  "padreflect_data_weights_1dim": [
    "data",
    "mode",
    "weights",
    "limits",
    "bandwidth"
  ],
  "GaussianKDE1DimV1": {
    "_N_OBS": [],
    "_bandwidth_methods": [],
    "__init__": [
      "self",
      "obs",
      "data",
      "bandwidth",
      "weights",
      "truncate"
    ]
  },
  "KDE1DimExact": {
    "_bandwidth_methods": [],
    "__init__": [
      "self",
      "data"
    ],
    "_pdf": [
      "self",
      "x",
      "norm",
      "params"
    ]
  },
  "KDE1DimExactRepr": {
    "_implementation": [],
    "validate_kernel": [
      "cls",
      "v"
    ],
    "validate_all": [
      "cls",
      "values"
    ]
  },
  "KDE1DimGrid": {
    "_N_OBS": [],
    "_bandwidth_methods": [],
    "__init__": [
      "self",
      "data"
    ]
  },
  "bw_is_arraylike": [
    "bw",
    "allow1d"
  ],
  "KDE1DimGridRepr": {
    "_implementation": [],
    "validate_kernel": [
      "cls",
      "v"
    ],
    "validate_all": [
      "cls",
      "values"
    ]
  },
  "KDE1DimFFT": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "data"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ]
  },
  "KDE1DimFFTRepr": {
    "_implementation": [],
    "validate_kernel": [
      "cls",
      "v"
    ],
    "validate_all": [
      "cls",
      "values"
    ]
  },
  "KDE1DimISJ": {
    "_N_OBS": [],
    "__init__": [
      "self",
      "data"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ]
  },
  "KDE1DimISJRepr": {
    "_implementation": [],
    "validate_kernel": [
      "cls",
      "v"
    ],
    "validate_all": [
      "cls",
      "values"
    ]
  },
  "BinwiseScaleModifier": {
    "__init__": [
      "self",
      "pdf",
      "modifiers",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "_counts_with_modifiers": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ]
  },
  "SimpleFuncV1": {
    "__init__": [
      "self",
      "obs",
      "func",
      "name"
    ],
    "_func": [
      "self",
      "x"
    ]
  },
  "BaseFunctorFuncV1": {
    "__init__": [
      "self",
      "funcs",
      "name",
      "params"
    ]
  },
  "SumFunc": {
    "__init__": [
      "self",
      "funcs",
      "obs",
      "name"
    ],
    "_func": [
      "self",
      "x"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ]
  },
  "ProdFunc": {
    "__init__": [
      "self",
      "funcs",
      "obs",
      "name"
    ],
    "_func": [
      "self",
      "x"
    ]
  },
  "ZFuncV1": {
    "__init__": [
      "self",
      "obs",
      "name"
    ],
    "__init_subclass__": [
      "cls"
    ]
  },
  "UnbinnedFromBinnedPDF": {
    "__init__": [
      "self",
      "pdf",
      "obs"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_ext_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ]
  },
  "TypedSplinePDF": {},
  "_BasePDF_USER_IMPL_METHODS_TO_CHECK": [],
  "_BasePDF_register_check_support": [
    "has_support"
  ],
  "PDFMeta": {
    "__call__": [
      "cls"
    ]
  },
  "BasePDF": {
    "__init__": [
      "self",
      "obs",
      "params"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_check_init_norm": [
      "self",
      "norm"
    ],
    "_check_input_norm": [
      "self",
      "norm",
      "none_is_error"
    ],
    "_check_input_params_tfp": [
      "self"
    ],
    "_func_to_integrate": [
      "self",
      "x"
    ],
    "_func_to_sample_from": [
      "self",
      "x"
    ],
    "label": [
      "self"
    ],
    "norm_range": [
      "self"
    ],
    "norm": [
      "self"
    ],
    "set_norm_range": [
      "self",
      "_"
    ],
    "_normalization": [
      "self",
      "norm",
      "options"
    ],
    "normalization": [
      "self",
      "norm"
    ],
    "_single_hook_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_hook_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_call_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_fallback_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "unnormalized_pdf": [
      "self",
      "x"
    ],
    "_single_hook_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_call_unnormalized_pdf": [
      "self",
      "x"
    ],
    "ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "pdf": [
      "self",
      "x",
      "norm"
    ],
    "_single_hook_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_hook_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_norm_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_single_hook_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_hook_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_norm_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_log_normalization": [
      "self",
      "norm"
    ],
    "log_normalization": [
      "self",
      "norm"
    ],
    "_single_hook_log_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_hook_log_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_call_log_normalization": [
      "self",
      "norm",
      "options"
    ],
    "_fallback_log_normalization": [
      "self",
      "norm",
      "options"
    ],
    "ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_apply_yield": [
      "self",
      "value",
      "norm",
      "log"
    ],
    "_set_yield_inplace": [
      "self"
    ],
    "create_extended": [
      "self",
      "yield_",
      "name"
    ],
    "to_positive": [
      "self",
      "epsilon",
      "name"
    ],
    "to_cached": [
      "self",
      "epsilon",
      "name"
    ],
    "set_yield": [
      "self",
      "value"
    ],
    "_set_yield": [
      "self",
      "value"
    ],
    "is_extended": [
      "self"
    ],
    "_hook_sample": [
      "self",
      "limits",
      "n"
    ],
    "get_yield": [
      "self"
    ],
    "extended": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_get_autograd_params": [
      "self"
    ],
    "create_projection_pdf": [
      "self"
    ],
    "copy": [
      "self"
    ],
    "as_func": [
      "self",
      "norm"
    ],
    "__str__": [
      "self"
    ],
    "to_unbinned": [
      "self"
    ],
    "to_binned": [
      "self",
      "space",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "to_truncated": [
      "self",
      "limits"
    ]
  },
  "RESERVED_NAMES": [],
  "valid_name_regex": [],
  "validate_preprocess_name": [
    "name"
  ],
  "BaseObject": {
    "__init__": [
      "self",
      "name"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "name": [
      "self"
    ],
    "copy": [
      "self",
      "deep",
      "name"
    ],
    "_copy": [
      "self",
      "deep",
      "name",
      "overwrite_params"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "convert_param_values": [
    "params"
  ],
  "BaseParametrized": {
    "__init__": [
      "self",
      "params",
      "autograd_params"
    ],
    "_assert_params_unique": [
      "self"
    ],
    "get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "params": [
      "self"
    ],
    "_check_set_input_params": [
      "self",
      "params",
      "guarantee_checked"
    ],
    "_check_convert_input_paramvalues": [
      "self",
      "params",
      "guarantee_checked"
    ]
  },
  "BaseNumeric": {
    "__init__": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_filter_floating_params": [
      "params"
    ]
  },
  "extract_filter_params": [
    "params",
    "floating",
    "extract_independent"
  ],
  "to_value_holder": [
    "var"
  ],
  "to_data": [
    "value",
    "space"
  ],
  "Func": {
    "__init__": [
      "self",
      "var",
      "output_var",
      "label"
    ],
    "__call__": [
      "self",
      "var"
    ],
    "values": [
      "self"
    ],
    "_call_values": [
      "self",
      "var",
      "options"
    ],
    "_fallback_values": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_values": [
      "self",
      "var",
      "norm",
      "options"
    ]
  },
  "register_tensor_conversion": [
    "convertable",
    "name",
    "overload_operators",
    "priority"
  ],
  "OverloadableMixin": {
    "_TensorConversionFunction": [
      "v",
      "dtype",
      "name",
      "as_ref"
    ],
    "_dense_var_to_tensor": [
      "self",
      "dtype",
      "name",
      "as_ref"
    ],
    "_AsTensor": [
      "self"
    ],
    "_OverloadAllOperators": [
      "cls"
    ],
    "_OverloadOperator": [
      "cls",
      "operator"
    ]
  },
  "OverloadableMixinValues": {
    "_TensorConversionFunction": [
      "v",
      "dtype",
      "name",
      "as_ref"
    ],
    "_dense_var_to_tensor": [
      "self",
      "dtype",
      "name",
      "as_ref"
    ],
    "_AsTensor": [
      "self"
    ],
    "_OverloadAllOperators": [
      "cls"
    ],
    "_OverloadOperator": [
      "cls",
      "operator"
    ]
  },
  "MetaBaseParameter": {},
  "_BaseModel_USER_IMPL_METHODS_TO_CHECK": [],
  "_BaseModel_register_check_support": [
    "has_support"
  ],
  "ParamArgsNotImplemented": {},
  "BaseModel": {
    "DEFAULTS_integration": [],
    "_analytic_integral": [],
    "_inverse_analytic_integral": [],
    "_additional_repr": [],
    "__init__": [
      "self",
      "obs",
      "params",
      "name",
      "dtype"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_subclass_check_support": [
      "cls",
      "methods_to_check",
      "wrapper_not_overwritten"
    ],
    "_func_to_integrate": [
      "self",
      "x"
    ],
    "_func_to_sample_from": [
      "self",
      "x"
    ],
    "space": [
      "self"
    ],
    "_check_set_space": [
      "self",
      "obs"
    ],
    "_convert_sort_x": [
      "self",
      "x",
      "partial",
      "allow_none",
      "fallback_obs"
    ],
    "update_integration_options": [
      "self",
      "draws_per_dim",
      "mc_sampler",
      "tol",
      "max_draws",
      "draws_simpson"
    ],
    "_check_input_norm": [
      "self",
      "norm",
      "none_is_error"
    ],
    "_check_input_limits": [
      "self",
      "limits",
      "none_is_error"
    ],
    "_convert_sort_space": [
      "self",
      "obs",
      "axes",
      "limits"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_single_hook_integrate": [
      "self",
      "limits",
      "norm",
      "x"
    ],
    "_hook_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_norm_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_limits_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_fallback_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "register_analytic_integral": [
      "cls",
      "func",
      "limits",
      "priority"
    ],
    "register_inverse_analytic_integral": [
      "cls",
      "func"
    ],
    "_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_single_hook_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_hook_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_norm_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_limits_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_fallback_analytic_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "has_analytic_integral": [
      "self"
    ],
    "_numeric_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "numeric_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_single_hook_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_hook_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_norm_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_limits_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_call_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_fallback_numeric_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "partial_integrate": [
      "self",
      "x",
      "limits"
    ],
    "_single_hook_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_hook_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_norm_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_limits_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_call_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_fallback_partial_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_single_hook_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_hook_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_norm_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_limits_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_call_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_fallback_partial_analytic_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_single_hook_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_hook_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_norm_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_limits_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_call_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_fallback_partial_numeric_integrate": [
      "self",
      "x",
      "limits",
      "norm"
    ],
    "_auto_numeric_integrate": [
      "self",
      "func",
      "limits",
      "x",
      "options"
    ],
    "_inverse_analytic_integrate": [
      "self",
      "x"
    ],
    "create_sampler": [
      "self",
      "n",
      "limits"
    ],
    "_create_sampler_tensor": [
      "self",
      "limits",
      "n"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ],
    "sample": [
      "self",
      "n",
      "limits"
    ],
    "_single_hook_sample": [
      "self",
      "n",
      "limits",
      "x"
    ],
    "_hook_sample": [
      "self",
      "limits",
      "n"
    ],
    "_limits_sample": [
      "self",
      "n",
      "limits"
    ],
    "_call_sample": [
      "self",
      "n",
      "limits"
    ],
    "_analytic_sample": [
      "self",
      "n",
      "limits"
    ],
    "_fallback_sample": [
      "self",
      "n",
      "limits"
    ],
    "_register_additional_repr": [
      "cls"
    ],
    "_get_additional_repr": [
      "self",
      "sorted"
    ],
    "__repr__": [
      "self"
    ],
    "_check_input_x_function": [
      "self",
      "func"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ]
  },
  "SimpleModelSubclassMixin": {
    "__init__": [
      "self"
    ],
    "_check_simple_model_subclass": [
      "cls"
    ]
  },
  "DEFAULT_FULL_ARG": [],
  "_unbinned_nll_tf": [
    "model",
    "data",
    "fit_range",
    "log_offset"
  ],
  "_nll_calc_unbinned_tf": [
    "log_probs",
    "weights",
    "log_offset",
    "kahan"
  ],
  "_constraint_check_convert": [
    "constraints"
  ],
  "BaseLossRepr": {
    "_implementation": [],
    "_owndict": [],
    "_check_container": [
      "cls",
      "v"
    ]
  },
  "GradientNotImplementedError": {},
  "ValueGradientNotImplementedError": {},
  "ValueGradientHessianNotImplementedError": {},
  "HessianNotImplementedError": {},
  "BaseLoss": {
    "__init__": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "options"
    ],
    "is_weighted": [
      "self"
    ],
    "is_precompiled": [
      "self",
      "value"
    ],
    "_check_init_options": [
      "self",
      "options",
      "data"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_check_set_input_params": [
      "self",
      "params",
      "guarantee_checked"
    ],
    "_input_check": [
      "self",
      "pdf",
      "data",
      "fit_range"
    ],
    "check_precompile": [
      "self"
    ],
    "_check_convert_model_data": [
      "self",
      "model",
      "data",
      "fit_range"
    ],
    "_input_check_params": [
      "self",
      "params",
      "only_independent"
    ],
    "add_constraints": [
      "self",
      "constraints"
    ],
    "_add_constraints": [
      "self",
      "constraints"
    ],
    "name": [
      "self"
    ],
    "model": [
      "self"
    ],
    "data": [
      "self"
    ],
    "fit_range": [
      "self"
    ],
    "constraints": [
      "self"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "errordef": [
      "self"
    ],
    "__call__": [
      "self",
      "_x"
    ],
    "value": [
      "self"
    ],
    "_call_value": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "_value": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "gradient": [
      "self",
      "params"
    ],
    "_call_gradient": [
      "self",
      "params",
      "numgrad"
    ],
    "gradients": [
      "self"
    ],
    "_gradient": [
      "self",
      "params",
      "numgrad"
    ],
    "_fallback_gradient": [
      "self",
      "params",
      "numgrad"
    ],
    "value_gradient": [
      "self",
      "params"
    ],
    "_call_value_gradient": [
      "self",
      "params",
      "numgrad",
      "full"
    ],
    "value_gradients": [
      "self"
    ],
    "_value_gradient": [
      "self",
      "params",
      "numgrad",
      "full"
    ],
    "_fallback_value_gradient": [
      "self",
      "params",
      "numgrad"
    ],
    "hessian": [
      "self",
      "params",
      "hessian"
    ],
    "_call_hessian": [
      "self",
      "params",
      "numgrad",
      "hessian"
    ],
    "_hessian": [
      "self",
      "params",
      "hessian",
      "numgrad"
    ],
    "_fallback_hessian": [
      "self",
      "params",
      "hessian",
      "numgrad"
    ],
    "value_gradient_hessian": [
      "self",
      "params"
    ],
    "_call_value_gradient_hessian": [
      "self",
      "params",
      "numgrad",
      "full",
      "hessian"
    ],
    "value_gradients_hessian": [
      "self"
    ],
    "_value_gradient_hessian": [
      "self",
      "params",
      "hessian",
      "numerical",
      "full"
    ],
    "_fallback_value_gradient_hessian": [
      "self",
      "params",
      "hessian",
      "numgrad"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_check_assert_autograd": [
      "self",
      "params"
    ]
  },
  "one_two_many": [
    "values",
    "n",
    "many"
  ],
  "BaseUnbinnedNLL": {
    "create_new": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "options"
    ]
  },
  "UnbinnedNLL": {
    "_name": [],
    "__init__": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "options"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ],
    "_loss_func_watched": [
      "self",
      "data",
      "model",
      "fit_range",
      "constraints",
      "log_offset",
      "sumtype"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ]
  },
  "UnbinnedNLLRepr": {
    "_implementation": []
  },
  "ExtendedUnbinnedNLL": {
    "__init__": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "options"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "is_extended": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ]
  },
  "ExtendedUnbinnedNLLRepr": {
    "_implementation": []
  },
  "SimpleLoss": {
    "_name": [],
    "__init__": [
      "self",
      "func",
      "params",
      "errordef"
    ],
    "_check_jit_or_not": [
      "self"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_gradient": [
      "self",
      "params",
      "numgrad"
    ],
    "_hessian": [
      "self",
      "params",
      "hessian",
      "numgrad"
    ],
    "register_convertable_loss": [
      "cls",
      "constructor"
    ],
    "from_any": [
      "cls",
      "func",
      "params"
    ],
    "errordef": [
      "self"
    ],
    "_loss_func": [
      "self",
      "model",
      "data",
      "fit_range",
      "constraints",
      "log_offset"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "create_new": [
      "self",
      "func",
      "params",
      "errordef"
    ]
  },
  "_simple_loss_constructor": [
    "func"
  ],
  "WrappedVariable": {
    "__init__": [
      "self",
      "initial_value"
    ],
    "name": [
      "self"
    ],
    "constraint": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "value": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "numpy": [
      "self"
    ],
    "assign": [
      "self",
      "value",
      "use_locking",
      "name",
      "read_value"
    ],
    "_dense_var_to_tensor": [
      "self",
      "dtype",
      "name",
      "as_ref"
    ],
    "_AsTensor": [
      "self"
    ],
    "_OverloadAllOperators": [],
    "_OverloadOperator": [
      "operator"
    ]
  },
  "BaseParameter": {
    "__init__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "_finalize_weakref": [
    "name"
  ],
  "ZfitParameterMixin": {
    "__init__": [
      "self",
      "name",
      "label"
    ],
    "name": [
      "self"
    ],
    "label": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "TFBaseVariable": {
    "_shared_name": [
      "self"
    ]
  },
  "Parameter": {
    "_independent": [],
    "_independent_params": [],
    "DEFAULT_stepsize": [],
    "__init__": [
      "self",
      "name",
      "value",
      "lower",
      "upper",
      "stepsize",
      "floating"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "_from_name": [
      "cls",
      "name"
    ],
    "lower": [
      "self",
      "value"
    ],
    "upper": [
      "self",
      "value"
    ],
    "prior": [
      "self"
    ],
    "set_prior": [
      "self",
      "prior"
    ],
    "has_limits": [
      "self"
    ],
    "at_limit": [
      "self"
    ],
    "_check_at_limit": [
      "self",
      "value",
      "exact"
    ],
    "value": [
      "self"
    ],
    "floating": [
      "self",
      "value"
    ],
    "independent": [
      "self"
    ],
    "has_stepsize": [
      "self"
    ],
    "has_step_size": [
      "self"
    ],
    "stepsize": [
      "self",
      "value"
    ],
    "step_size": [
      "self",
      "value"
    ],
    "set_value": [
      "self",
      "value"
    ],
    "assign": [
      "self",
      "value",
      "use_locking",
      "read_value"
    ],
    "randomize": [
      "self",
      "minval",
      "maxval",
      "sampler"
    ],
    "get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "lower_limit": [
      "self",
      "value"
    ],
    "upper_limit": [
      "self",
      "value"
    ],
    "__tf_tracing_type__": [
      "self",
      "signature_context"
    ],
    "__reduce__": [
      "self"
    ]
  },
  "ParameterSpec": {
    "value_type": [],
    "__init__": [
      "self",
      "shape",
      "dtype",
      "trainable",
      "alias_id"
    ],
    "from_value": [
      "cls",
      "value"
    ],
    "_to_components": [
      "self",
      "value"
    ],
    "_from_components": [
      "self",
      "components"
    ],
    "_to_tensors": [
      "self",
      "value"
    ],
    "is_subtype_of": [
      "self",
      "other"
    ],
    "most_specific_common_supertype": [
      "self",
      "others"
    ],
    "placeholder_value": [
      "self",
      "placeholder_context"
    ],
    "is_compatible_with": [
      "self",
      "spec_or_value"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "ParameterRepr": {
    "_implementation": [],
    "_constructor": [],
    "_validate_value": [
      "cls",
      "v"
    ],
    "__hash__": [
      "self"
    ]
  },
  "BaseComposedParameter": {
    "__init__": [
      "self",
      "params",
      "func",
      "dtype",
      "name"
    ],
    "floating": [
      "self",
      "value"
    ],
    "params": [
      "self"
    ],
    "value": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "numpy": [
      "self"
    ],
    "independent": [
      "self"
    ],
    "set_value": [
      "self",
      "value"
    ],
    "randomize": [
      "self",
      "minval",
      "maxval",
      "sampler"
    ],
    "assign": [
      "self",
      "value",
      "use_locking",
      "name",
      "read_value"
    ]
  },
  "ConstantParameter": {
    "__init__": [
      "self",
      "name",
      "value"
    ],
    "shape": [
      "self"
    ],
    "value": [
      "self"
    ],
    "floating": [
      "self",
      "value"
    ],
    "independent": [
      "self"
    ],
    "static_value": [
      "self"
    ],
    "numpy": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ConstantParamRepr": {
    "_implementation": [],
    "_constructor": [],
    "_validate_value": [
      "cls",
      "value"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "ComposedParameter": {
    "__init__": [
      "self",
      "name",
      "func"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ComposedParameterRepr": {
    "_implementation": [],
    "_constructor": [],
    "_validate_value_pre": [
      "cls",
      "value"
    ],
    "validate_all_functor": [
      "cls",
      "values"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "ComplexParameter": {
    "__init__": [
      "self",
      "name",
      "func"
    ],
    "from_cartesian": [
      "cls",
      "name",
      "real",
      "imag",
      "floating"
    ],
    "from_polar": [
      "cls",
      "name",
      "mod",
      "arg",
      "floating"
    ],
    "conj": [
      "self"
    ],
    "real": [
      "self"
    ],
    "imag": [
      "self"
    ],
    "mod": [
      "self"
    ],
    "arg": [
      "self"
    ]
  },
  "_auto_number": [],
  "get_auto_number": [],
  "_reset_auto_number": [],
  "ALLOWED_KEYS": [],
  "convert_to_parameters": [
    "value",
    "name",
    "prefer_constant",
    "lower",
    "upper",
    "stepsize"
  ],
  "convert_to_parameter": [
    "value",
    "name",
    "prefer_constant",
    "params",
    "lower",
    "upper",
    "stepsize"
  ],
  "assign_values_jit": [
    "params",
    "values",
    "use_locking"
  ],
  "assign_values": [
    "params",
    "values",
    "use_locking",
    "allow_partial"
  ],
  "set_values": [
    "params",
    "values",
    "allow_partial"
  ],
  "check_convert_param_values_assign": [
    "params",
    "values",
    "allow_partial"
  ],
  "multiply": [
    "object1",
    "object2"
  ],
  "multiply_pdf_pdf": [
    "pdf1",
    "pdf2",
    "name"
  ],
  "multiply_func_func": [
    "func1",
    "func2",
    "name"
  ],
  "multiply_param_func": [
    "param",
    "func"
  ],
  "multiply_param_param": [
    "param1",
    "param2"
  ],
  "add": [
    "object1",
    "object2"
  ],
  "_convert_to_known": [
    "object1",
    "object2"
  ],
  "add_pdf_pdf": [
    "pdf1",
    "pdf2",
    "name"
  ],
  "add_func_func": [
    "func1",
    "func2",
    "name"
  ],
  "add_param_func": [
    "param",
    "func"
  ],
  "add_param_param": [
    "param1",
    "param2"
  ],
  "convert_pdf_to_func": [
    "pdf",
    "norm"
  ],
  "convert_func_to_pdf": [
    "func",
    "obs",
    "name"
  ],
  "Integration": {
    "__init__": [
      "self",
      "mc_sampler",
      "draws_per_dim",
      "numeric_integrator"
    ],
    "register_on_object": [
      "self",
      "var",
      "func",
      "overwrite"
    ],
    "get_available": [
      "self",
      "var"
    ],
    "has_full": [
      "self",
      "var"
    ],
    "has_partial": [
      "self",
      "var"
    ]
  },
  "PDF": {
    "__init__": [
      "self",
      "obs",
      "params",
      "var",
      "supports",
      "extended",
      "norm",
      "label"
    ],
    "_set_yield": [
      "self",
      "value"
    ],
    "is_extended": [
      "self"
    ],
    "__call__": [
      "self",
      "var"
    ],
    "_pdf": [
      "self",
      "var",
      "norm"
    ],
    "pdf": [
      "self",
      "var",
      "norm"
    ],
    "_call_pdf": [
      "self",
      "var",
      "norm"
    ],
    "_ext_pdf": [
      "self",
      "var",
      "norm"
    ],
    "ext_pdf": [
      "self",
      "var",
      "norm"
    ],
    "_call_ext_pdf": [
      "self",
      "var",
      "norm"
    ],
    "_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_auto_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_fallback_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_ext_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_values": [
      "self",
      "var",
      "options"
    ],
    "counts": [
      "self"
    ],
    "_call_counts": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_counts": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "rel_counts": [
      "self"
    ],
    "_call_rel_counts": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_rel_counts": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_fallback_rel_counts": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_ext_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_auto_ext_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_fallback_ext_integrate": [
      "self",
      "var",
      "norm",
      "options"
    ],
    "_convert_check_input_var": [
      "self",
      "var"
    ],
    "_convert_check_input_norm": [
      "self",
      "norm",
      "var"
    ]
  },
  "UnbinnedPDF": {
    "__init__": [
      "self",
      "obs",
      "params",
      "var",
      "supports",
      "extended",
      "norm"
    ]
  },
  "HistPDF": {
    "__init__": [
      "self",
      "obs",
      "params",
      "var",
      "supports",
      "extended",
      "norm",
      "label"
    ],
    "_ext_pdf": [
      "self",
      "var",
      "norm"
    ],
    "_pdf": [
      "self",
      "var",
      "norm"
    ]
  },
  "BaseFuncV1": {
    "__init__": [
      "self",
      "obs",
      "dtype",
      "name",
      "params"
    ],
    "_func_to_integrate": [
      "self",
      "x"
    ],
    "_func_to_sample_from": [
      "self",
      "x"
    ],
    "copy": [
      "self"
    ],
    "_func": [
      "self",
      "x"
    ],
    "func": [
      "self",
      "x",
      "name"
    ],
    "_single_hook_value": [
      "self",
      "x",
      "name"
    ],
    "_hook_value": [
      "self",
      "x",
      "name"
    ],
    "_call_value": [
      "self",
      "x",
      "name"
    ],
    "as_pdf": [
      "self"
    ],
    "_check_input_norm_range_default": [
      "self",
      "norm",
      "caller_name",
      "none_is_error"
    ]
  },
  "BaseDimensional": {
    "_check_n_obs": [
      "self",
      "space"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "obs": [
      "self"
    ],
    "axes": [
      "self"
    ],
    "n_obs": [
      "self"
    ]
  },
  "get_same_obs": [
    "obs"
  ],
  "limits_overlap": [
    "spaces",
    "allow_exact_match"
  ],
  "common_obs": [
    "spaces"
  ],
  "common_axes": [
    "spaces"
  ],
  "obs_subsets": [
    "dimensionals"
  ],
  "check_integrate": [
    "func",
    "limits",
    "norm"
  ],
  "AutoTester": {
    "__init__": [
      "self"
    ],
    "register_pdf": [
      "self",
      "pdf_class",
      "params_factories",
      "scipy_dist",
      "analytic_int_axes"
    ],
    "create_parameterized_pdfs": [
      "self"
    ]
  },
  "tester": [],
  "ZfitSerializable": {
    "get_repr": [
      "cls"
    ],
    "to_orm": [
      "self"
    ]
  },
  "NumpyArrayNotSerializableError": {},
  "SerializableMixin": {
    "hs3": [],
    "__init__": [
      "self"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "to_yaml": [
      "self"
    ],
    "to_asdf": [
      "self"
    ],
    "from_asdf": [
      "cls",
      "asdf_obj"
    ],
    "to_json": [
      "self"
    ],
    "from_json": [
      "cls",
      "json"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "dict_"
    ],
    "get_repr": [
      "cls"
    ]
  },
  "HS3": {
    "implementation": [],
    "__init__": [
      "self",
      "obj"
    ],
    "obj": [
      "self"
    ],
    "to_json": [
      "self"
    ],
    "to_dict": [
      "self"
    ],
    "from_json": [
      "cls",
      "json"
    ],
    "repr": [
      "self"
    ]
  },
  "create_HS3": [
    "cls"
  ],
  "ValueHolder": {
    "__init__": [
      "self",
      "args",
      "variables",
      "norm",
      "target",
      "holders"
    ],
    "get_var": [
      "self",
      "name"
    ],
    "_check_input_variables": [
      "self",
      "variables"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "__contains__": [
      "self",
      "item"
    ],
    "params": [
      "self"
    ],
    "space": [
      "self"
    ],
    "datasets": [
      "self"
    ]
  },
  "Coordinates": {
    "__init__": [
      "self",
      "obs",
      "axes"
    ],
    "_check_convert_obs_axes": [
      "obs",
      "axes"
    ],
    "obs": [
      "self"
    ],
    "axes": [
      "self"
    ],
    "n_obs": [
      "self"
    ],
    "with_obs": [
      "self",
      "obs",
      "allow_superset",
      "allow_subset"
    ],
    "with_axes": [
      "self",
      "axes",
      "allow_superset",
      "allow_subset"
    ],
    "with_autofill_axes": [
      "self",
      "overwrite"
    ],
    "_reorder_obs": [
      "self",
      "indices"
    ],
    "_reorder_axes": [
      "self",
      "indices"
    ],
    "get_reorder_indices": [
      "self",
      "obs",
      "axes"
    ],
    "reorder_x": [
      "self",
      "x"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_convert_axes_to_int": [
    "axes"
  ],
  "_convert_obs_to_str": [
    "obs"
  ],
  "_reorder_indices": [
    "old",
    "new"
  ],
  "convert_to_axes": [
    "axes",
    "container"
  ],
  "convert_to_obs_str": [
    "obs",
    "container"
  ],
  "tfd": [],
  "BaseConstraintRepr": {
    "_implementation": [],
    "_owndict": []
  },
  "BaseConstraint": {
    "__init__": [
      "self",
      "params",
      "name",
      "dtype"
    ],
    "value": [
      "self"
    ],
    "_value": [
      "self"
    ]
  },
  "SimpleConstraint": {
    "__init__": [
      "self",
      "func",
      "params"
    ],
    "_value": [
      "self"
    ]
  },
  "ProbabilityConstraint": {
    "__init__": [
      "self",
      "observation",
      "params",
      "name",
      "dtype"
    ],
    "observation": [
      "self"
    ],
    "value": [
      "self"
    ],
    "_value": [
      "self"
    ],
    "sample": [
      "self",
      "n"
    ],
    "_sample": [
      "self",
      "n"
    ],
    "_params_array": [
      "self"
    ]
  },
  "TFProbabilityConstraint": {
    "__init__": [
      "self",
      "observation",
      "params",
      "distribution",
      "dist_params",
      "dist_kwargs",
      "name",
      "dtype"
    ],
    "distribution": [
      "self"
    ],
    "_value": [
      "self"
    ],
    "_sample": [
      "self",
      "n"
    ]
  },
  "_preprocess_gaussian_constr_sigma_var": [
    "cov",
    "sigma",
    "legacy_uncertainty"
  ],
  "GaussianConstraint": {
    "__init__": [
      "self",
      "params",
      "observation"
    ],
    "covariance": [
      "self"
    ]
  },
  "GaussianConstraintRepr": {
    "_implementation": [],
    "get_init_args": [
      "cls",
      "values"
    ],
    "validate_params": [
      "cls",
      "v"
    ]
  },
  "PoissonConstraint": {
    "__init__": [
      "self",
      "params",
      "observation"
    ]
  },
  "PoissonConstraintRepr": {
    "_implementation": [],
    "get_init_args": [
      "cls",
      "values"
    ],
    "validate_params": [
      "cls",
      "v"
    ]
  },
  "LogNormalConstraint": {
    "__init__": [
      "self",
      "params",
      "observation",
      "uncertainty"
    ]
  },
  "LogNormalConstraintRepr": {
    "_implementation": [],
    "get_init_args": [
      "cls",
      "values"
    ],
    "validate_params": [
      "cls",
      "v"
    ]
  },
  "unbinned_to_hist_eager_edgesweightsargs": [
    "values"
  ],
  "unbinned_to_hist_eager": [
    "values",
    "edges",
    "weights"
  ],
  "unbinned_to_binned": [
    "data",
    "space",
    "binned_class",
    "initkwargs"
  ],
  "unbinned_to_binindex": [
    "data",
    "space",
    "flow"
  ],
  "convert_to_data": [
    "data",
    "obs"
  ],
  "DataMeta": {
    "__call__": [
      "cls",
      "data",
      "obs"
    ]
  },
  "Data": {
    "USE_HASH": [],
    "BATCH_SIZE": [],
    "__init__": [
      "self",
      "data"
    ],
    "_using_hash": [
      "self"
    ],
    "label": [
      "self"
    ],
    "num_entries": [
      "self"
    ],
    "nentries": [
      "self"
    ],
    "nevents": [
      "self"
    ],
    "samplesize": [
      "self"
    ],
    "enable_hashing": [
      "self"
    ],
    "hashint": [
      "self"
    ],
    "_approx_nevents": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "has_weights": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "_set_space": [
      "self",
      "obs",
      "autofill"
    ],
    "data_range": [
      "self"
    ],
    "set_data_range": [
      "self",
      "data_range"
    ],
    "_copy": [
      "self",
      "deep",
      "name",
      "overwrite_params"
    ],
    "weights": [
      "self"
    ],
    "with_weights": [
      "self",
      "weights"
    ],
    "set_weights": [
      "self",
      "weights"
    ],
    "_set_weights": [
      "self",
      "weights"
    ],
    "space": [
      "self"
    ],
    "from_pandas": [
      "cls",
      "df",
      "obs"
    ],
    "from_mapping": [
      "cls",
      "mapping",
      "obs"
    ],
    "from_root": [
      "cls",
      "path",
      "treepath",
      "obs"
    ],
    "from_numpy": [
      "cls",
      "obs",
      "array"
    ],
    "from_tensor": [
      "cls",
      "obs",
      "tensor"
    ],
    "_update_hash": [
      "self"
    ],
    "with_obs": [
      "self",
      "obs"
    ],
    "to_pandas": [
      "self",
      "obs",
      "weightsname"
    ],
    "unstack_x": [
      "self",
      "obs",
      "always_list"
    ],
    "value": [
      "self",
      "obs",
      "axis"
    ],
    "numpy": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "to_numpy": [
      "self"
    ],
    "_value_internal": [
      "self",
      "obs"
    ],
    "_get_permutation_indices": [
      "self",
      "obs"
    ],
    "sort_by_axes": [
      "self"
    ],
    "sort_by_obs": [
      "self"
    ],
    "_check_input_data_range": [
      "self",
      "data_range"
    ],
    "_convert_sort_space": [
      "self",
      "obs",
      "axes",
      "limits"
    ],
    "_get_nentries": [
      "self"
    ],
    "to_binned": [
      "self",
      "space"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "DataRepr": {
    "_implementation": [],
    "_owndict": [],
    "extract_data": [
      "cls",
      "values"
    ],
    "flatten_spaces": [
      "cls",
      "v"
    ],
    "convert_data": [
      "cls",
      "v"
    ],
    "convert_weights": [
      "cls",
      "v"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "getitem_obs": [
    "self",
    "item"
  ],
  "check_cut_datamap_weights": [
    "limits",
    "data",
    "weights",
    "guarantee_limits"
  ],
  "check_cut_data_weights": [
    "limits",
    "data",
    "weights",
    "guarantee_limits"
  ],
  "SamplerData": {
    "_cache_counting": [],
    "__init__": [
      "self",
      "data"
    ],
    "fixed_params": [
      "self"
    ],
    "n_samples": [
      "self"
    ],
    "_approx_nevents": [
      "self"
    ],
    "_update_hash": [
      "self"
    ],
    "_value_internal": [
      "self",
      "obs"
    ],
    "hashint": [
      "self"
    ],
    "get_cache_counting": [
      "cls"
    ],
    "from_sample": [
      "cls",
      "sample_func",
      "n",
      "obs",
      "fixed_params",
      "name",
      "weights",
      "dtype",
      "use_hash"
    ],
    "from_sampler": [
      "cls"
    ],
    "update_data": [
      "self",
      "sample",
      "weights",
      "guarantee_limits"
    ],
    "resample": [
      "self",
      "params"
    ],
    "__str__": [
      "self"
    ],
    "get_repr": [
      "cls"
    ]
  },
  "concat_data_obs": [
    "datasets",
    "obs",
    "name",
    "label",
    "use_hash"
  ],
  "concat_data_index": [
    "datasets",
    "obs",
    "name",
    "label",
    "use_hash"
  ],
  "LightDataset": {
    "__init__": [
      "self",
      "tensor",
      "tensormap",
      "ndims"
    ],
    "batch": [
      "self",
      "_"
    ],
    "num_entries": [
      "self"
    ],
    "ndims": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "from_tensor": [
      "cls",
      "tensor",
      "ndims"
    ],
    "with_indices": [
      "self",
      "indices"
    ],
    "_get_tensor_and_tensormap": [
      "self",
      "forcemap"
    ],
    "value": [
      "self",
      "index"
    ],
    "calc_hash": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "sum_samples": [
    "sample1",
    "sample2",
    "obs",
    "weights",
    "shuffle"
  ],
  "Sampler": {
    "__init__": [
      "self"
    ]
  },
  "LimitRangeDefinition": {},
  "Any": {
    "_singleton_instance": [],
    "__new__": [
      "cls"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "__repr__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ]
  },
  "AnyLower": {
    "__repr__": [
      "self"
    ]
  },
  "AnyUpper": {
    "__repr__": [
      "self"
    ]
  },
  "ANY": [],
  "ANY_LOWER": [],
  "ANY_UPPER": [],
  "V1Space": {
    "__init__": [
      "self",
      "space"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "volume": [
      "self"
    ],
    "area": [
      "self"
    ]
  },
  "V0Space": {
    "__init__": [
      "self",
      "space"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "volume": [
      "self"
    ],
    "area": [
      "self"
    ]
  },
  "VectorizeLimits": {
    "__init__": [
      "self",
      "space"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "volume": [
      "self"
    ]
  },
  "fail_not_rect": [
    "func"
  ],
  "calculate_rect_area": [
    "rect_limits"
  ],
  "inside_rect_limits": [
    "x",
    "rect_limits"
  ],
  "filter_rect_limits": [
    "x",
    "rect_limits",
    "axis"
  ],
  "convert_to_tensor_or_numpy": [
    "obj",
    "dtype"
  ],
  "_sanitize_x_input": [
    "x",
    "n_obs"
  ],
  "is_range_definition": [
    "limit"
  ],
  "Limit": {
    "_experimental_allow_vectors": [],
    "__init__": [
      "self",
      "limit_fn",
      "rect_limits",
      "n_obs"
    ],
    "_check_convert_input_limits": [
      "self",
      "limit_fn",
      "rect_limits",
      "n_obs"
    ],
    "_sanitize_rect_limit": [
      "limit"
    ],
    "has_rect_limits": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "rect_limits": [
      "self"
    ],
    "_rect_limits_tf": [
      "self"
    ],
    "rect_limits_np": [
      "self"
    ],
    "rect_lower": [
      "self"
    ],
    "rect_upper": [
      "self"
    ],
    "rect_area": [
      "self"
    ],
    "inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "_inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "filter": [
      "self",
      "x",
      "guarantee_limits",
      "axis"
    ],
    "_filter": [
      "self",
      "x",
      "guarantee_limits",
      "axis"
    ],
    "limit_fn": [
      "self"
    ],
    "rect_limits_are_tensors": [
      "self"
    ],
    "limits_are_set": [
      "self"
    ],
    "limits_are_false": [
      "self"
    ],
    "has_limits": [
      "self"
    ],
    "n_obs": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "less_equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "get_sublimits": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "rect_limits_are_any": [
    "limit"
  ],
  "less_equal_limits": [
    "limit1",
    "limit2",
    "allow_graph"
  ],
  "equal_limits": [
    "limit1",
    "limit2",
    "allow_graph"
  ],
  "deprecate_multispace": [
    "func"
  ],
  "warned_new_limits": [],
  "warn_new_limits": [
    "func"
  ],
  "BaseSpace": {
    "__init__": [
      "self",
      "obs",
      "axes",
      "name"
    ],
    "is_binned": [
      "self"
    ],
    "inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "area": [
      "self"
    ],
    "volume": [
      "self"
    ],
    "_inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "filter": [
      "self",
      "x",
      "guarantee_limits",
      "axis"
    ],
    "_filter": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "n_obs": [
      "self"
    ],
    "obs": [
      "self"
    ],
    "axes": [
      "self"
    ],
    "n_limits": [
      "self"
    ],
    "_depr_n_limits": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "get_reorder_indices": [
      "self",
      "obs",
      "axes"
    ],
    "_check_convert_input_axes": [
      "self",
      "axes",
      "allow_none"
    ],
    "_check_convert_input_obs": [
      "self",
      "obs",
      "allow_none"
    ],
    "_check_coords_allowed": [
      "self",
      "obs",
      "axes",
      "allow_superset",
      "allow_subset"
    ],
    "__repr__": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "get_sublimits": [
      "self"
    ],
    "add": [
      "self"
    ],
    "combine": [
      "self"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "less_equal": [
      "self",
      "other",
      "allow_graph"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "reorder_x": [
      "self",
      "x",
      "x_obs",
      "x_axes",
      "func_obs",
      "func_axes"
    ],
    "__len__": [
      "self"
    ],
    "__bool__": [
      "self"
    ]
  },
  "_legacy_get_arguments_space": [
    "obs",
    "args",
    "limits",
    "binning",
    "axes",
    "rect_limits",
    "lower",
    "upper"
  ],
  "Space": {
    "AUTO_FILL": [],
    "ANY": [],
    "ANY_LOWER": [],
    "ANY_UPPER": [],
    "__init__": [
      "self",
      "obs"
    ],
    "labels": [
      "self"
    ],
    "label": [
      "self"
    ],
    "binning": [
      "self"
    ],
    "is_binned": [
      "self"
    ],
    "_check_convert_input_limits": [
      "self",
      "limit",
      "rect_limits",
      "obs",
      "axes",
      "n_obs"
    ],
    "get_limits": [
      "self",
      "obs",
      "axes"
    ],
    "limits": [
      "self"
    ],
    "rect_limits": [
      "self"
    ],
    "_depr_rect_limits": [
      "self"
    ],
    "_rect_limits_tf": [
      "self"
    ],
    "rect_limits_np": [
      "self"
    ],
    "rect_upper": [
      "self"
    ],
    "rect_lower": [
      "self"
    ],
    "_rect_limits_z": [
      "self"
    ],
    "rect_area": [
      "self"
    ],
    "rect_limits_are_tensors": [
      "self"
    ],
    "has_rect_limits": [
      "self"
    ],
    "limits_are_false": [
      "self"
    ],
    "has_limits": [
      "self"
    ],
    "limits_are_set": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "n_limits": [
      "self"
    ],
    "with_limits": [
      "self",
      "limits",
      "rect_limits",
      "name"
    ],
    "reorder_x": [
      "self",
      "x"
    ],
    "with_obs": [
      "self",
      "obs",
      "allow_superset",
      "allow_subset"
    ],
    "with_axes": [
      "self",
      "axes",
      "allow_superset",
      "allow_subset"
    ],
    "with_coords": [
      "self",
      "coords",
      "allow_superset",
      "allow_subset"
    ],
    "with_autofill_axes": [
      "self",
      "overwrite"
    ],
    "get_subspace": [
      "self",
      "obs",
      "axes",
      "name"
    ],
    "_legacy_area": [
      "self"
    ],
    "with_binning": [
      "self",
      "binning"
    ],
    "copy": [
      "self"
    ],
    "_inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "limit1d": [
      "self"
    ],
    "from_axes": [
      "cls",
      "axes",
      "limits",
      "rect_limits",
      "name"
    ]
  },
  "extract_limits_from_dict": [
    "limits_dict",
    "obs",
    "axes"
  ],
  "add_spaces": [],
  "get_coord": [
    "space",
    "obs_in_use"
  ],
  "combine_spaces": [],
  "less_equal_space": [
    "space1",
    "space2",
    "allow_graph"
  ],
  "equal_space": [
    "space1",
    "space2",
    "allow_graph"
  ],
  "compare_spaces_equal_static": [
    "space1",
    "space2"
  ],
  "compare_multispace": [
    "space1",
    "space2",
    "comparator"
  ],
  "compare_limits_multispace": [
    "space1",
    "space2",
    "comparator"
  ],
  "compare_limits_coords_dict": [
    "limits1",
    "limits2",
    "comparator",
    "require_all_coord_types"
  ],
  "compare_limits_dict": [
    "dict1",
    "dict2",
    "comparator"
  ],
  "flatten_spaces": [
    "spaces"
  ],
  "MultiSpace": {
    "__new__": [
      "cls",
      "spaces",
      "obs",
      "binning",
      "axes",
      "name"
    ],
    "__init__": [
      "self",
      "spaces",
      "obs",
      "axes",
      "name"
    ],
    "label": [
      "self"
    ],
    "labels": [
      "self"
    ],
    "_initialize_space": [
      "space",
      "spaces",
      "obs",
      "axes"
    ],
    "_check_convert_input_spaces_obs_axes": [
      "spaces",
      "obs",
      "axes"
    ],
    "binning": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "rect_limits": [
      "self"
    ],
    "lower": [
      "self"
    ],
    "upper": [
      "self"
    ],
    "rect_limits_np": [
      "self"
    ],
    "rect_lower": [
      "self"
    ],
    "rect_upper": [
      "self"
    ],
    "rect_area": [
      "self"
    ],
    "rect_limits_are_tensors": [
      "self"
    ],
    "has_rect_limits": [
      "self"
    ],
    "limits_are_false": [
      "self"
    ],
    "has_limits": [
      "self"
    ],
    "limits_are_set": [
      "self"
    ],
    "n_events": [
      "self"
    ],
    "with_limits": [
      "self",
      "limits",
      "rect_limits",
      "name"
    ],
    "_legacy_area": [
      "self"
    ],
    "with_obs": [
      "self",
      "obs",
      "allow_superset",
      "allow_subset"
    ],
    "with_axes": [
      "self",
      "axes",
      "allow_superset",
      "allow_subset"
    ],
    "with_coords": [
      "self",
      "coords",
      "allow_superset",
      "allow_subset"
    ],
    "with_autofill_axes": [
      "self",
      "overwrite"
    ],
    "get_subspace": [
      "self",
      "obs",
      "axes",
      "name"
    ],
    "copy": [
      "self"
    ],
    "_raise_limits_not_implemented": [
      "self"
    ],
    "_inside": [
      "self",
      "x",
      "guarantee_limits"
    ],
    "__iter__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "convert_to_space": [
    "obs",
    "axes",
    "limits"
  ],
  "check_norm": [
    "supports"
  ],
  "param_args_supported": [
    "func"
  ],
  "no_multiple_limits": [
    "func"
  ],
  "supports": [],
  "contains_tensor": [
    "objects"
  ],
  "shape_np_tf": [
    "objects"
  ],
  "limits_consistent": [
    "spaces"
  ],
  "add_spaces_old": [
    "spaces"
  ],
  "_BinnedPDF_register_check_support": [
    "has_support"
  ],
  "BaseBinnedPDF": {
    "__init__": [
      "self",
      "obs",
      "extended",
      "norm",
      "name",
      "label"
    ],
    "label": [
      "self"
    ],
    "_check_convert_obs_init": [
      "self",
      "obs"
    ],
    "_check_convert_norm_init": [
      "self",
      "norm"
    ],
    "_subclass_check_support": [
      "cls",
      "methods_to_check",
      "wrapper_not_overwritten"
    ],
    "axes": [
      "self"
    ],
    "to_binneddata": [
      "self"
    ],
    "to_hist": [
      "self"
    ],
    "space": [
      "self"
    ],
    "_set_yield": [
      "self",
      "value"
    ],
    "_get_params": [
      "self",
      "floating",
      "is_yield",
      "extract_independent"
    ],
    "_convert_input_binned_x": [
      "self",
      "x",
      "none_is_space"
    ],
    "_check_convert_norm": [
      "self",
      "norm",
      "none_is_error"
    ],
    "_check_convert_limits": [
      "self",
      "limits"
    ],
    "_pdf": [
      "self",
      "x",
      "norm"
    ],
    "pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_call_unnormalized_pdf": [
      "self",
      "x"
    ],
    "_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_ext_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_log_pdf": [
      "self",
      "x"
    ],
    "log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_ext_log_pdf": [
      "self",
      "x"
    ],
    "ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_call_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_auto_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_ext_log_pdf": [
      "self",
      "x",
      "norm"
    ],
    "_log_normalization": [
      "self",
      "norm"
    ],
    "log_normalization": [
      "self",
      "norm"
    ],
    "_call_log_normalization": [
      "self",
      "norm"
    ],
    "_normalization": [
      "self",
      "limits"
    ],
    "normalization": [
      "self",
      "norm"
    ],
    "_call_normalization": [
      "self",
      "norm"
    ],
    "_integrate": [
      "self",
      "limits",
      "norm",
      "options",
      "params"
    ],
    "integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_fallback_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "_auto_integrate": [
      "self",
      "limits",
      "norm",
      "options"
    ],
    "ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_call_ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_fallback_ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_auto_ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "_ext_integrate": [
      "self",
      "limits",
      "norm"
    ],
    "create_sampler": [
      "self",
      "n",
      "limits"
    ],
    "_create_sampler_tensor": [
      "self",
      "limits",
      "n"
    ],
    "sample": [
      "self",
      "n",
      "limits"
    ],
    "_call_sample": [
      "self",
      "n",
      "limits"
    ],
    "_fallback_sample": [
      "self",
      "n",
      "limits"
    ],
    "values": [
      "self"
    ],
    "update_integration_options": [
      "self"
    ],
    "as_func": [
      "self",
      "norm"
    ],
    "is_extended": [
      "self"
    ],
    "set_norm": [
      "self",
      "norm"
    ],
    "create_extended": [
      "self",
      "yield_"
    ],
    "get_yield": [
      "self"
    ],
    "register_analytic_integral": [
      "cls",
      "func",
      "limits",
      "priority"
    ],
    "partial_integrate": [
      "self",
      "x",
      "limits"
    ],
    "register_inverse_analytic_integral": [
      "cls",
      "func"
    ],
    "_sample": [
      "self",
      "n",
      "limits"
    ],
    "_copy": [
      "self",
      "deep",
      "name",
      "overwrite_params"
    ],
    "norm": [
      "self"
    ],
    "norm_range": [
      "self"
    ],
    "_convert_sort_space": [
      "self",
      "obs",
      "axes",
      "limits"
    ],
    "counts": [
      "self",
      "x",
      "norm"
    ],
    "_call_counts": [
      "self",
      "x",
      "norm"
    ],
    "_auto_counts": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_counts": [
      "self",
      "x",
      "norm"
    ],
    "_counts": [
      "self",
      "x",
      "norm"
    ],
    "ext_normalization": [
      "self",
      "norm"
    ],
    "_call_ext_normalization": [
      "self",
      "norm"
    ],
    "_ext_normalization": [
      "self",
      "norm"
    ],
    "rel_counts": [
      "self",
      "x"
    ],
    "_call_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "_auto_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "_fallback_rel_counts": [
      "self",
      "x",
      "norm"
    ],
    "set_norm_range": [
      "self"
    ],
    "to_binned": [
      "self",
      "space"
    ],
    "to_unbinned": [
      "self"
    ]
  },
  "BaseBinnedPDFV1": [],
  "binned_rect_integration": [],
  "cut_edges_and_bins": [
    "edges",
    "limits",
    "axis",
    "unscaled"
  ],
  "UniformSampleAndWeights": {
    "__call__": [
      "self",
      "n_to_produce",
      "limits",
      "dtype",
      "prng"
    ]
  },
  "EventSpace": {
    "__init__": [
      "self",
      "obs",
      "limits",
      "factory",
      "dtype",
      "name"
    ],
    "factory": [
      "self"
    ],
    "is_generator": [
      "self"
    ],
    "limits": [
      "self"
    ],
    "create_limits": [
      "self",
      "n"
    ],
    "iter_areas": [
      "self",
      "rel"
    ],
    "add": [
      "self",
      "other"
    ],
    "combine": [
      "self",
      "other"
    ],
    "_calculate_areas": [
      "limits"
    ],
    "__hash__": [
      "self"
    ]
  },
  "accept_reject_sample": [
    "prob",
    "n",
    "limits",
    "sample_and_weights_factory",
    "dtype",
    "prob_max",
    "efficiency_estimation"
  ],
  "extract_extended_pdfs": [
    "pdfs"
  ],
  "extended_sampling": [
    "pdfs",
    "limits"
  ],
  "auto_integrate": [
    "func",
    "limits",
    "n_axes",
    "x",
    "method",
    "dtype",
    "mc_sampler",
    "max_draws",
    "tol",
    "vectorizable",
    "mc_options",
    "simpsons_options"
  ],
  "numeric_integrate": [],
  "simpson": [
    "func",
    "lower",
    "upper",
    "num_points",
    "dtype"
  ],
  "simpson_integrate": [
    "func",
    "limits",
    "num_points"
  ],
  "mc_integrate": [
    "func",
    "limits",
    "axes",
    "x",
    "n_axes",
    "draws_per_dim",
    "max_draws",
    "tol",
    "method",
    "xfixed",
    "dtype",
    "mc_sampler",
    "importance_sampling",
    "vectorizable"
  ],
  "normalization_nograd": [
    "func",
    "n_axes",
    "batch_size",
    "num_batches",
    "dtype",
    "space",
    "x",
    "shape_after"
  ],
  "normalization_chunked": [
    "func",
    "n_axes",
    "batch_size",
    "num_batches",
    "dtype",
    "space",
    "x",
    "shape_after"
  ],
  "chunked_average": [
    "func",
    "x",
    "num_batches",
    "batch_size",
    "space",
    "mc_sampler"
  ],
  "AnalyticIntegral": {
    "__init__": [
      "self"
    ],
    "get_max_axes": [
      "self",
      "limits"
    ],
    "_get_max_axes_limits": [
      "self",
      "limits",
      "out_of_axes"
    ],
    "get_max_integral": [
      "self",
      "limits",
      "axes"
    ],
    "register": [
      "self",
      "func",
      "limits",
      "priority"
    ],
    "integrate": [
      "self",
      "x",
      "limits",
      "axes",
      "norm",
      "model",
      "params"
    ]
  },
  "Integral": {
    "__init__": [
      "self",
      "func",
      "limits",
      "priority"
    ],
    "__call__": [
      "self"
    ]
  },
  "PosteriorSamples": {
    "__init__": [
      "self",
      "samples",
      "params",
      "loss",
      "sampler",
      "n_warmup",
      "n_samples",
      "raw_result",
      "info"
    ],
    "mean": [
      "self",
      "params"
    ],
    "symerr": [
      "self",
      "params"
    ],
    "std": [
      "self",
      "params"
    ],
    "credible_interval": [
      "self",
      "params"
    ],
    "get_samples": [
      "self",
      "params"
    ],
    "as_prior": [
      "self",
      "param"
    ],
    "to_arviz": [
      "self"
    ],
    "update_params": [
      "self",
      "params"
    ],
    "_set_params_to_mean": [
      "self",
      "params"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "params": [
      "self"
    ],
    "param_names": [
      "self"
    ],
    "sampler": [
      "self"
    ],
    "loss": [
      "self"
    ],
    "valid": [
      "self"
    ],
    "converged": [
      "self"
    ],
    "covariance": [
      "self",
      "params"
    ],
    "summary": [
      "self",
      "round_to"
    ],
    "_get_param_positions": [
      "self",
      "params"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_repr_pretty_": [
      "self",
      "p",
      "cycle"
    ],
    "_compute_convergence_diagnostics": [
      "self"
    ],
    "rhat": [
      "self"
    ],
    "ess": [
      "self"
    ],
    "convergence_summary": [
      "self"
    ],
    "diagnostics": [
      "self"
    ]
  },
  "ConstraintType": {
    "UNCONSTRAINED": [],
    "POSITIVE": [],
    "UNIT_INTERVAL": [],
    "CUSTOM_BOUNDS": [],
    "LOWER_BOUNDED": [],
    "UPPER_BOUNDED": []
  },
  "Transform": {
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "IdentityTransform": {
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "LogTransform": {
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "SigmoidTransform": {
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "AffineTransform": {
    "__init__": [
      "self",
      "lower",
      "upper"
    ],
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "LowerBoundTransform": {
    "__init__": [
      "self",
      "lower"
    ],
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "UpperBoundTransform": {
    "__init__": [
      "self",
      "upper"
    ],
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "y"
    ],
    "log_abs_det_jacobian": [
      "self",
      "x"
    ],
    "constraint_type": [
      "self"
    ]
  },
  "PriorConstraint": {
    "__init__": [
      "self",
      "constraint_type",
      "bounds",
      "transform"
    ],
    "_create_default_transform": [
      "self"
    ],
    "validate_bounds": [
      "self",
      "bounds"
    ],
    "__repr__": [
      "self"
    ]
  },
  "UNCONSTRAINED": [],
  "POSITIVE": [],
  "UNIT_INTERVAL": [],
  "validate_parameter": [
    "name",
    "value",
    "constraint"
  ],
  "BasePrior": {
    "__init__": [
      "self",
      "pdf_params",
      "bounds",
      "name"
    ],
    "_validate_parameters": [
      "self",
      "params"
    ],
    "_create_pdf": [
      "self",
      "obs"
    ],
    "_register_default_param": [
      "self",
      "param"
    ],
    "_should_adapt_to_param": [
      "self",
      "param"
    ],
    "_get_adapted_bounds": [
      "self",
      "param"
    ],
    "_adapt_to_parameter_limits": [
      "self",
      "param"
    ],
    "_create_adapted_pdf": [
      "self",
      "obs",
      "lower",
      "upper"
    ]
  },
  "Normal": {
    "constraint": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "name"
    ],
    "_validate_parameters": [
      "self",
      "params"
    ],
    "_create_pdf": [
      "self",
      "obs",
      "mu",
      "sigma"
    ],
    "_create_adapted_pdf": [
      "self",
      "obs",
      "lower",
      "upper"
    ]
  },
  "HalfNormal": {
    "__init__": [
      "self"
    ],
    "_validate_parameters": [
      "self",
      "params"
    ],
    "_create_pdf": [
      "self",
      "obs",
      "mu",
      "sigma"
    ],
    "_get_adapted_bounds": [
      "self",
      "param"
    ]
  },
  "KDE": {
    "__init__": [
      "self",
      "samples",
      "bandwidth",
      "name"
    ],
    "_create_kde_pdf": [
      "self",
      "bounds"
    ],
    "_register_default_param": [
      "self",
      "param"
    ],
    "_adapt_to_parameter_limits": [
      "self",
      "param"
    ]
  },
  "BasePDFRepr": {
    "_implementation": [],
    "_owndict": [],
    "convert_params": [
      "cls",
      "values"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "make_param_constructor": [
    "constructor"
  ],
  "NumericTyped": [],
  "NameObsTyped": [],
  "SpaceRepr": {
    "_implementation": [],
    "_validate_pre": [
      "cls",
      "values"
    ],
    "_validate_lower": [
      "cls",
      "v"
    ],
    "_validate_upper": [
      "cls",
      "v"
    ],
    "validate_binning": [
      "cls",
      "v"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "Aliases": {},
  "alias1": [],
  "Types": {
    "__init__": [
      "self"
    ],
    "one_or_many": [
      "self",
      "repr"
    ],
    "PDFTypeDiscriminated": [
      "self"
    ],
    "DataTypeDiscriminated": [
      "self"
    ],
    "ConstraintTypeDiscriminated": [
      "self"
    ],
    "ParamTypeDiscriminated": [
      "self"
    ],
    "ListParamTypeDiscriminated": [
      "self"
    ],
    "ParamInputTypeDiscriminated": [
      "self"
    ],
    "ListParamInputTypeDiscriminated": [
      "self"
    ],
    "register_repr": [
      "self",
      "repr"
    ]
  },
  "SerializationTypeError": {},
  "Serializer": {
    "__new__": [
      "cls"
    ],
    "types": [],
    "is_initialized": [],
    "_deserializing": [],
    "_existing_params": [],
    "register": [
      "own_cls",
      "repr"
    ],
    "initialize": [
      "cls"
    ],
    "to_hs3": [
      "cls",
      "obj"
    ],
    "from_hs3": [
      "cls",
      "load"
    ],
    "deserializing": [
      "cls"
    ],
    "post_serialize": [
      "cls",
      "out"
    ],
    "pre_deserialize": [
      "cls",
      "out"
    ],
    "post_deserialize": [
      "cls",
      "out"
    ]
  },
  "TYPENAME": [],
  "elements_match": [
    "mapping",
    "replace"
  ],
  "replace_matching": [
    "mapping",
    "replace"
  ],
  "convert_to_orm": [
    "init"
  ],
  "to_orm_init": [
    "func"
  ],
  "MODES": {
    "orm": [],
    "repr": []
  },
  "BaseRepr": {
    "_implementation": [],
    "_context": [],
    "_constructor": [],
    "__init_subclass__": [
      "cls"
    ],
    "orm_mode": [
      "cls",
      "v"
    ],
    "from_orm": [
      "cls",
      "obj"
    ],
    "to_orm": [
      "self"
    ],
    "_to_orm": [
      "self",
      "init"
    ]
  },
  "plot_sumpdf_components_pdfV1": [
    "model"
  ],
  "plot_model_pdf": [
    "model"
  ],
  "assert_initialized": [
    "func"
  ],
  "ZfitPDFPlotter": {
    "plotpdf": [
      "self",
      "data"
    ],
    "_plotpdf": [
      "self"
    ],
    "comp": [
      "self"
    ],
    "__call__": [
      "self",
      "data"
    ],
    "_plot_scale_data": [
      "self",
      "data",
      "density",
      "normalize",
      "ax",
      "histplotkwargs"
    ],
    "_preprocess_args_extended": [
      "self",
      "extended"
    ]
  },
  "PDFPlotter": {
    "__init__": [
      "self",
      "pdf",
      "pdfplotter",
      "componentplotter",
      "defaults"
    ],
    "_plotpdf": [
      "self",
      "depth"
    ],
    "comp": [
      "self"
    ]
  },
  "SumCompPlotter": {
    "__init__": [
      "self",
      "pdf"
    ],
    "_plotpdf": [
      "self",
      "data"
    ]
  },
  "JIT": {
    "_set_all": [
      "self",
      "enable"
    ],
    "_set_default": [
      "self"
    ],
    "_update_allowed": [
      "self",
      "update_jit"
    ],
    "_get_allowed": [
      "self"
    ],
    "experimental_is_eager": [
      "self"
    ]
  },
  "jit": [],
  "_PRINTED_WARNING": [],
  "deprecated": [
    "date",
    "instructions",
    "warn_once"
  ],
  "deprecated_norm_range": [
    "func"
  ],
  "ZfitGraphCachable": {
    "register_cacher": [
      "self",
      "cacher"
    ],
    "add_cache_deps": [
      "self",
      "cache_dependents",
      "allow_non_cachable"
    ],
    "reset_cache_self": [
      "self"
    ],
    "reset_cache": [
      "self",
      "reseter"
    ]
  },
  "GraphCachable": {
    "instances": [],
    "__init__": [
      "self"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "register_cacher": [
      "self",
      "cacher"
    ],
    "add_cache_deps": [
      "self",
      "cache_deps",
      "allow_non_cachable"
    ],
    "reset_cache_self": [
      "self"
    ],
    "reset_cache": [
      "self",
      "reseter"
    ],
    "_clean_cache": [
      "self"
    ],
    "_inform_cachers": [
      "self"
    ]
  },
  "invalidate_graph": [
    "func"
  ],
  "FunctionCacheHolder": {
    "IS_TENSOR": [],
    "__init__": [
      "self",
      "func",
      "wrapped_func",
      "cachables",
      "cachables_mapping",
      "stateless_args",
      "deleter",
      "keepalive",
      "do_jit",
      "xla"
    ],
    "execute_func": [
      "self"
    ],
    "reset_cache_self": [
      "self"
    ],
    "create_immutable": [
      "self",
      "args",
      "kwargs"
    ],
    "get_immutable_repr_obj": [
      "self",
      "obj"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "clear_graph_cache": [],
  "PDFCompatibilityError": {},
  "LogicalUndefinedOperationError": {},
  "OperationNotAllowedError": {},
  "ExtendedPDFError": {},
  "AlreadyExtendedPDFError": {},
  "NotExtendedPDFError": {},
  "ConversionError": {},
  "SubclassingError": {},
  "BasePDFSubclassingError": {},
  "MinimizerSubclassingError": {},
  "IntentionAmbiguousError": {},
  "UnderdefinedError": {},
  "LimitsUnderdefinedError": {},
  "NormRangeUnderdefinedError": {},
  "OverdefinedError": {},
  "LimitsOverdefinedError": {},
  "CoordinatesUnderdefinedError": {},
  "AxesAmbiguousError": {},
  "NotSpecifiedError": {},
  "LimitsNotSpecifiedError": {},
  "NormRangeNotSpecifiedError": {},
  "AxesNotSpecifiedError": {},
  "ObsNotSpecifiedError": {},
  "ParamNameNotUniqueError": {},
  "IncompatibleError": {},
  "ShapeIncompatibleError": {},
  "CoordinatesIncompatibleError": {},
  "ObsIncompatibleError": {},
  "AxesIncompatibleError": {},
  "SpaceIncompatibleError": {},
  "LimitsIncompatibleError": {},
  "NumberOfEventsIncompatibleError": {},
  "InvalidLimitSubspaceError": {},
  "ModelIncompatibleError": {},
  "WeightsNotImplementedError": {},
  "DataIsBatchedError": {},
  "ParameterNotIndependentError": {},
  "NotMinimizedError": {},
  "IllegalInGraphModeError": {},
  "CannotConvertToNumpyError": {},
  "ZfitNotImplementedError": {
    "__init__": [
      "self"
    ]
  },
  "FunctionNotImplemented": {},
  "StandardControlFlow": {},
  "SpecificFunctionNotImplemented": {},
  "MinimizeNotImplemented": {},
  "MinimizeStepNotImplemented": {},
  "AnalyticNotImplemented": {},
  "AnalyticIntegralNotImplemented": {},
  "AnalyticSamplingNotImplemented": {},
  "NormNotImplemented": {},
  "NormRangeNotImplemented": [],
  "MultipleLimitsNotImplemented": {},
  "InitNotImplemented": {},
  "VectorizedLimitsNotImplemented": {},
  "DerivativeCalculationError": {},
  "WorkInProgressError": {},
  "BreakingAPIChangeError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "BehaviorUnderDiscussion": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "MaximumIterationReached": {},
  "AnalyticGradientNotAvailable": {},
  "TemporarilySet": {
    "__init__": [
      "self",
      "value",
      "setter",
      "getter"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "RunManager": {
    "__init__": [
      "self",
      "n_cpu"
    ],
    "mode": [
      "self"
    ],
    "chunksize": [
      "self"
    ],
    "check_numerics": [
      "self",
      "value"
    ],
    "n_cpu": [
      "self"
    ],
    "set_n_cpu": [
      "self",
      "n_cpu",
      "strict"
    ],
    "set_cpus_explicit": [
      "self",
      "intra",
      "inter"
    ],
    "aquire_cpu": [
      "self",
      "max_cpu"
    ],
    "__call__": [
      "self"
    ],
    "experimental_enable_eager": [
      "eager"
    ],
    "experimental_disable_param_update": [
      "self",
      "value"
    ],
    "set_graph_mode": [
      "self",
      "graph"
    ],
    "_force_set_graph_mode": [
      "self",
      "graph",
      "set_backend"
    ],
    "set_autograd_mode": [
      "self",
      "autograd"
    ],
    "set_mode": [
      "self",
      "graph",
      "autograd"
    ],
    "_set_autograd_mode": [
      "self",
      "autograd"
    ],
    "_set_graph_mode": [
      "self",
      "graph"
    ],
    "get_graph_mode": [
      "self"
    ],
    "current_policy_graph": [
      "self"
    ],
    "get_autograd_mode": [
      "self"
    ],
    "current_policy_autograd": [
      "self"
    ],
    "set_mode_default": [
      "self"
    ],
    "clear_graph_cache": [
      "self"
    ],
    "set_graph_cache_size": [
      "self",
      "size"
    ],
    "assert_executing_eagerly": [
      "self"
    ],
    "experimental_is_eager": [
      "self"
    ],
    "executing_eagerly": [
      "self"
    ],
    "experimental_clear_caches": [
      "self"
    ],
    "hashing_data": [
      "self"
    ],
    "set_data_hashing": [
      "self",
      "enabled"
    ]
  },
  "eval_object": [
    "obj"
  ],
  "convert_to_container": [
    "value",
    "container",
    "non_containers",
    "ignore",
    "convert_none"
  ],
  "is_container": [
    "obj"
  ],
  "calc_f": [
    "s",
    "f",
    "squared_integers",
    "grid_data_dct2",
    "N"
  ],
  "_fixed_point": [
    "t",
    "N",
    "squared_integers",
    "grid_data_dct2"
  ],
  "_find_root": [
    "function",
    "N",
    "squared_integers",
    "grid_data_dct2"
  ],
  "_calculate_t_star": [
    "data",
    "num_grid_points",
    "binning_method",
    "weights"
  ],
  "_calculate_density": [
    "t_star",
    "R",
    "squared_integers",
    "grid_data_dct"
  ],
  "calculate_bandwidth": [
    "data",
    "num_grid_points",
    "binning_method",
    "weights"
  ],
  "calculate_bandwidth_and_density": [
    "data",
    "num_grid_points",
    "binning_method",
    "weights"
  ],
  "get_logger": [
    "name",
    "stdout_level",
    "file_level",
    "file_name"
  ],
  "find_practical_support_bandwidth": [
    "kernel",
    "bandwidth",
    "absolute_tolerance"
  ],
  "convolve_1d_data_with_kernel": [
    "kernel",
    "bandwidth",
    "data",
    "grid",
    "support",
    "fft_method"
  ],
  "tensor_like": [],
  "BoolTensor": [],
  "IntTensor": [],
  "RealTensor": [],
  "FloatTensor": [],
  "DoubleTensor": [],
  "ComplexTensor": [],
  "StringTensor": [],
  "generate_1d_grid": [
    "data",
    "num_grid_points",
    "absolute_boundary",
    "relative_boundary"
  ],
  "bin_1d": [
    "binning_method",
    "data",
    "grid",
    "weights"
  ],
  "bin_1d_simple": [
    "data",
    "grid",
    "weights"
  ],
  "bin_1d_linear": [
    "data",
    "grid",
    "weights"
  ],
  "_bin_1d_weighted": [
    "data",
    "grid",
    "weights",
    "method"
  ],
  "ExperimentalFeatureWarning": {},
  "warn_experimental_feature": [
    "func"
  ],
  "AdvancedFeatureWarning": {},
  "warned_advanced": [],
  "warn_advanced_feature": [
    "message",
    "identifier"
  ],
  "ChangedFeatureWarning": {},
  "warned_changed": [],
  "warn_changed_feature": [
    "message",
    "identifier"
  ],
  "warned_changing": [],
  "warn_changing_feature": [
    "message",
    "identifier"
  ],
  "warned_once": [],
  "warn_once": [
    "message",
    "identifier"
  ],
  "dataclass": [
    "cls"
  ],
  "validate_parameter_type": [
    "param",
    "name"
  ],
  "validate_parameters": [],
  "validate_limit_bounds": [
    "lower",
    "upper"
  ],
  "validate_value_in_limits": [
    "value",
    "lower",
    "upper",
    "name"
  ],
  "calculate_limit_tolerance": [
    "lower",
    "upper",
    "exact"
  ],
  "check_at_limit": [
    "value",
    "lower",
    "upper",
    "exact"
  ],
  "validate_parameter_shapes": [],
  "validate_parameter_names": [],
  "format_parameter_error": [
    "expected_type",
    "actual_type",
    "param_name"
  ],
  "validate_stepsize": [
    "stepsize",
    "param_name"
  ],
  "LowerTypeInput": [],
  "LowerTypeReturn": [],
  "UpperTypeInput": [],
  "UpperTypeReturn": [],
  "LowerRectTypeInput": [],
  "LowerRectTypeReturn": [],
  "UpperRectTypeInput": [],
  "UpperRectTypeReturn": [],
  "RectLowerReturnType": [],
  "RectUpperReturnType": [],
  "RectLimitsReturnType": [],
  "RectLimitsTFReturnType": [],
  "RectLimitsNPReturnType": [],
  "RectLimitsInputType": [],
  "LimitsType": [],
  "LimitsTypeSimpleInput": [],
  "LimitsTypeReturn": [],
  "NumericalType": [],
  "LimitsTypeInputV1": [],
  "LimitsFuncTypeInput": [],
  "_IterLimitsTypeReturn": [],
  "AxesTypeInput": [],
  "AxesTypeReturn": [],
  "ObsTypeInput": [],
  "ObsTypeReturn": [],
  "ObsType": [],
  "SpaceOrSpacesTypeInput": [],
  "SpaceType": [],
  "NormInputType": [],
  "XType": [],
  "XTypeInput": [],
  "XTypeReturnNoData": [],
  "XTypeReturn": [],
  "NumericalTypeReturn": [],
  "DataInputType": [],
  "BinnedDataInputType": [],
  "ZfitBinnedDataInputType": [],
  "AnyDataInputType": [],
  "WeightsStrInputType": [],
  "WeightsInputType": [],
  "ModelsInputType": [],
  "PDFInputType": [],
  "BinnedPDFInputType": [],
  "BinnedHistPDFInputType": [],
  "FuncInputType": [],
  "NumericalScalarType": [],
  "nSamplingTypeIn": [],
  "ConstraintsTypeInput": [],
  "ParamsTypeOpt": [],
  "ParamsNameOpt": [],
  "ParamsOrNameType": [],
  "ParameterType": [],
  "ParametersType": [],
  "ParamTypeInput": [],
  "ParamsTypeInput": [],
  "ExtendedInputType": [],
  "BaseObjectType": [],
  "DependentsType": [],
  "CacherOrCachersType": [],
  "LimitsDictAxes": [],
  "LimitsDictObs": [],
  "LimitsDictNoCoords": [],
  "LimitsDictWithCoords": [],
  "BinningTypeInput": [],
  "OptionsInputType": [],
  "ConstraintsInputType": [],
  "ArrayLike": [],
  "ParamValuesMap": [],
  "default_relative_root_tolerance": [
    "dtype"
  ],
  "BrentResults": {},
  "_BrentSearchConstants": {},
  "_BrentSearchState": {},
  "_BrentSearchParams": {},
  "_swap_where": [
    "condition",
    "x",
    "y"
  ],
  "_secant_step": [
    "x1",
    "x2",
    "y1",
    "y2"
  ],
  "_quadratic_interpolation_step": [
    "x1",
    "x2",
    "x3",
    "y1",
    "y2",
    "y3"
  ],
  "_should_stop": [
    "state",
    "stopping_policy_fn"
  ],
  "_brent_loop_body": [
    "state",
    "params",
    "constants"
  ],
  "_prepare_brent_args": [
    "objective_fn",
    "left_bracket",
    "right_bracket",
    "value_at_left_bracket",
    "value_at_right_bracket",
    "absolute_root_tolerance",
    "relative_root_tolerance",
    "function_tolerance",
    "max_iterations",
    "stopping_policy_fn"
  ],
  "_brent": [
    "objective_fn",
    "left_bracket",
    "right_bracket",
    "value_at_left_bracket",
    "value_at_right_bracket",
    "absolute_root_tolerance",
    "relative_root_tolerance",
    "function_tolerance",
    "max_iterations",
    "stopping_policy_fn",
    "validate_args",
    "name"
  ],
  "brentq": [
    "objective_fn",
    "left_bracket",
    "right_bracket",
    "value_at_left_bracket",
    "value_at_right_bracket",
    "absolute_root_tolerance",
    "relative_root_tolerance",
    "function_tolerance",
    "max_iterations",
    "stopping_policy_fn",
    "validate_args",
    "name"
  ],
  "Singleton": {
    "__instance": [],
    "__new__": [
      "cls"
    ]
  },
  "NotSpecified": {
    "__bool__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "NONE": [],
  "ZfitNotImplemented": {
    "__new__": [
      "cls"
    ]
  },
  "RuntimeDependency": {
    "__init__": [
      "self",
      "name",
      "how",
      "error_msg"
    ],
    "__getattr__": [
      "self",
      "item"
    ]
  }
}