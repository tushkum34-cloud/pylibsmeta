{
  "DISABLE_TORCH_KEY": [],
  "DISABLE_JAX_KEY": [],
  "DISABLE_CUPY_KEY": [],
  "DISABLE_TF_KEY": [],
  "str_type_error": [],
  "_BACKEND_IMPLEMENTATIONS": [],
  "_BACKENDS": [],
  "_register_backend_implementation": [
    "backend_impl"
  ],
  "_get_backend_instance": [
    "backend_impl"
  ],
  "_check_args_backend": [
    "backend_impl",
    "args"
  ],
  "get_backend_list": [],
  "get_available_backend_implementations": [],
  "get_backend": [],
  "to_numpy": [],
  "Backend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "__str__": [
      "self"
    ],
    "to_numpy": [
      "self"
    ],
    "_to_numpy": [
      "self",
      "a"
    ],
    "from_numpy": [
      "self"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "detach": [
      "self"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "unsqueeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "a"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "NumpyBackend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "_to_numpy": [
      "self",
      "a"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "unsqueeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "a"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "JaxBackend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "__init__": [
      "self"
    ],
    "_to_numpy": [
      "self",
      "a"
    ],
    "_get_device": [
      "self",
      "a"
    ],
    "_change_device": [
      "self",
      "a",
      "type_as"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "unsqueeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "x"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "TorchBackend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "__init__": [
      "self"
    ],
    "_to_numpy": [
      "self",
      "a"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "unsqueeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "x"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "CupyBackend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "__init__": [
      "self"
    ],
    "_to_numpy": [
      "self",
      "a"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "x"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "TensorflowBackend": {
    "__name__": [],
    "__type__": [],
    "__type_list__": [],
    "rng_": [],
    "__init__": [
      "self"
    ],
    "_to_numpy": [
      "self",
      "a"
    ],
    "_from_numpy": [
      "self",
      "a",
      "type_as"
    ],
    "set_gradients": [
      "self",
      "val",
      "inputs",
      "grads"
    ],
    "_detach": [
      "self",
      "a"
    ],
    "zeros": [
      "self",
      "shape",
      "type_as"
    ],
    "ones": [
      "self",
      "shape",
      "type_as"
    ],
    "arange": [
      "self",
      "stop",
      "start",
      "step",
      "type_as"
    ],
    "full": [
      "self",
      "shape",
      "fill_value",
      "type_as"
    ],
    "eye": [
      "self",
      "N",
      "M",
      "type_as"
    ],
    "sum": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "cumsum": [
      "self",
      "a",
      "axis"
    ],
    "max": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "min": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "maximum": [
      "self",
      "a",
      "b"
    ],
    "minimum": [
      "self",
      "a",
      "b"
    ],
    "sign": [
      "self",
      "a"
    ],
    "dot": [
      "self",
      "a",
      "b"
    ],
    "abs": [
      "self",
      "a"
    ],
    "exp": [
      "self",
      "a"
    ],
    "log": [
      "self",
      "a"
    ],
    "sqrt": [
      "self",
      "a"
    ],
    "power": [
      "self",
      "a",
      "exponents"
    ],
    "norm": [
      "self",
      "a",
      "axis",
      "keepdims"
    ],
    "any": [
      "self",
      "a"
    ],
    "isnan": [
      "self",
      "a"
    ],
    "isinf": [
      "self",
      "a"
    ],
    "einsum": [
      "self",
      "subscripts"
    ],
    "sort": [
      "self",
      "a",
      "axis"
    ],
    "argsort": [
      "self",
      "a",
      "axis"
    ],
    "searchsorted": [
      "self",
      "a",
      "v",
      "side"
    ],
    "flip": [
      "self",
      "a",
      "axis"
    ],
    "outer": [
      "self",
      "a",
      "b"
    ],
    "clip": [
      "self",
      "a",
      "a_min",
      "a_max"
    ],
    "repeat": [
      "self",
      "a",
      "repeats",
      "axis"
    ],
    "take_along_axis": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "concatenate": [
      "self",
      "arrays",
      "axis"
    ],
    "zero_pad": [
      "self",
      "a",
      "pad_width",
      "value"
    ],
    "argmax": [
      "self",
      "a",
      "axis"
    ],
    "argmin": [
      "self",
      "a",
      "axis"
    ],
    "mean": [
      "self",
      "a",
      "axis"
    ],
    "median": [
      "self",
      "a",
      "axis"
    ],
    "std": [
      "self",
      "a",
      "axis"
    ],
    "linspace": [
      "self",
      "start",
      "stop",
      "num",
      "type_as"
    ],
    "meshgrid": [
      "self",
      "a",
      "b"
    ],
    "diag": [
      "self",
      "a",
      "k"
    ],
    "unique": [
      "self",
      "a",
      "return_inverse"
    ],
    "logsumexp": [
      "self",
      "a",
      "axis"
    ],
    "stack": [
      "self",
      "arrays",
      "axis"
    ],
    "reshape": [
      "self",
      "a",
      "shape"
    ],
    "seed": [
      "self",
      "seed"
    ],
    "rand": [
      "self"
    ],
    "randn": [
      "self"
    ],
    "randperm": [
      "self",
      "size",
      "type_as"
    ],
    "_convert_to_index_for_coo": [
      "self",
      "tensor"
    ],
    "coo_matrix": [
      "self",
      "data",
      "rows",
      "cols",
      "shape",
      "type_as"
    ],
    "issparse": [
      "self",
      "a"
    ],
    "tocsr": [
      "self",
      "a"
    ],
    "eliminate_zeros": [
      "self",
      "a",
      "threshold"
    ],
    "todense": [
      "self",
      "a"
    ],
    "where": [
      "self",
      "condition",
      "x",
      "y"
    ],
    "copy": [
      "self",
      "a"
    ],
    "allclose": [
      "self",
      "a",
      "b",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "dtype_device": [
      "self",
      "a"
    ],
    "assert_same_dtype_device": [
      "self",
      "a",
      "b"
    ],
    "squeeze": [
      "self",
      "a",
      "axis"
    ],
    "unsqueeze": [
      "self",
      "a",
      "axis"
    ],
    "bitsize": [
      "self",
      "type_as"
    ],
    "device_type": [
      "self",
      "type_as"
    ],
    "_bench": [
      "self",
      "callable"
    ],
    "solve": [
      "self",
      "a",
      "b"
    ],
    "trace": [
      "self",
      "a"
    ],
    "inv": [
      "self",
      "a"
    ],
    "pinv": [
      "self",
      "a",
      "hermitian"
    ],
    "sqrtm": [
      "self",
      "a"
    ],
    "eigh": [
      "self",
      "a"
    ],
    "kl_div": [
      "self",
      "p",
      "q",
      "mass",
      "eps"
    ],
    "isfinite": [
      "self",
      "a"
    ],
    "array_equal": [
      "self",
      "a",
      "b"
    ],
    "is_floating_point": [
      "self",
      "a"
    ],
    "tile": [
      "self",
      "a",
      "reps"
    ],
    "floor": [
      "self",
      "a"
    ],
    "prod": [
      "self",
      "a",
      "axis"
    ],
    "sort2": [
      "self",
      "a",
      "axis"
    ],
    "qr": [
      "self",
      "a"
    ],
    "atan2": [
      "self",
      "a",
      "b"
    ],
    "transpose": [
      "self",
      "a",
      "axes"
    ],
    "matmul": [
      "self",
      "a",
      "b"
    ],
    "nan_to_num": [
      "self",
      "x",
      "copy",
      "nan",
      "posinf",
      "neginf"
    ],
    "det": [
      "self",
      "x"
    ],
    "slogdet": [
      "self",
      "a"
    ]
  },
  "gaussian_logpdf": [
    "x",
    "m",
    "C"
  ],
  "gaussian_pdf": [
    "x",
    "m",
    "C"
  ],
  "gmm_pdf": [
    "x",
    "m",
    "C",
    "w"
  ],
  "dist_bures_squared": [
    "m_s",
    "m_t",
    "C_s",
    "C_t"
  ],
  "gmm_ot_loss": [
    "m_s",
    "m_t",
    "C_s",
    "C_t",
    "w_s",
    "w_t",
    "log"
  ],
  "gmm_ot_plan": [
    "m_s",
    "m_t",
    "C_s",
    "C_t",
    "w_s",
    "w_t",
    "log"
  ],
  "gmm_ot_apply_map": [
    "x",
    "m_s",
    "m_t",
    "C_s",
    "C_t",
    "w_s",
    "w_t",
    "plan",
    "method",
    "seed"
  ],
  "gmm_ot_plan_density": [
    "x",
    "y",
    "m_s",
    "m_t",
    "C_s",
    "C_t",
    "w_s",
    "w_t",
    "plan",
    "atol"
  ],
  "gmm_barycenter_fixed_point": [
    "means_list",
    "covs_list",
    "w_list",
    "means_init",
    "covs_init",
    "weights",
    "w_bar",
    "iterations",
    "log",
    "barycentric_proj_method"
  ],
  "__all__": [],
  "weak_optimal_transport": [
    "Xa",
    "Xb",
    "a",
    "b",
    "verbose",
    "log",
    "G0"
  ],
  "projection_simplex": [
    "V",
    "z",
    "axis"
  ],
  "Regularization": {
    "__init__": [
      "self",
      "gamma"
    ],
    "delta_Omega": [
      "X"
    ],
    "max_Omega": [
      "X",
      "b"
    ],
    "Omega": [
      "T"
    ]
  },
  "NegEntropy": {
    "delta_Omega": [
      "self",
      "X"
    ],
    "max_Omega": [
      "self",
      "X",
      "b"
    ],
    "Omega": [
      "self",
      "T"
    ]
  },
  "SquaredL2": {
    "delta_Omega": [
      "self",
      "X"
    ],
    "max_Omega": [
      "self",
      "X",
      "b"
    ],
    "Omega": [
      "self",
      "T"
    ]
  },
  "SparsityConstrained": {
    "__init__": [
      "self",
      "max_nz",
      "gamma"
    ],
    "delta_Omega": [
      "self",
      "X"
    ],
    "max_Omega": [
      "self",
      "X",
      "b"
    ],
    "Omega": [
      "self",
      "T"
    ]
  },
  "dual_obj_grad": [
    "alpha",
    "beta",
    "a",
    "b",
    "C",
    "regul"
  ],
  "solve_dual": [
    "a",
    "b",
    "C",
    "regul",
    "method",
    "tol",
    "max_iter",
    "verbose"
  ],
  "semi_dual_obj_grad": [
    "alpha",
    "a",
    "b",
    "C",
    "regul"
  ],
  "solve_semi_dual": [
    "a",
    "b",
    "C",
    "regul",
    "method",
    "tol",
    "max_iter",
    "verbose"
  ],
  "get_plan_from_dual": [
    "alpha",
    "beta",
    "C",
    "regul"
  ],
  "get_plan_from_semi_dual": [
    "alpha",
    "b",
    "C",
    "regul"
  ],
  "smooth_ot_dual": [
    "a",
    "b",
    "M",
    "reg",
    "reg_type",
    "method",
    "stopThr",
    "numItermax",
    "verbose",
    "log",
    "max_nz"
  ],
  "smooth_ot_semi_dual": [
    "a",
    "b",
    "M",
    "reg",
    "reg_type",
    "max_nz",
    "method",
    "stopThr",
    "numItermax",
    "verbose",
    "log"
  ],
  "dist": [
    "x1",
    "x2"
  ],
  "sinkhorn": [
    "w1",
    "w2",
    "M",
    "reg",
    "k"
  ],
  "logsumexp": [
    "M",
    "axis"
  ],
  "sinkhorn_log": [
    "w1",
    "w2",
    "M",
    "reg",
    "k"
  ],
  "split_classes": [
    "X",
    "y"
  ],
  "fda": [
    "X",
    "y",
    "p",
    "reg"
  ],
  "wda": [
    "X",
    "y",
    "p",
    "reg",
    "k",
    "solver",
    "sinkhorn_method",
    "maxiter",
    "verbose",
    "P0",
    "normalize"
  ],
  "projection_robust_wasserstein": [
    "X",
    "Y",
    "a",
    "b",
    "tau",
    "U0",
    "reg",
    "k",
    "stopThr",
    "maxiter",
    "verbose",
    "random_state"
  ],
  "ewca": [
    "X",
    "U0",
    "reg",
    "k",
    "method",
    "sinkhorn_method",
    "stopThr",
    "maxiter",
    "maxiter_sink",
    "maxiter_MM",
    "verbose"
  ],
  "coordinate_grad_semi_dual": [
    "b",
    "M",
    "reg",
    "beta",
    "i"
  ],
  "sag_entropic_transport": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "lr",
    "random_state"
  ],
  "averaged_sgd_entropic_transport": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "lr",
    "random_state"
  ],
  "c_transform_entropic": [
    "b",
    "M",
    "reg",
    "beta"
  ],
  "solve_semi_dual_entropic": [
    "a",
    "b",
    "M",
    "reg",
    "method",
    "numItermax",
    "lr",
    "log"
  ],
  "batch_grad_dual": [
    "a",
    "b",
    "M",
    "reg",
    "alpha",
    "beta",
    "batch_size",
    "batch_alpha",
    "batch_beta"
  ],
  "sgd_entropic_regularization": [
    "a",
    "b",
    "M",
    "reg",
    "batch_size",
    "numItermax",
    "lr",
    "random_state"
  ],
  "solve_dual_entropic": [
    "a",
    "b",
    "M",
    "reg",
    "batch_size",
    "numItermax",
    "lr",
    "log"
  ],
  "loss_dual_entropic": [
    "u",
    "v",
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "metric"
  ],
  "plan_dual_entropic": [
    "u",
    "v",
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "metric"
  ],
  "loss_dual_quadratic": [
    "u",
    "v",
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "metric"
  ],
  "plan_dual_quadratic": [
    "u",
    "v",
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "metric"
  ],
  "get_random_projections": [
    "d",
    "n_projections",
    "seed",
    "backend",
    "type_as"
  ],
  "sliced_wasserstein_distance": [
    "X_s",
    "X_t",
    "a",
    "b",
    "n_projections",
    "p",
    "projections",
    "seed",
    "log"
  ],
  "max_sliced_wasserstein_distance": [
    "X_s",
    "X_t",
    "a",
    "b",
    "n_projections",
    "p",
    "projections",
    "seed",
    "log"
  ],
  "get_projections_sphere": [
    "d",
    "n_projections",
    "seed",
    "backend",
    "type_as"
  ],
  "projection_sphere_to_circle": [
    "x",
    "n_projections",
    "projections",
    "seed",
    "backend"
  ],
  "sliced_wasserstein_sphere": [
    "X_s",
    "X_t",
    "a",
    "b",
    "n_projections",
    "p",
    "projections",
    "seed",
    "log"
  ],
  "sliced_wasserstein_sphere_unif": [
    "X_s",
    "a",
    "n_projections",
    "projections",
    "seed",
    "log"
  ],
  "linear_sliced_wasserstein_sphere": [
    "X_s",
    "X_t",
    "a",
    "b",
    "n_projections",
    "projections",
    "seed",
    "log"
  ],
  "sinkhorn_lpl1_mm": [
    "a",
    "labels_a",
    "b",
    "M",
    "reg",
    "eta",
    "numItermax",
    "numInnerItermax",
    "stopInnerThr",
    "verbose",
    "log"
  ],
  "sinkhorn_l1l2_gl": [
    "a",
    "labels_a",
    "b",
    "M",
    "reg",
    "eta",
    "numItermax",
    "numInnerItermax",
    "stopInnerThr",
    "eps",
    "verbose",
    "log"
  ],
  "OT_mapping_linear": [],
  "emd_laplace": [
    "a",
    "b",
    "xs",
    "xt",
    "M",
    "sim",
    "sim_param",
    "reg",
    "eta",
    "alpha",
    "numItermax",
    "stopThr",
    "numInnerItermax",
    "stopInnerThr",
    "log",
    "verbose"
  ],
  "distribution_estimation_uniform": [
    "X"
  ],
  "BaseTransport": {
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "fit_transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ],
    "transform_labels": [
      "self",
      "ys"
    ],
    "inverse_transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ],
    "inverse_transform_labels": [
      "self",
      "yt"
    ]
  },
  "LinearTransport": {
    "__init__": [
      "self",
      "reg",
      "bias",
      "log",
      "distribution_estimation"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ],
    "inverse_transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ]
  },
  "LinearGWTransport": {
    "__init__": [
      "self",
      "log",
      "sign_eigs",
      "distribution_estimation"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "SinkhornTransport": {
    "__init__": [
      "self",
      "reg_e",
      "method",
      "max_iter",
      "tol",
      "verbose",
      "log",
      "metric",
      "norm",
      "distribution_estimation",
      "out_of_sample_map",
      "limit_max"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ],
    "inverse_transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ]
  },
  "EMDTransport": {
    "__init__": [
      "self",
      "metric",
      "norm",
      "log",
      "distribution_estimation",
      "out_of_sample_map",
      "limit_max",
      "max_iter"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "SinkhornLpl1Transport": {
    "__init__": [
      "self",
      "reg_e",
      "reg_cl",
      "max_iter",
      "max_inner_iter",
      "log",
      "tol",
      "verbose",
      "metric",
      "norm",
      "distribution_estimation",
      "out_of_sample_map",
      "limit_max"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "EMDLaplaceTransport": {
    "__init__": [
      "self",
      "reg_type",
      "reg_lap",
      "reg_src",
      "metric",
      "norm",
      "similarity",
      "similarity_param",
      "max_iter",
      "tol",
      "max_inner_iter",
      "inner_tol",
      "log",
      "verbose",
      "distribution_estimation",
      "out_of_sample_map"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "SinkhornL1l2Transport": {
    "__init__": [
      "self",
      "reg_e",
      "reg_cl",
      "max_iter",
      "max_inner_iter",
      "tol",
      "verbose",
      "log",
      "metric",
      "norm",
      "distribution_estimation",
      "out_of_sample_map",
      "limit_max"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "MappingTransport": {
    "__init__": [
      "self",
      "mu",
      "eta",
      "bias",
      "metric",
      "norm",
      "kernel",
      "sigma",
      "max_iter",
      "tol",
      "max_inner_iter",
      "inner_tol",
      "log",
      "verbose",
      "verbose2"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs"
    ]
  },
  "UnbalancedSinkhornTransport": {
    "__init__": [
      "self",
      "reg_e",
      "reg_m",
      "method",
      "max_iter",
      "tol",
      "verbose",
      "log",
      "metric",
      "norm",
      "distribution_estimation",
      "out_of_sample_map",
      "limit_max"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ]
  },
  "JCPOTTransport": {
    "__init__": [
      "self",
      "reg_e",
      "max_iter",
      "tol",
      "verbose",
      "log",
      "metric",
      "out_of_sample_map"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt",
      "batch_size"
    ],
    "transform_labels": [
      "self",
      "ys"
    ],
    "inverse_transform_labels": [
      "self",
      "yt"
    ]
  },
  "NearestBrenierPotential": {
    "__init__": [
      "self",
      "strongly_convex_constant",
      "gradient_lipschitz_constant",
      "log",
      "its",
      "seed"
    ],
    "fit": [
      "self",
      "Xs",
      "ys",
      "Xt",
      "yt"
    ],
    "transform": [
      "self",
      "Xs",
      "ys"
    ]
  },
  "__time_tic_toc": [],
  "tic": [],
  "toc": [
    "message"
  ],
  "toq": [],
  "kernel": [
    "x1",
    "x2",
    "method",
    "sigma"
  ],
  "laplacian": [
    "x"
  ],
  "list_to_array": [],
  "proj_simplex": [
    "v",
    "z"
  ],
  "projection_sparse_simplex": [
    "V",
    "max_nz",
    "z",
    "axis",
    "nx"
  ],
  "unif": [
    "n",
    "type_as"
  ],
  "clean_zeros": [
    "a",
    "b",
    "M"
  ],
  "euclidean_distances": [
    "X",
    "Y",
    "squared",
    "nx"
  ],
  "dist0": [
    "n",
    "method"
  ],
  "cost_normalization": [
    "C",
    "norm",
    "return_value",
    "value"
  ],
  "dots": [],
  "is_all_finite": [],
  "label_normalization": [
    "y",
    "start",
    "nx"
  ],
  "labels_to_masks": [
    "y",
    "type_as",
    "nx"
  ],
  "parmap": [
    "f",
    "X",
    "nprocs"
  ],
  "check_params": [],
  "check_random_state": [
    "seed"
  ],
  "get_coordinate_circle": [
    "x"
  ],
  "reduce_lazytensor": [
    "a",
    "func",
    "axis",
    "nx",
    "batch_size"
  ],
  "get_lowrank_lazytensor": [
    "Q",
    "R",
    "d",
    "nx"
  ],
  "get_parameter_pair": [
    "parameter"
  ],
  "deprecated": {
    "__init__": [
      "self",
      "extra"
    ],
    "__call__": [
      "self",
      "obj"
    ],
    "_decorate_class": [
      "self",
      "cls"
    ],
    "_decorate_fun": [
      "self",
      "fun"
    ],
    "_update_doc": [
      "self",
      "olddoc"
    ]
  },
  "_is_deprecated": [
    "func"
  ],
  "BaseEstimator": {
    "_get_backend": [
      "self"
    ],
    "_get_param_names": [
      "cls"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "UndefinedParameter": {},
  "OTResult": {
    "__init__": [
      "self",
      "potentials",
      "value",
      "value_linear",
      "value_quad",
      "plan",
      "log",
      "backend",
      "sparse_plan",
      "lazy_plan",
      "status",
      "batch_size"
    ],
    "__repr__": [
      "self"
    ],
    "potentials": [
      "self"
    ],
    "potential_a": [
      "self"
    ],
    "potential_b": [
      "self"
    ],
    "plan": [
      "self"
    ],
    "sparse_plan": [
      "self"
    ],
    "lazy_plan": [
      "self"
    ],
    "value": [
      "self"
    ],
    "value_linear": [
      "self"
    ],
    "value_quad": [
      "self"
    ],
    "marginals": [
      "self"
    ],
    "marginal_a": [
      "self"
    ],
    "marginal_b": [
      "self"
    ],
    "status": [
      "self"
    ],
    "log": [
      "self"
    ],
    "a_to_b": [
      "self"
    ],
    "b_to_a": [
      "self"
    ],
    "citation": [
      "self"
    ]
  },
  "LazyTensor": {
    "__init__": [
      "self",
      "shape",
      "getitem"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__repr__": [
      "self"
    ]
  },
  "proj_SDP": [
    "S",
    "nx",
    "vmin"
  ],
  "exp_bures": [
    "Sigma",
    "S",
    "nx"
  ],
  "check_number_threads": [
    "numThreads"
  ],
  "fun_to_numpy": [
    "fun",
    "arr",
    "nx",
    "warn"
  ],
  "_init_lr_sinkhorn": [
    "X_s",
    "X_t",
    "a",
    "b",
    "rank",
    "init",
    "reg_init",
    "random_state",
    "nx"
  ],
  "compute_lr_sqeuclidean_matrix": [
    "X_s",
    "X_t",
    "rescale_cost",
    "nx"
  ],
  "_LR_Dysktra": [
    "eps1",
    "eps2",
    "eps3",
    "p1",
    "p2",
    "alpha",
    "stopThr",
    "numItermax",
    "warn",
    "nx"
  ],
  "lowrank_sinkhorn": [
    "X_s",
    "X_t",
    "a",
    "b",
    "reg",
    "rank",
    "alpha",
    "rescale_cost",
    "init",
    "reg_init",
    "seed_init",
    "gamma_init",
    "numItermax",
    "stopThr",
    "warn",
    "log"
  ],
  "kernel_nystroem": [
    "X_s",
    "X_t",
    "anchors",
    "sigma",
    "random_state"
  ],
  "sinkhorn_low_rank_kernel": [
    "K1",
    "K2",
    "a",
    "b",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "__version__": [],
  "lst_method_lazy": [],
  "solve": [
    "M",
    "a",
    "b",
    "reg",
    "c",
    "reg_type",
    "unbalanced",
    "unbalanced_type",
    "method",
    "n_threads",
    "max_iter",
    "plan_init",
    "potentials_init",
    "tol",
    "verbose",
    "grad"
  ],
  "solve_gromov": [
    "Ca",
    "Cb",
    "M",
    "a",
    "b",
    "loss",
    "symmetric",
    "alpha",
    "reg",
    "reg_type",
    "unbalanced",
    "unbalanced_type",
    "n_threads",
    "method",
    "max_iter",
    "plan_init",
    "tol",
    "verbose"
  ],
  "solve_sample": [
    "X_a",
    "X_b",
    "a",
    "b",
    "metric",
    "reg",
    "c",
    "reg_type",
    "unbalanced",
    "unbalanced_type",
    "lazy",
    "batch_size",
    "method",
    "n_threads",
    "max_iter",
    "plan_init",
    "rank",
    "scaling",
    "potentials_init",
    "X_init",
    "tol",
    "verbose",
    "grad",
    "random_state"
  ],
  "bures_wasserstein_mapping": [
    "ms",
    "mt",
    "Cs",
    "Ct",
    "log"
  ],
  "empirical_bures_wasserstein_mapping": [
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "bias",
    "log"
  ],
  "bures_distance": [
    "Cs",
    "Ct",
    "paired",
    "log",
    "nx"
  ],
  "bures_wasserstein_distance": [
    "ms",
    "mt",
    "Cs",
    "Ct",
    "paired",
    "log"
  ],
  "empirical_bures_wasserstein_distance": [
    "xs",
    "xt",
    "reg",
    "ws",
    "wt",
    "bias",
    "log"
  ],
  "bures_barycenter_fixpoint": [
    "C",
    "weights",
    "num_iter",
    "eps",
    "log",
    "nx"
  ],
  "bures_barycenter_gradient_descent": [
    "C",
    "weights",
    "num_iter",
    "eps",
    "log",
    "step_size",
    "batch_size",
    "averaged",
    "nx"
  ],
  "bures_wasserstein_barycenter": [
    "m",
    "C",
    "weights",
    "method",
    "num_iter",
    "eps",
    "log",
    "step_size",
    "batch_size"
  ],
  "empirical_bures_wasserstein_barycenter": [
    "X",
    "reg",
    "weights",
    "num_iter",
    "eps",
    "w",
    "bias",
    "log"
  ],
  "gaussian_gromov_wasserstein_distance": [
    "Cov_s",
    "Cov_t",
    "log"
  ],
  "empirical_gaussian_gromov_wasserstein_distance": [
    "xs",
    "xt",
    "ws",
    "wt",
    "log"
  ],
  "gaussian_gromov_wasserstein_mapping": [
    "mu_s",
    "mu_t",
    "Cov_s",
    "Cov_t",
    "sign_eigs",
    "log"
  ],
  "empirical_gaussian_gromov_wasserstein_mapping": [
    "xs",
    "xt",
    "ws",
    "wt",
    "sign_eigs",
    "log"
  ],
  "plot1D_mat": [
    "a",
    "b",
    "M",
    "title",
    "plot_style",
    "a_label",
    "b_label",
    "color_source",
    "color_target",
    "coupling_cmap"
  ],
  "rescale_for_imshow_plot": [
    "x",
    "y",
    "n",
    "m",
    "a_y",
    "b_y"
  ],
  "plot2D_samples_mat": [
    "xs",
    "xt",
    "G",
    "thr"
  ],
  "make_1D_gauss": [
    "n",
    "m",
    "s"
  ],
  "get_1D_gauss": [
    "n",
    "m",
    "sigma"
  ],
  "make_2D_samples_gauss": [
    "n",
    "m",
    "sigma",
    "random_state"
  ],
  "get_2D_samples_gauss": [
    "n",
    "m",
    "sigma",
    "random_state"
  ],
  "make_data_classif": [
    "dataset",
    "n",
    "nz",
    "theta",
    "p",
    "random_state"
  ],
  "get_data_classif": [
    "dataset",
    "n",
    "nz",
    "theta",
    "random_state"
  ],
  "line_search_armijo": [
    "f",
    "xk",
    "pk",
    "gfk",
    "old_fval",
    "args",
    "c1",
    "alpha0",
    "alpha_min",
    "alpha_max",
    "nx"
  ],
  "generic_conditional_gradient": [
    "a",
    "b",
    "M",
    "f",
    "df",
    "reg1",
    "reg2",
    "lp_solver",
    "line_search",
    "G0",
    "numItermax",
    "stopThr",
    "stopThr2",
    "verbose",
    "log",
    "nx"
  ],
  "cg": [
    "a",
    "b",
    "M",
    "reg",
    "f",
    "df",
    "G0",
    "line_search",
    "numItermax",
    "numItermaxEmd",
    "stopThr",
    "stopThr2",
    "verbose",
    "log",
    "nx"
  ],
  "semirelaxed_cg": [
    "a",
    "b",
    "M",
    "reg",
    "f",
    "df",
    "G0",
    "line_search",
    "numItermax",
    "stopThr",
    "stopThr2",
    "verbose",
    "log",
    "nx"
  ],
  "partial_cg": [
    "a",
    "b",
    "a_extended",
    "b_extended",
    "M",
    "reg",
    "f",
    "df",
    "G0",
    "line_search",
    "numItermax",
    "stopThr",
    "stopThr2",
    "warn",
    "verbose",
    "log"
  ],
  "gcg": [
    "a",
    "b",
    "M",
    "reg1",
    "reg2",
    "f",
    "df",
    "G0",
    "numItermax",
    "numInnerItermax",
    "stopThr",
    "stopThr2",
    "verbose",
    "log"
  ],
  "solve_1d_linesearch_quad": [
    "a",
    "b"
  ],
  "co_optimal_transport": [
    "X",
    "Y",
    "wx_samp",
    "wx_feat",
    "wy_samp",
    "wy_feat",
    "epsilon",
    "alpha",
    "M_samp",
    "M_feat",
    "warmstart",
    "nits_bcd",
    "tol_bcd",
    "eval_bcd",
    "nits_ot",
    "tol_sinkhorn",
    "method_sinkhorn",
    "early_stopping_tol",
    "log",
    "verbose"
  ],
  "co_optimal_transport2": [
    "X",
    "Y",
    "wx_samp",
    "wx_feat",
    "wy_samp",
    "wy_feat",
    "epsilon",
    "alpha",
    "M_samp",
    "M_feat",
    "warmstart",
    "log",
    "verbose",
    "early_stopping_tol",
    "nits_bcd",
    "tol_bcd",
    "eval_bcd",
    "nits_ot",
    "tol_sinkhorn",
    "method_sinkhorn"
  ],
  "factored_optimal_transport": [
    "Xa",
    "Xb",
    "a",
    "b",
    "reg",
    "r",
    "X0",
    "stopThr",
    "numItermax",
    "verbose",
    "log"
  ],
  "recast_ot_as_lasso": [
    "a",
    "b",
    "C"
  ],
  "recast_semi_relaxed_as_lasso": [
    "a",
    "b",
    "C"
  ],
  "ot_next_gamma": [
    "phi",
    "delta",
    "HtH",
    "Hty",
    "c",
    "active_index",
    "current_gamma"
  ],
  "semi_relaxed_next_gamma": [
    "phi",
    "delta",
    "phi_u",
    "delta_u",
    "HrHr",
    "Hc",
    "Hra",
    "c",
    "active_index",
    "current_gamma"
  ],
  "compute_next_removal": [
    "phi",
    "delta",
    "current_gamma"
  ],
  "complement_schur": [
    "M_current",
    "b",
    "d",
    "id_pop"
  ],
  "construct_augmented_H": [
    "active_index",
    "m",
    "Hc",
    "HrHr"
  ],
  "fully_relaxed_path": [
    "a",
    "b",
    "C",
    "reg",
    "itmax"
  ],
  "semi_relaxed_path": [
    "a",
    "b",
    "C",
    "reg",
    "itmax"
  ],
  "regularization_path": [
    "a",
    "b",
    "C",
    "reg",
    "semi_relaxed",
    "itmax"
  ],
  "compute_transport_plan": [
    "gamma",
    "gamma_list",
    "Pi_list"
  ],
  "nearest_brenier_potential_fit": [
    "X",
    "V",
    "X_classes",
    "a",
    "b",
    "strongly_convex_constant",
    "gradient_lipschitz_constant",
    "its",
    "log",
    "init_method",
    "solver"
  ],
  "_ssnb_qcqp_constants": [
    "strongly_convex_constant",
    "gradient_lipschitz_constant"
  ],
  "nearest_brenier_potential_predict_bounds": [
    "X",
    "phi",
    "G",
    "Y",
    "X_classes",
    "Y_classes",
    "strongly_convex_constant",
    "gradient_lipschitz_constant",
    "log",
    "solver"
  ],
  "joint_OT_mapping_linear": [
    "xs",
    "xt",
    "mu",
    "eta",
    "bias",
    "verbose",
    "verbose2",
    "numItermax",
    "numInnerItermax",
    "stopInnerThr",
    "stopThr",
    "log"
  ],
  "joint_OT_mapping_kernel": [
    "xs",
    "xt",
    "mu",
    "eta",
    "kerneltype",
    "sigma",
    "bias",
    "verbose",
    "verbose2",
    "numItermax",
    "numInnerItermax",
    "stopInnerThr",
    "stopThr",
    "log"
  ],
  "center_ot_dual": [
    "alpha0",
    "beta0",
    "a",
    "b"
  ],
  "estimate_dual_null_weights": [
    "alpha0",
    "beta0",
    "a",
    "b",
    "M"
  ],
  "emd": [
    "a",
    "b",
    "M",
    "numItermax",
    "log",
    "center_dual",
    "numThreads",
    "check_marginals"
  ],
  "emd2": [
    "a",
    "b",
    "M",
    "processes",
    "numItermax",
    "log",
    "return_matrix",
    "center_dual",
    "numThreads",
    "check_marginals"
  ],
  "dist_monge_max_min": [
    "i"
  ],
  "dmmot_monge_1dgrid_loss": [
    "A",
    "verbose",
    "log"
  ],
  "dmmot_monge_1dgrid_optimize": [
    "A",
    "niters",
    "lr_init",
    "lr_decay",
    "print_rate",
    "verbose",
    "log"
  ],
  "scipy_sparse_to_spmatrix": [
    "A"
  ],
  "barycenter": [
    "A",
    "M",
    "weights",
    "verbose",
    "log",
    "solver"
  ],
  "free_support_barycenter": [
    "measures_locations",
    "measures_weights",
    "X_init",
    "b",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "numThreads"
  ],
  "generalized_free_support_barycenter": [
    "X_list",
    "a_list",
    "P_list",
    "n_samples_bary",
    "Y_init",
    "b",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "numThreads",
    "eps"
  ],
  "ot_barycenter_energy": [
    "measure_locations",
    "measure_weights",
    "X",
    "a",
    "cost_list",
    "nx"
  ],
  "free_support_barycenter_generic_costs": [
    "measure_locations",
    "measure_weights",
    "X_init",
    "cost_list",
    "ground_bary",
    "a",
    "numItermax",
    "method",
    "stopThr",
    "log",
    "ground_bary_lr",
    "ground_bary_numItermax",
    "ground_bary_stopThr",
    "ground_bary_solver",
    "clean_measure"
  ],
  "_to_int_array": [
    "x",
    "nx"
  ],
  "NorthWestMMGluing": [
    "pi_list",
    "a",
    "log",
    "nx"
  ],
  "_clean_discrete_measure": [
    "X",
    "a",
    "tol",
    "nx"
  ],
  "quantile_function": [
    "qs",
    "cws",
    "xs"
  ],
  "wasserstein_1d": [
    "u_values",
    "v_values",
    "u_weights",
    "v_weights",
    "p",
    "require_sort"
  ],
  "emd_1d": [
    "x_a",
    "x_b",
    "a",
    "b",
    "metric",
    "p",
    "dense",
    "log",
    "check_marginals"
  ],
  "emd2_1d": [
    "x_a",
    "x_b",
    "a",
    "b",
    "metric",
    "p",
    "dense",
    "log"
  ],
  "roll_cols": [
    "M",
    "shifts"
  ],
  "derivative_cost_on_circle": [
    "theta",
    "u_values",
    "v_values",
    "u_cdf",
    "v_cdf",
    "p"
  ],
  "ot_cost_on_circle": [
    "theta",
    "u_values",
    "v_values",
    "u_cdf",
    "v_cdf",
    "p"
  ],
  "binary_search_circle": [
    "u_values",
    "v_values",
    "u_weights",
    "v_weights",
    "p",
    "Lm",
    "Lp",
    "tm",
    "tp",
    "eps",
    "require_sort",
    "log"
  ],
  "wasserstein1_circle": [
    "u_values",
    "v_values",
    "u_weights",
    "v_weights",
    "require_sort"
  ],
  "wasserstein_circle": [
    "u_values",
    "v_values",
    "u_weights",
    "v_weights",
    "p",
    "Lm",
    "Lp",
    "tm",
    "tp",
    "eps",
    "require_sort"
  ],
  "semidiscrete_wasserstein2_unif_circle": [
    "u_values",
    "u_weights"
  ],
  "linear_circular_embedding": [
    "x",
    "u_values",
    "u_weights",
    "require_sort"
  ],
  "linear_circular_ot": [
    "u_values",
    "v_values",
    "u_weights",
    "v_weights"
  ],
  "geometricBar": [
    "weights",
    "alldistribT"
  ],
  "geometricMean": [
    "alldistribT"
  ],
  "projR": [
    "gamma",
    "p"
  ],
  "projC": [
    "gamma",
    "q"
  ],
  "_warning_msg": [],
  "_get_convol_img_fn": [
    "nx",
    "width",
    "height",
    "reg",
    "type_as",
    "log_domain"
  ],
  "_print_report": [
    "ii",
    "err"
  ],
  "convolutional_barycenter2d": [
    "A",
    "reg",
    "weights",
    "method",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "_convolutional_barycenter2d": [
    "A",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "stabThr",
    "verbose",
    "log",
    "warn"
  ],
  "_convolutional_barycenter2d_log": [
    "A",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "stabThr",
    "verbose",
    "log",
    "warn"
  ],
  "convolutional_barycenter2d_debiased": [
    "A",
    "reg",
    "weights",
    "method",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "_convolutional_barycenter2d_debiased": [
    "A",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "stabThr",
    "verbose",
    "log",
    "warn"
  ],
  "_convolutional_barycenter2d_debiased_log": [
    "A",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "stabThr",
    "verbose",
    "log",
    "warn"
  ],
  "barycenter_sinkhorn": [
    "A",
    "M",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "free_support_sinkhorn_barycenter": [
    "measures_locations",
    "measures_weights",
    "X_init",
    "reg",
    "b",
    "weights",
    "numItermax",
    "numInnerItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "_barycenter_sinkhorn_log": [
    "A",
    "M",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "barycenter_stabilized": [
    "A",
    "M",
    "reg",
    "tau",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "barycenter_debiased": [
    "A",
    "M",
    "reg",
    "weights",
    "method",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "_barycenter_debiased": [
    "A",
    "M",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "_barycenter_debiased_log": [
    "A",
    "M",
    "reg",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "jcpot_barycenter": [
    "Xs",
    "Ys",
    "Xt",
    "reg",
    "metric",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "sinkhorn2": [
    "a",
    "b",
    "M",
    "reg",
    "method",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "sinkhorn_knopp": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "greenkhorn": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "sinkhorn_stabilized": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "tau",
    "stopThr",
    "warmstart",
    "verbose",
    "print_period",
    "log",
    "warn"
  ],
  "sinkhorn_epsilon_scaling": [
    "a",
    "b",
    "M",
    "reg",
    "numItermax",
    "epsilon0",
    "numInnerItermax",
    "tau",
    "stopThr",
    "warmstart",
    "verbose",
    "print_period",
    "log",
    "warn"
  ],
  "screenkhorn": [
    "a",
    "b",
    "M",
    "reg",
    "ns_budget",
    "nt_budget",
    "uniform",
    "restricted",
    "maxiter",
    "maxfun",
    "pgtol",
    "verbose",
    "log"
  ],
  "get_sinkhorn_lazytensor": [
    "X_a",
    "X_b",
    "f",
    "g",
    "metric",
    "reg",
    "nx"
  ],
  "empirical_sinkhorn": [
    "X_s",
    "X_t",
    "reg",
    "a",
    "b",
    "metric",
    "numIterMax",
    "stopThr",
    "isLazy",
    "batchSize",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "empirical_sinkhorn2": [
    "X_s",
    "X_t",
    "reg",
    "a",
    "b",
    "metric",
    "numIterMax",
    "stopThr",
    "isLazy",
    "batchSize",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "empirical_sinkhorn_divergence": [
    "X_s",
    "X_t",
    "reg",
    "a",
    "b",
    "metric",
    "numIterMax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart"
  ],
  "empirical_sinkhorn_nystroem": [
    "X_s",
    "X_t",
    "reg",
    "anchors",
    "a",
    "b",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart",
    "random_state"
  ],
  "empirical_sinkhorn_nystroem2": [
    "X_s",
    "X_t",
    "reg",
    "anchors",
    "a",
    "b",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn",
    "warmstart",
    "random_state"
  ],
  "unmix": [
    "a",
    "D",
    "M",
    "M0",
    "h0",
    "reg",
    "reg0",
    "alpha",
    "numItermax",
    "stopThr",
    "verbose",
    "log",
    "warn"
  ],
  "get_sinkhorn_geomloss_lazytensor": [
    "X_a",
    "X_b",
    "f",
    "g",
    "a",
    "b",
    "metric",
    "blur",
    "nx"
  ],
  "empirical_sinkhorn2_geomloss": [
    "X_s",
    "X_t",
    "reg",
    "a",
    "b",
    "metric",
    "scaling",
    "verbose",
    "debias",
    "log",
    "backend"
  ],
  "entropy_batch": [
    "T",
    "nx",
    "eps"
  ],
  "norm_batch": [
    "u",
    "p",
    "nx"
  ],
  "bmv": [
    "A",
    "b",
    "nx"
  ],
  "bop": [
    "a",
    "b",
    "nx"
  ],
  "bregman_projection_batch": [
    "K",
    "a",
    "b",
    "nx",
    "max_iter",
    "tol",
    "grad"
  ],
  "bregman_log_projection_batch": [
    "K",
    "a",
    "b",
    "nx",
    "max_iter",
    "tol",
    "grad"
  ],
  "dist_lp_batch": [
    "X",
    "Y",
    "p",
    "q",
    "nx"
  ],
  "dist_euclidean_batch": [
    "X",
    "Y",
    "squared",
    "nx"
  ],
  "dist_kl_batch": [
    "X",
    "Y",
    "logits_X",
    "nx",
    "eps"
  ],
  "loss_linear_batch": [
    "M",
    "T",
    "nx"
  ],
  "loss_linear_samples_batch": [
    "X",
    "Y",
    "T",
    "metric"
  ],
  "dist_batch": [
    "X1",
    "X2",
    "metric",
    "p",
    "nx"
  ],
  "solve_batch": [
    "M",
    "reg",
    "a",
    "b",
    "max_iter",
    "tol",
    "solver",
    "reg_type",
    "grad"
  ],
  "solve_sample_batch": [
    "X_a",
    "X_b",
    "reg",
    "a",
    "b",
    "metric",
    "p",
    "max_iter",
    "tol",
    "solver",
    "reg_type",
    "grad"
  ],
  "tensor_batch": [
    "a",
    "b",
    "C1",
    "C2",
    "symmetric",
    "nx",
    "loss",
    "logits"
  ],
  "loss_quadratic_batch": [
    "L",
    "T",
    "recompute_const",
    "symmetric",
    "nx"
  ],
  "loss_quadratic_samples_batch": [
    "a",
    "b",
    "C1",
    "C2",
    "T",
    "loss",
    "symmetric",
    "nx",
    "logits",
    "recompute_const"
  ],
  "solve_gromov_batch": [
    "C1",
    "C2",
    "reg",
    "a",
    "b",
    "loss",
    "symmetric",
    "M",
    "alpha",
    "T_init",
    "max_iter",
    "tol",
    "max_iter_inner",
    "tol_inner",
    "grad",
    "logits"
  ],
  "compute_tensor_batch": [
    "f1",
    "f2",
    "h1",
    "h2",
    "a",
    "b",
    "C1",
    "C2",
    "symmetric"
  ],
  "tensor_product_batch": [
    "L",
    "T",
    "nx",
    "recompute_const",
    "symmetric"
  ],
  "transpose": [
    "C",
    "nx"
  ],
  "compute_const_from_marginals": [
    "fC1",
    "fC2",
    "a",
    "b",
    "nx"
  ],
  "detach_cost_tensor": [
    "L",
    "nx"
  ],
  "sinkhorn_unbalanced": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "method",
    "reg_type",
    "c",
    "warmstart",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "sinkhorn_unbalanced2": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "method",
    "reg_type",
    "c",
    "warmstart",
    "returnCost",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "sinkhorn_knopp_unbalanced": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "reg_type",
    "c",
    "warmstart",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "sinkhorn_stabilized_unbalanced": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "reg_type",
    "c",
    "warmstart",
    "tau",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "sinkhorn_unbalanced_translation_invariant": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "reg_type",
    "c",
    "warmstart",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "barycenter_unbalanced_stabilized": [
    "A",
    "M",
    "reg",
    "reg_m",
    "weights",
    "tau",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "barycenter_unbalanced_sinkhorn": [
    "A",
    "M",
    "reg",
    "reg_m",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "barycenter_unbalanced": [
    "A",
    "M",
    "reg",
    "reg_m",
    "method",
    "weights",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "mm_unbalanced": [
    "a",
    "b",
    "M",
    "reg_m",
    "c",
    "reg",
    "div",
    "G0",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "mm_unbalanced2": [
    "a",
    "b",
    "M",
    "reg_m",
    "c",
    "reg",
    "div",
    "G0",
    "returnCost",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "_get_loss_unbalanced": [
    "a",
    "b",
    "c",
    "M",
    "reg",
    "reg_m1",
    "reg_m2",
    "reg_div",
    "regm_div"
  ],
  "lbfgsb_unbalanced": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "c",
    "reg_div",
    "regm_div",
    "G0",
    "numItermax",
    "stopThr",
    "method",
    "verbose",
    "log"
  ],
  "lbfgsb_unbalanced2": [
    "a",
    "b",
    "M",
    "reg",
    "reg_m",
    "c",
    "reg_div",
    "regm_div",
    "G0",
    "returnCost",
    "numItermax",
    "stopThr",
    "method",
    "verbose",
    "log"
  ],
  "_transform_matrix": [
    "C1",
    "C2",
    "loss_fun",
    "nx"
  ],
  "init_matrix": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "nx"
  ],
  "tensor_product": [
    "constC",
    "hC1",
    "hC2",
    "T",
    "nx"
  ],
  "gwloss": [
    "constC",
    "hC1",
    "hC2",
    "T",
    "nx"
  ],
  "gwggrad": [
    "constC",
    "hC1",
    "hC2",
    "T",
    "nx"
  ],
  "init_matrix_semirelaxed": [
    "C1",
    "C2",
    "p",
    "loss_fun",
    "nx"
  ],
  "semirelaxed_init_plan": [
    "C1",
    "C2",
    "p",
    "M",
    "alpha",
    "method",
    "use_target",
    "random_state",
    "nx"
  ],
  "update_barycenter_structure": [
    "Ts",
    "Cs",
    "lambdas",
    "p",
    "loss_fun",
    "target",
    "check_zeros",
    "nx"
  ],
  "update_barycenter_feature": [
    "Ts",
    "Ys",
    "lambdas",
    "p",
    "loss_fun",
    "target",
    "check_zeros",
    "nx"
  ],
  "div_to_product": [
    "pi",
    "a",
    "b",
    "pi1",
    "pi2",
    "divergence",
    "mass",
    "nx"
  ],
  "div_between_product": [
    "mu",
    "nu",
    "alpha",
    "beta",
    "divergence",
    "nx"
  ],
  "uot_cost_matrix": [
    "data",
    "pi",
    "tuple_p",
    "hyperparams",
    "divergence",
    "reg_type",
    "nx"
  ],
  "uot_parameters_and_measures": [
    "pi",
    "tuple_weights",
    "hyperparams",
    "reg_type",
    "divergence",
    "nx"
  ],
  "fused_unbalanced_across_spaces_cost": [
    "M_linear",
    "data",
    "tuple_pxy_samp",
    "tuple_pxy_feat",
    "pi_samp",
    "pi_feat",
    "hyperparams",
    "divergence",
    "reg_type",
    "nx"
  ],
  "GW_distance_estimation": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "T",
    "nb_samples_p",
    "nb_samples_q",
    "std",
    "random_state"
  ],
  "pointwise_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "alpha",
    "max_iter",
    "threshold_plan",
    "log",
    "verbose",
    "random_state"
  ],
  "sampled_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "nb_samples_grad",
    "epsilon",
    "max_iter",
    "log",
    "verbose",
    "random_state"
  ],
  "entropic_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "solver",
    "warmstart",
    "verbose",
    "log"
  ],
  "entropic_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "solver",
    "warmstart",
    "verbose",
    "log"
  ],
  "BAPG_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "marginal_loss",
    "verbose",
    "log"
  ],
  "BAPG_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "marginal_loss",
    "verbose",
    "log"
  ],
  "entropic_gromov_barycenters": [
    "N",
    "Cs",
    "ps",
    "p",
    "lambdas",
    "loss_fun",
    "epsilon",
    "symmetric",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "random_state"
  ],
  "entropic_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "solver",
    "warmstart",
    "verbose",
    "log"
  ],
  "entropic_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "solver",
    "warmstart",
    "verbose",
    "log"
  ],
  "BAPG_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "marginal_loss",
    "verbose",
    "log"
  ],
  "BAPG_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "epsilon",
    "symmetric",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "marginal_loss",
    "verbose",
    "log"
  ],
  "entropic_fused_gromov_barycenters": [
    "N",
    "Ys",
    "Cs",
    "ps",
    "p",
    "lambdas",
    "loss_fun",
    "epsilon",
    "symmetric",
    "alpha",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "init_Y",
    "fixed_structure",
    "fixed_features",
    "random_state"
  ],
  "semirelaxed_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "log",
    "G0",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "semirelaxed_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "log",
    "G0",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "semirelaxed_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "alpha",
    "G0",
    "log",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "semirelaxed_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "alpha",
    "G0",
    "log",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "solve_semirelaxed_gromov_linesearch": [
    "G",
    "deltaG",
    "cost_G",
    "C1",
    "C2",
    "ones_p",
    "M",
    "reg",
    "fC2t",
    "alpha_min",
    "alpha_max",
    "nx"
  ],
  "entropic_semirelaxed_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "log",
    "verbose",
    "random_state"
  ],
  "entropic_semirelaxed_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "loss_fun",
    "epsilon",
    "symmetric",
    "G0",
    "max_iter",
    "tol",
    "log",
    "verbose",
    "random_state"
  ],
  "entropic_semirelaxed_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "epsilon",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "log",
    "verbose",
    "random_state"
  ],
  "entropic_semirelaxed_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "loss_fun",
    "symmetric",
    "epsilon",
    "alpha",
    "G0",
    "max_iter",
    "tol",
    "log",
    "verbose",
    "random_state"
  ],
  "semirelaxed_gromov_barycenters": [
    "N",
    "Cs",
    "ps",
    "lambdas",
    "loss_fun",
    "symmetric",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "G0",
    "random_state"
  ],
  "semirelaxed_fgw_barycenters": [
    "N",
    "Ys",
    "Cs",
    "ps",
    "lambdas",
    "alpha",
    "fixed_structure",
    "fixed_features",
    "p",
    "loss_fun",
    "symmetric",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "init_X",
    "G0",
    "random_state"
  ],
  "gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "symmetric",
    "log",
    "armijo",
    "G0",
    "max_iter",
    "tol_rel",
    "tol_abs"
  ],
  "gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "symmetric",
    "log",
    "armijo",
    "G0",
    "max_iter",
    "tol_rel",
    "tol_abs"
  ],
  "fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "symmetric",
    "alpha",
    "armijo",
    "G0",
    "log",
    "max_iter",
    "tol_rel",
    "tol_abs"
  ],
  "fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "loss_fun",
    "symmetric",
    "alpha",
    "armijo",
    "G0",
    "log",
    "max_iter",
    "tol_rel",
    "tol_abs"
  ],
  "solve_gromov_linesearch": [
    "G",
    "deltaG",
    "cost_G",
    "C1",
    "C2",
    "M",
    "reg",
    "alpha_min",
    "alpha_max",
    "nx",
    "symmetric"
  ],
  "gromov_barycenters": [
    "N",
    "Cs",
    "ps",
    "p",
    "lambdas",
    "loss_fun",
    "symmetric",
    "armijo",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "random_state"
  ],
  "fgw_barycenters": [
    "N",
    "Ys",
    "Cs",
    "ps",
    "lambdas",
    "alpha",
    "fixed_structure",
    "fixed_features",
    "p",
    "loss_fun",
    "armijo",
    "symmetric",
    "max_iter",
    "tol",
    "stop_criterion",
    "warmstartT",
    "verbose",
    "log",
    "init_C",
    "init_X",
    "random_state"
  ],
  "quantized_fused_gromov_wasserstein_partitioned": [
    "CR1",
    "CR2",
    "list_R1",
    "list_R2",
    "list_p1",
    "list_p2",
    "MR",
    "alpha",
    "build_OT",
    "log",
    "armijo",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "nx"
  ],
  "get_graph_partition": [
    "C",
    "npart",
    "part_method",
    "F",
    "alpha",
    "random_state",
    "nx"
  ],
  "get_graph_representants": [
    "C",
    "part",
    "rep_method",
    "random_state",
    "nx"
  ],
  "format_partitioned_graph": [
    "C",
    "p",
    "part",
    "rep_indices",
    "F",
    "M",
    "alpha",
    "nx"
  ],
  "quantized_fused_gromov_wasserstein": [
    "C1",
    "C2",
    "npart1",
    "npart2",
    "p",
    "q",
    "C1_aux",
    "C2_aux",
    "F1",
    "F2",
    "alpha",
    "part_method",
    "rep_method",
    "log",
    "armijo",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "get_partition_and_representants_samples": [
    "X",
    "npart",
    "method",
    "random_state",
    "nx"
  ],
  "format_partitioned_samples": [
    "X",
    "p",
    "part",
    "rep_indices",
    "F",
    "alpha",
    "nx"
  ],
  "quantized_fused_gromov_wasserstein_samples": [
    "X1",
    "X2",
    "npart1",
    "npart2",
    "p",
    "q",
    "F1",
    "F2",
    "alpha",
    "method",
    "log",
    "armijo",
    "max_iter",
    "tol_rel",
    "tol_abs",
    "random_state"
  ],
  "partial_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "m",
    "loss_fun",
    "nb_dummies",
    "G0",
    "thres",
    "numItermax",
    "tol",
    "symmetric",
    "warn",
    "log",
    "verbose"
  ],
  "partial_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "q",
    "m",
    "loss_fun",
    "nb_dummies",
    "G0",
    "thres",
    "numItermax",
    "tol",
    "symmetric",
    "warn",
    "log",
    "verbose"
  ],
  "partial_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "m",
    "loss_fun",
    "alpha",
    "nb_dummies",
    "G0",
    "thres",
    "numItermax",
    "tol",
    "symmetric",
    "warn",
    "log",
    "verbose"
  ],
  "partial_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "m",
    "loss_fun",
    "alpha",
    "nb_dummies",
    "G0",
    "thres",
    "numItermax",
    "tol",
    "symmetric",
    "warn",
    "log",
    "verbose"
  ],
  "solve_partial_gromov_linesearch": [
    "G",
    "deltaG",
    "cost_G",
    "df_G",
    "df_Gc",
    "M",
    "reg",
    "alpha_min",
    "alpha_max",
    "nx"
  ],
  "entropic_partial_gromov_wasserstein": [
    "C1",
    "C2",
    "p",
    "q",
    "reg",
    "m",
    "loss_fun",
    "G0",
    "numItermax",
    "tol",
    "symmetric",
    "log",
    "verbose"
  ],
  "entropic_partial_gromov_wasserstein2": [
    "C1",
    "C2",
    "p",
    "q",
    "reg",
    "m",
    "loss_fun",
    "G0",
    "numItermax",
    "tol",
    "symmetric",
    "log",
    "verbose"
  ],
  "entropic_partial_fused_gromov_wasserstein": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "reg",
    "m",
    "loss_fun",
    "alpha",
    "G0",
    "numItermax",
    "tol",
    "symmetric",
    "log",
    "verbose"
  ],
  "entropic_partial_fused_gromov_wasserstein2": [
    "M",
    "C1",
    "C2",
    "p",
    "q",
    "reg",
    "m",
    "loss_fun",
    "alpha",
    "G0",
    "numItermax",
    "tol",
    "symmetric",
    "log",
    "verbose"
  ],
  "gromov_wasserstein_dictionary_learning": [
    "Cs",
    "D",
    "nt",
    "reg",
    "ps",
    "q",
    "epochs",
    "batch_size",
    "learning_rate",
    "Cdict_init",
    "projection",
    "use_log",
    "tol_outer",
    "tol_inner",
    "max_iter_outer",
    "max_iter_inner",
    "use_adam_optimizer",
    "verbose",
    "random_state"
  ],
  "_initialize_adam_optimizer": [
    "variable"
  ],
  "_adam_stochastic_updates": [
    "variable",
    "grad",
    "learning_rate",
    "adam_moments",
    "beta_1",
    "beta_2",
    "eps"
  ],
  "gromov_wasserstein_linear_unmixing": [
    "C",
    "Cdict",
    "reg",
    "p",
    "q",
    "tol_outer",
    "tol_inner",
    "max_iter_outer",
    "max_iter_inner",
    "symmetric"
  ],
  "_cg_gromov_wasserstein_unmixing": [
    "C",
    "Cdict",
    "Cembedded",
    "w",
    "const_q",
    "T",
    "starting_loss",
    "reg",
    "tol",
    "max_iter"
  ],
  "_linesearch_gromov_wasserstein_unmixing": [
    "w",
    "grad_w",
    "x",
    "Cdict",
    "Cembedded",
    "const_q",
    "const_TCT",
    "reg"
  ],
  "fused_gromov_wasserstein_dictionary_learning": [
    "Cs",
    "Ys",
    "D",
    "nt",
    "alpha",
    "reg",
    "ps",
    "q",
    "epochs",
    "batch_size",
    "learning_rate_C",
    "learning_rate_Y",
    "Cdict_init",
    "Ydict_init",
    "projection",
    "use_log",
    "tol_outer",
    "tol_inner",
    "max_iter_outer",
    "max_iter_inner",
    "use_adam_optimizer",
    "verbose",
    "random_state"
  ],
  "fused_gromov_wasserstein_linear_unmixing": [
    "C",
    "Y",
    "Cdict",
    "Ydict",
    "alpha",
    "reg",
    "p",
    "q",
    "tol_outer",
    "tol_inner",
    "max_iter_outer",
    "max_iter_inner",
    "symmetric"
  ],
  "_cg_fused_gromov_wasserstein_unmixing": [
    "C",
    "Y",
    "Cdict",
    "Ydict",
    "Cembedded",
    "Yembedded",
    "w",
    "T",
    "p",
    "q",
    "const_q",
    "diag_q",
    "starting_loss",
    "alpha",
    "reg",
    "tol",
    "max_iter"
  ],
  "_linesearch_fused_gromov_wasserstein_unmixing": [
    "w",
    "grad_w",
    "x",
    "Y",
    "Cdict",
    "Ydict",
    "Cembedded",
    "Yembedded",
    "T",
    "const_q",
    "const_TCT",
    "ones_ns_d",
    "alpha",
    "reg"
  ],
  "_flat_product_operator": [
    "X",
    "nx"
  ],
  "lowrank_gromov_wasserstein_samples": [
    "X_s",
    "X_t",
    "a",
    "b",
    "reg",
    "rank",
    "alpha",
    "gamma_init",
    "rescale_cost",
    "cost_factorized_Xs",
    "cost_factorized_Xt",
    "stopThr",
    "numItermax",
    "stopThr_dykstra",
    "numItermax_dykstra",
    "seed_init",
    "warn",
    "warn_dykstra",
    "log"
  ],
  "fused_unbalanced_across_spaces_divergence": [
    "X",
    "Y",
    "wx_samp",
    "wx_feat",
    "wy_samp",
    "wy_feat",
    "reg_marginals",
    "epsilon",
    "reg_type",
    "divergence",
    "unbalanced_solver",
    "alpha",
    "M_samp",
    "M_feat",
    "rescale_plan",
    "init_pi",
    "init_duals",
    "max_iter",
    "tol",
    "max_iter_ot",
    "tol_ot",
    "log",
    "verbose"
  ],
  "unbalanced_co_optimal_transport": [
    "X",
    "Y",
    "wx_samp",
    "wx_feat",
    "wy_samp",
    "wy_feat",
    "reg_marginals",
    "epsilon",
    "divergence",
    "unbalanced_solver",
    "alpha",
    "M_samp",
    "M_feat",
    "rescale_plan",
    "init_pi",
    "init_duals",
    "max_iter",
    "tol",
    "max_iter_ot",
    "tol_ot",
    "log",
    "verbose"
  ],
  "unbalanced_co_optimal_transport2": [
    "X",
    "Y",
    "wx_samp",
    "wx_feat",
    "wy_samp",
    "wy_feat",
    "reg_marginals",
    "epsilon",
    "divergence",
    "unbalanced_solver",
    "alpha",
    "M_samp",
    "M_feat",
    "rescale_plan",
    "init_pi",
    "init_duals",
    "max_iter",
    "tol",
    "max_iter_ot",
    "tol_ot",
    "log",
    "verbose"
  ],
  "fused_unbalanced_gromov_wasserstein": [
    "Cx",
    "Cy",
    "wx",
    "wy",
    "reg_marginals",
    "epsilon",
    "divergence",
    "unbalanced_solver",
    "alpha",
    "M",
    "init_duals",
    "init_pi",
    "max_iter",
    "tol",
    "max_iter_ot",
    "tol_ot",
    "log",
    "verbose"
  ],
  "fused_unbalanced_gromov_wasserstein2": [
    "Cx",
    "Cy",
    "wx",
    "wy",
    "reg_marginals",
    "epsilon",
    "divergence",
    "unbalanced_solver",
    "alpha",
    "M",
    "init_duals",
    "init_pi",
    "max_iter",
    "tol",
    "max_iter_ot",
    "tol_ot",
    "log",
    "verbose"
  ],
  "partial_wasserstein_lagrange": [
    "a",
    "b",
    "M",
    "reg_m",
    "nb_dummies",
    "log"
  ],
  "partial_wasserstein": [
    "a",
    "b",
    "M",
    "m",
    "nb_dummies",
    "log"
  ],
  "partial_wasserstein2": [
    "a",
    "b",
    "M",
    "m",
    "nb_dummies",
    "log"
  ],
  "entropic_partial_wasserstein": [
    "a",
    "b",
    "M",
    "reg",
    "m",
    "numItermax",
    "stopThr",
    "verbose",
    "log"
  ],
  "gwgrad_partial": [
    "C1",
    "C2",
    "T"
  ],
  "gwloss_partial": [
    "C1",
    "C2",
    "T"
  ],
  "partial_wasserstein_1d": [
    "x_a",
    "x_b",
    "n_transported_samples",
    "p"
  ],
  "get_openmp_flag": [
    "compiler"
  ],
  "check_openmp_support": [],
  "_get_compiler": [],
  "compile_test_program": [
    "code",
    "extra_preargs",
    "extra_postargs"
  ],
  "TFGW_template_initialization": [
    "n_tplt",
    "n_tplt_nodes",
    "n_features",
    "feature_init_mean",
    "feature_init_std"
  ],
  "FGW_distance_to_templates": [
    "G_edges",
    "tplt_adjacencies",
    "G_features",
    "tplt_features",
    "tplt_weights",
    "alpha",
    "multi_alpha",
    "batch"
  ],
  "wasserstein_distance_to_templates": [
    "G_features",
    "tplt_features",
    "tplt_weights",
    "batch"
  ],
  "TFGWPooling": {
    "__init__": [
      "self",
      "n_features",
      "n_tplt",
      "n_tplt_nodes",
      "alpha",
      "train_node_weights",
      "multi_alpha",
      "feature_init_mean",
      "feature_init_std"
    ],
    "forward": [
      "self",
      "x",
      "edge_index",
      "batch"
    ]
  },
  "TWPooling": {
    "__init__": [
      "self",
      "n_features",
      "n_tplt",
      "n_tplt_nodes",
      "train_node_weights",
      "feature_init_mean",
      "feature_init_std"
    ],
    "forward": [
      "self",
      "x",
      "edge_index",
      "batch"
    ]
  }
}