{
  "__version__": [],
  "_FEATURE_SPEC": [],
  "_TYPE_SPEC": [],
  "_identity_preprocessing_fn": [
    "inputs"
  ],
  "_side_affect_preprocessing_fn": [
    "inputs"
  ],
  "_non_identity_ops_preprocessing_fn": [
    "inputs"
  ],
  "_renaming_preprocessing_fn": [
    "inputs"
  ],
  "_plus_one": [
    "x"
  ],
  "_one_phase_preprocessing_fn": [
    "inputs"
  ],
  "_two_phases_preprocessing_fn": [
    "inputs"
  ],
  "_preprocessing_fn_with_control_dependency": [
    "inputs"
  ],
  "InspectPreprocessingFnTest": {
    "test_column_inference": [
      "self",
      "preprocessing_fn",
      "expected_analyze_input_columns",
      "expected_transform_input_columns",
      "force_tf_compat_v1"
    ]
  },
  "_INITIALIZABLE_TABLE_OP_TYPES": [],
  "_TABLE_INIT_OP_TYPES": [],
  "_decompose_tensor_or_op": [
    "tensor_or_op"
  ],
  "retrieve_sources": [
    "sinks",
    "ignore_control_dependencies"
  ],
  "get_func_graph_for_name": [
    "graph",
    "func_name"
  ],
  "_UnexpectedPlaceholderError": {
    "__init__": [
      "self",
      "op",
      "func_graph_name"
    ]
  },
  "_UnexpectedTableError": {
    "__init__": [
      "self",
      "op",
      "func_graph_name"
    ]
  },
  "_reraise_unexpected_error": [
    "func"
  ],
  "_AnalysisResult": [],
  "_SourceInfo": [],
  "_GraphAnalyzer": {
    "__init__": [
      "self",
      "source_info_dict",
      "translate_path_fn",
      "graph"
    ],
    "_get_parents": [
      "self",
      "tensor_or_op"
    ],
    "_compute_analysis_results_for_func_attributes": [
      "self",
      "tensor_or_op",
      "parent_analysis_results"
    ],
    "_compute_analysis_result": [
      "self",
      "tensor_or_op",
      "parent_analysis_results"
    ],
    "analyze_tensor": [
      "self",
      "tensor_or_op"
    ],
    "ready_to_run": [
      "self",
      "tensor_or_op"
    ],
    "get_unique_path": [
      "self",
      "tensor"
    ]
  },
  "_set_unique_value_in_dict": [
    "input_dict",
    "key",
    "value"
  ],
  "InitializableGraphAnalyzer": {
    "__init__": [
      "self",
      "graph",
      "input_signature",
      "replaced_tensors_ready",
      "translate_path_fn"
    ],
    "_log_warning": [
      "self",
      "message"
    ],
    "_get_table_init_op_and_inputs": [
      "self",
      "table_init_op_or_tensor"
    ],
    "_make_source_infos_dict": [
      "self",
      "input_signature",
      "replaced_tensors_ready"
    ],
    "_get_table_init_op_source_info": [
      "self",
      "table_init_op",
      "graph_analyzer",
      "translate_path_fn"
    ],
    "ready_table_initializers": [
      "self"
    ],
    "ready_to_run": [
      "self",
      "tensor_or_op"
    ],
    "get_unique_path": [
      "self",
      "tensor"
    ],
    "get_dependent_inputs": [
      "self",
      "tensor_or_op"
    ]
  },
  "_QuietInitializableGraphAnalyzer": {
    "_log_warning": [
      "self",
      "message"
    ]
  },
  "get_dependent_inputs": [
    "graph",
    "input_tensors",
    "output_tensors"
  ],
  "_serialize_op_attr": [
    "op_attr"
  ],
  "describe_path_as_analyzer_cache_hash": [
    "x",
    "parents"
  ],
  "SourcedTensorsVisitor": {
    "__init__": [
      "self"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_retrieve_source_keys": [
    "sourced_tensors",
    "structured_inputs"
  ],
  "AnalyzersFingerprint": [],
  "get_analyzers_fingerprint": [
    "graph",
    "structured_inputs"
  ],
  "_sparse_index_name": [
    "index",
    "tensor_name"
  ],
  "_sparse_value_name": [
    "tensor_name"
  ],
  "_FEED_DICT": [],
  "_MULTIPLE_FEATURES_CASE_RECORD_BATCH": [],
  "_ROUNDTRIP_CASES": [],
  "_MAKE_FEED_DICT_CASES": [],
  "_TO_INSTANCE_DICT_ERROR_CASES": [],
  "_CONVERT_TO_ARROW_ERROR_CASES": [],
  "_ragged_tensor_from_value": [
    "value"
  ],
  "_eager_tensor_from_values": [
    "values"
  ],
  "ImplHelperTest": {
    "test_batched_placeholders_from_feature_spec": [
      "self"
    ],
    "test_batched_placeholders_from_typespecs": [
      "self"
    ],
    "test_batched_placeholders_from_specs_invalid_dtype": [
      "self"
    ],
    "test_batched_placeholders_from_specs_invalid_mixing": [
      "self"
    ],
    "test_to_instance_dicts": [
      "self",
      "feature_spec",
      "instances",
      "record_batch",
      "feed_dict",
      "feed_eager_tensors"
    ],
    "test_to_instance_dicts_error": [
      "self",
      "feature_spec",
      "feed_dict",
      "error_msg",
      "error_type"
    ],
    "test_convert_to_arrow": [
      "self",
      "feature_spec",
      "instances",
      "record_batch",
      "feed_dict",
      "feed_eager_tensors"
    ],
    "test_convert_to_arrow_error": [
      "self",
      "feature_spec",
      "feed_dict",
      "error_msg",
      "error_type"
    ],
    "test_analyze_in_place": [
      "self",
      "force_tf_compat_v1"
    ],
    "test_analyze_in_place_with_analyzers_raises_error": [
      "self",
      "force_tf_compat_v1"
    ],
    "test_validate_varlen_sparse_value": [
      "self",
      "value",
      "error"
    ]
  },
  "_subtract_ten_with_tf_while": [
    "x"
  ],
  "ANALYZER_COLLECTION": [],
  "MAPPER_COLLECTION": [],
  "ANNOTATION_PREFIX_URL": [],
  "_in_logging_context": [],
  "logging_context": [],
  "log_api_use": [
    "collection_name"
  ],
  "_get_tensor_value": [
    "tensor_or_eager_tensor"
  ],
  "_TransformedFeaturesDict": {
    "pop": [
      "self",
      "key",
      "default"
    ]
  },
  "TFTransformOutput": {
    "TRANSFORMED_METADATA_DIR": [],
    "TRANSFORM_FN_DIR": [],
    "ASSET_MAP": [],
    "__init__": [
      "self",
      "transform_output_dir"
    ],
    "transformed_metadata": [
      "self"
    ],
    "transform_savedmodel_dir": [
      "self"
    ],
    "_exported_as_v1": [
      "self"
    ],
    "_transformed_metadata_dir": [
      "self"
    ],
    "transformed_feature_spec": [
      "self"
    ],
    "transformed_domains": [
      "self"
    ],
    "vocabulary_file_by_name": [
      "self",
      "vocab_filename"
    ],
    "_vocabulary_size_from_annotations": [
      "self",
      "vocab_filename"
    ],
    "vocabulary_size_by_name": [
      "self",
      "vocab_filename"
    ],
    "vocabulary_by_name": [
      "self",
      "vocab_filename"
    ],
    "num_buckets_for_transformed_feature": [
      "self",
      "name"
    ],
    "transform_features_layer": [
      "self"
    ],
    "transform_raw_features": [
      "self",
      "raw_features",
      "drop_unused_features"
    ],
    "_transform_raw_features_compat_v1": [
      "self",
      "raw_features",
      "drop_unused_features"
    ],
    "load_transform_graph": [
      "self"
    ],
    "RAW_METADATA_DIR": [],
    "_FEATURE_STATS_PB": [],
    "PRE_TRANSFORM_FEATURE_STATS_PATH": [],
    "POST_TRANSFORM_FEATURE_STATS_PATH": [],
    "raw_metadata": [
      "self"
    ],
    "raw_feature_spec": [
      "self"
    ],
    "raw_domains": [
      "self"
    ],
    "pre_transform_statistics_path": [
      "self"
    ],
    "post_transform_statistics_path": [
      "self"
    ]
  },
  "TransformFeaturesLayer": {
    "__init__": [
      "self",
      "tft_output",
      "exported_as_v1"
    ],
    "_saved_model_loader": [
      "self"
    ],
    "_init_batch_counters": [
      "self"
    ],
    "call": [
      "self",
      "inputs"
    ]
  },
  "_make_method_override": [
    "name"
  ],
  "_override_parent_methods": [
    "keep_items"
  ],
  "use_tf_compat_v1": [
    "force_tf_compat_v1"
  ],
  "strip_and_get_tensors_and_control_dependencies": [
    "flat_tensor_list"
  ],
  "supply_missing_tensor": [
    "batch_size",
    "tensor_shape",
    "tensor_dtype"
  ],
  "supply_missing_inputs": [
    "structured_inputs",
    "batch_size",
    "missing_keys"
  ],
  "get_structured_inputs_from_func_graph": [
    "func_graph"
  ],
  "main": [],
  "named_parameters": [],
  "SkipTest": [],
  "cross_named_parameters": [],
  "parameters": [],
  "cross_parameters": [],
  "_make_placeholder": [
    "tensor_spec"
  ],
  "_graph_function_handler": [
    "input_signature"
  ],
  "_ragged_value_as_constant": [
    "value",
    "dtype"
  ],
  "_wrap_as_constant": [
    "value",
    "tensor_spec"
  ],
  "_eager_function_handler": [
    "input_signature"
  ],
  "_tf_function_function_handler": [
    "input_signature"
  ],
  "FUNCTION_HANDLERS": [],
  "is_external_environment": [],
  "skip_if_external_environment": [
    "reason"
  ],
  "skip_if_not_tf2": [
    "reason"
  ],
  "cross_with_function_handlers": [
    "parameters_list"
  ],
  "TransformTestCase": {
    "longMessage": [],
    "assertDataCloseOrEqual": [
      "self",
      "a_data",
      "b_data"
    ],
    "_assertValuesCloseOrEqual": [
      "self",
      "a_value",
      "b_value",
      "msg"
    ],
    "AssertVocabularyContents": [
      "self",
      "vocab_file_path",
      "file_contents"
    ],
    "WriteRenderedDotFile": [
      "self",
      "dot_string",
      "output_file"
    ],
    "_NumpyArraysToLists": [
      "self",
      "maybe_arrays"
    ],
    "_SortedDicts": [
      "self",
      "list_of_dicts"
    ],
    "_SortedData": [
      "self",
      "list_of_dicts_of_arrays"
    ]
  },
  "CommonTest": {
    "testLogAPIUse": [
      "self"
    ],
    "testLogAPIUseWithNestedFunction": [
      "self"
    ]
  },
  "PretrainedModelsTest": {
    "save_model_with_single_input": [
      "self",
      "export_dir"
    ],
    "save_model_with_multi_inputs": [
      "self",
      "export_dir"
    ],
    "make_tensor_fn_two_inputs": [
      "self"
    ],
    "save_checkpoint_with_two_inputs": [
      "self",
      "checkpoint_path"
    ],
    "testApplySavedModelSingleInput": [
      "self"
    ],
    "testApplySavedModelMultiInputs": [
      "self"
    ],
    "testApplyFunctionWithCheckpointTwoInputs": [
      "self"
    ]
  },
  "mock": [],
  "MappersTest": {
    "assertSparseOutput": [
      "self",
      "expected_indices",
      "expected_values",
      "expected_shape",
      "actual_sparse_tensor",
      "close_values"
    ],
    "testSegmentIndices": [
      "self"
    ],
    "testSegmentIndicesSkipOne": [
      "self"
    ],
    "testNGramsEmpty": [
      "self"
    ],
    "testNGrams": [
      "self"
    ],
    "testNGramsMinSizeNotOne": [
      "self"
    ],
    "testNGramsWithSpaceSeparator": [
      "self"
    ],
    "testNGramsWithRepeatedTokensPerRow": [
      "self"
    ],
    "testNGramsBadSizes": [
      "self"
    ],
    "testNGramsBagOfWordsEmpty": [
      "self"
    ],
    "testBagOfWords": [
      "self",
      "strings",
      "expected_output_indices",
      "expected_output_values",
      "ngram_range",
      "separator"
    ],
    "testDedupeSparseTensorPerRow": [
      "self",
      "indices",
      "values",
      "dense_shape",
      "expected_output_indices",
      "expected_output_values",
      "expected_output_shape"
    ],
    "testDedupeDenseTensorPerRow": [
      "self",
      "values",
      "expected_indices",
      "expected_output"
    ],
    "testDedup3dInputRaises": [
      "self"
    ],
    "testWordCountEmpty": [
      "self"
    ],
    "testWordCount": [
      "self"
    ],
    "testWordCountRagged": [
      "self"
    ],
    "testTermFrequency": [
      "self"
    ],
    "testTermFrequencyUnusedTerm": [
      "self"
    ],
    "testCountDocsWithTerm": [
      "self"
    ],
    "testCountDocsWithTermUnusedTerm": [
      "self"
    ],
    "testToTFIDF": [
      "self"
    ],
    "testToTFIDFNotSmooth": [
      "self"
    ],
    "testSplitTFIDF": [
      "self"
    ],
    "testSplitTFIDFWithEmptyInput": [
      "self"
    ],
    "testHashStringsNoKeyDenseInput": [
      "self"
    ],
    "testHashStringsNoKeySparseInput": [
      "self"
    ],
    "testHashStringsNoKeyRaggedInput": [
      "self"
    ],
    "testHashStringsWithKeyDenseInput": [
      "self"
    ],
    "testHashStringsWithKeySparseInput": [
      "self"
    ],
    "testHashStringsWithKeyRaggedInput": [
      "self"
    ],
    "testApplyBuckets": [
      "self",
      "x",
      "bucket_boundaries",
      "expected_buckets"
    ],
    "testApplybucketsToSparseTensor": [
      "self"
    ],
    "testApplybucketsToRaggedTensor": [
      "self"
    ],
    "testApplyBucketsWithKeys": [
      "self"
    ],
    "testApplyBucketsWithInterpolation": [
      "self",
      "x",
      "boundaries",
      "expected_results",
      "input_dtype",
      "boundaries_dtype"
    ],
    "testApplyBucketsWithInterpolationAllNanBoundariesRaises": [
      "self"
    ],
    "testApplyBucketsWithInterpolationRaises": [
      "self"
    ],
    "testApplyBucketsWithInterpolationSparseTensor": [
      "self"
    ],
    "testApplyBucketsWithInterpolationRaggedTensor": [
      "self"
    ],
    "testBucketsWithInterpolationUnknownShapeBoundary": [
      "self"
    ],
    "testSparseTensorToDenseWithShape": [
      "self"
    ],
    "testSparseTensorLeftAlign": [
      "self"
    ],
    "testEstimatedProbabilityDensityMissingKey": [
      "self"
    ]
  },
  "TftUnitTest": {
    "testCrossNamedParameters": [
      "self"
    ],
    "testCrossParameters": [
      "self"
    ],
    "testAssertDataCloseOrEqual": [
      "self"
    ],
    "testSampleParametrizedTestMethod": [
      "self",
      "my_arg",
      "my_other_arg"
    ]
  },
  "EPSILON": [],
  "_make_hypergeometric_pmf_sum_up_to_one_parameters": [],
  "InfoTheoryTest": {
    "testHypergeometricPmf": [
      "self"
    ],
    "testHypergeometricPmf_LargeN": [
      "self"
    ],
    "test_hypergeometric_pmf_sum_up_to_one": [
      "self",
      "test_range",
      "n",
      "y_j"
    ],
    "test_calculate_partial_expected_mutual_information": [
      "self",
      "n",
      "x_i",
      "y_j",
      "expected"
    ],
    "test_mutual_information": [
      "self",
      "cell_count",
      "row_count",
      "col_count",
      "total_count",
      "expected_mi"
    ]
  },
  "tukey_hh_l_mean_and_scale": [
    "h_params"
  ],
  "_tukey_hh_l_skewness_and_kurtosis": [
    "h_params"
  ],
  "_binary_search": [
    "error_fn",
    "low_value",
    "high_value"
  ],
  "_params_to_errors": [
    "h",
    "delta_h",
    "l_skewness_and_kurtosis"
  ],
  "compute_tukey_hh_params": [
    "l_skewness_and_kurtosis"
  ],
  "lambert_w": [
    "x"
  ],
  "inverse_tukey_hh": [
    "x",
    "hl",
    "hr"
  ],
  "log2": [],
  "calculate_partial_expected_mutual_information": [
    "n",
    "x_i",
    "y_j"
  ],
  "calculate_partial_mutual_information": [
    "n_ij",
    "x_i",
    "y_j",
    "n"
  ],
  "_hypergeometric_pmf": [
    "n",
    "x_i",
    "y_j"
  ],
  "_logfactorial": [
    "n"
  ],
  "_get_variables": [
    "scope",
    "suffix",
    "collection"
  ],
  "_get_variables_to_restore": [
    "include",
    "exclude"
  ],
  "apply_saved_model": [
    "model_dir",
    "inputs",
    "tags",
    "signature_name",
    "output_keys_in_signature"
  ],
  "apply_function_with_checkpoint": [
    "fn",
    "inputs",
    "checkpoint",
    "include",
    "exclude"
  ],
  "_TEST_BATCH_SIZES": [],
  "_TEST_DTYPES": [],
  "_TEST_TENSORS_TYPES": [],
  "TF2UtilsTest": {
    "test_strip_and_get_tensors_and_control_dependencies": [
      "self"
    ],
    "test_supply_missing_tensor_inputs": [
      "self",
      "batch_size",
      "dtype",
      "type_spec_getter",
      "tensor_type",
      "inner_shape"
    ]
  },
  "TENSOR_REPLACEMENTS": [],
  "ALL_REPLACEMENTS": [],
  "sanitize_label": [
    "label"
  ],
  "_make_label": [
    "cls",
    "label"
  ],
  "TemporaryAssetInfo": [],
  "TensorInfo": {
    "__new__": [
      "cls",
      "dtype",
      "shape",
      "temporary_asset_info"
    ]
  },
  "TensorSource": {
    "__new__": [
      "cls",
      "tensors"
    ]
  },
  "get_input_tensors_value_nodes": [
    "tensor_inputs"
  ],
  "TensorSink": [],
  "_bind_future_as_tensor_v1": [
    "future",
    "tensor_info",
    "name"
  ],
  "_TemporaryAnalyzerOutputWrapper": [],
  "_write_to_temporary_asset_file": [
    "temp_dir",
    "temporary_asset_info"
  ],
  "_get_temporary_analyzer_output": [
    "temp_dir",
    "tensor_info",
    "name"
  ],
  "_bind_future_as_tensor_v2": [
    "future",
    "tensor_info",
    "name"
  ],
  "bind_future_as_tensor": [
    "future",
    "tensor_info",
    "name"
  ],
  "wrap_as_tensor": [
    "output_value_node"
  ],
  "Combiner": {
    "__repr__": [
      "self"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "compact": [
      "self",
      "accumulator"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "accumulator_coder": [
      "self"
    ]
  },
  "CacheCoder": {
    "__repr__": [
      "self"
    ],
    "encode_cache": [
      "self",
      "cache"
    ],
    "decode_cache": [
      "self",
      "encoded_cache"
    ]
  },
  "JsonNumpyCacheCoder": {
    "__init__": [
      "self",
      "np_dtype"
    ],
    "_convert_numpy_dtype": [
      "self",
      "x"
    ],
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "AnalyzerDef": {
    "output_tensor_infos": [
      "self"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "PackedCombineAccumulate": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiners",
      "label"
    ],
    "num_outputs": [
      "self"
    ],
    "is_partitionable": [
      "self"
    ]
  },
  "PackedCombineMerge": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiners",
      "label"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "CacheableCombineAccumulate": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiner"
    ],
    "num_outputs": [
      "self"
    ],
    "is_partitionable": [
      "self"
    ],
    "cache_coder": [
      "self"
    ]
  },
  "CacheableCombineMerge": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiner"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "_CombinerPerKeyAccumulatorCoder": {
    "__init__": [
      "self",
      "value_coder"
    ],
    "__repr__": [
      "self"
    ],
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "CacheableCombinePerKeyAccumulate": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiner"
    ],
    "num_outputs": [
      "self"
    ],
    "is_partitionable": [
      "self"
    ],
    "cache_coder": [
      "self"
    ]
  },
  "CacheableCombinePerKeyMerge": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiner"
    ]
  },
  "CacheableCombinePerKeyFormatKeys": {
    "__slots__": [],
    "__new__": [
      "cls",
      "combiner"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "CacheableCombinePerKeyFormatLarge": {
    "__slots__": [],
    "__new__": [
      "cls"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "ScaleAndFlattenPerKeyBucketBouandaries": {
    "__slots__": [],
    "__new__": [
      "cls",
      "output_tensor_dtype"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "VocabularyAccumulate": {
    "__slots__": [],
    "__new__": [
      "cls",
      "vocab_ordering_type",
      "input_dtype"
    ],
    "num_outputs": [
      "self"
    ],
    "is_partitionable": [
      "self"
    ],
    "cache_coder": [
      "self"
    ]
  },
  "_BaseKVCoder": {
    "__init__": [
      "self"
    ],
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "_VocabularyAccumulatorCoder": {
    "__init__": [
      "self",
      "input_dtype"
    ],
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "VocabularyCount": {
    "__slots__": [],
    "__new__": [
      "cls",
      "label"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "VocabularyMerge": {
    "__slots__": [],
    "__new__": [
      "cls",
      "vocab_ordering_type",
      "use_adjusted_mutual_info",
      "min_diff_from_avg"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "VocabularyPrune": {
    "__slots__": [],
    "__new__": [
      "cls",
      "top_k",
      "frequency_threshold",
      "input_dtype",
      "informativeness_threshold",
      "coverage_top_k",
      "coverage_frequency_threshold",
      "coverage_informativeness_threshold",
      "key_fn"
    ],
    "num_outputs": [
      "self"
    ]
  },
  "VocabularyOrderAndWrite": {
    "__slots__": [],
    "__new__": [
      "cls",
      "vocab_filename",
      "store_frequency",
      "fingerprint_shuffle",
      "file_format",
      "input_dtype",
      "input_is_sorted"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "ExtractVocabularyReservedTokens": {
    "__slots__": [],
    "__new__": [
      "cls",
      "name"
    ]
  },
  "PTransform": {
    "__slots__": [],
    "__new__": [
      "cls",
      "ptransform",
      "output_tensor_info_list",
      "is_partitionable",
      "cache_coder"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "EncodeCache": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "InstrumentDatasetCache": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "DecodeCache": {
    "__slots__": [],
    "get_field_str": [
      "self",
      "field_name"
    ],
    "is_partitionable": [
      "self"
    ]
  },
  "AddKey": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "FlattenLists": {
    "__new__": [
      "cls"
    ],
    "is_partitionable": [
      "self"
    ]
  },
  "ExtractCombineMergeOutputs": {
    "__slots__": [],
    "__new__": [
      "cls",
      "output_tensor_info_list"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "ExtractPackedCombineMergeOutputs": {
    "__slots__": [],
    "output_tensor_infos": [
      "self"
    ]
  },
  "OperationDef": {
    "num_outputs": [
      "self"
    ],
    "label": [
      "self"
    ],
    "get_field_str": [
      "self",
      "field_name"
    ],
    "is_partitionable": [
      "self"
    ],
    "cache_coder": [
      "self"
    ]
  },
  "ValueNode": {
    "__post_init__": [
      "self"
    ]
  },
  "OperationNode": {
    "__init__": [
      "self",
      "operation_def",
      "inputs"
    ],
    "__repr__": [
      "self"
    ],
    "operation_def": [
      "self"
    ],
    "inputs": [
      "self"
    ],
    "outputs": [
      "self"
    ]
  },
  "apply_operation": [
    "operation_def_cls"
  ],
  "apply_multi_output_operation": [
    "operation_def_cls"
  ],
  "Visitor": {
    "validate_value": [
      "self",
      "value"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ]
  },
  "Traverser": {
    "__init__": [
      "self",
      "visitor"
    ],
    "visit_value_node": [
      "self",
      "value_node"
    ],
    "_maybe_visit_value_node": [
      "self",
      "value_node"
    ],
    "_visit_operation": [
      "self",
      "operation"
    ]
  },
  "_escape": [
    "line"
  ],
  "_PrintGraphVisitor": {
    "__init__": [
      "self"
    ],
    "get_dot_graph": [
      "self"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_nodes"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "get_dot_graph": [
    "leaf_nodes"
  ],
  "_CountGraphNodes": {
    "num_nodes": [],
    "visit": [
      "self",
      "operation_def",
      "_"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "count_graph_nodes": [
    "leaf_nodes"
  ],
  "_make_tensors": [
    "inputs"
  ],
  "_make_tensors_with_override": [
    "inputs"
  ],
  "_make_tensors_with_depth": [
    "inputs",
    "depth"
  ],
  "SchemaInferenceTest": {
    "_get_schema": [
      "self",
      "preprocessing_fn",
      "use_compat_v1",
      "inputs",
      "input_signature",
      "create_session"
    ],
    "test_infer_feature_schema": [
      "self",
      "make_tensors_fn",
      "feature_spec",
      "use_compat_v1",
      "domains",
      "create_session"
    ],
    "test_infer_feature_schema_bad_rank": [
      "self",
      "use_compat_v1"
    ],
    "test_vocab_annotation": [
      "self",
      "use_compat_v1"
    ],
    "test_bucketization_annotation": [
      "self",
      "use_compat_v1"
    ],
    "test_global_annotation": [
      "self",
      "use_compat_v1"
    ],
    "test_infer_feature_schema_with_ragged_tensor": [
      "self",
      "use_compat_v1"
    ]
  },
  "__all__": [],
  "_ASSET_KEY_COLLECTION": [],
  "_ASSET_FILENAME_COLLECTION": [],
  "_OBJECT_TRACKER": [],
  "VOCABULARY_SIZE_BY_NAME_COLLECTION": [],
  "ObjectTracker": {
    "__slots__": [],
    "__init__": [
      "self"
    ],
    "trackable_objects": [
      "self"
    ],
    "add_trackable_object": [
      "self",
      "trackable_object",
      "name"
    ]
  },
  "object_tracker_scope": [
    "object_tracker"
  ],
  "_get_object": [
    "name"
  ],
  "track_object": [
    "trackable",
    "name"
  ],
  "make_and_track_object": [
    "trackable_factory_callable",
    "name"
  ],
  "get_asset_annotations": [
    "graph"
  ],
  "clear_asset_annotations": [
    "graph"
  ],
  "annotate_asset": [
    "asset_key",
    "asset_filename"
  ],
  "annotate_vocab_size": [
    "vocab_filename",
    "vocab_size"
  ],
  "scale_to_gaussian": [
    "x",
    "elementwise",
    "name",
    "output_dtype"
  ],
  "_scale_to_gaussian_internal": [
    "x",
    "elementwise",
    "output_dtype"
  ],
  "sparse_tensor_to_dense_with_shape": [
    "x",
    "shape",
    "default_value"
  ],
  "sparse_tensor_left_align": [
    "sparse_tensor"
  ],
  "scale_by_min_max": [
    "x",
    "output_min",
    "output_max",
    "elementwise",
    "name"
  ],
  "scale_by_min_max_per_key": [
    "x",
    "key",
    "output_min",
    "output_max",
    "elementwise",
    "key_vocabulary_filename",
    "name"
  ],
  "_scale_by_min_max_internal": [
    "x",
    "key",
    "output_min",
    "output_max",
    "elementwise",
    "key_vocabulary_filename"
  ],
  "scale_to_0_1": [
    "x",
    "elementwise",
    "name"
  ],
  "scale_to_0_1_per_key": [
    "x",
    "key",
    "elementwise",
    "key_vocabulary_filename",
    "name"
  ],
  "scale_to_z_score": [
    "x",
    "elementwise",
    "name",
    "output_dtype"
  ],
  "scale_to_z_score_per_key": [
    "x",
    "key",
    "elementwise",
    "key_vocabulary_filename",
    "name",
    "output_dtype"
  ],
  "_scale_to_z_score_internal": [
    "x",
    "key",
    "elementwise",
    "key_vocabulary_filename",
    "output_dtype"
  ],
  "tfidf": [
    "x",
    "vocab_size",
    "smooth",
    "name"
  ],
  "_split_tfidfs_to_outputs": [
    "tfidfs"
  ],
  "_to_term_frequency": [
    "x",
    "vocab_size"
  ],
  "_to_tfidf": [
    "term_frequency",
    "reduced_term_freq",
    "corpus_size",
    "smooth"
  ],
  "_count_docs_with_term": [
    "term_frequency"
  ],
  "compute_and_apply_vocabulary": [
    "x"
  ],
  "apply_vocabulary": [
    "x",
    "deferred_vocab_filename_tensor"
  ],
  "_make_construct_vocabulary_table_function": [
    "x",
    "file_format",
    "num_oov_buckets",
    "default_value",
    "store_frequency"
  ],
  "_apply_vocabulary_internal": [
    "x",
    "deferred_vocab_filename_tensor",
    "default_value",
    "num_oov_buckets",
    "lookup_fn",
    "file_format",
    "store_frequency",
    "name"
  ],
  "get_num_buckets_for_transformed_feature": [
    "transformed_feature"
  ],
  "segment_indices": [
    "segment_ids",
    "name"
  ],
  "deduplicate_tensor_per_row": [
    "input_tensor",
    "name"
  ],
  "_DedupRowLoopArgs": [],
  "_DedupRowLoopVars": {},
  "_deduplicate_tensor_per_row": [
    "input_tensor",
    "batch_dim"
  ],
  "bag_of_words": [
    "tokens",
    "ngram_range",
    "separator",
    "name"
  ],
  "ngrams": [
    "tokens",
    "ngram_range",
    "separator",
    "name"
  ],
  "word_count": [
    "tokens",
    "name"
  ],
  "hash_strings": [
    "strings",
    "hash_buckets",
    "key",
    "name"
  ],
  "bucketize": [
    "x",
    "num_buckets",
    "epsilon",
    "weights",
    "elementwise",
    "name"
  ],
  "bucketize_per_key": [
    "x",
    "key",
    "num_buckets",
    "epsilon",
    "weights",
    "name"
  ],
  "_make_composite_tensor_wrapper_if_composite": [
    "x"
  ],
  "_fill_shape": [
    "value",
    "shape",
    "dtype"
  ],
  "_apply_buckets_with_keys": [
    "x",
    "key",
    "key_vocab",
    "bucket_boundaries",
    "scale_factor_per_key",
    "shift_per_key",
    "num_buckets",
    "name"
  ],
  "apply_buckets_with_interpolation": [
    "x",
    "bucket_boundaries",
    "name"
  ],
  "apply_buckets": [
    "x",
    "bucket_boundaries",
    "name"
  ],
  "_annotate_buckets": [
    "x",
    "bucket_boundaries"
  ],
  "estimated_probability_density": [
    "x",
    "boundaries",
    "categorical",
    "name"
  ],
  "_CONSTRUCT_TABLE_PARAMETERS": [],
  "_construct_table": [
    "asset_file_path",
    "key_dtype",
    "key_index",
    "value_dtype",
    "value_index",
    "default_value"
  ],
  "_value_to_tensor": [
    "value"
  ],
  "_SparseTensorSpec": {
    "__init__": [
      "self",
      "shape",
      "dtype"
    ]
  },
  "TFUtilsTest": {
    "_assertCompositeRefEqual": [
      "self",
      "left",
      "right"
    ],
    "test_copy_tensors_produces_different_tensors": [
      "self"
    ],
    "test_copy_tensors_produces_equivalent_tensors": [
      "self"
    ],
    "test_get_ragged_batch_value_rowids": [
      "self",
      "tensor",
      "rowids",
      "tensor_spec",
      "function_handler"
    ],
    "test_reduce_batch_weighted_counts": [
      "self",
      "x",
      "x_spec",
      "weights",
      "filter_regex",
      "expected_unique_x",
      "expected_summed_weights_per_x",
      "function_handler"
    ],
    "test_reduce_batch_weighted_counts_weights_none": [
      "self",
      "x",
      "filter_regex",
      "expected_result",
      "function_handler"
    ],
    "test_reduce_batch_weighted_counts_weights_none_force": [
      "self",
      "x",
      "filter_regex",
      "expected_result",
      "function_handler"
    ],
    "test_hashable_tensor_or_op": [
      "self",
      "get_value_fn"
    ],
    "test_reduce_batch_coocurrences": [
      "self",
      "x",
      "weights",
      "y",
      "expected_result",
      "filter_regex",
      "function_handler"
    ],
    "test_reduce_batch_coocurrences_no_weights": [
      "self",
      "x",
      "y",
      "expected_result",
      "input_signature",
      "filter_regex",
      "function_handler"
    ],
    "test_same_shape_exceptions": [
      "self",
      "x_input",
      "y_input",
      "x_shape",
      "y_shape",
      "exception_cls",
      "error_string"
    ],
    "test_same_shape": [
      "self",
      "function_handler"
    ],
    "test_lookup_key": [
      "self",
      "query_list",
      "key_vocab_list",
      "query_shape",
      "expected_output"
    ],
    "test_apply_per_key_vocab": [
      "self",
      "with_default_value",
      "input_keys"
    ],
    "test_reduce_batch_count": [
      "self",
      "x",
      "input_signature",
      "expected_result",
      "reduce_instance_dims",
      "function_handler"
    ],
    "test_reduce_batch_count_mean_and_var": [
      "self",
      "x",
      "input_signature",
      "expected_count",
      "expected_mean",
      "expected_var",
      "reduce_instance_dims",
      "function_handler"
    ],
    "test_num_terms_and_factors": [
      "self",
      "num_samples",
      "dtype",
      "expected_counts",
      "expected_factors"
    ],
    "test_reduce_batch_count_l_moments": [
      "self",
      "x",
      "input_signature",
      "expected_counts",
      "expected_moments",
      "reduce_instance_dims",
      "function_handler"
    ],
    "test_reduce_batch_count_mean_and_var_per_key": [
      "self",
      "x",
      "key",
      "input_signature",
      "expected_key_vocab",
      "expected_count",
      "expected_mean",
      "expected_var",
      "reduce_instance_dims",
      "function_handler"
    ],
    "test_reduce_batch_minus_min_and_max": [
      "self",
      "x",
      "expected_x_minus_min",
      "expected_x_max",
      "reduce_instance_dims",
      "input_signature",
      "function_handler"
    ],
    "test_reduce_batch_minus_min_and_max_per_key": [
      "self",
      "x",
      "key",
      "reduce_instance_dims",
      "expected_key_vocab",
      "expected_x_minus_min",
      "expected_x_max",
      "input_signature",
      "function_handler"
    ],
    "test_reduce_batch_count_per_key": [
      "self",
      "key",
      "spec",
      "expected_key_vocab",
      "expected_count",
      "function_handler"
    ],
    "test_reorder_histogram": [
      "self",
      "bucket_vocab",
      "counts",
      "boundary_size",
      "expected_counts",
      "function_handler"
    ],
    "test_assign_buckets": [
      "self",
      "x",
      "x_spec",
      "boundaries",
      "boundaries_spec",
      "side",
      "expected_buckets",
      "function_handler"
    ],
    "test_sparse_indices": [
      "self"
    ],
    "test_convert_sparse_indices": [
      "self"
    ],
    "test_convert_ragged_indices": [
      "self"
    ],
    "test_map_per_key_reductions": [
      "self",
      "key",
      "key_vocab",
      "reductions",
      "x",
      "reduce_instance_dims",
      "expected_results"
    ],
    "test_serialize_feature": [
      "self",
      "feature",
      "input_signature",
      "ascii_protos",
      "function_handler"
    ],
    "test_serialize_example": [
      "self",
      "examples",
      "ascii_protos"
    ],
    "test_extend_reduced_batch_with_y_counts": [
      "self"
    ],
    "test_to_vocab_range": [
      "self",
      "x",
      "vocab_size",
      "input_signature",
      "expected_output_values",
      "function_handler"
    ],
    "test_document_frequency_to_idf": [
      "self",
      "df_input",
      "corpus_size",
      "smooth",
      "add_baseline",
      "expected_idf",
      "function_handler"
    ]
  },
  "VocabTFUtilsTest": {
    "_write_tfrecords": [
      "self",
      "path",
      "bytes_records"
    ],
    "test_split_vocabulary_entries": [
      "self"
    ],
    "test_read_tfrecord_vocabulary_dataset": [
      "self"
    ],
    "test_make_tfrecord_vocabulary_dataset": [
      "self",
      "contents",
      "expected",
      "key_dtype",
      "value_dtype",
      "return_indicator_as_value",
      "has_indicator"
    ],
    "test_make_tfrecord_vocabulary_lookup_initializer": [
      "self",
      "function_handler"
    ],
    "test_construct_and_lookup_table": [
      "self",
      "asset_path_input_fn",
      "function_handler"
    ]
  },
  "builtin_max": [],
  "builtin_min": [],
  "ALLOWED_VOCABULARY_FILE_FORMATS": [],
  "VOCAB_FILENAME_PREFIX": [],
  "VOCAB_FREQUENCY_FILENAME_PREFIX": [],
  "LARGE_VOCAB_TOP_K": [],
  "_EMPTY_STRING_OR_NEWLINE_CHARS_REGEX": [],
  "_SUM_OUTPUT_DTYPE_MAP": [],
  "_FLOAT_OUTPUT_DTYPE_MAP": [],
  "apply_cacheable_combine_operation": [
    "combiner"
  ],
  "_apply_cacheable_combiner": [
    "combiner"
  ],
  "_apply_cacheable_combiner_per_key": [
    "combiner"
  ],
  "_apply_cacheable_combiner_per_key_large": [
    "combiner",
    "key_vocabulary_filename"
  ],
  "NumPyCombiner": {
    "__init__": [
      "self",
      "fn",
      "default_accumulator_value",
      "output_dtypes",
      "output_shapes"
    ],
    "_equals_to_scalar_nan": [
      "self",
      "array"
    ],
    "_equals_to_default_sub_accumulator": [
      "self",
      "array"
    ],
    "_is_default_sub_accumulator": [
      "self",
      "array"
    ],
    "create_accumulator": [
      "self"
    ],
    "_create_sub_accumulator": [
      "self",
      "shape"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ]
  },
  "_get_output_shape_from_input": [
    "x"
  ],
  "_get_elementwise_per_key_output_shape": [
    "x",
    "key"
  ],
  "_numeric_combine": [
    "inputs",
    "fn",
    "default_accumulator_value",
    "reduce_instance_dims",
    "output_dtypes",
    "key",
    "key_vocabulary_filename"
  ],
  "min": [
    "x",
    "reduce_instance_dims",
    "name"
  ],
  "max": [
    "x",
    "reduce_instance_dims",
    "name"
  ],
  "_min_and_max": [
    "x",
    "reduce_instance_dims",
    "name"
  ],
  "_min_and_max_per_key": [
    "x",
    "key",
    "reduce_instance_dims",
    "key_vocabulary_filename",
    "name"
  ],
  "_sum_combine_fn_and_dtype": [
    "input_dtype"
  ],
  "sum": [
    "x",
    "reduce_instance_dims",
    "name"
  ],
  "remove_leftmost_boundary": [
    "boundaries"
  ],
  "histogram": [
    "x",
    "boundaries",
    "categorical",
    "name"
  ],
  "size": [
    "x",
    "reduce_instance_dims",
    "name"
  ],
  "count_per_key": [
    "key",
    "key_vocabulary_filename",
    "name"
  ],
  "mean": [
    "x",
    "reduce_instance_dims",
    "name",
    "output_dtype"
  ],
  "var": [
    "x",
    "reduce_instance_dims",
    "name",
    "output_dtype"
  ],
  "_mean_and_var": [
    "x",
    "reduce_instance_dims",
    "output_dtype"
  ],
  "tukey_location": [
    "x",
    "reduce_instance_dims",
    "output_dtype",
    "name"
  ],
  "tukey_scale": [
    "x",
    "reduce_instance_dims",
    "output_dtype",
    "name"
  ],
  "tukey_h_params": [
    "x",
    "reduce_instance_dims",
    "output_dtype",
    "name"
  ],
  "_tukey_parameters": [
    "x",
    "reduce_instance_dims",
    "output_dtype"
  ],
  "_mean_and_var_per_key": [
    "x",
    "key",
    "reduce_instance_dims",
    "output_dtype",
    "key_vocabulary_filename"
  ],
  "_WeightedMeanAndVarAccumulator": {
    "make_nan_to_num": [
      "cls",
      "counts",
      "means",
      "variances",
      "weights",
      "compute_variance",
      "compute_weighted"
    ]
  },
  "WeightedMeanAndVarCombiner": {
    "accumulator_class": [],
    "__init__": [
      "self",
      "output_numpy_dtype",
      "output_shape",
      "compute_variance",
      "compute_weighted"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "_combine_mean_and_var_accumulators": [
      "self",
      "a",
      "b"
    ]
  },
  "_pad_arrays_to_match": [
    "a",
    "b"
  ],
  "_LMomentsAccumulator": {
    "make_nan_to_num": [
      "cls",
      "count_l1",
      "count_l2",
      "count_l3",
      "count_l4",
      "l1",
      "l2",
      "l3",
      "l4"
    ],
    "__reduce__": [
      "self"
    ]
  },
  "_LMomentsCombiner": {
    "accumulator_class": [],
    "__init__": [
      "self",
      "output_numpy_dtype",
      "output_shape"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "accumulator_coder": [
      "self"
    ],
    "_combine_accumulators": [
      "self",
      "a",
      "b"
    ]
  },
  "sanitized_vocab_filename": [
    "filename",
    "prefix"
  ],
  "_get_vocab_filename": [
    "vocab_filename",
    "store_frequency"
  ],
  "_maybe_get_per_key_vocab_filename": [
    "key_vocabulary_filename"
  ],
  "_get_top_k_and_frequency_threshold": [
    "top_k",
    "frequency_threshold"
  ],
  "_VocabOrderingType": {
    "FREQUENCY": [],
    "WEIGHTED_FREQUENCY": [],
    "WEIGHTED_MUTUAL_INFORMATION": [],
    "WEIGHTED_LABELS": [],
    "MUTUAL_INFORMATION": []
  },
  "register_vocab": [
    "sanitized_filename",
    "vocabulary_size",
    "vocabulary_key",
    "file_format"
  ],
  "get_empy_vocabulary_dummy_value": [
    "dtype"
  ],
  "vocabulary": [
    "x"
  ],
  "_get_vocabulary_analyzer_inputs": [
    "vocab_ordering_type",
    "x",
    "file_format",
    "labels",
    "weights"
  ],
  "get_vocab_newline_characters_regex": [
    "input_dtype",
    "file_format"
  ],
  "_vocabulary_analyzer_nodes": [
    "analyzer_inputs",
    "input_dtype",
    "vocab_ordering_type",
    "vocab_filename",
    "top_k",
    "frequency_threshold",
    "informativeness_threshold",
    "use_adjusted_mutual_info",
    "min_diff_from_avg",
    "fingerprint_shuffle",
    "store_frequency",
    "key_fn",
    "coverage_top_k",
    "coverage_frequency_threshold",
    "coverage_informativeness_threshold",
    "file_format",
    "vocabulary_key",
    "reserved_tokens"
  ],
  "calculate_recommended_min_diff_from_avg": [
    "dataset_size"
  ],
  "QuantilesCombiner": {
    "__init__": [
      "self",
      "num_quantiles",
      "epsilon",
      "bucket_numpy_dtype",
      "has_weights",
      "output_shape",
      "include_max_and_min",
      "feature_shape"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "next_input"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "compact": [
      "self",
      "accumulator"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "accumulator_coder": [
      "self"
    ]
  },
  "_QuantilesSketchCacheCoder": {
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "quantiles": [
    "x",
    "num_buckets",
    "epsilon",
    "weights",
    "reduce_instance_dims",
    "name"
  ],
  "_quantiles_per_key": [
    "x",
    "key",
    "num_buckets",
    "epsilon",
    "weights",
    "name"
  ],
  "CovarianceCombiner": {
    "__init__": [
      "self",
      "output_shape",
      "numpy_dtype"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "accumulator_coder": [
      "self"
    ]
  },
  "covariance": [
    "x",
    "dtype",
    "name"
  ],
  "PCACombiner": {
    "__init__": [
      "self",
      "output_shape",
      "output_dim",
      "numpy_dtype"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ]
  },
  "pca": [
    "x",
    "output_dim",
    "dtype",
    "name"
  ],
  "_maybe_annotate_vocab_metadata": [
    "vocab_filename",
    "unfiltered_vocabulary_size",
    "filtered_vocabulary_size"
  ],
  "PrimitiveType": [],
  "InstanceValueType": [],
  "InstanceDictType": [],
  "BucketBoundariesType": [],
  "FeatureSpecType": [],
  "DomainType": [],
  "TensorType": [],
  "ConsistentTensorType": [],
  "SparseTensorValueType": [],
  "RaggedTensorValueType": [],
  "TensorValueType": [],
  "TemporaryAnalyzerOutputType": [],
  "VocabularyFileFormatType": [],
  "SPARSE_VALUES_NAME_TEMPLATE": [],
  "SPARSE_INDICES_NAME_TEMPLATE": [],
  "_ragged_feature_spec_from_batched_tensor": [
    "name",
    "tensor"
  ],
  "_feature_spec_from_batched_tensors": [
    "tensors",
    "is_evaluation_complete",
    "forced_sparse_keys"
  ],
  "_get_tensor_values": [
    "tensor"
  ],
  "infer_feature_schema": [
    "features",
    "graph",
    "session"
  ],
  "infer_feature_schema_v2": [
    "features",
    "concrete_metadata_fn",
    "evaluate_schema_overrides"
  ],
  "_override_sparse_feature_annotated_shapes": [
    "feature_spec",
    "sparse_output_annotations"
  ],
  "_infer_feature_schema_common": [
    "features",
    "tensor_ranges",
    "feature_annotations",
    "global_annotations",
    "sparse_output_annotations",
    "is_evaluation_complete"
  ],
  "_TF_METADATA_TENSOR_COLLECTION": [],
  "_TF_METADATA_TENSOR_MIN_COLLECTION": [],
  "_TF_METADATA_TENSOR_MAX_COLLECTION": [],
  "_TF_METADATA_EXTRA_ANNOTATION": [],
  "_TF_METADATA_EXTRA_ANNOTATION_TYPE_URL": [],
  "_TF_METADATA_EXTRA_ANNOTATION_PROTO": [],
  "_TF_METADATA_EXTRA_ANNOTATION_GLOBAL": [],
  "_METADATA_SPARSE_OUTPUT_OVERRIDES_FIELD": [],
  "set_tensor_schema_override": [
    "tensor",
    "min_value",
    "max_value"
  ],
  "_get_tensor_ranges": [
    "graph"
  ],
  "_get_tensor_ranges_v2": [
    "metadata"
  ],
  "get_tensor_schema_override": [
    "tensor"
  ],
  "annotate": [
    "type_url",
    "proto_message",
    "tensor"
  ],
  "_get_schema_annotations": [
    "graph",
    "session"
  ],
  "_get_schema_annotations_v2": [
    "metadata"
  ],
  "_get_schema_annotations_common": [
    "tensor_annotation_keys",
    "type_urls",
    "proto_values"
  ],
  "_get_tensor_value_to_key_map": [
    "features_dict"
  ],
  "_get_schema_overrides": [
    "graph",
    "tensor_name_to_key_map",
    "tensor_collection_key",
    "overrides_keys",
    "default_tensor_name"
  ],
  "get_traced_metadata_fn": [
    "preprocessing_fn",
    "structured_inputs",
    "tf_graph_context",
    "evaluate_schema_overrides"
  ],
  "_ANNOTATED_SPARSE_SHAPE_TENSORS": [],
  "_ANNOTATED_SPARSE_SHAPES": [],
  "_ANNOTATED_TRUELY_SPARSE_TENSORS": [],
  "annotate_sparse_output_shape": [
    "tensor",
    "shape"
  ],
  "annotate_true_sparse_output": [
    "tensor"
  ],
  "_extract_true_sparse_annotations": [
    "graph"
  ],
  "_extract_sparse_output_annotations": [
    "graph"
  ],
  "_get_sparse_output_annotations": [
    "graph"
  ],
  "_get_sparse_output_annotations_v1": [
    "graph",
    "session"
  ],
  "_get_sparse_output_annotations_v2": [
    "graph",
    "tensor_to_feature_names"
  ],
  "_AssetFileType": [],
  "_FLOATING_NAN": [],
  "GLOBAL_Y_COUNT_SENTINEL_STRING": [],
  "GLOBAL_Y_COUNT_SENTINEL_INT": [],
  "_ASSET_REPLACEMENTS": [],
  "_VOCABULARY_RESERVED_TOKENS_IDS": [],
  "_VOCABULARY_RESERVED_TOKENS": [],
  "_MISSING_MASK_VALUE": [],
  "ReducedBatchWeightedCounts": [],
  "_CompositeTensorRef": [],
  "_BatchWeightedVocabulary": {},
  "get_values": [
    "x"
  ],
  "copy_tensors": [
    "tensors"
  ],
  "_copy_tensor": [
    "tensor"
  ],
  "_copy_tensor_or_composite_tensor": [
    "tensor"
  ],
  "_get_ragged_batch_value_rowids": [
    "tensor"
  ],
  "_make_regex_filter_fn": [
    "x",
    "filter_regex"
  ],
  "reduce_batch_weighted_counts": [
    "x",
    "weights",
    "force",
    "filter_regex"
  ],
  "reduce_batch_weighted_cooccurrences": [
    "x_input",
    "y_input",
    "weights_input",
    "extend_with_sentinel_counts",
    "filter_regex"
  ],
  "_compute_weighted_counts": [
    "x_input",
    "y_input",
    "weights_input",
    "filter_regex",
    "max_y_value"
  ],
  "_preprocess_tensors_for_cooccurences": [
    "x_input",
    "y_input",
    "weights_input",
    "filter_regex"
  ],
  "_compute_summed_positive_per_x_and_y": [
    "weights",
    "dummy_index",
    "max_x_idx",
    "max_y_value"
  ],
  "_compute_vocabulary_values": [
    "x",
    "weights"
  ],
  "extend_reduced_batch_with_y_counts": [
    "reduced_batch",
    "y",
    "weights"
  ],
  "hashable_tensor_or_op": [
    "tensor_or_op"
  ],
  "deref_tensor_or_op": [
    "tensor_or_op"
  ],
  "_broadcast_to_x_shape": [
    "x",
    "y"
  ],
  "assert_same_shape": [
    "x",
    "y"
  ],
  "_sparse_reduce_batch_keep_shape": [
    "sparse_reduce_fn",
    "sparse_tensor"
  ],
  "reduce_batch_count": [
    "x",
    "reduce_instance_dims"
  ],
  "_map_values": [
    "map_function",
    "tensor"
  ],
  "maybe_format_vocabulary_input": [
    "x"
  ],
  "_to_string": [
    "x"
  ],
  "reduce_batch_count_per_key": [
    "key"
  ],
  "reorder_histogram": [
    "bucket_vocab",
    "counts",
    "boundary_size"
  ],
  "Side": {
    "RIGHT": [],
    "LEFT": []
  },
  "assign_buckets": [
    "x",
    "bucket_boundaries",
    "side"
  ],
  "_DatasetInitializerCompat": {
    "__init__": [
      "self"
    ],
    "initialize": [
      "self",
      "table"
    ]
  },
  "_make_vocab_entry_to_dtype_fn": [
    "dtype"
  ],
  "_make_tfrecord_vocabulary_dataset": [
    "vocab_path",
    "key_dtype",
    "value_dtype",
    "return_indicator_as_value",
    "has_indicator"
  ],
  "make_tfrecord_vocabulary_lookup_initializer": [
    "filename_tensor",
    "key_dtype",
    "value_dtype",
    "return_indicator_as_value",
    "has_indicator"
  ],
  "_split_vocabulary_entries": [
    "batched_vocab_lines"
  ],
  "apply_per_key_vocabulary": [
    "per_key_filename",
    "key",
    "default_value",
    "target_ndims"
  ],
  "_is_finite": [
    "x"
  ],
  "_reduce_batch_count_mean_and_var_sparse": [
    "x"
  ],
  "_reduce_batch_count_mean_and_var_ragged": [
    "x"
  ],
  "_reduce_batch_count_mean_and_var_dense": [
    "x",
    "reduce_instance_dims"
  ],
  "reduce_batch_count_mean_and_var": [
    "x",
    "reduce_instance_dims"
  ],
  "_num_terms_and_factors": [
    "num_samples",
    "dtype"
  ],
  "_condition_l_moments_sparse": [
    "current_index",
    "unused_l1_sum",
    "unused_l2_sum",
    "unused_l3_sum",
    "unused_l4_sum",
    "unused_count_samples",
    "unused_count_pairs",
    "unused_count_triplets",
    "unused_count_quadruplets",
    "x_rank_2"
  ],
  "_iteration_l_moments_sparse": [
    "current_index",
    "l1_sum",
    "l2_sum",
    "l3_sum",
    "l4_sum",
    "count_samples",
    "count_pairs",
    "count_triplets",
    "count_quadruplets",
    "x_rank_2"
  ],
  "_condition_l_moments_dense": [
    "current_index",
    "unused_l1_sum",
    "unused_l2_sum",
    "unused_l3_sum",
    "unused_l4_sum",
    "unused_l1_factors",
    "unused_l2_factors",
    "unused_l3_factors",
    "unused_l4_factors",
    "x_rank_2"
  ],
  "_iteration_l_moments_dense": [
    "current_index",
    "l1_sum",
    "l2_sum",
    "l3_sum",
    "l4_sum",
    "l1_factors",
    "l2_factors",
    "l3_factors",
    "l4_factors",
    "x_rank_2"
  ],
  "reduce_batch_count_l_moments": [
    "x",
    "reduce_instance_dims"
  ],
  "_validate_and_get_dense_value_key_inputs": [
    "x",
    "key"
  ],
  "lookup_key": [
    "query",
    "key_vocab"
  ],
  "_align_dims": [
    "tensor",
    "target_ndims"
  ],
  "map_per_key_reductions": [
    "tensors_to_map",
    "key",
    "key_vocab",
    "original_input",
    "reduce_instance_dims"
  ],
  "reduce_batch_count_mean_and_var_per_key": [
    "x",
    "key",
    "reduce_instance_dims"
  ],
  "_DEFAULT_VALUE_BY_DTYPE": [],
  "_encode_proto": [
    "values_dict",
    "message_type",
    "descriptor_source"
  ],
  "_serialize_feature": [
    "values"
  ],
  "serialize_example": [
    "features"
  ],
  "_get_missing_value": [
    "dtype"
  ],
  "_sparse_minus_reduce_min_and_reduce_max": [
    "x"
  ],
  "reduce_batch_minus_min_and_max": [
    "x",
    "reduce_instance_dims"
  ],
  "reduce_batch_minus_min_and_max_per_key": [
    "x",
    "key",
    "reduce_instance_dims"
  ],
  "track_asset_analyzer_output": [
    "eager_asset_path",
    "graph_tensor"
  ],
  "_get_asset_analyzer_output_and_control_dependency": [
    "asset_filepath"
  ],
  "_lookup_table": [
    "table",
    "x",
    "control_dependency"
  ],
  "construct_and_lookup_table": [
    "construct_table_callable",
    "asset_filepath",
    "x"
  ],
  "lookup_table": [
    "lookup_fn",
    "asset_filepath",
    "x"
  ],
  "to_vocab_range": [
    "x",
    "vocab_size"
  ],
  "document_frequency_to_idf": [
    "document_frequency",
    "corpus_size",
    "smooth",
    "add_baseline"
  ],
  "register_vocabulary_reserved_tokens": [
    "name",
    "reserved_tokens"
  ],
  "fetch_vocabulary_reserved_tokens": [
    "graph",
    "name"
  ],
  "AnnotatorsTest": {
    "test_annotate_asset": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_object_tracker": [
      "self"
    ]
  },
  "_ANNOTATION_CLASSES": [],
  "_PROTO_CLASSES": [],
  "_PROTO_CLS_BY_NAME": [],
  "_pickle_proto": [
    "proto"
  ],
  "_unpickle_proto": [
    "name",
    "serialized_proto"
  ],
  "_pickle_tensor_spec": [
    "tensor_spec"
  ],
  "_unpickle_tensor_spec": [
    "shape",
    "numpy_dtype"
  ],
  "fix_internal_object_pickling": [],
  "_Concat": {
    "__slots__": []
  },
  "_Swap": {
    "__slots__": [],
    "num_outputs": [
      "self"
    ]
  },
  "_Constant": {
    "__slots__": []
  },
  "_Identity": {
    "__slots__": []
  },
  "NodesTest": {
    "testApplyOperationWithKwarg": [
      "self"
    ],
    "testApplyOperationWithTupleOutput": [
      "self"
    ],
    "testValueNodeWithNegativeValueIndex": [
      "self"
    ],
    "testValueNodeWithTooHighValueIndex": [
      "self"
    ],
    "testTraverserSimpleGraph": [
      "self"
    ],
    "testTraverserComplexGraph": [
      "self"
    ],
    "testTraverserComplexGraphMultipleCalls": [
      "self"
    ],
    "testTraverserOutputsNotATuple": [
      "self"
    ],
    "testTraverserBadNumOutputs": [
      "self"
    ],
    "testTraverserCycle": [
      "self"
    ],
    "testGetDotGraph": [
      "self"
    ]
  },
  "_VALID_SCOPE_REGEX": [],
  "_INVALID_SCOPE_CHAR": [],
  "METADATA_DIR_NAME": [],
  "_FEATURE_VALUE_KIND_TO_NP_DTYPE": [],
  "batched_placeholders_from_specs": [
    "specs"
  ],
  "_is_feature_spec": [
    "spec"
  ],
  "_sanitize_scope_name": [
    "name"
  ],
  "_batched_placeholder_from_typespec": [
    "name",
    "typespec"
  ],
  "_batched_placeholder_from_feature_spec": [
    "name",
    "feature_spec"
  ],
  "_example_to_dict": [
    "example"
  ],
  "record_batch_to_instance_dicts": [
    "record_batch",
    "schema"
  ],
  "validate_varlen_sparse_value": [
    "name",
    "batched_value"
  ],
  "get_type_specs_from_feature_specs": [
    "feature_specs",
    "ragged_sequence_features"
  ],
  "make_tensor_to_arrow_converter": [
    "schema"
  ],
  "get_traced_transform_fn": [
    "preprocessing_fn",
    "input_signature",
    "tf_graph_context",
    "output_keys_to_name_map"
  ],
  "_trace_preprocessing_fn_v1": [
    "preprocessing_fn",
    "specs"
  ],
  "_trace_preprocessing_fn_v2": [
    "preprocessing_fn",
    "specs",
    "base_temp_dir"
  ],
  "trace_preprocessing_function": [
    "preprocessing_fn",
    "input_specs",
    "use_tf_compat_v1",
    "base_temp_dir"
  ],
  "_trace_and_write_transform_fn": [
    "saved_model_dir",
    "preprocessing_fn",
    "input_signature",
    "base_temp_dir",
    "tensor_replacement_map",
    "output_keys_to_name_map",
    "save_options"
  ],
  "_trace_and_get_metadata": [
    "concrete_transform_fn",
    "structured_inputs",
    "preprocessing_fn",
    "base_temp_dir",
    "tensor_replacement_map"
  ],
  "_validate_analyzers_fingerprint": [
    "baseline_analyzers_fingerprint",
    "graph",
    "structured_inputs"
  ],
  "trace_and_write_v2_saved_model": [
    "saved_model_dir",
    "preprocessing_fn",
    "input_signature",
    "base_temp_dir",
    "baseline_analyzers_fingerprint",
    "tensor_replacement_map",
    "output_keys_to_name_map",
    "save_options"
  ],
  "_assert_no_analyzers_in_graph": [
    "graph"
  ],
  "analyze_in_place": [
    "preprocessing_fn",
    "force_tf_compat_v1",
    "feature_specs",
    "type_specs",
    "transform_output_path"
  ],
  "_NP_TYPES": [],
  "_SUM_TEST": [],
  "_SUM_SCALAR_TEST": [],
  "_SUM_OF_SIZE_ZERO_TENSORS_TEST": [],
  "_COVARIANCE_SIZE_ZERO_TENSORS_TEST": [],
  "_COVARIANCE_WITH_DEGENERATE_COVARIANCE_MATRIX_TEST": [],
  "_COVARIANCE_WITH_LARGE_NUMBERS_TEST": [],
  "_PCA_WITH_DEGENERATE_COVARIANCE_MATRIX_TEST": [],
  "_make_mean_and_var_accumulator_from_instance": [
    "instance",
    "axis"
  ],
  "_MEAN_AND_VAR_TEST": [],
  "_MEAN_AND_VAR_SIMPLE_TEST": [],
  "_MEAN_AND_VAR_BIG_TEST": [],
  "_MEAN_AND_VAR_VECTORS_TEST": [],
  "_MEAN_AND_VAR_ND_TEST": [],
  "_L_MOMENTS_TESTS": [],
  "_L_MOMENTS_ND_TESTS": [],
  "_QUANTILES_NO_ELEMENTS_TEST": [],
  "_QUANTILES_EXACT_NO_ELEMENTS_TEST": [],
  "_QUANTILES_NO_TRIM_TEST": [],
  "_QUANTILES_SINGLE_BATCH_TESTS": [],
  "_QUANTILES_ELEMENTWISE_TESTS": [],
  "_QUANTILES_MULTIPLE_BATCH_TESTS": [],
  "_EXACT_NUM_QUANTILES_TESTS": [],
  "AnalyzersTest": {
    "testCombiner": [
      "self",
      "combiner",
      "batches",
      "expected_outputs"
    ],
    "test_pad_arrays_to_match": [
      "self",
      "a",
      "b",
      "expected_a",
      "expected_b"
    ],
    "testMinDiffFromAvg": [
      "self"
    ]
  },
  "_create_lookup_table_from_file": [
    "filename"
  ],
  "_create_graph_with_y_function_of_x": [],
  "_create_graph_with_tf_function": [],
  "_create_graph_with_tf2_saved_model_with_table": [],
  "_create_graph_with_placeholder_in_tf_function": [],
  "_create_graph_with_mixed_dependencies": [],
  "_create_graph_with_chained_tf_function": [],
  "_create_graph_with_y_function_of_x_with_unused_inputs": [],
  "_create_graph_with_y_function_of_x_sparse": [],
  "_create_graph_with_z_function_of_x_ragged": [],
  "_create_graph_with_ragged_tensor": [],
  "_create_graph_with_y_sparse_function_of_x_sparse": [],
  "_create_graph_with_y_function_of_x_and_table": [],
  "_create_graph_with_y_function_of_x_and_table_in_first_phase": [],
  "_create_graph_with_y_function_of_x_and_untracked_table": [],
  "_create_graph_with_table_initialized_by_table_output": [],
  "_create_graph_with_assert_equal": [],
  "_create_graph_with_y_function_of_x_with_tf_while": [],
  "_create_graph_with_tf_function_while": [],
  "_Matcher": {
    "_future_proof": [
      "self",
      "value"
    ],
    "expected_fields": [
      "self",
      "other"
    ],
    "expected_fields_values": [
      "self"
    ],
    "expected_class": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "_TensorMatcher": {
    "__slots__": [],
    "expected_fields": [
      "self",
      "other"
    ],
    "expected_fields_values": [
      "self"
    ],
    "expected_class": [
      "self"
    ]
  },
  "_OpMatcher": {
    "__slots__": [],
    "expected_fields": [
      "self",
      "other"
    ],
    "expected_fields_values": [
      "self"
    ],
    "expected_class": [
      "self"
    ]
  },
  "GraphToolsTest": {
    "testDetermineReadyTensorsAndTableInitializers": [
      "self",
      "create_graph_fn",
      "feeds",
      "replaced_tensors_ready",
      "should_be_ready",
      "num_ready_table_initializers"
    ],
    "testInitializableGraphAnalyzerConstructorRaises": [
      "self",
      "create_graph_fn",
      "feeds",
      "replaced_tensors_ready",
      "error_msg_regex"
    ],
    "testInitializableGraphAnalyzerReadyToRunRaises": [
      "self",
      "create_graph_fn",
      "feeds",
      "replaced_tensors_ready",
      "fetch",
      "error_msg_regex"
    ],
    "testGetDependentInputs": [
      "self",
      "create_graph_fn",
      "feeds",
      "fetches",
      "expected_dependent_inputs"
    ]
  },
  "GraphToolsTestUniquePath": {
    "testGetUniquePath": [
      "self",
      "create_graph_fn",
      "feeds",
      "replaced_tensors_ready",
      "expected_calls_dict"
    ]
  },
  "_value_to_matcher": [
    "value",
    "add_quotes"
  ],
  "version_fn": [],
  "_MEAN_SCALE_SCALAR_TEST": [],
  "_MEAN_SCALE_ND_TEST": [],
  "_L_SKEWNESS_KURTOSIS_SCALAR_TEST": [],
  "_L_SKEWNESS_KURTOSIS_ND_TEST": [],
  "_COMPUTE_TUKEY_H_PARAMS_REGULAR_TESTS": [],
  "_COMPUTE_TUKEY_H_PARAMS_NEG_SKEWNESS_TEST": [],
  "_COMPUTE_TUKEY_H_PARAMS_PATOLOGICAL_TESTS": [],
  "_LAMBERT_W_SCALAR_TESTS": [],
  "_LAMBERT_W_ND_TESTS": [],
  "_INVERSE_TUKEY_HH_SCALAR_TESTS": [],
  "_tukey_hh": [
    "x",
    "hl",
    "hr"
  ],
  "_INVERSE_TUKEY_HH_ND_TESTS": [],
  "GaussianizationTest": {
    "test_tukey_hh_l_mean_and_scale": [
      "self",
      "h_params",
      "expected_outputs"
    ],
    "test_tukey_hh_l_skewness_and_kurtosis": [
      "self",
      "h_params",
      "expected_outputs"
    ],
    "test_compute_tukey_hh_params": [
      "self",
      "l_skewness_and_kurtosis",
      "expected_output"
    ],
    "test_lambert_w": [
      "self",
      "samples",
      "expected_output"
    ],
    "test_inverse_tukey_hh": [
      "self",
      "samples",
      "hl",
      "hr",
      "expected_output"
    ]
  },
  "get_analyze_input_columns": [
    "preprocessing_fn",
    "specs",
    "force_tf_compat_v1"
  ],
  "get_transform_input_columns": [
    "preprocessing_fn",
    "specs",
    "force_tf_compat_v1"
  ],
  "TFGraphContext": {
    "_TEMP_SUBDIR": [],
    "_thread_local": [],
    "__init__": [
      "self",
      "module_to_export",
      "temp_dir",
      "evaluated_replacements"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ],
    "module_to_export": [
      "self"
    ],
    "_get_current_state": [
      "cls"
    ],
    "get_or_create_temp_dir": [
      "cls"
    ],
    "get_evaluated_replacements": [
      "cls"
    ],
    "get_module_to_export": [
      "cls"
    ]
  },
  "get_vocabulary_size_by_name": [
    "vocab_filename"
  ],
  "compute_and_apply_approximate_vocabulary": [
    "x"
  ],
  "document_frequency": [
    "x",
    "vocab_size",
    "name"
  ],
  "idf": [
    "x",
    "vocab_size",
    "smooth",
    "add_baseline",
    "name"
  ],
  "_to_term_document_one_hot": [
    "x",
    "vocab_size"
  ],
  "_to_global_document_frequency": [
    "x",
    "vocab_size"
  ],
  "PTransformAnalyzerCacheCoder": [],
  "SimpleJsonPTransformAnalyzerCacheCoder": [],
  "_APPROXIMATE_VOCAB_FILENAME_PREFIX": [],
  "_APPROXIMATE_VOCAB_FREQUENCY_FILENAME_PREFIX": [],
  "_BeamPTransform": {
    "expand": [
      "self",
      "pcol"
    ],
    "default_label": [
      "self"
    ]
  },
  "CacheablePTransformAnalyzer": {
    "__slots__": []
  },
  "_apply_analyzer": [
    "ptransform"
  ],
  "ptransform_analyzer": [
    "inputs",
    "ptransform",
    "output_dtypes",
    "output_shapes",
    "output_asset_default_values",
    "name"
  ],
  "_get_approx_vocab_filename": [
    "vocab_filename",
    "store_frequency"
  ],
  "approximate_vocabulary": [
    "x",
    "top_k"
  ],
  "_approximate_vocabulary_analyzer_nodes": [
    "analyzer_inputs",
    "input_dtype",
    "vocab_filename",
    "top_k",
    "store_frequency",
    "file_format",
    "vocabulary_key",
    "reserved_tokens"
  ],
  "_MisraGriesSketchCoder": {
    "encode_cache": [
      "self",
      "accumulator"
    ],
    "decode_cache": [
      "self",
      "encoded_accumulator"
    ]
  },
  "_VocabularyCombiner": {
    "__init__": [
      "self",
      "top_k",
      "input_dtype",
      "output_pylist"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "next_input"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ],
    "output_tensor_infos": [
      "self"
    ],
    "accumulator_coder": [
      "self"
    ]
  },
  "_get_approximate_vocabulary_analyzer_inputs": [
    "x",
    "file_format",
    "weights"
  ],
  "apply_pyfunc": [
    "func",
    "Tout",
    "stateful",
    "name"
  ],
  "_PYFUNC_COLLECTION_KEY": [],
  "_PyFuncDef": {
    "__slots__": [],
    "from_proto": [
      "attr_value",
      "import_scope"
    ],
    "from_proto_string": [
      "proto_str",
      "import_scope"
    ],
    "to_proto": [
      "self",
      "export_scope"
    ]
  },
  "insert_pyfunc": [
    "func",
    "Tout",
    "stateful",
    "name"
  ],
  "register_pyfuncs_from_saved_transform": [
    "graph",
    "meta_graph",
    "loaded_in_tf2"
  ],
  "_create_test_saved_model": [],
  "SavedTransformIOTest": {
    "setUpClass": [
      "cls"
    ],
    "test_apply_saved_transform": [
      "self"
    ],
    "test_apply_transform_extra_features_no_passthrough": [
      "self"
    ],
    "test_apply_transform_type_mismatch": [
      "self"
    ],
    "test_apply_transform_shape_mismatch": [
      "self"
    ],
    "test_apply_saved_transform_to_tensor_inside_scope": [
      "self"
    ],
    "test_apply_saved_transform_to_tensor_outside_scope": [
      "self"
    ],
    "test_dense_roundtrip": [
      "self"
    ],
    "test_table_roundtrip": [
      "self"
    ],
    "test_sparse_roundtrip": [
      "self"
    ],
    "test_ragged_roundtrip": [
      "self"
    ],
    "test_stale_asset_collections_are_cleaned": [
      "self"
    ]
  },
  "parse_saved_model": [
    "saved_model_dir"
  ],
  "_choose_meta_graph_def_internal": [
    "saved_model",
    "tags"
  ],
  "choose_meta_graph_def": [
    "saved_model"
  ],
  "choose_meta_graph_def_and_raise": [
    "saved_model"
  ],
  "get_asset_tensors": [
    "saved_model_dir",
    "meta_graph_def_to_load"
  ],
  "_TRANFORM_FN_EXPORT_TF_VERSION_TEST_CASES": [],
  "_get_preprocessing_fn_asset_table": [
    "asset_file"
  ],
  "_get_preprocessing_fn_non_asset_table": [
    "asset_file"
  ],
  "_RE_EXPORT_TF2_TO_TF1_TEST_CASES": [],
  "SavedTransformIOV2Test": {
    "setUpClass": [
      "cls"
    ],
    "_get_saved_model_loader": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_saved_transform": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_saved_transform_dataset_map": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_transform_extra_features_no_passthrough": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_transform_type_mismatch": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_transform_shape_mismatch": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_saved_transform_to_tensor_inside_scope": [
      "self",
      "exported_in_tf1"
    ],
    "test_apply_saved_transform_to_tensor_outside_scope": [
      "self",
      "exported_in_tf1"
    ],
    "test_dense_roundtrip": [
      "self",
      "exported_in_tf1"
    ],
    "test_table_roundtrip": [
      "self",
      "exported_in_tf1"
    ],
    "test_sparse_roundtrip": [
      "self",
      "exported_in_tf1"
    ],
    "test_ragged_roundtrip": [
      "self",
      "exported_in_tf1"
    ],
    "test_ragged_with_unfed": [
      "self",
      "exported_in_tf1"
    ],
    "test_re_export_tf2_saved_model_to_tf1": [
      "self",
      "preprocessing_fn_getter",
      "expected_output",
      "test_input",
      "asset_file_contents"
    ],
    "test_stale_asset_collections_are_cleaned": [
      "self"
    ],
    "test_finalize": [
      "self"
    ],
    "test_optimize_concrete_function": [
      "self",
      "strip_control_dependencies"
    ],
    "test_restore_from_v1_saved_model_with_pyfuncs": [
      "self"
    ],
    "test_restore_from_v1_saved_model_without_pyfuncs": [
      "self"
    ]
  },
  "_create_test_saved_model_dir": [],
  "SavedModelLoaderTest": {
    "setUpClass": [
      "cls"
    ]
  },
  "_MANGLED_TENSOR_NAME_RE": [],
  "_update_legacy_signature": [
    "signature"
  ],
  "_load_transform_saved_model": [
    "transform_savedmodel_dir"
  ],
  "_expand_input_map": [
    "logical_input_map",
    "input_signature"
  ],
  "_PARTITIONED_VARIABLE_NAME_RE": [],
  "_maybe_register_addon_ops": [],
  "_partially_apply_saved_transform_impl": [
    "saved_model_dir",
    "logical_input_map",
    "tensor_replacement_map"
  ],
  "partially_apply_saved_transform_internal": [
    "saved_model_dir",
    "logical_input_map",
    "tensor_replacement_map"
  ],
  "write_saved_transform_from_session": [
    "session",
    "inputs",
    "outputs",
    "export_path",
    "as_text"
  ],
  "exported_as_v1": [
    "transform_savedmodel_dir"
  ],
  "_restore_from_v1_saved_model": [
    "restored_function",
    "saved_model_dir"
  ],
  "_as_operation": [
    "op_or_tensor"
  ],
  "_get_component_tensors": [
    "tensor"
  ],
  "_get_output_to_inputs_map": [
    "output_signature"
  ],
  "SavedModelLoader": {
    "__init__": [
      "self",
      "saved_model_dir"
    ],
    "_initialize": [
      "self",
      "load_v2_in_compat",
      "imported",
      "wrapped",
      "structured_inputs",
      "structured_outputs",
      "outputs_to_inputs_map"
    ],
    "load_v2_in_compat": [
      "self"
    ],
    "structured_outputs": [
      "self"
    ],
    "_get_feeds": [
      "self",
      "unfed_input_keys"
    ],
    "_get_unfed_input_keys": [
      "self",
      "input_tensor_keys"
    ],
    "_get_fetches": [
      "self",
      "feeds"
    ],
    "_get_fetches_keys": [
      "self",
      "feeds"
    ],
    "_get_missing_inputs": [
      "self",
      "unfed_input_keys",
      "batch_size"
    ],
    "_apply_v1_transform_model_in_v2": [
      "self",
      "logical_input_map"
    ],
    "_format_input_map_as_tensors": [
      "self",
      "input_map"
    ],
    "_apply_v2_transform_model_finalized": [
      "self",
      "logical_input_map"
    ],
    "_apply_v2_transform_model": [
      "self",
      "logical_input_map"
    ],
    "apply_transform_model": [
      "self",
      "logical_input_map"
    ],
    "_finalize_wrapped_function": [
      "self",
      "unfed_input_keys",
      "fetches_keys"
    ],
    "finalize": [
      "self",
      "input_tensor_keys",
      "output_tensor_keys"
    ]
  },
  "optimize_concrete_function": [
    "concrete_function",
    "strip_control_dependencies"
  ],
  "trace_and_update_module": [
    "module",
    "tf_function",
    "name",
    "strip_control_dependencies"
  ],
  "write_v2_saved_model": [
    "module",
    "tf_function",
    "name",
    "saved_model_dir",
    "save_options"
  ],
  "TRANSFORM_TAG": [],
  "TRANSFORM_SIGNATURE": [],
  "_MATERIALIZATION_BARRIER_TRANSFORMS": [],
  "_is_at_materialization_boundary": [
    "pcollection"
  ],
  "_get_items_to_clone": [
    "pcollection"
  ],
  "_clone_items": [
    "pipeline",
    "to_clone"
  ],
  "deep_copy": [
    "pcollection"
  ],
  "METRICS_NAMESPACE": [],
  "EnvironmentTags": {
    "TF_COMPAT_V1": [],
    "TF_V2_ONLY": []
  },
  "_ALLOWED_PTRANSFORM_TAGS": [],
  "get_unique_temp_path": [
    "base_temp_dir"
  ],
  "_PtransformWrapper": {
    "_GENERAL_ENVIRONMENT_TAG": [],
    "__init__": [
      "self"
    ],
    "add_ptransform": [
      "self",
      "ptransform_class",
      "tags"
    ],
    "get_ptransform": [
      "self",
      "tag"
    ]
  },
  "_PTRANSFORM_BY_OPERATION_DEF_SUBCLASS": [],
  "register_ptransform": [
    "operation_def_subclass",
    "tags"
  ],
  "ConstructBeamPipelineVisitor": {
    "__init__": [
      "self",
      "extra_args"
    ],
    "visit": [
      "self",
      "operation",
      "inputs"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "IncrementCounter": {
    "__init__": [
      "self",
      "counter_name"
    ],
    "_make_and_increment_counter": [
      "self",
      "unused_element"
    ],
    "expand": [
      "self",
      "pcoll"
    ]
  },
  "_ANALYSIS_GRAPH": [],
  "_IntermediateCacheType": [],
  "_tensor_name": [
    "tensor"
  ],
  "_ReadyVisitor": {
    "__init__": [
      "self",
      "graph_analyzer"
    ],
    "_validate_operation_label_uniqueness": [
      "self",
      "operation_def"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_TranslateVisitor": {
    "__init__": [
      "self"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_OptimizationView": {
    "__post_init__": [
      "self"
    ]
  },
  "_OptimizeVisitor": {
    "__init__": [
      "self",
      "dataset_keys",
      "cache_dict",
      "tensor_keys_to_paths",
      "cache_output_nodes",
      "num_phases"
    ],
    "_validate_operation_def": [
      "self",
      "operation_def"
    ],
    "get_detached_sideeffect_leafs": [
      "self"
    ],
    "_make_next_hashed_path": [
      "self",
      "parent_hashed_paths",
      "operation_def"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_visit_partitionable_operation": [
      "self",
      "operation_def",
      "upstream_views"
    ],
    "_apply_operation_on_fine_grained_view": [
      "self",
      "operation_def",
      "fine_grained_views",
      "next_hashed_path"
    ],
    "_visit_apply_savedmodel_operation": [
      "self",
      "operation_def",
      "upstream_views"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_perform_cache_optimization": [
    "saved_model_future",
    "dataset_keys",
    "tensor_keys_to_paths",
    "cache_dict",
    "num_phases"
  ],
  "_InspectVisitor": {
    "__init__": [
      "self",
      "required_dataset_keys_output"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_build_analysis_graph_for_inspection": [
    "preprocessing_fn",
    "specs",
    "dataset_keys",
    "input_cache",
    "force_tf_compat_v1"
  ],
  "get_analysis_dataset_keys": [
    "preprocessing_fn",
    "specs",
    "dataset_keys",
    "input_cache",
    "force_tf_compat_v1"
  ],
  "get_analysis_cache_entry_keys": [
    "preprocessing_fn",
    "specs",
    "dataset_keys",
    "force_tf_compat_v1"
  ],
  "AnalysisCache": [],
  "_format_output_cache": [
    "cache_value_nodes"
  ],
  "build": [
    "graph",
    "input_signature",
    "output_signature",
    "dataset_keys",
    "cache_dict"
  ],
  "_SCALE_TO_Z_SCORE_TEST_CASES": [],
  "_SCALE_TO_Z_SCORE_NAN_TEST_CASES": [],
  "_sigmoid": [
    "x"
  ],
  "sum_output_dtype": [
    "input_dtype"
  ],
  "_mean_output_dtype": [
    "input_dtype"
  ],
  "BeamImplTest": {
    "setUp": [
      "self"
    ],
    "tearDown": [
      "self"
    ],
    "_OutputRecordBatches": [
      "self"
    ],
    "_SkipIfOutputRecordBatches": [
      "self"
    ],
    "assertAnalyzeAndTransformResults": [
      "self"
    ],
    "assertAnalyzerOutputs": [
      "self"
    ],
    "_MakeTransformOutputAssertFn": [
      "self",
      "expected",
      "sort"
    ],
    "testApplySavedModelSingleInput": [
      "self"
    ],
    "testApplySavedModelWithHashTable": [
      "self"
    ],
    "testApplySavedModelMultiInputs": [
      "self"
    ],
    "testApplyFunctionWithCheckpoint": [
      "self"
    ],
    "testMultipleLevelsOfAnalyzers": [
      "self",
      "with_deep_copy"
    ],
    "testRawFeedDictInput": [
      "self"
    ],
    "testTransformWithExcludedOutputs": [
      "self"
    ],
    "testMapWithCond": [
      "self"
    ],
    "testPyFuncs": [
      "self"
    ],
    "testAssertsNoReturnPyFunc": [
      "self"
    ],
    "testWithMoreThanDesiredBatchSize": [
      "self"
    ],
    "testWithUnicode": [
      "self"
    ],
    "testNpArrayInput": [
      "self"
    ],
    "testScaleUnitInterval": [
      "self",
      "elementwise"
    ],
    "testScaleUnitIntervalPerKey": [
      "self",
      "elementwise"
    ],
    "testScaleMinMax": [
      "self",
      "elementwise"
    ],
    "testScaleMinMaxPerKey": [
      "self",
      "elementwise",
      "key_vocabulary_filename"
    ],
    "testScalePerKeySparse": [
      "self"
    ],
    "testScaleMinMaxSparsePerKey": [
      "self",
      "input_data",
      "input_metadata",
      "expected_data"
    ],
    "testScalePerKeyRagged": [
      "self",
      "input_data",
      "make_key_spec",
      "expected_data",
      "input_dtype"
    ],
    "testScaleMinMaxConstant": [
      "self"
    ],
    "testScaleMinMaxConstantElementwise": [
      "self"
    ],
    "testScaleMinMaxError": [
      "self"
    ],
    "testScaleMinMaxWithEmptyInputs": [
      "self"
    ],
    "testScaleToZScore": [
      "self",
      "input_data",
      "output_data",
      "elementwise"
    ],
    "testScaleToZScoreSparse": [
      "self",
      "input_dtype",
      "elementwise"
    ],
    "testScaleToZScoreSparsePerDenseKey": [
      "self",
      "input_dtype"
    ],
    "testScaleToZScorePerKey": [
      "self",
      "key_vocabulary_filename"
    ],
    "testScaleToZScorePerKeyElementwise": [
      "self",
      "input_data",
      "expected_data",
      "input_metadata",
      "expected_metadata"
    ],
    "testScaleToZScoreSparsePerKey": [
      "self",
      "input_dtype"
    ],
    "testScaleToZScoreWithEmptyInputs": [
      "self"
    ],
    "testMeanAndVar": [
      "self"
    ],
    "testMeanAndVarPerKey": [
      "self"
    ],
    "testMeanAndVarPerKeyElementwise": [
      "self"
    ],
    "testMinAndMaxPerKey": [
      "self",
      "input_data",
      "input_metadata",
      "reduce_instance_dims",
      "expected_outputs"
    ],
    "testPerKeyWithOOVKeys": [
      "self",
      "use_vocabulary"
    ],
    "testCountPerKey": [
      "self",
      "input_data",
      "input_metadata",
      "expected_outputs"
    ],
    "testHistograms": [
      "self",
      "input_data",
      "make_feature_spec",
      "boundaries",
      "categorical",
      "expected_outputs"
    ],
    "testProbCategoricalInt": [
      "self"
    ],
    "testProbCategorical": [
      "self"
    ],
    "testProbTenBoundaries": [
      "self"
    ],
    "testProbUnknownBoundaries": [
      "self",
      "input_data",
      "expected_outputs",
      "boundaries"
    ],
    "testNumericAnalyzersWithScalarInputs": [
      "self",
      "input_dtype",
      "output_dtypes"
    ],
    "testNumericAnalyzersWithCompositeInputs": [
      "self",
      "input_data",
      "make_feature_spec",
      "expected_outputs",
      "reduce_instance_dims",
      "input_dtype"
    ],
    "testNumericMappersWithCompositeInputs": [
      "self",
      "input_data",
      "make_feature_spec",
      "elementwise",
      "expected_outputs"
    ],
    "testNumericAnalyzersWithInputsAndAxis": [
      "self"
    ],
    "testNumericAnalyzersWithNDInputsAndAxis": [
      "self"
    ],
    "testNumericAnalyzersWithShape1NDInputsAndAxis": [
      "self"
    ],
    "testNumericAnalyzersWithNDInputs": [
      "self"
    ],
    "testNumericAnalyzersWithEmptyInputs": [
      "self",
      "input_dtype",
      "input_shape",
      "reduce_instance_dims"
    ],
    "testNumericMeanWithSparseTensorReduceFalseOverflow": [
      "self"
    ],
    "testStringToTFIDF": [
      "self"
    ],
    "testTFIDFNoData": [
      "self"
    ],
    "testStringToTFIDFEmptyDoc": [
      "self"
    ],
    "testIntToTFIDF": [
      "self"
    ],
    "testIntToTFIDFWithoutSmoothing": [
      "self"
    ],
    "testTFIDFWithOOV": [
      "self"
    ],
    "testTFIDFWithNegatives": [
      "self"
    ],
    "_get_dfidf_experimental_preprocessing_fn": [
      "self",
      "is_str_input",
      "smooth",
      "add_baseline",
      "vocab_size",
      "top_k"
    ],
    "testStringToDFIDFExperimental": [
      "self",
      "smooth",
      "add_baseline"
    ],
    "testDFIDFExperimentalNoData": [
      "self"
    ],
    "testStringToDFIDFExperimentalEmptyDoc": [
      "self"
    ],
    "testDFIDFExperimentalWithOOV": [
      "self"
    ],
    "testIntToDFIDFExpeirmental": [
      "self",
      "smooth",
      "add_baseline"
    ],
    "testDFIDFExperimentalWithNegatives": [
      "self"
    ],
    "testCovarianceTwoDimensions": [
      "self"
    ],
    "testCovarianceOneDimension": [
      "self"
    ],
    "testCovarianceOneDimensionWithEmptyInputs": [
      "self"
    ],
    "testPCAThreeToTwoDimensions": [
      "self"
    ],
    "testPCAThreeToTwoDimensionsWithEmptyInputs": [
      "self"
    ],
    "testPTransformAnalyzer": [
      "self"
    ],
    "testPTransformAnalyzerMultiDimOutput": [
      "self",
      "output_fn"
    ],
    "testSavedModelWithAnnotations": [
      "self"
    ],
    "testSavedModelWithGlobalAnnotations": [
      "self"
    ],
    "testPipelineAPICounters": [
      "self"
    ],
    "testNumBytesCounter": [
      "self"
    ],
    "testHandleBatchError": [
      "self"
    ],
    "testPassthroughKeys": [
      "self"
    ],
    "test3dSparseWithTFXIO": [
      "self"
    ],
    "testRaggedWithTFXIO": [
      "self"
    ],
    "testPipelineWithoutAutomaterialization": [
      "self"
    ],
    "testModifyInputs": [
      "self"
    ],
    "testEmptySchema": [
      "self"
    ],
    "testLoadKerasModelInPreprocessingFn": [
      "self"
    ],
    "test_non_deterministic_preprocessing_fn_without_name": [
      "self"
    ],
    "test_non_deterministic_preprocessing_fn_with_name": [
      "self"
    ],
    "test_preprocessing_fn_returns_wrong_type": [
      "self"
    ]
  },
  "_TransformFnPathType": [],
  "Context": [],
  "_CREATE_SAVED_MODEL_COUNTER_NAME": [],
  "_FIXED_PARALLELISM_TF_CONFIG": [],
  "_DEFAULT_TENSORFLOW_CONFIG_BY_BEAM_RUNNER_TYPE": [],
  "_MAX_TRANSFORMED_BATCH_BYTES_SIZE": [],
  "_clear_shared_state_after_barrier": [
    "pipeline",
    "input_barrier"
  ],
  "_RunMetaGraphDoFn": {
    "__init__": [
      "self",
      "tf_config",
      "shared_graph_state_handle",
      "passthrough_keys",
      "use_tf_compat_v1",
      "input_tensor_adapter_config",
      "exclude_outputs"
    ],
    "_get_input_tensor_names": [
      "self"
    ],
    "_update_metrics": [
      "self",
      "batch"
    ],
    "_make_feed_dict": [
      "self",
      "batch"
    ],
    "_get_passthrough_data_from_recordbatch": [
      "self",
      "batch"
    ],
    "_handle_batch": [
      "self",
      "batch"
    ],
    "_make_graph_state": [
      "self",
      "saved_model_dir"
    ],
    "setup": [
      "self"
    ],
    "process": [
      "self",
      "batch",
      "saved_model_dir"
    ]
  },
  "_warn_about_tf_compat_v1": [],
  "_maybe_slice_large_record_batch": [
    "record_batch"
  ],
  "_convert_to_record_batch": [
    "batch_dict",
    "converter",
    "passthrough_keys",
    "input_metadata",
    "validate_varlen_sparse_values"
  ],
  "_transformed_batch_to_instance_dicts": [
    "transformed_batch",
    "schema"
  ],
  "_TensorBinding": {},
  "_CreateTensorBindingsImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_get_tensor_replacement_map": [
    "graph"
  ],
  "_replace_tensors_with_constant_values": [
    "saved_model_dir",
    "base_temp_dir"
  ],
  "_CreateSavedModelImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_create_v2_saved_model": [
    "tensor_replacement_map",
    "base_temp_dir",
    "preprocessing_fn",
    "input_signature",
    "baseline_analyzers_fingerprint",
    "output_keys_to_name_map",
    "save_options"
  ],
  "_CreateSavedModelImplV2": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "_maybe_get_output_tensor_names_dict": [
      "self"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_BindTensors": {
    "__init__": [
      "self",
      "base_temp_dir",
      "unbound_saved_model_dir"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_ExtractInputForSavedModelImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "pbegin"
    ]
  },
  "_ApplySavedModelImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_ExtractFromDictImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_Flatten": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_infer_metadata_from_saved_model": [
    "saved_model_dir",
    "use_tf_compat_v1"
  ],
  "_infer_metadata_from_saved_model_v1": [
    "saved_model_dir"
  ],
  "_infer_metadata_from_saved_model_v2": [
    "saved_model_dir"
  ],
  "_InstrumentAPI": {
    "__init__": [
      "self",
      "tf_graph",
      "force_tf_compat_v1",
      "use_tf_compat_v1"
    ],
    "expand": [
      "self",
      "pipeline"
    ]
  },
  "_InstanceDictInputToTFXIOInput": {
    "__init__": [
      "self",
      "schema",
      "desired_batch_size"
    ],
    "tensor_adapter_config": [
      "self"
    ],
    "expand": [
      "self",
      "instance_dict_pcoll"
    ]
  },
  "_make_output_cache": [
    "cache_value_nodes",
    "traverser",
    "dataset_metrics"
  ],
  "_AnalyzeDatasetCommon": {
    "__init__": [
      "self",
      "preprocessing_fn",
      "pipeline"
    ],
    "_extract_input_pvalues": [
      "self",
      "dataset"
    ],
    "expand": [
      "self",
      "dataset"
    ]
  },
  "AnalyzeDatasetWithCache": {
    "_make_parent_dataset": [
      "self",
      "dataset"
    ],
    "_extract_input_pvalues": [
      "self",
      "dataset"
    ],
    "expand": [
      "self",
      "dataset"
    ]
  },
  "AnalyzeDataset": {
    "_extract_input_pvalues": [
      "self",
      "dataset"
    ],
    "expand": [
      "self",
      "dataset"
    ]
  },
  "AnalyzeAndTransformDataset": {
    "__init__": [
      "self",
      "preprocessing_fn",
      "output_record_batches"
    ],
    "_extract_input_pvalues": [
      "self",
      "dataset"
    ],
    "expand": [
      "self",
      "dataset"
    ]
  },
  "_remove_columns_from_metadata": [
    "metadata",
    "excluded_columns"
  ],
  "_MaybeInferTensorRepresentationsDoFn": {
    "process": [
      "self",
      "schema"
    ]
  },
  "TransformDataset": {
    "__init__": [
      "self",
      "exclude_outputs",
      "output_record_batches"
    ],
    "_extract_input_pvalues": [
      "self",
      "dataset_and_transform_fn"
    ],
    "expand": [
      "self",
      "dataset_and_transform_fn"
    ]
  },
  "EncodeTransformedDataset": {
    "_extract_input_pvalues": [
      "self",
      "transformed_data_and_metadata"
    ],
    "expand": [
      "self",
      "transformed_data_and_metadata"
    ]
  },
  "_get_quantiles_accumulator": [],
  "AnalyzerCacheTest": {
    "test_validate_dataset_keys": [
      "self"
    ],
    "test_coders_round_trip": [
      "self",
      "coder",
      "value"
    ],
    "test_cache_helpers_round_trip": [
      "self"
    ],
    "test_cache_write_empty": [
      "self"
    ],
    "test_cache_merge": [
      "self"
    ],
    "test_cache_helpers_with_alternative_io": [
      "self"
    ]
  },
  "AnalyzerImplsTest": {
    "testSplitInputsByKey": [
      "self"
    ],
    "testMergeOutputsByKey": [
      "self"
    ],
    "testMergeOutputsByKeyEmptyInput": [
      "self"
    ],
    "testMakeStrictlyIncreasingBoundariesRows": [
      "self",
      "input_boundaries",
      "expected_boundaries",
      "atol"
    ],
    "testJoinBoundarieRows": [
      "self",
      "input_boundaries",
      "expected_boundaries",
      "expected_scales",
      "expected_shifts",
      "expected_num_buckets"
    ]
  },
  "_CombinerOpWrapper": {},
  "_ValidationVisitor": {
    "__init__": [
      "self"
    ],
    "validate_operation_def": [
      "self",
      "operation_def"
    ],
    "validate_value": [
      "self",
      "value"
    ]
  },
  "_InspectAccumulateCombineVisitor": {
    "__init__": [
      "self"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_maybe_add_packable_combine": [
      "self",
      "operation_def",
      "input_values"
    ]
  },
  "_PackAccumulateCombineVisitor": {
    "__init__": [
      "self",
      "packable_combines"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_get_packed_combine": [
      "self",
      "operation_def",
      "input_values"
    ]
  },
  "_COMBINE_PARENT_NODE_TYPES": [],
  "_InspectMergeCombineVisitor": {
    "__init__": [
      "self"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_maybe_add_packable_combine": [
      "self",
      "operation_def",
      "input_values"
    ]
  },
  "_PackMergeCombineVisitor": {
    "__init__": [
      "self",
      "packable_combine_extract_outputs"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_add_flatten_placeholder": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_get_packed_combine": [
      "self",
      "operation_def",
      "input_values"
    ]
  },
  "_TensorBindingInfo": {},
  "_MAX_PACKED_POST_PROCESSING_DEPTH": [],
  "_RemoveRedundantPackedMergeCombineVisitor": {
    "__init__": [
      "self",
      "final_packed_merge_combine_label"
    ],
    "visit": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_remove_redundant_nodes": [
      "self",
      "operation_def",
      "input_values"
    ],
    "_is_packed_post_processing_node": [
      "self",
      "value_node"
    ],
    "_get_redundant_and_non_redundant_input_values": [
      "self",
      "input_values"
    ],
    "_get_final_packed_combine_and_tensor_bindings": [
      "self",
      "input_values"
    ],
    "_get_to_be_created_tensor_bindings_info": [
      "self",
      "input_values"
    ],
    "_create_tensor_bindings": [
      "self",
      "to_be_created_tensor_bindings",
      "final_packed_merge_combine"
    ]
  },
  "_update_cache_value_node_references": [
    "cache_value_nodes",
    "traverser"
  ],
  "perform_combiner_packing_optimization": [
    "saved_model_future",
    "cache_value_nodes",
    "num_phases"
  ],
  "_SINGLE_PHASE_NUM_SAVED_MODELS": [],
  "_ZERO_PHASE_NUM_SAVED_MODELS": [],
  "_make_cache_key": [
    "cache_identifier"
  ],
  "_encode_vocabulary_accumulator": [
    "token_bytes",
    "value_bytes"
  ],
  "_preprocessing_fn_for_common_optimize_traversal": [
    "inputs"
  ],
  "_OPTIMIZE_TRAVERSAL_COMMON_CASE": [],
  "_OPTIMIZE_TRAVERSAL_MULTI_PHASE_FULL_CACHE_HIT_CASE": [],
  "_TF_VERSION_NAMED_PARAMETERS": [],
  "_preprocessing_fn_for_generalized_chained_ptransforms": [
    "inputs"
  ],
  "_OPTIMIZE_TRAVERSAL_GENERALIZED_CHAINED_PTRANSFORMS_CASE": [],
  "_OPTIMIZE_TRAVERSAL_TEST_CASES": [],
  "mock_out_cache_hash": [
    "test_fn"
  ],
  "_RunPipelineResult": [],
  "CachedImplTest": {
    "setUp": [
      "self"
    ],
    "tearDown": [
      "self"
    ],
    "_get_running_index": [
      "self"
    ],
    "_publish_rendered_dot_graph_file_from_leaf_nodes": [
      "self",
      "leaf_nodes"
    ],
    "_publish_rendered_dot_graph_file": [
      "self",
      "preprocessing_fn",
      "feature_spec",
      "dataset_keys",
      "pcoll_cache_dict",
      "use_tf_compat_v1"
    ],
    "_run_pipeline": [
      "self",
      "feature_spec",
      "input_data_dict",
      "preprocessing_fn",
      "cache_dict",
      "should_read_cache",
      "datasets_to_transform",
      "expected_transform_data",
      "expected_cache",
      "transform_fn_output_dir",
      "use_tf_compat_v1"
    ],
    "test_single_phase_mixed_analyzer_run_once": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_single_phase_run_twice": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_caching_vocab_for_integer_categorical": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_non_frequency_vocabulary_merge": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_cached_ptransform_analyzer": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_optimize_traversal": [
      "self",
      "feature_spec",
      "preprocessing_fn",
      "dataset_input_cache_dicts",
      "expected_dot_graph_str",
      "expected_dot_graph_str_py312"
    ],
    "test_no_data_needed": [
      "self"
    ],
    "test_tf_function_works_with_cache": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_cache_with_missing_metadata": [
      "self"
    ],
    "test_non_cached_dataset_run_twice": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_node_count": [
      "self",
      "num_non_packed_analyzers",
      "num_packed_analyzers",
      "num_input_datasets",
      "expected_node_count_with_cache",
      "expected_node_count_without_cache"
    ],
    "test_vocab_reserved_tokens_not_cached": [
      "self",
      "use_tf_compat_v1"
    ]
  },
  "_LARGE_BATCH_SIZE": [],
  "BeamImplOutputRecordBatchesTest": {
    "_OutputRecordBatches": [
      "self"
    ],
    "_MakeTransformOutputAssertFn": [
      "self",
      "expected",
      "sort"
    ],
    "testConvertToRecordBatchPassthroughData": [
      "self"
    ],
    "testConvertToLargeRecordBatch": [
      "self",
      "passthrough_data",
      "expected_unary_features"
    ]
  },
  "DeepCopyTest": {
    "_MakeBeamPipeline": [],
    "_CountingIdentityFn": [
      "label",
      "x"
    ],
    "_MakeAdd1CountingIdentityFn": [
      "label"
    ],
    "_InitializeCounts": [],
    "setUp": [
      "self"
    ],
    "testBasicDeepCopy": [
      "self"
    ],
    "testMultipleCopies": [
      "self"
    ],
    "testFlatten": [
      "self"
    ],
    "testEachPTransformCopiedOnce": [
      "self"
    ],
    "testCombineGlobally": [
      "self"
    ],
    "testSideInputNotCopied": [
      "self"
    ],
    "testDeepCopyTags": [
      "self"
    ]
  },
  "_preprocessing_fn_with_no_analyzers": [
    "inputs"
  ],
  "_NO_ANALYZERS_CASE": [],
  "_preprocessing_fn_with_one_analyzer": [
    "inputs"
  ],
  "_ONE_ANALYZER_CASE": [],
  "_preprocessing_fn_with_table": [
    "inputs"
  ],
  "_WITH_TABLE_CASE": [],
  "_preprocessing_fn_with_two_phases": [
    "inputs"
  ],
  "_TWO_PHASES_CASE": [],
  "_preprocessing_fn_with_chained_ptransforms": [
    "inputs"
  ],
  "_CHAINED_PTRANSFORMS_CASE": [],
  "_ANALYZE_TEST_CASES": [],
  "AnalysisGraphBuilderTest": {
    "test_build": [
      "self",
      "feature_spec",
      "preprocessing_fn",
      "expected_dot_graph_str_py312",
      "expected_dot_graph_str_tf2",
      "use_tf_compat_v1"
    ],
    "test_get_analysis_dataset_keys": [
      "self",
      "preprocessing_fn",
      "full_dataset_keys",
      "cached_dataset_keys",
      "expected_dataset_keys",
      "use_tf_compat_v1"
    ],
    "test_get_analysis_cache_entry_keys": [
      "self",
      "use_tf_compat_v1"
    ],
    "test_duplicate_label_error": [
      "self"
    ]
  },
  "_COMPOSITE_COMPUTE_AND_APPLY_VOCABULARY_TEST_CASES": [],
  "VocabularyIntegrationTest": {
    "setUp": [
      "self"
    ],
    "_VocabFormat": [
      "self"
    ],
    "_WITH_LABEL_PARAMS": [],
    "testVocabulary": [
      "self",
      "x_data",
      "x_feature_spec",
      "label_data",
      "label_feature_spec",
      "weight_data",
      "weight_feature_spec",
      "expected_vocab_file_contents"
    ],
    "testApproximateVocabulary": [
      "self",
      "input_data",
      "make_feature_spec",
      "top_k",
      "make_expected_vocab_fn",
      "store_frequency",
      "reserved_tokens"
    ],
    "testComputeAndApplyApproximateVocabulary": [
      "self",
      "store_frequency",
      "reserved_tokens"
    ],
    "testEmptyComputeAndApplyApproximateVocabulary": [
      "self"
    ],
    "testJointVocabularyForMultipleFeatures": [
      "self"
    ],
    "_EMPTY_VOCABULARY_PARAMS": [],
    "testComputeAndApplyVocabulary": [
      "self",
      "x_data",
      "x_feature_spec",
      "index_data",
      "index_feature_spec",
      "index_domain",
      "label_data",
      "label_feature_spec",
      "weight_data",
      "weight_feature_spec",
      "expected_vocab_file_contents",
      "required_format"
    ],
    "testCompositeComputeAndApplyVocabulary": [
      "self",
      "input_data",
      "input_metadata",
      "expected_data",
      "expected_vocab_contents",
      "store_frequency"
    ],
    "testCreateVocabWithFrequency": [
      "self"
    ],
    "testVocabularyAnalyzerWithTokenization": [
      "self"
    ],
    "testVocabularyWithFrequency": [
      "self"
    ],
    "testVocabularyWithKeyFnAndFrequency": [
      "self"
    ],
    "testVocabularyAnnotations": [
      "self"
    ],
    "testVocabularyPreSort": [
      "self"
    ],
    "testVocabularyWithUserDefinedLookupFnFeedsSecondAnalyzer": [
      "self"
    ],
    "testVocabularyWithTableDefinedInPreprocessingFnFeedsSecondAnalyzer": [
      "self"
    ],
    "testStringOpsWithAutomaticControlDependencies": [
      "self"
    ],
    "testVocabularyOneHotEncoding": [
      "self"
    ],
    "testVocabularyReservedTokens": [
      "self"
    ]
  },
  "TFRecordVocabularyIntegrationTest": {
    "_VocabFormat": [
      "self"
    ]
  },
  "_SCALE_TO_GAUSSIAN_TEST_CASES": [],
  "TukeyHHParamsIntegrationTest": {
    "setUp": [
      "self"
    ],
    "tearDown": [
      "self"
    ],
    "testGaussianize": [
      "self",
      "input_data",
      "output_data",
      "elementwise"
    ],
    "testGaussianizeSparse": [
      "self",
      "input_dtype",
      "elementwise"
    ],
    "testGaussianizeRagged": [
      "self",
      "input_dtype"
    ],
    "testTukeyHHAnalyzersWithDenseInputs": [
      "self",
      "input_dtype",
      "output_dtypes",
      "elementwise"
    ],
    "testTukeyHHAnalyzersWithNDDenseInputs": [
      "self"
    ],
    "testTukeyHHAnalyzersWithSparseInputs": [
      "self",
      "input_dtype",
      "output_dtypes",
      "elementwise"
    ],
    "testTukeyHHAnalyzersWithRaggedInputs": [
      "self",
      "input_dtype"
    ]
  },
  "CreateTensorBinding": {
    "__slots__": []
  },
  "CreateSavedModel": {
    "__slots__": [],
    "_get_tensor_type_name": [
      "self",
      "tensor"
    ],
    "get_field_str": [
      "self",
      "field_name"
    ]
  },
  "ExtractInputForSavedModel": {
    "__slots__": []
  },
  "ApplySavedModel": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "ExtractFromDict": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "Flatten": {
    "__slots__": [],
    "is_partitionable": [
      "self"
    ]
  },
  "_preprocessing_fn_with_packable_analyzer_single_phase": [
    "inputs"
  ],
  "_PACKABLE_ANALYZER_SINGLE_PHASE_CASE": [],
  "_preprocessing_fn_with_packable_analyzer_two_phases": [
    "inputs"
  ],
  "_PACKABLE_ANALYZER_TWO_PHASES_CASE": [],
  "_COMBINER_PACKING_TEST_CASES": [],
  "CombinerPackingUtilTest": {
    "test_perform_combiner_packing_optimization": [
      "self",
      "feature_spec",
      "preprocessing_fn",
      "num_phases",
      "expected_dot_graph_str_before_packing",
      "expected_dot_graph_str_before_packing_py312",
      "expected_dot_graph_str_after_packing",
      "expected_dot_graph_str_after_packing_py312"
    ]
  },
  "_ENABLE_BEAM_TYPE_CHECKS": [],
  "_VocabTokenType": [],
  "_VocabAccumulatedIndicatorType": [],
  "_VocabIndicatorType": [],
  "_DEFAULT_COMBINE_GLOBALLY_FANOUT": [],
  "_PRESORT_BATCH_SIZE": [],
  "_BatchAndPreSort": [
    "counts",
    "sort_kwargs"
  ],
  "maybe_add_empty_vocabulary_dummy": [
    "counts",
    "dtype"
  ],
  "_count_and_token_to_bytes": [
    "count",
    "token"
  ],
  "_OrderElementsFn": {
    "__init__": [
      "self",
      "store_frequency",
      "sort_kwargs",
      "input_dtype"
    ],
    "process": [
      "self",
      "unused_element",
      "batched_counts_iter",
      "reserved_tokens"
    ]
  },
  "_ApplyThresholdsAndTopK": [
    "counts",
    "frequency_threshold",
    "top_k",
    "input_dtype",
    "info_threshold",
    "key_fn"
  ],
  "sum_labeled_weights": [
    "accs"
  ],
  "_VocabularyAccumulateImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_VocabularyCountImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "_format_count": [
      "self",
      "count"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_VocabularyMergeImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_VocabularyPruneImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_VocabularyOrderAndWriteImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_flatten_value_to_list": [
    "batch_values"
  ],
  "_flatten_value_and_weights_to_list_of_tuples": [
    "batch_values"
  ],
  "_flatten_value_and_labeled_weights_to_list_of_tuples": [
    "batch_values"
  ],
  "_make_count_and_weights_means_accumulator": [
    "sum_positive",
    "weights_sum_total",
    "count"
  ],
  "_flatten_to_key_and_means_accumulator_list": [
    "batch_values",
    "compute_weighted"
  ],
  "_clip_probability": [
    "p",
    "epsilon"
  ],
  "_calculate_mutual_information_for_feature_value": [
    "feature_and_accumulator",
    "global_accumulator",
    "use_adjusted_mutual_info",
    "min_diff_from_avg"
  ],
  "_MutualInformationTransformAccumulate": [
    "pcol",
    "compute_weighted"
  ],
  "_extract_sentinels": [
    "kv"
  ],
  "_MutualInformationTransformMerge": [
    "pcol",
    "use_adjusted_mutual_info",
    "min_diff_from_avg",
    "compute_weighted"
  ],
  "_WeightedMeanCombineFn": {
    "__init__": [
      "self",
      "output_shape",
      "compute_weighted"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "batch_values"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ]
  },
  "_CombinerWrapper": {
    "__init__": [
      "self",
      "combiner",
      "is_combining_accumulators"
    ],
    "create_accumulator": [
      "self"
    ],
    "add_input": [
      "self",
      "accumulator",
      "next_input"
    ],
    "merge_accumulators": [
      "self",
      "accumulators"
    ],
    "compact": [
      "self",
      "accumulator"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ]
  },
  "_PackedCombinerWrapper": {
    "__init__": [
      "self",
      "combiner_ops",
      "is_combining_accumulators"
    ],
    "add_input": [
      "self",
      "accumulator",
      "element"
    ],
    "extract_output": [
      "self",
      "accumulator"
    ]
  },
  "_split_inputs_by_key": [
    "batch_values"
  ],
  "_merge_outputs_by_key": [
    "keys_and_outputs",
    "outputs_dtype"
  ],
  "_make_strictly_increasing_boundaries_rows": [
    "boundary_matrix"
  ],
  "_join_boundary_rows": [
    "boundary_matrix"
  ],
  "_ScaleAndFlattenPerKeyBucketBouandariesImpl": {
    "_OUTPUT_TAGS": [],
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "_transform_boundaries": [
      "self",
      "boundary_matrix"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_InitialAccumulatePackedCombineImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_MergeAccumulatorsPackedCombineImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_InitialAccumulateCombineImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_MergeAccumulatorsCombineImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_InitialAccumulateCombinePerKeyImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_MergeAccumulatorsCombinePerKeyImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_CombinePerKeyFormatKeysImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_CombinePerKeyFormatLargeImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_PTransformImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_EncodeCacheImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_InstrumentDatasetCacheImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "_make_and_increment_counter": [
      "self",
      "value",
      "name"
    ],
    "expand": [
      "self",
      "pbegin"
    ]
  },
  "_DecodeCacheImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "pbegin"
    ]
  },
  "_AddKeyImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_FlattenListsItemType": [],
  "_FlattenListsImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_ExtractOutputImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "inputs"
    ]
  },
  "_ExtractVocabularyReservedTokensImpl": {
    "__init__": [
      "self",
      "operation",
      "extra_args"
    ],
    "expand": [
      "self",
      "pbegin"
    ]
  },
  "_CACHE_VERSION_NUMBER": [],
  "_PYTHON_VERSION": [],
  "_CACHE_VERSION": [],
  "_METADATA_FILE_NAME": [],
  "_CACHE_COMPONENT_CHARACTER_REPLACEMENTS": [],
  "_make_valid_cache_component": [
    "name"
  ],
  "DatasetKey": {
    "__slots__": [],
    "_FLATTENED_DATASET_KEY": [],
    "non_cacheable": [
      "self"
    ],
    "__new__": [
      "cls",
      "dataset_key",
      "is_cached"
    ],
    "__str__": [
      "self"
    ],
    "is_flattened_dataset_key": [
      "self"
    ]
  },
  "_make_flattened_dataset_key": [],
  "_get_dataset_cache_path": [
    "base_dir",
    "dataset_key"
  ],
  "DatasetCacheMetadata": {
    "__slots__": [],
    "encode": [
      "self"
    ],
    "decode": [
      "cls",
      "value"
    ]
  },
  "DatasetCache": {
    "__slots__": [],
    "get": [
      "self",
      "key"
    ],
    "values": [
      "self"
    ],
    "keys": [
      "self"
    ],
    "items": [
      "self"
    ]
  },
  "BeamAnalysisCache": [],
  "_ManifestFile": {
    "_MANIFEST_FILE_NAME": [],
    "__init__": [
      "self",
      "base_path"
    ],
    "_open": [
      "self"
    ],
    "_close": [
      "self"
    ],
    "_delete": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ],
    "_get_manifest_contents": [
      "self",
      "manifest_file_handle"
    ],
    "read": [
      "self"
    ],
    "write": [
      "self",
      "manifest"
    ]
  },
  "_WriteToTFRecordGzip": {
    "__init__": [
      "self",
      "file_path_prefix"
    ]
  },
  "_WriteMetadata": {
    "__init__": [
      "self",
      "dataset_key_dir"
    ],
    "expand": [
      "self",
      "metadata"
    ]
  },
  "_ReadMetadata": {
    "__init__": [
      "self",
      "dataset_key_dir"
    ],
    "expand": [
      "self",
      "pipeline"
    ]
  },
  "WriteAnalysisCacheToFS": {
    "__init__": [
      "self",
      "pipeline",
      "cache_base_dir",
      "dataset_keys",
      "sink"
    ],
    "_extract_input_pvalues": [
      "self",
      "dataset_cache_dict"
    ],
    "_write_cache": [
      "self",
      "manifest_file",
      "dataset_key_index",
      "dataset_key_dir",
      "cache"
    ],
    "expand": [
      "self",
      "dataset_cache_dict"
    ]
  },
  "ReadAnalysisCacheFromFS": {
    "__init__": [
      "self",
      "cache_base_dir",
      "dataset_keys",
      "cache_entry_keys",
      "source"
    ],
    "_should_read_cache_entry_key": [
      "self",
      "key"
    ],
    "expand": [
      "self",
      "pipeline"
    ]
  },
  "validate_dataset_keys": [
    "dataset_keys"
  ],
  "make_cache_entry_key": [
    "cache_key"
  ],
  "ContextTest": {
    "testNestedContextCreateBaseTempDir": [
      "self"
    ]
  },
  "_construct_test_bucketization_tight_sequence_parameters": [],
  "_construct_test_bucketization_parameters": [],
  "_SIMPLE_PER_KEY_BUCKETS": [],
  "_WEIGHTED_PER_KEY_0_RANGE": [],
  "_WEIGHTED_PER_KEY_BUCKETS": [],
  "_compute_simple_per_key_bucket": [
    "val",
    "key",
    "weighted"
  ],
  "_BUCKETIZE_COMPOSITE_INPUT_TEST_CASES": [],
  "_BUCKETIZE_PER_KEY_TEST_CASES": [],
  "BucketizeIntegrationTest": {
    "setUp": [
      "self"
    ],
    "tearDown": [
      "self"
    ],
    "testBucketization": [
      "self",
      "test_inputs",
      "expected_boundaries",
      "do_shuffle",
      "epsilon",
      "should_apply",
      "is_manual_boundaries",
      "input_dtype"
    ],
    "testBucketizationElementwise": [
      "self",
      "test_inputs",
      "expected_boundaries",
      "do_shuffle",
      "epsilon",
      "should_apply",
      "is_manual_boundaries",
      "input_dtype"
    ],
    "testBucketizeCompositeInput": [
      "self",
      "input_data",
      "input_metadata",
      "expected_data"
    ],
    "testQuantileBucketsWithWeights": [
      "self",
      "input_dtype",
      "with_nans"
    ],
    "testElementwiseQuantileBucketsWithWeights": [
      "self",
      "input_dtype"
    ],
    "testQuantileBuckets": [
      "self",
      "input_dtype"
    ],
    "testQuantilesPerKey": [
      "self"
    ],
    "testBucketizePerKey": [
      "self",
      "input_data",
      "input_metadata",
      "expected_data",
      "expected_metadata"
    ],
    "testBucketizePerKeyWithInfrequentKeys": [
      "self"
    ],
    "_assert_quantile_boundaries": [
      "self",
      "test_inputs",
      "expected_boundaries",
      "input_dtype",
      "num_buckets",
      "num_expected_buckets"
    ],
    "testBucketizationForTightSequence": [
      "self",
      "test_inputs",
      "expected_boundaries",
      "dtype",
      "num_buckets",
      "num_expected_buckets"
    ],
    "testBucketizationEqualDistributionInSequence": [
      "self"
    ],
    "testBucketizationEqualDistributionInterleaved": [
      "self"
    ],
    "testBucketizationSpecificDistribution": [
      "self"
    ]
  },
  "canonical_numeric_dtype": [
    "dtype"
  ],
  "make_feature_spec_wrapper": [
    "make_feature_spec"
  ],
  "_format_example_as_numpy_dict": [
    "example",
    "feature_shape_dict"
  ],
  "_encode_transformed_data_batch": [
    "data",
    "coder"
  ],
  "make_test_beam_pipeline_kwargs": [],
  "BeamMetadataIoTest": {
    "testWriteMetadataNonDeferred": [
      "self"
    ],
    "testWriteMetadataDeferred": [
      "self"
    ],
    "testWriteMetadataIsRetryable": [
      "self"
    ]
  },
  "COMPLETE_METADATA": [],
  "INCOMPLETE_METADATA": [],
  "TRANSFORMED_METADATA_DIR": [],
  "TRANSFORM_FN_DIR": [],
  "_copy_tree_to_unique_temp_dir": [
    "source",
    "base_temp_dir_path"
  ],
  "_copy_tree": [
    "source",
    "destination"
  ],
  "WriteTransformFn": {
    "__init__": [
      "self",
      "path"
    ],
    "_extract_input_pvalues": [
      "self",
      "transform_fn"
    ],
    "expand": [
      "self",
      "transform_fn"
    ]
  },
  "ReadTransformFn": {
    "__init__": [
      "self",
      "path"
    ],
    "expand": [
      "self",
      "pvalue"
    ]
  },
  "_COPY_TREE_TO_UNIQUE_TEMP_DIR_CALLED": [],
  "TransformFnIoTest": {
    "testReadTransformFn": [
      "self"
    ],
    "testWriteTransformFn": [
      "self"
    ],
    "testWriteTransformFnIsIdempotent": [
      "self"
    ],
    "testWriteTransformFnIsRetryable": [
      "self"
    ]
  },
  "BeamDatasetMetadata": {
    "schema": [
      "self"
    ]
  },
  "WriteMetadata": {
    "__init__": [
      "self",
      "path",
      "pipeline",
      "write_to_unique_subdirectory"
    ],
    "_extract_input_pvalues": [
      "self",
      "metadata"
    ],
    "expand": [
      "self",
      "metadata"
    ]
  },
  "PTransformAnalyzer": {
    "__init__": [
      "self"
    ],
    "base_temp_dir": [
      "self",
      "val"
    ]
  },
  "_make_cast_fn": [
    "np_dtype"
  ],
  "_make_feature_value_fn": [
    "dtype"
  ],
  "_FixedLenFeatureHandler": {
    "__init__": [
      "self",
      "name",
      "feature_spec"
    ],
    "name": [
      "self"
    ],
    "initialize_encode_cache": [
      "self",
      "example"
    ],
    "encode_value": [
      "self",
      "values"
    ]
  },
  "_VarLenFeatureHandler": {
    "__init__": [
      "self",
      "name",
      "dtype"
    ],
    "name": [
      "self"
    ],
    "initialize_encode_cache": [
      "self",
      "example"
    ],
    "encode_value": [
      "self",
      "values"
    ]
  },
  "ExampleProtoCoder": {
    "__init__": [
      "self",
      "schema",
      "serialized"
    ],
    "__reduce__": [
      "self"
    ],
    "encode": [
      "self",
      "instance"
    ]
  },
  "_ENCODE_CASES": [],
  "_ENCODE_ERROR_CASES": [],
  "_maybe_extend_encode_case_with_ragged": [
    "encode_case"
  ],
  "_maybe_extend_encode_cases_with_ragged": [
    "encode_cases"
  ],
  "_ascii_to_example": [
    "ascii_proto"
  ],
  "_ascii_to_binary": [
    "ascii_proto"
  ],
  "_binary_to_example": [
    "serialized_proto"
  ],
  "ExampleProtoCoderTest": {
    "setUp": [
      "self"
    ],
    "assertSerializedProtosEqual": [
      "self",
      "a",
      "b"
    ],
    "test_encode": [
      "self",
      "feature_spec",
      "ascii_proto",
      "instance"
    ],
    "test_encode_non_serialized": [
      "self",
      "feature_spec",
      "ascii_proto",
      "instance"
    ],
    "test_encode_error": [
      "self",
      "feature_spec",
      "instance",
      "error_msg",
      "error_type"
    ],
    "test_example_proto_coder_picklable": [
      "self"
    ],
    "test_example_proto_coder_cache": [
      "self"
    ]
  },
  "_COLUMNS": [],
  "_CONSTRUCTOR_ERROR_CASES": [],
  "TestCSVCoder": {
    "test_encode": [
      "self",
      "columns",
      "feature_spec",
      "csv_line",
      "instance"
    ],
    "test_constructor_error": [
      "self",
      "columns",
      "feature_spec",
      "error_msg",
      "error_type"
    ],
    "test_encode_error": [
      "self",
      "columns",
      "feature_spec",
      "instance",
      "error_msg",
      "error_type"
    ],
    "test_picklable": [
      "self"
    ]
  },
  "CsvCoder": {
    "__init__": [
      "self",
      "column_names",
      "schema",
      "delimiter",
      "secondary_delimiter",
      "multivalent_columns"
    ],
    "__reduce__": [
      "self"
    ],
    "encode": [
      "self",
      "instance"
    ]
  },
  "read_metadata": [
    "path"
  ],
  "_parse_schema_json": [
    "schema_json"
  ],
  "_column_schema_from_json": [
    "feature_dict"
  ],
  "_domain_from_json": [
    "domain"
  ],
  "_dtype_from_json": [
    "domain"
  ],
  "write_metadata": [
    "metadata",
    "path"
  ],
  "_convert_scalar_or_list": [
    "fn",
    "scalar_or_list"
  ],
  "_SCHEMA_WITH_INVALID_KEYS": [],
  "SchemaIOv1JsonTest": {
    "_write_schema_to_disk": [
      "self",
      "basedir",
      "schema_string"
    ],
    "test_read_with_invalid_keys": [
      "self"
    ],
    "test_read_features_default_axis": [
      "self"
    ],
    "test_read_features": [
      "self"
    ],
    "test_write_and_read": [
      "self"
    ]
  },
  "test_feature_spec": [],
  "get_test_schema": [],
  "SchemaUtilsTest": {
    "test_schema_from_feature_spec": [
      "self",
      "ascii_proto",
      "feature_spec",
      "domains",
      "generate_legacy_feature_spec"
    ],
    "test_schema_as_feature_spec": [
      "self",
      "ascii_proto",
      "feature_spec",
      "domains",
      "generate_legacy_feature_spec"
    ],
    "test_schema_as_feature_spec_fails": [
      "self",
      "ascii_proto",
      "error_msg",
      "error_class",
      "generate_legacy_feature_spec"
    ],
    "test_schema_from_feature_spec_fails": [
      "self",
      "feature_spec",
      "error_msg",
      "domain",
      "error_class"
    ],
    "test_pop_ragged_source_columns": [
      "self",
      "name",
      "tensor_representation",
      "feature_by_name",
      "expected_value_feature",
      "truncated_feature_by_name"
    ]
  },
  "should_set_generate_legacy_feature_spec": [
    "feature_spec"
  ],
  "set_generate_legacy_feature_spec": [
    "schema_proto",
    "value"
  ],
  "_DatasetMetadataType": [],
  "DatasetMetadata": {
    "__init__": [
      "self",
      "schema"
    ],
    "from_feature_spec": [
      "cls",
      "feature_spec",
      "domains"
    ],
    "schema": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "EQUIVALENT_FEATURE_SPEC_AND_SCHEMAS": [],
  "NON_ROUNDTRIP_SCHEMAS": [],
  "INVALID_SCHEMA_PROTOS": [],
  "INVALID_FEATURE_SPECS": [],
  "_FEATURE_BY_NAME": [],
  "RAGGED_VALUE_FEATURES_AND_TENSOR_REPRESENTATIONS": [],
  "DatasetSchemaTest": {
    "test_sanity": [
      "self"
    ]
  },
  "TENSOR_REPRESENTATION_GROUP": [],
  "schema_from_feature_spec": [
    "feature_spec",
    "domains"
  ],
  "_ragged_tensor_representation_from_feature_spec": [
    "spec",
    "name",
    "domains"
  ],
  "_sparse_feature_from_feature_spec": [
    "spec",
    "name",
    "domains"
  ],
  "_feature_from_feature_spec": [
    "spec",
    "name",
    "domains"
  ],
  "_set_type": [
    "name",
    "feature",
    "dtype"
  ],
  "_set_domain": [
    "name",
    "feature",
    "domain"
  ],
  "SchemaAsFeatureSpecResult": {
    "__iter__": [
      "self"
    ]
  },
  "_standardize_default_value": [
    "spec"
  ],
  "schema_as_feature_spec": [
    "schema_proto"
  ],
  "_sequence_schema_as_feature_spec": [
    "schema"
  ],
  "_get_source_feature_domains": [
    "schema_or_domain",
    "string_domains"
  ],
  "_get_string_domains": [
    "schema"
  ],
  "_get_domain": [
    "feature",
    "string_domains"
  ],
  "pop_ragged_source_columns": [
    "name",
    "tensor_representation",
    "feature_by_name"
  ],
  "_ragged_tensor_representation_as_feature_spec": [
    "name",
    "tensor_representation",
    "feature_by_name",
    "string_domains"
  ],
  "_legacy_schema_from_feature_spec": [
    "feature_spec",
    "domains"
  ]
}