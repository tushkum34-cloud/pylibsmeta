{
  "_default_global_config": [],
  "_threadlocal": [],
  "_get_onedal_threadlocal_config": [],
  "_get_config": [
    "copy"
  ],
  "_is_spmd_backend": [],
  "__all__": [],
  "DummySyclQueue": {
    "__init__": [
      "self",
      "filter_string"
    ]
  },
  "_copy_to_usm": [
    "queue",
    "array"
  ],
  "_transfer_to_host": [
    "queue"
  ],
  "_get_global_queue": [],
  "_get_host_inputs": [],
  "_extract_usm_iface": [],
  "_run_on_device": [
    "func",
    "obj"
  ],
  "support_usm_ndarray": [
    "freefunc",
    "queue_param"
  ],
  "SVMtype": {
    "c_svc": [],
    "epsilon_svr": [],
    "nu_svc": [],
    "nu_svr": []
  },
  "BaseSVM": {
    "__init__": [
      "self",
      "C",
      "nu",
      "epsilon",
      "kernel"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "_get_onedal_params": [
      "self",
      "data"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "module",
      "queue"
    ],
    "_create_model": [
      "self",
      "module"
    ],
    "_predict": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_ovr_decision_function": [
      "self",
      "predictions",
      "confidences",
      "n_classes"
    ],
    "_decision_function": [
      "self",
      "X",
      "module",
      "queue"
    ]
  },
  "SVR": {
    "__init__": [
      "self",
      "C",
      "epsilon",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "SVC": {
    "__init__": [
      "self",
      "C",
      "kernel"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "decision_function": [
      "self",
      "X",
      "queue"
    ]
  },
  "NuSVR": {
    "__init__": [
      "self",
      "nu",
      "C",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "NuSVC": {
    "__init__": [
      "self",
      "nu",
      "kernel"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "decision_function": [
      "self",
      "X",
      "queue"
    ]
  },
  "_test_libsvm_parameters": [
    "queue",
    "array_constr",
    "dtype"
  ],
  "test_libsvm_parameters": [
    "queue",
    "array_constr",
    "dtype"
  ],
  "test_class_weight": [
    "queue"
  ],
  "test_sample_weight": [
    "queue"
  ],
  "test_decision_function": [
    "queue"
  ],
  "test_iris": [
    "queue"
  ],
  "test_decision_function_shape": [
    "queue"
  ],
  "test_pickle": [
    "queue"
  ],
  "test_svc_sigmoid": [
    "queue",
    "dtype"
  ],
  "synth_params": [],
  "test_run_to_run_fit": [
    "queue"
  ],
  "test_diabetes_simple": [
    "queue"
  ],
  "test_input_format_for_diabetes": [
    "queue"
  ],
  "test_predict": [
    "queue"
  ],
  "_test_diabetes_compare_with_sklearn": [
    "queue",
    "kernel"
  ],
  "test_diabetes_compare_with_sklearn": [
    "queue",
    "kernel"
  ],
  "_test_synth_rbf_compare_with_sklearn": [
    "queue",
    "C",
    "gamma"
  ],
  "test_synth_rbf_compare_with_sklearn": [
    "queue",
    "C",
    "gamma"
  ],
  "_test_synth_linear_compare_with_sklearn": [
    "queue",
    "C"
  ],
  "test_synth_linear_compare_with_sklearn": [
    "queue",
    "C"
  ],
  "_test_synth_poly_compare_with_sklearn": [
    "queue",
    "params"
  ],
  "test_synth_poly_compare_with_sklearn": [
    "queue",
    "params"
  ],
  "test_sided_sample_weight": [
    "queue"
  ],
  "check_svm_model_equal": [
    "queue",
    "dense_svm",
    "sparse_svm",
    "X_train",
    "y_train",
    "X_test",
    "decimal"
  ],
  "_test_simple_dataset": [
    "queue",
    "kernel"
  ],
  "test_simple_dataset": [
    "queue",
    "kernel"
  ],
  "_test_binary_dataset": [
    "queue",
    "kernel"
  ],
  "test_binary_dataset": [
    "queue",
    "kernel"
  ],
  "_test_iris": [
    "queue",
    "kernel"
  ],
  "_test_diabetes": [
    "queue",
    "kernel"
  ],
  "test_diabetes": [
    "queue",
    "kernel"
  ],
  "test_sparse_realdata": [
    "queue"
  ],
  "_test_cancer_rbf_compare_with_sklearn": [
    "queue",
    "nu",
    "gamma"
  ],
  "test_cancer_rbf_compare_with_sklearn": [
    "queue",
    "nu",
    "gamma"
  ],
  "_test_cancer_linear_compare_with_sklearn": [
    "queue",
    "nu"
  ],
  "test_cancer_linear_compare_with_sklearn": [
    "queue",
    "nu"
  ],
  "_test_cancer_poly_compare_with_sklearn": [
    "queue",
    "params"
  ],
  "test_cancer_poly_compare_with_sklearn": [
    "queue",
    "params"
  ],
  "_get_policy": [
    "queue"
  ],
  "_get_queue": [],
  "_HostInteropPolicy": {
    "__init__": [
      "self"
    ]
  },
  "_get_backend": [
    "backend",
    "module",
    "submodule",
    "method"
  ],
  "BaseEstimator": {
    "_get_backend": [
      "self",
      "module",
      "submodule",
      "method"
    ],
    "_get_policy": [
      "self",
      "queue"
    ]
  },
  "_check_is_fitted": [
    "estimator",
    "attributes"
  ],
  "_is_classifier": [
    "estimator"
  ],
  "_is_regressor": [
    "estimator"
  ],
  "ClusterMixin": {
    "_estimator_type": [],
    "fit_predict": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "_more_tags": [
      "self"
    ]
  },
  "ClassifierMixin": {
    "_estimator_type": [],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "_more_tags": [
      "self"
    ]
  },
  "RegressorMixin": {
    "_estimator_type": [],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "_more_tags": [
      "self"
    ]
  },
  "TransformerMixin": {
    "_estimator_type": [],
    "fit_transform": [
      "self",
      "X",
      "y",
      "queue"
    ]
  },
  "test_queue_passed_directly": [
    "queue"
  ],
  "test_with_numpy_data": [
    "queue"
  ],
  "test_with_usm_ndarray_data": [
    "queue",
    "memtype"
  ],
  "test_queue_parameter_with_usm_ndarray": [
    "memtype"
  ],
  "BaseEstimatorSPMD": {
    "_get_backend": [
      "self",
      "module",
      "submodule",
      "method"
    ],
    "_get_policy": [
      "self",
      "queue"
    ]
  },
  "LogisticRegression": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "predict_proba": [
      "self",
      "X",
      "queue"
    ],
    "predict_log_proba": [
      "self",
      "X",
      "queue"
    ]
  },
  "LinearRegression": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "BasicStatistics": {
    "compute": [
      "self",
      "data",
      "weights",
      "queue"
    ],
    "fit": [
      "self",
      "data",
      "sample_weight",
      "queue"
    ]
  },
  "PCA": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ]
  },
  "RandomForestClassifier": {},
  "RandomForestRegressor": {},
  "KNeighborsClassifier": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "predict_proba": [
      "self",
      "X",
      "queue"
    ],
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance",
      "queue"
    ]
  },
  "KNeighborsRegressor": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "_get_onedal_params": [
      "self",
      "X",
      "y"
    ]
  },
  "NearestNeighbors": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance",
      "queue"
    ]
  },
  "KMeansInit": {},
  "KMeans": {
    "_get_basic_statistics_backend": [
      "self",
      "result_options"
    ],
    "_get_kmeans_init": [
      "self",
      "cluster_count",
      "seed",
      "algorithm"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "queue"
    ]
  },
  "DBSCAN": {},
  "EmpiricalCovariance": {
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ]
  },
  "BaseLogisticRegression": {
    "__init__": [
      "self",
      "tol",
      "C",
      "fit_intercept",
      "solver",
      "max_iter",
      "algorithm"
    ],
    "_get_onedal_params": [
      "self",
      "is_csr",
      "dtype"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "module",
      "queue"
    ],
    "_create_model": [
      "self",
      "module",
      "policy"
    ],
    "_infer": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_predict": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_predict_proba": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_predict_log_proba": [
      "self",
      "X",
      "module",
      "queue"
    ]
  },
  "IncrementalLinearRegression": {
    "__init__": [
      "self",
      "fit_intercept",
      "copy_X",
      "algorithm"
    ],
    "_reset": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "finalize_fit": [
      "self",
      "queue"
    ]
  },
  "BaseLinearRegression": {
    "__init__": [
      "self",
      "fit_intercept",
      "copy_X",
      "algorithm",
      "alpha"
    ],
    "_get_onedal_params": [
      "self",
      "dtype"
    ],
    "_create_model": [
      "self",
      "policy"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "Ridge": {
    "__init__": [
      "self",
      "alpha",
      "fit_intercept",
      "copy_X"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "queue"
    ]
  },
  "test_full_results": [
    "queue",
    "num_blocks",
    "dtype"
  ],
  "test_no_intercept_results": [
    "queue",
    "num_blocks",
    "dtype"
  ],
  "test_reconstruct_model": [
    "queue",
    "dtype"
  ],
  "test_sklearn_check_version_ban": [],
  "get_queues": [
    "filter_"
  ],
  "get_memory_usm": [],
  "is_dpctl_available": [
    "targets"
  ],
  "device_type_to_str": [
    "queue"
  ],
  "pass_if_not_implemented_for_gpu": [
    "reason"
  ],
  "get_dataframes_and_queues": [
    "dataframe_filter_",
    "device_filter_"
  ],
  "_as_numpy": [
    "obj"
  ],
  "_convert_to_dataframe": [
    "obj",
    "sycl_queue",
    "target_df"
  ],
  "_apply_and_pass": [
    "func"
  ],
  "from_table": [],
  "convert_one_to_table": [
    "arg"
  ],
  "to_table": [],
  "_test_input_format_c_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "test_input_format_c_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "_test_input_format_f_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "test_input_format_f_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "_test_input_format_c_not_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "test_input_format_c_not_contiguous_numpy": [
    "queue",
    "dtype"
  ],
  "_test_input_format_c_contiguous_pandas": [
    "queue",
    "dtype"
  ],
  "test_input_format_c_contiguous_pandas": [
    "queue",
    "dtype"
  ],
  "_test_input_format_f_contiguous_pandas": [
    "queue",
    "dtype"
  ],
  "test_input_format_f_contiguous_pandas": [
    "queue",
    "dtype"
  ],
  "_test_conversion_to_table": [
    "dtype"
  ],
  "test_conversion_to_table": [
    "dtype"
  ],
  "test_input_format_c_contiguous_dpctl": [
    "queue",
    "dtype"
  ],
  "test_input_format_f_contiguous_dpctl": [
    "queue",
    "dtype"
  ],
  "DataConversionWarning": {},
  "_is_arraylike": [
    "x"
  ],
  "_is_arraylike_not_scalar": [
    "array"
  ],
  "_column_or_1d": [
    "y",
    "warn"
  ],
  "_compute_class_weight": [
    "class_weight",
    "classes",
    "y"
  ],
  "_validate_targets": [
    "y",
    "class_weight",
    "dtype"
  ],
  "_check_array": [
    "array",
    "dtype",
    "accept_sparse",
    "order",
    "copy",
    "force_all_finite",
    "ensure_2d",
    "accept_large_sparse"
  ],
  "_check_X_y": [
    "X",
    "y",
    "dtype",
    "accept_sparse",
    "order",
    "copy",
    "force_all_finite",
    "ensure_2d",
    "accept_large_sparse",
    "y_numeric",
    "accept_2d_y"
  ],
  "_check_classification_targets": [
    "y"
  ],
  "_type_of_target": [
    "y"
  ],
  "_is_integral_float": [
    "y"
  ],
  "_is_multilabel": [
    "y"
  ],
  "_check_n_features": [
    "self",
    "X",
    "reset"
  ],
  "_num_features": [
    "X",
    "fallback_1d"
  ],
  "_num_samples": [
    "x"
  ],
  "_is_csr": [
    "x"
  ],
  "get_tree_state_cls": [
    "model",
    "iTree",
    "n_classes"
  ],
  "get_tree_state_reg": [
    "model",
    "iTree",
    "n_classes"
  ],
  "_check_inputs": [
    "X",
    "Y"
  ],
  "_compute_kernel": [
    "params",
    "submodule",
    "X",
    "Y",
    "queue"
  ],
  "linear_kernel": [
    "X",
    "Y",
    "scale",
    "shift",
    "queue"
  ],
  "rbf_kernel": [
    "X",
    "Y",
    "gamma",
    "queue"
  ],
  "poly_kernel": [
    "X",
    "Y",
    "gamma",
    "coef0",
    "degree",
    "queue"
  ],
  "sigmoid_kernel": [
    "X",
    "Y",
    "gamma",
    "coef0",
    "queue"
  ],
  "test_dense_self_linear_kernel": [
    "queue"
  ],
  "_test_dense_small_linear_kernel": [
    "queue",
    "scale",
    "shift",
    "dtype"
  ],
  "test_dense_small_linear_kernel": [
    "queue",
    "scale",
    "shift",
    "dtype"
  ],
  "test_dense_self_rbf_kernel": [
    "queue"
  ],
  "_test_dense_small_rbf_kernel": [
    "queue",
    "gamma",
    "dtype"
  ],
  "test_dense_small_rbf_kernel": [
    "queue",
    "gamma",
    "dtype"
  ],
  "test_dense_self_poly_kernel": [
    "queue"
  ],
  "_test_dense_small_poly_kernel": [
    "queue",
    "gamma",
    "coef0",
    "degree",
    "dtype"
  ],
  "test_dense_small_poly_kernel": [
    "queue",
    "gamma",
    "coef0",
    "degree",
    "dtype"
  ],
  "test_dense_self_sigmoid_kernel": [
    "queue"
  ],
  "_test_dense_small_sigmoid_kernel": [
    "queue",
    "gamma",
    "coef0",
    "dtype"
  ],
  "test_dense_small_sigmoid_kernel": [
    "queue",
    "gamma",
    "coef0",
    "dtype"
  ],
  "IncrementalBasicStatistics": {
    "__init__": [
      "self",
      "result_options"
    ],
    "_reset": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "weights",
      "queue"
    ],
    "finalize_fit": [
      "self",
      "queue"
    ]
  },
  "BaseBasicStatistics": {
    "__init__": [
      "self",
      "result_options",
      "algorithm"
    ],
    "get_all_result_options": [],
    "_get_result_options": [
      "self",
      "options"
    ],
    "_get_onedal_params": [
      "self",
      "is_csr",
      "dtype"
    ]
  },
  "expected_sum": [
    "X"
  ],
  "expected_max": [
    "X"
  ],
  "expected_min": [
    "X"
  ],
  "expected_mean": [
    "X"
  ],
  "expected_standard_deviation": [
    "X"
  ],
  "expected_variance": [
    "X"
  ],
  "expected_variation": [
    "X"
  ],
  "expected_sum_squares": [
    "X"
  ],
  "expected_sum_squares_centered": [
    "X"
  ],
  "expected_second_order_raw_moment": [
    "X"
  ],
  "options_and_tests": [],
  "options_and_tests_csr": [],
  "test_single_option_on_random_data": [
    "queue",
    "option",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_multiple_options_on_random_data": [
    "queue",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_all_option_on_random_data": [
    "queue",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_1d_input_on_random_data": [
    "queue",
    "option",
    "data_size",
    "weighted",
    "dtype"
  ],
  "test_basic_csr": [
    "queue",
    "dtype"
  ],
  "test_options_csr": [
    "queue",
    "option",
    "dtype"
  ],
  "test_warning": [],
  "test_multiple_options_on_gold_data": [
    "queue",
    "weighted",
    "dtype"
  ],
  "BasePCA": {
    "__init__": [
      "self",
      "n_components",
      "is_deterministic",
      "method",
      "whiten"
    ],
    "_get_onedal_params": [
      "self",
      "data",
      "stage"
    ],
    "_validate_n_components": [
      "self",
      "n_components",
      "n_samples",
      "n_features"
    ],
    "_resolve_n_components_for_training": [
      "self",
      "shape_tuple"
    ],
    "_resolve_n_components_for_result": [
      "self",
      "shape_tuple"
    ],
    "_compute_noise_variance": [
      "self",
      "n_components",
      "n_sf_min"
    ],
    "_create_model": [
      "self"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "IncrementalPCA": {
    "__init__": [
      "self",
      "n_components",
      "is_deterministic",
      "method",
      "whiten"
    ],
    "_reset": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "queue"
    ],
    "finalize_fit": [
      "self",
      "queue"
    ]
  },
  "test_on_gold_data": [
    "queue",
    "is_deterministic",
    "whiten",
    "num_blocks",
    "dtype"
  ],
  "test_on_random_data": [
    "queue",
    "n_components",
    "whiten",
    "num_blocks",
    "row_count",
    "column_count",
    "dtype"
  ],
  "BaseForest": {
    "__init__": [
      "self",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "min_impurity_split",
      "bootstrap",
      "oob_score",
      "random_state",
      "warm_start",
      "class_weight",
      "ccp_alpha",
      "max_samples",
      "max_bins",
      "min_bin_size",
      "infer_mode",
      "splitter_mode",
      "voting_mode",
      "error_metric_mode",
      "variable_importance_mode",
      "algorithm"
    ],
    "_to_absolute_max_features": [
      "self",
      "n_features"
    ],
    "_get_observations_per_tree_fraction": [
      "self",
      "n_samples",
      "max_samples"
    ],
    "_get_onedal_params": [
      "self",
      "data"
    ],
    "_check_parameters": [
      "self"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "_get_sample_weight": [
      "self",
      "sample_weight",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "module",
      "queue"
    ],
    "_create_model": [
      "self",
      "module"
    ],
    "_predict": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_predict_proba": [
      "self",
      "X",
      "module",
      "queue"
    ]
  },
  "ExtraTreesClassifier": {
    "__init__": [
      "self",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "min_impurity_split",
      "bootstrap",
      "oob_score",
      "random_state",
      "warm_start",
      "class_weight",
      "ccp_alpha",
      "max_samples",
      "max_bins",
      "min_bin_size",
      "infer_mode",
      "splitter_mode",
      "voting_mode",
      "error_metric_mode",
      "variable_importance_mode",
      "algorithm"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ],
    "predict_proba": [
      "self",
      "X",
      "queue"
    ]
  },
  "ExtraTreesRegressor": {
    "__init__": [
      "self",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "min_impurity_split",
      "bootstrap",
      "oob_score",
      "random_state",
      "warm_start",
      "class_weight",
      "ccp_alpha",
      "max_samples",
      "max_bins",
      "min_bin_size",
      "infer_mode",
      "splitter_mode",
      "voting_mode",
      "error_metric_mode",
      "variable_importance_mode",
      "algorithm"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "predict": [
      "self",
      "X",
      "queue"
    ]
  },
  "test_rf_classifier": [
    "queue"
  ],
  "test_rf_regression": [
    "queue"
  ],
  "test_rf_classifier_random_splitter": [
    "queue"
  ],
  "test_rf_regression_random_splitter": [
    "queue"
  ],
  "NeighborsCommonBase": {
    "_parse_auto_method": [
      "self",
      "method",
      "n_samples",
      "n_features"
    ],
    "_validate_data": [
      "self",
      "X",
      "y",
      "reset",
      "validate_separately"
    ],
    "_get_weights": [
      "self",
      "dist",
      "weights"
    ],
    "_get_onedal_params": [
      "self",
      "X",
      "y",
      "n_neighbors"
    ],
    "_get_daal_params": [
      "self",
      "data",
      "n_neighbors"
    ]
  },
  "NeighborsBase": {
    "__init__": [
      "self",
      "n_neighbors",
      "radius",
      "algorithm",
      "metric",
      "p",
      "metric_params"
    ],
    "_validate_targets": [
      "self",
      "y",
      "dtype"
    ],
    "_validate_n_classes": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "_kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance",
      "queue"
    ]
  },
  "_BaseKMeans": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_validate_center_shape": [
      "self",
      "X",
      "centers"
    ],
    "_get_kmeans_init": [
      "self",
      "cluster_count",
      "seed",
      "algorithm"
    ],
    "_get_basic_statistics_backend": [
      "self",
      "result_options"
    ],
    "_tolerance": [
      "self",
      "rtol",
      "X_table",
      "policy",
      "dtype"
    ],
    "_check_params_vs_input": [
      "self",
      "X_table",
      "policy",
      "default_n_init",
      "dtype"
    ],
    "_get_onedal_params": [
      "self",
      "dtype"
    ],
    "_get_params_and_input": [
      "self",
      "X",
      "policy"
    ],
    "_init_centroids_custom": [
      "self",
      "X_table",
      "init",
      "random_seed",
      "policy",
      "dtype",
      "n_centroids"
    ],
    "_init_centroids_generic": [
      "self",
      "X",
      "init",
      "random_state",
      "policy",
      "dtype"
    ],
    "_fit_backend": [
      "self",
      "X_table",
      "centroids_table",
      "module",
      "policy",
      "dtype"
    ],
    "_fit": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_get_cluster_centers": [
      "self"
    ],
    "_set_cluster_centers": [
      "self",
      "cluster_centers"
    ],
    "cluster_centers_": [],
    "_predict_raw": [
      "self",
      "X_table",
      "module",
      "policy",
      "dtype"
    ],
    "_predict": [
      "self",
      "X",
      "module",
      "queue"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "k_means": [
    "X",
    "n_clusters"
  ],
  "BaseDBSCAN": {
    "__init__": [
      "self",
      "eps"
    ],
    "_get_onedal_params": [
      "self",
      "dtype"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "module",
      "queue"
    ]
  },
  "generate_data": [
    "low",
    "high",
    "samples_number",
    "sample_dimension"
  ],
  "check_labels_equals": [
    "left_labels",
    "right_labels"
  ],
  "_test_dbscan_big_data_numpy_gen": [
    "queue",
    "eps",
    "min_samples",
    "metric",
    "use_weights",
    "low",
    "high",
    "samples_number",
    "sample_dimension"
  ],
  "test_dbscan_big_data_numpy_gen": [
    "queue",
    "metric",
    "use_weights"
  ],
  "_test_across_grid_parameter_numpy_gen": [
    "queue",
    "metric",
    "use_weights"
  ],
  "test_across_grid_parameter_numpy_gen": [
    "queue",
    "metric",
    "use_weights"
  ],
  "BaseEmpiricalCovariance": {
    "__init__": [
      "self",
      "method",
      "bias",
      "assume_centered"
    ],
    "_get_onedal_params": [
      "self",
      "dtype"
    ]
  },
  "IncrementalEmpiricalCovariance": {
    "__init__": [
      "self",
      "method",
      "bias",
      "assume_centered"
    ],
    "_reset": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "finalize_fit": [
      "self",
      "queue"
    ]
  },
  "test_onedal_import_covariance": [
    "queue"
  ],
  "test_on_gold_data_unbiased": [
    "queue",
    "dtype"
  ],
  "test_on_gold_data_biased": [
    "queue",
    "dtype"
  ],
  "test_partial_fit_on_random_data": [
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "bias",
    "dtype"
  ],
  "_main": [],
  "DaalVersionTuple": [],
  "oneapi_is_available": [],
  "set_idp_sklearn_verbose": [],
  "get_daal_version": [],
  "daal_check_version": [
    "required_version",
    "daal_version"
  ],
  "sklearn_check_version": [
    "ver"
  ],
  "parse_dtype": [
    "dt"
  ],
  "getFPType": [
    "X"
  ],
  "make2d": [
    "X"
  ],
  "get_patch_message": [
    "s"
  ],
  "is_in_sycl_ctxt": [],
  "is_DataFrame": [
    "X"
  ],
  "get_dtype": [
    "X"
  ],
  "get_number_of_types": [
    "dataframe"
  ],
  "check_tree_nodes": [
    "tree_nodes"
  ],
  "PatchingConditionsChain": {
    "__init__": [
      "self",
      "scope_name"
    ],
    "_iter_conditions": [
      "self",
      "conditions_and_messages"
    ],
    "and_conditions": [
      "self",
      "conditions_and_messages",
      "conditions_merging"
    ],
    "and_condition": [
      "self",
      "condition",
      "message"
    ],
    "or_conditions": [
      "self",
      "conditions_and_messages",
      "conditions_merging"
    ],
    "write_log": [
      "self"
    ],
    "get_status": [
      "self",
      "logs"
    ]
  },
  "threadpool_controller": [],
  "get_suggested_n_threads": [
    "n_cpus"
  ],
  "_run_with_n_jobs": [
    "method"
  ],
  "control_n_jobs": [
    "decorated_methods"
  ],
  "_get_libsvm_impl": [],
  "_dual_coef_getter": [
    "self"
  ],
  "_intercept_getter": [
    "self"
  ],
  "_dual_coef_setter": [
    "self",
    "val"
  ],
  "_intercept_setter": [
    "self",
    "val"
  ],
  "group_indices_by_class": [
    "num_classes",
    "sv_ind_by_clf",
    "labels"
  ],
  "map_sv_to_columns_in_dual_coef_matrix": [
    "sv_ind_by_class"
  ],
  "map_to_lexicographic": [
    "n"
  ],
  "permute_list": [
    "li",
    "perm"
  ],
  "extract_dual_coef": [
    "num_classes",
    "sv_ind_by_clf",
    "sv_coef_by_clf",
    "labels"
  ],
  "_daal4py_kf": [
    "kernel",
    "X_fptype",
    "gamma",
    "is_sparse"
  ],
  "_daal4py_check_weight": [
    "self",
    "X",
    "y",
    "sample_weight"
  ],
  "_daal4py_svm": [
    "fptype",
    "C",
    "accuracyThreshold",
    "tau",
    "maxIterations",
    "cacheSize",
    "doShrinking",
    "kernel",
    "nClasses"
  ],
  "_daal4py_fit": [
    "self",
    "X",
    "y_inp",
    "sample_weight",
    "kernel",
    "is_sparse"
  ],
  "_compute_gamma": [
    "gamma",
    "kernel",
    "X"
  ],
  "fit": [
    "self",
    "X",
    "y",
    "sample_weight"
  ],
  "_daal4py_predict": [
    "self",
    "X",
    "is_decision_function"
  ],
  "predict": [
    "self",
    "X"
  ],
  "_daal4py_predict_proba": [
    "self",
    "X"
  ],
  "predict_proba": [
    "self"
  ],
  "decision_function": [
    "self",
    "X"
  ],
  "__base_svc_init_arg_names__": [],
  "__base_svc_init_function__": [],
  "__base_svc_init_function_code__": [],
  "_daal4py_check": [
    "self",
    "X",
    "y",
    "check_input"
  ],
  "_daal4py_fit_enet": [
    "self",
    "X",
    "y_",
    "check_input"
  ],
  "_daal4py_predict_enet": [
    "self",
    "X"
  ],
  "_daal4py_fit_lasso": [
    "self",
    "X",
    "y_",
    "check_input"
  ],
  "_daal4py_predict_lasso": [
    "self",
    "X"
  ],
  "_fit": [
    "self",
    "_X",
    "_y",
    "sample_weight",
    "check_input"
  ],
  "_dual_gap": [
    "self"
  ],
  "ElasticNet": {
    "__doc__": [],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ],
    "predict": [
      "self",
      "X"
    ],
    "dual_gap_": [
      "self"
    ]
  },
  "Lasso": {
    "__doc__": [],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ],
    "predict": [
      "self",
      "X"
    ],
    "dual_gap_": [
      "self"
    ]
  },
  "_resultsToCompute_string": [
    "value",
    "gradient",
    "hessian"
  ],
  "_daal4py_logistic_loss_extra_args": [
    "nClasses_unused",
    "beta",
    "X",
    "y",
    "l1",
    "l2",
    "fit_intercept",
    "value",
    "gradient",
    "hessian"
  ],
  "_daal4py_cross_entropy_loss_extra_args": [
    "nClasses",
    "beta",
    "X",
    "y",
    "l1",
    "l2",
    "fit_intercept",
    "value",
    "gradient",
    "hessian"
  ],
  "_daal4py_loss_and_grad": [
    "beta",
    "objF_instance",
    "X",
    "y",
    "n"
  ],
  "_daal4py_loss_": [
    "beta",
    "objF_instance",
    "X",
    "y",
    "n",
    "l2_unused"
  ],
  "_daal4py_grad_": [
    "beta",
    "objF_instance",
    "X",
    "y",
    "n",
    "l2_unused"
  ],
  "_daal4py_grad_hess_": [
    "beta",
    "objF_instance",
    "X",
    "y",
    "n",
    "l2"
  ],
  "_fit_linear": [
    "self",
    "X",
    "y",
    "sample_weight"
  ],
  "_predict_linear": [
    "self",
    "X"
  ],
  "_fit_ridge": [
    "self",
    "_X",
    "_y",
    "sample_weight"
  ],
  "_predict_ridge": [
    "self",
    "_X"
  ],
  "__logistic_regression_path": [
    "X",
    "y",
    "pos_class",
    "Cs",
    "fit_intercept",
    "max_iter",
    "tol",
    "verbose",
    "solver",
    "coef",
    "class_weight",
    "dual",
    "penalty",
    "intercept_scaling",
    "multi_class",
    "random_state",
    "check_input",
    "max_squared_sum",
    "sample_weight",
    "l1_ratio",
    "n_threads"
  ],
  "daal4py_fit": [
    "self",
    "X",
    "y",
    "sample_weight"
  ],
  "daal4py_predict": [
    "self",
    "X",
    "resultsToEvaluate"
  ],
  "logistic_regression_path": [
    "X",
    "y",
    "pos_class",
    "Cs",
    "fit_intercept",
    "max_iter",
    "tol",
    "verbose",
    "solver",
    "coef",
    "class_weight",
    "dual",
    "penalty",
    "intercept_scaling",
    "multi_class",
    "random_state",
    "check_input",
    "max_squared_sum",
    "sample_weight",
    "l1_ratio",
    "n_threads"
  ],
  "make_dataset": [
    "n_samples",
    "n_features",
    "kind",
    "random_state",
    "types"
  ],
  "test_linear_array_vs_dataframe_homogen": [],
  "test_linear_array_vs_dataframe_heterogen": [],
  "test_linear_array_vs_dataframe_heterogen_double_float": [],
  "test_linear_array_vs_dataframe_heterogen_double_int": [],
  "test_linear_array_vs_dataframe_heterogen_float_int": [],
  "_test_multivariate_ridge_coefficients": [
    "ridge_class",
    "random_state"
  ],
  "_test_multivariate_ridge_alpha_shape": [
    "ridge_class",
    "random_state"
  ],
  "test_multivariate_ridge_coefficients": [],
  "test_multivariate_ridge_alpha_shape": [],
  "_daal4py_cosine_distance_dense": [
    "X"
  ],
  "_daal4py_correlation_distance_dense": [
    "X"
  ],
  "pairwise_distances": [
    "X",
    "Y",
    "metric"
  ],
  "_daal_type_of_target": [
    "y"
  ],
  "roc_auc_score": [
    "y_true",
    "y_score"
  ],
  "_daal_validate_data": [
    "self",
    "X",
    "y",
    "reset",
    "validate_separately"
  ],
  "_assert_all_finite": [
    "X",
    "allow_nan",
    "msg_dtype",
    "estimator_name",
    "input_name"
  ],
  "_pandas_check_array": [
    "array",
    "array_orig",
    "force_all_finite",
    "ensure_min_samples",
    "ensure_min_features",
    "copy",
    "context"
  ],
  "_daal_check_array": [
    "array",
    "accept_sparse"
  ],
  "_daal_check_X_y": [
    "X",
    "y",
    "accept_sparse"
  ],
  "_daal_num_features": [
    "X"
  ],
  "test_daal_check_version": [
    "required_version",
    "expected"
  ],
  "TSNE": {
    "__doc__": [],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_daal_tsne": [
      "self",
      "P",
      "n_samples",
      "X_embedded"
    ],
    "_fit": [
      "self",
      "X",
      "skip_num_points"
    ]
  },
  "AdaBoostClassifier": {
    "__init__": [
      "self",
      "split_criterion",
      "max_tree_depth",
      "min_observations_in_leaf_node",
      "max_iterations",
      "learning_rate",
      "accuracy_threshold"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_to_absolute_max_features": [
    "max_features",
    "n_features",
    "is_classification"
  ],
  "_get_n_samples_bootstrap": [
    "n_samples",
    "max_samples"
  ],
  "check_sample_weight": [
    "sample_weight",
    "X",
    "dtype"
  ],
  "RandomForestBase": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_check_parameters": [
      "self"
    ]
  },
  "GBTDAALBase": {
    "__init__": [
      "self",
      "split_method",
      "max_iterations",
      "max_tree_depth",
      "shrinkage",
      "min_split_loss",
      "reg_lambda",
      "observations_per_tree_fraction",
      "features_per_node",
      "min_observations_in_leaf_node",
      "memory_saving_mode",
      "max_bins",
      "min_bin_size",
      "random_state"
    ],
    "_check_params": [
      "self"
    ],
    "allow_nan_": [],
    "_more_tags": [
      "self"
    ]
  },
  "GBTDAALClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "resultsToEvaluate"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "convert_model": [
      "model"
    ]
  },
  "GBTDAALRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "pred_contribs",
      "pred_interactions"
    ],
    "convert_model": [
      "model"
    ]
  },
  "ACCURACY_RATIO": [],
  "MSE_RATIO": [],
  "LOG_LOSS_RATIO": [],
  "ROC_AUC_RATIO": [],
  "RNG": [],
  "IRIS": [],
  "_compare_with_sklearn_classifier_iris": [
    "n_estimators",
    "class_weight",
    "sample_weight",
    "description"
  ],
  "CLASS_WEIGHTS_IRIS": [],
  "test_classifier_class_weight_iris": [
    "class_weight"
  ],
  "SAMPLE_WEIGHTS_IRIS": [],
  "test_classifier_sample_weight_iris": [
    "sample_weight"
  ],
  "N_ESTIMATORS_IRIS": [],
  "test_classifier_big_estimators_iris": [
    "n_estimators"
  ],
  "_compare_with_sklearn_mse_regressor_iris": [
    "n_estimators",
    "sample_weight",
    "description"
  ],
  "test_mse_regressor_sample_weight_iris": [
    "weight"
  ],
  "test_mse_regressor_big_estimators_iris": [
    "n_estimators"
  ],
  "training_algorithm": [
    "method",
    "fptype",
    "params"
  ],
  "prediction_algorithm": [
    "method",
    "fptype",
    "params"
  ],
  "parse_auto_method": [
    "estimator",
    "method",
    "n_samples",
    "n_features"
  ],
  "daal4py_kneighbors": [
    "estimator",
    "X",
    "n_neighbors",
    "return_distance"
  ],
  "validate_data": [
    "estimator",
    "X",
    "y",
    "reset",
    "validate_separately"
  ],
  "KNeighborsMixin": {
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance"
    ]
  },
  "RadiusNeighborsMixin": {
    "radius_neighbors": [
      "self",
      "X",
      "radius",
      "return_distance",
      "sort_results"
    ]
  },
  "daal4py_classifier_predict": [
    "estimator",
    "X",
    "base_predict"
  ],
  "DISTANCES": [],
  "ALGORITHMS": [],
  "WEIGHTS": [],
  "KS": [],
  "N_TRIES": [],
  "_test_determenistic": [
    "distance",
    "algorithm",
    "weight",
    "k"
  ],
  "test_determenistic": [
    "distance",
    "algorithm",
    "weight",
    "k"
  ],
  "get_dtypes": [
    "data"
  ],
  "train_test_split": [],
  "N_SAMPLES": [],
  "RANDOM_STATE": [],
  "test_results_similarity": [
    "n_samples"
  ],
  "_validate_center_shape": [
    "X",
    "n_centers",
    "centers"
  ],
  "_tolerance": [
    "X",
    "rtol"
  ],
  "_daal4py_compute_starting_centroids": [
    "X",
    "X_fptype",
    "nClusters",
    "cluster_centers_0",
    "verbose",
    "random_state"
  ],
  "_daal4py_kmeans_compatibility": [
    "nClusters",
    "maxIterations",
    "fptype",
    "method",
    "accuracyThreshold",
    "resultsToEvaluate",
    "gamma"
  ],
  "_daal4py_k_means_predict": [
    "X",
    "nClusters",
    "centroids",
    "resultsToEvaluate"
  ],
  "_daal4py_k_means_fit": [
    "X",
    "nClusters",
    "numIterations",
    "tol",
    "cluster_centers_0",
    "n_init",
    "verbose",
    "random_state"
  ],
  "_daal4py_check_test_data": [
    "self",
    "X"
  ],
  "_predict": [
    "self",
    "X",
    "sample_weight"
  ],
  "_daal_dbscan": [
    "X",
    "eps",
    "min_samples",
    "sample_weight"
  ],
  "METRIC": [],
  "USE_WEIGHTS": [],
  "_get_map_of_algorithms": [],
  "do_patch": [
    "name",
    "get_map"
  ],
  "do_unpatch": [
    "name",
    "get_map"
  ],
  "enable": [
    "name",
    "verbose",
    "deprecation",
    "get_map"
  ],
  "disable": [
    "name",
    "get_map"
  ],
  "_is_enabled": [
    "name",
    "get_map"
  ],
  "patch_is_enabled": [
    "name",
    "get_map",
    "return_map"
  ],
  "_patch_names": [],
  "get_branch": [
    "s"
  ],
  "run_parse": [
    "mas",
    "result"
  ],
  "get_result_log": [],
  "result_log": [],
  "test_patching": [
    "configuration"
  ],
  "test_monkey_patching": [],
  "MODELS_INFO": [],
  "TYPES": [],
  "TO_SKIP": [],
  "absolute_path": [],
  "get_class_name": [
    "x"
  ],
  "generate_dataset": [
    "name",
    "dtype",
    "model_name"
  ],
  "run_patch": [
    "model_info",
    "dtype"
  ],
  "run_algotithms": [],
  "run_utils": [],
  "GBTDAALBaseModel": {
    "__init__": [
      "self"
    ],
    "_is_regression": [
      "self"
    ],
    "_get_params_from_lightgbm": [
      "self",
      "params"
    ],
    "_get_params_from_xgboost": [
      "self",
      "params"
    ],
    "_get_params_from_catboost": [
      "self",
      "params"
    ],
    "_convert_model_from_lightgbm": [
      "self",
      "booster"
    ],
    "_convert_model_from_xgboost": [
      "self",
      "booster"
    ],
    "_convert_model_from_catboost": [
      "self",
      "booster"
    ],
    "_convert_model": [
      "self",
      "model"
    ],
    "_predict_classification": [
      "self",
      "X",
      "fptype",
      "resultsToEvaluate"
    ],
    "_predict_regression": [
      "self",
      "X",
      "fptype",
      "pred_contribs",
      "pred_interactions"
    ],
    "_predict_regression_with_results_to_compute": [
      "self",
      "X",
      "fptype",
      "pred_contribs",
      "pred_interactions"
    ]
  },
  "GBTDAALModel": {
    "predict": [
      "self",
      "X",
      "pred_contribs",
      "pred_interactions"
    ],
    "_check_proba": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "convert_model": [
    "model"
  ],
  "set_sklearn_ex_verbose": [],
  "get_sklearnex_version": [
    "rule"
  ],
  "register_hyperparameters": [
    "hyperparameters_map"
  ],
  "get_config": [],
  "set_config": [
    "target_offload",
    "allow_fallback_to_host"
  ],
  "config_context": [],
  "pytest_configure": [
    "config"
  ],
  "pytest_runtest_call": [
    "item"
  ],
  "with_sklearnex": [],
  "with_array_api": [],
  "onedal_iface_flag": [],
  "_is_new_patching_available": [],
  "_is_preview_enabled": [],
  "get_patch_map_core": [
    "preview"
  ],
  "get_patch_map": [],
  "get_patch_names": [],
  "patch_sklearn": [
    "name",
    "verbose",
    "global_patch",
    "preview"
  ],
  "unpatch_sklearn": [
    "name",
    "global_unpatch"
  ],
  "sklearn_is_patched": [
    "name",
    "return_map"
  ],
  "is_patched_instance": [
    "instance"
  ],
  "dispatch": [
    "obj",
    "method_name",
    "branches"
  ],
  "wrap_output_data": [
    "func"
  ],
  "get_dual_coef": [
    "self"
  ],
  "set_dual_coef": [
    "self",
    "value"
  ],
  "get_intercept": [
    "self"
  ],
  "set_intercept": [
    "self",
    "value"
  ],
  "BaseSVC": {
    "_compute_balanced_class_weight": [
      "self",
      "y"
    ],
    "_fit_proba": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "_save_attributes": [
      "self"
    ]
  },
  "BaseSVR": {
    "_save_attributes": [
      "self"
    ],
    "_onedal_score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ]
  },
  "test_sklearnex_import_svc": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_nusvc": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_svr": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_nusvr": [
    "dataframe",
    "queue"
  ],
  "test_logistic_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_logistic_spmd_synthetic": [
    "n_samples",
    "n_features",
    "C",
    "tol",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_linear_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_linear_spmd_synthetic": [
    "n_samples",
    "n_features",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_basic_stats_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_basic_stats_spmd_synthetic": [
    "n_samples",
    "n_features",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_pca_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_pca_spmd_synthetic": [
    "n_samples",
    "n_features",
    "n_components",
    "whiten",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_rfcls_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_rfcls_spmd_synthetic": [
    "n_samples",
    "n_features_and_classes",
    "n_estimators",
    "max_depth",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_rfreg_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_rfreg_spmd_synthetic": [
    "n_samples",
    "n_features",
    "n_estimators",
    "max_depth",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_knncls_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_knncls_spmd_synthetic": [
    "n_samples",
    "n_features_and_classes",
    "n_neighbors",
    "weights",
    "dataframe",
    "queue",
    "dtype",
    "metric"
  ],
  "test_knnreg_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_knnreg_spmd_synthetic": [
    "n_samples",
    "n_features",
    "n_neighbors",
    "weights",
    "metric",
    "dataframe",
    "queue",
    "dtype"
  ],
  "BaseDBSCANspmd": {
    "_onedal_dbscan": [
      "self"
    ]
  },
  "test_kmeans_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_kmeans_spmd_synthetic": [
    "n_samples",
    "n_features",
    "n_clusters",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_dbscan_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_dbscan_spmd_synthetic": [
    "n_samples",
    "n_features_and_eps",
    "centers",
    "min_samples",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_covariance_spmd_gold": [
    "dataframe",
    "queue"
  ],
  "test_covariance_spmd_synthetic": [
    "n_samples",
    "n_features",
    "assume_centered",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_sklearnex_import_linear": [
    "dataframe",
    "queue",
    "dtype",
    "macro_block"
  ],
  "test_sklearnex_import_ridge": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_lasso": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_elastic": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_reconstruct_model": [
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_sklearnex_multivariate_ridge_coefs": [],
  "test_sklearnex_multivariate_ridge_alpha_shape": [],
  "prepare_input": [
    "X",
    "y",
    "dataframe",
    "queue"
  ],
  "test_sklearnex_multiclass_classification": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_binary_classification": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_fit_on_gold_data": [
    "dataframe",
    "queue",
    "fit_intercept",
    "macro_block",
    "dtype"
  ],
  "test_sklearnex_partial_fit_on_gold_data": [
    "dataframe",
    "queue",
    "fit_intercept",
    "macro_block",
    "dtype"
  ],
  "test_sklearnex_partial_fit_multitarget_on_gold_data": [
    "dataframe",
    "queue",
    "fit_intercept",
    "macro_block",
    "dtype"
  ],
  "test_sklearnex_partial_fit_on_random_data": [
    "dataframe",
    "queue",
    "fit_intercept",
    "num_samples",
    "num_features",
    "num_targets",
    "num_blocks",
    "macro_block",
    "dtype"
  ],
  "_load_all_models": [
    "with_sklearnex",
    "estimator"
  ],
  "PATCHED_MODELS": [],
  "UNPATCHED_MODELS": [],
  "PATCHED_FUNCTIONS": [],
  "UNPATCHED_FUNCTIONS": [],
  "mixin_map": [],
  "_sklearn_clone_dict": {
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "SPECIAL_INSTANCES": [],
  "gen_models_info": [
    "algorithms",
    "required_inputs"
  ],
  "call_method": [
    "estimator",
    "method",
    "X",
    "y"
  ],
  "_gen_dataset_type": [
    "est"
  ],
  "_dataset_dict": [],
  "gen_dataset": [
    "est",
    "datasets",
    "sparse",
    "queue",
    "target_df",
    "dtype"
  ],
  "DTYPES": [],
  "eval_method": [
    "X",
    "y",
    "est",
    "method"
  ],
  "_run_test": [
    "estimator",
    "method",
    "datasets"
  ],
  "SPARSE_INSTANCES": [],
  "STABILITY_INSTANCES": [],
  "test_standard_estimator_stability": [
    "estimator",
    "method",
    "dataframe",
    "queue"
  ],
  "test_special_estimator_stability": [
    "estimator",
    "method",
    "dataframe",
    "queue"
  ],
  "test_sparse_estimator_stability": [
    "estimator",
    "method",
    "dataframe",
    "queue"
  ],
  "test_other_estimator_stability": [
    "estimator",
    "method",
    "dataframe",
    "queue"
  ],
  "test_train_test_split": [
    "features"
  ],
  "test_pairwise_distances": [
    "metric"
  ],
  "test_roc_auc": [
    "array_size"
  ],
  "ALLOWED_LOCATIONS": [],
  "test_target_offload_ban": [],
  "test_pairwise_distances_patching": [
    "caplog",
    "dataframe",
    "queue",
    "dtype",
    "metric"
  ],
  "test_roc_auc_score_patching": [
    "caplog",
    "dataframe",
    "queue",
    "dtype"
  ],
  "test_standard_estimator_patching": [
    "caplog",
    "dataframe",
    "queue",
    "dtype",
    "estimator",
    "method"
  ],
  "test_special_estimator_patching": [
    "caplog",
    "dataframe",
    "queue",
    "dtype",
    "estimator",
    "method"
  ],
  "test_standard_estimator_signatures": [
    "estimator"
  ],
  "test_standard_estimator_init_signatures": [
    "estimator"
  ],
  "test_patched_function_signatures": [
    "function"
  ],
  "test_patch_map_match": [],
  "test_is_patched_instance": [
    "estimator"
  ],
  "test_if_estimator_inherits_sklearn": [
    "estimator"
  ],
  "test_docstring_patching_match": [
    "estimator"
  ],
  "test_onedal_supported_member": [
    "name",
    "member"
  ],
  "ESTIMATORS": [],
  "test_n_jobs_support": [
    "caplog",
    "estimator_class",
    "n_jobs"
  ],
  "test_get_config_contains_sklearn_params": [],
  "test_set_config_works": [],
  "test_config_context_in_parallel": [
    "with_sklearnex"
  ],
  "test_patch_by_list_simple": [],
  "test_patch_by_list_many_estimators": [],
  "test_unpatch_by_list_many_estimators": [],
  "test_patching_checker": [],
  "test_preview_namespace": [],
  "_mpi_libs_and_gpu_available": [],
  "_get_local_tensor": [
    "full_data"
  ],
  "_generate_regression_data": [
    "n_samples",
    "n_features",
    "dtype",
    "random_state"
  ],
  "_generate_classification_data": [
    "n_samples",
    "n_features",
    "n_classes",
    "dtype",
    "random_state"
  ],
  "_generate_statistic_data": [
    "n_samples",
    "n_features",
    "dtype",
    "random_state"
  ],
  "_generate_clustering_data": [
    "n_samples",
    "n_features",
    "centers",
    "dtype",
    "random_state"
  ],
  "_spmd_assert_allclose": [
    "spmd_result",
    "batch_result"
  ],
  "_assert_unordered_allclose": [
    "spmd_result",
    "batch_result",
    "localize"
  ],
  "_assert_kmeans_labels_allclose": [
    "spmd_labels",
    "batch_labels",
    "spmd_centers",
    "batch_centers"
  ],
  "CPU_SKIP_LIST": [],
  "GPU_SKIP_LIST": [],
  "gen_functions": [
    "functions"
  ],
  "FUNCTIONS": [],
  "CPU_ESTIMATORS": [],
  "GPU_ESTIMATORS": [],
  "data_shapes": [],
  "EXTRA_MEMORY_THRESHOLD": [],
  "N_SPLITS": [],
  "ORDER_DICT": [],
  "gen_clsf_data": [
    "n_samples",
    "n_features"
  ],
  "get_traced_memory": [
    "queue"
  ],
  "take": [
    "x",
    "index",
    "axis",
    "queue"
  ],
  "split_train_inference": [
    "kf",
    "x",
    "y",
    "estimator",
    "queue"
  ],
  "_kfold_function_template": [
    "estimator",
    "dataframe",
    "data_shape",
    "queue",
    "func"
  ],
  "test_memory_leaks": [
    "estimator",
    "dataframe",
    "queue",
    "order",
    "data_shape"
  ],
  "test_gpu_memory_leaks": [
    "estimator",
    "queue",
    "order",
    "data_shape"
  ],
  "test_sklearnex_import_roc_auc": [],
  "test_sklearnex_import_pairwise_distances": [],
  "test_ridge_coefficients": [
    "dataframe",
    "queue",
    "sample_size",
    "feature_size",
    "alpha"
  ],
  "test_sklearnex_import": [
    "dataframe",
    "queue"
  ],
  "check_pca_on_gold_data": [
    "incpca",
    "dtype",
    "whiten",
    "transformed_data"
  ],
  "check_pca": [
    "incpca",
    "dtype",
    "whiten",
    "data",
    "transformed_data"
  ],
  "test_sklearnex_fit_transform_on_gold_data": [
    "dataframe",
    "queue",
    "whiten",
    "num_blocks",
    "dtype"
  ],
  "get_cluster_centers": [
    "self"
  ],
  "set_cluster_centers": [
    "self",
    "value"
  ],
  "get_labels": [
    "self"
  ],
  "set_labels": [
    "self",
    "value"
  ],
  "get_inertia": [
    "self"
  ],
  "set_inertia": [
    "self",
    "value"
  ],
  "get_n_iter": [
    "self"
  ],
  "set_n_iter": [
    "self",
    "value"
  ],
  "BaseKMeans": {
    "_save_attributes": [
      "self"
    ]
  },
  "test_sklearnex_import_covariance": [
    "dataframe",
    "queue",
    "macro_block",
    "assume_centered"
  ],
  "get_patch_str": [
    "name",
    "verbose"
  ],
  "get_patch_str_re": [],
  "patch_sklearn_global": [
    "name",
    "verbose"
  ],
  "unpatch_sklearn_global": [],
  "_FuncWrapper": {
    "__init__": [
      "self",
      "function"
    ],
    "with_config": [
      "self",
      "config"
    ],
    "__call__": [
      "self"
    ]
  },
  "_FuncWrapperOld": {
    "__init__": [
      "self",
      "function"
    ],
    "__call__": [
      "self"
    ]
  },
  "get_namespace": [],
  "test_sum_infinite_actually_finite": [
    "dtype",
    "shape",
    "allow_nan"
  ],
  "test_assert_finite_random_location": [
    "dtype",
    "shape",
    "allow_nan",
    "check",
    "seed"
  ],
  "test_assert_finite_random_shape_and_location": [
    "dtype",
    "allow_nan",
    "check",
    "seed"
  ],
  "test_sklearnex_import_basic_statistics": [
    "dataframe",
    "queue"
  ],
  "test_partial_fit_multiple_options_on_gold_data": [
    "dataframe",
    "queue",
    "weighted",
    "dtype"
  ],
  "test_partial_fit_single_option_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "option",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_partial_fit_multiple_options_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_partial_fit_all_option_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_fit_multiple_options_on_gold_data": [
    "dataframe",
    "queue",
    "weighted",
    "dtype"
  ],
  "test_fit_single_option_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "option",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_fit_multiple_options_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "test_fit_all_option_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "weighted",
    "dtype"
  ],
  "ForestClassifier": {
    "_err": [],
    "_get_tree_state": [],
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "_estimators_": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_onedal_fit_ready": [
      "self",
      "patching_status",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_onedal_cpu_supported": [
      "self",
      "method_name"
    ],
    "_onedal_gpu_supported": [
      "self",
      "method_name"
    ],
    "_onedal_predict": [
      "self",
      "X",
      "queue"
    ],
    "_onedal_predict_proba": [
      "self",
      "X",
      "queue"
    ],
    "_onedal_score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ]
  },
  "ForestRegressor": {
    "_err": [],
    "_get_tree_state": [],
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "_onedal_fit_ready": [
      "self",
      "patching_status",
      "X",
      "y",
      "sample_weight"
    ],
    "_onedal_cpu_supported": [
      "self",
      "method_name"
    ],
    "_onedal_gpu_supported": [
      "self",
      "method_name"
    ],
    "_onedal_predict": [
      "self",
      "X",
      "queue"
    ],
    "_onedal_score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "queue"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "test_sklearnex_import_rf_classifier": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_rf_regression": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_et_classifier": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_et_regression": [
    "dataframe",
    "queue"
  ],
  "LocalOutlierFactor": {
    "__doc__": [],
    "_save_attributes": [],
    "_onedal_knn_fit": [],
    "_onedal_kneighbors": [],
    "_onedal_fit": [
      "self",
      "X",
      "y",
      "queue"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "_kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance"
    ],
    "kneighbors": [],
    "score_samples": [
      "self",
      "X"
    ]
  },
  "KNeighborsDispatchingBase": {
    "_fit_validation": [
      "self",
      "X",
      "y"
    ],
    "_onedal_supported": [
      "self",
      "device",
      "method_name"
    ],
    "_onedal_gpu_supported": [
      "self",
      "method_name"
    ],
    "_onedal_cpu_supported": [
      "self",
      "method_name"
    ],
    "kneighbors_graph": [
      "self",
      "X",
      "n_neighbors",
      "mode"
    ]
  },
  "test_sklearnex_import_knn_classifier": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_knn_regression": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_kneighbors": [
    "estimator",
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_lof": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_import_train_test_split": [],
  "test_sklearnex_import_dbscan": [
    "dataframe",
    "queue"
  ],
  "test_sklearnex_fit_on_random_data": [
    "dataframe",
    "queue",
    "num_batches",
    "row_count",
    "column_count",
    "dtype",
    "assume_centered"
  ],
  "test_whitened_toy_score": [
    "dataframe",
    "queue"
  ],
  "test_IncrementalEmpiricalCovariance_against_sklearn": [
    "monkeypatch",
    "sklearn_test"
  ]
}