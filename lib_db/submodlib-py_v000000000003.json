{
  "__all__": [],
  "TYPE_CHECKING": [],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "square": [
    "num"
  ],
  "cos_sim_square": [
    "A"
  ],
  "cos_sim_rectangle": [
    "A",
    "B"
  ],
  "euc_dis": [
    "A",
    "B"
  ],
  "euc_dis_numba": [
    "A",
    "B"
  ],
  "cos_sim_square_numba": [
    "A"
  ],
  "cos_sim_rectangle_numba": [
    "A",
    "B"
  ],
  "create_sparse_kernel": [
    "X",
    "metric",
    "num_neigh",
    "n_jobs",
    "method"
  ],
  "create_kernel_dense_other": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_rowwise": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_sklearn": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_scipy": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_np": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_np_numba": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_kernel_dense_np_numba_rectangular": [
    "X",
    "metric",
    "X_rep"
  ],
  "create_cluster_kernels": [
    "X",
    "metric",
    "cluster_lab",
    "num_cluster",
    "onlyClusters"
  ],
  "create_kernel": [
    "X",
    "metric",
    "mode",
    "num_neigh",
    "n_jobs",
    "X_rep",
    "method"
  ],
  "MixtureFunction": {
    "__init__": [
      "self",
      "functions",
      "weights"
    ]
  },
  "ProbabilisticSetCoverConditionalGainFunction": {
    "__init__": [
      "self",
      "n",
      "num_concepts",
      "probs",
      "private_concepts",
      "concept_weights"
    ]
  },
  "GraphCutMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "query_sijs",
      "data",
      "queryData",
      "metric"
    ]
  },
  "LogDeterminantConditionalMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "num_privates",
      "lambdaVal",
      "data_sijs",
      "query_sijs",
      "query_query_sijs",
      "private_sijs",
      "private_private_sijs",
      "query_private_sijs",
      "data",
      "queryData",
      "privateData",
      "metric",
      "magnificationEta",
      "privacyHardness"
    ]
  },
  "GraphCutFunction": {
    "__init__": [
      "self",
      "n",
      "mode",
      "lambdaVal",
      "separate_rep",
      "n_rep",
      "mgsijs",
      "ggsijs",
      "data",
      "data_rep",
      "metric",
      "num_neighbors"
    ]
  },
  "LogDeterminantConditionalGainFunction": {
    "__init__": [
      "self",
      "n",
      "num_privates",
      "lambdaVal",
      "data_sijs",
      "private_sijs",
      "private_private_sijs",
      "data",
      "privateData",
      "metric",
      "privacyHardness"
    ]
  },
  "FacilityLocationConditionalMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "num_privates",
      "data_sijs",
      "query_sijs",
      "private_sijs",
      "data",
      "queryData",
      "privateData",
      "metric",
      "magnificationEta",
      "privacyHardness"
    ]
  },
  "ConcaveOverModularFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "query_sijs",
      "data",
      "queryData",
      "metric",
      "queryDiversityEta",
      "mode"
    ]
  },
  "SetCoverConditionalMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "cover_set",
      "num_concepts",
      "query_concepts",
      "private_concepts",
      "concept_weights"
    ]
  },
  "FacilityLocationConditionalGainFunction": {
    "__init__": [
      "self",
      "n",
      "num_privates",
      "data_sijs",
      "private_sijs",
      "data",
      "privateData",
      "metric",
      "privacyHardness"
    ]
  },
  "SetCoverMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "cover_set",
      "num_concepts",
      "query_concepts",
      "concept_weights"
    ]
  },
  "FacilityLocationVariantMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "query_sijs",
      "data",
      "queryData",
      "metric",
      "queryDiversityEta"
    ]
  },
  "ProbabilisticSetCoverFunction": {
    "__init__": [
      "self",
      "n",
      "probs",
      "num_concepts",
      "concept_weights"
    ]
  },
  "FacilityLocationMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "data_sijs",
      "query_sijs",
      "data",
      "queryData",
      "metric",
      "magnificationEta"
    ]
  },
  "SetCoverConditionalGainFunction": {
    "__init__": [
      "self",
      "n",
      "cover_set",
      "num_concepts",
      "private_concepts",
      "concept_weights"
    ]
  },
  "ProbabilisticSetCoverMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_concepts",
      "probs",
      "query_concepts",
      "concept_weights"
    ]
  },
  "FeatureBasedFunction": {
    "__init__": [
      "self",
      "n",
      "features",
      "numFeatures",
      "sparse",
      "featureWeights",
      "mode"
    ]
  },
  "GraphCutConditionalGainFunction": {
    "__init__": [
      "self",
      "n",
      "num_privates",
      "lambdaVal",
      "data_sijs",
      "private_sijs",
      "data",
      "privateData",
      "metric",
      "privacyHardness"
    ]
  },
  "DisparitySumFunction": {
    "__init__": [
      "self",
      "n",
      "mode",
      "sijs",
      "data",
      "metric",
      "num_neighbors"
    ]
  },
  "LogDeterminantFunction": {
    "__init__": [
      "self",
      "n",
      "mode",
      "lambdaVal",
      "sijs",
      "data",
      "metric",
      "num_neighbors"
    ]
  },
  "SetCoverFunction": {
    "__init__": [
      "self",
      "n",
      "cover_set",
      "num_concepts",
      "concept_weights"
    ]
  },
  "SetFunction": {
    "__init__": [
      "self",
      "n",
      "f",
      "clusters"
    ],
    "evaluate": [
      "self",
      "X"
    ],
    "maximize": [
      "self",
      "budget",
      "optimizer",
      "stopIfZeroGain",
      "stopIfNegativeGain",
      "epsilon",
      "verbose",
      "show_progress",
      "costs",
      "costSensitiveGreedy"
    ],
    "marginalGain": [
      "self",
      "X",
      "element"
    ],
    "marginalGainWithMemoization": [
      "self",
      "X",
      "element"
    ],
    "evaluateWithMemoization": [
      "self",
      "X"
    ],
    "updateMemoization": [
      "self",
      "X",
      "element"
    ],
    "clearMemoization": [
      "self"
    ],
    "setMemoization": [
      "self",
      "X"
    ],
    "getEffectiveGroundSet": [
      "self"
    ]
  },
  "FacilityLocationFunction": {
    "__init__": [
      "self",
      "n",
      "mode",
      "separate_rep",
      "n_rep",
      "sijs",
      "data",
      "data_rep",
      "num_clusters",
      "cluster_labels",
      "metric",
      "num_neighbors",
      "create_dense_cpp_kernel_in_python",
      "pybind_mode"
    ]
  },
  "DisparityMinFunction": {
    "__init__": [
      "self",
      "n",
      "mode",
      "sijs",
      "data",
      "metric",
      "num_neighbors"
    ]
  },
  "ProbabilisticSetCoverConditionalMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_concepts",
      "probs",
      "query_concepts",
      "private_concepts",
      "concept_weights"
    ]
  },
  "SaturatedCoverageFunction": {
    "__init__": [
      "self",
      "n",
      "alpha",
      "sijs",
      "data",
      "metric",
      "n_neighbors"
    ]
  },
  "ClusteredFunction": {
    "__init__": [
      "self",
      "n",
      "f_name",
      "data",
      "mode",
      "cluster_lab",
      "num_clusters",
      "metric",
      "lambdaVal"
    ]
  },
  "LogDeterminantMutualInformationFunction": {
    "__init__": [
      "self",
      "n",
      "num_queries",
      "lambdaVal",
      "data_sijs",
      "query_sijs",
      "query_query_sijs",
      "data",
      "queryData",
      "metric",
      "magnificationEta"
    ]
  }
}