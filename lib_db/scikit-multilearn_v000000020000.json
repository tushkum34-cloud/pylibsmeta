{
  "SPARSE_FORMAT_TO_CONSTRUCTOR": [],
  "get_matrix_in_format": [
    "original_matrix",
    "matrix_format"
  ],
  "matrix_creation_function_for_format": [
    "sparse_format"
  ],
  "measure_per_label": [
    "measure",
    "y_true",
    "y_predicted"
  ],
  "get_data_home": [
    "data_home",
    "subdirectory"
  ],
  "clear_data_home": [
    "data_home"
  ],
  "_get_download_base_url": [],
  "available_data_sets": [],
  "download_dataset": [
    "set_name",
    "variant",
    "data_home"
  ],
  "load_dataset": [
    "set_name",
    "variant",
    "data_home"
  ],
  "load_from_arff": [
    "filename",
    "label_count",
    "label_location",
    "input_feature_type",
    "encode_nominal",
    "load_sparse",
    "return_attribute_definitions"
  ],
  "save_to_arff": [
    "X",
    "y",
    "label_location",
    "save_sparse",
    "filename"
  ],
  "save_dataset_dump": [
    "input_space",
    "labels",
    "feature_names",
    "label_names",
    "filename"
  ],
  "load_dataset_dump": [
    "filename"
  ],
  "_download_single_file": [
    "data_file_name",
    "target_file_name",
    "base_url"
  ],
  "_get_md5": [
    "file_name"
  ],
  "SUPPORTED_VERSION": [],
  "SUPPORTED_VERSION_MD5": [],
  "download_meka": [
    "version"
  ],
  "Meka": {
    "__init__": [
      "self",
      "meka_classifier",
      "weka_classifier",
      "java_command",
      "meka_classpath"
    ],
    "_clean": [
      "self"
    ],
    "_remove_temporary_files": [
      "self",
      "temporary_files"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_run": [
      "self",
      "train_file",
      "test_file",
      "additional_arguments"
    ],
    "_parse_output": [
      "self"
    ],
    "_run_meka_command": [
      "self",
      "args"
    ]
  },
  "__all__": [],
  "Keras": {
    "__init__": [
      "self",
      "build_function",
      "multi_class",
      "keras_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "EmbeddingClassifier": {
    "__init__": [
      "self",
      "embedder",
      "regressor",
      "classifier",
      "regressor_per_dimension",
      "require_dense"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_concatenate_matrices": [
      "self",
      "X",
      "y_embedded"
    ],
    "_predict_embedding": [
      "self",
      "X"
    ]
  },
  "CLEMS": {
    "__init__": [
      "self",
      "measure",
      "is_score",
      "params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "OpenNetworkEmbedder": {
    "_EMBEDDINGS": [],
    "_AGGREGATION_FUNCTIONS": [],
    "__init__": [
      "self",
      "graph_builder",
      "embedding",
      "dimension",
      "aggregation_function",
      "normalize_weights",
      "param_dict"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_init_openne_graph": [
      "self",
      "y"
    ],
    "_embedd_y": [
      "self",
      "y"
    ]
  },
  "_iterate_over_sparse_matrix": [
    "y"
  ],
  "_smacof_single_w": [
    "similarities",
    "n_uq",
    "uq_weight",
    "metric",
    "n_components",
    "init",
    "max_iter",
    "verbose",
    "eps",
    "random_state"
  ],
  "_smacof_w": [
    "similarities",
    "n_uq",
    "uq_weight",
    "metric",
    "n_components",
    "init",
    "n_init",
    "n_jobs",
    "max_iter",
    "verbose",
    "eps",
    "random_state",
    "return_n_iter"
  ],
  "_MDSW": {
    "__init__": [
      "self",
      "n_components",
      "n_uq",
      "uq_weight",
      "metric",
      "n_init",
      "max_iter",
      "verbose",
      "eps",
      "n_jobs",
      "random_state",
      "dissimilarity"
    ],
    "_pairwise": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "init"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "init"
    ]
  },
  "SKLearnEmbedder": {
    "__init__": [
      "self",
      "embedder",
      "pass_input_space"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "EmbeddingTest": {
    "TEST_NEIGHBORS": [],
    "classifiers": [
      "self"
    ],
    "test_if_embedding_classification_works_on_sparse_input": [
      "self"
    ],
    "test_if_embedding_classification_works_on_dense_input": [
      "self"
    ],
    "test_if_embedding_works_with_cross_validation": [
      "self"
    ]
  },
  "MLkNN": {
    "__init__": [
      "self",
      "k",
      "s",
      "ignore_first_neighbours"
    ],
    "_compute_prior": [
      "self",
      "y"
    ],
    "_compute_cond": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "MLTSVM": {
    "__init__": [
      "self",
      "c_k",
      "sor_omega",
      "threshold",
      "lambda_param",
      "max_iteration"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_successive_overrelaxation": [
      "self",
      "omegaW",
      "Q"
    ]
  },
  "_get_x_noclass_instances": [
    "X",
    "Y",
    "label_class"
  ],
  "_get_x_class_instances": [
    "X",
    "Y",
    "label_class"
  ],
  "_hstack": [
    "X",
    "Y"
  ],
  "_BinaryRelevanceKNN": {
    "__init__": [
      "self",
      "k"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "BRkNNaClassifier": {
    "_predict_variant": [
      "self",
      "X"
    ]
  },
  "BRkNNbClassifier": {
    "_predict_variant": [
      "self",
      "X"
    ]
  },
  "Neuron": {
    "__init__": [
      "self",
      "vc",
      "label"
    ]
  },
  "_get_label_combination_representation": [
    "label_assignment_binary_indicator_list"
  ],
  "_get_label_vector": [
    "y",
    "i"
  ],
  "_concatenate_with_negation": [
    "row"
  ],
  "_normalize_input_space": [
    "X"
  ],
  "MLARAM": {
    "__init__": [
      "self",
      "vigilance",
      "threshold",
      "neurons"
    ],
    "reset": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "LabelSpacePartitioningClassifier": {
    "__init__": [
      "self",
      "classifier",
      "clusterer",
      "require_dense"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_generate_partition": [
      "self",
      "X",
      "y"
    ]
  },
  "MajorityVotingClassifier": {
    "__init__": [
      "self",
      "classifier",
      "clusterer",
      "require_dense"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "RakelO": {
    "__init__": [
      "self",
      "base_classifier",
      "model_count",
      "labelset_size",
      "base_classifier_require_dense"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "RakelD": {
    "__init__": [
      "self",
      "base_classifier",
      "labelset_size",
      "base_classifier_require_dense"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "BinaryRelevance": {
    "__init__": [
      "self",
      "classifier",
      "require_dense"
    ],
    "_generate_partition": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "ClassifierChain": {
    "__init__": [
      "self",
      "classifier",
      "require_dense",
      "order"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "order"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_order": [
      "self"
    ]
  },
  "LabelPowerset": {
    "__init__": [
      "self",
      "classifier",
      "require_dense"
    ],
    "_clean": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ]
  },
  "example_distribution": [
    "folds",
    "desired_size"
  ],
  "get_indicator_representation": [
    "row"
  ],
  "get_combination_wise_output_matrix": [
    "y",
    "order"
  ],
  "get_unique_combinations": [
    "combinations_per_row"
  ],
  "folds_without_evidence_for_at_least_one_label_combination": [
    "y",
    "folds",
    "order"
  ],
  "folds_label_combination_pairs_without_evidence": [
    "y",
    "folds",
    "order"
  ],
  "percentage_of_label_combinations_without_evidence_per_fold": [
    "y",
    "folds",
    "order"
  ],
  "label_combination_distribution": [
    "y",
    "folds",
    "order"
  ],
  "iterative_train_test_split": [
    "X",
    "y",
    "test_size"
  ],
  "_fold_tie_break": [
    "desired_samples_per_fold",
    "M"
  ],
  "_get_most_desired_combination": [
    "samples_with_combination"
  ],
  "IterativeStratification": {
    "__init__": [
      "self",
      "n_splits",
      "order",
      "sample_distribution_per_fold",
      "random_state"
    ],
    "_prepare_stratification": [
      "self",
      "y"
    ],
    "_distribute_positive_evidence": [
      "self",
      "rows_used",
      "folds",
      "samples_with_combination",
      "per_row_combinations"
    ],
    "_distribute_negative_evidence": [
      "self",
      "rows_used",
      "folds"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "StochasticBlockModel": {
    "__init__": [
      "self",
      "nested",
      "use_degree_correlation",
      "allow_overlap",
      "weight_model"
    ],
    "fit_predict": [
      "self",
      "graph",
      "weights"
    ],
    "_detect_communities": [
      "self"
    ],
    "_model_fit_function": [
      "self"
    ]
  },
  "GraphToolLabelGraphClusterer": {
    "__init__": [
      "self",
      "graph_builder",
      "model"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "_build_graph_instance": [
      "self",
      "y"
    ]
  },
  "MatrixLabelSpaceClusterer": {
    "__init__": [
      "self",
      "clusterer",
      "pass_input_space"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "GraphBuilderBase": {
    "__init__": [
      "self"
    ],
    "transform": [
      "self",
      "y"
    ]
  },
  "LabelSpaceClustererBase": {
    "__init__": [
      "self"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "LabelGraphClustererBase": {
    "__init__": [
      "self",
      "graph_builder"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "LabelCooccurrenceGraphBuilder": {
    "__init__": [
      "self",
      "weighted",
      "include_self_edges",
      "normalize_self_edges"
    ],
    "transform": [
      "self",
      "y"
    ]
  },
  "IGraphLabelGraphClusterer": {
    "_METHODS": [],
    "__init__": [
      "self",
      "graph_builder",
      "method"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "_membership_to_list_of_communities": [
    "membership_vector",
    "size"
  ],
  "_overlapping_membership_to_list_of_communities": [
    "membership_vector",
    "size"
  ],
  "_euclidean_distance": [
    "array1",
    "array2"
  ],
  "_recalculateCenters": [
    "y",
    "balancedCluster",
    "k"
  ],
  "_countNumberOfAparitions": [
    "array",
    "number"
  ],
  "FixedLabelSpaceClusterer": {
    "__init__": [
      "self",
      "clusters"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "BalancedKMeansClusterer": {
    "__init__": [
      "self",
      "k",
      "it"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "NetworkXLabelGraphClusterer": {
    "__init__": [
      "self",
      "graph_builder",
      "method"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "RandomLabelSpaceClusterer": {
    "__init__": [
      "self",
      "cluster_size",
      "cluster_count",
      "allow_overlap"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "MLClassifierBase": {
    "__init__": [
      "self"
    ],
    "_generate_data_subset": [
      "self",
      "y",
      "subset",
      "axis"
    ],
    "_ensure_input_format": [
      "self",
      "X",
      "sparse_format",
      "enforce_sparse"
    ],
    "_ensure_output_format": [
      "self",
      "matrix",
      "sparse_format",
      "enforce_sparse"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "ProblemTransformationBase": {
    "__init__": [
      "self",
      "classifier",
      "require_dense"
    ],
    "_ensure_multi_label_from_single_class": [
      "self",
      "matrix",
      "matrix_format"
    ]
  },
  "MockClassifier": {
    "__init__": [
      "self"
    ],
    "fit": [
      "X",
      "y"
    ],
    "predict": [
      "X"
    ]
  }
}