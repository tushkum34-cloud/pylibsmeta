{
  "__all__": [],
  "NoChangeClassifier": {
    "__init__": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "PriorClassifier": {
    "__init__": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "StatisticRegressor": {
    "__init__": [
      "self",
      "statistic"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "collect_ignore": [],
  "iter_estimators": [],
  "iter_estimators_which_can_be_tested": [],
  "test_check_estimator": [
    "estimator",
    "check"
  ],
  "__version__": [],
  "ThresholdFilter": {
    "__init__": [
      "self",
      "anomaly_detector",
      "threshold",
      "protect_anomaly_detector"
    ],
    "classify": [
      "self",
      "score"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "QuantileFilter": {
    "__init__": [
      "self",
      "anomaly_detector",
      "q",
      "protect_anomaly_detector"
    ],
    "q": [
      "self"
    ],
    "classify": [
      "self",
      "score"
    ],
    "learn_one": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "OneClassSVM": {
    "__init__": [
      "self",
      "nu",
      "optimizer",
      "intercept_lr",
      "clip_gradient",
      "initializer"
    ],
    "_get_intercept_update": [
      "self",
      "loss_gradient"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X"
    ],
    "score_one": [
      "self",
      "x"
    ]
  },
  "test_incremental_lof_scores": [],
  "test_batch_lof_scores": [],
  "test_issue_1328": [],
  "test_issue_1331": [],
  "AnomalyDetector": {
    "_supervised": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "score_one": [
      "self",
      "x"
    ]
  },
  "SupervisedAnomalyDetector": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "score_one": [
      "self",
      "x",
      "y"
    ]
  },
  "AnomalyFilter": {
    "__init__": [
      "self",
      "anomaly_detector",
      "protect_anomaly_detector"
    ],
    "_wrapped_model": [
      "self"
    ],
    "classify": [
      "self",
      "score"
    ],
    "score_one": [
      "self"
    ],
    "learn_one": [
      "self"
    ]
  },
  "StandardAbsoluteDeviation": {
    "__init__": [
      "self",
      "sub_stat"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "score_one": [
      "self",
      "x",
      "y"
    ]
  },
  "PredictiveAnomalyDetection": {
    "__init__": [
      "self",
      "predictive_model",
      "horizon",
      "n_std",
      "warmup_period"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "score_one": [
      "self",
      "x",
      "y"
    ]
  },
  "GaussianScorer": {
    "__init__": [
      "self",
      "window_size",
      "grace_period"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "score_one": [
      "self",
      "x",
      "y"
    ]
  },
  "tests": [],
  "test_sklearn_coherence": [
    "river_params",
    "sklearn_params"
  ],
  "HSTBranch": {
    "__init__": [
      "self",
      "left",
      "right",
      "feature",
      "threshold",
      "l_mass",
      "r_mass"
    ],
    "left": [
      "self"
    ],
    "right": [
      "self"
    ],
    "next": [
      "self",
      "x"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_split": [
      "self"
    ]
  },
  "HSTLeaf": {
    "__repr__": [
      "self"
    ]
  },
  "make_padded_tree": [
    "limits",
    "height",
    "padding",
    "rng"
  ],
  "HalfSpaceTrees": {
    "__init__": [
      "self",
      "n_trees",
      "height",
      "window_size",
      "limits",
      "seed"
    ],
    "size_limit": [
      "self"
    ],
    "_max_score": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "score_one": [
      "self",
      "x"
    ]
  },
  "check_equal": [
    "x_list",
    "y_list"
  ],
  "expand_objects": [
    "new_particles",
    "x_list",
    "neighborhoods",
    "rev_neighborhoods",
    "k_dist",
    "reach_dist",
    "dist_dict",
    "local_reach",
    "lof"
  ],
  "define_sets": [
    "nm",
    "neighborhoods",
    "rev_neighborhoods"
  ],
  "calc_reach_dist_new_points": [
    "set_index",
    "neighborhoods",
    "rev_neighborhoods",
    "reach_dist",
    "dist_dict",
    "k_dist"
  ],
  "calc_reach_dist_other_points": [
    "set_index",
    "rev_neighborhoods",
    "reach_dist",
    "dist_dict",
    "k_dist"
  ],
  "calc_local_reach_dist": [
    "set_index",
    "neighborhoods",
    "reach_dist",
    "local_reach_dist"
  ],
  "calc_lof": [
    "set_index",
    "neighborhoods",
    "local_reach",
    "lof"
  ],
  "LocalOutlierFactor": {
    "__init__": [
      "self",
      "n_neighbors",
      "distance_func"
    ],
    "learn_many": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "learn": [
      "self",
      "x_batch"
    ],
    "score_one": [
      "self",
      "x"
    ],
    "_initial_calculations": [
      "self",
      "x_list",
      "nm",
      "neighborhoods",
      "rev_neighborhoods",
      "k_distances",
      "dist_dict"
    ]
  },
  "test_missing_features": [],
  "BasePA": {
    "__init__": [
      "self",
      "C",
      "mode",
      "learn_intercept"
    ],
    "_calc_tau_0": [
      "cls",
      "x",
      "loss"
    ],
    "_calc_tau_1": [
      "self",
      "x",
      "loss"
    ],
    "_calc_tau_2": [
      "self",
      "x",
      "loss"
    ]
  },
  "PARegressor": {
    "__init__": [
      "self",
      "C",
      "mode",
      "eps",
      "learn_intercept"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "PAClassifier": {
    "__init__": [
      "self",
      "C",
      "mode",
      "learn_intercept"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "LogisticRegression": {
    "__init__": [
      "self",
      "optimizer",
      "loss",
      "l2",
      "l1",
      "intercept_init",
      "intercept_lr",
      "clip_gradient",
      "initializer"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ]
  },
  "ALMAClassifier": {
    "__init__": [
      "self",
      "p",
      "alpha",
      "B",
      "C"
    ],
    "_raw_dot": [
      "self",
      "x"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "GLM": {
    "__init__": [
      "self",
      "optimizer",
      "loss",
      "l2",
      "l1",
      "intercept_init",
      "intercept_lr",
      "clip_gradient",
      "initializer"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "weights": [
      "self"
    ],
    "_learn_mode": [
      "self",
      "mask"
    ],
    "_get_intercept_update": [
      "self",
      "loss_gradient"
    ],
    "_fit": [
      "self",
      "x",
      "y",
      "w",
      "get_grad"
    ],
    "_update_weights": [
      "self",
      "x"
    ],
    "_raw_dot_one": [
      "self",
      "x"
    ],
    "_eval_gradient_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "_raw_dot_many": [
      "self",
      "X"
    ],
    "_eval_gradient_many": [
      "self",
      "X",
      "y",
      "w"
    ],
    "learn_many": [
      "self",
      "X",
      "y",
      "w"
    ]
  },
  "iter_perturbations": [
    "keys",
    "n"
  ],
  "test_finite_differences": [
    "lm",
    "dataset"
  ],
  "test_one_many_consistent": [],
  "test_shuffle_columns": [],
  "test_add_remove_columns": [],
  "ScikitLearnSquaredLoss": {
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "lin_reg_tests": [],
  "test_lin_reg_sklearn_coherence": [
    "river_params",
    "sklearn_params"
  ],
  "test_lin_reg_sklearn_learn_many_coherence": [
    "river_params",
    "sklearn_params"
  ],
  "log_reg_tests": [],
  "test_log_reg_sklearn_coherence": [
    "river_params",
    "sklearn_params"
  ],
  "perceptron_tests": [],
  "test_perceptron_sklearn_coherence": [
    "river_params",
    "sklearn_params"
  ],
  "test_lin_reg_sklearn_l1_non_regression": [],
  "test_log_reg_sklearn_l1_non_regression": [],
  "Perceptron": {
    "__init__": [
      "self",
      "l2",
      "clip_gradient",
      "initializer"
    ]
  },
  "SoftmaxRegression": {
    "__init__": [
      "self",
      "optimizer",
      "loss",
      "l2"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "LinearRegression": {
    "__init__": [
      "self",
      "optimizer",
      "loss",
      "l2",
      "l1",
      "intercept_init",
      "intercept_lr",
      "clip_gradient",
      "initializer"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "predict_many": [
      "self",
      "X"
    ],
    "debug_one": [
      "self",
      "x",
      "decimals"
    ]
  },
  "BayesianLinearRegression": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "smoothing"
    ],
    "_unit_test_skips": [
      "self"
    ],
    "_get_arrays": [
      "self",
      "features",
      "m",
      "ss",
      "ss_inv"
    ],
    "_set_arrays": [
      "self",
      "features",
      "m_arr",
      "ss_arr",
      "ss_inv_arr"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x",
      "with_dist"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "ComplementNB": {
    "__init__": [
      "self",
      "alpha"
    ],
    "_more_tags": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "p_class": [
      "self",
      "c"
    ],
    "p_class_many": [
      "self"
    ],
    "joint_log_likelihood": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "_feature_log_prob": [
      "self",
      "unknown",
      "columns"
    ],
    "joint_log_likelihood_many": [
      "self",
      "X"
    ]
  },
  "river_models": [],
  "sklearn_models": [],
  "yield_dataset": [],
  "yield_batch_dataset": [],
  "yield_unseen_data": [],
  "yield_batch_unseen_data": [],
  "test_learn_one_methods": [
    "model"
  ],
  "test_learn_many_vs_learn_one": [
    "model",
    "batch_model"
  ],
  "test_learn_many_not_fit": [
    "batch_model"
  ],
  "test_river_vs_sklearn": [
    "model",
    "sk_model",
    "bag"
  ],
  "BaseNB": {
    "joint_log_likelihood": [
      "self",
      "x"
    ],
    "joint_log_likelihood_many": [
      "self",
      "X"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "from_dict": [
    "data"
  ],
  "one_hot_encode": [
    "y"
  ],
  "MultinomialNB": {
    "__init__": [
      "self",
      "alpha"
    ],
    "_more_tags": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "classes_": [
      "self"
    ],
    "n_terms": [
      "self"
    ],
    "p_feature_given_class": [
      "self",
      "f",
      "c"
    ],
    "p_class": [
      "self",
      "c"
    ],
    "p_class_many": [
      "self"
    ],
    "joint_log_likelihood": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "_feature_log_prob": [
      "self",
      "columns",
      "known",
      "unknown"
    ],
    "joint_log_likelihood_many": [
      "self",
      "X"
    ]
  },
  "GaussianNB": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "p_class": [
      "self",
      "c"
    ],
    "joint_log_likelihood": [
      "self",
      "x"
    ],
    "joint_log_likelihood_many": [
      "self",
      "X"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "BernoulliNB": {
    "__init__": [
      "self",
      "alpha",
      "true_threshold"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "p_feature_given_class": [
      "self",
      "f",
      "c"
    ],
    "p_class": [
      "self",
      "c"
    ],
    "p_class_many": [
      "self"
    ],
    "joint_log_likelihood": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "_feature_log_prob": [
      "self",
      "columns"
    ],
    "joint_log_likelihood_many": [
      "self",
      "X"
    ]
  },
  "Activation": {
    "apply": [
      "self",
      "z"
    ],
    "gradient": [
      "self",
      "z"
    ]
  },
  "ReLU": {
    "apply": [
      "z"
    ],
    "gradient": [
      "z"
    ]
  },
  "Sigmoid": {
    "apply": [
      "z"
    ],
    "gradient": [
      "z"
    ]
  },
  "Identity": {
    "apply": [
      "z"
    ],
    "gradient": [
      "z"
    ]
  },
  "xavier_init": [
    "dims",
    "seed"
  ],
  "MLP": {
    "__init__": [
      "self",
      "hidden_dims",
      "activations",
      "loss",
      "optimizer",
      "seed"
    ],
    "n_layers": [
      "self"
    ],
    "_forward": [
      "self",
      "X"
    ],
    "_backward": [
      "self",
      "z",
      "a",
      "y"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "MLPRegressor": {
    "__init__": [
      "self",
      "hidden_dims",
      "activations",
      "loss",
      "optimizer",
      "seed"
    ],
    "_default_params": [
      "self"
    ],
    "predict_many": [
      "self",
      "X"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "MAE": {
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "test_cross_entropy": [],
  "CrossEntropy": {
    "_fmt": [],
    "bigger_is_better": [
      "self"
    ],
    "requires_labels": [
      "self"
    ],
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "FowlkesMallows": {
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "test_multi_fbeta": [],
  "test_rolling_multi_fbeta": [],
  "test_issue_1443": [],
  "test_confusion_and_other_metrics": [],
  "Precision": {
    "get": [
      "self"
    ]
  },
  "MacroPrecision": {
    "get": [
      "self"
    ]
  },
  "MicroPrecision": {
    "get": [
      "self"
    ]
  },
  "WeightedPrecision": {
    "get": [
      "self"
    ]
  },
  "load_metrics": [],
  "test_pickling": [
    "metric"
  ],
  "test_repr": [
    "metric"
  ],
  "generate_test_cases": [
    "metric",
    "n"
  ],
  "partial": [
    "f"
  ],
  "roc_auc_score": [
    "y_true",
    "y_score"
  ],
  "TEST_CASES": [],
  "test_metric": [
    "metric",
    "sk_metric"
  ],
  "test_rolling_metric": [
    "metric",
    "sk_metric"
  ],
  "test_compose": [],
  "Metric": {
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "works_with_weights": [
      "self"
    ],
    "is_better_than": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ClassificationMetric": {
    "_fmt": [],
    "__init__": [
      "self",
      "cm"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "requires_labels": [
      "self"
    ],
    "_clamp_proba": [
      "p"
    ],
    "__add__": [
      "self",
      "other"
    ]
  },
  "BinaryMetric": {
    "__init__": [
      "self",
      "cm",
      "pos_val"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ]
  },
  "MultiClassMetric": {
    "works_with": [
      "self",
      "model"
    ]
  },
  "RegressionMetric": {
    "_fmt": [],
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "__add__": [
      "self",
      "other"
    ]
  },
  "Metrics": {
    "__init__": [
      "self",
      "metrics",
      "str_sep"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with_weights": [
      "self"
    ],
    "requires_labels": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "clone": [
      "self"
    ]
  },
  "WrapperMetric": {
    "_fmt": [
      "self"
    ],
    "metric": [
      "self"
    ],
    "get": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "requires_labels": [
      "self"
    ],
    "__metaclass__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MeanMetric": {
    "__init__": [
      "self"
    ],
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ]
  },
  "ClusteringMetric": {
    "_fmt": [],
    "update": [
      "self",
      "x",
      "y_pred",
      "centers",
      "w"
    ],
    "revert": [
      "self",
      "x",
      "y_pred",
      "centers",
      "w"
    ],
    "get": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SMAPE": {
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get": [
      "self"
    ]
  },
  "BalancedAccuracy": {
    "get": [
      "self"
    ]
  },
  "ClassificationReport": {
    "__init__": [
      "self",
      "decimals",
      "cm"
    ],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ROCAUC": {
    "__init__": [
      "self",
      "n_thresholds",
      "pos_val"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "requires_labels": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "GeometricMean": {
    "get": [
      "self"
    ]
  },
  "Recall": {
    "get": [
      "self"
    ]
  },
  "MacroRecall": {
    "get": [
      "self"
    ]
  },
  "MicroRecall": {},
  "WeightedRecall": {
    "get": [
      "self"
    ]
  },
  "MSE": {
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "RMSE": {
    "get": [
      "self"
    ]
  },
  "RMSLE": {
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ]
  },
  "Homogeneity": {
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "Completeness": {
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "VBeta": {
    "__init__": [
      "self",
      "beta",
      "cm"
    ],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "Accuracy": {
    "get": [
      "self"
    ]
  },
  "Silhouette": {
    "__init__": [
      "self"
    ],
    "_find_distance_second_closest_center": [
      "centers",
      "x"
    ],
    "update": [
      "self",
      "x",
      "y_pred",
      "centers",
      "w"
    ],
    "revert": [
      "self",
      "x",
      "y_pred",
      "centers",
      "w"
    ],
    "get": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ]
  },
  "RollingROCAUC": {
    "__init__": [
      "self",
      "window_size",
      "pos_val"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred"
    ],
    "requires_labels": [
      "self"
    ],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "test_r2": [],
  "test_rolling_r2": [],
  "ConfusionMatrix": {
    "__init__": [
      "self",
      "classes"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "_update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "classes": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "support": [
      "self",
      "label"
    ],
    "true_positives": [
      "self",
      "label"
    ],
    "true_negatives": [
      "self",
      "label"
    ],
    "false_positives": [
      "self",
      "label"
    ],
    "false_negatives": [
      "self",
      "label"
    ],
    "total_true_positives": [
      "self"
    ],
    "total_true_negatives": [
      "self"
    ],
    "total_false_positives": [
      "self"
    ],
    "total_false_negatives": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "FBeta": {
    "__init__": [
      "self",
      "beta",
      "cm",
      "pos_val"
    ],
    "get": [
      "self"
    ]
  },
  "MacroFBeta": {
    "__init__": [
      "self",
      "beta",
      "cm"
    ],
    "get": [
      "self"
    ]
  },
  "MicroFBeta": {
    "__init__": [
      "self",
      "beta",
      "cm"
    ],
    "get": [
      "self"
    ]
  },
  "WeightedFBeta": {
    "__init__": [
      "self",
      "beta",
      "cm"
    ],
    "get": [
      "self"
    ]
  },
  "MultiFBeta": {
    "__init__": [
      "self",
      "betas",
      "weights",
      "cm"
    ],
    "get": [
      "self"
    ]
  },
  "F1": {
    "__init__": [
      "self",
      "cm",
      "pos_val"
    ]
  },
  "MacroF1": {
    "__init__": [
      "self",
      "cm"
    ]
  },
  "MicroF1": {
    "__init__": [
      "self",
      "cm"
    ]
  },
  "WeightedF1": {
    "__init__": [
      "self",
      "cm"
    ]
  },
  "LogLoss": {
    "_fmt": [],
    "bigger_is_better": [
      "self"
    ],
    "requires_labels": [
      "self"
    ],
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Jaccard": {
    "get": [
      "self"
    ]
  },
  "MacroJaccard": {
    "get": [
      "self"
    ]
  },
  "MicroJaccard": {
    "get": [
      "self"
    ]
  },
  "WeightedJaccard": {
    "get": [
      "self"
    ]
  },
  "MutualInfo": {
    "_fmt": [],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "NormalizedMutualInfo": {
    "_AVERAGE_MIN": [],
    "_AVERAGE_MAX": [],
    "_AVERAGE_GEOMETRIC": [],
    "_AVERAGE_ARITHMETIC": [],
    "_VALID_AVERAGE": [],
    "_fmt": [],
    "__init__": [
      "self",
      "cm",
      "average_method"
    ],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "AdjustedMutualInfo": {
    "_AVERAGE_MIN": [],
    "_AVERAGE_MAX": [],
    "_AVERAGE_GEOMETRIC": [],
    "_AVERAGE_ARITHMETIC": [],
    "_VALID_AVERAGE": [],
    "_fmt": [],
    "__init__": [
      "self",
      "cm",
      "average_method"
    ],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "_entropy": [
    "cm",
    "y_true"
  ],
  "_average_geometric": [
    "u",
    "v"
  ],
  "_average_arithmetic": [
    "u",
    "v"
  ],
  "test_log_loss": [],
  "MAPE": {
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get": [
      "self"
    ]
  },
  "MCC": {
    "_fmt": [],
    "get": [
      "self"
    ]
  },
  "_pair_confusion": [
    "cm"
  ],
  "Rand": {
    "_fmt": [],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "AdjustedRand": {
    "_fmt": [],
    "works_with_weights": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "R2": {
    "__init__": [
      "self"
    ],
    "bigger_is_better": [
      "self"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ]
  },
  "CohenKappa": {
    "get": [
      "self"
    ]
  },
  "SampleAverage": {
    "__init__": [
      "self",
      "metric"
    ],
    "metric": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ]
  },
  "MultiOutputMetric": {},
  "MultiOutputClassificationMetric": {
    "_fmt": [],
    "__init__": [
      "self",
      "cm"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "bigger_is_better": [
      "self"
    ],
    "requires_labels": [
      "self"
    ]
  },
  "MultiOutputRegressionMetric": {
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "bigger_is_better": [
      "self"
    ]
  },
  "test_multiout_binary_clf": [
    "metric",
    "sk_metric"
  ],
  "test_multiout_regression": [
    "metric",
    "sk_metric"
  ],
  "PerOutput": {
    "__init__": [
      "self",
      "metric"
    ],
    "metric": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MicroAverage": {
    "__init__": [
      "self",
      "metric"
    ],
    "metric": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ]
  },
  "MultiLabelConfusionMatrix": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MacroAverage": {
    "__init__": [
      "self",
      "metric"
    ],
    "metric": [
      "self"
    ],
    "works_with": [
      "self",
      "model"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "revert": [
      "self",
      "y_true",
      "y_pred",
      "w"
    ],
    "get": [
      "self"
    ]
  },
  "ExactMatch": {
    "_eval": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "convert_sklearn_to_river": [
    "estimator",
    "classes"
  ],
  "SKL2RiverBase": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_align_dict": [
      "self",
      "x"
    ],
    "_align_df": [
      "self",
      "X"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "SKL2RiverRegressor": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "SKL2RiverClassifier": {
    "__init__": [
      "self",
      "estimator",
      "classes"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "test_river_to_sklearn_check_estimator": [
    "estimator"
  ],
  "test_sklearn_check_twoway": [],
  "test_not_fitted_still_works_regression": [
    "estimator"
  ],
  "test_not_fitted_still_works_classification": [
    "estimator",
    "n_classes"
  ],
  "SKLEARN_INPUT_X_PARAMS": [],
  "SKLEARN_INPUT_Y_PARAMS": [],
  "convert_river_to_sklearn": [
    "estimator"
  ],
  "River2SKLBase": {
    "_wrapped_model": [
      "self"
    ],
    "_required_parameters": []
  },
  "River2SKLRegressor": {
    "__init__": [
      "self",
      "river_estimator"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "River2SKLClassifier": {
    "__init__": [
      "self",
      "river_estimator"
    ],
    "_more_tags": [
      "self"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "River2SKLTransformer": {
    "__init__": [
      "self",
      "river_estimator"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "River2SKLClusterer": {
    "__init__": [
      "self",
      "river_estimator"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "ChebyshevUnderSampler": {
    "__init__": [
      "self",
      "regressor",
      "sp",
      "seed"
    ],
    "_wrapped_model": [
      "self"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "ChebyshevOverSampler": {
    "__init__": [
      "self",
      "regressor"
    ],
    "_wrapped_model": [
      "self"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "Triplet": {
    "__lt__": [
      "self",
      "other"
    ]
  },
  "HardSampling": {
    "__init__": [
      "self",
      "model",
      "loss",
      "size",
      "p",
      "seed"
    ],
    "_wrapped_model": [
      "self"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_model_pred_func": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "HardSamplingRegressor": {
    "__init__": [
      "self",
      "regressor",
      "size",
      "p",
      "loss",
      "seed"
    ],
    "regressor": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "HardSamplingClassifier": {
    "__init__": [
      "self",
      "classifier",
      "size",
      "p",
      "loss",
      "seed"
    ],
    "classifier": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "ClassificationSampler": {
    "__init__": [
      "self",
      "classifier",
      "seed"
    ],
    "_wrapped_model": [
      "self"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "RandomUnderSampler": {
    "__init__": [
      "self",
      "classifier",
      "desired_dist",
      "seed"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "RandomOverSampler": {
    "__init__": [
      "self",
      "classifier",
      "desired_dist",
      "seed"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "RandomSampler": {
    "__init__": [
      "self",
      "classifier",
      "desired_dist",
      "sampling_rate",
      "seed"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "TREC07": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "PipeCSVDialect": {
    "delimiter": []
  },
  "WebTraffic": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "AirlinePassengers": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Insects": {
    "variant_sizes": [],
    "variants": [],
    "__init__": [
      "self",
      "variant"
    ],
    "_iter": [
      "self"
    ],
    "_repr_content": [
      "self"
    ]
  },
  "Restaurants": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "REG": [],
  "BINARY_CLF": [],
  "MULTI_CLF": [],
  "MO_BINARY_CLF": [],
  "MO_REG": [],
  "get_data_home": [],
  "Dataset": {
    "__init__": [
      "self",
      "task",
      "n_features",
      "n_samples",
      "n_classes",
      "n_outputs",
      "sparse"
    ],
    "__iter__": [
      "self"
    ],
    "take": [
      "self",
      "k"
    ],
    "desc": [
      "self"
    ],
    "_repr_content": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SyntheticDataset": {
    "__repr__": [
      "self"
    ],
    "_get_params": [
      "self"
    ]
  },
  "FileDataset": {
    "__init__": [
      "self",
      "filename",
      "directory"
    ],
    "path": [
      "self"
    ],
    "_repr_content": [
      "self"
    ]
  },
  "RemoteDataset": {
    "__init__": [
      "self",
      "url",
      "size",
      "unpack",
      "filename"
    ],
    "path": [
      "self"
    ],
    "download": [
      "self",
      "force",
      "verbose"
    ],
    "_iter": [
      "self"
    ],
    "is_downloaded": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "_repr_content": [
      "self"
    ]
  },
  "Elec2": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "MovieLens100K": {
    "__init__": [
      "self",
      "unpack_user_and_item"
    ],
    "_iter": [
      "self"
    ]
  },
  "Bananas": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "TrumpApproval": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Music": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "_docs_overview": [
    "print"
  ],
  "MaliciousURL": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "Bikes": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "Higgs": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "ChickWeights": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Phishing": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "HTTP": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "SMTP": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "Keystroke": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "WaterFlow": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "ImageSegments": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "SMSSpam": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "SolarFlare": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Taxis": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "_iter_datasets": [],
  "test_remote_url": [
    "dataset"
  ],
  "test_dimensions": [
    "dataset"
  ],
  "_iter_synth_datasets": [],
  "test_synth_idempotent": [
    "dataset"
  ],
  "test_synth_non_idempotent": [
    "dataset"
  ],
  "test_synth_pausable": [
    "dataset"
  ],
  "CreditCard": {
    "__init__": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "SEA": {
    "__init__": [
      "self",
      "variant",
      "noise",
      "seed"
    ],
    "__iter__": [
      "self"
    ],
    "_repr_content": [
      "self"
    ]
  },
  "Waveform": {
    "_N_CLASSES": [],
    "_N_BASE_FEATURES": [],
    "_N_FEATURES_INCLUDING_NOISE": [],
    "_H_FUNCTION": [],
    "__init__": [
      "self",
      "seed",
      "has_noise"
    ],
    "__iter__": [
      "self"
    ]
  },
  "LED": {
    "_N_RELEVANT_FEATURES": [],
    "_N_FEATURES_INCLUDING_NOISE": [],
    "_ORIGINAL_INSTANCES": [],
    "__init__": [
      "self",
      "seed",
      "noise_percentage",
      "irrelevant_features"
    ],
    "__iter__": [
      "self"
    ]
  },
  "LEDDrift": {
    "_N_IRRELEVANT_ATTRIBUTES": [],
    "__init__": [
      "self",
      "seed",
      "noise_percentage",
      "irrelevant_features",
      "n_drift_features"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Logical": {
    "__init__": [
      "self",
      "n_tiles",
      "shuffle",
      "seed"
    ],
    "__iter__": [
      "self"
    ],
    "_make_logical": [
      "self",
      "n_tiles",
      "shuffle"
    ]
  },
  "AnomalySine": {
    "__init__": [
      "self",
      "n_samples",
      "n_anomalies",
      "contextual",
      "n_contextual",
      "shift",
      "noise",
      "replace",
      "seed"
    ],
    "_generate_data": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "RandomRBF": {
    "__init__": [
      "self",
      "seed_model",
      "seed_sample",
      "n_classes",
      "n_features",
      "n_centroids"
    ],
    "__iter__": [
      "self"
    ],
    "_generate_sample": [
      "self",
      "rng_sample"
    ],
    "_generate_centroids": [
      "self"
    ]
  },
  "RandomRBFDrift": {
    "__init__": [
      "self",
      "seed_model",
      "seed_sample",
      "n_classes",
      "n_features",
      "n_centroids",
      "change_speed",
      "n_drift_centroids"
    ],
    "__iter__": [
      "self"
    ],
    "_generate_centroids": [
      "self"
    ]
  },
  "Centroid": {
    "__init__": [
      "self"
    ]
  },
  "random_index_based_on_weights": [
    "weights",
    "rng"
  ],
  "Agrawal": {
    "__init__": [
      "self",
      "classification_function",
      "seed",
      "balance_classes",
      "perturbation"
    ],
    "__iter__": [
      "self"
    ],
    "_perturb_value": [
      "self",
      "val",
      "val_min",
      "val_max",
      "val_range"
    ],
    "generate_drift": [
      "self"
    ],
    "_classification_function_0": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_1": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_2": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_3": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_4": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_5": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_6": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_7": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_8": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ],
    "_classification_function_9": [
      "salary",
      "commission",
      "age",
      "elevel",
      "car",
      "zipcode",
      "hvalue",
      "hyears",
      "loan"
    ]
  },
  "Mv": {
    "__init__": [
      "self",
      "seed"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Planes2D": {
    "__init__": [
      "self",
      "seed"
    ],
    "__iter__": [
      "self"
    ]
  },
  "STAGGER": {
    "__init__": [
      "self",
      "classification_function",
      "seed",
      "balance_classes"
    ],
    "__iter__": [
      "self"
    ],
    "generate_drift": [
      "self"
    ],
    "_classification_function_zero": [
      "size",
      "color",
      "shape"
    ],
    "_classification_function_one": [
      "size",
      "color",
      "shape"
    ],
    "_classification_function_two": [
      "size",
      "color",
      "shape"
    ]
  },
  "Hyperplane": {
    "__init__": [
      "self",
      "seed",
      "n_features",
      "n_drift_features",
      "mag_change",
      "noise_percentage",
      "sigma"
    ],
    "__iter__": [
      "self"
    ],
    "_generate_drift": [
      "self"
    ]
  },
  "Friedman": {
    "__init__": [
      "self",
      "seed"
    ],
    "__iter__": [
      "self"
    ]
  },
  "FriedmanDrift": {
    "_LOCAL_EXPANDING_ABRUPT": [],
    "_GLOBAL_RECURRING_ABRUPT": [],
    "_GLOBAL_AND_SLOW_GRADUAL": [],
    "_VALID_DRIFT_TYPES": [],
    "__init__": [
      "self",
      "drift_type",
      "position",
      "transition_window",
      "seed"
    ],
    "__lea_in_r1": [
      "self",
      "x",
      "index"
    ],
    "__lea_in_r2": [
      "self",
      "x",
      "index"
    ],
    "_local_expanding_abrupt_gen": [
      "self",
      "x",
      "index"
    ],
    "_global_recurring_abrupt_gen": [
      "self",
      "x",
      "index"
    ],
    "_global_and_slow_gradual_gen": [
      "self",
      "x",
      "index",
      "rc"
    ],
    "__iter__": [
      "self"
    ]
  },
  "RandomTree": {
    "__init__": [
      "self",
      "seed_tree",
      "seed_sample",
      "n_classes",
      "n_num_features",
      "n_cat_features",
      "n_categories_per_feature",
      "max_tree_depth",
      "first_leaf_level",
      "fraction_leaves_per_level"
    ],
    "_generate_random_tree": [
      "self"
    ],
    "_generate_random_tree_node": [
      "self",
      "current_depth",
      "candidate_features",
      "min_numeric_value",
      "max_numeric_value",
      "rng"
    ],
    "_classify_instance": [
      "self",
      "node",
      "x"
    ],
    "__iter__": [
      "self"
    ]
  },
  "TreeNode": {
    "__init__": [
      "self",
      "class_label",
      "split_feature_idx",
      "split_feature_val"
    ]
  },
  "Sine": {
    "_N_BASE_FEATURES": [],
    "_N_FEATURES_INCLUDING_NOISE": [],
    "__init__": [
      "self",
      "classification_function",
      "seed",
      "balance_classes",
      "has_noise"
    ],
    "__iter__": [
      "self"
    ],
    "generate_drift": [
      "self"
    ],
    "_classification_function_zero": [
      "att1",
      "att2"
    ],
    "_classification_function_one": [
      "att1",
      "att2"
    ],
    "_classification_function_two": [
      "att1",
      "att2"
    ],
    "_classification_function_three": [
      "att1",
      "att2"
    ]
  },
  "ConceptDriftStream": {
    "__init__": [
      "self",
      "stream",
      "drift_stream",
      "position",
      "width",
      "seed",
      "alpha"
    ],
    "__iter__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Mixed": {
    "__init__": [
      "self",
      "classification_function",
      "seed",
      "balance_classes"
    ],
    "__iter__": [
      "self"
    ],
    "_classification_function_zero": [
      "v",
      "w",
      "x",
      "y"
    ],
    "_classification_function_one": [
      "v",
      "w",
      "x",
      "y"
    ],
    "generate_drift": [
      "self"
    ]
  },
  "Distribution": {
    "__init__": [
      "self",
      "seed"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "sample": [
      "self"
    ],
    "n_samples": [
      "self"
    ],
    "mode": [
      "self"
    ],
    "__gt__": [
      "self",
      "other"
    ]
  },
  "DiscreteDistribution": {
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ]
  },
  "BinaryDistribution": {
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ]
  },
  "ContinuousDistribution": {
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ]
  },
  "MultivariateContinuousDistribution": {
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ]
  },
  "test_univariate_multivariate_consistency": [
    "p"
  ],
  "Multinomial": {
    "__init__": [
      "self",
      "events",
      "seed"
    ],
    "n_samples": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "mode": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "sample": [
      "self"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Gaussian": {
    "__init__": [
      "self",
      "seed"
    ],
    "_from_state": [
      "cls",
      "n",
      "m",
      "sig",
      "ddof"
    ],
    "n_samples": [
      "self"
    ],
    "mu": [
      "self"
    ],
    "sigma": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "w"
    ],
    "revert": [
      "self",
      "x",
      "w"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self"
    ],
    "mode": [
      "self"
    ]
  },
  "MultivariateGaussian": {
    "__init__": [
      "self",
      "seed"
    ],
    "_from_state": [
      "cls",
      "n",
      "mean",
      "cov",
      "ddof",
      "seed"
    ],
    "n_samples": [
      "self"
    ],
    "mu": [
      "self"
    ],
    "var": [
      "self"
    ],
    "sigma": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self"
    ],
    "mode": [
      "self"
    ]
  },
  "_beta_func": [
    "a",
    "b"
  ],
  "Beta": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "seed"
    ],
    "n_samples": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "__call__": [
      "self",
      "p"
    ],
    "sample": [
      "self"
    ],
    "mode": [
      "self"
    ],
    "cdf": [
      "self",
      "x"
    ]
  },
  "Literal": {
    "__slots__": [],
    "__init__": [
      "self",
      "on",
      "at",
      "neg"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "describe": [
      "self"
    ]
  },
  "NumericLiteral": {
    "__init__": [
      "self",
      "on",
      "at",
      "neg"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "describe": [
      "self"
    ]
  },
  "NominalLiteral": {
    "__init__": [
      "self",
      "on",
      "at",
      "neg"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "describe": [
      "self"
    ]
  },
  "HoeffdingRule": {
    "__init__": [
      "self",
      "template_splitter",
      "split_criterion"
    ],
    "_hoeffding_bound": [
      "self",
      "r_heur",
      "delta"
    ],
    "statistics": [
      "self",
      "target_stats"
    ],
    "total_weight": [
      "self"
    ],
    "last_expansion_attempt_at": [
      "self"
    ],
    "expand": [
      "self",
      "delta",
      "tau"
    ],
    "covers": [
      "self",
      "x"
    ],
    "new_nominal_splitter": [
      "self"
    ],
    "_iter_features": [
      "self",
      "x"
    ],
    "_update_target_stats": [
      "self",
      "y",
      "w"
    ],
    "_update_feature_stats": [
      "self",
      "feat_name",
      "feat_val",
      "w"
    ],
    "update": [
      "self",
      "x",
      "y",
      "w"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MeanRegressor": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "AdaptiveRegressor": {
    "__init__": [
      "self",
      "model_predictor",
      "fading_factor"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "RegRule": {
    "__init__": [
      "self",
      "template_splitter",
      "split_criterion",
      "pred_model",
      "drift_detector"
    ],
    "new_nominal_splitter": [
      "self"
    ],
    "statistics": [
      "self",
      "target_stats"
    ],
    "_update_target_stats": [
      "self",
      "y",
      "w"
    ],
    "_update_feature_stats": [
      "self",
      "feat_name",
      "feat_val",
      "w"
    ],
    "drift_test": [
      "self",
      "y",
      "y_pred"
    ],
    "score_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "AMRules": {
    "_PRED_MEAN": [],
    "_PRED_MODEL": [],
    "_PRED_ADAPTIVE": [],
    "_VALID_PRED": [],
    "__init__": [
      "self",
      "n_min",
      "delta",
      "tau",
      "pred_type",
      "pred_model",
      "splitter",
      "drift_detector",
      "fading_factor",
      "anomaly_threshold",
      "m_min",
      "ordered_rule_set",
      "min_samples_split"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "n_drifts_detected": [
      "self"
    ],
    "_new_rule": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "anomaly_score": [
      "self",
      "x"
    ],
    "debug_one": [
      "self",
      "x"
    ]
  },
  "SDFT": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "Skyline": {
    "__init__": [
      "self",
      "minimize",
      "maximize"
    ],
    "_count_diffs": [
      "self",
      "a",
      "b"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "Bin": {
    "__slots__": [],
    "__init__": [
      "self",
      "left",
      "right",
      "count"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "coverage_ratio": [
    "x",
    "y"
  ],
  "Histogram": {
    "__init__": [
      "self",
      "max_bins"
    ],
    "update": [
      "self",
      "x"
    ],
    "_shrink": [
      "self",
      "k"
    ],
    "iter_cdf": [
      "self",
      "X",
      "verbose"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "Set": {
    "__init__": [
      "self",
      "capacity",
      "fp_rate",
      "seed"
    ],
    "n_hash": [
      "self"
    ],
    "n_bits": [
      "self"
    ],
    "_hash": [
      "self",
      "x"
    ],
    "add": [
      "self",
      "x"
    ],
    "update": [
      "self",
      "values"
    ],
    "__contains__": [
      "self",
      "x"
    ],
    "_is_mergeable": [
      "self",
      "other"
    ],
    "_check_mergeable": [
      "self",
      "other"
    ],
    "__iand__": [
      "self",
      "other"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__ior__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "intersection": [
      "self",
      "other"
    ],
    "union": [
      "self",
      "other"
    ]
  },
  "Counter": {
    "__init__": [
      "self",
      "epsilon",
      "delta",
      "seed"
    ],
    "_hash": [
      "self",
      "x"
    ],
    "__getitem__": [
      "self",
      "x"
    ],
    "__matmul__": [
      "self",
      "other"
    ],
    "__len__": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "w"
    ],
    "total": [
      "self"
    ],
    "n_slots": [
      "self"
    ],
    "n_tables": [
      "self"
    ]
  },
  "HeavyHitters": {
    "__init__": [
      "self",
      "support",
      "epsilon",
      "fading_factor"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "update": [
      "self",
      "x"
    ],
    "most_common": [
      "self",
      "n"
    ]
  },
  "AMFLearner": {
    "__init__": [
      "self",
      "n_estimators",
      "step",
      "loss",
      "use_aggregation",
      "split_pure",
      "seed"
    ],
    "_is_initialized": [
      "self"
    ],
    "_initialize_trees": [
      "self"
    ],
    "_min_number_of_models": [
      "self"
    ]
  },
  "AMFClassifier": {
    "__init__": [
      "self",
      "n_estimators",
      "step",
      "use_aggregation",
      "dirichlet",
      "split_pure",
      "seed"
    ],
    "_initialize_trees": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "AMFRegressor": {
    "__init__": [
      "self",
      "n_estimators",
      "step",
      "use_aggregation",
      "seed"
    ],
    "_initialize_trees": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "test_issue_1272": [],
  "Sampler": {
    "__call__": [
      "self",
      "rate",
      "rng"
    ]
  },
  "ConstantSampler": {
    "__call__": [
      "self",
      "rate",
      "rng"
    ]
  },
  "BaggingSampler": {
    "__call__": [
      "self",
      "rate",
      "rng"
    ]
  },
  "SubBaggingSampler": {
    "__call__": [
      "self",
      "rate",
      "rng"
    ]
  },
  "ExtraTrees": {
    "_FEATURES_SQRT": [],
    "_FEATURES_LOG2": [],
    "_FEATURES_RANDOM": [],
    "_BAGGING": [],
    "_SUBBAGGING": [],
    "_DETECTION_ALL": [],
    "_DETECTION_DROP": [],
    "_DETECTION_OFF": [],
    "__init__": [
      "self",
      "n_models",
      "max_features",
      "resampling_strategy",
      "resampling_rate",
      "detection_mode",
      "warning_detector",
      "drift_detector",
      "max_depth",
      "randomize_tree_depth",
      "track_metric",
      "disable_weighted_vote",
      "split_buffer_size",
      "seed"
    ],
    "_new_member": [
      "self",
      "max_features",
      "max_depth",
      "seed"
    ],
    "_drift_input": [
      "self",
      "y",
      "y_hat"
    ],
    "_calculate_tree_depth": [
      "self"
    ],
    "_calculate_max_features": [
      "self",
      "n_features"
    ],
    "_init_trees": [
      "self",
      "n_features"
    ],
    "__weight_sampler_factory": [
      "self"
    ],
    "_detection_mode_all": [
      "drift_detector",
      "warning_detector",
      "detector_input"
    ],
    "_detection_mode_drop": [
      "drift_detector",
      "warning_detector",
      "detector_input"
    ],
    "_detection_mode_off": [
      "drift_detector",
      "warning_detector",
      "detector_input"
    ],
    "__detection_mode_factory": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "n_warnings": [
      "self"
    ],
    "n_drifts": [
      "self"
    ],
    "n_tree_swaps": [
      "self"
    ],
    "total_instances": [
      "self"
    ],
    "instances_per_tree": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "ETRegressor": {
    "__init__": [
      "self",
      "max_features",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "split_buffer_size",
      "seed"
    ],
    "_new_learning_node": [
      "self",
      "initial_stats",
      "parent"
    ]
  },
  "OXTRegressor": {
    "__init__": [
      "self",
      "n_models",
      "max_features",
      "resampling_strategy",
      "resampling_rate",
      "detection_mode",
      "warning_detector",
      "drift_detector",
      "max_depth",
      "randomize_tree_depth",
      "track_metric",
      "disable_weighted_vote",
      "split_buffer_size",
      "seed",
      "grace_period",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_new_member": [
      "self",
      "max_features",
      "max_depth",
      "seed"
    ],
    "_drift_input": [
      "self",
      "y",
      "y_hat"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "BaseForest": {
    "_FEATURES_SQRT": [],
    "_FEATURES_LOG2": [],
    "__init__": [
      "self",
      "n_models",
      "max_features",
      "lambda_value",
      "drift_detector",
      "warning_detector",
      "metric",
      "disable_weighted_vote",
      "seed"
    ],
    "_min_number_of_models": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_unit_test_skips": [
      "self"
    ],
    "_drift_detector_input": [
      "self",
      "tree_id",
      "y_true",
      "y_pred"
    ],
    "_new_base_model": [
      "self"
    ],
    "n_warnings_detected": [
      "self",
      "tree_id"
    ],
    "n_drifts_detected": [
      "self",
      "tree_id"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_init_ensemble": [
      "self",
      "features"
    ],
    "_set_max_features": [
      "self",
      "n_features"
    ]
  },
  "BaseTreeClassifier": {
    "__init__": [
      "self",
      "max_features",
      "grace_period",
      "max_depth",
      "split_criterion",
      "delta",
      "tau",
      "leaf_prediction",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "rng"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ]
  },
  "BaseTreeRegressor": {
    "__init__": [
      "self",
      "max_features",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "splitter",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "rng"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ]
  },
  "ARFClassifier": {
    "__init__": [
      "self",
      "n_models",
      "max_features",
      "lambda_value",
      "metric",
      "disable_weighted_vote",
      "drift_detector",
      "warning_detector",
      "grace_period",
      "max_depth",
      "split_criterion",
      "delta",
      "tau",
      "leaf_prediction",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_new_base_model": [
      "self"
    ],
    "_drift_detector_input": [
      "self",
      "tree_id",
      "y_true",
      "y_pred"
    ]
  },
  "ARFRegressor": {
    "_MEAN": [],
    "_MEDIAN": [],
    "_VALID_AGGREGATION_METHOD": [],
    "__init__": [
      "self",
      "n_models",
      "max_features",
      "aggregation_method",
      "lambda_value",
      "metric",
      "disable_weighted_vote",
      "drift_detector",
      "warning_detector",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "splitter",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_new_base_model": [
      "self"
    ],
    "_drift_detector_input": [
      "self",
      "tree_id",
      "y_true",
      "y_pred"
    ],
    "valid_aggregation_method": [
      "self"
    ]
  },
  "ActiveLearningClassifier": {
    "__init__": [
      "self",
      "classifier",
      "seed"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_ask_for_label": [
      "self",
      "x",
      "y_pred"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "EntropySampler": {
    "__init__": [
      "self",
      "classifier",
      "discount_factor",
      "seed"
    ],
    "_p": [
      "self",
      "y_pred"
    ],
    "_ask_for_label": [
      "self",
      "x",
      "y_pred"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "ExtremelyFastDecisionTreeClassifier": {
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "min_samples_reevaluate",
      "split_criterion",
      "delta",
      "tau",
      "leaf_prediction",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "_branch_selector": [
      "self",
      "numerical_feature",
      "multiway_split"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_sort_to_leaf": [
      "self",
      "x",
      "y",
      "w"
    ],
    "_process_nodes": [
      "self",
      "x",
      "y",
      "w",
      "node",
      "parent",
      "branch_index"
    ],
    "_reevaluate_best_split": [
      "self",
      "node",
      "parent",
      "branch_index"
    ],
    "_attempt_to_split": [
      "self",
      "node",
      "parent",
      "branch_index"
    ],
    "_kill_subtree": [
      "self",
      "node"
    ]
  },
  "get_classification_data": [],
  "get_regression_data": [],
  "test_memory_usage_class": [
    "dataset",
    "model"
  ],
  "test_memory_usage_reg": [
    "dataset",
    "model"
  ],
  "test_memory_usage_multitarget": [],
  "test_efdt_split_reevaluation": [],
  "test_drift_adaptation_hatc": [],
  "test_drift_adaptation_hatr": [],
  "Loss": {
    "compute_derivatives": [
      "self",
      "y_true",
      "y_pred"
    ],
    "transfer": [
      "self",
      "y"
    ]
  },
  "BinaryCrossEntropyLoss": {
    "compute_derivatives": [
      "self",
      "y_true",
      "y_pred"
    ],
    "transfer": [
      "self",
      "y"
    ]
  },
  "SquaredErrorLoss": {
    "compute_derivatives": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "HoeffdingAdaptiveTreeClassifier": {
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "split_criterion",
      "delta",
      "tau",
      "leaf_prediction",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "bootstrap_sampling",
      "drift_window_threshold",
      "drift_detector",
      "switch_significance",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "n_alternate_trees": [
      "self"
    ],
    "n_pruned_alternate_trees": [
      "self"
    ],
    "n_switch_alternate_trees": [
      "self"
    ],
    "summary": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "_branch_selector": [
      "self",
      "numerical_feature",
      "multiway_split"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "Branch": {
    "__init__": [
      "self"
    ],
    "next": [
      "self",
      "x"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_split": [
      "self"
    ],
    "walk": [
      "self",
      "x",
      "until_leaf"
    ],
    "traverse": [
      "self",
      "x",
      "until_leaf"
    ],
    "n_nodes": [
      "self"
    ],
    "n_branches": [
      "self"
    ],
    "n_leaves": [
      "self"
    ],
    "height": [
      "self"
    ],
    "iter_dfs": [
      "self"
    ],
    "iter_bfs": [
      "self"
    ],
    "iter_leaves": [
      "self"
    ],
    "iter_branches": [
      "self"
    ],
    "iter_edges": [
      "self"
    ],
    "to_dataframe": [
      "self"
    ],
    "_repr_html_": [
      "self"
    ]
  },
  "Leaf": {
    "__init__": [
      "self"
    ],
    "walk": [
      "self",
      "x",
      "until_leaf"
    ],
    "__repr__": [
      "self"
    ],
    "n_nodes": [
      "self"
    ],
    "n_branches": [
      "self"
    ],
    "n_leaves": [
      "self"
    ],
    "height": [
      "self"
    ],
    "iter_dfs": [
      "self"
    ],
    "iter_leaves": [
      "self"
    ],
    "iter_branches": [
      "self"
    ],
    "iter_edges": [
      "self"
    ]
  },
  "HoeffdingTreeClassifier": {
    "_GINI_SPLIT": [],
    "_INFO_GAIN_SPLIT": [],
    "_HELLINGER_SPLIT": [],
    "_VALID_SPLIT_CRITERIA": [],
    "_MAJORITY_CLASS": [],
    "_NAIVE_BAYES": [],
    "_NAIVE_BAYES_ADAPTIVE": [],
    "_VALID_LEAF_PREDICTION": [],
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "split_criterion",
      "delta",
      "tau",
      "leaf_prediction",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "split_criterion": [
      "self",
      "split_criterion"
    ],
    "leaf_prediction": [
      "self",
      "leaf_prediction"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "_new_split_criterion": [
      "self"
    ],
    "_attempt_to_split": [
      "self",
      "leaf",
      "parent",
      "parent_branch"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "do_naive_bayes_prediction": [
    "x",
    "observed_class_distribution",
    "splitters"
  ],
  "BranchFactory": {
    "assemble": [
      "self",
      "branch",
      "stats",
      "depth"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "GradHess": {
    "__slots__": [],
    "__init__": [
      "self",
      "gradient",
      "hessian"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__isub__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ]
  },
  "GradHessMerit": {
    "__lt__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "GradHessStats": {
    "__init__": [
      "self"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__isub__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ],
    "update": [
      "self",
      "gh",
      "w"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "covariance": [
      "self"
    ],
    "total_weight": [
      "self"
    ],
    "delta_loss_mean_var": [
      "self",
      "delta_pred"
    ]
  },
  "calculate_object_size": [
    "obj",
    "unit"
  ],
  "add_dict_values": [
    "dict_a",
    "dict_b",
    "inplace"
  ],
  "round_sig_fig": [
    "x",
    "significant_digits"
  ],
  "configuration": [
    "parent_package",
    "top_path"
  ],
  "LASTClassifier": {
    "__init__": [
      "self",
      "max_depth",
      "split_criterion",
      "leaf_prediction",
      "change_detector",
      "track_error",
      "nb_threshold",
      "nominal_attributes",
      "splitter",
      "binary_split",
      "min_branch_fraction",
      "max_share_to_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "_new_split_criterion": [
      "self"
    ],
    "_attempt_to_split": [
      "self",
      "leaf",
      "parent",
      "parent_branch"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "HoeffdingAdaptiveTreeRegressor": {
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "splitter",
      "min_samples_split",
      "bootstrap_sampling",
      "drift_window_threshold",
      "drift_detector",
      "switch_significance",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "n_alternate_trees": [
      "self"
    ],
    "n_pruned_alternate_trees": [
      "self"
    ],
    "n_switch_alternate_trees": [
      "self"
    ],
    "summary": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent",
      "is_active"
    ],
    "_branch_selector": [
      "self",
      "numerical_feature",
      "multiway_split"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "iSOUPTreeRegressor": {
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "splitter",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "split_criterion": [
      "self",
      "split_criterion"
    ],
    "_new_split_criterion": [
      "self"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "test_class_splitter": [
    "dataset",
    "splitter"
  ],
  "test_reg_splitter": [
    "dataset",
    "splitter"
  ],
  "test_nominal_reg_splitter": [],
  "StochasticGradientTree": {
    "__init__": [
      "self",
      "loss_func",
      "delta",
      "grace_period",
      "init_pred",
      "max_depth",
      "lambda_value",
      "gamma",
      "nominal_attributes",
      "feature_quantizer"
    ],
    "_target_transform": [
      "self",
      "y"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_compute_p_value": [
      "merit",
      "n_observations"
    ],
    "n_splits": [
      "self"
    ],
    "n_node_updates": [
      "self"
    ],
    "n_observations": [
      "self"
    ],
    "height": [
      "self"
    ],
    "n_nodes": [
      "self"
    ],
    "n_branches": [
      "self"
    ],
    "n_leaves": [
      "self"
    ]
  },
  "SGTClassifier": {
    "__init__": [
      "self",
      "delta",
      "grace_period",
      "init_pred",
      "max_depth",
      "lambda_value",
      "gamma",
      "nominal_attributes",
      "feature_quantizer"
    ],
    "_target_transform": [
      "self",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "SGTRegressor": {
    "__init__": [
      "self",
      "delta",
      "grace_period",
      "init_pred",
      "max_depth",
      "lambda_value",
      "gamma",
      "nominal_attributes",
      "feature_quantizer"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "HoeffdingTree": {
    "__init__": [
      "self",
      "max_depth",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_hoeffding_bound": [
      "range_val",
      "confidence",
      "n"
    ],
    "max_size": [
      "self",
      "size"
    ],
    "height": [
      "self"
    ],
    "n_nodes": [
      "self"
    ],
    "n_branches": [
      "self"
    ],
    "n_leaves": [
      "self"
    ],
    "n_active_leaves": [
      "self"
    ],
    "n_inactive_leaves": [
      "self"
    ],
    "summary": [
      "self"
    ],
    "to_dataframe": [
      "self"
    ],
    "_branch_selector": [
      "self",
      "numerical_feature",
      "multiway_split"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "split_criterion": [
      "self",
      "split_criterion"
    ],
    "leaf_prediction": [
      "self",
      "leaf_prediction"
    ],
    "_enforce_size_limit": [
      "self"
    ],
    "_estimate_model_size": [
      "self"
    ],
    "_deactivate_all_leaves": [
      "self"
    ],
    "_find_leaves": [
      "self"
    ],
    "debug_one": [
      "self",
      "x"
    ],
    "draw": [
      "self",
      "max_depth"
    ]
  },
  "_color_brew": [
    "n"
  ],
  "transparency_hex": [
    "color",
    "alpha"
  ],
  "tree_to_html": [
    "tree"
  ],
  "CSS": [],
  "BinaryBranch": {
    "__init__": [
      "self",
      "left",
      "right",
      "threshold"
    ],
    "next": [
      "self",
      "x"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_split": [
      "self"
    ]
  },
  "test_size": [],
  "test_height": [],
  "test_iter_dfs": [],
  "test_iter_bfs": [],
  "test_iter_leaves": [],
  "test_iter_branches": [],
  "test_iter_edges": [],
  "HoeffdingTreeRegressor": {
    "_TARGET_MEAN": [],
    "_MODEL": [],
    "_ADAPTIVE": [],
    "_VALID_LEAF_PREDICTION": [],
    "__init__": [
      "self",
      "grace_period",
      "max_depth",
      "delta",
      "tau",
      "leaf_prediction",
      "leaf_model",
      "model_selector_decay",
      "nominal_attributes",
      "splitter",
      "min_samples_split",
      "binary_split",
      "max_size",
      "memory_estimate_period",
      "stop_mem_management",
      "remove_poor_attrs",
      "merit_preprune"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "leaf_prediction": [
      "self",
      "leaf_prediction"
    ],
    "split_criterion": [
      "self",
      "split_criterion"
    ],
    "_new_split_criterion": [
      "self"
    ],
    "_new_leaf": [
      "self",
      "initial_stats",
      "parent"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_attempt_to_split": [
      "self",
      "leaf",
      "parent",
      "parent_branch"
    ]
  },
  "SplitCriterion": {
    "__init__": [
      "self"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ]
  },
  "HellingerDistanceCriterion": {
    "__init__": [
      "self",
      "min_branch_fraction"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "compute_hellinger": [
      "dist"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ],
    "num_subsets_greater_than_frac": [
      "distributions",
      "min_frac"
    ]
  },
  "GiniSplitCriterion": {
    "__init__": [
      "self",
      "min_branch_fraction"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "compute_gini": [
      "dist",
      "dist_sum_of_weights"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ],
    "num_subsets_greater_than_frac": [
      "distributions",
      "min_frac"
    ]
  },
  "VarianceReductionSplitCriterion": {
    "__init__": [
      "self",
      "min_samples_split"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "compute_var": [
      "dist"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ]
  },
  "IntraClusterVarianceReductionSplitCriterion": {
    "__init__": [
      "self",
      "min_samples_split"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "compute_var": [
      "dist"
    ]
  },
  "VarianceRatioSplitCriterion": {
    "__init__": [
      "self",
      "min_samples_split"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "compute_var": [
      "dist"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ],
    "select_best_branch": [
      "children_stats"
    ]
  },
  "InfoGainSplitCriterion": {
    "__init__": [
      "self",
      "min_branch_fraction"
    ],
    "merit_of_split": [
      "self",
      "pre_split_dist",
      "post_split_dist"
    ],
    "range_of_merit": [
      "pre_split_dist"
    ],
    "compute_entropy": [
      "self",
      "dist"
    ],
    "current_merit": [
      "self",
      "dist"
    ],
    "_compute_entropy_dict": [
      "dist"
    ],
    "_compute_entropy_list": [
      "self",
      "dists"
    ],
    "num_subsets_greater_than_frac": [
      "distributions",
      "min_frac"
    ]
  },
  "Splitter": {
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "is_numeric": [
      "self"
    ],
    "is_target_class": [
      "self"
    ]
  },
  "Quantizer": {
    "__len__": [
      "self"
    ],
    "update": [
      "self",
      "x_val",
      "gh",
      "w"
    ],
    "__iter__": [
      "self"
    ]
  },
  "GaussianSplitter": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "_split_point_suggestions": [
      "self"
    ],
    "_class_dists_from_binary_split": [
      "self",
      "split_value"
    ]
  },
  "RandomSplitter": {
    "__init__": [
      "self",
      "seed",
      "buffer_size"
    ],
    "clone": [
      "self",
      "new_params",
      "include_attributes"
    ],
    "_update_stats": [
      "self",
      "branch",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "class_val"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ]
  },
  "RegRandomSplitter": {
    "__init__": [
      "self",
      "seed",
      "buffer_size"
    ],
    "_update_stats": [
      "self",
      "branch",
      "target_val",
      "w"
    ],
    "is_target_class": [
      "self"
    ]
  },
  "DynamicQuantizer": {
    "__init__": [
      "self",
      "radius",
      "std_prop"
    ],
    "update": [
      "self",
      "x_val",
      "gh",
      "w"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "k"
    ],
    "__iter__": [
      "self"
    ],
    "_get_params": [
      "self"
    ]
  },
  "StaticQuantizer": {
    "__init__": [
      "self",
      "n_bins",
      "warm_start"
    ],
    "update": [
      "self",
      "x_val",
      "gh",
      "w"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "_get_params": [
      "self"
    ]
  },
  "ExhaustiveSplitter": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "_search_for_best_split_option": [
      "self",
      "current_node",
      "current_best_option",
      "actual_parent_left",
      "parent_left",
      "parent_right",
      "left_child",
      "criterion",
      "pre_split_dist",
      "att_idx"
    ]
  },
  "ExhaustiveNode": {
    "__init__": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "insert_value": [
      "self",
      "val",
      "label",
      "w"
    ]
  },
  "QOSplitter": {
    "__init__": [
      "self",
      "radius",
      "allow_multiway_splits"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "is_target_class": [
      "self"
    ]
  },
  "Slot": {
    "__init__": [
      "self",
      "x",
      "y",
      "weight"
    ],
    "_init_estimator": [
      "self",
      "y"
    ],
    "_update_estimator_univariate": [
      "self",
      "target",
      "w"
    ],
    "_update_estimator_multivariate": [
      "self",
      "target",
      "w"
    ],
    "__iadd__": [
      "self",
      "o"
    ],
    "update": [
      "self",
      "x",
      "y",
      "w"
    ]
  },
  "FeatureQuantizer": {
    "__init__": [
      "self",
      "radius"
    ],
    "__getitem__": [
      "self",
      "k"
    ],
    "__len__": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "y",
      "weight"
    ],
    "__iter__": [
      "self"
    ],
    "all": [
      "self"
    ]
  },
  "EBSTSplitter": {
    "__init__": [
      "self"
    ],
    "is_target_class": [
      "self"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "_find_best_split": [
      "self",
      "node",
      "candidate"
    ],
    "remove_bad_splits": [
      "self",
      "criterion",
      "last_check_ratio",
      "last_check_vr",
      "last_check_e",
      "pre_split_dist"
    ],
    "_remove_bad_split_nodes": [
      "self",
      "current_node",
      "parent",
      "is_left_child"
    ]
  },
  "EBSTNode": {
    "__init__": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "_update_estimator_univariate": [
      "node",
      "target",
      "w"
    ],
    "_update_estimator_multivariate": [
      "node",
      "target",
      "w"
    ],
    "insert_value": [
      "self",
      "att_val",
      "target_val",
      "w"
    ]
  },
  "TEBSTSplitter": {
    "__init__": [
      "self",
      "digits"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ]
  },
  "HistogramSplitter": {
    "__init__": [
      "self",
      "n_bins",
      "n_splits"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ]
  },
  "decimal_range": [
    "start",
    "stop",
    "num"
  ],
  "NominalSplitterClassif": {
    "__init__": [
      "self"
    ],
    "is_numeric": [
      "self"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ],
    "_class_dist_from_multiway_split": [
      "self"
    ],
    "_class_dist_from_binary_split": [
      "self",
      "val_idx"
    ]
  },
  "NominalSplitterReg": {
    "__init__": [
      "self"
    ],
    "is_numeric": [
      "self"
    ],
    "_update_estimator_univariate": [
      "estimator",
      "target",
      "w"
    ],
    "_update_estimator_multivariate": [
      "estimator",
      "target",
      "w"
    ],
    "update": [
      "self",
      "att_val",
      "target_val",
      "w"
    ],
    "cond_proba": [
      "self",
      "att_val",
      "target_val"
    ],
    "best_evaluated_split_suggestion": [
      "self",
      "criterion",
      "pre_split_dist",
      "att_idx",
      "binary_only"
    ]
  },
  "RandomLeafMean": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng"
    ]
  },
  "RandomLeafModel": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng",
      "leaf_model"
    ]
  },
  "RandomLeafAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng",
      "leaf_model"
    ]
  },
  "LeafMean": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "new_nominal_splitter": [],
    "manage_memory": [
      "self",
      "criterion",
      "last_check_ratio",
      "last_check_vr",
      "last_check_e"
    ],
    "update_stats": [
      "self",
      "y",
      "w"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "total_weight": [
      "self"
    ],
    "calculate_promise": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "LeafModel": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "leaf_model"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ]
  },
  "LeafAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "leaf_model"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ]
  },
  "SGTLeaf": {
    "__init__": [
      "self",
      "prediction",
      "depth",
      "split_params"
    ],
    "reset": [
      "self"
    ],
    "is_categorical": [
      "idx",
      "x_val",
      "nominal_attributes"
    ],
    "update": [
      "self",
      "x",
      "gh",
      "sgt",
      "w"
    ],
    "prediction": [
      "self"
    ],
    "_eval_categorical_splits": [
      "self",
      "feature_idx",
      "candidate",
      "sgt"
    ],
    "_eval_numerical_splits": [
      "self",
      "feature_idx",
      "candidate",
      "sgt"
    ],
    "find_best_split": [
      "self",
      "sgt"
    ],
    "apply_split": [
      "self",
      "split",
      "p_node",
      "p_branch",
      "sgt"
    ],
    "total_weight": [
      "self"
    ],
    "update_stats": [
      "self"
    ],
    "delta_prediction": [
      "gh",
      "lambda_value"
    ],
    "__repr__": [
      "self"
    ]
  },
  "AdaLeafRegressor": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "drift_detector",
      "rng"
    ],
    "kill_tree_children": [
      "self",
      "hatr"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "AdaBranchRegressor": {
    "__init__": [
      "self",
      "stats"
    ],
    "traverse": [
      "self",
      "x",
      "until_leaf"
    ],
    "iter_leaves": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "kill_tree_children": [
      "self",
      "tree"
    ]
  },
  "AdaNomBinaryBranchReg": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "value",
      "depth",
      "left",
      "right"
    ]
  },
  "AdaNumBinaryBranchReg": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "threshold",
      "depth",
      "left",
      "right"
    ]
  },
  "AdaNomMultiwayBranchReg": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "feature_values",
      "depth"
    ]
  },
  "AdaNumMultiwayBranchReg": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "radius_and_slots",
      "depth"
    ]
  },
  "AdaLeafRegMean": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "drift_detector",
      "rng"
    ]
  },
  "AdaLeafRegModel": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "drift_detector",
      "rng"
    ]
  },
  "AdaLeafRegAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "drift_detector",
      "rng"
    ]
  },
  "BaseEFDTLeaf": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "best_split_suggestions": [
      "self",
      "criterion",
      "tree"
    ]
  },
  "BaseEFDTBranch": {
    "__init__": [
      "self",
      "stats"
    ],
    "total_weight": [
      "self"
    ],
    "new_nominal_splitter": [],
    "update_stats": [
      "self",
      "y",
      "w"
    ],
    "update_splitters": [
      "self",
      "x",
      "y",
      "w",
      "nominal_attributes"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "find_attribute": [
      "id_att",
      "split_suggestions"
    ],
    "last_split_reevaluation_at": [
      "self",
      "value"
    ],
    "observed_class_distribution_is_pure": [
      "self"
    ],
    "best_split_suggestions": [
      "self",
      "criterion",
      "tree"
    ]
  },
  "EFDTLeafMajorityClass": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ]
  },
  "EFDTLeafNaiveBayes": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ]
  },
  "EFDTLeafNaiveBayesAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ]
  },
  "EFDTNominalBinaryBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "value",
      "depth",
      "left",
      "right"
    ]
  },
  "EFDTNominalMultiwayBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "feature_values",
      "depth"
    ]
  },
  "EFDTNumericBinaryBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "threshold",
      "depth",
      "left",
      "right"
    ]
  },
  "EFDTNumericMultiwayBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "radius_and_slots",
      "depth"
    ]
  },
  "ETLeaf": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "seed"
    ],
    "_iter_features": [
      "self",
      "x"
    ],
    "_sample_features": [
      "self",
      "x",
      "max_features"
    ]
  },
  "ETLeafMean": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "seed"
    ]
  },
  "ETLeafModel": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "seed"
    ]
  },
  "ETLeafAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "seed"
    ]
  },
  "DTBranch": {
    "__init__": [
      "self",
      "stats"
    ],
    "total_weight": [
      "self"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "next": [
      "self",
      "x"
    ],
    "max_branches": [
      "self"
    ],
    "repr_branch": [
      "self",
      "index",
      "shorten"
    ]
  },
  "NumericBinaryBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "threshold",
      "depth",
      "left",
      "right"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "max_branches": [
      "self"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_branch": [
      "self",
      "index",
      "shorten"
    ],
    "repr_split": [
      "self"
    ]
  },
  "NominalBinaryBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "value",
      "depth",
      "left",
      "right"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "max_branches": [
      "self"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_branch": [
      "self",
      "index",
      "shorten"
    ],
    "repr_split": [
      "self"
    ]
  },
  "NumericMultiwayBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "radius_and_slots",
      "depth"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "max_branches": [
      "self"
    ],
    "most_common_path": [
      "self"
    ],
    "add_child": [
      "self",
      "feature_val",
      "child"
    ],
    "repr_branch": [
      "self",
      "index",
      "shorten"
    ],
    "repr_split": [
      "self"
    ]
  },
  "NominalMultiwayBranch": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "feature_values",
      "depth"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "max_branches": [
      "self"
    ],
    "most_common_path": [
      "self"
    ],
    "add_child": [
      "self",
      "feature_val",
      "child"
    ],
    "repr_branch": [
      "self",
      "index",
      "shorten"
    ],
    "repr_split": [
      "self"
    ]
  },
  "LeafMajorityClassWithDetector": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "change_detector",
      "split_criterion"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "LeafNaiveBayesWithDetector": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "change_detector",
      "split_criterion"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "disable_attribute": [
      "self",
      "att_index"
    ]
  },
  "LeafNaiveBayesAdaptiveWithDetector": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "change_detector",
      "split_criterion"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "disable_attribute": [
      "self",
      "att_index"
    ]
  },
  "BaseRandomLeaf": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng"
    ],
    "_iter_features": [
      "self",
      "x"
    ],
    "_sample_features": [
      "self",
      "x",
      "max_features"
    ]
  },
  "RandomLeafMajorityClass": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng"
    ]
  },
  "RandomLeafNaiveBayes": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng"
    ]
  },
  "RandomLeafNaiveBayesAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "max_features",
      "rng"
    ]
  },
  "LeafMeanMultiTarget": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "update_stats": [
      "self",
      "y",
      "w"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "total_weight": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "LeafModelMultiTarget": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "leaf_models"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ]
  },
  "LeafAdaptiveMultiTarget": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "leaf_models"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ]
  },
  "AdaLeafClassifier": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter",
      "drift_detector",
      "rng"
    ],
    "kill_tree_children": [
      "self",
      "hat"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ]
  },
  "AdaBranchClassifier": {
    "__init__": [
      "self",
      "stats"
    ],
    "traverse": [
      "self",
      "x",
      "until_leaf"
    ],
    "iter_leaves": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "kill_tree_children": [
      "self",
      "tree"
    ]
  },
  "AdaNomBinaryBranchClass": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "value",
      "depth",
      "left",
      "right"
    ]
  },
  "AdaNumBinaryBranchClass": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "threshold",
      "depth",
      "left",
      "right"
    ]
  },
  "AdaNomMultiwayBranchClass": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "feature_values",
      "depth"
    ]
  },
  "AdaNumMultiwayBranchClass": {
    "__init__": [
      "self",
      "stats",
      "feature",
      "radius_and_slots",
      "depth"
    ]
  },
  "HTLeaf": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "total_weight": [
      "self"
    ],
    "is_active": [
      "self"
    ],
    "activate": [
      "self"
    ],
    "deactivate": [
      "self"
    ],
    "last_split_attempt_at": [
      "self",
      "weight"
    ],
    "new_nominal_splitter": [],
    "update_stats": [
      "self",
      "y",
      "w"
    ],
    "_iter_features": [
      "self",
      "x"
    ],
    "update_splitters": [
      "self",
      "x",
      "y",
      "w",
      "nominal_attributes"
    ],
    "best_split_suggestions": [
      "self",
      "criterion",
      "tree"
    ],
    "disable_attribute": [
      "self",
      "att_id"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "calculate_promise": [
      "self"
    ]
  },
  "LeafMajorityClass": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "new_nominal_splitter": [],
    "update_stats": [
      "self",
      "y",
      "w"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "total_weight": [
      "self"
    ],
    "best_split_suggestions": [
      "self",
      "criterion",
      "tree"
    ],
    "calculate_promise": [
      "self"
    ],
    "observed_class_distribution_is_pure": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "LeafNaiveBayes": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "disable_attribute": [
      "self",
      "att_index"
    ]
  },
  "LeafNaiveBayesAdaptive": {
    "__init__": [
      "self",
      "stats",
      "depth",
      "splitter"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "prediction": [
      "self",
      "x"
    ],
    "disable_attribute": [
      "self",
      "att_index"
    ]
  },
  "MondrianTree": {
    "__init__": [
      "self",
      "step",
      "loss",
      "use_aggregation",
      "iteration",
      "seed"
    ]
  },
  "MondrianTreeRegressor": {
    "__init__": [
      "self",
      "step",
      "use_aggregation",
      "iteration",
      "seed"
    ],
    "_is_initialized": [
      "self"
    ],
    "_predict": [
      "self",
      "node"
    ],
    "_loss": [
      "self",
      "node"
    ],
    "_update_weight": [
      "self",
      "node"
    ],
    "_update_downwards": [
      "self",
      "node",
      "do_update_weight"
    ],
    "_compute_split_time": [
      "self",
      "node",
      "extensions_sum"
    ],
    "_split": [
      "self",
      "node",
      "split_time",
      "threshold",
      "feature",
      "is_right_extension"
    ],
    "_go_downwards": [
      "self"
    ],
    "_go_upwards": [
      "self",
      "leaf"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "MondrianLeaf": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MondrianBranch": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth",
      "feature",
      "threshold"
    ],
    "branch_no": [
      "self",
      "x"
    ],
    "next": [
      "self",
      "x"
    ],
    "most_common_path": [
      "self"
    ],
    "repr_split": [
      "self"
    ]
  },
  "MondrianNode": {
    "__init__": [
      "self"
    ],
    "update_depth": [
      "self",
      "depth"
    ],
    "update_weight_tree": [
      "self"
    ],
    "range": [
      "self",
      "feature"
    ],
    "range_extension": [
      "self",
      "x"
    ]
  },
  "MondrianNodeClassifier": {
    "__init__": [
      "self"
    ],
    "replant": [
      "self",
      "leaf",
      "copy_all"
    ],
    "score": [
      "self",
      "y",
      "dirichlet",
      "n_classes"
    ],
    "predict": [
      "self",
      "dirichlet",
      "classes",
      "n_classes"
    ],
    "loss": [
      "self",
      "y",
      "dirichlet",
      "n_classes"
    ],
    "update_weight": [
      "self",
      "y",
      "dirichlet",
      "use_aggregation",
      "step",
      "n_classes"
    ],
    "update_count": [
      "self",
      "y"
    ],
    "is_dirac": [
      "self",
      "y"
    ],
    "update_downwards": [
      "self",
      "x",
      "y",
      "dirichlet",
      "use_aggregation",
      "step",
      "do_update_weight",
      "n_classes"
    ]
  },
  "MondrianLeafClassifier": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth"
    ]
  },
  "MondrianBranchClassifier": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth",
      "feature",
      "threshold"
    ]
  },
  "MondrianNodeRegressor": {
    "__init__": [
      "self"
    ],
    "replant": [
      "self",
      "leaf",
      "copy_all"
    ],
    "predict": [
      "self"
    ],
    "loss": [
      "self",
      "sample_value"
    ],
    "update_weight": [
      "self",
      "sample_value",
      "use_aggregation",
      "step"
    ],
    "update_downwards": [
      "self",
      "x",
      "sample_value",
      "use_aggregation",
      "step",
      "do_update_weight"
    ]
  },
  "MondrianLeafRegressor": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth"
    ]
  },
  "MondrianBranchRegressor": {
    "__init__": [
      "self",
      "parent",
      "time",
      "depth",
      "feature",
      "threshold"
    ]
  },
  "MondrianTreeClassifier": {
    "__init__": [
      "self",
      "step",
      "use_aggregation",
      "dirichlet",
      "split_pure",
      "iteration",
      "seed"
    ],
    "_is_initialized": [
      "self"
    ],
    "_score": [
      "self",
      "node"
    ],
    "_predict": [
      "self",
      "node"
    ],
    "_loss": [
      "self",
      "node"
    ],
    "_update_weight": [
      "self",
      "node"
    ],
    "_update_count": [
      "self",
      "node"
    ],
    "_update_downwards": [
      "self",
      "x",
      "y",
      "node",
      "do_weight_update"
    ],
    "_compute_split_time": [
      "self",
      "y",
      "node",
      "extensions_sum"
    ],
    "_split": [
      "self",
      "node",
      "split_time",
      "threshold",
      "feature",
      "is_right_extension"
    ],
    "_go_downwards": [
      "self",
      "x",
      "y"
    ],
    "_go_upwards": [
      "self",
      "leaf"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "FuncTransformer": {
    "__init__": [
      "self",
      "func"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "transform_many": [
      "self",
      "X"
    ],
    "__str__": [
      "self"
    ]
  },
  "Grouper": {
    "__init__": [
      "self",
      "transformer",
      "by"
    ],
    "_get_key": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Discard": {
    "__init__": [
      "self"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Select": {
    "__init__": [
      "self"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "transform_many": [
      "self",
      "X"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SelectType": {
    "__init__": [
      "self"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "learn_during_predict": [],
  "Pipeline": {
    "_LEARN_UNSUPERVISED_DURING_PREDICT": [],
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_get_params": [
      "self"
    ],
    "clone": [
      "self",
      "new_params",
      "include_attributes"
    ],
    "mutate": [
      "self",
      "new_params"
    ],
    "_supervised": [
      "self"
    ],
    "_last_step": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "_add_step": [
      "self",
      "obj",
      "at_start"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_transform_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "score_one": [
      "self",
      "x"
    ],
    "forecast": [
      "self",
      "horizon",
      "xs"
    ],
    "debug_one": [
      "self",
      "x",
      "show_types",
      "n_decimals"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "_transform_many": [
      "self",
      "X"
    ],
    "transform_many": [
      "self",
      "X"
    ],
    "predict_many": [
      "self",
      "X"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "TargetTransformRegressor": {
    "__init__": [
      "self",
      "regressor",
      "func",
      "inverse_func"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_update": [
      "self",
      "y"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "TransformerUnion": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_get_params": [
      "self"
    ],
    "clone": [
      "self",
      "new_params",
      "include_attributes"
    ],
    "mutate": [
      "self",
      "new_params"
    ],
    "_supervised": [
      "self"
    ],
    "_add_step": [
      "self",
      "transformer"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "test_issue_1238": [],
  "test_issue_1243": [],
  "test_issue_1253": [],
  "test_left_is_pipeline": [],
  "test_right_is_pipeline": [],
  "test_both_are_pipelines": [],
  "test_renaming": [],
  "test_prefixing": [],
  "test_suffixing": [],
  "test_issue_1310": [],
  "TransformerProduct": {
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "test_pipeline_funcs": [],
  "test_pipeline_add_at_start": [],
  "test_union_funcs": [],
  "test_learn_one_with_learn_during_predict": [],
  "test_learn_many_with_learn_during_predict": [],
  "test_list_of_funcs": [],
  "test_get": [],
  "Renamer": {
    "__init__": [
      "self",
      "mapping"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Prefixer": {
    "__init__": [
      "self",
      "prefix"
    ],
    "_rename": [
      "self",
      "s"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Suffixer": {
    "__init__": [
      "self",
      "suffix"
    ],
    "_rename": [
      "self",
      "s"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Rollable": {
    "update": [
      "self"
    ],
    "revert": [
      "self"
    ]
  },
  "BaseRolling": {
    "__init__": [
      "self",
      "obj"
    ],
    "__getattribute__": [
      "self",
      "name"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Rolling": {
    "__init__": [
      "self",
      "obj",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self"
    ]
  },
  "TimeRolling": {
    "__init__": [
      "self",
      "obj",
      "period"
    ],
    "update": [
      "self"
    ]
  },
  "normalize_values_in_dict": [
    "dictionary",
    "factor",
    "inplace",
    "raise_error"
  ],
  "scale_values_in_dict": [
    "dictionary",
    "multiplier",
    "inplace"
  ],
  "dotvecmat": [
    "x",
    "A"
  ],
  "matmul2d": [
    "A",
    "B"
  ],
  "outer": [
    "u",
    "v"
  ],
  "minkowski_distance": [
    "a",
    "b",
    "p"
  ],
  "softmax": [
    "y_pred"
  ],
  "prod": [
    "iterable"
  ],
  "dot": [
    "x",
    "y"
  ],
  "chain_dot": [],
  "sigmoid": [
    "x"
  ],
  "clamp": [
    "x",
    "minimum",
    "maximum"
  ],
  "norm": [
    "x",
    "order"
  ],
  "sign": [
    "x"
  ],
  "argmax": [
    "lst"
  ],
  "sherman_morrison": [
    "A",
    "u",
    "v"
  ],
  "woodbury_matrix": [
    "A",
    "U",
    "V"
  ],
  "log_sum_2_exp": [
    "a",
    "b"
  ],
  "test_with_counter": [],
  "test_rolling_with_not_rollable": [],
  "test_time_rolling_with_not_rollable": [],
  "test_issue_1343": [],
  "test_expand_param_grid_count": [
    "model",
    "param_grid",
    "count"
  ],
  "test_decision_tree_max_depth": [],
  "test_dotvecmat_zero_vector_times_matrix_of_ones": [],
  "test_dotvecmat_vector_of_ones_times_zero_matrix": [],
  "test_dotvecmat_filter_first_matrix_row_with_vector": [],
  "test_dotvecmat_filter_second_matrix_row_with_vector": [],
  "test_dotvecmat_vector_times_identity_matrix": [],
  "test_dotvecmat_vector_times_anti_diagonal_identity_matrix": [],
  "test_dotvecmat_three_dimensional_vector_times_non_quadratic_matrix": [],
  "expand_param_grid": [
    "model",
    "grid"
  ],
  "_expand_param_grid": [
    "grid"
  ],
  "test_vectordict": [],
  "extract_relevant": [
    "model"
  ],
  "ischildobject": [
    "obj",
    "class_name"
  ],
  "isanomalydetector": [
    "model"
  ],
  "isanomalyfilter": [
    "model"
  ],
  "isclassifier": [
    "model"
  ],
  "isclusterer": [
    "model"
  ],
  "ismoclassifier": [
    "model"
  ],
  "isregressor": [
    "model"
  ],
  "istransformer": [
    "model"
  ],
  "ismoregressor": [
    "model"
  ],
  "isdriftdetector": [
    "model"
  ],
  "isactivelearner": [
    "model"
  ],
  "print_table": [
    "headers",
    "columns",
    "order"
  ],
  "humanize_bytes": [
    "n_bytes"
  ],
  "SortedWindow": {
    "__init__": [
      "self",
      "size"
    ],
    "size": [
      "self"
    ],
    "append": [
      "self",
      "x"
    ]
  },
  "poisson": [
    "rate",
    "rng"
  ],
  "exponential": [
    "rate",
    "rng"
  ],
  "Interval": {
    "center": [
      "self"
    ],
    "width": [
      "self"
    ],
    "__contains__": [
      "self",
      "x"
    ]
  },
  "T": [],
  "RegressionJackknife": {
    "__init__": [
      "self",
      "regressor",
      "confidence_level",
      "window_size"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x",
      "with_interval"
    ]
  },
  "Baseline": {
    "__init__": [
      "self",
      "optimizer",
      "loss",
      "l2",
      "initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_one": [
      "self",
      "user",
      "item",
      "x"
    ],
    "learn_one": [
      "self",
      "user",
      "item",
      "y",
      "x"
    ]
  },
  "BiasedMF": {
    "__init__": [
      "self",
      "n_factors",
      "bias_optimizer",
      "latent_optimizer",
      "loss",
      "l2_bias",
      "l2_latent",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "predict_one": [
      "self",
      "user",
      "item",
      "x"
    ],
    "learn_one": [
      "self",
      "user",
      "item",
      "y",
      "x"
    ]
  },
  "ID": [],
  "Reward": [],
  "Ranker": {
    "__init__": [
      "self",
      "seed"
    ],
    "is_contextual": [
      "self"
    ],
    "learn_one": [
      "self",
      "user",
      "item",
      "y",
      "x"
    ],
    "predict_one": [
      "self",
      "user",
      "item",
      "x"
    ],
    "rank": [
      "self",
      "user",
      "items",
      "x"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "RandomNormal": {
    "__init__": [
      "self",
      "seed"
    ],
    "learn_one": [
      "self",
      "user",
      "item",
      "y",
      "x"
    ],
    "predict_one": [
      "self",
      "user",
      "item",
      "x"
    ]
  },
  "FunkMF": {
    "__init__": [
      "self",
      "n_factors",
      "optimizer",
      "loss",
      "l2",
      "initializer",
      "clip_gradient",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "predict_one": [
      "self",
      "user",
      "item",
      "x"
    ],
    "learn_one": [
      "self",
      "user",
      "item",
      "y",
      "x"
    ]
  },
  "ThompsonSampling": {
    "__init__": [
      "self",
      "reward_obj",
      "burn_in",
      "seed"
    ],
    "_clone_reward_obj_with_seed": [
      "self"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "test_ranking": [],
  "RandomPolicy": {
    "_pull": [
      "self",
      "arm_ids"
    ]
  },
  "_iter_policies": [],
  "test_better_than_random_policy": [
    "policy",
    "env"
  ],
  "_iter_envs": [],
  "test_gym_check_env": [
    "env"
  ],
  "ArmID": [],
  "RewardObj": [],
  "Policy": {
    "_REQUIRES_UNIVARIATE_REWARD": [],
    "__init__": [
      "self",
      "reward_obj",
      "reward_scaler",
      "burn_in"
    ],
    "__post_init__": [
      "self"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "pull": [
      "self",
      "arm_ids"
    ],
    "update": [
      "self",
      "arm_id"
    ],
    "ranking": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ContextualPolicy": {
    "_pull": [
      "self",
      "arm_ids",
      "context"
    ],
    "pull": [
      "self",
      "arm_ids",
      "context"
    ],
    "update": [
      "self",
      "arm_id",
      "context"
    ]
  },
  "Exp3": {
    "_REQUIRES_UNIVARIATE_REWARD": [],
    "__init__": [
      "self",
      "gamma",
      "reward_obj",
      "reward_scaler",
      "burn_in",
      "seed"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "update": [
      "self",
      "arm_id"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "BayesUCB": {
    "_REQUIRES_UNIVARIATE_REWARD": [],
    "__init__": [
      "self",
      "reward_obj",
      "burn_in",
      "seed"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "compute_index": [
      "self",
      "arm_id"
    ],
    "update": [
      "self",
      "arm_id"
    ]
  },
  "UCB": {
    "__init__": [
      "self",
      "delta",
      "reward_obj",
      "reward_scaler",
      "burn_in",
      "seed"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "LinUCBDisjoint": {
    "_REQUIRES_UNIVARIATE_REWARD": [],
    "__init__": [
      "self",
      "alpha",
      "beta",
      "smoothing",
      "reward_obj",
      "burn_in",
      "seed"
    ],
    "_pull": [
      "self",
      "arm_ids",
      "context"
    ],
    "update": [
      "self",
      "arm_id",
      "context"
    ]
  },
  "evaluate": [
    "policies",
    "env",
    "reward_stat",
    "n_episodes",
    "seed"
  ],
  "History": [],
  "evaluate_offline": [
    "policy",
    "history",
    "reward_stat"
  ],
  "EpsilonGreedy": {
    "__init__": [
      "self",
      "epsilon",
      "decay",
      "reward_obj",
      "burn_in",
      "seed"
    ],
    "current_epsilon": [
      "self"
    ],
    "_pull": [
      "self",
      "arm_ids"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "NewsArticles": {
    "__init__": [
      "self"
    ],
    "arms": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "BanditDataset": {
    "__init__": [
      "self",
      "n_features",
      "n_samples",
      "n_classes",
      "n_outputs",
      "sparse"
    ],
    "arms": [
      "self"
    ],
    "_repr_content": [
      "self"
    ]
  },
  "KArmedTestbed": {
    "n_steps": [],
    "__init__": [
      "self",
      "k"
    ],
    "reset": [
      "self",
      "seed",
      "options"
    ],
    "step": [
      "self",
      "arm"
    ]
  },
  "VendingMachine": {},
  "CandyCaneContest": {
    "n_steps": [],
    "__init__": [
      "self",
      "n_machines",
      "reward_decay"
    ],
    "_get_observation": [
      "self"
    ],
    "_get_info": [
      "self"
    ],
    "reset": [
      "self",
      "seed",
      "options"
    ],
    "step": [
      "self",
      "machine_index"
    ]
  },
  "FM": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_init_latents": [
      "self"
    ],
    "_interaction_names": [
      "self",
      "x"
    ],
    "_interaction_combination_keys": [
      "self",
      "x"
    ],
    "_interaction_val": [
      "self",
      "x",
      "combination"
    ],
    "_interaction_coefficient": [
      "self",
      "combination"
    ],
    "_calculate_weights_gradients": [
      "self",
      "x",
      "g_loss"
    ],
    "_update_latents": [
      "self",
      "x",
      "g_loss"
    ]
  },
  "FMRegressor": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "FMClassifier": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "FwFM": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "int_weight_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_init_latents": [
      "self"
    ],
    "_interaction_names": [
      "self",
      "x"
    ],
    "_interaction_combination_keys": [
      "self",
      "x"
    ],
    "_interaction_val": [
      "self",
      "x",
      "combination"
    ],
    "_interaction_coefficient": [
      "self",
      "combination"
    ],
    "_calculate_weights_gradients": [
      "self",
      "x",
      "g_loss"
    ],
    "_update_latents": [
      "self",
      "x",
      "g_loss"
    ]
  },
  "FwFMRegressor": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "int_weight_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "FwFMClassifier": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "int_weight_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "BaseFM": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_init_latents": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "_ohe_cat_features": [
      "self",
      "x"
    ],
    "_learn_one": [
      "self",
      "x",
      "y",
      "w"
    ],
    "_raw_dot": [
      "self",
      "x"
    ],
    "_field": [
      "self",
      "j"
    ],
    "_calculate_interactions": [
      "self",
      "x"
    ],
    "debug_one": [
      "self",
      "x",
      "decimals"
    ],
    "_interaction_names": [
      "self",
      "x"
    ],
    "_interaction_combination_keys": [
      "self",
      "x"
    ],
    "_interaction_val": [
      "self",
      "x",
      "combination"
    ],
    "_interaction_coefficient": [
      "self",
      "combination"
    ],
    "_calculate_weights_gradients": [
      "self",
      "x",
      "g_loss"
    ],
    "_update_latents": [
      "self",
      "x",
      "g_loss"
    ]
  },
  "FFM": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_init_latents": [
      "self"
    ],
    "_interaction_names": [
      "self",
      "x"
    ],
    "_interaction_combination_keys": [
      "self",
      "x"
    ],
    "_interaction_val": [
      "self",
      "x",
      "combination"
    ],
    "_interaction_coefficient": [
      "self",
      "combination"
    ],
    "_calculate_weights_gradients": [
      "self",
      "x",
      "g_loss"
    ],
    "_update_latents": [
      "self",
      "x",
      "g_loss"
    ]
  },
  "FFMRegressor": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "FFMClassifier": {
    "__init__": [
      "self",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "HOFM": {
    "__init__": [
      "self",
      "degree",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "_init_latents": [
      "self"
    ],
    "_interaction_names": [
      "self",
      "x"
    ],
    "_interaction_combination_keys": [
      "self",
      "x"
    ],
    "_interaction_val": [
      "self",
      "x",
      "combination"
    ],
    "_interaction_coefficient": [
      "self",
      "combination"
    ],
    "_calculate_weights_gradients": [
      "self",
      "x",
      "g_loss"
    ],
    "_update_latents": [
      "self",
      "x",
      "g_loss"
    ]
  },
  "HOFMRegressor": {
    "__init__": [
      "self",
      "degree",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "HOFMClassifier": {
    "__init__": [
      "self",
      "degree",
      "n_factors",
      "weight_optimizer",
      "latent_optimizer",
      "loss",
      "sample_normalization",
      "l1_weight",
      "l2_weight",
      "l1_latent",
      "l2_latent",
      "intercept",
      "intercept_lr",
      "weight_initializer",
      "latent_initializer",
      "clip_gradient",
      "seed"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "OneVsOneClassifier": {
    "__init__": [
      "self",
      "classifier"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "OneVsRestClassifier": {
    "__init__": [
      "self",
      "classifier"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "test_online_batch_consistent": [],
  "l1_dist": [
    "a",
    "b"
  ],
  "OutputCodeClassifier": {
    "__init__": [
      "self",
      "classifier",
      "code_size",
      "coding_method",
      "seed"
    ],
    "_next_code": [
      "self"
    ],
    "_multiclass": [
      "self"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "AdaBoostClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "ADWINBoostingClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "BOLEClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed",
      "error_bound"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "StackingClassifier": {
    "__init__": [
      "self",
      "models",
      "meta_classifier",
      "include_features"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "EWARegressor": {
    "__init__": [
      "self",
      "models",
      "loss",
      "learning_rate"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_predict_one": [
      "self",
      "x",
      "y"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "BaseSRPEnsemble": {
    "_TRAIN_RANDOM_SUBSPACES": [],
    "_TRAIN_RESAMPLING": [],
    "_TRAIN_RANDOM_PATCHES": [],
    "_FEATURES_SQRT": [],
    "_FEATURES_SQRT_INV": [],
    "_VALID_TRAINING_METHODS": [],
    "__init__": [
      "self",
      "model",
      "n_models",
      "subspace_size",
      "training_method",
      "lam",
      "drift_detector",
      "warning_detector",
      "disable_detector",
      "disable_weighted_vote",
      "seed",
      "metric"
    ],
    "_min_number_of_models": [
      "self"
    ],
    "_wrapped_model": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_unit_test_skips": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_generate_subspaces": [
      "self",
      "features"
    ],
    "_init_ensemble": [
      "self",
      "features"
    ],
    "reset": [
      "self"
    ]
  },
  "BaseSRPEstimator": {
    "__init__": [
      "self",
      "idx_original",
      "model",
      "metric",
      "created_on",
      "drift_detector",
      "warning_detector",
      "is_background_learner",
      "rng",
      "features"
    ],
    "_trigger_warning": [
      "self",
      "all_features",
      "n_samples_seen"
    ],
    "reset": [
      "self",
      "all_features",
      "n_samples_seen"
    ]
  },
  "random_subspace": [
    "all_features",
    "k",
    "rng"
  ],
  "SRPClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "subspace_size",
      "training_method",
      "lam",
      "drift_detector",
      "warning_detector",
      "disable_detector",
      "disable_weighted_vote",
      "seed",
      "metric"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "BaseSRPClassifier": {
    "__init__": [
      "self",
      "idx_original",
      "model",
      "metric",
      "created_on",
      "drift_detector",
      "warning_detector",
      "is_background_learner",
      "rng",
      "features"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "SRPRegressor": {
    "_MEAN": [],
    "_MEDIAN": [],
    "_ERROR": [],
    "_PREDICTION": [],
    "__init__": [
      "self",
      "model",
      "n_models",
      "subspace_size",
      "training_method",
      "lam",
      "drift_detector",
      "warning_detector",
      "disable_detector",
      "disable_weighted_vote",
      "drift_detection_criteria",
      "aggregation_method",
      "seed",
      "metric"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "BaseSRPRegressor": {
    "__init__": [
      "self",
      "idx_original",
      "model",
      "metric",
      "created_on",
      "drift_detector",
      "warning_detector",
      "is_background_learner",
      "rng",
      "features",
      "drift_detection_criteria"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "VotingClassifier": {
    "__init__": [
      "self",
      "models",
      "use_probabilities"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "BaseBagging": {
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "BaggingClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "BaggingRegressor": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "ADWINBaggingClassifier": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "LeveragingBaggingClassifier": {
    "_BAGGING_METHODS": [],
    "__init__": [
      "self",
      "model",
      "n_models",
      "w",
      "adwin_delta",
      "bagging_method",
      "seed"
    ],
    "_leveraging_bag": [
      "self"
    ],
    "_leveraging_bag_me": [
      "self"
    ],
    "_leveraging_bag_half": [
      "self"
    ],
    "_leveraging_bag_wt": [
      "self"
    ],
    "_leveraging_subag": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "bagging_methods": [
      "self"
    ]
  },
  "KNNClassifier": {
    "__init__": [
      "self",
      "n_neighbors",
      "engine",
      "weighted",
      "cleanup_every",
      "softmax"
    ],
    "_multiclass": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "clean_up_classes": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_run_class_cleanup": [
      "self"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "KNNRegressor": {
    "_MEAN": [],
    "_MEDIAN": [],
    "_WEIGHTED_MEAN": [],
    "__init__": [
      "self",
      "n_neighbors",
      "engine",
      "aggregation_method"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_check_aggregation_method": [
      "self",
      "method"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "DistanceFunc": {
    "__call__": [
      "self",
      "a",
      "b"
    ]
  },
  "FunctionWrapper": {
    "__init__": [
      "self",
      "distance_function"
    ],
    "__call__": [
      "self",
      "a",
      "b"
    ]
  },
  "BaseNN": {
    "__init__": [
      "self",
      "dist_func"
    ],
    "append": [
      "self",
      "item"
    ],
    "search": [
      "self",
      "item",
      "n_neighbors"
    ]
  },
  "LazySearch": {
    "__init__": [
      "self",
      "window_size",
      "min_distance_keep",
      "dist_func"
    ],
    "append": [
      "self",
      "item",
      "extra"
    ],
    "update": [
      "self",
      "item",
      "n_neighbors",
      "extra"
    ],
    "search": [
      "self",
      "item",
      "n_neighbors"
    ]
  },
  "Vertex": {
    "__init__": [
      "self",
      "item",
      "uuid"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "farewell": [
      "self",
      "vertex_pool"
    ],
    "fill": [
      "self",
      "neighbors",
      "dists"
    ],
    "add_edge": [
      "self",
      "vertex",
      "dist"
    ],
    "rem_edge": [
      "self",
      "vertex"
    ],
    "push_edge": [
      "self",
      "node",
      "dist",
      "max_edges",
      "vertex_pool"
    ],
    "is_neighbor": [
      "self",
      "vertex"
    ],
    "get_edge": [
      "self",
      "vertex"
    ],
    "has_neighbors": [
      "self"
    ],
    "has_rneighbors": [
      "self"
    ],
    "sample_flags": [
      "self",
      "sampled"
    ],
    "neighbors": [
      "self"
    ],
    "r_neighbors": [
      "self"
    ],
    "all_neighbors": [
      "self"
    ],
    "is_isolated": [
      "self"
    ],
    "prune": [
      "self",
      "prune_prob",
      "prune_trigger",
      "vertex_pool",
      "rng"
    ]
  },
  "SWINN": {
    "__init__": [
      "self",
      "graph_k",
      "dist_func",
      "maxlen",
      "warm_up",
      "max_candidates",
      "delta",
      "prune_prob",
      "n_iters",
      "seed"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ],
    "__iter__": [
      "self"
    ],
    "_init_graph": [
      "self"
    ],
    "_fix_graph": [
      "self"
    ],
    "_safe_node_removal": [
      "self",
      "nid"
    ],
    "_refine": [
      "self",
      "nodes"
    ],
    "append": [
      "self",
      "item"
    ],
    "_linear_scan": [
      "self",
      "item",
      "k"
    ],
    "_search": [
      "self",
      "item",
      "k",
      "epsilon",
      "seed",
      "exclude"
    ],
    "search": [
      "self",
      "item",
      "n_neighbors",
      "epsilon"
    ],
    "connectivity": [
      "self"
    ]
  },
  "clamp_proba": [
    "x"
  ],
  "BinaryLoss": {
    "mean_func": [
      "self",
      "y_pred"
    ]
  },
  "MultiClassLoss": {
    "mean_func": [
      "self",
      "y_pred"
    ]
  },
  "RegressionLoss": {
    "mean_func": [
      "self",
      "y_pred"
    ]
  },
  "Absolute": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Cauchy": {
    "__init__": [
      "self",
      "C"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Hinge": {
    "__init__": [
      "self",
      "threshold"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "EpsilonInsensitiveHinge": {
    "__init__": [
      "self",
      "eps"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Log": {
    "__init__": [
      "self",
      "weight_pos",
      "weight_neg"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Quantile": {
    "__init__": [
      "self",
      "alpha"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Squared": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Huber": {
    "__init__": [
      "self",
      "epsilon"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "BinaryFocalLoss": {
    "__init__": [
      "self",
      "gamma",
      "beta"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "Poisson": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "gradient": [
      "self",
      "y_true",
      "y_pred"
    ],
    "mean_func": [
      "self",
      "y_pred"
    ]
  },
  "FTRLProximal": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "l1",
      "l2"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "AdaMax": {
    "__init__": [
      "self",
      "lr",
      "beta_1",
      "beta_2",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "Adam": {
    "__init__": [
      "self",
      "lr",
      "beta_1",
      "beta_2",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ],
    "_step_with_vector": [
      "self",
      "w",
      "g"
    ]
  },
  "VectorLike": [],
  "Initializer": {
    "__call__": [
      "self",
      "shape"
    ]
  },
  "Scheduler": {
    "get": [
      "self",
      "t"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Optimizer": {
    "__init__": [
      "self",
      "lr"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "learning_rate": [
      "self"
    ],
    "look_ahead": [
      "self",
      "w"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ],
    "_step_with_vector": [
      "self",
      "w",
      "g"
    ],
    "step": [
      "self",
      "w",
      "g"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Constant": {
    "__init__": [
      "self",
      "value"
    ],
    "__call__": [
      "self",
      "shape"
    ]
  },
  "Zeros": {
    "__init__": [
      "self"
    ]
  },
  "Normal": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "seed"
    ],
    "__call__": [
      "self",
      "shape"
    ]
  },
  "Averager": {
    "__init__": [
      "self",
      "optimizer",
      "start"
    ],
    "look_ahead": [
      "self",
      "w"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "NesterovMomentum": {
    "__init__": [
      "self",
      "lr",
      "rho"
    ],
    "look_ahead": [
      "self",
      "w"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "AdaBound": {
    "__init__": [
      "self",
      "lr",
      "beta_1",
      "beta_2",
      "eps",
      "gamma",
      "final_lr"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "SGD": {
    "__init__": [
      "self",
      "lr"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ],
    "_step_with_vector": [
      "self",
      "w",
      "g"
    ]
  },
  "AMSGrad": {
    "__init__": [
      "self",
      "lr",
      "beta_1",
      "beta_2",
      "eps",
      "correct_bias"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "AdaDelta": {
    "__init__": [
      "self",
      "rho",
      "eps"
    ],
    "_rms": [
      "self",
      "x"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "AdaGrad": {
    "__init__": [
      "self",
      "lr",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "RMSProp": {
    "__init__": [
      "self",
      "lr",
      "rho",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ],
    "_step_with_vector": [
      "self",
      "w",
      "g"
    ]
  },
  "Momentum": {
    "__init__": [
      "self",
      "lr",
      "rho"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "Newton": {
    "__init__": [
      "self",
      "lr",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "losses": [],
  "test_loss_batch_online_equivalence": [
    "loss"
  ],
  "optimizers": [],
  "test_optimizer_step_with_dict_same_as_step_with_vector_dict": [
    "optimizer"
  ],
  "test_optimizer_step_with_dict_same_as_step_with_numpy_array": [
    "optimizer"
  ],
  "InverseScaling": {
    "__init__": [
      "self",
      "learning_rate",
      "power"
    ],
    "get": [
      "self",
      "t"
    ]
  },
  "Optimal": {
    "__init__": [
      "self",
      "loss",
      "alpha"
    ],
    "get": [
      "self",
      "t"
    ]
  },
  "Nadam": {
    "__init__": [
      "self",
      "lr",
      "beta_1",
      "beta_2",
      "eps"
    ],
    "_step_with_dict": [
      "self",
      "w",
      "g"
    ]
  },
  "ADWIN": {
    "__init__": [
      "self",
      "delta",
      "clock",
      "max_buckets",
      "min_window_length",
      "grace_period"
    ],
    "_reset": [
      "self"
    ],
    "width": [
      "self"
    ],
    "n_detections": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "total": [
      "self"
    ],
    "estimation": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "NoDrift": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "drift_detected": [
      "self"
    ]
  },
  "DummyDriftDetector": {
    "_FIXED_TRIGGER": [],
    "_RANDOM_TRIGGER": [],
    "__init__": [
      "self",
      "trigger_method",
      "t_0",
      "w",
      "dynamic_cloning",
      "seed"
    ],
    "_fixed_trigger": [
      "self"
    ],
    "_random_trigger": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "clone": [
      "self"
    ]
  },
  "data_stream_1": [],
  "data_stream_2": [],
  "data_stream_3": [],
  "test_adwin": [],
  "test_ddm": [],
  "test_eddm": [],
  "test_hddm_a": [],
  "test_hddm_w": [],
  "test_kswin": [],
  "test_kswin_coverage": [],
  "test_page_hinkley": [],
  "perform_test": [
    "drift_detector",
    "data_stream"
  ],
  "DriftRetrainingClassifier": {
    "__init__": [
      "self",
      "model",
      "drift_detector",
      "train_in_background"
    ],
    "_wrapped_model": [
      "self"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "_update_detector": [
      "self",
      "x",
      "y"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "PageHinkley": {
    "_MODE_UP": [],
    "_MODE_DOWN": [],
    "_MODE_BOTH": [],
    "_VALID_MODES": [],
    "__init__": [
      "self",
      "min_instances",
      "delta",
      "threshold",
      "alpha",
      "mode"
    ],
    "_reset": [
      "self"
    ],
    "_test_increase": [
      "self",
      "test_increase",
      "test_decrease"
    ],
    "_test_decrease": [
      "self",
      "test_increase",
      "test_decrease"
    ],
    "_test_both": [
      "self",
      "test_increase",
      "test_decrease"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "KSWIN": {
    "__init__": [
      "self",
      "alpha",
      "window_size",
      "stat_size",
      "seed",
      "window"
    ],
    "_reset": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "Occupancy": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "UKCoalEmploy": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "ChangePointFileDataset": {
    "__init__": [
      "self",
      "annotations"
    ],
    "_repr_content": [
      "self"
    ],
    "_annotations_aggregated": [
      "self",
      "annotator_aggregation"
    ]
  },
  "RunLog": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "BrentSpotPrice": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Apple": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Bitcoin": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "HDDM_A": {
    "__init__": [
      "self",
      "drift_confidence",
      "warning_confidence",
      "two_sided_test"
    ],
    "_reset": [
      "self"
    ],
    "_hoeffding_bound": [
      "self",
      "n"
    ],
    "update": [
      "self",
      "x"
    ],
    "_mean_incr": [
      "self",
      "confidence"
    ],
    "_mean_decr": [
      "self",
      "confidence"
    ]
  },
  "HDDM_W": {
    "__init__": [
      "self",
      "drift_confidence",
      "warning_confidence",
      "lambda_val",
      "two_sided_test"
    ],
    "_reset": [
      "self"
    ],
    "_mcdiarmid_bound": [
      "self",
      "ibc",
      "confidence"
    ],
    "update": [
      "self",
      "x"
    ],
    "_has_mean_changed": [
      "self",
      "sample1",
      "sample2",
      "confidence"
    ],
    "_detect_mean_incr": [
      "self",
      "confidence"
    ],
    "_detect_mean_decr": [
      "self",
      "confidence"
    ],
    "_update_incr_stats": [
      "self",
      "x",
      "confidence"
    ],
    "_update_decr_stats": [
      "self",
      "x",
      "confidence"
    ]
  },
  "SampleInfo": {
    "__init__": [
      "self",
      "lambd"
    ],
    "update": [
      "self",
      "x"
    ],
    "ewma": [
      "self"
    ],
    "ibc": [
      "self"
    ],
    "is_init": [
      "self"
    ]
  },
  "EDDM": {
    "__init__": [
      "self",
      "warm_start",
      "alpha",
      "beta"
    ],
    "_reset": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "DDM": {
    "__init__": [
      "self",
      "warm_start",
      "warning_threshold",
      "drift_threshold"
    ],
    "_reset": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "FHDDM": {
    "__init__": [
      "self",
      "sliding_window_size",
      "confidence_level",
      "short_window_size"
    ],
    "_reset": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "Forecaster": {
    "_supervised": [
      "self"
    ],
    "learn_one": [
      "self",
      "y",
      "x"
    ],
    "forecast": [
      "self",
      "horizon",
      "xs"
    ]
  },
  "ForecastingMetric": {
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get": [
      "self"
    ]
  },
  "HorizonMetric": {
    "__init__": [
      "self",
      "metric"
    ],
    "update": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "HorizonAggMetric": {
    "__init__": [
      "self",
      "metric",
      "agg_func"
    ],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "printer": [],
  "oil": [],
  "ausair": [],
  "austourists": [],
  "test_oil": [
    "printer",
    "oil"
  ],
  "test_ausair": [
    "printer",
    "ausair"
  ],
  "test_austourists_additive": [
    "printer",
    "austourists"
  ],
  "test_austourists_multiplicative": [
    "printer",
    "austourists"
  ],
  "Component": {},
  "AdditiveLevel": {
    "__init__": [
      "self",
      "alpha"
    ],
    "update": [
      "self",
      "y",
      "trend",
      "season"
    ]
  },
  "MultiplicativeLevel": {
    "__init__": [
      "self",
      "alpha"
    ],
    "update": [
      "self",
      "y",
      "trend",
      "season"
    ]
  },
  "Trend": {
    "__init__": [
      "self",
      "beta"
    ],
    "update": [
      "self",
      "y",
      "level"
    ]
  },
  "AdditiveSeason": {
    "__init__": [
      "self",
      "gamma",
      "seasonality"
    ],
    "update": [
      "self",
      "y",
      "level",
      "trend"
    ]
  },
  "MultiplicativeSeason": {
    "__init__": [
      "self",
      "gamma",
      "seasonality"
    ],
    "update": [
      "self",
      "y",
      "level",
      "trend"
    ]
  },
  "HoltWinters": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "gamma",
      "seasonality",
      "multiplicative"
    ],
    "learn_one": [
      "self",
      "y",
      "x"
    ],
    "forecast": [
      "self",
      "horizon",
      "xs"
    ]
  },
  "MeanForecaster": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "y",
      "x"
    ],
    "forecast": [
      "self",
      "horizon",
      "xs"
    ]
  },
  "test_forecasts_at_each_step": [],
  "Differencer": {
    "__init__": [
      "self",
      "d",
      "m"
    ],
    "n_required_past_values": [
      "self"
    ],
    "from_coeffs": [
      "cls",
      "coeffs"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "diff": [
      "self",
      "p",
      "Y"
    ],
    "undiff": [
      "self",
      "p",
      "Y"
    ]
  },
  "SNARIMAX": {
    "__init__": [
      "self",
      "p",
      "d",
      "q",
      "m",
      "sp",
      "sd",
      "sq",
      "regressor"
    ],
    "_add_lag_features": [
      "self",
      "x",
      "Y",
      "errors"
    ],
    "learn_one": [
      "self",
      "y",
      "x"
    ],
    "forecast": [
      "self",
      "horizon",
      "xs"
    ]
  },
  "Yt": {
    "t": [],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "test_diff_formula": [],
  "test_diff_example": [],
  "test_undiff": [
    "differencer"
  ],
  "test_add_lag_features": [
    "snarimax",
    "Y",
    "errors",
    "expected"
  ],
  "test_no_overflow": [
    "snarimax"
  ],
  "TimeSeries": [],
  "_iter_with_horizon": [
    "dataset",
    "horizon"
  ],
  "iter_evaluate": [
    "dataset",
    "model",
    "metric",
    "horizon",
    "agg_func",
    "grace_period"
  ],
  "ModelSelector": {
    "__init__": [
      "self",
      "models",
      "metric"
    ],
    "best_model": [
      "self"
    ]
  },
  "ModelSelectionRegressor": {
    "predict_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "ModelSelectionClassifier": {
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "test_1259": [],
  "test_bandit_classifier_with_each_policy": [
    "policy"
  ],
  "test_bandit_regressor_with_each_policy": [
    "policy"
  ],
  "SuccessiveHalving": {
    "__init__": [
      "self",
      "models",
      "metric",
      "budget",
      "eta",
      "verbose"
    ],
    "_pred_func": [
      "self",
      "model"
    ],
    "best_model": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "SuccessiveHalvingRegressor": {
    "_pred_func": [
      "self",
      "model"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "SuccessiveHalvingClassifier": {
    "_pred_func": [
      "self",
      "model"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "BanditModelSection": {
    "_pick_arms": [
      "self"
    ],
    "best_model": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "BanditRegressor": {
    "__init__": [
      "self",
      "models",
      "metric",
      "policy"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "BanditClassifier": {
    "__init__": [
      "self",
      "models",
      "metric",
      "policy"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "GreedyRegressor": {
    "__init__": [
      "self",
      "models",
      "metric"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "best_model": [
      "self"
    ]
  },
  "PeakToPeak": {
    "__init__": [
      "self"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingPeakToPeak": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "IQR": {
    "__init__": [
      "self",
      "q_inf",
      "q_sup"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "RollingIQR": {
    "__init__": [
      "self",
      "window_size",
      "q_inf",
      "q_sup"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ],
    "window_size": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "test_incremental_ks_statistics": [],
  "test_issue_1178": [],
  "test_ge": [],
  "EWVar": {
    "__init__": [
      "self",
      "fading_factor"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingQuantile": {
    "__init__": [
      "self",
      "q",
      "window_size"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ],
    "window_size": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Statistic": {
    "_fmt": [],
    "get": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__gt__": [
      "self",
      "other"
    ]
  },
  "Univariate": {
    "update": [
      "self",
      "x"
    ],
    "name": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ]
  },
  "RollingUnivariate": {
    "window_size": [
      "self"
    ],
    "name": [
      "self"
    ]
  },
  "Bivariate": {
    "update": [
      "self",
      "x",
      "y"
    ]
  },
  "Treap": {
    "__init__": [
      "self",
      "key",
      "value"
    ],
    "sum_all": [
      "node",
      "value"
    ],
    "unlazy": [
      "cls",
      "node"
    ],
    "update": [
      "cls",
      "node"
    ],
    "split_keep_right": [
      "cls",
      "node",
      "key"
    ],
    "merge": [
      "cls",
      "left",
      "right"
    ],
    "split_smallest": [
      "cls",
      "node"
    ],
    "split_greatest": [
      "cls",
      "node"
    ],
    "get_size": [
      "node"
    ],
    "get_height": [
      "node"
    ]
  },
  "KolmogorovSmirnov": {
    "__init__": [
      "self",
      "statistic"
    ],
    "update": [
      "self",
      "x",
      "y"
    ],
    "revert": [
      "self",
      "x",
      "y"
    ],
    "get": [
      "self"
    ],
    "_ca": [
      "p_value"
    ],
    "_test_ks_threshold": [
      "self",
      "ca"
    ]
  },
  "Shift": {
    "__init__": [
      "self",
      "amount",
      "fill_value"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ],
    "name": [
      "self"
    ]
  },
  "Kurtosis": {
    "__init__": [
      "self",
      "bias"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Var": {
    "__init__": [
      "self",
      "ddof"
    ],
    "n": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "w"
    ],
    "revert": [
      "self",
      "x",
      "w"
    ],
    "update_many": [
      "self",
      "X"
    ],
    "get": [
      "self"
    ],
    "_from_state": [
      "cls",
      "n",
      "m",
      "sig"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__isub__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ]
  },
  "Mean": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "w"
    ],
    "update_many": [
      "self",
      "X"
    ],
    "revert": [
      "self",
      "x",
      "w"
    ],
    "get": [
      "self"
    ],
    "_from_state": [
      "cls",
      "n",
      "mean"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__isub__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ]
  },
  "BayesianMean": {
    "__init__": [
      "self",
      "prior",
      "prior_weight"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "SEM": {
    "get": [
      "self"
    ]
  },
  "load_stats": [],
  "test_pickling_value": [
    "stat"
  ],
  "test_repr_with_no_updates": [
    "stat"
  ],
  "test_univariate": [
    "stat",
    "func"
  ],
  "test_univariate_frequency_weights": [
    "stat",
    "func"
  ],
  "test_univariate_reliability_weights": [
    "stat",
    "func"
  ],
  "test_rolling_univariate": [
    "stat",
    "func"
  ],
  "test_rolling_univariate_sample_weights": [
    "stat",
    "func"
  ],
  "test_rolling_univariate_reliability_weights": [
    "stat",
    "func"
  ],
  "test_bivariate": [
    "stat",
    "func"
  ],
  "test_rolling_bivariate": [
    "stat",
    "func"
  ],
  "test_update_many_univariate": [
    "stat"
  ],
  "test_update_many_bivariate": [
    "stat"
  ],
  "Min": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingMin": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "NUnique": {
    "P32": [],
    "__init__": [
      "self",
      "error_rate",
      "seed"
    ],
    "name": [
      "self"
    ],
    "_hash": [
      "self",
      "x"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Mode": {
    "__init__": [
      "self",
      "k"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingMode": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Count": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Max": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingMax": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "AbsMax": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "RollingAbsMax": {
    "__init__": [
      "self",
      "window_size"
    ],
    "window_size": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "MAD": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "test_add_mean": [],
  "_weighted_var": [
    "X",
    "W",
    "ddof"
  ],
  "test_add_var": [
    "ddof"
  ],
  "test_sub": [
    "stat"
  ],
  "test_sub_back_to_zero": [
    "stat"
  ],
  "test_add_cov": [
    "ddof"
  ],
  "test_sub_cov": [
    "ddof"
  ],
  "test_weighted_variance_with_close_numbers": [],
  "test_revert": [],
  "Cov": {
    "__init__": [
      "self",
      "ddof"
    ],
    "n": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "y",
      "w"
    ],
    "revert": [
      "self",
      "x",
      "y",
      "w"
    ],
    "update_many": [
      "self",
      "X",
      "Y"
    ],
    "get": [
      "self"
    ],
    "_from_state": [
      "cls",
      "n",
      "mean_x",
      "mean_y",
      "cov"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__isub__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ]
  },
  "Skew": {
    "__init__": [
      "self",
      "bias"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "PearsonCorr": {
    "__init__": [
      "self",
      "ddof"
    ],
    "ddof": [
      "self"
    ],
    "update": [
      "self",
      "x",
      "y"
    ],
    "update_many": [
      "self",
      "X",
      "Y"
    ],
    "revert": [
      "self",
      "x",
      "y"
    ],
    "get": [
      "self"
    ]
  },
  "Entropy": {
    "__init__": [
      "self",
      "fading_factor",
      "eps"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "AutoCorr": {
    "__init__": [
      "self",
      "lag"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "EWMean": {
    "__init__": [
      "self",
      "fading_factor"
    ],
    "name": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Sum": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ]
  },
  "Link": {
    "__init__": [
      "self",
      "left",
      "right"
    ],
    "update": [
      "self",
      "x"
    ],
    "get": [
      "self"
    ],
    "name": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "iter_sklearn_dataset": [
    "dataset"
  ],
  "Cache": {
    "__init__": [
      "self",
      "directory"
    ],
    "_get_path": [
      "self",
      "key"
    ],
    "__call__": [
      "self",
      "stream",
      "key"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "clear": [
      "self",
      "key"
    ],
    "clear_all": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "iter_pandas": [
    "X",
    "y"
  ],
  "pokedb": [],
  "test_iter_sql": [
    "pokedb"
  ],
  "test_iter_sql_join": [
    "pokedb"
  ],
  "iter_vaex": [
    "X",
    "y",
    "features"
  ],
  "iter_arff": [
    "filepath_or_buffer",
    "target",
    "compression",
    "sparse"
  ],
  "open_filepath": [
    "filepath_or_buffer",
    "compression"
  ],
  "Memento": {
    "__lt__": [
      "self",
      "other"
    ]
  },
  "simulate_qa": [
    "dataset",
    "moment",
    "delay",
    "copy"
  ],
  "iter_polars": [
    "X",
    "y"
  ],
  "TwitterLiveStream": {
    "__init__": [
      "self",
      "rules",
      "bearer_token"
    ],
    "_request": [
      "self",
      "method",
      "endpoint"
    ],
    "_get_rules": [
      "self"
    ],
    "_delete_rules": [
      "self",
      "rules"
    ],
    "_set_rules": [
      "self",
      "rules"
    ],
    "__iter__": [
      "self"
    ]
  },
  "iter_libsvm": [
    "filepath_or_buffer",
    "target_type",
    "compression"
  ],
  "iter_array": [
    "X",
    "y",
    "feature_names",
    "target_names",
    "shuffle",
    "seed"
  ],
  "iter_sql": [
    "query",
    "conn",
    "target_name"
  ],
  "DictReader": {
    "__init__": [
      "self",
      "fraction",
      "rng"
    ],
    "__next__": [
      "self"
    ]
  },
  "iter_csv": [
    "filepath_or_buffer",
    "target",
    "converters",
    "parse_dates",
    "drop",
    "drop_nones",
    "fraction",
    "compression",
    "seed",
    "field_size_limit"
  ],
  "test_iter_csv_custom_converter": [],
  "test_iter_csv_drop_nones": [],
  "SERVER": [],
  "PORT": [],
  "BUFFER_SIZE": [],
  "ENCODING": [],
  "TIMEOUT": [],
  "CHAT_ITEM_PATTERN": [],
  "PING_PATTERN": [],
  "IrcMessage": {
    "PASS": [],
    "NICK": [],
    "JOIN": [],
    "PONG": []
  },
  "ChatMessageItem": {},
  "TwitchChatStream": {
    "__init__": [
      "self",
      "nickname",
      "token",
      "channels",
      "buffer_size",
      "timeout"
    ],
    "_send": [
      "self",
      "s",
      "msg",
      "payload"
    ],
    "_setup_connection": [
      "self",
      "s"
    ],
    "_is_ping": [
      "self",
      "resp"
    ],
    "_extract_chat_messages": [
      "self",
      "resp",
      "dt"
    ],
    "_gen_items": [
      "self",
      "sock"
    ],
    "__iter__": [
      "self"
    ]
  },
  "shuffle": [
    "stream",
    "buffer_size",
    "seed"
  ],
  "VarianceThreshold": {
    "__init__": [
      "self",
      "threshold",
      "min_samples"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "check_feature": [
      "self",
      "feature"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "SelectKBest": {
    "__init__": [
      "self",
      "similarity",
      "k",
      "use_abs"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "PoissonInclusion": {
    "__init__": [
      "self",
      "p",
      "seed"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "KMeans": {
    "__init__": [
      "self",
      "n_clusters",
      "halflife",
      "mu",
      "sigma",
      "p",
      "seed"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "learn_predict_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "TextClust": {
    "__init__": [
      "self",
      "radius",
      "fading_factor",
      "tgap",
      "term_fading",
      "real_time_fading",
      "micro_distance",
      "macro_distance",
      "num_macro",
      "min_weight",
      "auto_r",
      "auto_merge",
      "sigma"
    ],
    "learn_one": [
      "self",
      "x",
      "t",
      "w"
    ],
    "predict_one": [
      "self",
      "x",
      "w",
      "type"
    ],
    "_get_closest_mc": [
      "self",
      "mc",
      "idf",
      "distance"
    ],
    "_calculateIDF": [
      "self",
      "micro_clusters"
    ],
    "_updateweights": [
      "self"
    ],
    "_cleanup": [
      "self"
    ],
    "_mergemicroclusters": [
      "self"
    ],
    "_get_distance_matrix": [
      "self",
      "clusters"
    ],
    "_agglomerative_clustering": [
      "self",
      "micros",
      "k"
    ],
    "updateMacroClusters": [
      "self"
    ],
    "get_macroclusters": [
      "self"
    ],
    "showclusters": [
      "self",
      "topn",
      "num",
      "type"
    ],
    "get_assignment": [
      "self",
      "x",
      "type"
    ]
  },
  "STREAMKMeans": {
    "__init__": [
      "self",
      "chunk_size",
      "n_clusters"
    ],
    "learn_one": [
      "self",
      "x",
      "w"
    ],
    "predict_one": [
      "self",
      "x",
      "w"
    ]
  },
  "CluStream": {
    "__init__": [
      "self",
      "n_macro_clusters",
      "max_micro_clusters",
      "micro_cluster_r_factor",
      "time_window",
      "time_gap",
      "seed"
    ],
    "_maintain_micro_clusters": [
      "self",
      "x",
      "w"
    ],
    "_get_closest_mc": [
      "self",
      "x"
    ],
    "_distance": [
      "point_a",
      "point_b"
    ],
    "learn_one": [
      "self",
      "x",
      "w"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "CluStreamMicroCluster": {
    "__init__": [
      "self",
      "x",
      "w",
      "timestamp"
    ],
    "center": [
      "self"
    ],
    "radius": [
      "self",
      "r_factor"
    ],
    "_deviation": [
      "self"
    ],
    "weight": [
      "self"
    ],
    "insert": [
      "self",
      "x",
      "w",
      "timestamp"
    ],
    "relevance_stamp": [
      "self",
      "max_mc"
    ],
    "_quantile": [
      "self",
      "z"
    ],
    "inverse_error": [
      "x"
    ],
    "__iadd__": [
      "self",
      "other"
    ]
  },
  "DenStream": {
    "__init__": [
      "self",
      "decaying_factor",
      "beta",
      "mu",
      "epsilon",
      "n_samples_init",
      "stream_speed"
    ],
    "centers": [
      "self"
    ],
    "_distance": [
      "point_a",
      "point_b"
    ],
    "_get_closest_cluster_key": [
      "self",
      "point",
      "clusters"
    ],
    "_merge": [
      "self",
      "point"
    ],
    "_is_directly_density_reachable": [
      "self",
      "c_p",
      "c_q"
    ],
    "_query_neighbor": [
      "self",
      "cluster"
    ],
    "_generate_clusters_for_labels": [
      "cluster_labels"
    ],
    "_expand_cluster": [
      "self",
      "mc",
      "neighborhood"
    ],
    "_get_neighborhood_ids": [
      "self",
      "item"
    ],
    "_initial_dbscan": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "w"
    ],
    "predict_one": [
      "self",
      "x",
      "w"
    ]
  },
  "DenStreamMicroCluster": {
    "__init__": [
      "self",
      "x",
      "timestamp",
      "decaying_factor"
    ],
    "calc_norm_cf1_cf2": [
      "self",
      "fading_factor"
    ],
    "calc_weight": [
      "self",
      "timestamp"
    ],
    "_weight": [
      "self",
      "fading_factor"
    ],
    "calc_center": [
      "self",
      "timestamp"
    ],
    "calc_radius": [
      "self",
      "timestamp"
    ],
    "insert": [
      "self",
      "x",
      "timestamp"
    ],
    "merge": [
      "self",
      "cluster"
    ],
    "fading_function": [
      "self",
      "time"
    ]
  },
  "DBSTREAM": {
    "__init__": [
      "self",
      "clustering_threshold",
      "fading_factor",
      "cleanup_interval",
      "intersection_factor",
      "minimum_weight"
    ],
    "_distance": [
      "point_a",
      "point_b"
    ],
    "_find_fixed_radius_nn": [
      "self",
      "x"
    ],
    "_gaussian_neighborhood": [
      "self",
      "point_a",
      "point_b"
    ],
    "_update": [
      "self",
      "x"
    ],
    "_cleanup": [
      "self"
    ],
    "_generate_weighted_adjacency_matrix": [
      "self"
    ],
    "_generate_labels": [
      "self",
      "weighted_adjacency_list"
    ],
    "_generate_clusters_from_labels": [
      "self",
      "cluster_labels"
    ],
    "_recluster": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "w"
    ],
    "predict_one": [
      "self",
      "x",
      "w"
    ],
    "n_clusters": [
      "self"
    ],
    "clusters": [
      "self"
    ],
    "centers": [
      "self"
    ],
    "micro_clusters": [
      "self"
    ]
  },
  "DBSTREAMMicroCluster": {
    "__init__": [
      "self",
      "x",
      "last_update",
      "weight"
    ],
    "merge": [
      "self",
      "cluster"
    ]
  },
  "ODAC": {
    "__init__": [
      "self",
      "confidence_level",
      "n_min",
      "tau"
    ],
    "n_active_clusters": [
      "self"
    ],
    "n_clusters": [
      "self"
    ],
    "height": [
      "self"
    ],
    "summary": [
      "self"
    ],
    "_calculate_height": [
      "self",
      "node"
    ],
    "_count_clusters": [
      "self",
      "node"
    ],
    "_count_active_clusters": [
      "self",
      "node"
    ],
    "_find_all_active_clusters": [
      "self",
      "node"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "render_ascii": [
      "self",
      "n_decimal_places"
    ],
    "draw": [
      "self",
      "max_depth",
      "show_clusters_info",
      "n_decimal_places"
    ],
    "structure_changed": [
      "self"
    ]
  },
  "ODACCluster": {
    "__init__": [
      "self",
      "name",
      "parent"
    ],
    "design_structure": [
      "self",
      "decimal_places"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_init_stats": [
      "self"
    ],
    "__call__": [
      "self",
      "ts_names"
    ],
    "update_statistics": [
      "self",
      "x"
    ],
    "_calculate_rnomc_dict": [
      "self"
    ],
    "calculate_coefficients": [
      "self",
      "confidence_level"
    ],
    "_get_closest_cluster": [
      "self",
      "pivot_1",
      "pivot_2",
      "current",
      "rnormc_dict"
    ],
    "_split_this_cluster": [
      "self",
      "pivot_1",
      "pivot_2",
      "rnormc_dict"
    ],
    "_aggregate_this_cluster": [
      "self"
    ],
    "test_split": [
      "self",
      "tau"
    ],
    "test_aggregate": [
      "self"
    ]
  },
  "ODACChildren": {
    "__init__": [
      "self",
      "first",
      "second"
    ],
    "reset_parent": [
      "self"
    ]
  },
  "build_dbstream": [
    "fading_factor",
    "intersection_factor"
  ],
  "add_cluster": [
    "dbstream",
    "initial_point",
    "move_towards",
    "times"
  ],
  "assert_micro_cluster_properties": [
    "cluster",
    "center",
    "last_update"
  ],
  "test_cluster_formation_and_cleanup": [],
  "test_with_two_micro_clusters": [],
  "test_density_graph_with_three_micro_clusters": [],
  "test_density_graph_with_removed_microcluster": [],
  "test_dbstream_synthetic_sklearn": [],
  "check_learn_one": [
    "model",
    "dataset"
  ],
  "check_shuffle_features_no_impact": [
    "model",
    "dataset"
  ],
  "check_emerging_features": [
    "model",
    "dataset"
  ],
  "check_disappearing_features": [
    "model",
    "dataset"
  ],
  "check_radically_disappearing_features": [
    "model",
    "dataset"
  ],
  "check_debug_one": [
    "model",
    "dataset"
  ],
  "check_pickling": [
    "model",
    "dataset"
  ],
  "check_has_tag": [
    "model",
    "tag"
  ],
  "check_repr": [
    "model"
  ],
  "check_str": [
    "model"
  ],
  "check_tags": [
    "model"
  ],
  "check_clone_same_class": [
    "model"
  ],
  "check_clone_is_idempotent": [
    "model"
  ],
  "check_mutate_can_be_idempotent": [
    "model"
  ],
  "check_init_has_default_params_for_tests": [
    "model"
  ],
  "check_init_default_params_are_not_mutable": [
    "model"
  ],
  "check_doc": [
    "model"
  ],
  "check_clone_changes_memory_addresses": [
    "model"
  ],
  "check_seeding_is_idempotent": [
    "model",
    "dataset"
  ],
  "check_mutable_attributes_exist": [
    "model"
  ],
  "check_wrapper_accepts_kwargs": [
    "wrapper"
  ],
  "check_roc_auc": [
    "anomaly_detector",
    "dataset"
  ],
  "assert_predictions_are_close": [
    "y1",
    "y2"
  ],
  "seed_params": [
    "params",
    "seed"
  ],
  "_allow_exception": [
    "func",
    "exception"
  ],
  "_wrapped_partial": [
    "func"
  ],
  "_DummyDataset": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "_yield_datasets": [
    "model"
  ],
  "yield_checks": [
    "model"
  ],
  "check_estimator": [
    "model"
  ],
  "check_model_selection_order_does_not_matter": [
    "model",
    "dataset"
  ],
  "check_predict_proba_one": [
    "classifier",
    "dataset"
  ],
  "check_predict_proba_one_binary": [
    "classifier",
    "dataset"
  ],
  "check_multiclass_is_bool": [
    "model"
  ],
  "check_reco_routine": [
    "ranker"
  ],
  "make_counter": [
    "skip"
  ],
  "OrdinalEncoder": {
    "__init__": [
      "self",
      "unknown_value",
      "none_value"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_many": [
      "self",
      "X"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ]
  },
  "test_gaussian_random_projector_dot_product": [],
  "test_sparse_random_projector_dot_product": [],
  "test_sparse_random_projector_size": [],
  "GaussianRandomProjector": {
    "__init__": [
      "self",
      "n_components",
      "seed"
    ],
    "_rand_gauss": [
      "self"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "SparseRandomProjector": {
    "__init__": [
      "self",
      "n_components",
      "density",
      "seed"
    ],
    "_rand_weights_for_feature": [
      "self"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "DOC_SET": [],
  "REFERENCE_STATISTICS_TWO_COMPONENTS": [],
  "REFERENCE_STATISTICS_FIVE_COMPONENTS": [],
  "REFERENCE_FIVE_COMPONENTS": [],
  "REFERENCE_COMPONENTS_WITH_PRUNNING": [],
  "REFERENCE_LEARN_ONE_PREDICT_ONE": [],
  "test_extraction_words_ids": [],
  "test_statistics_two_components": [],
  "test_statistics_five_components": [],
  "test_five_components": [],
  "test_prunning_vocabulary": [],
  "test_learn_transform": [],
  "OneHotEncoder": {
    "__init__": [
      "self",
      "drop_zeros",
      "drop_first"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x",
      "y"
    ],
    "learn_many": [
      "self",
      "X"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "FeatureHasher": {
    "__init__": [
      "self",
      "n_features",
      "seed"
    ],
    "_hash": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "test_standard_scaler_one_many_consistent": [],
  "test_standard_scaler_shuffle_columns": [],
  "test_standard_scaler_add_remove_columns": [],
  "test_issue_1313": [],
  "safe_div": [
    "a",
    "b"
  ],
  "Binarizer": {
    "__init__": [
      "self",
      "threshold",
      "dtype"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "StandardScaler": {
    "__init__": [
      "self",
      "with_std"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "MinMaxScaler": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "MaxAbsScaler": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "RobustScaler": {
    "__init__": [
      "self",
      "with_centering",
      "with_scaling",
      "q_inf",
      "q_sup"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Normalizer": {
    "__init__": [
      "self",
      "order"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "AdaptiveStandardScaler": {
    "__init__": [
      "self",
      "fading_factor"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "PredClipper": {
    "__init__": [
      "self",
      "regressor",
      "y_min",
      "y_max"
    ],
    "_wrapped_model": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "LDA": {
    "__init__": [
      "self",
      "n_components",
      "number_of_documents",
      "alpha_theta",
      "alpha_beta",
      "tau",
      "kappa",
      "vocab_prune_interval",
      "number_of_samples",
      "ranking_smooth_factor",
      "burn_in_sweeps",
      "maximum_size_vocabulary",
      "seed"
    ],
    "learn_transform_one": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "_update_indexes": [
      "self",
      "word_list"
    ],
    "_compute_weights": [
      "cls",
      "n_components",
      "nu_1",
      "nu_2"
    ],
    "_update_weights": [
      "self",
      "statistics"
    ],
    "_compute_statistics_components": [
      "self",
      "words_indexes_list"
    ],
    "_prune_vocabulary": [
      "self"
    ]
  },
  "TargetStandardScaler": {
    "__init__": [
      "self",
      "regressor"
    ],
    "_update": [
      "self",
      "y"
    ],
    "_scale": [
      "self",
      "y"
    ],
    "_unscale": [
      "self",
      "y"
    ]
  },
  "TargetMinMaxScaler": {
    "__init__": [
      "self",
      "regressor"
    ],
    "_update": [
      "self",
      "y"
    ],
    "_scale": [
      "self",
      "y"
    ],
    "_unscale": [
      "self",
      "y"
    ]
  },
  "PreviousImputer": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "StatImputer": {
    "__init__": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "MultiLabelClassifier": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "MultiTargetRegressor": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "_BaseDriftDetector": {
    "__init__": [
      "self"
    ],
    "_reset": [
      "self"
    ],
    "drift_detected": [
      "self"
    ]
  },
  "_BaseDriftAndWarningDetector": {
    "__init__": [
      "self"
    ],
    "_reset": [
      "self"
    ],
    "warning_detected": [
      "self"
    ]
  },
  "DriftDetector": {
    "update": [
      "self",
      "x"
    ]
  },
  "DriftAndWarningDetector": {},
  "BinaryDriftDetector": {
    "update": [
      "self",
      "x"
    ]
  },
  "BinaryDriftAndWarningDetector": {},
  "Base": {
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_get_params": [
      "self"
    ],
    "clone": [
      "self",
      "new_params",
      "include_attributes"
    ],
    "_mutable_attributes": [
      "self"
    ],
    "mutate": [
      "self",
      "new_attrs"
    ],
    "_is_stochastic": [
      "self"
    ],
    "_raw_memory_usage": [
      "self"
    ],
    "_memory_usage": [
      "self"
    ]
  },
  "_log_method_calls": [
    "self",
    "name",
    "class_condition",
    "method_condition"
  ],
  "log_method_calls": [
    "class_condition",
    "method_condition"
  ],
  "_repr_obj": [
    "obj",
    "show_modules",
    "depth"
  ],
  "Classifier": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_multiclass": [
      "self"
    ],
    "_supervised": [
      "self"
    ]
  },
  "MiniBatchClassifier": {
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "predict_proba_many": [
      "self",
      "X"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "Clusterer": {
    "_supervised": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "BaseTransformer": {
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "Transformer": {
    "_supervised": [
      "self"
    ],
    "learn_one": [
      "self",
      "x"
    ]
  },
  "SupervisedTransformer": {
    "_supervised": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "MiniBatchTransformer": {
    "transform_many": [
      "self",
      "X"
    ],
    "learn_many": [
      "self",
      "X"
    ]
  },
  "MiniBatchSupervisedTransformer": {
    "_supervised": [
      "self"
    ],
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "Wrapper": {
    "_wrapped_model": [
      "self"
    ],
    "_labelloc": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "_supervised": [
      "self"
    ],
    "_multiclass": [
      "self"
    ]
  },
  "FeatureName": [],
  "RegTarget": [],
  "ClfTarget": [],
  "Target": [],
  "Stream": [],
  "Learner": {
    "learn_one": [
      "self",
      "x",
      "y"
    ]
  },
  "Predictor": {
    "predict_one": [
      "self",
      "x"
    ]
  },
  "TEXT_INPUT": [],
  "POSITIVE_INPUT": [],
  "Estimator": {
    "_supervised": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "_repr_html_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "_tags": [
      "self"
    ],
    "_unit_test_params": [
      "self"
    ],
    "_unit_test_skips": [
      "self"
    ]
  },
  "Regressor": {
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "MiniBatchRegressor": {
    "learn_many": [
      "self",
      "X",
      "y"
    ],
    "predict_many": [
      "self",
      "X"
    ]
  },
  "to_html": [
    "obj"
  ],
  "estimator_to_html": [
    "estimator"
  ],
  "pipeline_to_html": [
    "pipeline"
  ],
  "union_to_html": [
    "union"
  ],
  "wrapper_to_html": [
    "wrapper"
  ],
  "Ensemble": {
    "__init__": [
      "self",
      "models"
    ],
    "_min_number_of_models": [
      "self"
    ],
    "models": [
      "self"
    ]
  },
  "WrapperEnsemble": {
    "__init__": [
      "self",
      "model",
      "n_models",
      "seed"
    ],
    "_wrapped_model": [
      "self"
    ]
  },
  "test_clone_estimator": [],
  "test_clone_include_attributes": [],
  "test_clone_pipeline": [],
  "test_clone_idempotent": [],
  "test_memory_usage": [],
  "test_mutate": [],
  "test_clone_positional_args": [],
  "test_clone_nested_pipeline": [],
  "Agg": {
    "__init__": [
      "self",
      "on",
      "by",
      "how"
    ],
    "_make_key": [
      "self",
      "x"
    ],
    "learn_one": [
      "self",
      "x",
      "t"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "state": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "TargetAgg": {
    "__init__": [
      "self",
      "by",
      "how",
      "target_name"
    ],
    "target_name": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y",
      "t"
    ]
  },
  "test_ngrams": [
    "params",
    "text",
    "expected_ngrams"
  ],
  "N_GRAM": [],
  "strip_accents_unicode": [
    "s"
  ],
  "tokenize_using_regex_pattern": [
    "text",
    "pattern"
  ],
  "remove_stop_words": [
    "tokens",
    "stop_words"
  ],
  "find_ngrams": [
    "tokens",
    "n"
  ],
  "find_all_ngrams": [
    "tokens",
    "ngram_range"
  ],
  "VectorizerMixin": {
    "__init__": [
      "self",
      "on",
      "strip_accents",
      "lowercase",
      "preprocessor",
      "stop_words",
      "tokenizer_pattern",
      "tokenizer",
      "ngram_range"
    ],
    "process_text": [
      "self",
      "x"
    ],
    "_more_tags": [
      "self"
    ]
  },
  "BagOfWords": {
    "transform_one": [
      "self",
      "x"
    ],
    "transform_many": [
      "self",
      "X"
    ],
    "learn_many": [
      "self",
      "X"
    ]
  },
  "TFIDF": {
    "__init__": [
      "self",
      "normalize",
      "on",
      "strip_accents",
      "lowercase",
      "preprocessor",
      "stop_words",
      "tokenizer_pattern",
      "tokenizer",
      "ngram_range"
    ],
    "learn_one": [
      "self",
      "x"
    ],
    "transform_one": [
      "self",
      "x"
    ],
    "learn_many": [
      "self",
      "X"
    ],
    "transform_many": [
      "self",
      "X"
    ]
  },
  "RBFSampler": {
    "__init__": [
      "self",
      "gamma",
      "n_components",
      "seed"
    ],
    "_random_weights": [
      "self"
    ],
    "transform_one": [
      "self",
      "x",
      "y"
    ]
  },
  "powerset": [
    "iterable",
    "min_size",
    "max_size",
    "with_replacement"
  ],
  "PolynomialExtender": {
    "__init__": [
      "self",
      "degree",
      "interaction_only",
      "include_bias",
      "bias_name"
    ],
    "_enumerate": [
      "self",
      "keys"
    ],
    "transform_one": [
      "self",
      "x"
    ]
  },
  "test_agg_lag": [],
  "test_target_agg_lag": [],
  "_progressive_validation": [
    "dataset",
    "model",
    "metric",
    "checkpoints",
    "moment",
    "delay",
    "measure_time",
    "measure_memory",
    "yield_predictions"
  ],
  "iter_progressive_val_score": [
    "dataset",
    "model",
    "metric",
    "moment",
    "delay",
    "step",
    "measure_time",
    "measure_memory",
    "yield_predictions"
  ],
  "progressive_val_score": [
    "dataset",
    "model",
    "metric",
    "moment",
    "delay",
    "print_every",
    "show_time",
    "show_memory"
  ],
  "WrappedGenerator": {
    "__init__": [
      "self",
      "n_samples",
      "n_features",
      "task",
      "gen"
    ],
    "__iter__": [
      "self"
    ]
  },
  "Friedman7k": {
    "__init__": [
      "self"
    ]
  },
  "FriedmanLEA10k": {
    "__init__": [
      "self"
    ]
  },
  "FriedmanGSG10k": {
    "__init__": [
      "self"
    ]
  },
  "Track": {
    "__init__": [
      "self",
      "name",
      "datasets",
      "metric"
    ],
    "__iter__": [
      "self"
    ],
    "run": [
      "self",
      "model",
      "dataset",
      "n_checkpoints"
    ]
  },
  "BinaryClassificationTrack": {
    "__init__": [
      "self"
    ]
  },
  "MultiClassClassificationTrack": {
    "__init__": [
      "self"
    ]
  },
  "RegressionTrack": {
    "__init__": [
      "self"
    ]
  },
  "test_covariance_revert": [
    "ddof"
  ],
  "test_covariance_update_shuffled": [
    "ddof"
  ],
  "test_covariance_update_sampled": [],
  "test_covariance_update_many": [
    "ddof"
  ],
  "test_covariance_update_many_shuffled": [
    "ddof"
  ],
  "test_covariance_update_many_sampled": [],
  "test_precision_update_shuffled": [],
  "test_precision_update_many_mini_batches": [],
  "test_precision_one_many_same": [],
  "SymmetricMatrix": {
    "_fmt": [],
    "matrix": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__repr__": [
      "self"
    ]
  },
  "EmpiricalCovariance": {
    "__init__": [
      "self",
      "ddof"
    ],
    "matrix": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "revert": [
      "self",
      "x"
    ],
    "update_many": [
      "self",
      "X"
    ],
    "_update_from_state": [
      "self",
      "n",
      "mean",
      "cov"
    ],
    "_from_state": [
      "cls",
      "n",
      "mean",
      "cov"
    ]
  },
  "EmpiricalPrecision": {
    "__init__": [
      "self"
    ],
    "matrix": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ],
    "update_many": [
      "self",
      "X"
    ]
  },
  "MultiClassEncoder": {
    "__init__": [
      "self",
      "model"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ],
    "_unit_test_params": [
      "cls"
    ]
  },
  "BaseChain": {
    "__init__": [
      "self",
      "model",
      "order"
    ],
    "_wrapped_model": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "ClassifierChain": {
    "__init__": [
      "self",
      "model",
      "order"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "_multiclass": [
      "self"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_proba_one": [
      "self",
      "x"
    ]
  },
  "RegressorChain": {
    "__init__": [
      "self",
      "model",
      "order"
    ],
    "_unit_test_params": [
      "cls"
    ],
    "learn_one": [
      "self",
      "x",
      "y"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  },
  "ProbabilisticClassifierChain": {
    "__init__": [
      "self",
      "model"
    ],
    "predict_one": [
      "self",
      "x"
    ],
    "_payoff": [
      "self",
      "x",
      "y"
    ]
  },
  "MonteCarloClassifierChain": {
    "__init__": [
      "self",
      "model",
      "m",
      "seed"
    ],
    "_sample": [
      "self",
      "x"
    ],
    "predict_one": [
      "self",
      "x"
    ]
  }
}