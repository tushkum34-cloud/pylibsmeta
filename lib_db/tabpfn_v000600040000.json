{
  "TabPFNError": {},
  "TabPFNUserError": {},
  "TabPFNValidationError": {},
  "TabPFNHuggingFaceGatedRepoError": {
    "__init__": [
      "self",
      "repo_id"
    ]
  },
  "TabPFNOutOfMemoryError": {
    "__init__": [
      "self",
      "original_error"
    ]
  },
  "TabPFNCUDAOutOfMemoryError": {
    "device_name": []
  },
  "TabPFNMPSOutOfMemoryError": {
    "device_name": []
  },
  "handle_oom_errors": [
    "devices",
    "X",
    "model_type"
  ],
  "MIN_NUM_SAMPLES_RECOMMENDED_FOR_TUNING": [],
  "TuningConfig": {
    "resolve": [
      "self",
      "num_samples"
    ]
  },
  "ClassifierTuningConfig": {},
  "ClassifierEvalMetrics": {
    "F1": [],
    "ACCURACY": [],
    "BALANCED_ACCURACY": [],
    "ROC_AUC": [],
    "LOG_LOSS": []
  },
  "METRIC_NAME_TO_OBJECTIVE": [],
  "compute_metric_to_minimize": [
    "metric_name",
    "y_true",
    "y_pred"
  ],
  "get_tuning_splits": [
    "X",
    "y",
    "holdout_frac",
    "n_splits",
    "random_state"
  ],
  "find_optimal_classification_thresholds": [
    "metric_name",
    "y_true",
    "y_pred_probas",
    "n_classes"
  ],
  "find_optimal_classification_threshold_single_class": [
    "metric_name",
    "y_true",
    "y_pred_probas"
  ],
  "select_robust_optimal_threshold": [
    "thresholds_and_losses",
    "plateau_delta"
  ],
  "find_optimal_temperature": [
    "raw_logits",
    "y_true",
    "logits_to_probabilities_fn",
    "current_default_temperature"
  ],
  "get_default_tuning_holdout_frac": [
    "n_samples"
  ],
  "get_default_tuning_n_folds": [
    "n_samples"
  ],
  "resolve_tuning_config": [
    "tuning_config",
    "num_samples"
  ],
  "BaseModelSpecs": {
    "__init__": [
      "self",
      "model",
      "architecture_config",
      "inference_config"
    ]
  },
  "ClassifierModelSpecs": {
    "norm_criterion": []
  },
  "RegressorModelSpecs": {
    "__init__": [
      "self",
      "model",
      "architecture_config",
      "inference_config",
      "norm_criterion"
    ]
  },
  "ModelSpecs": [],
  "initialize_tabpfn_model": [
    "model_path",
    "which",
    "fit_mode"
  ],
  "_assert_inference_configs_equal": [
    "model_specs"
  ],
  "determine_precision": [
    "inference_precision",
    "devices_"
  ],
  "create_inference_engine": [],
  "initialize_model_variables_helper": [
    "calling_instance",
    "model_type"
  ],
  "estimator_to_device": [
    "estimator",
    "device"
  ],
  "initialize_telemetry": [],
  "get_embeddings": [
    "model",
    "X",
    "data_source"
  ],
  "TabPFNSettings": {
    "model_config": [],
    "model_post_init": [
      "self",
      "_"
    ]
  },
  "PytorchSettings": {},
  "TestingSettings": {
    "_parse_ci": [
      "cls",
      "value"
    ]
  },
  "Settings": {},
  "settings": [],
  "MAXINT_RANDOM_SEED": [],
  "get_autocast_context": [
    "device"
  ],
  "_repair_borders": [
    "borders"
  ],
  "_cancel_nan_borders": [],
  "DevicesSpecification": [],
  "infer_devices": [
    "devices"
  ],
  "_parse_device": [
    "device"
  ],
  "_is_mps_supported": [],
  "is_autocast_available": [
    "device_type"
  ],
  "infer_fp16_inference_mode": [
    "devices"
  ],
  "infer_random_state": [
    "random_state"
  ],
  "_map_to_bucket_ix": [
    "y",
    "borders"
  ],
  "_cdf": [
    "logits",
    "borders",
    "ys"
  ],
  "translate_probs_across_borders": [
    "logits"
  ],
  "remove_non_differentiable_preprocessing_from_models": [
    "models"
  ],
  "transform_borders_one": [
    "borders",
    "target_transform"
  ],
  "pad_tensors": [
    "tensor_list",
    "padding_val"
  ],
  "balance_probas_by_class_counts": [
    "probas",
    "class_counts"
  ],
  "convert_batch_of_cat_ix_to_schema": [
    "batch_of_cat_indices",
    "num_features"
  ],
  "DEFAULT_CLASSIFICATION_EVAL_METRIC": [],
  "TabPFNClassifier": {
    "__init__": [
      "self"
    ],
    "create_default_for_version": [
      "cls",
      "version"
    ],
    "estimator_type": [
      "self"
    ],
    "model_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_initialize_model_variables": [
      "self"
    ],
    "_initialize_for_differentiable_input": [
      "self",
      "X",
      "y",
      "rng"
    ],
    "_initialize_dataset_preprocessing": [
      "self",
      "X",
      "y",
      "rng"
    ],
    "_get_tuning_classifier": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_from_preprocessed": [
      "self",
      "X_preprocessed",
      "y_preprocessed",
      "cat_ix",
      "configs"
    ],
    "fit_with_differentiable_input": [
      "self",
      "X",
      "y"
    ],
    "_maybe_calibrate_temperature_and_tune_decision_thresholds": [
      "self",
      "X",
      "y"
    ],
    "_compute_holdout_validation_data": [
      "self",
      "X",
      "y",
      "holdout_frac",
      "n_folds"
    ],
    "_raw_predict": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_logits": [
      "self",
      "X"
    ],
    "predict_raw_logits": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_calibrated_softmax_temperature": [
      "self",
      "holdout_raw_logits",
      "holdout_y_true"
    ],
    "_maybe_reweight_probas": [
      "self",
      "probas"
    ],
    "_apply_temperature": [
      "self",
      "logits"
    ],
    "_average_across_estimators": [
      "self",
      "tensors"
    ],
    "_apply_softmax": [
      "self",
      "logits"
    ],
    "_apply_balancing": [
      "self",
      "probas"
    ],
    "logits_to_probabilities": [
      "self",
      "raw_logits"
    ],
    "forward": [
      "self",
      "X"
    ],
    "get_embeddings": [
      "self",
      "X",
      "data_source"
    ],
    "save_fit_state": [
      "self",
      "path"
    ],
    "load_from_fit_state": [
      "cls",
      "path"
    ],
    "to": [
      "self",
      "device"
    ]
  },
  "_validate_eval_metric": [
    "eval_metric"
  ],
  "R_co": [],
  "ParallelFunction": {
    "__call__": [
      "self"
    ]
  },
  "parallel_execute": [
    "devices",
    "functions"
  ],
  "_execute_in_current_thread": [
    "device",
    "functions"
  ],
  "_execute_with_multithreading": [
    "devices",
    "functions"
  ],
  "_execute_function_in_thread": [
    "all_devices",
    "free_devices",
    "function"
  ],
  "__all__": [],
  "logger": [],
  "FALLBACK_S3_BASE_URL": [],
  "V_2_5_IDENTIFIER": [],
  "ModelType": {
    "CLASSIFIER": [],
    "REGRESSOR": []
  },
  "ModelSource": {
    "get_classifier_v2": [
      "cls"
    ],
    "get_regressor_v2": [
      "cls"
    ],
    "get_classifier_v2_5": [
      "cls"
    ],
    "get_regressor_v2_5": [
      "cls"
    ]
  },
  "_get_model_source": [
    "version",
    "model_type"
  ],
  "_try_huggingface_downloads": [
    "base_path",
    "source",
    "model_name"
  ],
  "_try_direct_downloads": [
    "base_path",
    "source",
    "model_name"
  ],
  "download_model": [
    "to"
  ],
  "download_all_models": [
    "to"
  ],
  "_version_has_direct_download_option": [
    "version"
  ],
  "get_cache_dir": [],
  "_get_download_lock": [],
  "_with_download_lock": [
    "func"
  ],
  "P": [],
  "prepend_cache_path": [
    "model_path"
  ],
  "load_model_criterion_config": [
    "model_path"
  ],
  "_resolve_model_version": [
    "model_path"
  ],
  "_log_model_config": [
    "model_paths",
    "which",
    "version"
  ],
  "log_model_init_params": [
    "estimator",
    "params"
  ],
  "resolve_model_version": [
    "model_path"
  ],
  "resolve_model_path": [
    "model_path",
    "which",
    "version"
  ],
  "get_loss_criterion": [
    "config"
  ],
  "load_model": [],
  "_get_inference_config_from_checkpoint": [
    "checkpoint",
    "criterion"
  ],
  "get_n_out": [
    "config",
    "loss"
  ],
  "save_tabpfn_model": [
    "model",
    "save_path",
    "additional_fields"
  ],
  "save_fitted_tabpfn_model": [
    "estimator",
    "path"
  ],
  "_extract_archive": [
    "path",
    "tmp"
  ],
  "load_fitted_tabpfn_model": [
    "path"
  ],
  "InferenceConfig": {
    "override_with_user_input_and_resolve_auto": [
      "self",
      "user_config"
    ],
    "get_resolved_outlier_removal_std": [
      "self",
      "estimator_type"
    ],
    "get_default": [
      "cls",
      "task_type",
      "model_version"
    ]
  },
  "_get_v2_config": [
    "preprocessor_configs"
  ],
  "_get_v2_5_config": [
    "preprocessor_configs"
  ],
  "ModelVersion": {
    "V2": [],
    "V2_5": []
  },
  "NA_PLACEHOLDER": [],
  "SKLEARN_16_DECIMAL_PRECISION": [],
  "PROBABILITY_EPSILON_ROUND_ZERO": [],
  "REGRESSION_NAN_BORDER_LIMIT_UPPER": [],
  "REGRESSION_NAN_BORDER_LIMIT_LOWER": [],
  "REGRESSION_CONSTANT_TARGET_BORDER_EPSILON": [],
  "AUTOCAST_DTYPE_BYTE_SIZE": [],
  "DEFAULT_DTYPE_BYTE_SIZE": [],
  "DEFAULT_NUMPY_PREPROCESSING_DTYPE": [],
  "MEMORY_SAFETY_FACTOR": [],
  "ENSEMBLE_CONFIGURATION_MAX_STEP": [],
  "MAXIMUM_FEATURE_SHIFT": [],
  "CLASS_SHUFFLE_OVERESTIMATE_FACTOR": [],
  "SUPPORTS_GENERATOR_UNORDERED": [],
  "SUPPORTS_RETURN_AS": [],
  "_OUTPUT_TYPES_BASIC": [],
  "_OUTPUT_TYPES_QUANTILES": [],
  "_OUTPUT_TYPES": [],
  "_OUTPUT_TYPES_COMPOSITE": [],
  "_USABLE_OUTPUT_TYPES": [],
  "OutputType": [],
  "MainOutputDict": {},
  "FullOutputDict": {},
  "RegressionResultType": [],
  "TabPFNRegressor": {
    "__init__": [
      "self"
    ],
    "create_default_for_version": [
      "cls",
      "version"
    ],
    "estimator_type": [
      "self"
    ],
    "model_": [
      "self"
    ],
    "norm_bardist_": [
      "self",
      "value"
    ],
    "bardist_": [
      "self",
      "value"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_initialize_model_variables": [
      "self"
    ],
    "_initialize_dataset_preprocessing": [
      "self",
      "X",
      "y",
      "rng"
    ],
    "fit_from_preprocessed": [
      "self",
      "X_preprocessed",
      "y_preprocessed",
      "cat_ix",
      "configs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_handle_constant_target": [
      "self",
      "n_samples",
      "output_type",
      "quantiles"
    ],
    "get_embeddings": [
      "self",
      "X",
      "data_source"
    ],
    "save_fit_state": [
      "self",
      "path"
    ],
    "load_from_fit_state": [
      "cls",
      "path"
    ],
    "to": [
      "self",
      "device"
    ]
  },
  "_logits_to_output": [],
  "ensure_compatible_fit_inputs": [
    "X",
    "y"
  ],
  "ensure_compatible_predict_input_sklearn": [
    "X",
    "estimator"
  ],
  "validate_dataset_size": [
    "X",
    "y"
  ],
  "ensure_compatible_fit_inputs_sklearn": [
    "X",
    "y"
  ],
  "validate_num_classes": [
    "num_classes",
    "max_num_classes"
  ],
  "_validate_num_samples_and_features": [
    "num_features",
    "num_samples",
    "max_num_samples",
    "max_num_features"
  ],
  "_validate_num_samples_for_cpu": [
    "devices",
    "num_samples"
  ],
  "InferenceEngine": {
    "__init__": [
      "self"
    ],
    "iter_outputs": [
      "self",
      "X"
    ],
    "use_torch_inference_mode": [
      "self"
    ],
    "save_state_except_model_weights": [
      "self",
      "path"
    ],
    "_create_copy_for_pickling": [
      "self"
    ],
    "load_state": [
      "path",
      "models"
    ],
    "_set_models": [
      "self",
      "models"
    ],
    "to": [
      "self",
      "devices",
      "force_inference_dtype",
      "dtype_byte_size"
    ],
    "_move_models_to_devices": [
      "self",
      "devices"
    ]
  },
  "_raise_if_kv_cache_enabled_on_save_or_load": [
    "engine"
  ],
  "SingleDeviceInferenceEngine": {
    "__init__": [
      "self"
    ],
    "_create_copy_for_pickling": [
      "self"
    ],
    "_set_models": [
      "self",
      "models"
    ]
  },
  "MultiDeviceInferenceEngine": {
    "__init__": [
      "self"
    ],
    "_create_copy_for_pickling": [
      "self"
    ],
    "_set_models": [
      "self",
      "models"
    ],
    "_move_models_to_devices": [
      "self",
      "devices"
    ],
    "get_devices": [
      "self"
    ]
  },
  "InferenceEngineOnDemand": {
    "__init__": [
      "self",
      "X_train",
      "y_train"
    ],
    "iter_outputs": [
      "self",
      "X"
    ],
    "_call_model": [
      "self"
    ]
  },
  "InferenceEngineBatchedNoPreprocessing": {
    "__init__": [
      "self",
      "X_trains",
      "y_trains"
    ],
    "iter_outputs": [
      "self",
      "X"
    ],
    "use_torch_inference_mode": [
      "self"
    ],
    "_move_models_to_devices": [
      "self",
      "devices"
    ]
  },
  "InferenceEngineCachePreprocessing": {
    "__init__": [
      "self",
      "X_train",
      "y_train"
    ],
    "iter_outputs": [
      "self",
      "X"
    ],
    "_call_model": [
      "self"
    ],
    "use_torch_inference_mode": [
      "self"
    ]
  },
  "InferenceEngineCacheKV": {
    "__init__": [
      "self",
      "X_train",
      "y_train"
    ],
    "iter_outputs": [
      "self",
      "X"
    ],
    "_move_models_to_devices": [
      "self",
      "devices"
    ]
  },
  "_prepare_model_inputs": [
    "device",
    "force_inference_dtype",
    "X_train",
    "X_test",
    "y_train"
  ],
  "_move_and_squeeze_output": [
    "output",
    "device"
  ],
  "_maybe_run_gpu_preprocessing": [
    "X",
    "gpu_preprocessor"
  ],
  "_PerDeviceModelCache": {
    "__init__": [
      "self",
      "model"
    ],
    "to": [
      "self",
      "devices"
    ],
    "get": [
      "self",
      "device"
    ],
    "set_dtype": [
      "self",
      "dtype"
    ],
    "get_devices": [
      "self"
    ]
  },
  "_get_current_device": [
    "model"
  ],
  "_compute_regression_loss": [],
  "_ranked_probability_score_loss_from_bar_logits": [],
  "FinetunedTabPFNRegressor": {
    "__init__": [
      "self"
    ],
    "_estimator_kwargs": [
      "self"
    ],
    "_model_type": [
      "self"
    ],
    "_metric_name": [
      "self"
    ],
    "_create_estimator": [
      "self",
      "config"
    ],
    "_setup_estimator": [
      "self"
    ],
    "_should_skip_batch": [
      "self",
      "batch"
    ],
    "_setup_batch": [
      "self",
      "batch"
    ],
    "_forward_with_loss": [
      "self",
      "batch"
    ],
    "_evaluate_model": [
      "self",
      "eval_config",
      "X_train",
      "y_train",
      "X_val",
      "y_val"
    ],
    "_is_improvement": [
      "self",
      "current",
      "best"
    ],
    "_get_initial_best_metric": [
      "self"
    ],
    "_get_checkpoint_metrics": [
      "self",
      "eval_result"
    ],
    "_get_valid_finetuning_query_size": [
      "self"
    ],
    "_log_epoch_evaluation": [
      "self",
      "epoch",
      "eval_result",
      "mean_train_loss"
    ],
    "_setup_inference_model": [
      "self",
      "final_inference_eval_config"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "X_val",
      "y_val",
      "output_dir"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_compute_classification_loss": [],
  "FinetunedTabPFNClassifier": {
    "__init__": [
      "self"
    ],
    "_estimator_kwargs": [
      "self"
    ],
    "_model_type": [
      "self"
    ],
    "_metric_name": [
      "self"
    ],
    "_create_estimator": [
      "self",
      "config"
    ],
    "_setup_estimator": [
      "self"
    ],
    "_setup_batch": [
      "self",
      "batch"
    ],
    "_should_skip_batch": [
      "self",
      "batch"
    ],
    "_forward_with_loss": [
      "self",
      "batch"
    ],
    "_evaluate_model": [
      "self",
      "eval_config",
      "X_train",
      "y_train",
      "X_val",
      "y_val"
    ],
    "_is_improvement": [
      "self",
      "current",
      "best"
    ],
    "_get_initial_best_metric": [
      "self"
    ],
    "_get_checkpoint_metrics": [
      "self",
      "eval_result"
    ],
    "_get_valid_finetuning_query_size": [
      "self"
    ],
    "_log_epoch_evaluation": [
      "self",
      "epoch",
      "eval_result",
      "mean_train_loss"
    ],
    "_setup_inference_model": [
      "self",
      "final_inference_eval_config"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "X_val",
      "y_val",
      "output_dir"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_format_train_size": [
    "train_size"
  ],
  "clone_model_for_evaluation": [
    "original_model",
    "eval_init_args",
    "model_class"
  ],
  "get_checkpoint_name": [
    "train_size",
    "epoch"
  ],
  "save_checkpoint": [
    "estimator",
    "output_dir",
    "epoch",
    "optimizer",
    "metrics",
    "train_size"
  ],
  "get_checkpoint_path_and_epoch_from_output_dir": [
    "output_dir",
    "train_size"
  ],
  "get_and_init_optimizer": [
    "model_parameters",
    "learning_rate",
    "weight_decay",
    "checkpoint_path",
    "device"
  ],
  "get_cosine_schedule_with_warmup": [
    "total_steps",
    "warmup_steps"
  ],
  "ClassifierBatch": {},
  "RegressorBatch": {},
  "BaseDatasetConfig": {},
  "ClassifierDatasetConfig": {},
  "RegressorDatasetConfig": {
    "bardist_": [
      "self",
      "value"
    ]
  },
  "_take": [
    "obj",
    "idx"
  ],
  "_chunk_data_non_stratified": [
    "X_shuffled",
    "y_shuffled"
  ],
  "_chunk_data_stratified": [
    "X_shuffled",
    "y_shuffled"
  ],
  "DatasetCollectionWithPreprocessing": {
    "__init__": [
      "self",
      "split_fn",
      "rng",
      "dataset_config_collection",
      "n_preprocessing_jobs"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "_collate_list_field": [
    "batch",
    "field_name",
    "num_estimators",
    "padding_val"
  ],
  "_collate_tensor_field": [
    "batch",
    "field_name",
    "padding_val"
  ],
  "_collate_cat_indices": [
    "batch"
  ],
  "meta_dataset_collator": [
    "batch",
    "padding_val"
  ],
  "shuffle_and_chunk_data": [
    "X",
    "y"
  ],
  "get_preprocessed_dataset_chunks": [
    "calling_instance",
    "X_raw",
    "y_raw",
    "split_fn",
    "max_data_size",
    "model_type"
  ],
  "META_BATCH_SIZE": [],
  "MAX_VALIDATION_SAMPLES": [],
  "EvalResult": {},
  "FinetunedTabPFNBase": {
    "__init__": [
      "self"
    ],
    "_build_estimator_config": [
      "self",
      "base_config",
      "n_estimators_override"
    ],
    "_build_eval_config": [
      "self",
      "base_config",
      "n_estimators_override"
    ],
    "_estimator_kwargs": [
      "self"
    ],
    "_model_type": [
      "self"
    ],
    "_metric_name": [
      "self"
    ],
    "_create_estimator": [
      "self",
      "config"
    ],
    "_setup_estimator": [
      "self"
    ],
    "_setup_batch": [
      "self",
      "batch"
    ],
    "_should_skip_batch": [
      "self",
      "batch"
    ],
    "_forward_with_loss": [
      "self",
      "batch"
    ],
    "_evaluate_model": [
      "self",
      "eval_config",
      "X_train",
      "y_train",
      "X_val",
      "y_val"
    ],
    "_is_improvement": [
      "self",
      "current",
      "best"
    ],
    "_get_initial_best_metric": [
      "self"
    ],
    "_get_checkpoint_metrics": [
      "self",
      "eval_result"
    ],
    "_log_epoch_evaluation": [
      "self",
      "epoch",
      "eval_result",
      "mean_train_loss"
    ],
    "_setup_inference_model": [
      "self",
      "final_inference_eval_config"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_get_train_val_split": [
      "self",
      "X",
      "y"
    ],
    "_get_valid_finetuning_query_size": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "X_val",
      "y_val",
      "output_dir"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "X_val",
      "y_val",
      "output_dir"
    ]
  },
  "ArchitectureConfig": {
    "get_unused_config": [
      "self",
      "unparsed_config"
    ]
  },
  "_get_unused_items": [
    "full_config",
    "used_config"
  ],
  "ArchitectureModule": {
    "parse_config": [
      "self",
      "config"
    ],
    "get_architecture": [
      "self",
      "config"
    ]
  },
  "Architecture": {
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "register_architecture": [
    "name",
    "module"
  ],
  "TorchPreprocessingPipeline": {
    "__init__": [
      "self",
      "steps",
      "output_key"
    ],
    "forward": [
      "self",
      "input",
      "single_eval_pos"
    ]
  },
  "TorchPreprocessingStep": {
    "__init__": [
      "self",
      "in_keys",
      "out_keys"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ],
    "_validate_input_keys": [
      "self",
      "state"
    ],
    "_validate_output_keys": [
      "self",
      "outputs"
    ],
    "forward": [
      "self",
      "state"
    ]
  },
  "NanHandlingEncoderStep": {
    "nan_indicator": [],
    "inf_indicator": [],
    "neg_inf_indicator": [],
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "state",
      "single_eval_pos"
    ],
    "_transform": [
      "self",
      "state"
    ],
    "_validate_keys": [
      "self"
    ]
  },
  "FrequencyFeatureEncoderStep": {
    "__init__": [
      "self",
      "num_features",
      "num_frequencies",
      "freq_power_base",
      "max_wave_length",
      "in_keys",
      "out_keys"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "torch_nansum": [
    "x",
    "axis"
  ],
  "torch_nanmean": [
    "x",
    "axis"
  ],
  "torch_nanstd": [
    "x",
    "axis"
  ],
  "normalize_data": [
    "data"
  ],
  "select_features": [
    "x",
    "sel"
  ],
  "remove_outliers": [
    "X",
    "n_sigma",
    "normalize_positions",
    "lower",
    "upper"
  ],
  "FeatureTransformEncoderStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "state",
      "single_eval_pos"
    ],
    "_transform": [
      "self",
      "state",
      "single_eval_pos"
    ]
  },
  "NormalizeFeatureGroupsEncoderStep": {
    "__init__": [
      "self",
      "num_features_per_group"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "RemoveEmptyFeaturesEncoderStep": {
    "__init__": [
      "self",
      "in_keys",
      "out_keys"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "LinearInputEncoderStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "MLPInputEncoderStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "MulticlassClassificationTargetEncoderStep": {
    "__init__": [
      "self",
      "in_keys",
      "out_keys"
    ],
    "_apply": [
      "self",
      "fn"
    ],
    "_fit": [
      "self",
      "state",
      "single_eval_pos"
    ],
    "flatten_targets": [
      "y",
      "unique_ys"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "RemoveDuplicateFeaturesEncoderStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "state"
    ],
    "_transform": [
      "self",
      "state"
    ]
  },
  "AddThinkingTokens": {
    "__init__": [
      "self",
      "num_thinking_rows",
      "emsize"
    ],
    "forward": [
      "self",
      "embedded_input",
      "single_eval_pos"
    ],
    "reset_parameters": [
      "self"
    ]
  },
  "BarDistribution": {
    "__init__": [
      "self",
      "borders"
    ],
    "has_equal_borders": [
      "self",
      "other"
    ],
    "bucket_widths": [
      "self"
    ],
    "num_bars": [
      "self"
    ],
    "cdf": [
      "self",
      "logits",
      "ys"
    ],
    "get_probs_for_different_borders": [
      "self",
      "logits",
      "new_borders"
    ],
    "average_bar_distributions_into_this": [
      "self",
      "list_of_bar_distributions",
      "list_of_logits"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "map_to_bucket_idx": [
      "self",
      "y"
    ],
    "ignore_init": [
      "self",
      "y"
    ],
    "compute_scaled_log_probs": [
      "self",
      "logits"
    ],
    "full_ce": [
      "self",
      "logits",
      "probs"
    ],
    "forward": [
      "self",
      "logits",
      "y",
      "mean_prediction_logits"
    ],
    "mean_loss": [
      "self",
      "logits",
      "mean_prediction_logits"
    ],
    "mean": [
      "self",
      "logits"
    ],
    "median": [
      "self",
      "logits"
    ],
    "cdf_temporary": [
      "self",
      "logits"
    ],
    "icdf": [
      "self",
      "logits",
      "left_prob"
    ],
    "quantile": [
      "self",
      "logits",
      "center_prob"
    ],
    "ucb": [
      "self",
      "logits",
      "best_f",
      "rest_prob"
    ],
    "mode": [
      "self",
      "logits"
    ],
    "ei": [
      "self",
      "logits",
      "best_f"
    ],
    "pi": [
      "self",
      "logits",
      "best_f"
    ],
    "mean_of_square": [
      "self",
      "logits"
    ],
    "variance": [
      "self",
      "logits"
    ],
    "plot": [
      "self",
      "logits",
      "ax",
      "zoom_to_quantile"
    ]
  },
  "FullSupportBarDistribution": {
    "__init__": [
      "self",
      "borders"
    ],
    "assert_support": [
      "self"
    ],
    "halfnormal_with_p_weight_before": [
      "range_max",
      "p"
    ],
    "forward": [
      "self",
      "logits",
      "y",
      "mean_prediction_logits"
    ],
    "pdf": [
      "self",
      "logits",
      "y"
    ],
    "sample": [
      "self",
      "logits",
      "t"
    ],
    "mean": [
      "self",
      "logits"
    ],
    "mean_of_square": [
      "self",
      "logits"
    ],
    "pi": [
      "self",
      "logits",
      "best_f"
    ],
    "ei_for_halfnormal": [
      "self",
      "scale",
      "best_f"
    ],
    "ei": [
      "self",
      "logits",
      "best_f"
    ]
  },
  "get_bucket_limits": [
    "num_outputs",
    "full_range",
    "ys"
  ],
  "Activation": {
    "GELU": [],
    "RELU": []
  },
  "MLP": {
    "__init__": [
      "self",
      "size",
      "hidden_size",
      "activation"
    ],
    "_compute": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "parse_config": [
    "config"
  ],
  "get_architecture": [
    "config"
  ],
  "get_encoder": [],
  "get_y_encoder": [],
  "_legacy_normalize_features_no_op": [
    "num_features_per_group"
  ],
  "col_embedding_path": [],
  "COL_EMBEDDING": [],
  "LayerStack": {
    "__init__": [
      "self"
    ],
    "of_repeated_layer": [
      "cls",
      "layer_creator"
    ],
    "forward": [
      "self",
      "x",
      "recompute_layer"
    ]
  },
  "PerFeatureTransformer": {
    "__init__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ],
    "add_embeddings": [
      "self",
      "x",
      "y"
    ],
    "empty_trainset_representation_cache": [
      "self"
    ]
  },
  "_networkx_add_direct_connections": [
    "graph"
  ],
  "_add_pos_emb": [
    "graph"
  ],
  "FeaturePositionalEmbedding": [],
  "ModelConfig": {
    "upgrade_config": [
      "cls",
      "config"
    ],
    "_get_default": [
      "cls",
      "field"
    ],
    "validate_consistent": [
      "self"
    ]
  },
  "DEFAULT_SAVE_PEAK_MEMORY_FACTOR": [],
  "support_save_peak_mem_factor": [
    "method"
  ],
  "MemorySavingMode": [],
  "should_save_peak_mem": [
    "memory_saving_mode",
    "X_train_shape",
    "X_test_shape",
    "devices",
    "dtype_byte_size"
  ],
  "_should_save_peak_mem_cpu": [
    "X_train_shape",
    "X_test_shape"
  ],
  "_should_save_peak_mem_cuda": [
    "X_train_shape",
    "X_test_shape",
    "devices",
    "dtype_byte_size"
  ],
  "_get_free_cuda_memory_bytes": [
    "device"
  ],
  "_get_num_cells": [
    "X_train_shape",
    "X_test_shape"
  ],
  "HIDDEN_SIZE_LIMIT": [],
  "MLP_SAVE_PEAK_MEM_FACTOR": [],
  "LayerNorm": {
    "__init__": [
      "self"
    ],
    "_compute": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "PerFeatureEncoderLayer": {
    "__init__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "forward": [
      "self",
      "state",
      "single_eval_pos"
    ],
    "empty_trainset_representation_cache": [
      "self"
    ]
  },
  "_get_feature_attn_constructor": [
    "config"
  ],
  "_get_item_attn_constructor": [
    "config"
  ],
  "Attention": {
    "forward": [
      "self",
      "x",
      "x_kv"
    ]
  },
  "TORCH_VERSION": [],
  "TORCH_2_ATTENTION_POSSIBLE": [],
  "_gqa_is_supported": [],
  "USE_TORCH_2_GQA": [],
  "MultiHeadAttention": {
    "w_q": [
      "self"
    ],
    "w_k": [
      "self"
    ],
    "w_v": [
      "self"
    ],
    "w_qkv": [
      "self"
    ],
    "w_kv": [
      "self"
    ],
    "w_out": [
      "self"
    ],
    "has_cached_kv": [
      "self"
    ],
    "empty_kv_cache": [
      "self"
    ],
    "set_parameters": [
      "self",
      "w_out",
      "w_q",
      "w_k",
      "w_v",
      "w_kv",
      "w_qkv",
      "precomputed_k",
      "precomputed_v",
      "precomputed_kv"
    ],
    "newly_initialized_input_weight": [
      "self",
      "dims",
      "nhead",
      "device",
      "dtype"
    ],
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "x_kv"
    ],
    "compute_qkv": [
      "self",
      "x",
      "x_kv",
      "k_cache",
      "v_cache",
      "kv_cache"
    ],
    "_compute": [
      "self",
      "x",
      "x_kv",
      "k_cache",
      "v_cache",
      "kv_cache"
    ],
    "_rearrange_inputs_to_flat_batch": [
      "self",
      "x",
      "x_kv"
    ],
    "broadcast_kv_across_heads": [
      "kv",
      "share_kv_across_n_heads"
    ],
    "scaled_dot_product_attention_chunked": [
      "q",
      "k",
      "v",
      "dropout_p",
      "max_batch_size"
    ],
    "compute_attention_heads": [
      "q",
      "k",
      "v",
      "kv",
      "qkv",
      "dropout_p",
      "softmax_scale"
    ],
    "convert_torch_nn_multihead_attention_state_dict": [
      "state_dict",
      "nhead"
    ]
  },
  "SystemEnv": [],
  "COMMON_PATTERNS": [],
  "NVIDIA_PATTERNS": [],
  "CONDA_PATTERNS": [],
  "PIP_PATTERNS": [],
  "_run": [
    "command"
  ],
  "_run_and_read_all": [
    "run_lambda",
    "command"
  ],
  "_run_and_parse_first_match": [
    "run_lambda",
    "command",
    "regex"
  ],
  "_run_and_return_first_line": [
    "run_lambda",
    "command"
  ],
  "_get_conda_packages": [
    "run_lambda",
    "patterns"
  ],
  "_get_gcc_version": [
    "run_lambda"
  ],
  "_get_clang_version": [
    "run_lambda"
  ],
  "_get_cmake_version": [
    "run_lambda"
  ],
  "_get_nvidia_driver_version": [
    "run_lambda"
  ],
  "_get_gpu_info": [
    "run_lambda"
  ],
  "_get_running_cuda_version": [
    "run_lambda"
  ],
  "_get_cudnn_version": [
    "run_lambda"
  ],
  "_get_nvidia_smi": [],
  "_get_cpu_info": [
    "run_lambda"
  ],
  "_get_platform": [],
  "_get_mac_version": [
    "run_lambda"
  ],
  "_get_windows_version": [
    "run_lambda"
  ],
  "_get_lsb_version": [
    "run_lambda"
  ],
  "_check_release_file": [
    "run_lambda"
  ],
  "_get_os": [
    "run_lambda"
  ],
  "_get_python_platform": [],
  "_get_libc_version": [],
  "_get_pip_packages": [
    "run_lambda",
    "patterns"
  ],
  "_get_cachingallocator_config": [],
  "_get_cuda_module_loading_config": [],
  "_is_xnnpack_available": [],
  "_get_env_info": [],
  "env_info_fmt": [],
  "_replace_nones": [
    "dct",
    "replacement"
  ],
  "_replace_bools": [
    "dct",
    "true",
    "false"
  ],
  "_prepend": [
    "text",
    "tag"
  ],
  "_replace_if_empty": [
    "text",
    "replacement"
  ],
  "_maybe_start_on_next_line": [
    "string"
  ],
  "_pretty_str": [
    "envinfo"
  ],
  "_get_deps_info": [],
  "display_debug_info": [],
  "sklearn_version": [],
  "_dataclass_args": [],
  "get_tags": [
    "estimator"
  ],
  "_to_new_tags": [
    "old_tags",
    "estimator"
  ],
  "infer_categorical_features": [
    "X"
  ],
  "PreprocessingStepResult": {
    "__post_init__": [
      "self"
    ]
  },
  "PreprocessingPipelineResult": {},
  "PreprocessingStep": {
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "feature_schema"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_validate_added_data": [
      "self",
      "X_added",
      "modality_added"
    ]
  },
  "PreprocessingPipeline": {
    "__init__": [
      "self",
      "steps"
    ],
    "fit_transform": [
      "self",
      "X",
      "feature_schema"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_process_steps": [
      "self",
      "X",
      "feature_schema"
    ],
    "_maybe_append_added_columns": [
      "self",
      "X",
      "feature_schema",
      "result"
    ],
    "_validate_steps": [
      "self",
      "steps"
    ],
    "__len__": [
      "self"
    ]
  },
  "LabelMetadata": {},
  "TabPFNLabelEncoder": {
    "__init__": [
      "self",
      "original_target_name"
    ],
    "fit_transform": [
      "self",
      "y",
      "max_num_classes"
    ],
    "inverse_transform": [
      "self",
      "y"
    ]
  },
  "PreprocessorConfig": {
    "__str__": [
      "self"
    ]
  },
  "EnsembleConfig": {},
  "ClassifierEnsembleConfig": {},
  "RegressorEnsembleConfig": {},
  "_polynomial_feature_settings": [
    "polynomial_features"
  ],
  "create_preprocessing_pipeline": [
    "config"
  ],
  "_V2_FEATURE_SUBSAMPLING_THRESHOLD": [],
  "default_classifier_preprocessor_configs": [],
  "default_regressor_preprocessor_configs": [],
  "v2_classifier_preprocessor_configs": [],
  "v2_regressor_preprocessor_configs": [],
  "v2_5_classifier_preprocessor_configs": [],
  "v2_5_regressor_preprocessor_configs": [],
  "FeatureModality": {
    "NUMERICAL": [],
    "CATEGORICAL": [],
    "TEXT": [],
    "CONSTANT": []
  },
  "Feature": {},
  "FeatureSchema": {
    "from_only_categorical_indices": [
      "cls",
      "categorical_indices",
      "num_columns"
    ],
    "feature_names": [
      "self"
    ],
    "num_columns": [
      "self"
    ],
    "indices_for": [
      "self",
      "modality"
    ],
    "indices_for_modalities": [
      "self",
      "modalities"
    ],
    "append_columns": [
      "self",
      "modality",
      "num_new",
      "names"
    ],
    "slice_for_indices": [
      "self",
      "indices"
    ],
    "update_from_preprocessing_step_result": [
      "self",
      "original_indices",
      "new_schema"
    ],
    "remove_columns": [
      "self",
      "indices_to_remove"
    ],
    "apply_permutation": [
      "self",
      "permutation"
    ]
  },
  "_validate_permutation": [
    "permutation"
  ],
  "detect_feature_modalities": [
    "X",
    "feature_names"
  ],
  "_detect_feature_modality": [
    "s"
  ],
  "_is_numeric_pandas_series": [
    "s"
  ],
  "_detect_numeric_as_categorical": [
    "n_unique",
    "max_unique_for_category",
    "min_unique_for_numerical"
  ],
  "_get_unique_with_sklearn_compatible_error": [
    "s"
  ],
  "_fit_preprocessing_one": [
    "config",
    "X_train",
    "y_train",
    "random_state"
  ],
  "_transform_labels_one": [
    "config",
    "y_train"
  ],
  "fit_preprocessing": [
    "configs",
    "X_train",
    "y_train"
  ],
  "T": [],
  "TabPFNEnsembleMember": {
    "transform_X_test": [
      "self",
      "X"
    ]
  },
  "TabPFNEnsemblePreprocessor": {
    "__init__": [
      "self"
    ],
    "next_static_seed": [
      "self"
    ],
    "fit_transform_ensemble_members_iterator": [
      "self",
      "X_train",
      "y_train",
      "feature_schema",
      "parallel_mode",
      "override_random_state"
    ],
    "fit_transform_ensemble_members": [
      "self",
      "X_train",
      "y_train",
      "feature_schema"
    ]
  },
  "_balance": [
    "x",
    "n"
  ],
  "_generate_index_permutations": [
    "n"
  ],
  "_get_subsample_indices_for_estimators": [
    "subsample_samples",
    "num_estimators",
    "max_index",
    "static_seed"
  ],
  "_generate_class_permutations": [],
  "generate_classification_ensemble_configs": [],
  "generate_regression_ensemble_configs": [],
  "NUMERIC_DTYPE_KINDS": [],
  "OBJECT_DTYPE_KINDS": [],
  "STRING_DTYPE_KINDS": [],
  "UNSUPPORTED_DTYPE_KINDS": [],
  "clean_data": [
    "X",
    "feature_schema"
  ],
  "fix_dtypes": [
    "X",
    "cat_indices",
    "numeric_dtype"
  ],
  "process_text_na_dataframe": [
    "X",
    "placeholder",
    "ord_encoder"
  ],
  "DifferentiableZNormStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "_yeojohnson": [
    "x",
    "lmbda"
  ],
  "_yeojohnson_transform": [
    "x",
    "lmbda"
  ],
  "_yeojohnson_llf": [
    "lmb",
    "data"
  ],
  "_yeojohnson_normmax": [
    "x",
    "brack"
  ],
  "_yeojohnson_inverse_transform": [
    "x",
    "lmbda"
  ],
  "SafePowerTransformer": {
    "__init__": [
      "self",
      "method"
    ],
    "_yeo_johnson_optimize": [
      "self",
      "x"
    ],
    "_yeo_johnson_transform": [
      "self",
      "x",
      "lmbda"
    ],
    "_yeo_johnson_inverse_transform": [
      "self",
      "x",
      "lmbda"
    ]
  },
  "_get_least_common_category_count": [
    "x_column"
  ],
  "EncodeCategoricalFeaturesStep": {
    "__init__": [
      "self",
      "categorical_transform_name",
      "random_state"
    ],
    "_get_transformer": [
      "self",
      "X",
      "categorical_features"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_fit_transform_internal": [
      "self",
      "X",
      "feature_schema"
    ],
    "fit_transform": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "ShuffleFeaturesStep": {
    "__init__": [
      "self",
      "shuffle_method",
      "shuffle_index",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "make_scaler_safe": [
    "name",
    "scaler"
  ],
  "wrap_with_safe_standard_scaler": [
    "transformer"
  ],
  "_NoInverseImputer": {
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "_identity": [
    "x"
  ],
  "_replace_inf_with_nan": [
    "x"
  ],
  "_make_finite_steps": [
    "suffix"
  ],
  "_validate_data": [
    "estimator"
  ],
  "_mask_inf": [
    "X"
  ],
  "_set_zeros": [
    "X",
    "zero_cols"
  ],
  "_soft_clip": [
    "X",
    "max_absolute_value",
    "mask_inf"
  ],
  "_MinMaxScaler": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "SquashingScaler": {
    "__init__": [
      "self",
      "max_absolute_value",
      "quantile_range"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "RemoveConstantFeaturesStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "_exp_minus_1": [
    "x"
  ],
  "_make_box_cox_safe": [
    "input_transformer"
  ],
  "_skew": [
    "x"
  ],
  "ReshapeFeatureDistributionsStep": {
    "APPEND_TO_ORIGINAL_THRESHOLD": [],
    "get_column_types": [
      "X"
    ],
    "__init__": [
      "self"
    ],
    "_create_transformers_and_new_schema": [
      "self",
      "n_samples",
      "n_features",
      "feature_schema"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "get_adaptive_preprocessors": [
    "num_examples",
    "random_state"
  ],
  "get_all_reshape_feature_distribution_preprocessors": [
    "num_examples",
    "random_state"
  ],
  "_CONSTANT": [],
  "_MAX_COLLISION_RETRIES": [],
  "_HASH_ROUND_DECIMALS": [],
  "_float_hash_arr": [
    "arr",
    "offset"
  ],
  "AddFingerprintFeaturesStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "AdaptiveQuantileTransformer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "AddSVDFeaturesStep": {
    "__init__": [
      "self",
      "global_transformer_name",
      "random_state"
    ],
    "num_added_features": [
      "self",
      "n_samples",
      "n_features"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "get_svd_features_transformer": [
    "global_transformer_name",
    "n_samples",
    "n_features",
    "random_state"
  ],
  "NanHandlingPolynomialFeaturesStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "feature_schema"
    ],
    "_transform": [
      "self",
      "X"
    ]
  },
  "OrderPreservingColumnTransformer": {
    "__init__": [
      "self",
      "transformers"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_preserve_order": [
      "self",
      "X",
      "original_columns"
    ]
  },
  "get_ordinal_encoder": [],
  "_warned_about_missing_kditransform": [],
  "ALPHAS": [],
  "KDITransformerWithNaN": {
    "__init__": [
      "self",
      "alpha",
      "output_distribution"
    ],
    "_more_tags": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "get_all_kdi_transformers": [],
  "TorchPreprocessingStepResult": {},
  "TorchPreprocessingPipelineOutput": {},
  "create_gpu_preprocessing_pipeline": [
    "config"
  ],
  "TorchStandardScalerStep": {
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "x"
    ],
    "_transform": [
      "self",
      "x",
      "fitted_cache"
    ]
  },
  "TorchSoftClipOutliersStep": {
    "__init__": [
      "self",
      "n_sigma"
    ],
    "_fit": [
      "self",
      "x"
    ],
    "_transform": [
      "self",
      "x",
      "fitted_cache"
    ]
  },
  "TorchStandardScaler": {
    "fit": [
      "self",
      "x"
    ],
    "transform": [
      "self",
      "x",
      "fitted_cache"
    ],
    "__call__": [
      "self",
      "x",
      "num_train_rows"
    ]
  },
  "TorchSoftClipOutliers": {
    "__init__": [
      "self",
      "n_sigma"
    ],
    "fit": [
      "self",
      "x"
    ],
    "transform": [
      "self",
      "x",
      "fitted_cache"
    ],
    "__call__": [
      "self",
      "x",
      "num_train_rows"
    ]
  }
}