{
  "LOGGER": [],
  "CheckPoint": {},
  "sighandler": [
    "signal",
    "frame"
  ],
  "CPNest": {
    "__init__": [
      "self",
      "usermodel",
      "nlive",
      "poolsize",
      "output",
      "verbose",
      "seed",
      "maxmcmc",
      "nthreads",
      "nhamiltonian",
      "nslice",
      "resume",
      "proposals",
      "n_periodic_checkpoint",
      "periodic_checkpoint_interval",
      "prior_sampling"
    ],
    "run": [
      "self"
    ],
    "get_nested_samples": [
      "self",
      "filename"
    ],
    "get_posterior_samples": [
      "self",
      "filename"
    ],
    "get_prior_samples": [
      "self",
      "filename"
    ],
    "get_mcmc_samples": [
      "self",
      "filename"
    ],
    "plot": [
      "self",
      "corner"
    ],
    "worker_sampler": [
      "self",
      "producer_pipe",
      "logLmin"
    ],
    "worker_ns": [
      "self"
    ],
    "profile": [
      "self"
    ],
    "checkpoint": [
      "self"
    ]
  },
  "RunManager": {
    "__init__": [
      "self",
      "nthreads"
    ],
    "start": [
      "self"
    ],
    "connect_producer": [
      "self"
    ]
  },
  "FORMATTER": [],
  "LEVELS": [],
  "_Handler": {
    "__init__": [
      "self",
      "verbose"
    ],
    "get_verbosity": [
      "self"
    ],
    "set_verbosity": [
      "self",
      "verbose"
    ]
  },
  "StreamHandler": {
    "__init__": [
      "self",
      "verbose"
    ]
  },
  "FileHandler": {
    "__init__": [
      "self",
      "filename",
      "verbose"
    ]
  },
  "LogFile": {
    "__init__": [
      "self",
      "filename",
      "verbose",
      "loggername"
    ],
    "open": [
      "self"
    ],
    "close": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "logger": [],
  "console_handler": [],
  "__all__": [],
  "logsubexp": [
    "x",
    "y"
  ],
  "log_integrate_log_trap": [
    "log_func",
    "log_support"
  ],
  "compute_weights": [
    "data",
    "Nlive"
  ],
  "draw_posterior": [
    "data",
    "log_wts",
    "verbose"
  ],
  "draw_posterior_many": [
    "datas",
    "Nlives",
    "verbose"
  ],
  "draw_N_posterior": [
    "data",
    "log_wts",
    "N",
    "verbose"
  ],
  "draw_N_posterior_many": [
    "datas",
    "Nlives",
    "Npost",
    "verbose"
  ],
  "resample_mcmc_chain": [
    "chain",
    "verbose",
    "burnin"
  ],
  "autocorrelation": [
    "x"
  ],
  "acl": [
    "x",
    "tolerance"
  ],
  "Model": {
    "__metaclass__": [],
    "names": [],
    "bounds": [],
    "in_bounds": [
      "self",
      "param"
    ],
    "new_point": [
      "self"
    ],
    "log_likelihood": [
      "self",
      "param"
    ],
    "log_prior": [
      "self",
      "param"
    ],
    "potential": [
      "self",
      "param"
    ],
    "force": [
      "self",
      "param"
    ],
    "strsample": [
      "self",
      "sample"
    ],
    "header": [
      "self"
    ],
    "from_normalised": [
      "self",
      "normalised_value"
    ],
    "to_normalised": [
      "self",
      "point"
    ]
  },
  "init_plotting": [],
  "plot_chain": [
    "x",
    "name",
    "filename"
  ],
  "plot_hist": [
    "x",
    "name",
    "prior_samples",
    "mcmc_samples",
    "filename"
  ],
  "plot_indices": [
    "indices",
    "filename",
    "max_bins"
  ],
  "plot_corner": [
    "xs",
    "ps",
    "ms",
    "filename"
  ],
  "KeyOrderedList": {
    "__init__": [
      "self",
      "iterable",
      "key"
    ],
    "search": [
      "self",
      "item"
    ],
    "add": [
      "self",
      "item"
    ]
  },
  "OrderedLivePoints": {
    "__init__": [
      "self",
      "live_points"
    ],
    "insert_live_point": [
      "self",
      "live_point"
    ],
    "remove_n_worst_points": [
      "self",
      "n"
    ]
  },
  "_NSintegralState": {
    "__init__": [
      "self",
      "nlive"
    ],
    "reset": [
      "self"
    ],
    "increment": [
      "self",
      "logL",
      "nlive",
      "nreplace"
    ],
    "finalise": [
      "self"
    ],
    "plot": [
      "self",
      "filename"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "NestedSampler": {
    "__init__": [
      "self",
      "model",
      "logLmin",
      "logLmax",
      "input_pipes",
      "nlive",
      "output",
      "verbose",
      "seed",
      "prior_sampling",
      "stopping",
      "periodic_checkpoint_interval"
    ],
    "Nlive": [
      "self"
    ],
    "setup_output": [
      "self",
      "output"
    ],
    "write_chain_to_file": [
      "self"
    ],
    "write_evidence_to_file": [
      "self"
    ],
    "setup_random_seed": [
      "self",
      "seed"
    ],
    "consume_sample": [
      "self"
    ],
    "check_insertion_indices": [
      "self",
      "rolling",
      "filename"
    ],
    "reset": [
      "self"
    ],
    "nested_sampling_loop": [
      "self"
    ],
    "checkpoint": [
      "self"
    ],
    "resume": [
      "cls",
      "filename",
      "logLmin",
      "logLmax",
      "consumer_pipes",
      "usermodel"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "__checkpoint_flag": [],
  "Sampler": {
    "__init__": [
      "self",
      "model",
      "maxmcmc",
      "seed",
      "output",
      "verbose",
      "sample_prior",
      "poolsize",
      "proposal",
      "resume_file"
    ],
    "reset": [
      "self"
    ],
    "estimate_nmcmc_on_the_fly": [
      "self",
      "safety",
      "tau"
    ],
    "estimate_nmcmc": [
      "self",
      "safety"
    ],
    "produce_sample": [
      "self",
      "connection",
      "thread_id",
      "resume",
      "logLmin",
      "logLmax",
      "checkpoint_flag",
      "checkpoint_interval"
    ],
    "_produce_sample": [
      "self"
    ],
    "checkpoint": [
      "self"
    ],
    "resume": [
      "cls",
      "resume_file",
      "model"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "MetropolisHastingsSampler": {
    "yield_sample": [
      "self",
      "logLmin"
    ]
  },
  "HamiltonianMonteCarloSampler": {
    "yield_sample": [
      "self",
      "logLmin"
    ],
    "insert_sample": [
      "self",
      "p"
    ]
  },
  "SliceSampler": {
    "reset": [
      "self"
    ],
    "adapt_length_scale": [
      "self"
    ],
    "reset_boundaries": [
      "self"
    ],
    "increase_left_boundary": [
      "self"
    ],
    "increase_right_boundary": [
      "self"
    ],
    "yield_sample": [
      "self",
      "logLmin"
    ]
  },
  "Proposal": {
    "__metaclass__": [],
    "log_J": [],
    "get_sample": [
      "self",
      "old"
    ]
  },
  "EnsembleProposal": {
    "ensemble": [],
    "set_ensemble": [
      "self",
      "ensemble"
    ]
  },
  "ProposalCycle": {
    "idx": [],
    "N": [],
    "__init__": [
      "self",
      "proposals",
      "weights",
      "cyclelength"
    ],
    "set_cycle": [
      "self"
    ],
    "weights": [
      "self",
      "weights"
    ],
    "normalise_weights": [
      "self",
      "weights"
    ],
    "get_sample": [
      "self",
      "old"
    ],
    "set_ensemble": [
      "self",
      "ensemble"
    ],
    "add_proposal": [
      "self",
      "proposal",
      "weight"
    ]
  },
  "EnsembleSlice": {
    "log_J": []
  },
  "EnsembleSliceDifferential": {
    "get_direction": [
      "self",
      "mu"
    ]
  },
  "EnsembleSliceCorrelatedGaussian": {
    "mean": [],
    "covariance": [],
    "set_ensemble": [
      "self",
      "ensemble"
    ],
    "update_mean_covariance": [
      "self"
    ],
    "get_direction": [
      "self",
      "mu"
    ]
  },
  "EnsembleSliceGaussian": {
    "get_direction": [
      "self",
      "mu"
    ]
  },
  "EnsembleSliceProposalCycle": {
    "__init__": [
      "self",
      "model"
    ],
    "get_direction": [
      "self",
      "mu"
    ]
  },
  "EnsembleWalk": {
    "log_J": [],
    "Npoints": [],
    "get_sample": [
      "self",
      "old"
    ]
  },
  "EnsembleStretch": {
    "get_sample": [
      "self",
      "old"
    ]
  },
  "DifferentialEvolution": {
    "log_J": [],
    "get_sample": [
      "self",
      "old"
    ]
  },
  "EnsembleEigenVector": {
    "log_J": [],
    "eigen_values": [],
    "eigen_vectors": [],
    "covariance": [],
    "set_ensemble": [
      "self",
      "ensemble"
    ],
    "update_eigenvectors": [
      "self"
    ],
    "get_sample": [
      "self",
      "old"
    ]
  },
  "DefaultProposalCycle": {
    "__init__": [
      "self"
    ]
  },
  "HamiltonianProposalCycle": {
    "__init__": [
      "self",
      "model",
      "id"
    ]
  },
  "HamiltonianProposal": {
    "mass_matrix": [],
    "inverse_mass_matrix": [],
    "momenta_distribution": [],
    "__init__": [
      "self",
      "model",
      "id"
    ],
    "set_ensemble": [
      "self",
      "ensemble"
    ],
    "update_normal_vector": [
      "self"
    ],
    "unit_normal": [
      "self",
      "q"
    ],
    "gradient": [
      "self",
      "q"
    ],
    "update_momenta_distribution": [
      "self"
    ],
    "update_mass": [
      "self"
    ],
    "set_integration_parameters": [
      "self"
    ],
    "update_time_step": [
      "self",
      "acceptance"
    ],
    "update_trajectory_length": [
      "self",
      "nmcmc"
    ],
    "kinetic_energy": [
      "self",
      "p"
    ],
    "hamiltonian": [
      "self",
      "p",
      "q"
    ]
  },
  "LeapFrog": {
    "__init__": [
      "self",
      "model"
    ],
    "get_sample": [
      "self",
      "q0"
    ],
    "evolve_trajectory": [
      "self",
      "p0",
      "q0"
    ]
  },
  "ConstrainedLeapFrog": {
    "__init__": [
      "self",
      "model"
    ],
    "get_sample": [
      "self",
      "q0",
      "logLmin"
    ],
    "evolve_trajectory_one_step_position": [
      "self",
      "p",
      "q"
    ],
    "evolve_trajectory_one_step_momentum": [
      "self",
      "p",
      "q",
      "logLmin",
      "half"
    ],
    "check_constraint": [
      "self",
      "q",
      "logLmin"
    ],
    "evolve_trajectory": [
      "self",
      "p0",
      "q0",
      "logLmin"
    ],
    "sample_trajectory": [
      "self",
      "trajectory"
    ],
    "save_trajectory": [
      "self",
      "trajectory",
      "logLmin",
      "filename"
    ]
  }
}