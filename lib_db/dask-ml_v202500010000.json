{
  "copy_learned_attributes": [
    "from_estimator",
    "to_estimator"
  ],
  "draw_seed": [
    "random_state",
    "low",
    "high",
    "size",
    "dtype",
    "chunks"
  ],
  "ConstantFunction": {
    "__init__": [
      "self",
      "value",
      "sleep"
    ],
    "_fn": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self"
    ],
    "fit": [
      "self"
    ]
  },
  "LoggingContext": {
    "__init__": [
      "self",
      "logger",
      "level",
      "handler",
      "close"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "et",
      "ev",
      "tb"
    ]
  },
  "DaskMLBaseMixin": {
    "_validate_data": [
      "self",
      "X",
      "y",
      "reset",
      "validate_separately"
    ]
  },
  "ClassifierMixin": {
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "RegressorMixin": {
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "logger": [],
  "is_frame_base": [
    "inst"
  ],
  "_svd_flip_copy": [
    "x",
    "y",
    "u_based_decision"
  ],
  "svd_flip": [
    "u",
    "v",
    "u_based_decision"
  ],
  "flip_vector_signs": [
    "x",
    "axis"
  ],
  "slice_columns": [
    "X",
    "columns"
  ],
  "handle_zeros_in_scale": [
    "scale"
  ],
  "row_norms": [
    "X",
    "squared"
  ],
  "assert_estimator_equal": [
    "left",
    "right",
    "exclude"
  ],
  "check_array": [
    "array"
  ],
  "_assert_eq": [
    "lattr",
    "rattr",
    "name"
  ],
  "check_random_state": [
    "random_state"
  ],
  "check_matching_blocks": [],
  "check_X_y": [
    "X",
    "y",
    "accept_sparse"
  ],
  "_check_y": [
    "y",
    "multi_output",
    "y_numeric"
  ],
  "check_consistent_length": [],
  "check_chunks": [
    "n_samples",
    "n_features",
    "chunks"
  ],
  "_log_array": [
    "logger",
    "arr",
    "name"
  ],
  "_format_bytes": [
    "n"
  ],
  "_timer": [
    "name",
    "_logger",
    "level"
  ],
  "_timed": [
    "_logger",
    "level"
  ],
  "_num_samples": [
    "X"
  ],
  "_get_feature_names": [
    "X"
  ],
  "__all__": [],
  "ParallelPostFit": {
    "__init__": [
      "self",
      "estimator",
      "scoring",
      "predict_meta",
      "predict_proba_meta",
      "transform_meta"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "_postfit_estimator": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "compute"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "_check_method": [
      "self",
      "method"
    ]
  },
  "Incremental": {
    "__init__": [
      "self",
      "estimator",
      "scoring",
      "shuffle_blocks",
      "random_state",
      "assume_equal_chunks",
      "predict_meta",
      "predict_proba_meta",
      "transform_meta"
    ],
    "_postfit_estimator": [
      "self"
    ],
    "_fit_for_estimator": [
      "self",
      "estimator",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_first_block": [
    "dask_object"
  ],
  "_predict": [
    "part",
    "estimator"
  ],
  "_predict_proba": [
    "part",
    "estimator"
  ],
  "_transform": [
    "part",
    "estimator"
  ],
  "_get_output_dask_ar_meta_for_estimator": [
    "model_fn",
    "estimator",
    "input_dask_ar"
  ],
  "AnyArrayLike": [],
  "ArrayLike": [],
  "FrameOrSeriesUnion": [],
  "SeriesType": [],
  "DataFrameType": [],
  "Number": [],
  "Int": [],
  "NDArrayOrScalar": [],
  "GaussianNB": {
    "__init__": [
      "self",
      "priors",
      "classes"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ]
  },
  "logsumexp": [
    "arr",
    "axis"
  ],
  "SK_VERSION": [],
  "DASK_VERSION": [],
  "PANDAS_VERSION": [],
  "DISTRIBUTED_VERSION": [],
  "DASK_240": [],
  "DASK_2130": [],
  "DASK_2_20_0": [],
  "DASK_2_26_0": [],
  "DASK_2_28_0": [],
  "DASK_2021_02_0": [],
  "DASK_2022_01_0": [],
  "DISTRIBUTED_2_5_0": [],
  "DISTRIBUTED_2_11_0": [],
  "DISTRIBUTED_2021_02_0": [],
  "PANDAS_1_2_0": [],
  "WINDOWS": [],
  "SKLEARN_1_1_X": [],
  "dummy_context": [],
  "annotate": [],
  "blockwise": [],
  "_check_multimetric_scoring": [
    "estimator",
    "scoring"
  ],
  "_check_axis_partitioning": [
    "chunks",
    "n_features"
  ],
  "make_counts": [
    "n_samples",
    "n_features",
    "n_informative",
    "scale",
    "chunks",
    "random_state"
  ],
  "make_blobs": [
    "n_samples",
    "n_features",
    "centers",
    "cluster_std",
    "center_box",
    "shuffle",
    "random_state",
    "chunks"
  ],
  "make_regression": [
    "n_samples",
    "n_features",
    "n_informative",
    "n_targets",
    "bias",
    "effective_rank",
    "tail_strength",
    "noise",
    "shuffle",
    "coef",
    "random_state",
    "chunks"
  ],
  "make_classification": [
    "n_samples",
    "n_features",
    "n_informative",
    "n_redundant",
    "n_repeated",
    "n_classes",
    "n_clusters_per_class",
    "weights",
    "flip_y",
    "class_sep",
    "hypercube",
    "shift",
    "scale",
    "shuffle",
    "random_state",
    "chunks"
  ],
  "random_date": [
    "start",
    "end"
  ],
  "make_classification_df": [
    "n_samples",
    "response_rate",
    "predictability",
    "random_state",
    "chunks",
    "dates"
  ],
  "_partial_fit": [
    "model",
    "x",
    "y",
    "kwargs"
  ],
  "fit": [
    "model",
    "x",
    "y",
    "compute",
    "shuffle_blocks",
    "random_state",
    "assume_equal_chunks"
  ],
  "_blocks_and_name": [
    "obj"
  ],
  "predict": [
    "model",
    "x"
  ],
  "_copy_partial_doc": [
    "cls"
  ],
  "SimpleImputer": {
    "_types": [],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit_array": [
      "self",
      "X"
    ],
    "_fit_frame": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "TYPE_CHECKING": [],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "exp": [
    "A"
  ],
  "absolute": [
    "A"
  ],
  "sign": [
    "A"
  ],
  "log1p": [
    "A"
  ],
  "add_intercept": [
    "X"
  ],
  "_add_intercept": [
    "x"
  ],
  "lr_prob_stack": [
    "prob"
  ],
  "_base_doc": [],
  "_GLM": {
    "family": [
      "self"
    ],
    "__init__": [
      "self",
      "penalty",
      "dual",
      "tol",
      "C",
      "fit_intercept",
      "intercept_scaling",
      "class_weight",
      "random_state",
      "solver",
      "max_iter",
      "multi_class",
      "verbose",
      "warm_start",
      "n_jobs",
      "solver_kwargs"
    ],
    "_get_solver_kwargs": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_check_array": [
      "self",
      "X"
    ]
  },
  "LogisticRegression": {
    "__doc__": [],
    "family": [
      "self"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "LinearRegression": {
    "__doc__": [],
    "family": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "PoissonRegression": {
    "__doc__": [],
    "family": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_deviance": [
      "self",
      "X",
      "y"
    ]
  },
  "neg_mean_squared_error_scorer": [],
  "neg_log_loss_scorer": [],
  "SCORERS": [],
  "get_scorer": [
    "scoring",
    "compute"
  ],
  "check_scoring": [
    "estimator",
    "scoring"
  ],
  "accuracy_score": [
    "y_true",
    "y_pred",
    "normalize",
    "sample_weight",
    "compute"
  ],
  "_log_loss_inner": [
    "x",
    "y",
    "sample_weight"
  ],
  "log_loss": [
    "y_true",
    "y_pred",
    "eps",
    "normalize",
    "sample_weight",
    "labels"
  ],
  "pairwise_distances_argmin_min": [
    "X",
    "Y",
    "axis",
    "metric",
    "batch_size",
    "metric_kwargs"
  ],
  "pairwise_distances": [
    "X",
    "Y",
    "metric",
    "n_jobs"
  ],
  "euclidean_distances": [
    "X",
    "Y",
    "Y_norm_squared",
    "squared",
    "X_norm_squared"
  ],
  "check_pairwise_arrays": [
    "X",
    "Y",
    "precomputed"
  ],
  "linear_kernel": [
    "X",
    "Y"
  ],
  "rbf_kernel": [
    "X",
    "Y",
    "gamma"
  ],
  "polynomial_kernel": [
    "X",
    "Y",
    "degree",
    "gamma",
    "coef0"
  ],
  "sigmoid_kernel": [
    "X",
    "Y",
    "gamma",
    "coef0"
  ],
  "PAIRWISE_KERNEL_FUNCTIONS": [],
  "pairwise_kernels": [
    "X",
    "Y",
    "metric",
    "filter_params",
    "n_jobs"
  ],
  "_check_sample_weight": [
    "sample_weight"
  ],
  "_check_reg_targets": [
    "y_true",
    "y_pred",
    "multioutput"
  ],
  "mean_squared_error": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "squared",
    "compute"
  ],
  "mean_absolute_error": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "compute"
  ],
  "mean_absolute_percentage_error": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "compute"
  ],
  "r2_score": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "compute"
  ],
  "mean_squared_log_error": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "compute"
  ],
  "ColumnTransformer": {
    "__init__": [
      "self",
      "transformers",
      "remainder",
      "sparse_threshold",
      "n_jobs",
      "transformer_weights",
      "preserve_dataframe"
    ],
    "_hstack": [
      "self",
      "Xs"
    ]
  },
  "make_column_transformer": [],
  "_TYPE_MSG": [],
  "PCA": {
    "__init__": [
      "self",
      "n_components",
      "copy",
      "whiten",
      "svd_solver",
      "tol",
      "iterated_power",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_get_solver": [
      "self",
      "X",
      "n_components"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "_known_shape": [
    "shape"
  ],
  "_incremental_mean_and_var": [
    "X",
    "last_mean",
    "last_variance",
    "last_sample_count"
  ],
  "svd_flip_fast": [
    "u",
    "v"
  ],
  "IncrementalPCA": {
    "__init__": [
      "self",
      "n_components",
      "whiten",
      "copy",
      "batch_size",
      "svd_solver",
      "iterated_power",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "check_input"
    ]
  },
  "TruncatedSVD": {
    "__init__": [
      "self",
      "n_components",
      "algorithm",
      "n_iter",
      "random_state",
      "tol",
      "compute"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "BlockwiseBase": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "BlockwiseVotingClassifier": {
    "__init__": [
      "self",
      "estimator",
      "voting",
      "classes"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_collect_probas": [
      "self",
      "X"
    ]
  },
  "BlockwiseVotingRegressor": {
    "predict": [
      "self",
      "X"
    ]
  },
  "_vote": [
    "x"
  ],
  "_vote_block": [
    "block"
  ],
  "_predict_stack": [
    "part",
    "estimators"
  ],
  "_predict_proba_stack": [
    "part",
    "estimators"
  ],
  "MISSING": [],
  "FIT_FAILURE": [],
  "warn_fit_failure": [
    "error_score",
    "e"
  ],
  "CVCache": {
    "__init__": [
      "self",
      "splits",
      "pairwise",
      "cache",
      "num_train_samples"
    ],
    "__reduce__": [
      "self"
    ],
    "num_test_samples": [
      "self"
    ],
    "extract": [
      "self",
      "X",
      "y",
      "n",
      "is_x",
      "is_train"
    ],
    "extract_param": [
      "self",
      "key",
      "x",
      "n"
    ],
    "_extract": [
      "self",
      "X",
      "y",
      "n",
      "is_x",
      "is_train"
    ],
    "_extract_pairwise": [
      "self",
      "X",
      "y",
      "n",
      "is_train"
    ]
  },
  "cv_split": [
    "cv",
    "X",
    "y",
    "groups",
    "is_pairwise",
    "cache"
  ],
  "cv_n_samples": [
    "cvs"
  ],
  "cv_extract": [
    "cvs",
    "X",
    "y",
    "is_X",
    "is_train",
    "n"
  ],
  "cv_extract_params": [
    "cvs",
    "keys",
    "vals",
    "n"
  ],
  "_maybe_timed": [
    "x"
  ],
  "pipeline": [
    "names",
    "steps"
  ],
  "feature_union": [
    "names",
    "steps",
    "weights"
  ],
  "feature_union_concat": [
    "Xs",
    "nsamples",
    "weights"
  ],
  "SET_PARAMS_LOCK": [],
  "set_params": [
    "est",
    "fields",
    "params",
    "copy"
  ],
  "fit_transform": [
    "est",
    "X",
    "y",
    "error_score",
    "fields",
    "params",
    "fit_params"
  ],
  "_score": [
    "est",
    "X",
    "y",
    "scorer"
  ],
  "score": [
    "est_and_time",
    "X_test",
    "y_test",
    "X_train",
    "y_train",
    "scorer",
    "error_score"
  ],
  "fit_and_score": [
    "est",
    "cv",
    "X",
    "y",
    "n",
    "scorer",
    "error_score",
    "fields",
    "params",
    "fit_params",
    "return_train_score"
  ],
  "_store": [
    "results",
    "key_name",
    "array",
    "n_splits",
    "n_candidates",
    "weights",
    "splits",
    "rank"
  ],
  "create_cv_results": [
    "scores",
    "candidate_params",
    "n_splits",
    "error_score",
    "weights",
    "multimetric"
  ],
  "fit_best": [
    "estimator",
    "params",
    "X",
    "y",
    "fit_params"
  ],
  "normalize_estimator": [
    "est"
  ],
  "normalize_random_state": [
    "random_state"
  ],
  "normalize_KFold": [
    "x"
  ],
  "normalize_ShuffleSplit": [
    "x"
  ],
  "normalize_LeaveOneOut": [
    "x"
  ],
  "normalize_LeavePOut": [
    "x"
  ],
  "normalize_PredefinedSplit": [
    "x"
  ],
  "normalize_CVIterableWrapper": [
    "x"
  ],
  "no_default": [],
  "Results": [],
  "Params": [],
  "Meta": [],
  "Model": [],
  "History": [],
  "Info": [],
  "Instructions": [],
  "_create_model": [
    "model",
    "ident"
  ],
  "_fit": [
    "model",
    "params",
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "additional_calls",
    "fit_params",
    "scorer",
    "random_state",
    "verbose",
    "prefix"
  ],
  "BaseIncrementalSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "parameters",
      "test_size",
      "random_state",
      "scoring",
      "max_iter",
      "patience",
      "tol",
      "verbose",
      "prefix",
      "predict_meta",
      "predict_proba_meta",
      "transform_meta"
    ],
    "_validate_parameters": [
      "self",
      "X",
      "y"
    ],
    "_postfit_estimator": [
      "self"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "_get_train_test_split": [
      "self",
      "X",
      "y"
    ],
    "_additional_calls": [
      "self",
      "info"
    ],
    "_get_params": [
      "self"
    ],
    "_get_cv_results": [
      "self",
      "model_hist"
    ],
    "_process_results": [
      "self",
      "results"
    ],
    "_check_is_fitted": [
      "self",
      "method_name"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "IncrementalSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "parameters",
      "n_initial_parameters",
      "decay_rate",
      "test_size",
      "patience",
      "tol",
      "fits_per_score",
      "max_iter",
      "random_state",
      "scoring",
      "verbose",
      "prefix",
      "scores_per_fit",
      "predict_meta",
      "predict_proba_meta",
      "transform_meta"
    ],
    "_decay_deprecated": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_get_params": [
      "self"
    ],
    "_additional_calls": [
      "self",
      "info"
    ],
    "_adapt": [
      "self",
      "info"
    ],
    "_stop_on_plateau": [
      "self",
      "instructions",
      "info"
    ]
  },
  "InverseDecaySearchCV": {
    "__init__": [
      "self",
      "estimator",
      "parameters",
      "n_initial_parameters",
      "test_size",
      "patience",
      "tol",
      "fits_per_score",
      "max_iter",
      "random_state",
      "scoring",
      "verbose",
      "prefix",
      "decay_rate"
    ],
    "_decay_deprecated": [
      "self"
    ],
    "_adapt": [
      "self",
      "info"
    ]
  },
  "_I4MAX": [],
  "_check_blockwise": [
    "blockwise"
  ],
  "_maybe_normalize_split_sizes": [
    "train_size",
    "test_size"
  ],
  "_generate_idx": [
    "n",
    "seed",
    "n_train",
    "n_test"
  ],
  "ShuffleSplit": {
    "__init__": [
      "self",
      "n_splits",
      "test_size",
      "train_size",
      "blockwise",
      "random_state"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_split_blockwise": [
      "self",
      "X",
      "seeds"
    ],
    "_split": [
      "self",
      "X"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_generate_offset_idx": [
    "n",
    "start",
    "stop",
    "offset",
    "seed"
  ],
  "KFold": {
    "__init__": [
      "self",
      "n_splits",
      "shuffle",
      "random_state"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_split": [
      "self",
      "test_start",
      "test_stop",
      "n_samples",
      "chunks",
      "seeds"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_blockwise_slice": [
    "arr",
    "idx"
  ],
  "train_test_split": [],
  "SuccessiveHalvingSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "parameters",
      "n_initial_parameters",
      "n_initial_iter",
      "max_iter",
      "aggressiveness",
      "test_size",
      "patience",
      "tol",
      "random_state",
      "scoring",
      "verbose",
      "prefix"
    ],
    "_adapt": [
      "self",
      "info",
      "first_step_completed"
    ],
    "metadata": [
      "self"
    ],
    "metadata_": [
      "self"
    ]
  },
  "_simulate_sha": [
    "n",
    "r",
    "eta",
    "max_iter"
  ],
  "_indexable": [
    "x"
  ],
  "_maybe_indexable": [
    "x"
  ],
  "to_indexable": [],
  "_index_param_value": [
    "num_samples",
    "v",
    "indices"
  ],
  "to_keys": [
    "dsk"
  ],
  "copy_estimator": [
    "est"
  ],
  "estimator_has": [
    "attr"
  ],
  "unzip": [
    "itbl",
    "n"
  ],
  "DeprecationDict": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "get": [
      "self",
      "key",
      "default"
    ],
    "add_warning": [
      "self",
      "key"
    ]
  },
  "_safe_indexing": [
    "X",
    "indices",
    "axis"
  ],
  "_determine_key_type": [
    "key"
  ],
  "_pandas_indexing": [
    "X",
    "key",
    "key_dtype",
    "axis"
  ],
  "_array_indexing": [
    "array",
    "key",
    "key_dtype",
    "axis"
  ],
  "_list_indexing": [
    "X",
    "key",
    "key_dtype"
  ],
  "none_or_passthrough": [
    "x"
  ],
  "none_or_drop": [
    "x"
  ],
  "MockClassifier": {
    "__init__": [
      "self",
      "foo_param"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "T"
    ],
    "predict_proba": [],
    "predict_log_proba": [],
    "decision_function": [],
    "inverse_transform": [],
    "transform": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "MockClassifierWithFitParam": {
    "fit": [
      "self",
      "X",
      "y",
      "mock_fit_param"
    ]
  },
  "ScalingTransformer": {
    "__init__": [
      "self",
      "factor"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "CheckXClassifier": {
    "__init__": [
      "self",
      "expected_X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "FailingClassifier": {
    "FAILING_PARAMETER": [],
    "FAILING_SCORE_PARAMETER": [],
    "FAILING_PREDICT_PARAMETER": [],
    "__init__": [
      "self",
      "parameter"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "ArraySlicingWrapper": {
    "__init__": [
      "self",
      "array"
    ],
    "__getitem__": [
      "self",
      "aslice"
    ]
  },
  "MockDataFrame": {
    "__init__": [
      "self",
      "array"
    ],
    "__len__": [
      "self"
    ],
    "__array__": [
      "self",
      "dtype"
    ]
  },
  "CheckingClassifier": {
    "__init__": [
      "self",
      "check_y",
      "check_X",
      "foo_param",
      "expected_fit_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "T"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ]
  },
  "AsCompletedEstimator": {
    "__init__": [
      "self",
      "killed_workers_name",
      "lock_name",
      "counter_name",
      "min_complete",
      "foo_param"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "LinearFunction": {
    "__init__": [
      "self",
      "intercept",
      "slope",
      "foo"
    ],
    "fit": [
      "self"
    ],
    "partial_fit": [
      "self"
    ],
    "score": [
      "self"
    ]
  },
  "_MaybeLinearFunction": {
    "__init__": [
      "self",
      "final_score"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "BracketInfo": [],
  "_get_hyperband_params": [
    "R",
    "eta"
  ],
  "HyperbandSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "parameters",
      "max_iter",
      "aggressiveness",
      "patience",
      "tol",
      "test_size",
      "random_state",
      "scoring",
      "verbose",
      "prefix",
      "predict_meta",
      "predict_proba_meta",
      "transform_meta"
    ],
    "_get_SHAs": [
      "self",
      "brackets"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "metadata": [
      "self"
    ]
  },
  "_get_meta": [
    "hists",
    "brackets",
    "SHAs",
    "key"
  ],
  "_get_SHA_params": [
    "SHA"
  ],
  "_hyperband_paper_alg": [
    "R",
    "eta"
  ],
  "_get_patience": [
    "patience",
    "max_iter",
    "aggressiveness",
    "tol"
  ],
  "TokenIterator": {
    "__init__": [
      "self",
      "base_token"
    ],
    "__call__": [
      "self",
      "est"
    ]
  },
  "map_fit_params": [
    "dsk",
    "fit_params"
  ],
  "build_graph": [
    "estimator",
    "cv",
    "scorer",
    "candidate_params",
    "X",
    "y",
    "groups",
    "fit_params",
    "iid",
    "refit",
    "error_score",
    "return_train_score",
    "cache_cv",
    "multimetric"
  ],
  "build_cv_graph": [
    "estimator",
    "cv",
    "scorer",
    "candidate_params",
    "X",
    "y",
    "groups",
    "fit_params",
    "iid",
    "error_score",
    "return_train_score",
    "cache_cv"
  ],
  "build_refit_graph": [
    "estimator",
    "X",
    "y",
    "best_params",
    "fit_params"
  ],
  "normalize_params": [
    "params"
  ],
  "_get_fit_params": [
    "cv",
    "fit_params",
    "n_splits"
  ],
  "_group_fit_params": [
    "steps",
    "fit_params"
  ],
  "do_fit_and_score": [
    "dsk",
    "main_token",
    "est",
    "cv",
    "fields",
    "tokens",
    "params",
    "X",
    "y",
    "fit_params",
    "n_splits",
    "error_score",
    "scorer",
    "return_train_score"
  ],
  "do_fit": [
    "dsk",
    "next_token",
    "est",
    "cv",
    "fields",
    "tokens",
    "params",
    "Xs",
    "ys",
    "fit_params",
    "n_splits",
    "error_score"
  ],
  "do_fit_transform": [
    "dsk",
    "next_token",
    "est",
    "cv",
    "fields",
    "tokens",
    "params",
    "Xs",
    "ys",
    "fit_params",
    "n_splits",
    "error_score"
  ],
  "_group_subparams": [
    "steps",
    "fields",
    "ignore"
  ],
  "_group_ids_by_index": [
    "index",
    "tokens"
  ],
  "_do_fit_step": [
    "dsk",
    "next_token",
    "step",
    "cv",
    "fields",
    "tokens",
    "params",
    "Xs",
    "ys",
    "fit_params",
    "n_splits",
    "error_score",
    "step_fields_lk",
    "fit_params_lk",
    "field_to_index",
    "step_name",
    "none_passthrough",
    "is_transform"
  ],
  "_do_pipeline": [
    "dsk",
    "next_token",
    "est",
    "cv",
    "fields",
    "tokens",
    "params",
    "Xs",
    "ys",
    "fit_params",
    "n_splits",
    "error_score",
    "is_transform"
  ],
  "_do_n_samples": [
    "dsk",
    "token",
    "Xs",
    "n_splits"
  ],
  "_do_featureunion": [
    "dsk",
    "next_token",
    "est",
    "cv",
    "fields",
    "tokens",
    "params",
    "Xs",
    "ys",
    "fit_params",
    "n_splits",
    "error_score"
  ],
  "check_cv": [
    "cv",
    "y",
    "classifier"
  ],
  "compute_n_splits": [
    "cv",
    "X",
    "y",
    "groups"
  ],
  "_normalize_n_jobs": [
    "n_jobs"
  ],
  "StaticDaskSearchMixin": {
    "visualize": [
      "self",
      "filename",
      "format"
    ]
  },
  "DaskBaseSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "scoring",
      "iid",
      "refit",
      "cv",
      "error_score",
      "return_train_score",
      "scheduler",
      "n_jobs",
      "cache_cv"
    ],
    "_check_if_refit": [
      "self",
      "attr"
    ],
    "_estimator_type": [
      "self"
    ],
    "best_params_": [
      "self"
    ],
    "best_score_": [
      "self"
    ],
    "_check_is_fitted": [
      "self",
      "method_name"
    ],
    "classes_": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Xt"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_DOC_TEMPLATE": [],
  "_grid_oneliner": [],
  "_grid_description": [],
  "_grid_parameters": [],
  "_grid_example": [],
  "GridSearchCV": {
    "__doc__": [],
    "__init__": [
      "self",
      "estimator",
      "param_grid",
      "scoring",
      "iid",
      "refit",
      "cv",
      "error_score",
      "return_train_score",
      "scheduler",
      "n_jobs",
      "cache_cv"
    ],
    "_get_param_iterator": [
      "self"
    ]
  },
  "_randomized_oneliner": [],
  "_randomized_description": [],
  "_randomized_parameters": [],
  "_randomized_example": [],
  "RandomizedSearchCV": {
    "__doc__": [],
    "__init__": [
      "self",
      "estimator",
      "param_distributions",
      "n_iter",
      "random_state",
      "scoring",
      "iid",
      "refit",
      "cv",
      "error_score",
      "return_train_score",
      "scheduler",
      "n_jobs",
      "cache_cv"
    ],
    "_get_param_iterator": [
      "self"
    ]
  },
  "KMeans": {
    "__init__": [
      "self",
      "n_clusters",
      "init",
      "oversampling_factor",
      "max_iter",
      "tol",
      "precompute_distances",
      "random_state",
      "copy_x",
      "n_jobs",
      "algorithm",
      "init_max_iter",
      "n_init"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "k_means": [
    "X",
    "n_clusters",
    "init",
    "precompute_distances",
    "n_init",
    "max_iter",
    "verbose",
    "tol",
    "random_state",
    "copy_x",
    "n_jobs",
    "algorithm",
    "return_n_iter",
    "oversampling_factor",
    "init_max_iter"
  ],
  "compute_inertia": [
    "X",
    "labels",
    "centers"
  ],
  "k_init": [
    "X",
    "n_clusters",
    "init",
    "random_state",
    "max_iter",
    "oversampling_factor",
    "n_init"
  ],
  "init_pp": [
    "X",
    "n_clusters",
    "random_state"
  ],
  "init_random": [
    "X",
    "n_clusters",
    "random_state"
  ],
  "init_scalable": [
    "X",
    "n_clusters",
    "random_state",
    "max_iter",
    "oversampling_factor",
    "n_init"
  ],
  "evaluate_cost": [
    "X",
    "centers"
  ],
  "_sample_points": [
    "X",
    "centers",
    "oversampling_factor",
    "random_state"
  ],
  "_kmeans_single_lloyd": [
    "X",
    "n_clusters",
    "max_iter",
    "init",
    "verbose",
    "x_squared_norms",
    "random_state",
    "tol",
    "precompute_distances",
    "oversampling_factor",
    "init_max_iter",
    "n_init"
  ],
  "_centers_dense": [
    "X",
    "labels",
    "n_clusters"
  ],
  "SpectralClustering": {
    "__init__": [
      "self",
      "n_clusters",
      "eigen_solver",
      "random_state",
      "n_init",
      "gamma",
      "affinity",
      "n_neighbors",
      "eigen_tol",
      "assign_labels",
      "degree",
      "coef0",
      "kernel_params",
      "n_jobs",
      "n_components",
      "persist_embedding",
      "kmeans_params"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "embed": [
    "X_keep",
    "X_rest",
    "n_components",
    "metric",
    "kernel_params"
  ],
  "_slice_mostly_sorted": [
    "array",
    "keep",
    "rest",
    "ind"
  ],
  "LabelEncoder": {
    "__init__": [
      "self",
      "use_categorical"
    ],
    "_check_array": [
      "self",
      "y"
    ],
    "fit": [
      "self",
      "y"
    ],
    "fit_transform": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ]
  },
  "_encode_categorical": [
    "values",
    "uniques",
    "encode"
  ],
  "_check_and_search_block": [
    "arr",
    "uniques",
    "onehot_dtype",
    "block_info"
  ],
  "_construct": [
    "x",
    "categories"
  ],
  "_encode_dask_array": [
    "values",
    "uniques",
    "encode",
    "onehot_dtype"
  ],
  "_encode": [
    "values",
    "uniques",
    "encode"
  ],
  "_is_categorical": [
    "y"
  ],
  "OneHotEncoder": {
    "_legacy_mode": [],
    "__init__": [
      "self",
      "n_values",
      "categorical_features",
      "categories",
      "drop",
      "sparse_output",
      "dtype",
      "handle_unknown"
    ],
    "_get_param_names": [
      "cls"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "handle_unknown",
      "ensure_all_finite",
      "return_counts"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform_new": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X",
      "handle_unknown"
    ]
  },
  "_PANDAS_VERSION": [],
  "_HAS_CTD": [],
  "BOUNDS_THRESHOLD": [],
  "_handle_zeros_in_scale": [
    "scale",
    "copy"
  ],
  "StandardScaler": {
    "__doc__": [],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y",
      "copy"
    ],
    "inverse_transform": [
      "self",
      "X",
      "copy"
    ]
  },
  "MinMaxScaler": {
    "__doc__": [],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y",
      "copy"
    ],
    "inverse_transform": [
      "self",
      "X",
      "y",
      "copy"
    ]
  },
  "RobustScaler": {
    "__doc__": [],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "QuantileTransformer": {
    "__doc__": [],
    "_check_inputs": [
      "self",
      "X",
      "accept_sparse_negative",
      "copy",
      "in_fit"
    ],
    "_sparse_fit": [
      "self",
      "X",
      "random_state"
    ],
    "_dense_fit": [
      "self",
      "X",
      "random_state"
    ],
    "_transform": [
      "self",
      "X",
      "inverse"
    ],
    "_transform_col": [
      "self",
      "X_col",
      "quantiles",
      "inverse"
    ]
  },
  "Categorizer": {
    "__init__": [
      "self",
      "categories",
      "columns"
    ],
    "_check_array": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "_fit_dask": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "DummyEncoder": {
    "__init__": [
      "self",
      "columns",
      "drop_first"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "OrdinalEncoder": {
    "__init__": [
      "self",
      "columns"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "PolynomialFeatures": {
    "splitted_orig_doc": [],
    "__doc__": [],
    "__init__": [
      "self",
      "degree",
      "interaction_only",
      "include_bias",
      "preserve_dataframe"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "BlockTransformer": {
    "__init__": [
      "self",
      "func"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_BaseHasher": {
    "_hasher": [
      "self"
    ],
    "_transformer": [
      "self",
      "part"
    ],
    "transform": [
      "self",
      "raw_X"
    ]
  },
  "HashingVectorizer": {
    "__doc__": [],
    "_hasher": [
      "self"
    ],
    "transform": [
      "self",
      "raw_X"
    ]
  },
  "FeatureHasher": {
    "__doc__": [],
    "_hasher": [
      "self"
    ]
  },
  "CountVectorizer": {
    "fit_transform": [
      "self",
      "raw_documents",
      "y"
    ],
    "transform": [
      "self",
      "raw_documents"
    ]
  },
  "build_array": [
    "bag",
    "n_features",
    "meta"
  ],
  "vocabulary_length": [
    "vocabulary"
  ],
  "_count_vectorizer_transform": [
    "partition",
    "vocabulary",
    "params"
  ],
  "_build_vocabulary": [
    "partition",
    "params"
  ],
  "_merge_vocabulary": []
}