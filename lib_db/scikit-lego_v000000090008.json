{
  "TrainOnlyTransformerMixin": {
    "_HASHERS": [],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_hash": [
      "X"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "transform_train": [
      "self",
      "X",
      "y"
    ],
    "transform_test": [
      "self",
      "X",
      "y"
    ],
    "dim_": [
      "self"
    ]
  },
  "as_list": [
    "val"
  ],
  "flatten": [
    "nested_iterable"
  ],
  "expanding_list": [
    "list_to_extent",
    "return_type"
  ],
  "sliding_window": [
    "sequence",
    "window_size",
    "step_size"
  ],
  "poem": [],
  "ProbabilisticClassifierMeta": {
    "__instancecheck__": [
      "self",
      "other"
    ]
  },
  "ProbabilisticClassifier": {},
  "ClustererMeta": {
    "__instancecheck__": [
      "self",
      "other"
    ]
  },
  "Clusterer": {},
  "OutlierModelMeta": {
    "__instancecheck__": [
      "self",
      "other"
    ]
  },
  "OutlierModel": {},
  "RandomRegressor": {
    "_ALLOWED_STRATEGIES": [],
    "__init__": [
      "self",
      "strategy",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "dim_": [
      "self"
    ],
    "allowed_strategies": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KNOWN_PACKAGES": [],
  "NotInstalledPackage": {
    "__init__": [
      "self",
      "package_name",
      "version"
    ],
    "__getattr__": [
      "self",
      "name"
    ]
  },
  "correlation_score": [
    "column"
  ],
  "p_percent_score": [
    "sensitive_column",
    "positive_target"
  ],
  "equal_opportunity_score": [
    "sensitive_column",
    "positive_target"
  ],
  "subset_score": [
    "subset_picker",
    "score"
  ],
  "BayesianKernelDensityClassifier": {
    "__init__": [
      "self",
      "bandwidth",
      "kernel",
      "algorithm",
      "metric",
      "atol",
      "rtol",
      "breath_first",
      "leaf_size",
      "metric_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "__title__": [],
  "__version__": [],
  "check_shape_remains_same_regressor": [
    "name",
    "regressor"
  ],
  "check_shape_remains_same_classifier": [
    "name",
    "classifier"
  ],
  "default_log_callback": [
    "output",
    "execution_time"
  ],
  "_log_wrapper": [
    "log_callback"
  ],
  "_cache_with_function_log_statement": [
    "log_callback"
  ],
  "DebugPipeline": {
    "__init__": [
      "self",
      "steps",
      "memory",
      "verbose"
    ],
    "memory": [
      "self",
      "memory"
    ],
    "log_callback": [
      "self",
      "func"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "make_debug_pipeline": [],
  "GaussianMixtureNB": {
    "__init__": [
      "self",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weights_init",
      "means_init",
      "precisions_init",
      "random_state",
      "warm_start"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "num_fit_cols_": [
      "self"
    ]
  },
  "BayesianGaussianMixtureNB": {
    "__init__": [
      "self",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weight_concentration_prior_type",
      "weight_concentration_prior",
      "mean_precision_prior",
      "mean_prior",
      "degrees_of_freedom_prior",
      "covariance_prior",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "num_fit_cols_": [
      "self"
    ]
  },
  "TimeGapSplit": {
    "__init__": [
      "self",
      "date_serie",
      "valid_duration",
      "stride_duration",
      "train_duration",
      "gap_duration",
      "n_splits",
      "window"
    ],
    "_join_date_and_x": [
      "self",
      "X"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "summary": [
      "self",
      "X"
    ]
  },
  "KlusterFoldValidation": [],
  "ClusterFoldValidation": {
    "__init__": [
      "self",
      "cluster_method"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_method_is_fitted": [
      "self",
      "X"
    ]
  },
  "GroupTimeSeriesSplit": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "summary": [
      "self"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_check_for_long_estimated_runtime": [
      "self",
      "groups"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_calc_first_and_last_split_index": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_get_split_indices": [
      "self"
    ],
    "_calc_new_diffs": [
      "values",
      "diff_list",
      "prev_splits",
      "new_splits"
    ],
    "_regroup": [
      "self",
      "groups"
    ]
  },
  "load_penguins": [
    "return_X_y",
    "as_frame"
  ],
  "load_arrests": [
    "return_X_y",
    "as_frame"
  ],
  "load_chicken": [
    "return_X_y",
    "as_frame"
  ],
  "load_abalone": [
    "return_X_y",
    "as_frame"
  ],
  "load_heroes": [
    "return_X_y",
    "as_frame"
  ],
  "load_hearts": [
    "return_X_y",
    "as_frame"
  ],
  "make_simpleseries": [
    "n_samples",
    "trend",
    "season_trend",
    "noise",
    "as_frame",
    "seed",
    "stack_noise",
    "start_date"
  ],
  "fetch_creditcard": [],
  "LowessRegression": {
    "__init__": [
      "self",
      "sigma",
      "span"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_calc_wts": [
      "self",
      "x_i"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "ProbWeightRegression": {
    "__init__": [
      "self",
      "non_negative"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "coefs_": [
      "self"
    ]
  },
  "DeadZoneRegressor": {
    "_ALLOWED_EFFECTS": [],
    "__init__": [
      "self",
      "threshold",
      "relative",
      "effect"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "coefs_": [
      "self"
    ],
    "allowed_effects": [
      "self"
    ]
  },
  "_FairClassifier": {
    "_ALLOWED_PENALTIES": [],
    "__init__": [
      "self",
      "sensitive_cols",
      "C",
      "penalty",
      "fit_intercept",
      "max_iter",
      "train_sensitive_cols"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "constraints": [
      "self",
      "y_hat",
      "y_true",
      "sensitive",
      "n_obs"
    ],
    "_solve": [
      "self",
      "sensitive",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "_more_tags": [
      "self"
    ]
  },
  "DemographicParityClassifier": {
    "__new__": [
      "cls"
    ]
  },
  "_DemographicParityClassifier": {
    "__init__": [
      "self",
      "covariance_threshold",
      "sensitive_cols",
      "C",
      "penalty",
      "fit_intercept",
      "max_iter",
      "train_sensitive_cols"
    ],
    "constraints": [
      "self",
      "y_hat",
      "y_true",
      "sensitive",
      "n_obs"
    ]
  },
  "EqualOpportunityClassifier": {
    "__new__": [
      "cls"
    ]
  },
  "_EqualOpportunityClassifier": {
    "__init__": [
      "self",
      "covariance_threshold",
      "positive_target",
      "sensitive_cols",
      "C",
      "penalty",
      "fit_intercept",
      "max_iter",
      "train_sensitive_cols"
    ],
    "constraints": [
      "self",
      "y_hat",
      "y_true",
      "sensitive",
      "n_obs"
    ]
  },
  "BaseScipyMinimizeRegressor": {
    "__init__": [
      "self",
      "alpha",
      "l1_ratio",
      "fit_intercept",
      "copy_X",
      "positive",
      "method"
    ],
    "_get_objective": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_regularized_loss": [
      "self",
      "params"
    ],
    "_regularized_grad_loss": [
      "self",
      "params"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_prepare_inputs": [
      "self",
      "X",
      "sample_weight",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "ImbalancedLinearRegression": {
    "__init__": [
      "self",
      "alpha",
      "l1_ratio",
      "fit_intercept",
      "copy_X",
      "positive",
      "method",
      "overestimation_punishment_factor"
    ],
    "_get_objective": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "QuantileRegression": {
    "__init__": [
      "self",
      "alpha",
      "l1_ratio",
      "fit_intercept",
      "copy_X",
      "positive",
      "method",
      "quantile"
    ],
    "_get_objective": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "LADRegression": {
    "__init__": [
      "self",
      "alpha",
      "l1_ratio",
      "fit_intercept",
      "copy_X",
      "positive",
      "method"
    ]
  },
  "_get_shape_delta": [
    "old_shape",
    "new_shape"
  ],
  "log_step": [
    "func"
  ],
  "log_step_extra": [],
  "add_lags": [
    "X",
    "cols",
    "lags",
    "drop_na"
  ],
  "_add_lagged_numpy_columns": [
    "X",
    "cols",
    "lags",
    "drop_na"
  ],
  "_add_lagged_dataframe_columns": [
    "df",
    "cols",
    "lags",
    "drop_na"
  ],
  "OutlierClassifier": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "model"
    ],
    "_is_outlier_model": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "ZeroInflatedRegressor": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "classifier",
      "regressor",
      "handle_zero"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ]
  },
  "parse_X_y": [
    "X",
    "y",
    "groups",
    "check_X"
  ],
  "_validate_groups_values": [
    "X",
    "groups"
  ],
  "_data_format_checks": [
    "X"
  ],
  "DecayEstimator": {
    "_ALLOWED_DECAYS": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "model",
      "decay_func",
      "check_input",
      "decay_kwargs"
    ],
    "_is_classifier": [
      "self"
    ],
    "_is_regressor": [
      "self"
    ],
    "_estimator_type": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "__all__": [],
  "ConfusionBalancer": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "estimator",
      "alpha",
      "cfm_smooth"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_get_estimator": [
    "estimators",
    "grp_values",
    "grp_names",
    "return_level",
    "fallback_method"
  ],
  "HierarchicalPredictor": {
    "_CHECK_KWARGS": [],
    "_ALLOWED_SHRINKAGE": [],
    "_ALLOWED_FALLBACK": [],
    "_GLOBAL_NAME": [],
    "_TARGET_NAME": [],
    "_INDEX_NAME": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "estimator",
      "groups"
    ],
    "_estimator_type": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict_estimators": [
      "self",
      "X",
      "method_name"
    ],
    "_fit_single_estimator": [
      "self",
      "grp_frame"
    ],
    "_fit_estimators": [
      "self",
      "frame"
    ],
    "__validate_frame": [
      "self",
      "frame"
    ],
    "n_levels_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "HierarchicalRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "HierarchicalClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "EstimatorTransformer": {
    "__init__": [
      "self",
      "estimator",
      "predict_func",
      "check_input"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "OrdinalClassifier": {
    "is_multiclass": [],
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_fit_binary_estimator": [
      "self",
      "X",
      "y",
      "y_label"
    ],
    "n_classes_": [
      "self"
    ]
  },
  "GroupedTransformer": {
    "_check_kwargs": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "transformer",
      "groups",
      "use_global_model",
      "check_X"
    ],
    "__fit_single_group": [
      "self",
      "group",
      "X",
      "y"
    ],
    "__fit_grouped_transformer": [
      "self",
      "frame",
      "y"
    ],
    "__check_transformer": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__transform_single_group": [
      "self",
      "group",
      "X"
    ],
    "__transform_groups": [
      "self",
      "frame"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_feature_names_out": [
      "self"
    ]
  },
  "RegressionOutlierDetector": {
    "_ALLOWED_METHODS": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "model",
      "column",
      "lower",
      "upper",
      "method"
    ],
    "_is_regression_model": [
      "self"
    ],
    "_handle_thresholds": [
      "self",
      "y_true",
      "y_pred"
    ],
    "to_x_y": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "y"
    ],
    "score_samples": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "GroupedPredictor": {
    "_check_kwargs": [],
    "_global_col_name": [],
    "_global_col_value": [],
    "_ALLOWED_SHRINKAGE": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "estimator",
      "groups",
      "shrinkage",
      "use_global_model",
      "check_X",
      "shrinkage_kwargs"
    ],
    "__fit_single_group": [
      "self",
      "group",
      "X",
      "y"
    ],
    "__fit_grouped_estimator": [
      "self",
      "frame",
      "y",
      "columns"
    ],
    "__fit_shrinkage_groups": [
      "self",
      "frame",
      "y"
    ],
    "__add_shrinkage_column": [
      "self",
      "frame",
      "groups"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__predict_shrinkage_groups": [
      "self",
      "frame",
      "method",
      "groups"
    ],
    "__predict_single_group": [
      "self",
      "group",
      "X",
      "method"
    ],
    "__predict_groups": [
      "self",
      "frame",
      "method",
      "groups"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "_estimator_type": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "GroupedRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "GroupedClassifier": {
    "__init__": [
      "self",
      "estimator",
      "groups",
      "use_global_model",
      "check_X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "Thresholder": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "model",
      "threshold",
      "refit",
      "check_input"
    ],
    "_handle_unfitted": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_handle_refit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "linear_decay": [
    "X",
    "y",
    "min_value",
    "max_value"
  ],
  "exponential_decay": [
    "X",
    "y",
    "decay_rate"
  ],
  "stepwise_decay": [
    "X",
    "y",
    "n_steps",
    "step_size",
    "min_value",
    "max_value"
  ],
  "sigmoid_decay": [
    "X",
    "y",
    "growth_rate",
    "min_value",
    "max_value"
  ],
  "_sigmoid": [
    "x",
    "growth_rate",
    "offset"
  ],
  "SubjectiveClassifier": {
    "_ALLOWED_EVIDENCE": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "estimator",
      "prior",
      "evidence"
    ],
    "_likelihood": [
      "self",
      "predicted_class",
      "given_class",
      "cfm"
    ],
    "_evidence": [
      "self",
      "predicted_class",
      "cfm"
    ],
    "_posterior": [
      "self",
      "y",
      "y_hat",
      "cfm"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_weighted_proba": [
      "weights",
      "y_hat_probas"
    ],
    "_to_discrete": [
      "y_hat_probas"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "classes_": [
      "self"
    ]
  },
  "constant_shrinkage": [
    "group_sizes",
    "alpha"
  ],
  "relative_shrinkage": [
    "group_sizes"
  ],
  "no_shrinkage_function": [
    "x",
    "n"
  ],
  "min_n_obs_shrinkage": [
    "group_sizes",
    "min_n_obs"
  ],
  "equal_shrinkage": [
    "group_sizes"
  ],
  "ShrinkageMixin": {
    "_set_shrinkage_function": [
      "self"
    ],
    "__check_shrinkage_func": [
      "self"
    ],
    "_fit_shrinkage_factors": [
      "self",
      "frame",
      "groups",
      "most_granular_only"
    ]
  },
  "BayesianGMMClassifier": {
    "__init__": [
      "self",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weight_concentration_prior_type",
      "weight_concentration_prior",
      "mean_precision_prior",
      "mean_prior",
      "degrees_of_freedom_prior",
      "covariance_prior",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "GMMClassifier": {
    "__init__": [
      "self",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weights_init",
      "means_init",
      "precisions_init",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "BayesianGMMOutlierDetector": {
    "_ALLOWED_METHODS": [],
    "__init__": [
      "self",
      "threshold",
      "method",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weight_concentration_prior_type",
      "weight_concentration_prior",
      "mean_precision_prior",
      "mean_prior",
      "degrees_of_freedom_prior",
      "covariance_prior",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "allowed_methods": [
      "self"
    ]
  },
  "GMMOutlierDetector": {
    "_ALLOWED_METHODS": [],
    "__init__": [
      "self",
      "threshold",
      "method",
      "n_components",
      "covariance_type",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "weights_init",
      "means_init",
      "precisions_init",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "allowed_methods": [
      "self"
    ]
  },
  "UMAPOutlierDetection": {
    "__init__": [
      "self",
      "n_components",
      "threshold",
      "variant",
      "n_neighbors",
      "min_dist",
      "metric",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "difference": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "PCAOutlierDetection": {
    "__init__": [
      "self",
      "n_components",
      "threshold",
      "variant",
      "whiten",
      "svd_solver",
      "tol",
      "iterated_power",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "difference": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_redundancy_pearson": [
    "X",
    "selected",
    "left"
  ],
  "MaximumRelevanceMinimumRedundancy": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "k"
    ],
    "_get_support_mask": [
      "self"
    ],
    "_get_relevance": [
      "self"
    ],
    "_get_redundancy": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "DictMapper": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "mapper",
      "default"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "dim_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "FormulaicTransformer": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "formula",
      "return_type"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_mk_monotonic_average": [
    "xs",
    "ys",
    "intervals",
    "method"
  ],
  "_mk_average": [
    "xs",
    "ys",
    "intervals",
    "method",
    "span"
  ],
  "IntervalEncoder": {
    "_ALLOWED_METHODS": [],
    "__init__": [
      "self",
      "n_chunks",
      "span",
      "method"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "num_cols_": [
      "self"
    ],
    "allowed_methods": [
      "self"
    ]
  },
  "ColumnCapper": {
    "__init__": [
      "self",
      "quantile_range",
      "interpolation",
      "discard_infs",
      "copy"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_check_quantile_range": [
      "quantile_range"
    ],
    "_check_interpolation": [
      "interpolation"
    ],
    "n_columns_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_nw_match_dtype": [
    "dtype",
    "selection"
  ],
  "_nw_select_dtypes": [
    "include",
    "exclude",
    "schema"
  ],
  "ColumnDropper": {
    "__init__": [
      "self",
      "columns"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names": [
      "self"
    ],
    "_check_column_length": [
      "self"
    ],
    "_check_column_names": [
      "self",
      "X"
    ]
  },
  "TypeSelector": {
    "__init__": [
      "self",
      "include",
      "exclude"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names": [
      "self"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "PandasTypeSelector": {
    "__init__": [
      "self",
      "include",
      "exclude"
    ]
  },
  "ColumnSelector": {
    "__init__": [
      "self",
      "columns"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names": [
      "self"
    ],
    "_check_column_length": [
      "self"
    ],
    "_check_column_names": [
      "self",
      "X"
    ]
  },
  "RepeatingBasisFunction": {
    "__init__": [
      "self",
      "column",
      "remainder",
      "n_periods",
      "input_range",
      "width"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "_RepeatingBasisFunction": {
    "__init__": [
      "self",
      "n_periods",
      "input_range",
      "width"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_array_base_distance": [
      "self",
      "arr",
      "base"
    ],
    "_array_bases_distances": [
      "self",
      "array",
      "bases"
    ],
    "_rbf": [
      "self",
      "arr"
    ]
  },
  "IdentityTransformer": {
    "__init__": [
      "self",
      "check_X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "shape_": [
      "self"
    ]
  },
  "RandomAdder": {
    "__init__": [
      "self",
      "noise",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform_train": [
      "self",
      "X"
    ],
    "dim_": [
      "self"
    ],
    "_more_tags": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "OutlierRemover": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "outlier_detector",
      "refit"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform_train": [
      "self",
      "X"
    ]
  },
  "MonotonicSplineTransformer": {
    "__init__": [
      "self",
      "n_knots",
      "degree",
      "knots"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "LinearEmbedder": {
    "__init__": [
      "self",
      "estimator",
      "check_input"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "OrthogonalTransformer": {
    "__init__": [
      "self",
      "normalize"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "scalar_projection": [
    "vec",
    "unto"
  ],
  "vector_projection": [
    "vec",
    "unto"
  ],
  "InformationFilter": {
    "_required_parameters": [],
    "__init__": [
      "self",
      "columns",
      "alpha"
    ],
    "_check_coltype": [
      "self",
      "X"
    ],
    "_col_idx": [
      "self",
      "X",
      "name"
    ],
    "_make_v_vectors": [
      "self",
      "X",
      "col_ids"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  }
}