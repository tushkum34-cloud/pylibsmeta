{
  "__version__": [],
  "BoxCDQPState": {},
  "fori_loop_body_fun": [
    "i",
    "tup"
  ],
  "BoxCDQP": {
    "init_state": [
      "self",
      "init_params",
      "params_obj",
      "params_ineq"
    ],
    "update": [
      "self",
      "params",
      "state",
      "params_obj",
      "params_ineq"
    ],
    "_fixed_point_fun": [
      "self",
      "sol",
      "params_obj",
      "params_ineq"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "params_obj",
      "params_ineq"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "extract_Qc_from_obj": [
    "init_params",
    "params_obj",
    "fun"
  ],
  "_make_eq_qp_optimality_fun": [
    "matvec_Q",
    "matvec_A",
    "fun"
  ],
  "EqualityConstrainedQP": {
    "_refined_solve": [
      "self",
      "matvec",
      "b",
      "init",
      "maxiter",
      "tol"
    ],
    "run": [
      "self",
      "init_params",
      "params_obj",
      "params_eq"
    ],
    "l2_optimality_error": [
      "self",
      "params",
      "params_obj",
      "params_eq"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "projection_non_negative": [
    "x",
    "hyperparams"
  ],
  "_clip_safe": [
    "x",
    "lower",
    "upper"
  ],
  "projection_box": [
    "x",
    "hyperparams"
  ],
  "projection_hypercube": [
    "x",
    "unit"
  ],
  "_projection_unit_simplex": [
    "x"
  ],
  "_projection_unit_simplex_jvp": [
    "primals",
    "tangents"
  ],
  "projection_simplex": [
    "x",
    "value"
  ],
  "_projection_unit_sparse_simplex": [
    "x",
    "max_nz",
    "use_approx_max_nz"
  ],
  "_projection_unit_sparse_simplex_jvp": [
    "max_nz",
    "use_approx_max_nz",
    "primals",
    "tangents"
  ],
  "projection_sparse_simplex": [
    "x",
    "max_nz",
    "use_approx_max_nz",
    "value"
  ],
  "projection_l1_sphere": [
    "x",
    "value"
  ],
  "projection_l1_ball": [
    "x",
    "max_value"
  ],
  "projection_l2_sphere": [
    "x",
    "value"
  ],
  "projection_l2_ball": [
    "x",
    "max_value"
  ],
  "projection_linf_ball": [
    "x",
    "max_value"
  ],
  "projection_hyperplane": [
    "x",
    "hyperparams"
  ],
  "projection_halfspace": [
    "x",
    "hyperparams"
  ],
  "projection_affine_set": [
    "x",
    "hyperparams"
  ],
  "projection_polyhedron": [
    "x",
    "hyperparams",
    "check_feasible"
  ],
  "_optimality_fun_proj_box_sec": [
    "tau",
    "x",
    "hyperparams"
  ],
  "_root_proj_box_sec": [
    "x",
    "hyperparams"
  ],
  "projection_box_section": [
    "x",
    "hyperparams",
    "check_feasible"
  ],
  "_max_l2": [
    "x",
    "marginal_b",
    "gamma"
  ],
  "_max_ent": [
    "x",
    "marginal_b",
    "gamma"
  ],
  "_max_l2_vmap": [],
  "_max_l2_grad_vmap": [],
  "_max_ent_vmap": [],
  "_max_ent_grad_vmap": [],
  "_delta_l2": [
    "x",
    "gamma"
  ],
  "_delta_ent": [
    "x",
    "gamma"
  ],
  "_delta_l2_vmap": [],
  "_delta_l2_grad_vmap": [],
  "_delta_ent_vmap": [],
  "_delta_ent_grad_vmap": [],
  "_make_semi_dual": [
    "max_vmap",
    "gamma"
  ],
  "_make_dual": [
    "delta_vmap",
    "gamma"
  ],
  "_regularized_transport_semi_dual": [
    "cost_matrix",
    "marginals_a",
    "marginals_b",
    "make_solver",
    "max_vmap",
    "max_grad_vmap",
    "gamma"
  ],
  "_regularized_transport_dual": [
    "cost_matrix",
    "marginals_a",
    "marginals_b",
    "make_solver",
    "delta_vmap",
    "delta_grad_vmap",
    "gamma"
  ],
  "projection_transport": [
    "sim_matrix",
    "marginals",
    "make_solver",
    "use_semi_dual"
  ],
  "kl_projection_transport": [
    "sim_matrix",
    "marginals",
    "make_solver",
    "use_semi_dual"
  ],
  "projection_birkhoff": [
    "sim_matrix",
    "make_solver",
    "use_semi_dual"
  ],
  "kl_projection_birkhoff": [
    "sim_matrix",
    "make_solver",
    "use_semi_dual"
  ],
  "BlockCDState": {},
  "BlockCoordinateDescent": {
    "init_state": [
      "self",
      "init_params",
      "hyperparams_prox"
    ],
    "update": [
      "self",
      "params",
      "state",
      "hyperparams_prox"
    ],
    "_fixed_point_fun": [
      "self",
      "params",
      "hyperparams_prox"
    ],
    "optimality_fun": [
      "self",
      "params",
      "hyperparams_prox"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "PolyakSGDState": {},
  "PolyakSGD": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__hash__": [
      "self"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_make_osqp_optimality_fun": [
    "matvec_Q",
    "matvec_A",
    "fun"
  ],
  "BoxOSQPState": {},
  "OSQPLinearSolver": {
    "init_state": [
      "self",
      "init_params",
      "params_Q",
      "params_A",
      "sigma",
      "rho_bar"
    ],
    "update_stepsize": [
      "self",
      "solver_state",
      "rho_bar"
    ],
    "run": [
      "self",
      "b",
      "osqp_state"
    ]
  },
  "OSQPIndirectSolver": {
    "_init_state_precond": [
      "self",
      "params_Q",
      "params_A",
      "sigma",
      "rho_bar"
    ],
    "_matvec_precond": [
      "self",
      "solver_state",
      "x"
    ],
    "init_state": [
      "self",
      "init_params",
      "params_Q",
      "params_A",
      "sigma",
      "rho_bar"
    ],
    "update_stepsize": [
      "self",
      "solver_state",
      "rho_bar"
    ],
    "run": [
      "self",
      "b",
      "osqp_state"
    ]
  },
  "OSQPLUSolver": {
    "_lu_factor_dense": [
      "self",
      "Q",
      "A",
      "sigma",
      "rho_bar"
    ],
    "_lu_factor_pytree": [
      "self",
      "params_Q",
      "params_A",
      "sigma",
      "rho_bar"
    ],
    "init_state": [
      "self",
      "init_params",
      "params_Q",
      "params_A",
      "sigma",
      "rho_bar"
    ],
    "update_stepsize": [
      "self",
      "solver_state",
      "rho_bar"
    ],
    "run": [
      "self",
      "b",
      "osqp_state"
    ]
  },
  "BoxOSQP": {
    "UNSOLVED": [],
    "SOLVED": [],
    "DUAL_INFEASIBLE": [],
    "PRIMAL_INFEASIBLE": [],
    "init_state": [
      "self",
      "init_params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "init_params": [
      "self",
      "init_x",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "_get_full_KKT_solution": [
      "primal",
      "y"
    ],
    "_update_stepsize": [
      "self",
      "rho_bar",
      "solver_state",
      "primal_residuals",
      "dual_residuals",
      "Q",
      "c",
      "A",
      "x",
      "y"
    ],
    "_compute_residuals": [
      "self",
      "Q",
      "c",
      "A",
      "x",
      "z",
      "y"
    ],
    "_compute_error": [
      "self",
      "primal_residuals",
      "dual_residuals"
    ],
    "_check_dual_infeasability": [
      "self",
      "error",
      "status",
      "delta_x",
      "Q",
      "c",
      "Adx",
      "l",
      "u"
    ],
    "_check_primal_infeasability": [
      "self",
      "error",
      "status",
      "delta_y",
      "ATdy",
      "l",
      "u"
    ],
    "_check_infeasability": [
      "self",
      "prev_sol",
      "sol",
      "error",
      "status",
      "Q",
      "c",
      "A",
      "l",
      "u"
    ],
    "_check_termination_conditions": [
      "self",
      "primal_residuals",
      "dual_residuals",
      "old_params",
      "params",
      "Q",
      "c",
      "A",
      "l",
      "u"
    ],
    "_solve_linear_system": [
      "self",
      "params",
      "Q",
      "c",
      "A",
      "rho_bar",
      "state"
    ],
    "_admm_step": [
      "self",
      "params",
      "Q",
      "c",
      "A",
      "box",
      "rho_bar",
      "state"
    ],
    "update": [
      "self",
      "params",
      "state",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "run": [
      "self",
      "init_params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "l2_optimality_error": [
      "self",
      "params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "OSQP_to_BoxOSQP": {
    "transform_matvec": [
      "matvec_Q",
      "matvec_A",
      "matvec_G"
    ],
    "_pytree_concat": [
      "pytrees",
      "axis"
    ],
    "transform": [
      "matvec_A_box",
      "params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "_pytree_split": [
      "pytree",
      "slice_sizes"
    ],
    "inverse_transform": [
      "matvec_A_box",
      "eq_ineq_size",
      "kkt_solution"
    ]
  },
  "OSQPState": {},
  "OSQP": {
    "__init__": [
      "self"
    ],
    "init_params": [
      "self",
      "init_x",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "run": [
      "self",
      "init_params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "l2_optimality_error": [
      "self",
      "params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ]
  },
  "huber_loss": [
    "target",
    "pred",
    "delta"
  ],
  "binary_logistic_loss": [
    "label",
    "logit"
  ],
  "binary_sparsemax_loss": [
    "label",
    "logit"
  ],
  "sparse_plus": [
    "x"
  ],
  "sparse_sigmoid": [
    "x"
  ],
  "binary_hinge_loss": [
    "label",
    "score"
  ],
  "binary_perceptron_loss": [
    "label",
    "score"
  ],
  "multiclass_logistic_loss": [
    "label",
    "logits"
  ],
  "multiclass_sparsemax_loss": [
    "label",
    "scores"
  ],
  "multiclass_hinge_loss": [
    "label",
    "scores"
  ],
  "multiclass_perceptron_loss": [
    "label",
    "scores"
  ],
  "make_fenchel_young_loss": [
    "max_fun"
  ],
  "_setup_linesearch": [
    "linesearch",
    "fun",
    "value_and_grad",
    "has_aux",
    "maxlsiter",
    "max_stepsize",
    "jit",
    "unroll",
    "verbose"
  ],
  "_init_stepsize": [
    "strategy",
    "max_stepsize",
    "min_stepsize",
    "increase_factor",
    "stepsize"
  ],
  "minimize_residuals": [
    "residual_gram",
    "ridge"
  ],
  "anderson_step": [
    "params_history",
    "residuals_history",
    "residual_gram",
    "ridge",
    "beta"
  ],
  "pytree_replace_elem": [
    "tree_batched",
    "index",
    "new_elems"
  ],
  "update_history": [
    "pos",
    "params_history",
    "residuals_history",
    "residual_gram",
    "extrapolated",
    "residual"
  ],
  "AndersonState": {},
  "AndersonAcceleration": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "Normal": {
    "sample": [
      "self",
      "seed",
      "sample_shape"
    ],
    "log_prob": [
      "self",
      "inputs"
    ]
  },
  "Gumbel": {
    "sample": [
      "self",
      "seed",
      "sample_shape"
    ],
    "log_prob": [
      "self",
      "inputs"
    ]
  },
  "make_perturbed_argmax": [
    "argmax_fun",
    "num_samples",
    "sigma",
    "noise",
    "control_variate"
  ],
  "make_perturbed_max": [
    "argmax_fun",
    "num_samples",
    "sigma",
    "noise"
  ],
  "make_perturbed_fun": [
    "fun",
    "num_samples",
    "sigma",
    "noise",
    "control_variate"
  ],
  "MirrorDescentState": {},
  "MirrorDescent": {
    "make_projection_grad": [
      "projection",
      "mapping_fun"
    ],
    "init_state": [
      "self",
      "init_params",
      "hyperparams_proj"
    ],
    "_error": [
      "self",
      "x",
      "next_x",
      "stepsize"
    ],
    "_stepsize": [
      "self",
      "iter_num"
    ],
    "_update": [
      "self",
      "x",
      "state",
      "hyperparams_proj",
      "args",
      "kwargs"
    ],
    "update": [
      "self",
      "params",
      "state",
      "hyperparams_proj"
    ],
    "run": [
      "self",
      "init_params",
      "hyperparams_proj"
    ],
    "_fixed_point_fun": [
      "self",
      "sol",
      "hyperparams_proj",
      "args",
      "kwargs"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "hyperparams_proj"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "BisectionState": {},
  "Bisection": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "run": [
      "self",
      "init_params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "AutoOrBoolean": [],
  "ArrayPair": [],
  "NUM_EVAL_DTYPE": [],
  "OptStep": {},
  "KKTSolution": {},
  "_add_aux_to_value_and_grad": [
    "value_and_grad"
  ],
  "_add_aux_to_fun": [
    "fun"
  ],
  "_split_value_and_grad_with_aux": [
    "value_and_grad_with_aux"
  ],
  "_remove_aux_from_value_and_grad": [
    "value_and_grad_with_aux"
  ],
  "_make_funs_without_aux": [
    "fun",
    "value_and_grad",
    "has_aux"
  ],
  "_make_funs_with_aux": [
    "fun",
    "value_and_grad",
    "has_aux"
  ],
  "Solver": {
    "run": [
      "self",
      "init_params"
    ],
    "l2_optimality_error": [
      "self",
      "params"
    ],
    "attribute_names": [
      "self"
    ],
    "attribute_values": [
      "self"
    ]
  },
  "IterativeSolver": {
    "_get_unroll_option": [
      "self"
    ],
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "log_info": [
      "self",
      "state",
      "error_name",
      "additional_info"
    ],
    "_body_fun": [
      "self",
      "inputs"
    ],
    "_make_zero_step": [
      "self",
      "init_params",
      "state"
    ],
    "_run": [
      "self",
      "init_params"
    ],
    "run": [
      "self",
      "init_params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_where": [
    "cond",
    "x",
    "y"
  ],
  "StochasticSolver": {
    "run_iterator": [
      "self",
      "init_params",
      "iterator"
    ]
  },
  "LinearOperator": {
    "__init__": [
      "self",
      "A"
    ],
    "shape": [
      "self"
    ],
    "matvec": [
      "self",
      "x"
    ],
    "matvec_element": [
      "self",
      "x",
      "idx"
    ],
    "rmatvec": [
      "self",
      "x"
    ],
    "rmatvec_element": [
      "self",
      "x",
      "idx"
    ],
    "update_matvec": [
      "self",
      "Ax",
      "delta",
      "idx"
    ],
    "update_rmatvec": [
      "self",
      "ATx",
      "delta",
      "idx"
    ],
    "column_l2_norms": [
      "self",
      "squared"
    ],
    "tree_flatten": [
      "self"
    ],
    "tree_unflatten": [
      "cls",
      "aux_data",
      "children"
    ]
  },
  "LineSearchStep": {},
  "IterativeLineSearch": {
    "_make_zero_step": [
      "self",
      "init_stepsize",
      "state"
    ],
    "run": [
      "self",
      "init_stepsize",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ]
  },
  "DenseLinearOperator": {
    "__init__": [
      "self",
      "pytree"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "matvec": [
      "self",
      "x"
    ],
    "rmatvec": [
      "self",
      "_",
      "y"
    ],
    "matvec_and_rmatvec": [
      "self",
      "x",
      "y"
    ],
    "normal_matvec": [
      "self",
      "x"
    ],
    "diag": [
      "self"
    ],
    "columns_l2_norms": [
      "self",
      "squared"
    ]
  },
  "FunctionalLinearOperator": {
    "__init__": [
      "self",
      "fun",
      "params"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "matvec": [
      "self",
      "x"
    ],
    "rmatvec": [
      "self",
      "x",
      "y"
    ],
    "matvec_and_rmatvec": [
      "self",
      "x",
      "y"
    ],
    "normal_matvec": [
      "self",
      "x"
    ]
  },
  "_make_linear_operator": [
    "matvec"
  ],
  "AndersonWrapperState": {},
  "AndersonWrapper": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "WARNING_PREAMBLE": [],
  "FLAG_NAN_INF_VALUES": [],
  "FLAG_INTERVAL_NOT_FOUND": [],
  "FLAG_INTERVAL_TOO_SMALL": [],
  "FLAG_CURVATURE_COND_NOT_SATSIFIED": [],
  "FLAG_NO_STEPSIZE_FOUND": [],
  "FLAG_NOT_A_DESCENT_DIRECTION": [],
  "_dot": [],
  "_cubicmin": [
    "a",
    "fa",
    "fpa",
    "b",
    "fb",
    "c",
    "fc"
  ],
  "_quadmin": [
    "a",
    "fa",
    "fpa",
    "b",
    "fb"
  ],
  "_set_values": [
    "cond",
    "candidate",
    "default"
  ],
  "_cond_print": [
    "condition",
    "message"
  ],
  "ZoomLineSearchState": {},
  "ZoomLineSearch": {
    "_value_and_slope_on_line": [
      "self",
      "params",
      "stepsize",
      "descent_direction",
      "args",
      "kwargs"
    ],
    "_decrease_error": [
      "self",
      "stepsize",
      "value_step",
      "slope_step",
      "value_init",
      "slope_init"
    ],
    "_curvature_error": [
      "self",
      "slope_step",
      "slope_init"
    ],
    "_make_safe_step": [
      "self",
      "stepsize",
      "state",
      "args",
      "kwargs"
    ],
    "_keep_step": [
      "self",
      "stepsize",
      "state",
      "_",
      "__"
    ],
    "_search_interval": [
      "self",
      "init_stepsize",
      "state",
      "args",
      "kwargs"
    ],
    "_zoom_into_interval": [
      "self",
      "stepsize",
      "state",
      "args",
      "kwargs"
    ],
    "init_state": [
      "self",
      "init_stepsize",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "update": [
      "self",
      "stepsize",
      "state",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "_log_info": [
      "self",
      "state",
      "stepsize"
    ],
    "failure_diagnostic": [
      "self",
      "stepsize",
      "state"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "cond": [
    "cond",
    "if_fun",
    "else_fun"
  ],
  "NonlinearCGState": {},
  "NonlinearCG": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "_grad_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "ProjectedGradient": {
    "init_state": [
      "self",
      "init_params",
      "hyperparams_proj"
    ],
    "update": [
      "self",
      "params",
      "state",
      "hyperparams_proj"
    ],
    "run": [
      "self",
      "init_params",
      "hyperparams_proj"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "hyperparams_proj"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "matvec": [
    "d_history",
    "c_history",
    "x",
    "indices"
  ],
  "inv_jacobian_product_leaf": [
    "v",
    "d_history",
    "c_history",
    "gamma",
    "start"
  ],
  "inv_jacobian_product": [
    "pytree",
    "d_history",
    "c_history",
    "gamma",
    "start"
  ],
  "inv_jacobian_rproduct": [
    "pytree",
    "d_history",
    "c_history",
    "gamma",
    "start"
  ],
  "init_history": [
    "pytree",
    "history_size"
  ],
  "BroydenState": {},
  "Broyden": {
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_value_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "BacktrackingLineSearchState": {},
  "BacktrackingLineSearch": {
    "init_state": [
      "self",
      "init_stepsize",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "update": [
      "self",
      "stepsize",
      "state",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "_compute_final_grad": [
      "self",
      "params",
      "fun_args",
      "fun_kwargs"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "CompositeLinearFunction": {
    "b": [
      "self"
    ],
    "lipschitz_const": [
      "self",
      "hyperparams"
    ],
    "subfun": [
      "self",
      "predictions"
    ],
    "__call__": [
      "self",
      "params"
    ]
  },
  "LeastSquares": {
    "subfun": [
      "self",
      "predictions",
      "data"
    ],
    "make_linop": [
      "self",
      "data"
    ],
    "columnwise_lipschitz_const": [
      "self",
      "data"
    ],
    "__call__": [
      "self",
      "W",
      "data"
    ]
  },
  "least_squares": [],
  "ridge_regression": [
    "params",
    "l2reg",
    "data"
  ],
  "_logloss_vmap": [],
  "MulticlassLogreg": {
    "subfun": [
      "self",
      "predictions",
      "data"
    ],
    "make_linop": [
      "self",
      "data"
    ],
    "columnwise_lipschitz_const": [
      "self",
      "data"
    ],
    "__call__": [
      "self",
      "W",
      "data"
    ]
  },
  "multiclass_logreg": [],
  "multiclass_logreg_with_intercept": [
    "params",
    "data"
  ],
  "l2_multiclass_logreg": [
    "W",
    "l2reg",
    "data"
  ],
  "l2_multiclass_logreg_with_intercept": [
    "params",
    "l2reg",
    "data"
  ],
  "_binary_logloss_vmap": [],
  "BinaryLogreg": {
    "subfun": [
      "self",
      "predictions",
      "data"
    ],
    "make_linop": [
      "self",
      "data"
    ],
    "columnwise_lipschitz_const": [
      "self",
      "data"
    ],
    "__call__": [
      "self",
      "w",
      "data"
    ]
  },
  "binary_logreg": [],
  "MulticlassLinearSvmDual": {
    "subfun": [
      "self",
      "Xbeta",
      "l2reg",
      "data"
    ],
    "make_linop": [
      "self",
      "l2reg",
      "data"
    ],
    "columnwise_lipschitz_const": [
      "self",
      "l2reg",
      "data"
    ],
    "b": [
      "self",
      "l2reg",
      "data"
    ]
  },
  "multiclass_linear_svm_dual": [],
  "OptaxState": {},
  "OptaxSolver": {
    "init_state": [
      "self",
      "init_params"
    ],
    "_apply_updates": [
      "self",
      "params",
      "updates"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "GaussNewtonState": {},
  "GaussNewton": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "__post_init__": [
      "self"
    ],
    "_jtj_op": [
      "self",
      "params",
      "vec"
    ],
    "_jt_op": [
      "self",
      "params",
      "residual"
    ]
  },
  "wolfe_cond_violated": [
    "stepsize",
    "coef",
    "f_cur",
    "f_next",
    "grad_sqnorm"
  ],
  "curvature_cond_violated": [
    "stepsize",
    "coef",
    "f_cur",
    "f_next",
    "grad_sqnorm"
  ],
  "armijo_line_search": [
    "fun_with_aux",
    "unroll",
    "jit",
    "goldstein",
    "maxls",
    "params",
    "f_cur",
    "stepsize",
    "grad",
    "coef",
    "decrease_factor",
    "increase_factor",
    "max_stepsize",
    "args",
    "kwargs"
  ],
  "ArmijoState": {},
  "ArmijoSGD": {
    "init_state": [
      "self",
      "init_params"
    ],
    "reset_stepsize": [
      "self",
      "stepsize"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "_grad_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_flatten_and_concat": [
    "tree",
    "batch_ndims"
  ],
  "_split_and_pack_like": [
    "x",
    "tree"
  ],
  "_get_error": [
    "x",
    "grad",
    "lower",
    "upper"
  ],
  "_find_cauchy_point": [
    "x",
    "grad",
    "lower",
    "upper",
    "theta",
    "w",
    "m"
  ],
  "_minimize_subspace": [
    "x",
    "grad",
    "lower",
    "upper",
    "x_cauchy",
    "c",
    "theta",
    "w",
    "m",
    "active_set_mask"
  ],
  "LbfgsbState": {},
  "LBFGSB": {
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "init_state": [
      "self",
      "init_params",
      "bounds"
    ],
    "update": [
      "self",
      "params",
      "state",
      "bounds"
    ],
    "_fixed_point_fun": [
      "self",
      "sol",
      "bounds",
      "args",
      "kwargs"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "bounds"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "_grad_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "select_ith_tree": [
    "tree_history",
    "i"
  ],
  "inv_hessian_product": [
    "pytree",
    "s_history",
    "y_history",
    "rho_history",
    "gamma",
    "start"
  ],
  "compute_gamma": [
    "s_history",
    "y_history",
    "last"
  ],
  "LbfgsState": {},
  "LBFGS": {
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "fista_line_search": [
    "fun",
    "prox_grad",
    "jit",
    "unroll",
    "maxls",
    "x",
    "x_fun_val",
    "x_fun_grad",
    "stepsize",
    "decrease_factor",
    "hyperparams_prox",
    "args",
    "kwargs"
  ],
  "ProxGradState": {},
  "ProximalGradient": {
    "init_state": [
      "self",
      "init_params",
      "hyperparams_prox"
    ],
    "_error": [
      "self",
      "diff_x",
      "stepsize"
    ],
    "_prox_grad": [
      "self",
      "x",
      "x_fun_grad",
      "stepsize",
      "hyperparams_prox"
    ],
    "_iter": [
      "self",
      "iter_num",
      "x",
      "x_fun_val",
      "x_fun_grad",
      "stepsize",
      "hyperparams_prox",
      "args",
      "kwargs"
    ],
    "_update": [
      "self",
      "x",
      "state",
      "hyperparams_prox",
      "args",
      "kwargs"
    ],
    "_update_accel": [
      "self",
      "x",
      "state",
      "hyperparams_prox",
      "args",
      "kwargs"
    ],
    "update": [
      "self",
      "params",
      "state",
      "hyperparams_prox"
    ],
    "_fixed_point_fun": [
      "self",
      "sol",
      "hyperparams_prox",
      "args",
      "kwargs"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "hyperparams_prox"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "_grad_fun": [
      "self",
      "params"
    ],
    "_grad_with_aux": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "LevenbergMarquardtState": {},
  "LevenbergMarquardt": {
    "contribution_ratio_threshold": [],
    "_cond_fun": [
      "self",
      "inputs"
    ],
    "init_state": [
      "self",
      "init_params"
    ],
    "update_state_using_gain_ratio": [
      "self",
      "gain_ratio",
      "contribution_ratio_diff",
      "gain_ratio_test_init_state"
    ],
    "update_state_using_delta_params": [
      "self",
      "loss_curr",
      "params",
      "delta_params",
      "contribution_ratio_diff",
      "damping_factor",
      "increase_factor",
      "residual",
      "gradient",
      "jac",
      "jt",
      "jtj",
      "hess_res",
      "aux"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "__post_init__": [
      "self"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_jt_op": [
      "self",
      "params",
      "residual"
    ],
    "_jtj_op": [
      "self",
      "params",
      "vec"
    ],
    "_jtj_diag_op": [
      "self",
      "params"
    ],
    "_d2fvv_op": [
      "self",
      "primals",
      "tangents1",
      "tangents2"
    ],
    "_solve_linear_eqs": [
      "self",
      "matvec",
      "state",
      "params"
    ]
  },
  "print_iteration": [
    "state"
  ],
  "ridge_solver": [
    "X",
    "y",
    "lam"
  ],
  "ridge_solver_jac": [
    "X",
    "y",
    "lam",
    "eps"
  ],
  "lasso_skl": [
    "X",
    "y",
    "lam",
    "tol",
    "fit_intercept"
  ],
  "lasso_skl_jac": [
    "X",
    "y",
    "lam",
    "tol",
    "fit_intercept",
    "eps"
  ],
  "enet_skl": [
    "X",
    "y",
    "params_prox",
    "tol",
    "fit_intercept"
  ],
  "enet_skl_jac": [
    "X",
    "y",
    "params_prox",
    "tol",
    "fit_intercept",
    "eps"
  ],
  "multitask_lasso_skl": [
    "X",
    "Y",
    "lam",
    "tol"
  ],
  "logreg_skl": [
    "X",
    "y",
    "lam",
    "tol",
    "fit_intercept",
    "penalty",
    "multiclass"
  ],
  "logreg_skl_jac": [
    "X",
    "y",
    "lam",
    "tol",
    "fit_intercept",
    "penalty",
    "multiclass",
    "eps"
  ],
  "multiclass_linear_svm_skl": [
    "X",
    "y",
    "lam",
    "tol"
  ],
  "multiclass_linear_svm_skl_jac": [
    "X",
    "y",
    "lam",
    "tol",
    "eps"
  ],
  "lsq_linear_osp": [
    "X",
    "y",
    "bounds",
    "tol",
    "max_iter"
  ],
  "lsq_linear_cube_osp": [
    "X",
    "y",
    "l",
    "tol",
    "max_iter"
  ],
  "lsq_linear_cube_osp_jac": [
    "X",
    "y",
    "l",
    "eps",
    "tol",
    "max_iter"
  ],
  "_dtype_to_32bit_dtype": [],
  "_canonicalize_dtype": [
    "x64_enabled",
    "dtype"
  ],
  "canonicalize_dtype": [
    "dtype"
  ],
  "_dtype": [
    "x"
  ],
  "_default_tolerance": [],
  "default_tolerance": [],
  "tolerance": [
    "dtype",
    "tol"
  ],
  "device_under_test": [],
  "_assert_numpy_allclose": [
    "a",
    "b",
    "atol",
    "rtol",
    "err_msg"
  ],
  "is_sequence": [
    "x"
  ],
  "JaxoptTestCase": {
    "assertArraysEqual": [
      "self",
      "x",
      "y"
    ],
    "assertArraysAllClose": [
      "self",
      "x",
      "y"
    ],
    "assertDtypesMatch": [
      "self",
      "x",
      "y"
    ],
    "assertAllClose": [
      "self",
      "x",
      "y"
    ]
  },
  "FixedPointState": {},
  "FixedPointIteration": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "prox_none": [
    "x",
    "hyperparams",
    "scaling"
  ],
  "prox_lasso": [
    "x",
    "l1reg",
    "scaling"
  ],
  "prox_non_negative_lasso": [
    "x",
    "l1reg",
    "scaling"
  ],
  "prox_elastic_net": [
    "x",
    "hyperparams",
    "scaling"
  ],
  "prox_group_lasso": [
    "x",
    "l2reg",
    "scaling"
  ],
  "prox_ridge": [
    "x",
    "l2reg",
    "scaling"
  ],
  "prox_non_negative_ridge": [
    "x",
    "l2reg",
    "scaling"
  ],
  "make_prox_from_projection": [
    "projection"
  ],
  "_failed_nan": [
    "value",
    "grad"
  ],
  "HagerZhangLineSearchState": {},
  "HagerZhangLineSearch": {
    "approximate_wolfe_threshold": [],
    "_value_and_grad_on_line": [
      "self",
      "x",
      "c",
      "descent_direction"
    ],
    "_satisfies_wolfe_and_approx_wolfe": [
      "self",
      "c",
      "value_c",
      "gd_vdot_c",
      "value_initial",
      "grad_initial",
      "approx_wolfe_threshold_value",
      "descent_direction"
    ],
    "_update": [
      "self",
      "x",
      "low",
      "high",
      "middle",
      "approx_wolfe_threshold_value",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "_secant": [
      "self",
      "x",
      "low",
      "high",
      "descent_direction"
    ],
    "_secant2": [
      "self",
      "x",
      "low",
      "high",
      "approx_wolfe_threshold_value",
      "descent_direction"
    ],
    "_bracket": [
      "self",
      "x",
      "c",
      "approx_wolfe_threshold_value",
      "descent_direction"
    ],
    "init_state": [
      "self",
      "init_stepsize",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "update": [
      "self",
      "stepsize",
      "state",
      "params",
      "value",
      "grad",
      "descent_direction",
      "fun_args",
      "fun_kwargs"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "root_vjp": [
    "optimality_fun",
    "sol",
    "args",
    "cotangent",
    "solve"
  ],
  "_jvp_sol": [
    "optimality_fun",
    "sol",
    "args",
    "tangent"
  ],
  "_jvp_args": [
    "optimality_fun",
    "sol",
    "args",
    "tangents"
  ],
  "root_jvp": [
    "optimality_fun",
    "sol",
    "args",
    "tangents",
    "solve"
  ],
  "_extract_kwargs": [
    "kwarg_keys",
    "flat_args"
  ],
  "_signature_bind": [
    "signature"
  ],
  "_signature_bind_and_match": [
    "signature"
  ],
  "_custom_root": [
    "solver_fun",
    "optimality_fun",
    "solve",
    "has_aux",
    "reference_signature"
  ],
  "custom_root": [
    "optimality_fun",
    "has_aux",
    "solve",
    "reference_signature"
  ],
  "custom_fixed_point": [
    "fixed_point_fun",
    "has_aux",
    "solve",
    "reference_signature"
  ],
  "make_kkt_optimality_fun": [
    "obj_fun",
    "eq_fun",
    "ineq_fun"
  ],
  "tree_flatten": [],
  "tree_leaves": [],
  "tree_map": [],
  "tree_reduce": [],
  "tree_unflatten": [],
  "broadcast_pytrees": [],
  "tree_add": [],
  "tree_sub": [],
  "tree_mul": [],
  "tree_div": [],
  "tree_scalar_mul": [
    "scalar",
    "tree_x"
  ],
  "tree_add_scalar_mul": [
    "tree_x",
    "scalar",
    "tree_y"
  ],
  "_vdot": [],
  "_vdot_safe": [
    "a",
    "b"
  ],
  "tree_vdot": [
    "tree_x",
    "tree_y"
  ],
  "_vdot_real": [
    "x",
    "y"
  ],
  "tree_vdot_real": [
    "tree_x",
    "tree_y"
  ],
  "tree_dot": [
    "tree_x",
    "tree_y"
  ],
  "tree_sum": [
    "tree_x"
  ],
  "tree_l2_norm": [
    "tree_x",
    "squared"
  ],
  "tree_zeros_like": [
    "tree_x"
  ],
  "tree_ones_like": [
    "tree_x"
  ],
  "tree_average": [
    "trees",
    "weights"
  ],
  "tree_gram": [
    "a"
  ],
  "tree_inf_norm": [
    "tree_x"
  ],
  "tree_where": [
    "cond",
    "a",
    "b"
  ],
  "tree_negative": [
    "tree"
  ],
  "tree_reciproqual": [
    "tree"
  ],
  "tree_mean": [
    "tree"
  ],
  "tree_single_dtype": [
    "tree",
    "convert_in_jax_dtype"
  ],
  "get_real_dtype": [
    "dtype"
  ],
  "tree_conj": [
    "tree"
  ],
  "tree_real": [
    "tree"
  ],
  "tree_imag": [
    "tree"
  ],
  "IterativeRefinementState": {},
  "IterativeRefinement": {
    "init_state": [
      "self",
      "init_params",
      "A",
      "b",
      "A_bar"
    ],
    "init_params": [
      "self",
      "A",
      "b",
      "A_bar"
    ],
    "update": [
      "self",
      "params",
      "state",
      "A",
      "b",
      "A_bar"
    ],
    "run": [
      "self",
      "init_params",
      "A",
      "b",
      "A_bar"
    ],
    "optimality_fun": [
      "self",
      "params",
      "A",
      "b",
      "A_bar"
    ],
    "l2_optimality_error": [
      "self",
      "params",
      "A",
      "b",
      "A_bar"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "solve_iterative_refinement": [
    "matvec",
    "b",
    "init",
    "maxiter",
    "tol",
    "solve"
  ],
  "_while_loop_scan": [
    "cond_fun",
    "body_fun",
    "init_val",
    "max_iter"
  ],
  "_while_loop_python": [
    "cond_fun",
    "body_fun",
    "init_val",
    "maxiter"
  ],
  "_while_loop_lax": [
    "cond_fun",
    "body_fun",
    "init_val",
    "maxiter"
  ],
  "while_loop": [
    "cond_fun",
    "body_fun",
    "init_val",
    "maxiter",
    "unroll",
    "jit"
  ],
  "_einsum": [],
  "pytree_to_flat_array": [
    "pytree",
    "dtype"
  ],
  "BfgsState": {},
  "BFGS": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "_value_and_grad_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_isotonic_l2_pav_numba": [
    "y"
  ],
  "_isotonic_l2_pav": [
    "y"
  ],
  "isotonic_l2_pav": [
    "y",
    "y_min",
    "y_max",
    "increasing"
  ],
  "_jvp_isotonic_l2_jax_pav": [
    "solution",
    "vector",
    "eps"
  ],
  "_isotonic_l2_pav_jvp": [
    "primals",
    "tangents"
  ],
  "LbfgsInvHessProductPyTree": {
    "__init__": [
      "self",
      "sk",
      "yk"
    ],
    "__repr__": [
      "self"
    ],
    "tree_flatten": [
      "self"
    ],
    "tree_unflatten": [
      "cls",
      "aux_data",
      "children"
    ]
  },
  "ScipyMinimizeInfo": {},
  "ScipyRootInfo": {},
  "ScipyLeastSquaresInfo": {},
  "PyTreeTopology": {
    "sizes": [
      "self"
    ],
    "n_leaves": [
      "self"
    ]
  },
  "jnp_to_onp": [
    "x_jnp",
    "dtype"
  ],
  "make_jac_jnp_to_onp": [
    "input_pytree_topology",
    "output_pytree_topology",
    "dtype"
  ],
  "make_onp_to_jnp": [
    "pytree_topology"
  ],
  "pytree_topology_from_example": [
    "x_jnp"
  ],
  "ScipyWrapper": {
    "optimality_fun": [
      "self",
      "sol"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "ScipyMinimize": {
    "optimality_fun": [
      "self",
      "sol"
    ],
    "_run": [
      "self",
      "init_params",
      "bounds"
    ],
    "run": [
      "self",
      "init_params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "ScipyBoundedMinimize": {
    "_fixed_point_fun": [
      "self",
      "sol",
      "bounds",
      "args",
      "kwargs"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "bounds"
    ],
    "run": [
      "self",
      "init_params",
      "bounds"
    ]
  },
  "ScipyRootFinding": {
    "run": [
      "self",
      "init_params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "LS_RHO_FUNS": [],
  "LS_DEFAULT_OPTIONS": [],
  "ScipyLeastSquares": {
    "_cost_fun": [
      "self",
      "params"
    ],
    "optimality_fun": [
      "self",
      "sol"
    ],
    "_run": [
      "self",
      "init_params",
      "bounds"
    ],
    "run": [
      "self",
      "init_params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "ScipyBoundedLeastSquares": {
    "_fixed_point_fun": [
      "self",
      "sol",
      "bounds",
      "args",
      "kwargs"
    ],
    "optimality_fun": [
      "self",
      "sol",
      "bounds"
    ],
    "run": [
      "self",
      "init_params",
      "bounds"
    ]
  },
  "GradientDescent": {
    "init_state": [
      "self",
      "init_params"
    ],
    "update": [
      "self",
      "params",
      "state"
    ],
    "optimality_fun": [
      "self",
      "params"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_check_params": [
    "params_obj",
    "params_eq",
    "params_ineq"
  ],
  "_make_cvxpy_qp_optimality_fun": [],
  "CvxpyQP": {
    "run": [
      "self",
      "init_params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "l2_optimality_error": [
      "self",
      "params",
      "params_obj",
      "params_eq",
      "params_ineq"
    ],
    "__post_init__": [
      "self"
    ]
  },
  "_materialize_array": [
    "matvec",
    "shape",
    "dtype"
  ],
  "_make_ridge_matvec": [
    "matvec",
    "ridge"
  ],
  "solve_lu": [
    "matvec",
    "b",
    "ridge"
  ],
  "solve_cholesky": [
    "matvec",
    "b",
    "ridge"
  ],
  "solve_inv": [
    "matvec",
    "b",
    "ridge"
  ],
  "solve_qr": [
    "matvec",
    "b",
    "ridge"
  ],
  "solve_cg": [
    "matvec",
    "b",
    "ridge",
    "init"
  ],
  "_make_rmatvec": [
    "matvec",
    "x"
  ],
  "_normal_matvec": [
    "matvec",
    "x"
  ],
  "solve_normal_cg": [
    "matvec",
    "b",
    "ridge",
    "init"
  ],
  "solve_gmres": [
    "matvec",
    "b",
    "ridge",
    "init",
    "tol"
  ],
  "solve_bicgstab": [
    "matvec",
    "b",
    "ridge",
    "init"
  ]
}