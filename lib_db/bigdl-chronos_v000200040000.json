{
  "__path__": [],
  "deprecated": [
    "message"
  ],
  "LazyImport": {
    "__init__": [
      "self",
      "module_name",
      "pkg"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__call__": [
      "self"
    ]
  },
  "SafePickle": {
    "key": [],
    "dump": [
      "self",
      "obj",
      "file",
      "return_digest"
    ],
    "load": [
      "self",
      "file",
      "digest"
    ]
  },
  "TRIGGER_REG_NAME_PREFIX": [],
  "triggerbyfile": [
    "filename"
  ],
  "triggerbyclock": [
    "seconds"
  ],
  "ConfigGenerator": {
    "__init__": [
      "self"
    ],
    "genConfig": [
      "self"
    ]
  },
  "EPSILON": [],
  "mae": [
    "y_label",
    "y_predict"
  ],
  "mse": [
    "y_label",
    "y_predict"
  ],
  "rmse": [
    "y_label",
    "y_predict"
  ],
  "mape": [
    "y_label",
    "y_predict"
  ],
  "smape": [
    "y_label",
    "y_predict"
  ],
  "r2": [
    "y_label",
    "y_predict"
  ],
  "REGRESSION_MAP": [],
  "_standard_input": [
    "metrics",
    "y_true",
    "y_pred"
  ],
  "_check_shape": [
    "input1",
    "input2",
    "input_name1",
    "input_name2"
  ],
  "Evaluator": {
    "evaluate": [
      "metrics",
      "y_true",
      "y_pred",
      "aggregate"
    ],
    "get_latency": [
      "func"
    ],
    "plot": [
      "y",
      "std",
      "ground_truth",
      "x",
      "feature_index",
      "instance_index",
      "layout",
      "prediction_interval",
      "figsize",
      "output_file"
    ]
  },
  "generate_forecaster": [
    "args"
  ],
  "train": [
    "args",
    "model_path",
    "forecaster",
    "train_loader",
    "records"
  ],
  "throughput": [
    "args",
    "model_path",
    "forecaster",
    "train_loader",
    "test_loader",
    "records"
  ],
  "latency": [
    "args",
    "model_path",
    "forecaster",
    "train_loader",
    "test_loader",
    "records"
  ],
  "accuracy": [
    "args",
    "records",
    "forecaster",
    "train_loader",
    "val_loader",
    "test_loader"
  ],
  "result": [
    "args",
    "records"
  ],
  "experiment": [
    "args",
    "records"
  ],
  "main": [],
  "get_bytesize": [
    "bytes"
  ],
  "_find_path": [
    "path_name"
  ],
  "get_nano_env_var": [
    "use_malloc",
    "use_openmp",
    "print_environment"
  ],
  "generate_data": [
    "args"
  ],
  "get_CPU_info": [],
  "check_nano_env": [
    "use_malloc",
    "use_openmp"
  ],
  "LSTMForecaster": {
    "__init__": [
      "self",
      "past_seq_len",
      "input_feature_num",
      "output_feature_num",
      "hidden_dim",
      "layer_num",
      "normalization",
      "decomposition_kernel_size",
      "dropout",
      "optimizer",
      "loss",
      "lr",
      "metrics",
      "seed",
      "distributed",
      "workers_per_node",
      "distributed_backend"
    ],
    "from_tsdataset": [
      "cls",
      "tsdataset",
      "past_seq_len"
    ]
  },
  "AutoformerForecaster": {
    "__init__": [
      "self",
      "past_seq_len",
      "future_seq_len",
      "input_feature_num",
      "output_feature_num",
      "freq",
      "label_len",
      "output_attention",
      "moving_avg",
      "d_model",
      "embed",
      "dropout",
      "factor",
      "n_head",
      "d_ff",
      "activation",
      "e_layers",
      "d_layers",
      "optimizer",
      "loss",
      "lr",
      "lr_scheduler_milestones",
      "metrics",
      "seed",
      "distributed",
      "workers_per_node",
      "distributed_backend"
    ],
    "_build_automodel": [
      "self",
      "data",
      "validation_data",
      "batch_size",
      "epochs"
    ],
    "tune": [
      "self",
      "data",
      "validation_data",
      "target_metric",
      "direction",
      "directions",
      "n_trials",
      "n_parallels",
      "epochs",
      "batch_size",
      "acceleration",
      "input_sample"
    ],
    "search_summary": [
      "self"
    ],
    "fit": [
      "self",
      "data",
      "validation_data",
      "epochs",
      "batch_size",
      "validation_mode",
      "earlystop_patience",
      "use_trial_id"
    ],
    "get_context": [
      "self",
      "thread_num"
    ],
    "predict": [
      "self",
      "data",
      "batch_size"
    ],
    "evaluate": [
      "self",
      "data",
      "batch_size"
    ],
    "predict_interval": [
      "self",
      "data",
      "validation_data",
      "batch_size",
      "repetition_times"
    ],
    "get_model": [
      "self"
    ],
    "load": [
      "self",
      "checkpoint_file"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "from_tsdataset": [
      "cls",
      "tsdataset",
      "past_seq_len",
      "future_seq_len",
      "label_len",
      "freq"
    ]
  },
  "_str2metric": [
    "metric"
  ],
  "_timedelta_to_delta_str": [
    "offset"
  ],
  "TCNForecaster": {
    "__init__": [
      "self",
      "past_seq_len",
      "future_seq_len",
      "input_feature_num",
      "output_feature_num",
      "dummy_encoder",
      "num_channels",
      "kernel_size",
      "normalization",
      "decomposition_kernel_size",
      "repo_initialization",
      "dropout",
      "optimizer",
      "loss",
      "lr",
      "metrics",
      "seed",
      "distributed",
      "workers_per_node",
      "distributed_backend"
    ]
  },
  "Seq2SeqForecaster": {
    "__init__": [
      "self",
      "past_seq_len",
      "future_seq_len",
      "input_feature_num",
      "output_feature_num",
      "lstm_hidden_dim",
      "lstm_layer_num",
      "teacher_forcing",
      "normalization",
      "decomposition_kernel_size",
      "dropout",
      "optimizer",
      "loss",
      "lr",
      "metrics",
      "seed",
      "distributed",
      "workers_per_node",
      "distributed_backend"
    ]
  },
  "TCMFForecaster": {
    "__init__": [
      "self",
      "vbsize",
      "hbsize",
      "num_channels_X",
      "num_channels_Y",
      "kernel_size",
      "dropout",
      "rank",
      "kernel_size_Y",
      "learning_rate",
      "normalize",
      "use_time",
      "svd"
    ],
    "fit": [
      "self",
      "x",
      "val_len",
      "start_date",
      "freq",
      "covariates",
      "dti",
      "period",
      "y_iters",
      "init_FX_epoch",
      "max_FX_epoch",
      "max_TCN_epoch",
      "alt_iters",
      "num_workers"
    ],
    "fit_incremental": [
      "self",
      "x_incr",
      "covariates_incr",
      "dti_incr"
    ],
    "evaluate": [
      "self",
      "target_value",
      "metric",
      "target_covariates",
      "target_dti",
      "num_workers"
    ],
    "predict": [
      "self",
      "horizon",
      "future_covariates",
      "future_dti",
      "num_workers"
    ],
    "save": [
      "self",
      "path"
    ],
    "is_xshards_distributed": [
      "self"
    ],
    "load": [
      "cls",
      "path",
      "is_xshards_distributed",
      "minPartitions"
    ]
  },
  "NBeatsForecaster": {
    "__init__": [
      "self",
      "past_seq_len",
      "future_seq_len",
      "stack_types",
      "nb_blocks_per_stack",
      "thetas_dim",
      "share_weights_in_stack",
      "hidden_layer_units",
      "nb_harmonics",
      "optimizer",
      "loss",
      "lr",
      "metrics",
      "seed",
      "distributed",
      "workers_per_node",
      "distributed_backend"
    ],
    "from_tsdataset": [
      "cls",
      "tsdataset",
      "past_seq_len",
      "future_seq_len"
    ]
  },
  "__all__": [],
  "loader_to_creator": [
    "loader"
  ],
  "np_to_creator": [
    "data"
  ],
  "set_pytorch_seed": [
    "seed"
  ],
  "xshard_to_np": [
    "shard",
    "mode",
    "expand_dim"
  ],
  "xshard_expand_dim": [
    "yhat",
    "expand_dim"
  ],
  "np_to_xshard": [
    "x",
    "workers_num",
    "prefix"
  ],
  "check_data": [
    "x",
    "y",
    "data_config"
  ],
  "check_transformer_data": [
    "x",
    "y",
    "x_enc",
    "y_enc",
    "data_config"
  ],
  "np_to_dataloader": [
    "data",
    "batch_size",
    "num_processes"
  ],
  "tsdataset_to_dataloader": [
    "data",
    "batch_size",
    "lookback",
    "horizon",
    "num_processes"
  ],
  "dataloader_batch_resize": [
    "data",
    "batch_size",
    "num_processes"
  ],
  "read_csv": [
    "filename",
    "loss_name"
  ],
  "delete_folder": [
    "path"
  ],
  "is_main_process": [],
  "ExportForecastingPipeline": {
    "__init__": [
      "self",
      "preprocess",
      "inference",
      "postprocess"
    ],
    "forward": [
      "self",
      "data"
    ]
  },
  "get_exported_module": [
    "tsdata",
    "forecaster_path",
    "drop_dt_col"
  ],
  "set_pytorch_thread": [
    "optimized_model_thread_num",
    "thread_num"
  ],
  "BasePytorchForecaster": {
    "__init__": [
      "self"
    ],
    "_build_automodel": [
      "self",
      "data",
      "validation_data",
      "batch_size",
      "epochs"
    ],
    "tune": [
      "self",
      "data",
      "validation_data",
      "target_metric",
      "direction",
      "directions",
      "n_trials",
      "n_parallels",
      "epochs",
      "batch_size",
      "acceleration",
      "input_sample"
    ],
    "search_summary": [
      "self"
    ],
    "fit": [
      "self",
      "data",
      "validation_data",
      "epochs",
      "batch_size",
      "validation_mode",
      "earlystop_patience",
      "use_trial_id"
    ],
    "optimize": [
      "self",
      "train_data",
      "validation_data",
      "batch_size",
      "thread_num",
      "accelerator",
      "precision",
      "metric",
      "accuracy_criterion"
    ],
    "get_context": [
      "self",
      "thread_num",
      "optimize"
    ],
    "predict": [
      "self",
      "data",
      "batch_size",
      "quantize",
      "acceleration"
    ],
    "predict_with_onnx": [
      "self",
      "data",
      "batch_size",
      "quantize"
    ],
    "predict_with_openvino": [
      "self",
      "data",
      "batch_size",
      "quantize"
    ],
    "predict_with_jit": [
      "self",
      "data",
      "batch_size",
      "quantize"
    ],
    "evaluate": [
      "self",
      "data",
      "batch_size",
      "multioutput",
      "quantize",
      "acceleration"
    ],
    "evaluate_with_onnx": [
      "self",
      "data",
      "batch_size",
      "multioutput",
      "quantize"
    ],
    "predict_interval": [
      "self",
      "data",
      "validation_data",
      "batch_size",
      "repetition_times"
    ],
    "save": [
      "self",
      "checkpoint_file",
      "quantize_checkpoint_file"
    ],
    "load": [
      "self",
      "checkpoint_file",
      "quantize_checkpoint_file"
    ],
    "to_local": [
      "self"
    ],
    "get_model": [
      "self"
    ],
    "build_onnx": [
      "self",
      "thread_num",
      "sess_options"
    ],
    "build_openvino": [
      "self",
      "thread_num"
    ],
    "build_jit": [
      "self",
      "thread_num",
      "use_ipex"
    ],
    "export_onnx_file": [
      "self",
      "dirname",
      "quantized_dirname"
    ],
    "export_openvino_file": [
      "self",
      "dirname",
      "quantized_dirname"
    ],
    "export_torchscript_file": [
      "self",
      "dirname",
      "quantized_dirname",
      "save_pipeline",
      "tsdata",
      "drop_dt_col"
    ],
    "quantize": [
      "self",
      "calib_data",
      "val_data",
      "metric",
      "conf",
      "framework",
      "approach",
      "tuning_strategy",
      "relative_drop",
      "absolute_drop",
      "timeout",
      "max_trials",
      "sess_options",
      "thread_num"
    ],
    "from_tsdataset": [
      "cls",
      "tsdataset",
      "past_seq_len",
      "future_seq_len"
    ]
  },
  "_str2optimizer_metric": [
    "metric"
  ],
  "Disablelogging": {
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "torch_available": [],
  "tf_available": [],
  "prophet_available": [],
  "arima_available": [],
  "orca_available": [],
  "PREFIXNAME": [],
  "TFParkForecaster": {
    "__init__": [
      "self"
    ],
    "_build": [
      "self"
    ]
  },
  "GenericLightningModule": {
    "__init__": [
      "self",
      "model_creator",
      "optim_creator",
      "loss_creator",
      "data",
      "validation_data",
      "batch_size",
      "epochs",
      "metrics",
      "scheduler",
      "num_processes",
      "model_config_keys",
      "data_config_keys",
      "optim_config_keys",
      "loss_config_keys"
    ],
    "_get_config_by_keys": [
      "keys",
      "config"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "test_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ]
  },
  "GenericTSTransformerLightningModule": {
    "__init__": [
      "self",
      "model_creator",
      "loss_creator",
      "data",
      "validation_data",
      "batch_size",
      "epochs",
      "metrics",
      "scheduler",
      "num_processes",
      "model_config_keys",
      "data_config_keys",
      "optim_config_keys",
      "loss_config_keys"
    ],
    "_get_config_by_keys": [
      "keys",
      "config"
    ],
    "forward": [
      "self"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "test_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "train_dataloader": [
      "self"
    ],
    "val_dataloader": [
      "self"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "_check_duplicate_metrics": [
    "metrics"
  ],
  "_format_metric": [
    "prefix",
    "metric",
    "id"
  ],
  "_format_metric_str": [
    "prefix",
    "metric"
  ],
  "_config_has_search_space": [
    "config"
  ],
  "Forecaster": {
    "fit": [
      "self"
    ],
    "evaluate": [
      "self"
    ],
    "predict": [
      "self"
    ]
  },
  "ProphetForecaster": {
    "__init__": [
      "self",
      "changepoint_prior_scale",
      "seasonality_prior_scale",
      "holidays_prior_scale",
      "seasonality_mode",
      "changepoint_range",
      "metric"
    ],
    "fit": [
      "self",
      "data",
      "validation_data"
    ],
    "_check_data": [
      "self",
      "data",
      "validation_data"
    ],
    "predict": [
      "self",
      "horizon",
      "freq",
      "ds_data"
    ],
    "evaluate": [
      "self",
      "data",
      "metrics"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ]
  },
  "ARIMAForecaster": {
    "__init__": [
      "self",
      "p",
      "q",
      "seasonality_mode",
      "P",
      "Q",
      "m",
      "metric"
    ],
    "fit": [
      "self",
      "data",
      "validation_data"
    ],
    "_check_data": [
      "self",
      "data",
      "validation_data"
    ],
    "predict": [
      "self",
      "horizon",
      "rolling"
    ],
    "evaluate": [
      "self",
      "validation_data",
      "metrics",
      "rolling"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ]
  },
  "MTNetForecaster": {
    "__init__": [
      "self",
      "target_dim",
      "feature_dim",
      "long_series_num",
      "series_length",
      "ar_window_size",
      "cnn_height",
      "cnn_hid_size",
      "rnn_hid_sizes",
      "lr",
      "loss",
      "cnn_dropout",
      "rnn_dropout",
      "metric",
      "uncertainty"
    ],
    "fit": [
      "self",
      "data",
      "epochs",
      "batch_size",
      "validation_data"
    ],
    "predict": [
      "self",
      "data",
      "batch_size"
    ],
    "evaluate": [
      "self",
      "data",
      "metric",
      "batch_size",
      "multioutput"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "load": [
      "self",
      "checkpoint_file"
    ]
  },
  "np_to_data_creator": [
    "tuple_data",
    "shuffle"
  ],
  "tsdata_to_data_creator": [
    "tf_data",
    "shuffle"
  ],
  "np_to_tfdataset": [
    "tuple_data",
    "shuffle",
    "batch_size"
  ],
  "np_to_xshards": [
    "data",
    "workers_num"
  ],
  "BaseTF2Forecaster": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "data",
      "epochs",
      "batch_size"
    ],
    "quantize": [
      "self",
      "input_data",
      "target_data",
      "metric",
      "conf",
      "framework",
      "approach",
      "tuning_strategy",
      "relative_drop",
      "absolute_drop",
      "timeout",
      "max_trials",
      "sess_options",
      "thread_num"
    ],
    "predict": [
      "self",
      "data",
      "batch_size",
      "quantize"
    ],
    "evaluate": [
      "self",
      "data",
      "batch_size",
      "multioutput",
      "quantize"
    ],
    "to_local": [
      "self"
    ],
    "get_model": [
      "self"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "load": [
      "self",
      "checkpoint_file"
    ],
    "from_tsdataset": [
      "cls",
      "tsdataset",
      "past_seq_len",
      "future_seq_len"
    ]
  },
  "tf_spec": [],
  "PREFIXNAME_TF2": [],
  "_tensor_inference": [
    "model",
    "input_sample_list",
    "batch_size"
  ],
  "_numpy_inference": [
    "model",
    "input_sample_list",
    "batch_size"
  ],
  "_pytorch_fashion_inference": [
    "model",
    "input_data",
    "batch_size",
    "output_tensor"
  ],
  "DummyForecasterContextManager": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "exc_tb"
    ]
  },
  "ForecasterContextManager": {
    "__init__": [
      "self",
      "forecaster",
      "thread_num",
      "optimize"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "exc_tb"
    ]
  },
  "AsymWeightLoss": {
    "__init__": [
      "self",
      "underestimation_penalty",
      "L1"
    ],
    "forward": [
      "self",
      "y_hat",
      "y"
    ]
  },
  "LinexLoss": {
    "__init__": [
      "self",
      "a"
    ],
    "forward": [
      "self",
      "y_hat",
      "y"
    ]
  },
  "NormalizeTSModel": {
    "__init__": [
      "self",
      "model",
      "output_feature_dim"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "moving_avg": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "series_decomp": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DecompositionTSModel": {
    "__init__": [
      "self",
      "models",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MODEL_PATH": [],
  "FEATURE_OUTPUT": [],
  "ATTRIBUTE_OUTPUT": [],
  "DPGANSimulator": {
    "__init__": [
      "self",
      "L_max",
      "sample_len",
      "feature_dim",
      "num_real_attribute",
      "discriminator_num_layers",
      "discriminator_num_units",
      "attr_discriminator_num_layers",
      "attr_discriminator_num_units",
      "attribute_num_units",
      "attribute_num_layers",
      "feature_num_units",
      "feature_num_layers",
      "attribute_input_noise_dim",
      "addi_attribute_input_noise_dim",
      "d_gp_coe",
      "attr_d_gp_coe",
      "g_attr_d_coe",
      "d_lr",
      "attr_d_lr",
      "g_lr",
      "g_rounds",
      "d_rounds",
      "seed",
      "num_threads",
      "ckpt_dir",
      "checkpoint_every_n_epoch"
    ],
    "fit": [
      "self",
      "data_feature",
      "data_attribute",
      "data_gen_flag",
      "feature_outputs",
      "attribute_outputs",
      "epoch",
      "batch_size"
    ],
    "generate": [
      "self",
      "sample_num",
      "batch_size"
    ],
    "save": [
      "self",
      "path_dir"
    ],
    "load": [
      "self",
      "path_dir",
      "model_version"
    ]
  },
  "DoppelGANger_pl": {
    "__init__": [
      "self",
      "data_feature_outputs",
      "data_attribute_outputs",
      "L_max",
      "num_real_attribute",
      "sample_len",
      "discriminator_num_layers",
      "discriminator_num_units",
      "attr_discriminator_num_layers",
      "attr_discriminator_num_units",
      "attribute_num_units",
      "attribute_num_layers",
      "feature_num_units",
      "feature_num_layers",
      "attribute_input_noise_dim",
      "addi_attribute_input_noise_dim",
      "d_gp_coe",
      "attr_d_gp_coe",
      "g_attr_d_coe",
      "d_lr",
      "attr_d_lr",
      "g_lr",
      "g_rounds",
      "d_rounds"
    ],
    "forward": [
      "self",
      "data_feature",
      "real_attribute_input_noise",
      "addi_attribute_input_noise",
      "feature_input_noise",
      "data_attribute"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ],
    "sample_from": [
      "self",
      "real_attribute_input_noise",
      "addi_attribute_input_noise",
      "feature_input_noise",
      "feature_input_data",
      "batch_size"
    ]
  },
  "EPS": [],
  "doppelganger_loss": [
    "d_fake",
    "attr_d_fake",
    "d_real",
    "attr_d_real",
    "g_attr_d_coe",
    "gradient_penalty",
    "discriminator",
    "attr_discriminator",
    "g_output_feature_train_tf",
    "g_output_attribute_train_tf",
    "real_feature_pl",
    "real_attribute_pl",
    "d_gp_coe",
    "attr_d_gp_coe"
  ],
  "Discriminator": {
    "__init__": [
      "self",
      "input_size",
      "num_layers",
      "num_units"
    ],
    "forward": [
      "self",
      "input_feature",
      "input_attribute"
    ]
  },
  "AttrDiscriminator": {
    "__init__": [
      "self",
      "input_size",
      "num_layers",
      "num_units"
    ],
    "forward": [
      "self",
      "input_attribute"
    ]
  },
  "RNNInitialStateType": {
    "ZERO": [],
    "RANDOM": [],
    "VARIABLE": []
  },
  "DoppelGANgerGenerator": {
    "__init__": [
      "self",
      "feed_back",
      "noise",
      "feature_outputs",
      "attribute_outputs",
      "real_attribute_mask",
      "sample_len",
      "attribute_num_units",
      "attribute_num_layers",
      "feature_num_units",
      "feature_num_layers",
      "attribute_input_noise_dim",
      "addi_attribute_input_noise_dim",
      "feature_input_noise_dim",
      "attribute_dim",
      "initial_state",
      "initial_stddev"
    ],
    "_post_process_generated_attribute": [
      "self",
      "sub_attribute_output",
      "sub_all_attribute_outputs"
    ],
    "forward": [
      "self",
      "attribute_input_noise",
      "addi_attribute_input_noise",
      "feature_input_noise",
      "feature_input_data",
      "attribute"
    ]
  },
  "DoppelGANgerDataModule": {
    "__init__": [
      "self",
      "sample_len",
      "real_data",
      "feature_outputs",
      "attribute_outputs",
      "batch_size"
    ],
    "train_dataloader": [
      "self"
    ]
  },
  "CustomizedDataset": {
    "__init__": [
      "self",
      "data_feature",
      "data_attribute"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "linear": {
    "__init__": [
      "self",
      "input_size",
      "output_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "flatten": [
    "x"
  ],
  "DoppelGANger": {
    "__init__": [
      "self",
      "data_feature_outputs",
      "data_attribute_outputs",
      "real_attribute_mask",
      "sample_len",
      "L_max",
      "num_packing",
      "discriminator_num_layers",
      "discriminator_num_units",
      "attr_discriminator_num_layers",
      "attr_discriminator_num_units",
      "attribute_num_units",
      "attribute_num_layers",
      "feature_num_units",
      "feature_num_layers",
      "attribute_input_noise_dim",
      "addi_attribute_input_noise_dim",
      "initial_state"
    ],
    "forward": [
      "self",
      "data_feature",
      "real_attribute_input_noise",
      "addi_attribute_input_noise",
      "feature_input_noise",
      "data_attribute"
    ],
    "sample_from": [
      "self",
      "real_attribute_input_noise",
      "addi_attribute_input_noise",
      "feature_input_noise",
      "feature_input_data",
      "gen_flag_dims",
      "batch_size"
    ]
  },
  "renormalize_per_sample": [
    "data_feature",
    "data_attribute",
    "data_feature_outputs",
    "data_attribute_outputs",
    "gen_flags",
    "num_real_attribute"
  ],
  "normalize_per_sample": [
    "data_feature",
    "data_attribute",
    "data_feature_outputs",
    "data_attribute_outputs",
    "eps"
  ],
  "add_gen_flag": [
    "data_feature",
    "data_gen_flag",
    "data_feature_outputs",
    "sample_len"
  ],
  "gen_attribute_input_noise": [
    "num_sample",
    "latent_dim"
  ],
  "gen_feature_input_noise": [
    "num_sample",
    "length",
    "latent_dim"
  ],
  "gen_feature_input_data_free": [
    "num_sample",
    "sample_len",
    "sample_feature_dim"
  ],
  "OutputType": {
    "CONTINUOUS": [],
    "DISCRETE": []
  },
  "Normalization": {
    "ZERO_ONE": [],
    "MINUSONE_ONE": []
  },
  "Output": {
    "__init__": [
      "self",
      "type_",
      "dim",
      "normalization",
      "is_gen_flag"
    ]
  },
  "get_public_dataset": [
    "name",
    "path",
    "redownload"
  ],
  "gen_synthetic_data": [
    "len",
    "sine_amplitude",
    "angular_freq",
    "noise_amplitude",
    "noise_scale",
    "seed",
    "time_freq"
  ],
  "_DEFAULT_ID_COL_NAME": [],
  "_DEFAULT_ID_PLACEHOLDER": [],
  "TSDataset": {
    "__init__": [
      "self",
      "data",
      "repair"
    ],
    "from_pandas": [
      "df",
      "dt_col",
      "target_col",
      "id_col",
      "extra_feature_col",
      "with_split",
      "val_ratio",
      "test_ratio",
      "repair",
      "deploy_mode"
    ],
    "from_parquet": [
      "path",
      "dt_col",
      "target_col",
      "id_col",
      "extra_feature_col",
      "with_split",
      "val_ratio",
      "test_ratio",
      "repair",
      "deploy_mode"
    ],
    "from_prometheus": [
      "prometheus_url",
      "query",
      "starttime",
      "endtime",
      "step",
      "target_col",
      "id_col",
      "extra_feature_col",
      "with_split",
      "val_ratio",
      "test_ratio",
      "repair",
      "deploy_mode"
    ],
    "impute": [
      "self",
      "mode",
      "const_num"
    ],
    "deduplicate": [
      "self"
    ],
    "resample": [
      "self",
      "interval",
      "start_time",
      "end_time",
      "merge_mode"
    ],
    "repair_abnormal_data": [
      "self",
      "mode",
      "threshold"
    ],
    "gen_dt_feature": [
      "self",
      "features",
      "one_hot_features"
    ],
    "gen_global_feature": [
      "self",
      "settings",
      "full_settings",
      "n_jobs"
    ],
    "gen_rolling_feature": [
      "self",
      "window_size",
      "settings",
      "full_settings",
      "n_jobs"
    ],
    "roll": [
      "self",
      "horizon",
      "lookback",
      "feature_col",
      "target_col",
      "id_sensitive",
      "time_enc",
      "label_len",
      "is_predict"
    ],
    "to_torch_data_loader": [
      "self",
      "batch_size",
      "roll",
      "lookback",
      "horizon",
      "feature_col",
      "target_col",
      "shuffle",
      "time_enc",
      "label_len",
      "is_predict"
    ],
    "to_tf_dataset": [
      "self",
      "batch_size",
      "shuffle"
    ],
    "to_numpy": [
      "self"
    ],
    "to_pandas": [
      "self"
    ],
    "scale": [
      "self",
      "scaler",
      "fit"
    ],
    "unscale": [
      "self"
    ],
    "unscale_numpy": [
      "self",
      "data"
    ],
    "_check_basic_invariants": [
      "self",
      "strict_check"
    ],
    "get_cycle_length": [
      "self",
      "aggregate",
      "top_k"
    ],
    "export_jit": [
      "self",
      "path_dir",
      "drop_dt_col"
    ]
  },
  "XShardsTSDataset": {
    "__init__": [
      "self",
      "shards"
    ],
    "from_xshards": [
      "shards",
      "dt_col",
      "target_col",
      "id_col",
      "extra_feature_col",
      "with_split",
      "val_ratio",
      "test_ratio"
    ],
    "from_sparkdf": [
      "df",
      "dt_col",
      "target_col",
      "id_col",
      "extra_feature_col",
      "with_split",
      "val_ratio",
      "test_ratio"
    ],
    "roll": [
      "self",
      "lookback",
      "horizon",
      "feature_col",
      "target_col",
      "id_sensitive"
    ],
    "scale": [
      "self",
      "scaler",
      "fit"
    ],
    "unscale": [
      "self"
    ],
    "gen_dt_feature": [
      "self",
      "features"
    ],
    "unscale_xshards": [
      "self",
      "data",
      "key"
    ],
    "impute": [
      "self",
      "mode",
      "const_num"
    ],
    "to_xshards": [
      "self",
      "partition_num"
    ]
  },
  "add_row": [
    "df",
    "name",
    "const_num"
  ],
  "transform_to_dict": [
    "data"
  ],
  "roll_timeseries_dataframe": [
    "df",
    "roll_feature_df",
    "lookback",
    "horizon",
    "feature_col",
    "target_col",
    "id_col",
    "label_len",
    "contain_id",
    "deploy_mode"
  ],
  "_append_rolling_feature_df": [
    "rolling_result",
    "roll_feature_df"
  ],
  "_roll_timeseries_dataframe_test": [
    "df",
    "roll_feature_df",
    "lookback",
    "feature_col",
    "target_col",
    "id_col",
    "contain_id"
  ],
  "_roll_timeseries_dataframe_train": [
    "df",
    "roll_feature_df",
    "lookback",
    "horizon",
    "feature_col",
    "target_col",
    "id_col",
    "label_len",
    "contain_id"
  ],
  "_shift": [
    "arr",
    "num",
    "fill_value"
  ],
  "_roll_timeseries_ndarray": [
    "data",
    "window"
  ],
  "_is_awake": [
    "hour"
  ],
  "_is_busy_hours": [
    "hour"
  ],
  "_is_weekend": [
    "weekday"
  ],
  "TIME_FEATURE": [],
  "ADDITIONAL_TIME_FEATURE_HOUR": [],
  "ADDITIONAL_TIME_FEATURE_WEEKDAY": [],
  "FEATURE_INTERVAL": [],
  "FEATURE_BIN_NUM": [],
  "_one_hot_encode_helper": [
    "df",
    "class_name",
    "class_range",
    "features_generated"
  ],
  "generate_dt_features": [
    "input_df",
    "dt_col",
    "features",
    "one_hot_features",
    "freq",
    "features_generated"
  ],
  "generate_global_features": [
    "input_df",
    "column_id",
    "column_sort",
    "default_fc_parameters",
    "kind_to_fc_parameters",
    "n_jobs"
  ],
  "ExportJIT": {
    "__init__": [
      "self",
      "lookback",
      "id_index",
      "target_feature_index",
      "operation"
    ],
    "_shift": [
      "self",
      "data",
      "i"
    ],
    "_groupby": [
      "self",
      "data",
      "colunm"
    ],
    "_roll_tensor": [
      "self",
      "data",
      "lookback",
      "target_feature_index"
    ],
    "roll": [
      "self",
      "data",
      "lookback",
      "id_index",
      "target_feature_index"
    ],
    "scale": [
      "self",
      "data"
    ],
    "unscale": [
      "self",
      "data"
    ],
    "export_preprocessing": [
      "self",
      "data"
    ],
    "export_postprocessing": [
      "self",
      "data"
    ],
    "forward": [
      "self",
      "data"
    ]
  },
  "ExportWithStandardScaler": {
    "__init__": [
      "self",
      "scaler",
      "lookback",
      "id_index",
      "target_feature_index",
      "scaler_index",
      "operation"
    ],
    "scale": [
      "self",
      "data"
    ],
    "unscale": [
      "self",
      "data"
    ]
  },
  "ExporWithMaxAbsScaler": {
    "__init__": [
      "self",
      "scaler",
      "lookback",
      "id_index",
      "target_feature_index",
      "scaler_index",
      "operation"
    ],
    "scale": [
      "self",
      "data"
    ],
    "unscale": [
      "self",
      "data"
    ]
  },
  "ExportWithMinMaxScaler": {
    "__init__": [
      "self",
      "scaler",
      "lookback",
      "id_index",
      "target_feature_index",
      "scaler_index",
      "operation"
    ],
    "scale": [
      "self",
      "data"
    ],
    "unscale": [
      "self",
      "data"
    ]
  },
  "ExportWithRobustScaler": {
    "__init__": [
      "self",
      "scaler",
      "lookback",
      "id_index",
      "target_feature_index",
      "scaler_index",
      "operation"
    ],
    "scale": [
      "self",
      "data"
    ],
    "unscale": [
      "self",
      "data"
    ]
  },
  "SCALE_JIT_HELPER_MAP": [],
  "export_processing_to_jit": [
    "scaler",
    "lookback",
    "id_index",
    "target_feature_index",
    "scaler_index",
    "operation"
  ],
  "get_index": [
    "df",
    "id_col",
    "target_col",
    "feature_col"
  ],
  "get_processing_module_instance": [
    "scaler",
    "lookback",
    "id_index",
    "target_feature_index",
    "scaler_index",
    "operation"
  ],
  "resample_timeseries_dataframe": [
    "df",
    "dt_col",
    "interval",
    "start_time",
    "end_time",
    "id_col",
    "merge_mode",
    "deploy_mode"
  ],
  "logger": [],
  "ch": [],
  "formatter": [],
  "DATASET_NAME": [],
  "BASE_URL": [],
  "PublicDataset": {
    "__init__": [
      "self",
      "name",
      "path",
      "redownload"
    ],
    "get_public_data": [
      "self",
      "chunk_size"
    ],
    "preprocess_network_traffic": [
      "self"
    ],
    "preprocess_AIOps": [
      "self"
    ],
    "preprocess_fsi": [
      "self"
    ],
    "preprocess_nyc_taxi": [
      "self"
    ],
    "preprocess_uci_electricity": [
      "self"
    ],
    "preprocess_uci_electricity_wide": [
      "self"
    ],
    "preprocess_tsinghua_electricity": [
      "self"
    ],
    "get_tsdata": [
      "self",
      "dt_col",
      "target_col",
      "extra_feature",
      "id_col",
      "repair"
    ]
  },
  "download": [
    "url",
    "path",
    "chunk_size"
  ],
  "bytes_convert": [
    "size"
  ],
  "Timestamp": [],
  "Duration": [],
  "Matrix": [],
  "Vector": [],
  "Scalar": [],
  "String": [],
  "Prometheus": {
    "__init__": [
      "self",
      "api_url",
      "http"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "query_range": [
      "self",
      "query",
      "start",
      "end",
      "step",
      "timeout"
    ],
    "_do_query": [
      "self",
      "path",
      "params"
    ]
  },
  "to_pandas": [
    "data"
  ],
  "metric_name": [
    "metric"
  ],
  "_timestamp": [
    "value"
  ],
  "_duration": [
    "value"
  ],
  "GetRangeDataframe": [
    "prometheus_url",
    "query_list",
    "starttime",
    "endtime",
    "step",
    "columns"
  ],
  "deduplicate_timeseries_dataframe": [
    "df",
    "dt_col"
  ],
  "_to_list": [
    "item",
    "name",
    "expect_type",
    "deploy_mode"
  ],
  "_check_type": [
    "item",
    "name",
    "expect_type"
  ],
  "_check_col_within": [
    "df",
    "col_name"
  ],
  "_check_col_no_na": [
    "df",
    "col_name"
  ],
  "_check_cols_no_na": [
    "df",
    "col_names"
  ],
  "_check_is_aligned": [
    "df",
    "id_col",
    "dt_col"
  ],
  "_check_dt_is_sorted": [
    "df",
    "dt_col"
  ],
  "TimeFeature": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "index"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SecondOfMinute": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MinuteOfHour": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "HourOfDay": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfWeek": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfMonth": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "DayOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "MonthOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "WeekOfYear": {
    "__call__": [
      "self",
      "index"
    ]
  },
  "time_features_from_frequency_str": [
    "offset"
  ],
  "time_features": [
    "dates",
    "freq"
  ],
  "gen_time_enc_arr": [
    "df",
    "dt_col",
    "freq",
    "horizon_time",
    "is_predict",
    "lookback",
    "label_len"
  ],
  "get_roll_start_idx": [
    "df",
    "id_col",
    "window_size"
  ],
  "RollDataset": {
    "__init__": [
      "self",
      "df",
      "dt_col",
      "freq",
      "lookback",
      "horizon",
      "feature_col",
      "target_col",
      "id_col",
      "time_enc",
      "label_len",
      "is_predict"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "_standard_scaler_unscale_timeseries_numpy": [
    "data",
    "scaler",
    "scaler_index"
  ],
  "_maxabs_scaler_unscale_timeseries_numpy": [
    "data",
    "scaler",
    "scaler_index"
  ],
  "_minmax_scaler_unscale_timeseries_numpy": [
    "data",
    "scaler",
    "scaler_index"
  ],
  "_robust_scaler_unscale_timeseries_numpy": [
    "data",
    "scaler",
    "scaler_index"
  ],
  "UNSCALE_HELPER_MAP": [],
  "unscale_timeseries_numpy": [
    "data",
    "scaler",
    "scaler_index"
  ],
  "_standard_scaler_scale_timeseries_numpy": [
    "data",
    "scaler"
  ],
  "_maxabs_scaler_scale_timeseries_numpy": [
    "data",
    "scaler"
  ],
  "_minmax_scaler_scale_timeseries_numpy": [
    "data",
    "scaler"
  ],
  "_robust_scaler_scale_timeseries_numpy": [
    "data",
    "scaler"
  ],
  "SCALE_HELPER_MAP": [],
  "scale_timeseries_numpy": [
    "data",
    "scaler"
  ],
  "split_timeseries_dataframe": [
    "df",
    "id_col",
    "val_ratio",
    "test_ratio",
    "look_back",
    "horizon"
  ],
  "split_single_timeseries_dataframe": [
    "df",
    "val_ratio",
    "test_ratio",
    "look_back",
    "horizon"
  ],
  "quality_check_timeseries_dataframe": [
    "df",
    "dt_col",
    "id_col",
    "repair"
  ],
  "_timestamp_type_check": [
    "df_column"
  ],
  "_timestamp_type_repair": [
    "df",
    "dt_col"
  ],
  "_time_interval_check": [
    "df",
    "dt_col",
    "id_col"
  ],
  "_time_interval_repair": [
    "df",
    "dt_col",
    "intervals",
    "id_col"
  ],
  "_missing_value_check": [
    "df",
    "dt_col",
    "threshold"
  ],
  "_missing_value_repair": [
    "df",
    "dt_col"
  ],
  "_abnormal_value_check": [
    "df",
    "dt_col",
    "threshold"
  ],
  "_abnormal_value_repair": [
    "df",
    "dt_col",
    "mode",
    "threshold"
  ],
  "_abs_abnormal_value_repair": [
    "df",
    "dt_col",
    "threshold"
  ],
  "_rel_abnormal_value_repair": [
    "df",
    "dt_col",
    "threshold"
  ],
  "parquet2pd": [
    "path",
    "columns"
  ],
  "impute_timeseries_dataframe": [
    "df",
    "dt_col",
    "mode",
    "const_num"
  ],
  "_last_impute_timeseries_dataframe": [
    "df"
  ],
  "_const_impute_timeseries_dataframe": [
    "df",
    "const_num"
  ],
  "_linear_impute_timeseries_dataframe": [
    "df",
    "dt_col"
  ],
  "cycle_length_est": [
    "data",
    "top_k",
    "adjust"
  ],
  "acf": [
    "x",
    "lag",
    "adjust"
  ],
  "sklearn_install_check": [],
  "INTEL_EXT_DBSCAN": {
    "__slots__": [],
    "__init__": [
      "self",
      "use_sklearnex",
      "algorithm_list"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "roll_arr": [
    "arr",
    "stride"
  ],
  "scale_arr": [
    "arr",
    "mode"
  ],
  "Distance": {
    "abs_dist": [
      "self",
      "x",
      "y"
    ]
  },
  "EuclideanDistance": {
    "__init__": [
      "self"
    ],
    "abs_dist": [
      "self",
      "x",
      "y"
    ]
  },
  "estimate_pattern_th": [
    "y",
    "yhat",
    "mode",
    "ratio",
    "dist_measure"
  ],
  "estimate_trend_th": [
    "y",
    "mode",
    "ratio"
  ],
  "detect_pattern_anomaly": [
    "y",
    "yhat",
    "th",
    "dist_measure"
  ],
  "detect_trend_anomaly": [
    "y",
    "th"
  ],
  "detect_trend_anomaly_arr": [
    "y",
    "th_arr"
  ],
  "detect_anomaly": [
    "y",
    "yhat",
    "pattern_th",
    "trend_th",
    "dist_measure"
  ],
  "ThresholdDetector": {
    "__init__": [
      "self"
    ],
    "set_params": [
      "self",
      "mode",
      "ratio",
      "pattern_threshold",
      "trend_threshold",
      "dist_measure"
    ],
    "fit": [
      "self",
      "y",
      "y_pred"
    ],
    "score": [
      "self",
      "y",
      "y_pred"
    ],
    "anomaly_indexes": [
      "self",
      "y",
      "y_pred"
    ]
  },
  "create_tf_model": [
    "compress_rate",
    "input_dim",
    "optimizer",
    "loss",
    "lr"
  ],
  "create_torch_model": [
    "compress_rate",
    "input_dim"
  ],
  "AEDetector": {
    "__init__": [
      "self",
      "roll_len",
      "ratio",
      "compress_rate",
      "batch_size",
      "epochs",
      "verbose",
      "sub_scalef",
      "backend",
      "lr"
    ],
    "check_rolled": [
      "self",
      "arr"
    ],
    "check_data": [
      "self",
      "arr"
    ],
    "fit": [
      "self",
      "y"
    ],
    "score": [
      "self"
    ],
    "anomaly_indexes": [
      "self"
    ]
  },
  "DBScanDetector": {
    "__init__": [
      "self",
      "eps",
      "min_samples"
    ],
    "check_data": [
      "self",
      "arr"
    ],
    "fit": [
      "self",
      "y",
      "use_sklearnex"
    ],
    "score": [
      "self"
    ],
    "anomaly_indexes": [
      "self"
    ]
  },
  "AnomalyDetector": {
    "fit": [
      "self",
      "y"
    ],
    "score": [
      "self"
    ],
    "anomaly_indexes": [
      "self"
    ]
  },
  "recalculate_n_sampling": [
    "search_space",
    "n_sampling"
  ],
  "check_quantize_available": [
    "model"
  ],
  "preprocess_quantize_data": [
    "self",
    "data"
  ],
  "AutoTSEstimator": [],
  "TSPipeline": [],
  "torch": [],
  "DEFAULT_MODEL_INIT_DIR": [],
  "DEFAULT_BEST_MODEL_DIR": [],
  "DEFAULT_DATA_PROCESS_DIR": [],
  "DEFAULT_BEST_CONFIG_DIR": [],
  "AutoTSTrainer": {
    "__init__": [
      "self",
      "horizon",
      "dt_col",
      "target_col",
      "logs_dir",
      "extra_features_col",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params",
      "name"
    ],
    "fit": [
      "self",
      "train_df",
      "validation_df",
      "metric",
      "recipe",
      "uncertainty",
      "upload_dir"
    ]
  },
  "NumpyEncoder": {
    "default": [
      "self",
      "obj"
    ]
  },
  "save_config": [
    "file_path",
    "config",
    "replace"
  ],
  "save": [
    "file_path",
    "feature_transformers",
    "model",
    "config"
  ],
  "load_config": [
    "file_path"
  ],
  "restore": [
    "file",
    "feature_transformers",
    "model",
    "config"
  ],
  "ADDITIONAL_TIME_FEATURE": [],
  "TimeSequenceFeatureTransformer": {
    "__init__": [
      "self",
      "future_seq_len",
      "dt_col",
      "target_col",
      "extra_features_col",
      "drop_missing",
      "time_features"
    ],
    "_fit_transform": [
      "self",
      "input_df"
    ],
    "fit_transform": [
      "self",
      "input_df"
    ],
    "_transform": [
      "self",
      "input_df",
      "mode"
    ],
    "transform": [
      "self",
      "input_df",
      "is_train"
    ],
    "_unscale": [
      "self",
      "y"
    ],
    "unscale_uncertainty": [
      "self",
      "y_uncertainty"
    ],
    "_get_y_pred_df": [
      "self",
      "y_pred_dt_df",
      "y_pred_unscale"
    ],
    "post_processing": [
      "self",
      "input_df",
      "y_pred",
      "is_train"
    ],
    "save": [
      "self",
      "file_path",
      "replace"
    ],
    "restore": [
      "self"
    ],
    "get_feature_list": [
      "self"
    ],
    "get_feature_dim": [
      "self"
    ],
    "get_target_dim": [
      "self"
    ],
    "_get_feat_config": [
      "self"
    ],
    "_check_input": [
      "self",
      "input_df",
      "mode"
    ],
    "_roll_data": [
      "self",
      "data",
      "seq_len"
    ],
    "_roll_train": [
      "self",
      "dataframe",
      "past_seq_len",
      "future_seq_len"
    ],
    "_roll_test": [
      "self",
      "dataframe",
      "past_seq_len"
    ],
    "__get_y_pred_dt_df": [
      "self",
      "input_df",
      "past_seq_len"
    ],
    "_get_y_pred_dt_df": [
      "self",
      "input_df",
      "past_seq_len"
    ],
    "_scale": [
      "self",
      "data"
    ],
    "_rearrange_data": [
      "self",
      "input_df"
    ],
    "_generate_features": [
      "self",
      "input_df"
    ],
    "_get_features": [
      "self",
      "input_df",
      "config"
    ],
    "_get_optional_parameters": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ]
  },
  "IdentityTransformer": {
    "__init__": [
      "self",
      "feature_cols",
      "target_col"
    ],
    "fit_transform": [
      "self",
      "input_df"
    ],
    "transform": [
      "self",
      "input_df",
      "is_train"
    ],
    "save": [
      "self",
      "file_path",
      "replace"
    ],
    "restore": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_get_optional_parameters": [
      "self"
    ],
    "post_processing": [
      "self",
      "input_df",
      "y_pred",
      "is_train"
    ]
  },
  "BaseFeatureTransformer": {
    "check_optional_config": [],
    "fit_transform": [
      "self",
      "input_df"
    ],
    "transform": [
      "self",
      "input_df"
    ],
    "save": [
      "self",
      "file_path"
    ],
    "restore": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_get_optional_parameters": [
      "self"
    ],
    "_check_config": [
      "self"
    ]
  },
  "Recipe": {
    "__init__": [
      "self"
    ],
    "search_space": [
      "self"
    ],
    "runtime_params": [
      "self"
    ]
  },
  "SmokeRecipe": {
    "__init__": [
      "self"
    ],
    "search_space": [
      "self"
    ]
  },
  "MTNetSmokeRecipe": {
    "__init__": [
      "self"
    ],
    "search_space": [
      "self"
    ]
  },
  "TCNSmokeRecipe": {
    "__init__": [
      "self"
    ],
    "search_space": [
      "self"
    ]
  },
  "PastSeqParamHandler": {
    "__init__": [
      "self"
    ],
    "get_past_seq_config": [
      "look_back"
    ]
  },
  "GridRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "look_back",
      "epochs",
      "training_iteration"
    ],
    "search_space": [
      "self"
    ]
  },
  "LSTMSeq2SeqRandomRecipe": {
    "__init__": [
      "self",
      "input_feature_num",
      "output_feature_num",
      "future_seq_len",
      "num_rand_samples",
      "epochs",
      "training_iteration",
      "batch_size",
      "lr",
      "lstm_hidden_dim",
      "lstm_layer_num",
      "dropout",
      "teacher_forcing"
    ],
    "_gen_sample_func": [
      "self",
      "ranges",
      "param_name"
    ],
    "search_space": [
      "self"
    ]
  },
  "LSTMGridRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "epochs",
      "training_iteration",
      "look_back",
      "lstm_1_units",
      "lstm_2_units",
      "batch_size"
    ],
    "search_space": [
      "self"
    ]
  },
  "Seq2SeqRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "epochs",
      "training_iteration",
      "look_back",
      "latent_dim",
      "batch_size"
    ],
    "search_space": [
      "self"
    ]
  },
  "MTNetGridRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "epochs",
      "training_iteration",
      "time_step",
      "long_num",
      "cnn_height",
      "cnn_hid_size",
      "ar_size",
      "batch_size"
    ],
    "search_space": [
      "self"
    ]
  },
  "TCNGridRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "training_iteration",
      "batch_size",
      "hidden_size",
      "levels",
      "kernel_size",
      "dropout",
      "lr"
    ],
    "search_space": [
      "self"
    ]
  },
  "RandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "look_back",
      "epochs",
      "reward_metric",
      "training_iteration"
    ],
    "search_space": [
      "self"
    ]
  },
  "BayesRecipe": {
    "__init__": [
      "self",
      "num_samples",
      "look_back",
      "epochs",
      "reward_metric",
      "training_iteration"
    ],
    "search_space": [
      "self"
    ]
  },
  "XgbRegressorGridRandomRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "n_estimators",
      "max_depth",
      "n_jobs",
      "tree_method",
      "random_state",
      "seed",
      "lr",
      "subsample",
      "colsample_bytree",
      "min_child_weight",
      "gamma",
      "reg_alpha",
      "reg_lambda"
    ],
    "search_space": [
      "self"
    ]
  },
  "XgbRegressorSkOptRecipe": {
    "__init__": [
      "self",
      "num_rand_samples",
      "n_estimators_range",
      "max_depth_range",
      "lr",
      "min_child_weight"
    ],
    "search_space": [
      "self"
    ]
  },
  "Pipeline": {
    "evaluate": [
      "self",
      "input_df",
      "metric"
    ],
    "predict": [
      "self",
      "input_df"
    ],
    "save": [
      "self",
      "file"
    ]
  },
  "DEFAULT_PPL_DIR": [],
  "DEFAULT_CONFIG_DIR": [],
  "TimeSequencePipeline": {
    "__init__": [
      "self",
      "model",
      "name"
    ],
    "describe": [
      "self"
    ],
    "fit": [
      "self",
      "input_df",
      "validation_df",
      "mc",
      "epoch_num"
    ],
    "fit_with_fixed_configs": [
      "self",
      "input_df",
      "validation_df",
      "mc"
    ],
    "evaluate": [
      "self",
      "input_df",
      "metrics",
      "multioutput"
    ],
    "predict": [
      "self",
      "input_df"
    ],
    "predict_with_uncertainty": [
      "self",
      "input_df",
      "n_iter"
    ],
    "save": [
      "self",
      "ppl_file"
    ],
    "config_save": [
      "self",
      "config_file"
    ]
  },
  "load_ts_pipeline": [
    "file"
  ],
  "train_val_test_split": [
    "df",
    "val_ratio",
    "test_ratio",
    "look_back",
    "horizon"
  ],
  "LastFill": {
    "__init__": [
      "self"
    ],
    "impute": [
      "self",
      "df"
    ]
  },
  "BaseImputation": {
    "impute": [
      "self",
      "input_df"
    ],
    "save": [
      "self",
      "file_path"
    ],
    "restore": [
      "self"
    ]
  },
  "BaseImpute": {
    "impute": [
      "self",
      "df"
    ],
    "evaluate": [
      "self",
      "df",
      "drop_rate"
    ]
  },
  "LastFillImpute": {
    "__init__": [
      "self"
    ],
    "impute": [
      "self",
      "input_df"
    ],
    "restore": [
      "self"
    ]
  },
  "FillZeroImpute": {
    "impute": [
      "self",
      "input_df"
    ]
  },
  "TimeMergeImputor": {
    "__init__": [
      "self",
      "time_interval",
      "timestamp_column_name",
      "mode"
    ],
    "impute": [
      "self",
      "input_df"
    ]
  },
  "TimeSequencePredictor": {
    "__init__": [
      "self",
      "name",
      "logs_dir",
      "future_seq_len",
      "dt_col",
      "target_col",
      "extra_features_col",
      "drop_missing",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params"
    ],
    "get_model_builder": [
      "self"
    ],
    "_check_missing_col": [
      "self",
      "df"
    ],
    "_check_df": [
      "self",
      "df"
    ]
  },
  "ALLOWED_FIT_METRICS": [],
  "BasePredictor": {
    "__init__": [
      "self",
      "name",
      "logs_dir",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params"
    ],
    "get_model_builder": [
      "self"
    ],
    "_check_df": [
      "self",
      "df"
    ],
    "_check_fit_metric": [
      "metric"
    ],
    "fit": [
      "self",
      "input_df",
      "validation_df",
      "metric",
      "recipe",
      "mc",
      "resources_per_trial",
      "upload_dir"
    ],
    "evaluate": [
      "self",
      "input_df",
      "metric"
    ],
    "predict": [
      "self",
      "input_df"
    ],
    "_detach_recipe": [
      "self",
      "recipe"
    ],
    "_hp_search": [
      "self",
      "input_df",
      "validation_df",
      "metric",
      "recipe",
      "mc",
      "resources_per_trial",
      "remote_dir"
    ]
  },
  "MODEL_MAP": [],
  "TSModelBuilder": {
    "__init__": [
      "self",
      "dt_col",
      "target_cols",
      "future_seq_len",
      "extra_features_col",
      "drop_missing",
      "add_dt_features"
    ],
    "build": [
      "self",
      "config"
    ]
  },
  "TimeSequenceModel": {
    "__init__": [
      "self",
      "feature_transformer"
    ],
    "create": [
      "cls",
      "dt_col",
      "target_cols",
      "future_seq_len",
      "extra_features_col",
      "drop_missing",
      "add_dt_features"
    ],
    "setup": [
      "self",
      "config"
    ],
    "_process_data": [
      "self",
      "data",
      "mode"
    ],
    "fit_eval": [
      "self",
      "data",
      "validation_data"
    ],
    "fit_incr": [
      "self",
      "data",
      "validation_data"
    ],
    "_sel_model": [
      "config",
      "verbose"
    ],
    "evaluate": [
      "self",
      "df",
      "metric"
    ],
    "predict": [
      "self",
      "df"
    ],
    "predict_with_uncertainty": [
      "self",
      "df",
      "n_iter"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_get_optional_parameters": [
      "self"
    ]
  },
  "AutoARIMA": {
    "__init__": [
      "self",
      "p",
      "q",
      "seasonal",
      "P",
      "Q",
      "m",
      "metric",
      "metric_mode",
      "logs_dir",
      "cpus_per_trial",
      "name",
      "remote_dir",
      "load_dir"
    ],
    "fit": [
      "self",
      "data",
      "epochs",
      "validation_data",
      "metric_threshold",
      "n_sampling",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params"
    ],
    "get_best_model": [
      "self"
    ]
  },
  "AutoProphet": {
    "__init__": [
      "self",
      "changepoint_prior_scale",
      "seasonality_prior_scale",
      "holidays_prior_scale",
      "seasonality_mode",
      "changepoint_range",
      "metric",
      "metric_mode",
      "logs_dir",
      "cpus_per_trial",
      "name",
      "remote_dir",
      "load_dir"
    ],
    "fit": [
      "self",
      "data",
      "cross_validation",
      "expect_horizon",
      "freq",
      "metric_threshold",
      "n_sampling",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params"
    ],
    "predict": [
      "self",
      "horizon",
      "freq",
      "ds_data"
    ],
    "evaluate": [
      "self",
      "data",
      "metrics"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ],
    "get_best_model": [
      "self"
    ]
  },
  "BaseAutomodel": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "data",
      "epochs",
      "batch_size",
      "validation_data",
      "metric_threshold",
      "n_sampling",
      "search_alg",
      "search_alg_params",
      "scheduler",
      "scheduler_params"
    ],
    "predict": [
      "self",
      "data",
      "batch_size"
    ],
    "predict_with_onnx": [
      "self",
      "data",
      "batch_size",
      "dirname"
    ],
    "evaluate": [
      "self",
      "data",
      "batch_size",
      "metrics",
      "multioutput"
    ],
    "evaluate_with_onnx": [
      "self",
      "data",
      "batch_size",
      "metrics",
      "dirname",
      "multioutput"
    ],
    "save": [
      "self",
      "checkpoint_path"
    ],
    "load": [
      "self",
      "checkpoint_path"
    ],
    "build_onnx": [
      "self",
      "thread_num",
      "sess_options"
    ],
    "export_onnx_file": [
      "self",
      "dirname"
    ],
    "get_best_model": [
      "self"
    ],
    "get_best_config": [
      "self"
    ],
    "_get_best_automl_model": [
      "self"
    ]
  },
  "AutoLSTM": {
    "__init__": [
      "self",
      "input_feature_num",
      "output_target_num",
      "past_seq_len",
      "optimizer",
      "loss",
      "metric",
      "metric_mode",
      "hidden_dim",
      "layer_num",
      "lr",
      "dropout",
      "backend",
      "logs_dir",
      "cpus_per_trial",
      "name",
      "remote_dir"
    ]
  },
  "AutoSeq2Seq": {
    "__init__": [
      "self",
      "input_feature_num",
      "output_target_num",
      "past_seq_len",
      "future_seq_len",
      "optimizer",
      "loss",
      "metric",
      "metric_mode",
      "lr",
      "lstm_hidden_dim",
      "lstm_layer_num",
      "dropout",
      "teacher_forcing",
      "backend",
      "logs_dir",
      "cpus_per_trial",
      "name",
      "remote_dir"
    ]
  },
  "AutoTCN": {
    "__init__": [
      "self",
      "input_feature_num",
      "output_target_num",
      "past_seq_len",
      "future_seq_len",
      "optimizer",
      "loss",
      "metric",
      "metric_mode",
      "hidden_units",
      "levels",
      "num_channels",
      "kernel_size",
      "lr",
      "dropout",
      "backend",
      "logs_dir",
      "cpus_per_trial",
      "name",
      "remote_dir"
    ]
  },
  "AUTO_MODEL_SUPPORT_LIST": [],
  "AUTO_MODEL_DEFAULT_SEARCH_SPACE": [],
  "AutoModelFactory": {
    "create_auto_model": [
      "name",
      "search_space"
    ],
    "get_default_search_space": [
      "model",
      "computing_resource"
    ]
  },
  "NBeatsNet": {
    "SEASONALITY_BLOCK": [],
    "TREND_BLOCK": [],
    "GENERIC_BLOCK": [],
    "__init__": [
      "self",
      "past_seq_len",
      "future_seq_len",
      "stack_types",
      "nb_blocks_per_stack",
      "thetas_dim",
      "share_weights_in_stack",
      "hidden_layer_units",
      "nb_harmonics",
      "seed"
    ],
    "create_stack": [
      "self",
      "stack_id"
    ],
    "_select_block": [
      "block_type"
    ],
    "forward": [
      "self",
      "backcast"
    ]
  },
  "seasonality_model": [
    "thetas",
    "t"
  ],
  "trend_model": [
    "thetas",
    "t"
  ],
  "linear_space": [
    "past_seq_len",
    "future_seq_len"
  ],
  "Block": {
    "__init__": [
      "self",
      "units",
      "thetas_dim",
      "past_seq_len",
      "future_seq_len",
      "share_thetas",
      "nb_harmonics"
    ],
    "forward": [
      "self",
      "x"
    ],
    "__str__": [
      "self"
    ]
  },
  "SeasonalityBlock": {
    "__init__": [
      "self",
      "units",
      "thetas_dim",
      "past_seq_len",
      "future_seq_len",
      "nb_harmonics"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TrendBlock": {
    "__init__": [
      "self",
      "units",
      "thetas_dim",
      "past_seq_len",
      "future_seq_len",
      "nb_harmonics"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "GenericBlock": {
    "__init__": [
      "self",
      "units",
      "thetas_dim",
      "past_seq_len",
      "future_seq_len",
      "nb_harmonics"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "model_creator": [
    "config"
  ],
  "optimizer_creator": [
    "model",
    "config"
  ],
  "loss_creator": [
    "config"
  ],
  "ProphetModel": {
    "__init__": [
      "self"
    ],
    "_build": [
      "self"
    ],
    "_fit": [
      "self",
      "data"
    ],
    "fit_eval": [
      "self",
      "data",
      "validation_data"
    ],
    "_eval_cross_validation": [
      "self",
      "expected_horizon"
    ],
    "predict": [
      "self",
      "ds_data",
      "horizon",
      "freq"
    ],
    "evaluate": [
      "self",
      "target",
      "data",
      "metrics"
    ],
    "save": [
      "self",
      "checkpoint"
    ],
    "restore": [
      "self",
      "checkpoint"
    ]
  },
  "ProphetBuilder": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "config"
    ]
  },
  "PYTORCH_REGRESSION_LOSS_MAP": [],
  "TCMF": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "config"
    ],
    "fit_eval": [
      "self",
      "data",
      "verbose",
      "num_workers"
    ],
    "fit_incremental": [
      "self",
      "x",
      "covariates_new",
      "dti_new"
    ],
    "get_default_num_workers": [],
    "predict": [
      "self",
      "x",
      "horizon",
      "mc",
      "future_covariates",
      "future_dti",
      "num_workers"
    ],
    "evaluate": [
      "self",
      "x",
      "y",
      "metrics",
      "target_covariates",
      "target_dti",
      "num_workers"
    ],
    "save": [
      "self",
      "model_file"
    ],
    "restore": [
      "self",
      "model_file"
    ],
    "_get_optional_parameters": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_check_covariates_dti": [
      "self",
      "covariates",
      "dti",
      "ts_len",
      "method_name"
    ]
  },
  "ModelWrapper": {
    "fit": [
      "self"
    ],
    "evaluate": [
      "self"
    ],
    "predict": [
      "self"
    ],
    "is_xshards_distributed": [
      "self"
    ],
    "save": [
      "self"
    ],
    "load": [
      "self"
    ]
  },
  "TCMFXshardsModelWrapper": {
    "__init__": [
      "self",
      "config"
    ],
    "fit": [
      "self",
      "x",
      "num_workers"
    ],
    "fit_incremental": [
      "self",
      "x_incr",
      "covariates_incr",
      "dti_incr"
    ],
    "evaluate": [
      "self",
      "y",
      "metric",
      "target_covariates",
      "target_dti",
      "num_workers"
    ],
    "predict": [
      "self",
      "horizon",
      "future_covariates",
      "future_dti",
      "num_workers"
    ],
    "is_xshards_distributed": [
      "self"
    ],
    "save": [
      "self",
      "model_path"
    ],
    "load": [
      "self",
      "model_path",
      "minPartitions"
    ]
  },
  "TCMFNdarrayModelWrapper": {
    "__init__": [
      "self",
      "config"
    ],
    "fit": [
      "self",
      "x",
      "num_workers"
    ],
    "_rearrange_data_by_id": [
      "self",
      "id_new",
      "data_new",
      "method_name"
    ],
    "fit_incremental": [
      "self",
      "x_incr",
      "covariates_incr",
      "dti_incr"
    ],
    "evaluate": [
      "self",
      "y",
      "metric",
      "target_covariates",
      "target_dti",
      "num_workers"
    ],
    "predict": [
      "self",
      "horizon",
      "future_covariates",
      "future_dti",
      "num_workers"
    ],
    "is_xshards_distributed": [
      "self"
    ],
    "save": [
      "self",
      "model_path"
    ],
    "load": [
      "self",
      "model_path"
    ]
  },
  "split_id_and_data": [
    "d",
    "is_xshards_distributed"
  ],
  "LSTMModel": {
    "__init__": [
      "self",
      "input_dim",
      "hidden_dim",
      "layer_num",
      "dropout",
      "output_dim",
      "seed"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "input_seq"
    ]
  },
  "ARIMAModel": {
    "__init__": [
      "self"
    ],
    "_build": [
      "self"
    ],
    "fit_eval": [
      "self",
      "data",
      "validation_data"
    ],
    "predict": [
      "self",
      "x",
      "horizon",
      "update",
      "rolling"
    ],
    "evaluate": [
      "self",
      "target",
      "x",
      "metrics",
      "rolling"
    ],
    "save": [
      "self",
      "checkpoint_file"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ]
  },
  "ARIMABuilder": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "config"
    ]
  },
  "LSTMSeq2Seq": {
    "__init__": [
      "self",
      "input_feature_num",
      "future_seq_len",
      "output_feature_num",
      "lstm_hidden_dim",
      "lstm_layer_num",
      "dropout",
      "teacher_forcing",
      "seed"
    ],
    "forward": [
      "self",
      "input_seq",
      "target_seq"
    ]
  },
  "Chomp1d": {
    "__init__": [
      "self",
      "chomp_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DummyEncoder": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalBlock": {
    "__init__": [
      "self",
      "n_inputs",
      "n_outputs",
      "kernel_size",
      "stride",
      "dilation",
      "padding",
      "dropout",
      "repo_initialization"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalConvNet": {
    "__init__": [
      "self",
      "past_seq_len",
      "input_feature_num",
      "future_seq_len",
      "output_feature_num",
      "num_channels",
      "dummy_encoder",
      "kernel_size",
      "dropout",
      "repo_initialization",
      "seed"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "AutoFormer": {
    "__init__": [
      "self",
      "configs"
    ],
    "forward": [
      "self",
      "x_enc",
      "x_mark_enc",
      "x_dec",
      "x_mark_dec",
      "enc_self_mask",
      "dec_self_mask",
      "dec_enc_mask"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "_transform_config_to_namedtuple": [
    "config"
  ],
  "my_Layernorm": {
    "__init__": [
      "self",
      "channels"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "EncoderLayer": {
    "__init__": [
      "self",
      "attention",
      "d_model",
      "d_ff",
      "moving_avg",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "Encoder": {
    "__init__": [
      "self",
      "attn_layers",
      "conv_layers",
      "norm_layer"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask"
    ]
  },
  "DecoderLayer": {
    "__init__": [
      "self",
      "self_attention",
      "cross_attention",
      "d_model",
      "c_out",
      "d_ff",
      "moving_avg",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask"
    ]
  },
  "Decoder": {
    "__init__": [
      "self",
      "layers",
      "norm_layer",
      "projection"
    ],
    "forward": [
      "self",
      "x",
      "cross",
      "x_mask",
      "cross_mask",
      "trend"
    ]
  },
  "AutoCorrelation": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "time_delay_agg_training": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_inference": [
      "self",
      "values",
      "corr"
    ],
    "time_delay_agg_full": [
      "self",
      "values",
      "corr"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "AutoCorrelationLayer": {
    "__init__": [
      "self",
      "correlation",
      "d_model",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "forward": [
      "self",
      "queries",
      "keys",
      "values",
      "attn_mask"
    ]
  },
  "PositionalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TokenEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FixedEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeFeatureEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DataEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "DataEmbedding_wo_pos": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "AttentionRNNWrapper": {
    "__init__": [
      "self",
      "layer",
      "weight_initializer"
    ],
    "_validate_input_shape": [
      "self",
      "input_shape"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "trainable_weights": [
      "self"
    ],
    "non_trainable_weights": [
      "self"
    ],
    "step": [
      "self",
      "x",
      "states"
    ],
    "call": [
      "self",
      "x",
      "constants",
      "mask",
      "initial_state"
    ],
    "get_constants": [
      "self",
      "x"
    ],
    "get_config": [
      "self"
    ]
  },
  "MTNetKeras": {
    "check_optional_config": [],
    "config": [],
    "model": [],
    "__init__": [
      "self",
      "check_optional_config",
      "future_seq_len"
    ],
    "apply_config": [
      "self",
      "rs",
      "config"
    ],
    "_check_hyperparameter": [
      "self"
    ],
    "build": [
      "self",
      "config"
    ],
    "__encoder": [
      "self",
      "input",
      "num",
      "name",
      "training"
    ],
    "_reshape_input_x": [
      "self",
      "x"
    ],
    "_pre_processing": [
      "self",
      "x",
      "validation_data"
    ],
    "_add_config_attributes": [
      "self",
      "config"
    ],
    "_check_input": [
      "self",
      "x",
      "y"
    ],
    "fit_eval": [
      "self",
      "data",
      "validation_data",
      "mc",
      "metric",
      "epochs",
      "verbose"
    ],
    "evaluate": [
      "self",
      "x",
      "y",
      "metrics",
      "batch_size"
    ],
    "predict": [
      "self",
      "x",
      "mc",
      "batch_size"
    ],
    "predict_with_uncertainty": [
      "self",
      "x",
      "n_iter"
    ],
    "state_dict": [
      "self"
    ],
    "save": [
      "self",
      "checkpoint_file",
      "config_path"
    ],
    "restore": [
      "self",
      "checkpoint_file"
    ],
    "_get_optional_parameters": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_check_config": [
      "self"
    ]
  },
  "model_creator_auto": [
    "config"
  ],
  "TCMFDataLoader": {
    "__init__": [
      "self",
      "Ymat",
      "covariates",
      "Ycov",
      "vbsize",
      "hbsize",
      "end_index",
      "val_len",
      "shuffle"
    ],
    "next_batch": [
      "self"
    ],
    "supply_test": [
      "self"
    ]
  },
  "console": [],
  "get_model": [
    "A",
    "y",
    "lamb"
  ],
  "DeepGLO": {
    "__init__": [
      "self",
      "vbsize",
      "hbsize",
      "num_channels_X",
      "num_channels_Y",
      "kernel_size",
      "dropout",
      "rank",
      "kernel_size_Y",
      "lr",
      "normalize",
      "use_time",
      "svd",
      "forward_cov"
    ],
    "tensor2d_to_temporal": [
      "self",
      "T"
    ],
    "temporal_to_tensor2d": [
      "self",
      "T"
    ],
    "calculate_newX_loss_vanilla": [
      "self",
      "Xn",
      "Fn",
      "Yn",
      "Xf",
      "alpha"
    ],
    "recover_future_X": [
      "self",
      "last_step",
      "future",
      "num_epochs",
      "alpha",
      "vanilla",
      "tol"
    ],
    "step_factX_loss": [
      "self",
      "inp",
      "out",
      "last_vindex",
      "last_hindex",
      "reg"
    ],
    "step_factF_loss": [
      "self",
      "inp",
      "out",
      "last_vindex",
      "last_hindex",
      "reg"
    ],
    "step_temporal_loss_X": [
      "self",
      "inp",
      "last_vindex",
      "last_hindex"
    ],
    "predict_future_batch": [
      "self",
      "model",
      "inp",
      "future"
    ],
    "predict_future": [
      "self",
      "model",
      "inp",
      "future",
      "bsize"
    ],
    "predict_global": [
      "self",
      "ind",
      "last_step",
      "future",
      "normalize",
      "bsize"
    ],
    "train_Xseq": [
      "self",
      "Ymat",
      "num_epochs",
      "val_len",
      "early_stop",
      "tenacity"
    ],
    "train_factors": [
      "self",
      "reg_X",
      "reg_F",
      "mod",
      "val_len",
      "early_stop",
      "tenacity",
      "ind",
      "seed"
    ],
    "create_Ycov": [
      "self"
    ],
    "train_Yseq": [
      "self",
      "num_epochs",
      "covariates",
      "dti",
      "val_len",
      "num_workers"
    ],
    "train_all_models": [
      "self",
      "Ymat",
      "val_len",
      "start_date",
      "freq",
      "covariates",
      "dti",
      "period",
      "init_epochs",
      "alt_iters",
      "y_iters",
      "tenacity",
      "mod",
      "max_FX_epoch",
      "max_TCN_epoch",
      "num_workers"
    ],
    "append_new_y": [
      "self",
      "Ymat_new",
      "covariates_new",
      "dti_new"
    ],
    "inject_new": [
      "self",
      "Ymat_new",
      "covariates_new",
      "dti_new"
    ],
    "get_time_covs": [
      "self",
      "future_start_date",
      "num_ts",
      "future_covariates",
      "future_dti"
    ],
    "get_future_time_covs": [
      "self",
      "horizon",
      "last_step",
      "future_covariates",
      "future_dti"
    ],
    "get_prediction_time_covs": [
      "self",
      "rg",
      "horizon",
      "last_step",
      "future_covariates",
      "future_dti"
    ],
    "predict_horizon": [
      "self",
      "ind",
      "future",
      "future_covariates",
      "future_dti",
      "bsize",
      "num_workers"
    ],
    "predict": [
      "self",
      "ind",
      "last_step",
      "future",
      "normalize",
      "bsize"
    ],
    "rolling_validation": [
      "self",
      "Ymat",
      "tau",
      "n",
      "bsize",
      "alpha"
    ]
  },
  "TimeCovariates": {
    "__init__": [
      "self",
      "start_date",
      "num_ts",
      "freq",
      "normalized"
    ],
    "_minute_of_hour": [
      "self"
    ],
    "_hour_of_day": [
      "self"
    ],
    "_day_of_week": [
      "self"
    ],
    "_day_of_month": [
      "self"
    ],
    "_day_of_year": [
      "self"
    ],
    "_month_of_year": [
      "self"
    ],
    "_week_of_year": [
      "self"
    ],
    "get_covariates": [
      "self"
    ]
  },
  "TemporalBlockLast": {
    "__init__": [
      "self",
      "n_inputs",
      "n_outputs",
      "kernel_size",
      "stride",
      "dilation",
      "padding",
      "dropout",
      "init"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "LocalModel": {
    "__init__": [
      "self",
      "Ymat",
      "num_inputs",
      "num_channels",
      "kernel_size",
      "dropout",
      "vbsize",
      "hbsize",
      "lr",
      "val_len",
      "test",
      "end_index",
      "normalize",
      "start_date",
      "freq",
      "covariates",
      "use_time",
      "dti",
      "Ycov"
    ],
    "train_model": [
      "self",
      "num_epochs",
      "num_workers",
      "early_stop",
      "tenacity"
    ],
    "loss": [
      "out",
      "target"
    ],
    "train_model_local": [
      "self",
      "num_epochs",
      "early_stop",
      "tenacity"
    ],
    "convert_to_input": [
      "data"
    ],
    "convert_covariates": [
      "data",
      "covs"
    ],
    "convert_ycovs": [
      "data",
      "ycovs"
    ],
    "convert_from_output": [
      "T"
    ],
    "predict_future_batch": [
      "data",
      "covariates",
      "ycovs",
      "future",
      "model"
    ],
    "_predict_future": [
      "data",
      "ycovs",
      "covariates",
      "model",
      "future",
      "I"
    ],
    "predict_future": [
      "self",
      "data_in",
      "covariates",
      "ycovs",
      "future",
      "bsize",
      "normalize",
      "num_workers"
    ],
    "rolling_validation": [
      "self",
      "Ymat",
      "tau",
      "n",
      "bsize",
      "alpha"
    ]
  },
  "get_tcmf_data_loader": [
    "config"
  ],
  "TcmfTrainDatasetDist": {
    "__init__": [
      "self",
      "config"
    ],
    "__iter__": [
      "self"
    ],
    "get_next_batch": [
      "self"
    ]
  },
  "TcmfTrainDatasetHorovod": {
    "__init__": [
      "self",
      "config"
    ],
    "__iter__": [
      "self"
    ],
    "get_next_batch": [
      "self"
    ]
  },
  "TcmfValDataset": {
    "__init__": [
      "self",
      "config"
    ],
    "__iter__": [
      "self"
    ]
  },
  "data_creator": [
    "config"
  ],
  "train_data_creator": [
    "config",
    "batch_size"
  ],
  "val_data_creator": [
    "config",
    "batch_size"
  ],
  "tcmf_loss": [
    "out",
    "target"
  ],
  "train_yseq_hvd": [
    "workers_per_node",
    "epochs"
  ],
  "check_iter_type": [
    "obj",
    "type"
  ],
  "VanillaLSTM": {
    "__init__": [
      "self",
      "check_optional_config",
      "future_seq_len"
    ],
    "_check_config": [
      "self"
    ],
    "_get_required_parameters": [
      "self"
    ],
    "_get_optional_parameters": [
      "self"
    ]
  }
}