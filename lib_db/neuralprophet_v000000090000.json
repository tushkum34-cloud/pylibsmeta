{
  "get_country_holidays": [
    "country",
    "years",
    "subdivision"
  ],
  "get_holidays_from_country": [
    "country",
    "df"
  ],
  "make_country_specific_holidays": [
    "year_list",
    "country"
  ],
  "Conformal": {
    "__post_init__": [
      "self"
    ],
    "predict": [
      "self",
      "df",
      "df_cal",
      "show_all_PI"
    ],
    "_get_nonconformity_scores": [
      "self",
      "df_cal",
      "step_number"
    ],
    "_get_q_hat": [
      "self",
      "df_cal",
      "noncon_scores"
    ],
    "plot": [
      "self",
      "plotting_backend"
    ]
  },
  "uncertainty_evaluate": [
    "df_forecast"
  ],
  "_get_evaluate_metrics_from_dataset": [
    "y",
    "yhat_lo",
    "yhat_hi"
  ],
  "log": [],
  "GlobalTimeDataset": {
    "__init__": [
      "self",
      "df"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "TimeDataset": {
    "__init__": [
      "self",
      "df",
      "name"
    ],
    "drop_nan_after_init": [
      "self",
      "df",
      "predict_steps",
      "drop_missing"
    ],
    "_split_nested_dict": [
      "inputs"
    ],
    "init_after_tabularized": [
      "self",
      "inputs",
      "targets"
    ],
    "filter_samples_after_init": [
      "self",
      "prediction_frequency"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ]
  },
  "tabularize_univariate_datetime": [
    "df",
    "predict_mode",
    "n_lags",
    "n_forecasts",
    "predict_steps",
    "config_seasonality",
    "config_events",
    "config_country_holidays",
    "config_lagged_regressors",
    "config_regressors",
    "config_missing",
    "prediction_frequency"
  ],
  "fourier_series": [
    "dates",
    "period",
    "series_order"
  ],
  "fourier_series_t": [
    "t",
    "period",
    "series_order"
  ],
  "_create_event_offset_features": [
    "event",
    "config",
    "feature",
    "additive_events",
    "multiplicative_events"
  ],
  "make_events_features": [
    "df",
    "config_events",
    "config_country_holidays"
  ],
  "make_regressors_features": [
    "df",
    "config_regressors"
  ],
  "seasonal_features_from_dates": [
    "df",
    "config_seasonality"
  ],
  "MetricsLogger": {
    "__init__": [
      "self"
    ],
    "after_save_checkpoint": [
      "self",
      "checkpoint_callback"
    ],
    "log_metrics": [
      "self",
      "metrics",
      "step"
    ]
  },
  "ProgressBar": {
    "__init__": [
      "self"
    ],
    "on_train_epoch_start": [
      "self",
      "trainer"
    ],
    "on_train_batch_end": [
      "self",
      "trainer",
      "pl_module"
    ],
    "_update_n": [
      "self",
      "bar",
      "value"
    ]
  },
  "NormalizeMode": [],
  "SeasonalityMode": [],
  "SeasonalityArgument": [],
  "GrowthMode": [],
  "CollectMetricsMode": [],
  "SeasonGlobalLocalMode": [],
  "FutureRegressorsModel": [],
  "Components": [],
  "ShiftScale": {},
  "prep_or_copy_df": [
    "df"
  ],
  "return_df_in_original_format": [
    "df",
    "received_ID_col",
    "received_single_time_series"
  ],
  "get_max_num_lags": [
    "config_lagged_regressors",
    "n_lags"
  ],
  "merge_dataframes": [
    "df"
  ],
  "data_params_definition": [
    "df",
    "normalize",
    "config_lagged_regressors",
    "config_regressors",
    "config_events",
    "config_seasonality",
    "local_run_despite_global"
  ],
  "init_data_params": [
    "df",
    "normalize",
    "config_lagged_regressors",
    "config_regressors",
    "config_events",
    "config_seasonality",
    "global_normalization",
    "global_time_normalization"
  ],
  "auto_normalization_setting": [
    "array"
  ],
  "get_normalization_params": [
    "array",
    "norm_type"
  ],
  "normalize": [
    "df",
    "data_params"
  ],
  "check_dataframe": [
    "df",
    "check_y",
    "covariates",
    "regressors",
    "events",
    "seasonalities",
    "future"
  ],
  "_crossvalidation_split_df": [
    "df",
    "n_lags",
    "n_forecasts",
    "k",
    "fold_pct",
    "fold_overlap_pct"
  ],
  "find_valid_time_interval_for_cv": [
    "df"
  ],
  "unfold_dict_of_folds": [
    "folds_dict",
    "k"
  ],
  "_crossvalidation_with_time_threshold": [
    "df",
    "n_lags",
    "n_forecasts",
    "k",
    "fold_pct",
    "fold_overlap_pct"
  ],
  "crossvalidation_split_df": [
    "df",
    "n_lags",
    "n_forecasts",
    "k",
    "fold_pct",
    "fold_overlap_pct",
    "global_model_cv_type"
  ],
  "double_crossvalidation_split_df": [
    "df",
    "n_lags",
    "n_forecasts",
    "k",
    "valid_pct",
    "test_pct"
  ],
  "find_time_threshold": [
    "df",
    "n_lags",
    "n_forecasts",
    "valid_p",
    "inputs_overbleed"
  ],
  "split_considering_timestamp": [
    "df",
    "n_lags",
    "n_forecasts",
    "inputs_overbleed",
    "threshold_time_stamp"
  ],
  "split_df": [
    "df",
    "n_lags",
    "n_forecasts",
    "valid_p",
    "inputs_overbleed",
    "local_split"
  ],
  "make_future_df": [
    "df_columns",
    "last_date",
    "periods",
    "freq",
    "config_events",
    "config_regressors",
    "events_df",
    "regressors_df"
  ],
  "convert_events_to_features": [
    "df",
    "config_events",
    "events_df"
  ],
  "add_missing_dates_nan": [
    "df",
    "freq"
  ],
  "create_dummy_datestamps": [
    "df",
    "freq",
    "startyear",
    "startmonth",
    "startday",
    "starthour",
    "startminute",
    "startsecond"
  ],
  "fill_linear_then_rolling_avg": [
    "series",
    "limit_linear",
    "rolling"
  ],
  "get_freq_dist": [
    "ds_col"
  ],
  "convert_str_to_num_freq": [
    "freq_str"
  ],
  "convert_num_to_str_freq": [
    "freq_num",
    "initial_time_stamp"
  ],
  "get_dist_considering_two_freqs": [
    "dist"
  ],
  "_get_dominant_frequency_percentage": [
    "frequencies",
    "distribution",
    "filter_list"
  ],
  "_infer_frequency": [
    "df",
    "freq",
    "min_freq_percentage"
  ],
  "infer_frequency": [
    "df",
    "freq",
    "n_lags",
    "min_freq_percentage"
  ],
  "create_dict_for_events_or_regressors": [
    "df",
    "other_df",
    "other_df_name"
  ],
  "handle_negative_values": [
    "df",
    "col",
    "handle_negatives"
  ],
  "drop_missing_from_df": [
    "df",
    "drop_missing",
    "predict_steps",
    "n_lags"
  ],
  "join_dfs_after_data_drop": [
    "predicted",
    "df",
    "merge"
  ],
  "add_quarter_condition": [
    "df"
  ],
  "add_weekday_condition": [
    "df"
  ],
  "create_mask_for_prediction_frequency": [
    "prediction_frequency",
    "ds",
    "forecast_lag"
  ],
  "plot_parameters": [
    "m",
    "plot_configuration",
    "quantile",
    "weekly_start",
    "yearly_start",
    "figsize",
    "df_name",
    "forecast_in_focus"
  ],
  "plot_trend_change": [
    "m",
    "quantile",
    "ax",
    "plot_name",
    "figsize",
    "df_name"
  ],
  "plot_trend": [
    "m",
    "quantile",
    "ax",
    "plot_name",
    "figsize",
    "df_name"
  ],
  "plot_scalar_weights": [
    "weights",
    "plot_name",
    "focus",
    "ax",
    "figsize"
  ],
  "plot_lagged_weights": [
    "weights",
    "comp_name",
    "focus",
    "ax",
    "figsize"
  ],
  "plot_custom_season": [
    "m",
    "comp_name",
    "quantile",
    "ax",
    "figsize",
    "df_name"
  ],
  "plot_yearly": [
    "m",
    "quantile",
    "comp_name",
    "yearly_start",
    "quick",
    "ax",
    "figsize",
    "df_name"
  ],
  "plot_weekly": [
    "m",
    "quantile",
    "comp_name",
    "weekly_start",
    "quick",
    "ax",
    "figsize",
    "df_name"
  ],
  "plot_daily": [
    "m",
    "quantile",
    "comp_name",
    "quick",
    "ax",
    "figsize",
    "df_name"
  ],
  "plot": [
    "fcst",
    "quantiles",
    "ax",
    "xlabel",
    "ylabel",
    "highlight_forecast",
    "line_per_origin",
    "figsize"
  ],
  "plot_components": [
    "m",
    "fcst",
    "plot_configuration",
    "df_name",
    "quantile",
    "one_period_per_season",
    "figsize"
  ],
  "plot_forecast_component": [
    "fcst",
    "comp_name",
    "plot_name",
    "ax",
    "figsize",
    "multiplicative",
    "bar",
    "rolling",
    "add_x",
    "fill"
  ],
  "plot_multiforecast_component": [
    "fcst",
    "comp_name",
    "plot_name",
    "ax",
    "figsize",
    "multiplicative",
    "bar",
    "focus",
    "num_overplot"
  ],
  "plot_nonconformity_scores": [
    "scores",
    "alpha",
    "q",
    "method"
  ],
  "plot_interval_width_per_timestep": [
    "q_hats",
    "method"
  ],
  "FILE_LIKE": [],
  "save": [
    "forecaster",
    "path"
  ],
  "load": [
    "path",
    "map_location"
  ],
  "reg_func_abs": [
    "weights"
  ],
  "reg_func_trend": [
    "weights",
    "threshold"
  ],
  "reg_func_trend_glocal": [
    "trend_k0",
    "trend_deltas",
    "trend_local_reg"
  ],
  "reg_func_seasonality_glocal": [
    "season_params",
    "seasonality_local_reg"
  ],
  "reg_func_season": [
    "weights"
  ],
  "_regularize_weights": [
    "weights",
    "reg_lambda"
  ],
  "reg_func_events": [
    "config_events",
    "config_country_holidays",
    "model"
  ],
  "reg_func_covariates": [
    "config_lagged_regressors",
    "model"
  ],
  "reg_func_regressors": [
    "config_regressors",
    "model"
  ],
  "check_for_regularization": [
    "configs"
  ],
  "symmetric_total_percentage_error": [
    "values",
    "estimates"
  ],
  "config_seasonality_to_model_dims": [
    "config_seasonality"
  ],
  "config_events_to_model_dims": [
    "config_events",
    "config_country_holidays"
  ],
  "create_event_names_for_offsets": [
    "event_name",
    "offset"
  ],
  "config_regressors_to_model_dims": [
    "config_regressors"
  ],
  "set_auto_seasonalities": [
    "df",
    "config_seasonality"
  ],
  "print_epoch_metrics": [
    "metrics",
    "val_metrics",
    "e"
  ],
  "fcst_df_to_latest_forecast": [
    "fcst",
    "quantiles",
    "n_last"
  ],
  "HiddenPrints": {
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "set_random_seed": [
    "seed"
  ],
  "set_logger_level": [
    "logger",
    "log_level",
    "include_handlers"
  ],
  "set_log_level": [
    "log_level",
    "include_handlers"
  ],
  "smooth_loss_and_suggest": [
    "lr_finder_results",
    "window"
  ],
  "_smooth_loss": [
    "loss",
    "beta"
  ],
  "configure_trainer": [
    "config_train",
    "config",
    "metrics_logger",
    "early_stopping",
    "early_stopping_target",
    "accelerator",
    "progress_bar_enabled",
    "metrics_enabled",
    "checkpointing_enabled",
    "num_batches_per_epoch"
  ],
  "Model": {},
  "Normalization": {
    "init_data_params": [
      "self",
      "df",
      "config_lagged_regressors",
      "config_regressors",
      "config_events",
      "config_seasonality"
    ],
    "get_data_params": [
      "self",
      "df_name"
    ]
  },
  "MissingDataHandling": {},
  "Train": {
    "__post_init__": [
      "self"
    ],
    "set_loss_func": [
      "self"
    ],
    "set_quantiles": [
      "self"
    ],
    "set_auto_batch_epoch": [
      "self",
      "n_data",
      "min_batch",
      "max_batch",
      "min_epoch",
      "max_epoch"
    ],
    "set_optimizer": [
      "self"
    ],
    "set_scheduler": [
      "self"
    ],
    "set_lr_finder_args": [
      "self",
      "dataset_size",
      "num_batches"
    ],
    "get_reg_delay_weight": [
      "self",
      "e",
      "iter_progress",
      "reg_start_pct",
      "reg_full_pct"
    ]
  },
  "Trend": {
    "__post_init__": [
      "self"
    ]
  },
  "Season": {},
  "ConfigSeasonality": {
    "__post_init__": [
      "self"
    ],
    "append": [
      "self",
      "name",
      "period",
      "resolution",
      "arg",
      "condition_name",
      "global_local"
    ]
  },
  "AR": {
    "__post_init__": [
      "self"
    ],
    "regularize": [
      "self",
      "weights",
      "original"
    ]
  },
  "LaggedRegressor": {
    "__post_init__": [
      "self"
    ]
  },
  "ConfigLaggedRegressors": [],
  "Regressor": {},
  "ConfigFutureRegressors": {
    "__post_init__": [
      "self"
    ]
  },
  "Event": {},
  "ConfigEvents": [],
  "Holidays": {
    "init_holidays": [
      "self",
      "df"
    ]
  },
  "ConfigCountryHolidays": [],
  "log_warning_deprecation_plotly": [
    "plotting_backend"
  ],
  "log_warning_resampler_invalid_env": [],
  "log_warning_resampler_switch_to_valid_env": [],
  "set_y_as_percent": [
    "ax"
  ],
  "predict_one_season": [
    "m",
    "quantile",
    "name",
    "n_steps",
    "df_name"
  ],
  "predict_season_from_dates": [
    "m",
    "dates",
    "name",
    "quantile",
    "df_name"
  ],
  "check_if_configured": [
    "m",
    "components",
    "error_flag"
  ],
  "get_valid_configuration": [
    "m",
    "components",
    "df_name",
    "valid_set",
    "validator",
    "forecast_in_focus",
    "quantile"
  ],
  "validate_current_env_for_resampler": [
    "auto"
  ],
  "is_notebook": [],
  "select_plotting_backend": [
    "model",
    "plotting_backend"
  ],
  "NeuralProphet": {
    "__init__": [
      "self",
      "growth",
      "changepoints",
      "n_changepoints",
      "changepoints_range",
      "trend_reg",
      "trend_reg_threshold",
      "trend_global_local",
      "trend_local_reg",
      "yearly_seasonality",
      "yearly_seasonality_glocal_mode",
      "weekly_seasonality",
      "weekly_seasonality_glocal_mode",
      "daily_seasonality",
      "daily_seasonality_glocal_mode",
      "seasonality_mode",
      "seasonality_reg",
      "season_global_local",
      "seasonality_local_reg",
      "future_regressors_model",
      "future_regressors_d_hidden",
      "future_regressors_num_hidden_layers",
      "n_forecasts",
      "n_lags",
      "ar_layers",
      "ar_reg",
      "lagged_reg_layers",
      "learning_rate",
      "epochs",
      "batch_size",
      "loss_func",
      "optimizer",
      "newer_samples_weight",
      "newer_samples_start",
      "quantiles",
      "impute_missing",
      "impute_linear",
      "impute_rolling",
      "drop_missing",
      "collect_metrics",
      "normalize",
      "global_normalization",
      "global_time_normalization",
      "unknown_data_normalization",
      "accelerator",
      "trainer_config",
      "prediction_frequency"
    ],
    "add_lagged_regressor": [
      "self",
      "names",
      "n_lags",
      "regularization",
      "normalize"
    ],
    "parameters": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "add_future_regressor": [
      "self",
      "name",
      "regularization",
      "normalize",
      "mode"
    ],
    "add_events": [
      "self",
      "events",
      "lower_window",
      "upper_window",
      "regularization",
      "mode"
    ],
    "add_country_holidays": [
      "self",
      "country_name",
      "lower_window",
      "upper_window",
      "regularization",
      "mode"
    ],
    "add_seasonality": [
      "self",
      "name",
      "period",
      "fourier_order",
      "global_local",
      "condition_name"
    ],
    "fit": [
      "self",
      "df",
      "freq",
      "validation_df",
      "epochs",
      "batch_size",
      "learning_rate",
      "early_stopping",
      "minimal",
      "metrics",
      "progress",
      "checkpointing",
      "continue_training",
      "num_workers"
    ],
    "predict": [
      "self",
      "df",
      "decompose",
      "raw",
      "auto_extend"
    ],
    "test": [
      "self",
      "df",
      "verbose"
    ],
    "split_df": [
      "self",
      "df",
      "freq",
      "valid_p",
      "local_split"
    ],
    "crossvalidation_split_df": [
      "self",
      "df",
      "freq",
      "k",
      "fold_pct",
      "fold_overlap_pct",
      "global_model_cv_type"
    ],
    "double_crossvalidation_split_df": [
      "self",
      "df",
      "freq",
      "k",
      "valid_pct",
      "test_pct"
    ],
    "create_df_with_events": [
      "self",
      "df",
      "events_df"
    ],
    "make_future_dataframe": [
      "self",
      "df",
      "events_df",
      "regressors_df",
      "periods",
      "n_historic_predictions"
    ],
    "handle_negative_values": [
      "self",
      "df",
      "handle",
      "columns"
    ],
    "predict_trend": [
      "self",
      "df",
      "quantile"
    ],
    "predict_seasonal_components": [
      "self",
      "df",
      "quantile"
    ],
    "set_true_ar_for_eval": [
      "self",
      "true_ar_weights"
    ],
    "set_plotting_backend": [
      "self",
      "plotting_backend"
    ],
    "highlight_nth_step_ahead_of_each_forecast": [
      "self",
      "step_number"
    ],
    "plot": [
      "self",
      "fcst",
      "df_name",
      "ax",
      "xlabel",
      "ylabel",
      "figsize",
      "forecast_in_focus",
      "plotting_backend"
    ],
    "get_latest_forecast": [
      "self",
      "fcst",
      "df_name",
      "include_history_data",
      "include_previous_forecasts"
    ],
    "plot_latest_forecast": [
      "self",
      "fcst",
      "df_name",
      "ax",
      "xlabel",
      "ylabel",
      "figsize",
      "include_previous_forecasts",
      "plot_history_data",
      "plotting_backend"
    ],
    "plot_last_forecast": [
      "self",
      "fcst",
      "df_name",
      "ax",
      "xlabel",
      "ylabel",
      "figsize",
      "include_previous_forecasts",
      "plot_history_data",
      "plotting_backend"
    ],
    "plot_components": [
      "self",
      "fcst",
      "df_name",
      "figsize",
      "forecast_in_focus",
      "plotting_backend",
      "components",
      "one_period_per_season"
    ],
    "plot_parameters": [
      "self",
      "weekly_start",
      "yearly_start",
      "figsize",
      "forecast_in_focus",
      "df_name",
      "plotting_backend",
      "quantile",
      "components"
    ],
    "_init_model": [
      "self"
    ],
    "_init_train_loader": [
      "self",
      "df",
      "num_workers"
    ],
    "_init_val_loader": [
      "self",
      "df"
    ],
    "_train": [
      "self",
      "df",
      "df_val",
      "progress_bar_enabled",
      "metrics_enabled",
      "checkpointing_enabled",
      "continue_training",
      "num_workers"
    ],
    "restore_trainer": [
      "self",
      "accelerator"
    ],
    "_eval_true_ar": [
      "self"
    ],
    "_predict_raw": [
      "self",
      "df",
      "df_name",
      "include_components",
      "prediction_frequency"
    ],
    "conformal_predict": [
      "self",
      "df",
      "calibration_df",
      "alpha",
      "method",
      "plotting_backend",
      "show_all_PI"
    ],
    "conformal_plot": [
      "self",
      "df",
      "n_highlight",
      "plotting_backend"
    ]
  },
  "PinballLoss": {
    "__init__": [
      "self",
      "loss_func",
      "quantiles"
    ],
    "forward": [
      "self",
      "outputs",
      "target"
    ]
  },
  "TimeNet": {
    "__init__": [
      "self",
      "config_seasonality",
      "config_train",
      "config_trend",
      "config_ar",
      "config_normalization",
      "config_lagged_regressors",
      "config_regressors",
      "config_events",
      "config_holidays",
      "n_forecasts",
      "n_lags",
      "max_lags",
      "ar_layers",
      "lagged_reg_layers",
      "compute_components_flag",
      "metrics",
      "id_list",
      "num_trends_modelled",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "meta_used_in_model"
    ],
    "ar_weights": [
      "self"
    ],
    "get_covar_weights": [
      "self",
      "covar_input"
    ],
    "set_covar_weights": [
      "self",
      "covar_weights"
    ],
    "get_event_weights": [
      "self",
      "name"
    ],
    "_compute_quantile_forecasts_from_diffs": [
      "self",
      "diffs",
      "predict_mode"
    ],
    "scalar_features_effects": [
      "self",
      "features",
      "params",
      "indices"
    ],
    "auto_regression": [
      "self",
      "lags"
    ],
    "forward_covar_net": [
      "self",
      "covariates"
    ],
    "forward": [
      "self",
      "inputs",
      "meta",
      "compute_components_flag"
    ],
    "compute_components": [
      "self",
      "inputs",
      "components_raw",
      "meta"
    ],
    "set_compute_components": [
      "self",
      "compute_components_flag"
    ],
    "loss_func": [
      "self",
      "inputs",
      "predicted",
      "targets"
    ],
    "training_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "test_step": [
      "self",
      "batch",
      "batch_idx"
    ],
    "predict_step": [
      "self",
      "batch",
      "batch_idx",
      "dataloader_idx"
    ],
    "configure_optimizers": [
      "self"
    ],
    "_get_time_based_sample_weight": [
      "self",
      "t"
    ],
    "_add_batch_regularizations": [
      "self",
      "loss",
      "epoch",
      "progress"
    ],
    "denormalize": [
      "self",
      "ts"
    ],
    "train_dataloader": [
      "self"
    ]
  },
  "FlatNet": {
    "__init__": [
      "self",
      "d_inputs",
      "d_outputs"
    ],
    "forward": [
      "self",
      "x"
    ],
    "ar_weights": [
      "self"
    ]
  },
  "DeepNet": {
    "__init__": [
      "self",
      "d_inputs",
      "d_outputs",
      "lagged_reg_layers"
    ],
    "forward": [
      "self",
      "x"
    ],
    "ar_weights": [
      "self"
    ]
  },
  "c_handler": [],
  "c_format": [],
  "warnings_log": [],
  "write_log_file": [],
  "color": [],
  "xaxis_args": [],
  "yaxis_args": [],
  "layout_args": [],
  "get_dynamic_axis_range": [
    "df_range",
    "type",
    "pad",
    "inverse"
  ],
  "TorchProphet": {
    "__init__": [
      "self",
      "growth",
      "changepoints",
      "n_changepoints",
      "changepoint_range",
      "yearly_seasonality",
      "weekly_seasonality",
      "daily_seasonality",
      "holidays",
      "seasonality_mode",
      "seasonality_prior_scale",
      "holidays_prior_scale",
      "changepoint_prior_scale",
      "mcmc_samples",
      "interval_width",
      "uncertainty_samples",
      "stan_backend"
    ],
    "validate_inputs": [
      "self"
    ],
    "validate_column_name": [
      "self",
      "name",
      "check_holidays",
      "check_seasonalities",
      "check_regressors"
    ],
    "setup_dataframe": [
      "self",
      "df",
      "initialize_scales"
    ],
    "fit": [
      "self",
      "df"
    ],
    "predict": [
      "self",
      "df"
    ],
    "predict_trend": [
      "self",
      "df"
    ],
    "make_future_dataframe": [
      "self",
      "periods",
      "freq",
      "include_history"
    ],
    "add_seasonality": [
      "self",
      "name",
      "period",
      "fourier_order",
      "prior_scale",
      "mode",
      "condition_name"
    ],
    "add_regressor": [
      "self",
      "name",
      "prior_scale",
      "standardize",
      "mode"
    ],
    "add_country_holidays": [
      "self",
      "country_name"
    ],
    "plot": [
      "self",
      "fcst",
      "ax",
      "uncertainty",
      "plot_cap",
      "xlabel",
      "ylabel",
      "figsize",
      "include_legend"
    ],
    "plot_components": [
      "self",
      "fcst",
      "uncertainty",
      "plot_cap",
      "weekly_start",
      "yearly_start",
      "figsize"
    ]
  },
  "plot_plotly": [
    "self",
    "fcst",
    "ax",
    "uncertainty",
    "plot_cap",
    "xlabel",
    "ylabel",
    "figsize",
    "include_legend"
  ],
  "plot_components_plotly": [
    "m",
    "fcst",
    "uncertainty",
    "plot_cap",
    "figsize"
  ],
  "init_parameter": [
    "dims"
  ],
  "penalize_nonzero": [
    "weights",
    "eagerness",
    "acceptance"
  ],
  "create_optimizer_from_config": [
    "optimizer_name",
    "optimizer_args"
  ],
  "interprete_model": [
    "target_model",
    "net",
    "forward_func",
    "_num_in_features",
    "_num_out_features",
    "_input",
    "additional_forward_args"
  ],
  "METRICS": [],
  "get_metrics": [
    "metric_input"
  ],
  "parse_args": [
    "args"
  ],
  "__version__": [],
  "prediction_color": [],
  "actual_color": [],
  "trend_color": [],
  "line_width": [],
  "marker_size": [],
  "get_forecast_component_props": [
    "fcst",
    "comp_name",
    "plot_name",
    "multiplicative",
    "bar",
    "rolling",
    "add_x",
    "fill",
    "num_overplot"
  ],
  "get_multiforecast_component_props": [
    "fcst",
    "comp_name",
    "plot_name",
    "multiplicative",
    "bar",
    "focus",
    "num_overplot"
  ],
  "get_seasonality_props": [
    "m",
    "fcst",
    "df_name",
    "comp_name",
    "multiplicative",
    "quick"
  ],
  "conformal_plot_plotly": [
    "fig",
    "df_cp_lo",
    "df_cp_hi",
    "plotting_backend"
  ],
  "BaseComponent": {
    "__init__": [
      "self",
      "n_forecasts",
      "quantiles",
      "id_list",
      "device"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "get_trend": [
    "config",
    "n_forecasts",
    "quantiles",
    "id_list",
    "num_trends_modelled",
    "device"
  ],
  "get_future_regressors": [
    "config",
    "id_list",
    "quantiles",
    "n_forecasts",
    "device",
    "config_trend_none_bool"
  ],
  "get_seasonality": [
    "config",
    "id_list",
    "quantiles",
    "num_seasonalities_modelled",
    "num_seasonalities_modelled_dict",
    "n_forecasts",
    "device"
  ],
  "FutureRegressors": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "n_forecasts",
      "device",
      "config_trend_none_bool"
    ]
  },
  "SharedNeuralNetsCoefFutureRegressors": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "n_forecasts",
      "device",
      "config_trend_none_bool"
    ],
    "get_reg_weights": [
      "self",
      "name"
    ],
    "regressors": [
      "self",
      "regressor_inputs",
      "mode"
    ],
    "forward": [
      "self",
      "inputs",
      "mode",
      "indeces"
    ]
  },
  "SharedNeuralNetsFutureRegressors": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "n_forecasts",
      "device",
      "config_trend_none_bool"
    ],
    "get_reg_weights": [
      "self",
      "name"
    ],
    "regressors": [
      "self",
      "regressor_inputs",
      "mode"
    ],
    "forward": [
      "self",
      "inputs",
      "mode",
      "indeces"
    ]
  },
  "NeuralNetsFutureRegressors": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "n_forecasts",
      "device",
      "config_trend_none_bool"
    ],
    "get_reg_weights": [
      "self",
      "name"
    ],
    "regressor": [
      "self",
      "regressor_input",
      "name"
    ],
    "all_regressors": [
      "self",
      "regressor_inputs",
      "mode"
    ],
    "forward": [
      "self",
      "inputs",
      "mode",
      "indeces"
    ]
  },
  "LinearFutureRegressors": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "n_forecasts",
      "device",
      "config_trend_none_bool"
    ],
    "scalar_features_effects": [
      "self",
      "features",
      "params",
      "indices"
    ],
    "get_reg_weights": [
      "self",
      "name"
    ],
    "forward": [
      "self",
      "inputs",
      "mode",
      "indeces"
    ]
  },
  "StaticTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "forward": [
      "self",
      "t",
      "meta"
    ],
    "get_trend_deltas": [
      "self"
    ],
    "add_regularization": [
      "self"
    ]
  },
  "PiecewiseLinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "forward": [
      "self",
      "t",
      "meta"
    ],
    "get_trend_deltas": [
      "self"
    ],
    "add_regularization": [
      "self"
    ],
    "compute_k_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_m_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_trend": [
      "self",
      "t",
      "k_t",
      "m_t",
      "meta_name_tensor_one_hot"
    ]
  },
  "GlobalPiecewiseLinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "compute_k_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_m_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_trend": [
      "self",
      "t",
      "k_t",
      "m_t",
      "meta_name_tensor_one_hot"
    ]
  },
  "LocalPiecewiseLinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "compute_k_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_m_t": [
      "self",
      "current_segment",
      "past_next_changepoint",
      "meta_name_tensor_one_hot"
    ],
    "compute_trend": [
      "self",
      "t",
      "k_t",
      "m_t",
      "meta_name_tensor_one_hot"
    ]
  },
  "LinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "get_trend_deltas": [
      "self"
    ],
    "add_regularization": [
      "self"
    ]
  },
  "GlobalLinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "forward": [
      "self",
      "t",
      "meta"
    ]
  },
  "LocalLinearTrend": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_trends_modelled",
      "n_forecasts",
      "device"
    ],
    "forward": [
      "self",
      "t",
      "meta"
    ]
  },
  "Seasonality": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "n_forecasts",
      "device"
    ]
  },
  "FourierSeasonality": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "n_forecasts",
      "device"
    ],
    "compute_fourier": [
      "self",
      "features",
      "name",
      "meta"
    ],
    "forward": [
      "self",
      "s",
      "meta"
    ]
  },
  "GlobalFourierSeasonality": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "n_forecasts",
      "device"
    ],
    "compute_fourier": [
      "self",
      "features",
      "name",
      "meta"
    ]
  },
  "LocalFourierSeasonality": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "n_forecasts",
      "device"
    ],
    "compute_fourier": [
      "self",
      "features",
      "name",
      "meta"
    ]
  },
  "GlocalFourierSeasonality": {
    "__init__": [
      "self",
      "config",
      "id_list",
      "quantiles",
      "num_seasonalities_modelled",
      "num_seasonalities_modelled_dict",
      "n_forecasts",
      "device"
    ],
    "compute_fourier": [
      "self",
      "features",
      "name",
      "meta"
    ]
  },
  "_reshape_raw_predictions_to_forecst_df": [
    "df",
    "predicted",
    "components",
    "prediction_frequency",
    "dates",
    "n_forecasts",
    "max_lags",
    "freq",
    "quantiles",
    "config_lagged_regressors"
  ],
  "_convert_raw_predictions_to_raw_df": [
    "dates",
    "predicted",
    "n_forecasts",
    "quantiles",
    "components"
  ],
  "_prepare_dataframe_to_predict": [
    "model",
    "df",
    "max_lags",
    "freq"
  ],
  "_validate_column_name": [
    "name",
    "config_events",
    "config_country_holidays",
    "config_seasonality",
    "config_lagged_regressors",
    "config_regressors",
    "events",
    "seasons",
    "regressors",
    "covariates"
  ],
  "_check_dataframe": [
    "model",
    "df",
    "check_y",
    "exogenous",
    "future"
  ],
  "_handle_missing_data": [
    "df",
    "freq",
    "n_lags",
    "n_forecasts",
    "config_missing",
    "config_regressors",
    "config_lagged_regressors",
    "config_events",
    "config_seasonality",
    "predicting"
  ],
  "_create_dataset": [
    "model",
    "df",
    "predict_mode",
    "prediction_frequency"
  ],
  "_maybe_extend_df": [
    "df",
    "n_forecasts",
    "max_lags",
    "freq",
    "config_regressors",
    "config_events"
  ],
  "_get_maybe_extend_periods": [
    "df",
    "n_forecasts",
    "max_lags",
    "config_regressors"
  ],
  "_make_future_dataframe": [
    "model",
    "df",
    "events_df",
    "regressors_df",
    "periods",
    "n_historic_predictions",
    "n_forecasts",
    "max_lags",
    "freq"
  ],
  "_normalize": [
    "df",
    "config_normalization"
  ]
}