{
  "variable_expression": [
    "model",
    "var",
    "truncate_deterministic"
  ],
  "_extract_dim_value": [
    "var"
  ],
  "dims_expression": [
    "model",
    "var"
  ],
  "model_parameter_count": [
    "model"
  ],
  "model_table": [
    "model"
  ],
  "IsType": [],
  "Deserialize": [],
  "Deserializer": {},
  "DeserializableError": {
    "__init__": [
      "self",
      "data"
    ]
  },
  "deserialize": [
    "data"
  ],
  "register_deserialization": [
    "is_type",
    "deserialize"
  ],
  "LinearModel": {
    "__init__": [
      "self",
      "model_config",
      "sampler_config",
      "nsamples"
    ],
    "_model_type": [],
    "version": [],
    "get_default_model_config": [],
    "get_default_sampler_config": [],
    "_serializable_model_config": [
      "self"
    ],
    "output_var": [
      "self"
    ],
    "build_model": [
      "self",
      "X",
      "y"
    ],
    "_data_setter": [
      "self",
      "X",
      "y"
    ],
    "_generate_and_preprocess_model_data": [
      "self",
      "X",
      "y"
    ]
  },
  "UnsupportedShapeError": {},
  "UnsupportedDistributionError": {},
  "UnsupportedParameterizationError": {},
  "MuAlreadyExistsError": {
    "__init__": [
      "self",
      "distribution"
    ]
  },
  "UnknownTransformError": {},
  "_remove_leading_xs": [
    "args"
  ],
  "handle_dims": [
    "x",
    "dims",
    "desired_dims"
  ],
  "DimHandler": [],
  "create_dim_handler": [
    "desired_dims"
  ],
  "_dims_to_str": [
    "obj"
  ],
  "_get_pymc_distribution": [
    "name"
  ],
  "_get_pymc_dim_distribution": [
    "name"
  ],
  "Transform": [],
  "register_tensor_transform": [
    "name",
    "transform"
  ],
  "_get_transform": [
    "name",
    "xdist"
  ],
  "_get_pymc_parameters": [
    "distribution"
  ],
  "VariableFactory": {
    "create_variable": [
      "self",
      "name",
      "xdist"
    ]
  },
  "sample_prior": [
    "factory",
    "coords",
    "name",
    "wrap",
    "xdist"
  ],
  "Prior": {
    "__init__": [
      "self",
      "distribution"
    ],
    "distribution": [
      "self",
      "distribution"
    ],
    "transform": [
      "self",
      "transform"
    ],
    "dims": [
      "self",
      "dims"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "_checks": [
      "self"
    ],
    "_parameters_are_at_least_subset_of_pymc": [
      "self"
    ],
    "_convert_lists_to_numpy": [
      "self"
    ],
    "_parameters_are_correct_type": [
      "self"
    ],
    "_correct_non_centered_distribution": [
      "self"
    ],
    "_unique_dims": [
      "self"
    ],
    "_param_dims_work": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_create_parameter": [
      "self",
      "param",
      "value",
      "name",
      "xdist"
    ],
    "_create_centered_variable": [
      "self",
      "name",
      "xdist"
    ],
    "_create_non_centered_variable": [
      "self",
      "name",
      "xdist"
    ],
    "create_variable": [
      "self",
      "name",
      "xdist"
    ],
    "preliz": [
      "self"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "data"
    ],
    "constrain": [
      "self",
      "lower",
      "upper",
      "mass",
      "kwargs"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "sample_prior": [
      "self",
      "coords",
      "name",
      "xdist"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "deepcopy": [
      "self"
    ],
    "to_graph": [
      "self"
    ],
    "create_likelihood_variable": [
      "self",
      "name",
      "mu",
      "observed",
      "xdist"
    ]
  },
  "VariableNotFound": {},
  "_remove_random_variable": [
    "var"
  ],
  "Censored": {
    "__post_init__": [
      "self"
    ],
    "dims": [
      "self",
      "dims"
    ],
    "create_variable": [
      "self",
      "name",
      "xdist"
    ],
    "to_dict": [
      "self"
    ],
    "from_dict": [
      "cls",
      "data"
    ],
    "sample_prior": [
      "self",
      "coords",
      "name",
      "xdist"
    ],
    "to_graph": [
      "self"
    ],
    "create_likelihood_variable": [
      "self",
      "name",
      "mu",
      "observed"
    ]
  },
  "Scaled": {
    "__init__": [
      "self",
      "dist",
      "factor"
    ],
    "dims": [
      "self"
    ],
    "create_variable": [
      "self",
      "name",
      "xdist"
    ]
  },
  "_is_prior_type": [
    "data"
  ],
  "_is_censored_type": [
    "data"
  ],
  "_is_data_array_type": [
    "data"
  ],
  "__getattr__": [
    "name"
  ],
  "_log": [],
  "__version__": [],
  "ModelBuilder": {
    "_model_type": [],
    "version": [],
    "__init__": [
      "self",
      "model_config",
      "sampler_config"
    ],
    "_validate_data": [
      "self",
      "X",
      "y"
    ],
    "_data_setter": [
      "self",
      "X",
      "y"
    ],
    "output_var": [
      "self"
    ],
    "get_default_model_config": [],
    "get_default_sampler_config": [
      "self"
    ],
    "_generate_and_preprocess_model_data": [
      "self",
      "X",
      "y"
    ],
    "build_model": [
      "self",
      "X",
      "y"
    ],
    "sample_model": [
      "self"
    ],
    "set_idata_attrs": [
      "self",
      "idata"
    ],
    "save": [
      "self",
      "fname"
    ],
    "_model_config_formatting": [
      "cls",
      "model_config"
    ],
    "load": [
      "cls",
      "fname"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "progressbar",
      "predictor_names",
      "random_seed"
    ],
    "predict": [
      "self",
      "X_pred",
      "extend_idata"
    ],
    "sample_prior_predictive": [
      "self",
      "X_pred",
      "y_pred",
      "samples",
      "extend_idata",
      "combined"
    ],
    "sample_posterior_predictive": [
      "self",
      "X_pred",
      "extend_idata",
      "combined"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_serializable_model_config": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X_pred",
      "extend_idata",
      "combined"
    ],
    "predict_posterior": [
      "self",
      "X_pred",
      "extend_idata",
      "combined"
    ],
    "id": [
      "self"
    ]
  },
  "solve_lower": [],
  "solve_upper": [],
  "LatentApprox": {},
  "ProjectedProcess": {
    "__init__": [
      "self",
      "n_inducing"
    ],
    "_build_prior": [
      "self",
      "name",
      "X",
      "X_inducing",
      "jitter"
    ],
    "prior": [
      "self",
      "name",
      "X",
      "X_inducing",
      "jitter"
    ],
    "_build_conditional": [
      "self",
      "name",
      "Xnew",
      "X_inducing",
      "L",
      "Kuuiu",
      "jitter"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "jitter"
    ]
  },
  "KarhunenLoeveExpansion": {
    "__init__": [
      "self",
      "variance_limit",
      "n_eigs"
    ],
    "_build_prior": [
      "self",
      "name",
      "X",
      "jitter"
    ],
    "prior": [
      "self",
      "name",
      "X",
      "jitter"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "X",
      "f",
      "U",
      "s",
      "jitter"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "jitter"
    ]
  },
  "__all__": [],
  "GenExtremeRV": {
    "signature": [],
    "__call__": [
      "self",
      "mu",
      "sigma",
      "xi",
      "size"
    ],
    "rng_fn": [
      "cls",
      "rng",
      "mu",
      "sigma",
      "xi",
      "size"
    ]
  },
  "gev": [],
  "GenExtreme": {
    "rv_op": [],
    "dist": [
      "cls",
      "mu",
      "sigma",
      "xi",
      "scipy"
    ],
    "logp": [
      "value",
      "mu",
      "sigma",
      "xi"
    ],
    "logcdf": [
      "value",
      "mu",
      "sigma",
      "xi"
    ],
    "support_point": [
      "rv",
      "size",
      "mu",
      "sigma",
      "xi"
    ]
  },
  "Chi": {
    "chi_dist": [
      "nu",
      "size"
    ],
    "__new__": [
      "cls",
      "name",
      "nu"
    ],
    "dist": [
      "cls",
      "nu"
    ]
  },
  "Maxwell": {
    "maxwell_dist": [
      "a",
      "size"
    ],
    "__new__": [
      "cls",
      "name",
      "a"
    ],
    "dist": [
      "cls",
      "a"
    ]
  },
  "log1mexp": [
    "x"
  ],
  "GeneralizedPoissonRV": {
    "name": [],
    "signature": [],
    "dtype": [],
    "_print_name": [],
    "rng_fn": [
      "cls",
      "rng",
      "theta",
      "lam",
      "size"
    ],
    "_inverse_rng_fn": [
      "cls",
      "rng",
      "theta",
      "lam",
      "dist_size",
      "idxs_mask"
    ],
    "_branching_rng_fn": [
      "cls",
      "rng",
      "theta",
      "lam",
      "dist_size",
      "idxs_mask"
    ]
  },
  "generalized_poisson": [],
  "GeneralizedPoisson": {
    "rv_op": [],
    "dist": [
      "cls",
      "mu",
      "lam"
    ],
    "support_point": [
      "rv",
      "size",
      "mu",
      "lam"
    ],
    "logp": [
      "value",
      "mu",
      "lam"
    ]
  },
  "BetaNegativeBinomial": {
    "beta_negative_binomial_dist": [
      "alpha",
      "beta",
      "r",
      "size"
    ],
    "beta_negative_binomial_logp": [
      "value",
      "alpha",
      "beta",
      "r"
    ],
    "__new__": [
      "cls",
      "name",
      "alpha",
      "beta",
      "r"
    ],
    "dist": [
      "cls",
      "alpha",
      "beta",
      "r"
    ]
  },
  "Skellam": {
    "skellam_dist": [
      "mu1",
      "mu2",
      "size"
    ],
    "skellam_logp": [
      "value",
      "mu1",
      "mu2"
    ],
    "__new__": [
      "cls",
      "name",
      "mu1",
      "mu2"
    ],
    "dist": [
      "cls",
      "mu1",
      "mu2"
    ]
  },
  "_make_outputs_info": [
    "n_lags",
    "init_dist"
  ],
  "DiscreteMarkovChainRV": {
    "default_output": [],
    "_print_name": [],
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "node"
    ]
  },
  "DiscreteMarkovChain": {
    "rv_type": [],
    "__new__": [
      "cls"
    ],
    "dist": [
      "cls",
      "P",
      "logit_P",
      "steps",
      "init_dist",
      "n_lags"
    ],
    "rv_op": [
      "cls",
      "P",
      "steps",
      "init_dist",
      "n_lags",
      "size"
    ]
  },
  "change_mc_size": [
    "op",
    "dist",
    "new_size",
    "expand"
  ],
  "discrete_mc_moment": [
    "op",
    "rv",
    "P",
    "steps",
    "init_dist",
    "state_rng"
  ],
  "discrete_mc_logp": [
    "op",
    "values",
    "P",
    "steps",
    "init_dist",
    "state_rng"
  ],
  "DiscreteMarkovChainGibbsMetropolis": {
    "name": [],
    "__init__": [
      "self",
      "vars",
      "proposal",
      "order",
      "model",
      "initial_point",
      "compile_kwargs"
    ],
    "competence": [
      "var"
    ]
  },
  "quantile_histogram": [
    "data",
    "n_quantiles",
    "zero_inflation"
  ],
  "discrete_histogram": [
    "data",
    "min_count"
  ],
  "histogram_approximation": [
    "name",
    "dist"
  ],
  "_psivar2musigma": [
    "psi",
    "explained_var",
    "psi_mask"
  ],
  "_R2D2M2CP_beta": [
    "name",
    "output_sigma",
    "input_sigma",
    "r2",
    "phi",
    "psi"
  ],
  "_broadcast_as_dims": [],
  "_psi_masked": [
    "positive_probs",
    "positive_probs_std"
  ],
  "_psi": [
    "positive_probs",
    "positive_probs_std"
  ],
  "_phi": [
    "variables_importance",
    "variance_explained",
    "importance_concentration"
  ],
  "R2D2M2CPOut": [],
  "R2D2M2CP": [
    "name",
    "output_sigma",
    "input_sigma"
  ],
  "dtype_minval": [
    "dtype"
  ],
  "padded_where": [
    "x",
    "to_len",
    "padval"
  ],
  "PartialOrder": {
    "name": [],
    "__init__": [
      "self",
      "adj_mat"
    ],
    "initvals": [
      "self",
      "shape",
      "lower",
      "upper"
    ],
    "backward": [
      "self",
      "value"
    ],
    "forward": [
      "self",
      "value"
    ],
    "log_jac_det": [
      "self",
      "value"
    ]
  },
  "as_model": [],
  "VIP": {
    "variational_parameters": [
      "self"
    ],
    "truncate_lambda": [
      "self"
    ],
    "truncate_all_lambda": [
      "self",
      "value"
    ],
    "get_lambda": [
      "self"
    ],
    "set_lambda": [
      "self"
    ],
    "set_all_lambda": [
      "self",
      "value"
    ],
    "fit": [
      "self"
    ]
  },
  "vip_reparam_node": [
    "op",
    "node",
    "name",
    "dims",
    "transform"
  ],
  "_vip_reparam_node": [
    "op",
    "node",
    "name",
    "dims",
    "transform",
    "lam"
  ],
  "_": [
    "op",
    "node",
    "name",
    "dims",
    "transform",
    "lam"
  ],
  "vip_reparametrize": [
    "model",
    "var_names"
  ],
  "static_shape_ancestors": [
    "vars"
  ],
  "find_conditional_input_rvs": [
    "output_rvs",
    "all_rvs"
  ],
  "is_conditional_dependent": [
    "dependent_rv",
    "dependable_rv",
    "all_rvs"
  ],
  "find_conditional_dependent_rvs": [
    "dependable_rv",
    "all_rvs"
  ],
  "get_support_axes": [
    "op"
  ],
  "_advanced_indexing_axis_and_ndim": [
    "idxs"
  ],
  "DIMS": [],
  "VAR_DIMS": [],
  "_broadcast_dims": [
    "inputs_dims"
  ],
  "_subgraph_batch_dim_connection": [
    "var_dims",
    "input_vars",
    "output_vars"
  ],
  "subgraph_batch_dim_connection": [
    "input_var",
    "output_vars"
  ],
  "MarginalRV": {
    "__init__": [
      "self"
    ],
    "support_axes": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "support_point_marginal_rv": [
    "op",
    "rv"
  ],
  "MarginalFiniteDiscreteRV": {},
  "MarginalDiscreteMarkovChainRV": {},
  "get_domain_of_finite_discrete_rv": [
    "rv"
  ],
  "reduce_batch_dependent_logps": [
    "dependent_dims_connections",
    "dependent_ops",
    "dependent_logps"
  ],
  "align_logp_dims": [
    "dims",
    "logp"
  ],
  "inline_ofg_outputs": [
    "op",
    "inputs"
  ],
  "NonSeparableLogpWarning": {},
  "warn_non_separable_logp": [
    "values"
  ],
  "DUMMY_ZERO": [],
  "finite_discrete_marginal_rv_logp": [
    "op",
    "values"
  ],
  "marginal_hmm_logp": [
    "op",
    "values"
  ],
  "ModelRVs": [],
  "MarginalModel": {
    "__init__": [
      "self"
    ]
  },
  "_warn_interval_transform": [
    "rv_to_marginalize",
    "replaced_vars"
  ],
  "_unique": [
    "seq"
  ],
  "marginalize": [
    "model",
    "rvs_to_marginalize"
  ],
  "local_unmarginalize": [
    "fgraph",
    "node"
  ],
  "unmarginalize_rewrite": [],
  "unmarginalize": [
    "model",
    "rvs_to_unmarginalize"
  ],
  "transform_posterior_pts": [
    "model",
    "posterior_pts"
  ],
  "recover_marginals": [
    "idata"
  ],
  "collect_shared_vars": [
    "outputs",
    "blockers"
  ],
  "remove_model_vars": [
    "vars"
  ],
  "replace_finite_discrete_marginal_subgraph": [
    "fgraph",
    "rv_to_marginalize",
    "dependent_rvs",
    "input_rvs"
  ],
  "numpy_bspline_basis": [
    "eval_points",
    "k",
    "degree"
  ],
  "BSplineBasis": {
    "__props__": [],
    "__init__": [
      "self",
      "sparse"
    ],
    "make_node": [
      "self"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "output_storage",
      "params"
    ],
    "infer_shape": [
      "self",
      "fgraph",
      "node",
      "ins_shapes"
    ]
  },
  "bspline_basis": [
    "n",
    "k",
    "degree",
    "dtype",
    "sparse"
  ],
  "bspline_interpolation": [
    "x"
  ],
  "EVAL_CG_TOLERANCE": [],
  "CG_TOLERANCE": [],
  "masked_fill": [
    "vector",
    "mask",
    "fill_value"
  ],
  "linear_cg_updates": [
    "result",
    "alpha",
    "residual_inner_prod",
    "eps",
    "beta",
    "residual",
    "precond_residual",
    "curr_conjugate_vec"
  ],
  "linear_cg": [
    "mat",
    "rhs",
    "n_tridiag",
    "tolerance",
    "eps",
    "stop_updating_after",
    "max_iter",
    "max_tridiag_iter",
    "initial_guess",
    "preconditioner",
    "terminate_cg_by_size",
    "use_eval_tolerance"
  ],
  "ParamCfg": {},
  "ShapeInfo": {},
  "VarInfo": {},
  "FlatInfo": {},
  "_arg_to_param_cfg": [
    "key",
    "value"
  ],
  "_parse_args": [
    "var_names"
  ],
  "_flatten": [
    "idata"
  ],
  "_mean_chol": [
    "flat_array"
  ],
  "_mvn_prior_from_flat_info": [
    "name",
    "flat_info"
  ],
  "prior_from_idata": [
    "idata",
    "name"
  ],
  "equal_computations_up_to_root": [
    "xs",
    "ys",
    "ignore_rng_values"
  ],
  "equivalent_models": [
    "model1",
    "model2"
  ],
  "fit": [
    "method"
  ],
  "GradientBackend": [],
  "VALID_BACKENDS": [],
  "set_optimizer_function_defaults": [
    "method",
    "use_grad",
    "use_hess",
    "use_hessp"
  ],
  "_compile_grad_and_hess_to_jax": [
    "f_fused",
    "use_hess",
    "use_hessp"
  ],
  "_compile_functions_for_scipy_optimize": [
    "loss",
    "inputs",
    "compute_grad",
    "compute_hess",
    "compute_hessp",
    "compile_kwargs"
  ],
  "scipy_optimize_funcs_from_loss": [
    "loss",
    "inputs",
    "initial_point_dict",
    "use_grad",
    "use_hess",
    "use_hessp",
    "gradient_backend",
    "compile_kwargs",
    "inputs_are_flat"
  ],
  "get_nearest_psd": [
    "A"
  ],
  "_make_initial_point": [
    "model",
    "initvals",
    "random_seed",
    "jitter_rvs"
  ],
  "_compute_inverse_hessian": [
    "optimizer_result",
    "optimal_point",
    "f_fused",
    "f_hessp",
    "use_hess",
    "method"
  ],
  "find_MAP": [
    "method"
  ],
  "get_conditional_gaussian_approximation": [
    "x",
    "Q",
    "mu",
    "args",
    "model",
    "method",
    "use_jac",
    "use_hess",
    "optimizer_kwargs"
  ],
  "unpack_last_axis": [
    "packed_input",
    "packed_shapes"
  ],
  "draws_from_laplace_approx": [],
  "fit_laplace": [
    "optimize_method"
  ],
  "make_default_labels": [
    "name",
    "shape"
  ],
  "make_unpacked_variable_names": [
    "names",
    "model",
    "var_name_to_model_var"
  ],
  "map_results_to_inference_data": [
    "map_point",
    "model",
    "include_transformed"
  ],
  "add_fit_to_inference_data": [
    "idata",
    "mu",
    "H_inv",
    "model"
  ],
  "add_data_to_inference_data": [
    "idata",
    "progressbar",
    "model",
    "compile_kwargs"
  ],
  "optimizer_result_to_dataset": [
    "result",
    "method",
    "mu",
    "model",
    "var_name_to_model_var"
  ],
  "add_optimizer_result_to_inference_data": [
    "idata",
    "result",
    "method",
    "mu",
    "model",
    "var_name_to_model_var"
  ],
  "fit_dadvi": [
    "model",
    "n_fixed_draws",
    "n_draws",
    "include_transformed",
    "optimizer_method",
    "use_grad",
    "use_hessp",
    "use_hess",
    "gradient_backend",
    "compile_kwargs",
    "random_seed",
    "progressbar"
  ],
  "create_dadvi_graph": [
    "model",
    "n_params",
    "n_fixed_draws",
    "random_seed"
  ],
  "TrainingFn": {
    "__call__": [
      "self",
      "draws"
    ]
  },
  "compile_svi_training_fn": [
    "model",
    "guide",
    "stick_the_landing"
  ],
  "get_logp_logq": [
    "model",
    "guide",
    "stick_the_landing"
  ],
  "advi_objective": [
    "logp",
    "logq"
  ],
  "vectorize_random_graph": [
    "graph",
    "batch_draws"
  ],
  "get_symbolic_rv_shapes": [
    "rvs",
    "raise_if_rvs_in_graph"
  ],
  "AutoGuideModel": {
    "__post_init__": [
      "self"
    ],
    "params": [
      "self"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "stochastic_logq": [
      "self",
      "stick_the_landing"
    ]
  },
  "AutoDiagonalNormal": [
    "model"
  ],
  "logger": [],
  "REGULARISATION_TERM": [],
  "DEFAULT_LINKER": [],
  "get_jaxified_logp_of_ravel_inputs": [
    "model",
    "jacobian"
  ],
  "get_logp_dlogp_of_ravel_inputs": [
    "model",
    "jacobian"
  ],
  "convert_flat_trace_to_idata": [
    "samples",
    "include_transformed",
    "postprocessing_backend",
    "inference_backend",
    "model",
    "importance_sampling"
  ],
  "alpha_recover": [
    "x",
    "g"
  ],
  "inverse_hessian_factors": [
    "alpha",
    "s",
    "z",
    "J"
  ],
  "bfgs_sample_dense": [
    "x",
    "g",
    "alpha",
    "beta",
    "gamma",
    "alpha_diag",
    "inv_sqrt_alpha_diag",
    "sqrt_alpha_diag",
    "u"
  ],
  "bfgs_sample_sparse": [
    "x",
    "g",
    "alpha",
    "beta",
    "gamma",
    "alpha_diag",
    "inv_sqrt_alpha_diag",
    "sqrt_alpha_diag",
    "u"
  ],
  "bfgs_sample": [
    "num_samples",
    "x",
    "g",
    "alpha",
    "beta",
    "gamma",
    "index"
  ],
  "LogLike": {
    "__props__": [],
    "__init__": [
      "self",
      "logp_func"
    ],
    "make_node": [
      "self",
      "inputs"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "outputs"
    ]
  },
  "PathStatus": {
    "SUCCESS": [],
    "ELBO_ARGMAX_AT_ZERO": [],
    "INVALID_LOGP": [],
    "INVALID_LOGQ": [],
    "LBFGS_FAILED": [],
    "PATH_FAILED": []
  },
  "FAILED_PATH_STATUS": [],
  "PathException": {
    "DEFAULT_MESSAGE": [],
    "__init__": [
      "self",
      "message",
      "status"
    ]
  },
  "PathInvalidLogP": {
    "DEFAULT_MESSAGE": [],
    "__init__": [
      "self",
      "message"
    ]
  },
  "PathInvalidLogQ": {
    "DEFAULT_MESSAGE": [],
    "__init__": [
      "self",
      "message"
    ]
  },
  "make_pathfinder_body": [
    "logp_func",
    "num_draws",
    "maxcor",
    "num_elbo_draws"
  ],
  "make_single_pathfinder_fn": [
    "model",
    "num_draws",
    "maxcor",
    "maxiter",
    "ftol",
    "gtol",
    "maxls",
    "num_elbo_draws",
    "jitter",
    "epsilon",
    "pathfinder_kwargs",
    "compile_kwargs"
  ],
  "_calculate_max_workers": [],
  "_thread": [
    "fn",
    "seed"
  ],
  "_process": [
    "fn",
    "seed"
  ],
  "_get_mp_context": [
    "mp_ctx"
  ],
  "_execute_concurrently": [
    "fn",
    "seeds",
    "concurrent",
    "max_workers"
  ],
  "_execute_serially": [
    "fn",
    "seeds"
  ],
  "make_generator": [
    "concurrent",
    "fn",
    "seeds",
    "max_workers"
  ],
  "PathfinderResult": {},
  "PathfinderConfig": {},
  "MultiPathfinderResult": {
    "from_path_results": [
      "cls",
      "path_results"
    ],
    "with_timing": [
      "self",
      "compile_time",
      "compute_time"
    ],
    "with_pathfinder_config": [
      "self",
      "config"
    ],
    "with_warnings": [
      "self",
      "warnings"
    ],
    "with_importance_sampling": [
      "self",
      "num_draws",
      "method",
      "random_seed"
    ],
    "create_summary": [
      "self"
    ],
    "display_summary": [
      "self"
    ]
  },
  "_get_status_warning": [
    "mpr"
  ],
  "multipath_pathfinder": [
    "model",
    "num_paths",
    "num_draws",
    "num_draws_per_path",
    "maxcor",
    "maxiter",
    "ftol",
    "gtol",
    "maxls",
    "num_elbo_draws",
    "jitter",
    "epsilon",
    "importance_sampling",
    "progressbar",
    "concurrent",
    "random_seed",
    "pathfinder_kwargs",
    "compile_kwargs",
    "display_summary"
  ],
  "fit_pathfinder": [
    "model",
    "num_paths",
    "num_draws",
    "num_draws_per_path",
    "maxcor",
    "maxiter",
    "ftol",
    "gtol",
    "maxls",
    "num_elbo_draws",
    "jitter",
    "epsilon",
    "importance_sampling",
    "progressbar",
    "concurrent",
    "random_seed",
    "postprocessing_backend",
    "inference_backend",
    "pathfinder_kwargs",
    "compile_kwargs",
    "initvals",
    "add_pathfinder_groups",
    "display_summary",
    "store_diagnostics",
    "pathfinder_group",
    "paths_group",
    "diagnostics_group",
    "config_group"
  ],
  "LBFGSHistory": {
    "__post_init__": [
      "self"
    ]
  },
  "LBFGSHistoryManager": {
    "__post_init__": [
      "self"
    ],
    "add_entry": [
      "self",
      "x",
      "g"
    ],
    "get_history": [
      "self"
    ],
    "entry_condition_met": [
      "self",
      "x",
      "value",
      "grad"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "LBFGSStatus": {
    "CONVERGED": [],
    "MAX_ITER_REACHED": [],
    "NON_FINITE": [],
    "LOW_UPDATE_PCT": [],
    "INIT_FAILED": [],
    "INIT_FAILED_LOW_UPDATE_PCT": [],
    "LBFGS_FAILED": []
  },
  "LBFGSException": {
    "DEFAULT_MESSAGE": [],
    "__init__": [
      "self",
      "message",
      "status"
    ]
  },
  "LBFGSInitFailed": {
    "DEFAULT_MESSAGE": [],
    "__init__": [
      "self",
      "status",
      "message"
    ]
  },
  "LBFGS": {
    "__init__": [
      "self",
      "value_grad_fn",
      "maxcor",
      "maxiter",
      "ftol",
      "gtol",
      "maxls",
      "epsilon"
    ],
    "minimize": [
      "self",
      "x0"
    ]
  },
  "ImportanceSamplingResult": {},
  "importance_sampling": [
    "samples",
    "logP",
    "logQ",
    "num_draws",
    "method",
    "random_seed"
  ],
  "get_param_coords": [
    "model",
    "n_params"
  ],
  "_status_counter_to_dataarray": [
    "counter",
    "status_enum_cls"
  ],
  "_extract_scalar": [
    "value"
  ],
  "pathfinder_result_to_xarray": [
    "result",
    "model"
  ],
  "multipathfinder_result_to_xarray": [
    "result",
    "model"
  ],
  "_add_summary_data": [
    "result",
    "data_vars",
    "coords",
    "attrs"
  ],
  "_add_paths_data": [
    "result",
    "data_vars",
    "coords",
    "param_coords",
    "n_params"
  ],
  "_add_config_data": [
    "config",
    "data_vars"
  ],
  "_add_diagnostics_data": [
    "result",
    "data_vars",
    "coords",
    "param_coords"
  ],
  "_determine_num_paths": [
    "result"
  ],
  "add_pathfinder_to_inference_data": [
    "idata",
    "result",
    "model"
  ],
  "log": [],
  "sample_smc_blackjax": [
    "n_particles",
    "random_seed",
    "kernel",
    "target_essn",
    "num_mcmc_steps",
    "inner_kernel_params",
    "model",
    "iterations_to_diagnose"
  ],
  "arviz_from_particles": [
    "model",
    "particles"
  ],
  "SMCDiagnostics": {
    "update_diagnosis": [
      "i",
      "history",
      "info",
      "state"
    ],
    "initial_diagnosis": [
      "iterations_to_diagnose",
      "n_particles"
    ]
  },
  "flatten_single_particle": [
    "particle"
  ],
  "inference_loop": [
    "rng_key",
    "initial_state",
    "kernel",
    "iterations_to_diagnose",
    "n_particles"
  ],
  "blackjax_particles_from_pymc_population": [
    "model",
    "pymc_population"
  ],
  "add_to_inference_data": [
    "inference_data",
    "n_particles",
    "target_ess",
    "num_mcmc_steps",
    "kernel",
    "diagnosis",
    "total_iterations",
    "iterations_to_diagnose",
    "kernel_parameters",
    "running_time_seconds"
  ],
  "get_jaxified_logprior": [
    "model"
  ],
  "get_jaxified_loglikelihood": [
    "model"
  ],
  "get_jaxified_particles_fn": [
    "model",
    "graph_outputs"
  ],
  "initialize_population": [
    "model",
    "draws",
    "random_seed"
  ],
  "var_map_from_model": [
    "model",
    "initial_point"
  ],
  "build_smc_with_kernel": [
    "prior_log_prob",
    "loglikelihood",
    "target_ess",
    "num_mcmc_steps",
    "kernel_parameters",
    "mcmc_kernel"
  ],
  "StandardScalerDF": {
    "__init__": [
      "self",
      "with_mean",
      "with_std"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "cleanup_states": [
    "states"
  ],
  "make_harvey_state_names": [
    "p",
    "d",
    "q",
    "P",
    "D",
    "Q",
    "S"
  ],
  "make_SARIMA_transition_matrix": [
    "p",
    "d",
    "q",
    "P",
    "D",
    "Q",
    "S"
  ],
  "conform_time_varying_and_time_invariant_matrices": [
    "A",
    "B"
  ],
  "normalize_axis": [
    "x",
    "axis"
  ],
  "reorder_from_labels": [
    "x",
    "labels",
    "ordered_labels",
    "labeled_axis"
  ],
  "pad_and_reorder": [
    "x",
    "labels",
    "ordered_labels",
    "labeled_axis"
  ],
  "ndim_pad_and_reorder": [
    "x",
    "labels",
    "ordered_labels",
    "labeled_axis"
  ],
  "add_tensors_by_dim_labels": [
    "tensor",
    "other_tensor",
    "labels",
    "other_labels",
    "labeled_axis"
  ],
  "join_tensors_by_dim_labels": [
    "tensor",
    "other_tensor",
    "labels",
    "other_labels",
    "labeled_axis",
    "join_axis",
    "block_diag_join"
  ],
  "get_exog_dims_from_idata": [
    "exog_name",
    "idata"
  ],
  "validate_names": [
    "names",
    "var_name",
    "optional"
  ],
  "floatX": [],
  "BayesianVARMAX": {
    "__init__": [
      "self",
      "order",
      "endog_names",
      "exog_state_names",
      "stationary_initialization",
      "filter_type",
      "measurement_error",
      "verbose",
      "mode"
    ],
    "set_parameters": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "default_priors": [
      "self"
    ],
    "add_default_priors": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "BayesianETS": {
    "__init__": [
      "self",
      "order",
      "endog_names",
      "trend",
      "damped_trend",
      "seasonal",
      "seasonal_periods",
      "measurement_error",
      "use_transformed_parameterization",
      "dense_innovation_covariance",
      "stationary_initialization",
      "initialization_dampening",
      "filter_type",
      "verbose",
      "mode"
    ],
    "set_parameters": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "_stationary_initialization": [
      "self",
      "T_stationary"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "_verify_order": [
    "p",
    "d",
    "q",
    "P",
    "D",
    "Q",
    "S"
  ],
  "BayesianSARIMAX": {
    "__init__": [
      "self",
      "order",
      "seasonal_order",
      "exog_state_names",
      "stationary_initialization",
      "filter_type",
      "state_structure",
      "measurement_error",
      "verbose",
      "mode"
    ],
    "set_parameters": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "_stationary_initialization": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "BayesianDynamicFactor": {
    "__init__": [
      "self",
      "k_factors",
      "factor_order",
      "endog_names",
      "exog_names",
      "shared_exog_states",
      "exog_innovations",
      "error_order",
      "error_var",
      "error_cov_type",
      "measurement_error",
      "verbose"
    ],
    "set_parameters": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "order_to_mask": [
    "order"
  ],
  "_frequency_transition_block": [
    "s",
    "j"
  ],
  "StructuralTimeSeries": {
    "__init__": [
      "self",
      "ssm",
      "name",
      "coords_info",
      "param_info",
      "data_info",
      "shock_info",
      "state_info",
      "tensor_variable_info",
      "tensor_data_info",
      "component_info",
      "measurement_error",
      "verbose",
      "filter_type",
      "mode"
    ],
    "_init_info_objects": [
      "self",
      "param_info",
      "data_info",
      "shock_info",
      "state_info",
      "coords_info",
      "k_states",
      "k_endog"
    ],
    "_init_stripped_names": [
      "self",
      "k_endog"
    ],
    "_init_ssm": [
      "self",
      "ssm",
      "k_posdef"
    ],
    "_populate_properties": [
      "self"
    ],
    "_strip_data_names_if_unambiguous": [
      "self",
      "names",
      "k_endog"
    ],
    "state_names": [
      "self"
    ],
    "shock_names": [
      "self"
    ],
    "_add_inital_state_cov_to_properties": [
      "param_info",
      "k_states"
    ],
    "make_symbolic_graph": [
      "self"
    ],
    "_state_slices_from_info": [
      "self"
    ],
    "_hidden_states_from_data": [
      "self",
      "data"
    ],
    "_get_subcomponent_names": [
      "self"
    ],
    "extract_components_from_idata": [
      "self",
      "idata"
    ]
  },
  "Component": {
    "__init__": [
      "self",
      "name",
      "k_endog",
      "k_states",
      "k_posdef",
      "base_state_names",
      "base_observed_state_names",
      "representation",
      "measurement_error",
      "combine_hidden_states",
      "component_from_sum",
      "obs_state_idxs",
      "share_states"
    ],
    "_init_ssm": [
      "self",
      "representation",
      "k_endog",
      "k_states",
      "k_posdef"
    ],
    "populate_component_properties": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "_set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "_set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "_set_shocks": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "_set_data_info": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "_set_coords": [
      "self"
    ],
    "state_names": [
      "self"
    ],
    "observed_state_names": [
      "self"
    ],
    "param_names": [
      "self"
    ],
    "param_info": [
      "self"
    ],
    "shock_names": [
      "self"
    ],
    "data_names": [
      "self"
    ],
    "exog_names": [
      "self"
    ],
    "coords": [
      "self"
    ],
    "param_dims": [
      "self"
    ],
    "needs_exog_data": [
      "self"
    ],
    "k_states": [
      "self"
    ],
    "k_endog": [
      "self"
    ],
    "k_posdef": [
      "self"
    ],
    "_name_to_variable": [
      "self"
    ],
    "_name_to_data": [
      "self"
    ],
    "make_and_register_variable": [
      "self",
      "name",
      "shape",
      "dtype"
    ],
    "make_and_register_data": [
      "self",
      "name",
      "shape",
      "dtype"
    ],
    "make_symbolic_graph": [
      "self"
    ],
    "_get_combined_shapes": [
      "self",
      "other"
    ],
    "_combine_statespace_representations": [
      "self",
      "other"
    ],
    "_combine_component_info": [
      "self",
      "other"
    ],
    "_make_combined_name": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "build": [
      "self",
      "name",
      "filter_type",
      "verbose",
      "mode"
    ]
  },
  "_DEPRECATED_NAMES": [],
  "Autoregressive": {
    "__init__": [
      "self",
      "order",
      "name",
      "observed_state_names",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "Regression": {
    "__init__": [
      "self",
      "name",
      "state_names",
      "observed_state_names",
      "innovations",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "MeasurementError": {
    "__init__": [
      "self",
      "name",
      "observed_state_names",
      "share_states"
    ],
    "set_parameters": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "LevelTrend": {
    "__init__": [
      "self",
      "order",
      "innovations_order",
      "name",
      "observed_state_names",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "Cycle": {
    "__init__": [
      "self",
      "name",
      "cycle_length",
      "estimate_cycle_length",
      "dampen",
      "innovations",
      "observed_state_names",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "TimeSeasonality": {
    "__init__": [
      "self",
      "season_length",
      "duration",
      "innovations",
      "name",
      "state_names",
      "remove_first_state",
      "observed_state_names",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "FrequencySeasonality": {
    "__init__": [
      "self",
      "season_length",
      "n",
      "name",
      "innovations",
      "observed_state_names",
      "share_states"
    ],
    "set_states": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "make_symbolic_graph": [
      "self"
    ]
  },
  "ALL_STATE_DIM": [],
  "ALL_STATE_AUX_DIM": [],
  "OBS_STATE_DIM": [],
  "OBS_STATE_AUX_DIM": [],
  "SHOCK_DIM": [],
  "SHOCK_AUX_DIM": [],
  "TIME_DIM": [],
  "AR_PARAM_DIM": [],
  "MA_PARAM_DIM": [],
  "SEASONAL_AR_PARAM_DIM": [],
  "SEASONAL_MA_PARAM_DIM": [],
  "ETS_SEASONAL_DIM": [],
  "FACTOR_DIM": [],
  "ERROR_AR_PARAM_DIM": [],
  "EXOG_STATE_DIM": [],
  "NEVER_TIME_VARYING": [],
  "VECTOR_VALUED": [],
  "MISSING_FILL": [],
  "JITTER_DEFAULT": [],
  "FILTER_OUTPUT_TYPES": [],
  "MATRIX_NAMES": [],
  "LONG_MATRIX_NAMES": [],
  "SHORT_NAME_TO_LONG": [],
  "LONG_NAME_TO_SHORT": [],
  "FILTER_OUTPUT_NAMES": [],
  "SMOOTHER_OUTPUT_NAMES": [],
  "OBSERVED_OUTPUT_NAMES": [],
  "MATRIX_DIMS": [],
  "FILTER_OUTPUT_DIMS": [],
  "POSITION_DERIVATIVE_NAMES": [],
  "SARIMAX_STATE_STRUCTURES": [],
  "NO_TIME_INDEX_WARNING": [],
  "NO_FREQ_INFO_WARNING": [],
  "get_data_dims": [
    "data"
  ],
  "_validate_data_shape": [
    "data_shape",
    "n_obs",
    "obs_coords",
    "check_col_names",
    "col_names"
  ],
  "preprocess_tensor_data": [
    "data",
    "n_obs",
    "obs_coords"
  ],
  "preprocess_numpy_data": [
    "data",
    "n_obs",
    "obs_coords"
  ],
  "preprocess_pandas_data": [
    "data",
    "n_obs",
    "obs_coords",
    "check_column_names"
  ],
  "add_data_to_active_model": [
    "values",
    "index",
    "data_dims"
  ],
  "mask_missing_values_in_data": [
    "values",
    "missing_fill_value"
  ],
  "register_data_with_pymc": [
    "data",
    "n_obs",
    "obs_coords",
    "register_data",
    "missing_fill_value",
    "data_dims"
  ],
  "KalmanSmoother": {
    "__init__": [
      "self"
    ],
    "unpack_args": [
      "self",
      "args"
    ],
    "build_graph": [
      "self",
      "T",
      "R",
      "Q",
      "filtered_states",
      "filtered_covariances",
      "cov_jitter"
    ],
    "smoother_step": [
      "self"
    ],
    "predict": [
      "self",
      "a",
      "P",
      "T",
      "R",
      "Q"
    ]
  },
  "MVN_CONST": [],
  "PARAM_NAMES": [],
  "assert_time_varying_dim_correct": [],
  "BaseFilter": {
    "__init__": [
      "self"
    ],
    "check_params": [
      "self",
      "data",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q"
    ],
    "add_check_on_time_varying_shapes": [
      "data",
      "sequence_params"
    ],
    "unpack_args": [
      "self",
      "args"
    ],
    "build_graph": [
      "self",
      "data",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q",
      "missing_fill_value",
      "cov_jitter"
    ],
    "_postprocess_scan_results": [
      "self",
      "results",
      "a0",
      "P0",
      "n"
    ],
    "handle_missing_values": [
      "self",
      "y",
      "Z",
      "H"
    ],
    "predict": [
      "a",
      "P",
      "c",
      "T",
      "R",
      "Q"
    ],
    "update": [
      "a",
      "P",
      "y",
      "d",
      "Z",
      "H",
      "all_nan_flag"
    ],
    "kalman_step": [
      "self"
    ]
  },
  "StandardFilter": {
    "update": [
      "self",
      "a",
      "P",
      "y",
      "d",
      "Z",
      "H",
      "all_nan_flag"
    ]
  },
  "SquareRootFilter": {
    "predict": [
      "self",
      "a",
      "P",
      "c",
      "T",
      "R",
      "Q"
    ],
    "update": [
      "self",
      "a",
      "P",
      "y",
      "d",
      "Z",
      "H",
      "all_nan_flag"
    ],
    "_postprocess_scan_results": [
      "self",
      "results",
      "a0",
      "P0",
      "n"
    ]
  },
  "UnivariateFilter": {
    "_univariate_inner_filter_step": [
      "self",
      "y",
      "Z_row",
      "d_row",
      "sigma_H",
      "nan_flag",
      "a",
      "P"
    ],
    "kalman_step": [
      "self",
      "y",
      "a",
      "P",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q"
    ]
  },
  "decide_if_x_time_varies": [
    "x",
    "name"
  ],
  "split_vars_into_seq_and_nonseq": [
    "params",
    "param_names"
  ],
  "stabilize": [
    "cov",
    "jitter"
  ],
  "quad_form_sym": [
    "A",
    "B"
  ],
  "COV_ZERO_TOL": [],
  "lgss_shape_message": [],
  "make_signature": [
    "sequence_names"
  ],
  "LinearGaussianStateSpaceRV": {
    "default_output": [],
    "_print_name": [],
    "update": [
      "self",
      "node"
    ]
  },
  "_LinearGaussianStateSpace": {
    "__new__": [
      "cls",
      "name",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q",
      "steps",
      "sequence_names",
      "append_x0",
      "method"
    ],
    "dist": [
      "cls",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q",
      "steps",
      "sequence_names",
      "append_x0",
      "method"
    ],
    "rv_op": [
      "cls",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q",
      "steps",
      "size",
      "rng",
      "sequence_names",
      "append_x0",
      "method"
    ]
  },
  "LinearGaussianStateSpace": {
    "__new__": [
      "cls",
      "name",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q"
    ],
    "dist": [
      "cls",
      "a0",
      "P0",
      "c",
      "d",
      "T",
      "Z",
      "R",
      "H",
      "Q"
    ],
    "_get_k_states": [
      "cls",
      "T"
    ],
    "_get_k_endog": [
      "cls",
      "H"
    ]
  },
  "KalmanFilterRV": {
    "default_output": [],
    "_print_name": [],
    "extended_signature": [],
    "update": [
      "self",
      "node"
    ]
  },
  "SequenceMvNormal": {
    "__new__": [
      "cls"
    ],
    "dist": [
      "cls",
      "mus",
      "covs",
      "logp",
      "method"
    ],
    "rv_op": [
      "cls",
      "mus",
      "covs",
      "logp",
      "method",
      "size",
      "rng"
    ]
  },
  "sequence_mvnormal_logp": [
    "op",
    "values",
    "mus",
    "covs",
    "logp",
    "rng"
  ],
  "StateSpaceLike": {
    "state_names": [
      "self"
    ],
    "observed_states": [
      "self"
    ],
    "shock_names": [
      "self"
    ]
  },
  "Property": {
    "__str__": [
      "self"
    ]
  },
  "T": [],
  "Info": {
    "__post_init__": [
      "self"
    ],
    "_key": [
      "self",
      "item"
    ],
    "get": [
      "self",
      "key",
      "default"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__contains__": [
      "self",
      "key"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "add": [
      "self",
      "new_item"
    ],
    "merge": [
      "self",
      "other",
      "overwrite_duplicates"
    ],
    "names": [
      "self"
    ],
    "copy": [
      "self"
    ]
  },
  "Parameter": {},
  "ParameterInfo": {
    "__init__": [
      "self",
      "parameters"
    ],
    "to_dict": [
      "self"
    ]
  },
  "Data": {},
  "DataInfo": {
    "__init__": [
      "self",
      "data"
    ],
    "needs_exogenous_data": [
      "self"
    ],
    "exogenous_names": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "to_dict": [
      "self"
    ]
  },
  "Coord": {},
  "CoordInfo": {
    "__init__": [
      "self",
      "coords"
    ],
    "__str__": [
      "self"
    ],
    "default_coords_from_model": [
      "cls",
      "model"
    ],
    "to_dict": [
      "self"
    ]
  },
  "State": {},
  "StateInfo": {
    "__init__": [
      "self",
      "states"
    ],
    "__contains__": [
      "self",
      "key"
    ],
    "__str__": [
      "self"
    ],
    "observed_state_names": [
      "self"
    ],
    "unobserved_state_names": [
      "self"
    ]
  },
  "Shock": {},
  "ShockInfo": {
    "__init__": [
      "self",
      "shocks"
    ]
  },
  "SymbolicVariable": {},
  "SymbolicVariableInfo": {
    "__init__": [
      "self",
      "symbolic_variables"
    ],
    "to_dict": [
      "self"
    ]
  },
  "SymbolicData": {},
  "SymbolicDataInfo": {
    "__init__": [
      "self",
      "symbolic_data"
    ],
    "to_dict": [
      "self"
    ]
  },
  "compile_statespace": [
    "statespace_model",
    "steps"
  ],
  "FILTER_FACTORY": [],
  "_validate_filter_arg": [
    "filter_arg"
  ],
  "_verify_group": [
    "group"
  ],
  "_validate_property": [
    "props",
    "property_name",
    "expected_type"
  ],
  "PyMCStateSpace": {
    "__init__": [
      "self",
      "k_endog",
      "k_states",
      "k_posdef",
      "filter_type",
      "verbose",
      "measurement_error",
      "mode"
    ],
    "_populate_properties": [
      "self"
    ],
    "set_parameters": [
      "self"
    ],
    "_set_parameters": [
      "self"
    ],
    "set_states": [
      "self"
    ],
    "_set_states": [
      "self"
    ],
    "set_shocks": [
      "self"
    ],
    "_set_shocks": [
      "self"
    ],
    "default_coords": [
      "self"
    ],
    "set_coords": [
      "self"
    ],
    "_set_coords": [
      "self"
    ],
    "set_data_info": [
      "self"
    ],
    "_set_data_info": [
      "self"
    ],
    "_populate_prior_requirements": [
      "self"
    ],
    "_populate_data_requirements": [
      "self"
    ],
    "_initialize_requirement_table": [
      "self"
    ],
    "_unpack_statespace_with_placeholders": [
      "self"
    ],
    "unpack_statespace": [
      "self"
    ],
    "param_names": [
      "self"
    ],
    "data_names": [
      "self"
    ],
    "param_info": [
      "self"
    ],
    "data_info": [
      "self"
    ],
    "state_names": [
      "self"
    ],
    "observed_states": [
      "self"
    ],
    "shock_names": [
      "self"
    ],
    "default_priors": [
      "self"
    ],
    "coords": [
      "self"
    ],
    "param_dims": [
      "self"
    ],
    "_name_to_variable": [
      "self"
    ],
    "_name_to_data": [
      "self"
    ],
    "add_default_priors": [
      "self"
    ],
    "make_and_register_variable": [
      "self",
      "name",
      "shape",
      "dtype"
    ],
    "make_and_register_data": [
      "self",
      "name",
      "shape",
      "dtype"
    ],
    "make_symbolic_graph": [
      "self"
    ],
    "_get_matrix_shape_and_dims": [
      "self",
      "name"
    ],
    "_save_exogenous_data_info": [
      "self"
    ],
    "_insert_random_variables": [
      "self"
    ],
    "_insert_data_variables": [
      "self"
    ],
    "_register_matrices_with_pymc_model": [
      "self"
    ],
    "_register_kalman_filter_outputs_with_pymc_model": [
      "outputs"
    ],
    "build_statespace_graph": [
      "self",
      "data",
      "register_data",
      "missing_fill_value",
      "cov_jitter",
      "mvn_method",
      "save_kalman_filter_outputs_in_idata",
      "mode"
    ],
    "_build_smoother_graph": [
      "self",
      "filtered_states",
      "filtered_covariances",
      "matrices",
      "mode",
      "cov_jitter"
    ],
    "_build_dummy_graph": [
      "self"
    ],
    "_kalman_filter_outputs_from_dummy_graph": [
      "self",
      "data",
      "data_dims",
      "scenario"
    ],
    "_sample_conditional": [
      "self",
      "idata",
      "group",
      "random_seed",
      "data",
      "mvn_method"
    ],
    "_sample_unconditional": [
      "self",
      "idata",
      "group",
      "steps",
      "use_data_time_dim",
      "random_seed",
      "mvn_method"
    ],
    "sample_conditional_prior": [
      "self",
      "idata",
      "random_seed",
      "mvn_method"
    ],
    "sample_conditional_posterior": [
      "self",
      "idata",
      "random_seed",
      "mvn_method"
    ],
    "sample_unconditional_prior": [
      "self",
      "idata",
      "steps",
      "use_data_time_dim",
      "random_seed",
      "mvn_method"
    ],
    "sample_unconditional_posterior": [
      "self",
      "idata",
      "steps",
      "use_data_time_dim",
      "random_seed",
      "mvn_method"
    ],
    "sample_statespace_matrices": [
      "self",
      "idata",
      "matrix_names",
      "group"
    ],
    "sample_filter_outputs": [
      "self",
      "idata",
      "filter_output_names",
      "group"
    ],
    "_validate_forecast_args": [
      "time_index",
      "start",
      "periods",
      "end",
      "scenario",
      "use_scenario_index",
      "verbose"
    ],
    "_get_fit_time_index": [
      "self"
    ],
    "_validate_scenario_data": [
      "self",
      "scenario",
      "name",
      "verbose"
    ],
    "_build_forecast_index": [
      "time_index",
      "start",
      "end",
      "periods",
      "use_scenario_index",
      "scenario"
    ],
    "_finalize_scenario_initialization": [
      "self",
      "scenario",
      "forecast_index",
      "name"
    ],
    "_build_forecast_model": [
      "self",
      "time_index",
      "t0",
      "forecast_index",
      "scenario",
      "filter_output",
      "mvn_method"
    ],
    "forecast": [
      "self",
      "idata",
      "start",
      "periods",
      "end",
      "scenario",
      "use_scenario_index",
      "filter_output",
      "random_seed",
      "verbose",
      "mvn_method"
    ],
    "impulse_response_function": [
      "self",
      "idata",
      "n_steps",
      "use_posterior_cov",
      "shock_size",
      "shock_cov",
      "shock_trajectory",
      "orthogonalize_shocks",
      "random_seed",
      "mvn_method"
    ],
    "_sort_obs_inputs_by_time_varying": [
      "self",
      "d",
      "Z"
    ],
    "_sort_obs_scan_args": [
      "args"
    ]
  },
  "KeyLike": [],
  "PytensorRepresentation": {
    "__slots__": [],
    "__init__": [
      "self",
      "k_endog",
      "k_states",
      "k_posdef",
      "design",
      "obs_intercept",
      "obs_cov",
      "transition",
      "state_intercept",
      "selection",
      "state_cov",
      "initial_state",
      "initial_state_cov"
    ],
    "_validate_key": [
      "self",
      "key"
    ],
    "_update_shape": [
      "self",
      "key",
      "value"
    ],
    "_add_time_dim_to_slice": [
      "self",
      "name",
      "slice_",
      "n_dim"
    ],
    "_validate_key_and_get_type": [
      "key"
    ],
    "_validate_matrix_shape": [
      "self",
      "name",
      "X"
    ],
    "_check_provided_tensor": [
      "self",
      "name",
      "X"
    ],
    "_numpy_to_pytensor": [
      "self",
      "name",
      "X"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__setitem__": [
      "self",
      "key",
      "value"
    ],
    "copy": [
      "self"
    ]
  }
}