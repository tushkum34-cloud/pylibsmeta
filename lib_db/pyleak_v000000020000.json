{
  "_logger": [],
  "TaskState": {
    "RUNNING": [],
    "CANCELLED": [],
    "DONE": []
  },
  "LeakedTask": {
    "from_task": [
      "cls",
      "task"
    ],
    "format_current_stack": [
      "self"
    ],
    "format_creation_stack": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "TaskLeakError": {
    "__init__": [
      "self",
      "message",
      "leaked_tasks"
    ],
    "get_stack_summary": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "_TaskStackCapture": {
    "capture_current_stack": [
      "task"
    ],
    "capture_creation_stack": [],
    "get_task_creation_stack": [
      "task"
    ]
  },
  "_TaskLeakDetector": {
    "_get_resource_name": [
      "self",
      "task"
    ],
    "get_running_resources": [
      "self",
      "exclude_current"
    ],
    "_is_resource_active": [
      "self",
      "task"
    ],
    "handle_leaked_resources": [
      "self",
      "leaked_resources"
    ],
    "leak_error_class": [
      "self"
    ],
    "resource_type": [
      "self"
    ],
    "_handle_cancel_action": [
      "self",
      "leaked_tasks",
      "task_names"
    ]
  },
  "_AsyncTaskLeakContextManager": {
    "__init__": [
      "self",
      "action",
      "name_filter",
      "logger",
      "enable_creation_tracking"
    ],
    "_create_detector": [
      "self"
    ],
    "enable_task_creation_tracking": [
      "self"
    ],
    "disable_task_creation_tracking": [
      "self"
    ],
    "_wait_for_completion": [
      "self"
    ],
    "__aenter__": [
      "self"
    ],
    "__aexit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "__enter__": [
      "self"
    ],
    "__call__": [
      "self",
      "func"
    ]
  },
  "no_task_leaks": [
    "action",
    "name_filter",
    "logger"
  ],
  "_this_file_path": [],
  "EventLoopBlock": {
    "format_blocking_stack": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "EventLoopBlockError": {
    "__init__": [
      "self",
      "message",
      "blocking_events"
    ],
    "get_block_summary": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "_ThreadWithException": {
    "__init__": [
      "self"
    ],
    "run": [
      "self"
    ]
  },
  "_EventLoopBlockDetector": {
    "__init__": [
      "self",
      "action",
      "logger"
    ],
    "_get_resource_name": [
      "self",
      "_"
    ],
    "get_running_resources": [
      "self",
      "exclude_current"
    ],
    "_is_resource_active": [
      "self",
      "block_info"
    ],
    "leak_error_class": [
      "self"
    ],
    "resource_type": [
      "self"
    ],
    "_handle_cancel_action": [
      "self",
      "leaked_resources",
      "resource_names"
    ],
    "_capture_main_thread_stack": [
      "self"
    ],
    "_matches_caller": [
      "self",
      "stack"
    ],
    "start_monitoring": [
      "self"
    ],
    "stop_monitoring": [
      "self"
    ],
    "_set_future_result": [
      "future"
    ],
    "_monitor_loop": [
      "self"
    ],
    "_add_block": [
      "self",
      "duration",
      "blocking_stack"
    ],
    "_stacks_are_same": [
      "self",
      "stack1",
      "stack2"
    ],
    "handle_detected_blocks": [
      "self"
    ],
    "_handle_single_block": [
      "self",
      "block_info"
    ],
    "get_summary": [
      "self"
    ]
  },
  "_EventLoopBlockContextManager": {
    "__init__": [
      "self",
      "action",
      "logger"
    ],
    "_get_caller_context": [
      "self"
    ],
    "_create_detector": [
      "self",
      "caller_context"
    ],
    "_wait_for_completion": [
      "self"
    ],
    "_get_schedule_callback": [],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ],
    "__aenter__": [
      "self"
    ],
    "__aexit__": [
      "self"
    ],
    "__call__": [
      "self",
      "func"
    ]
  },
  "no_event_loop_blocking": [
    "action",
    "logger"
  ],
  "LeakAction": {
    "WARN": [],
    "LOG": [],
    "CANCEL": [],
    "RAISE": []
  },
  "LeakError": {},
  "PyleakExceptionGroup": {
    "__init__": [
      "self",
      "message",
      "leak_errors"
    ]
  },
  "_BaseLeakDetector": {
    "__init__": [
      "self",
      "action",
      "name_filter",
      "logger"
    ],
    "_matches_filter": [
      "self",
      "resource_name"
    ],
    "_get_resource_name": [
      "self",
      "resource"
    ],
    "get_running_resources": [
      "self",
      "exclude_current"
    ],
    "_is_resource_active": [
      "self",
      "resource"
    ],
    "leak_error_class": [
      "self"
    ],
    "resource_type": [
      "self"
    ],
    "_handle_cancel_action": [
      "self",
      "leaked_resources",
      "resource_names"
    ],
    "get_leaked_resources": [
      "self",
      "initial_resources"
    ],
    "handle_leaked_resources": [
      "self",
      "leaked_resources"
    ]
  },
  "_BaseLeakContextManager": {
    "__init__": [
      "self",
      "action",
      "name_filter",
      "logger"
    ],
    "_create_detector": [
      "self"
    ],
    "_wait_for_completion": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "_enter_context": [
      "self"
    ],
    "_exit_context": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "__aenter__": [
      "self"
    ],
    "__aexit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "setup_logger": [
    "name"
  ],
  "CallerContext": {
    "__str__": [
      "self"
    ]
  },
  "_pyleak_src_dir": [],
  "_is_user_file": [
    "filename"
  ],
  "find_my_caller": [
    "ignore_frames"
  ],
  "should_monitor_test": [
    "item"
  ],
  "pytest_runtest_call": [
    "item"
  ],
  "__all__": [],
  "DEFAULT_THREAD_NAME_FILTER": [],
  "ThreadLeakError": {},
  "_ThreadLeakDetector": {
    "__init__": [
      "self",
      "action",
      "name_filter",
      "logger",
      "exclude_daemon"
    ],
    "_get_resource_name": [
      "self",
      "thread"
    ],
    "get_running_resources": [
      "self",
      "exclude_current"
    ],
    "_is_resource_active": [
      "self",
      "thread"
    ],
    "leak_error_class": [
      "self"
    ],
    "resource_type": [
      "self"
    ],
    "_handle_cancel_action": [
      "self",
      "leaked_threads",
      "thread_names"
    ]
  },
  "_ThreadLeakContextManager": {
    "__init__": [
      "self",
      "action",
      "name_filter",
      "logger",
      "exclude_daemon",
      "grace_period"
    ],
    "_create_detector": [
      "self"
    ],
    "_wait_for_completion": [
      "self"
    ],
    "__call__": [
      "self",
      "func"
    ]
  },
  "no_thread_leaks": [
    "action",
    "name_filter",
    "logger",
    "exclude_daemon",
    "grace_period"
  ],
  "PyLeakConfig": {
    "from_marker_args": [
      "cls",
      "marker_args"
    ],
    "to_markdown_table": [
      "self"
    ]
  },
  "CombinedLeakDetector": {
    "__init__": [
      "self",
      "config",
      "is_async",
      "caller_context"
    ],
    "__aenter__": [
      "self"
    ],
    "__aexit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  }
}