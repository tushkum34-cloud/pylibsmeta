{
  "PROJECT_DIR": [],
  "project": [],
  "copyright": [],
  "author": [],
  "version": [],
  "extensions": [],
  "intersphinx_mapping": [],
  "autoapi_dirs": [],
  "autoapi_type": [],
  "autoapi_add_toctree_entry": [],
  "autoapi_options": [],
  "autodoc_typehints": [],
  "templates_path": [],
  "exclude_patterns": [],
  "html_theme": [],
  "html_theme_options": [],
  "html_static_path": [],
  "html_title": [],
  "html_logo": [],
  "html_css_files": [],
  "autosummary_generate": [],
  "add_module_names": [],
  "source_suffix": [],
  "nb_execution_mode": [],
  "nb_execution_timeout": [],
  "suppress_warnings": [],
  "nb_custom_formats": [],
  "myst_enable_extensions": [],
  "skip_util_classes": [
    "app",
    "what",
    "name",
    "obj",
    "skip",
    "options"
  ],
  "setup": [
    "sphinx"
  ],
  "bibtex_bibfiles": [],
  "bibtex_default_style": [],
  "__all__": [],
  "potential_scale_reduction": [
    "input_array",
    "chain_axis",
    "sample_axis"
  ],
  "effective_sample_size": [
    "input_array",
    "chain_axis",
    "sample_axis"
  ],
  "progress_bar_scan": [
    "num_samples",
    "print_rate"
  ],
  "gen_scan_fn": [
    "num_samples",
    "progress_bar",
    "print_rate"
  ],
  "Position": [],
  "State": [],
  "Info": [],
  "InitFn": {
    "__call__": [
      "self",
      "position",
      "rng_key"
    ]
  },
  "UpdateFn": {
    "__call__": [
      "self",
      "rng_key",
      "state"
    ]
  },
  "SamplingAlgorithm": {},
  "VIAlgorithm": {},
  "RunFn": {
    "__call__": [
      "self",
      "rng_key",
      "position"
    ]
  },
  "AdaptationAlgorithm": {},
  "GenerateSamplingAPI": {
    "__call__": [
      "self"
    ],
    "register_factory": [
      "self",
      "name",
      "callable"
    ]
  },
  "GenerateVariationalAPI": {
    "__call__": [
      "self"
    ]
  },
  "GeneratePathfinderAPI": {
    "__call__": [
      "self"
    ]
  },
  "generate_top_level_api_from": [
    "module"
  ],
  "hmc": [],
  "nuts": [],
  "rmh": [],
  "irmh": [],
  "dynamic_hmc": [],
  "rmhmc": [],
  "mala": [],
  "mgrad_gaussian": [],
  "orbital_hmc": [],
  "additive_step_random_walk": [],
  "mclmc": [],
  "adjusted_mclmc_dynamic": [],
  "adjusted_mclmc": [],
  "elliptical_slice": [],
  "ghmc": [],
  "barker_proposal": [],
  "hmc_family": [],
  "adaptive_persistent_sampling_smc": [],
  "adaptive_tempered_smc": [],
  "tempered_smc": [],
  "inner_kernel_tuning": [],
  "partial_posteriors_smc": [],
  "persistent_sampling_smc": [],
  "pretuning": [],
  "smc_family": [],
  "sgld": [],
  "sghmc": [],
  "sgnht": [],
  "csgld": [],
  "svgd": [],
  "meanfield_vi": [],
  "schrodinger_follmer": [],
  "pathfinder": [],
  "linear_map": [
    "diag_or_dense_a",
    "b"
  ],
  "generate_gaussian_noise": [
    "rng_key",
    "position",
    "mu",
    "sigma"
  ],
  "generate_unit_vector": [
    "rng_key",
    "position"
  ],
  "pytree_size": [
    "pytree"
  ],
  "index_pytree": [
    "input_pytree"
  ],
  "run_inference_algorithm": [
    "rng_key",
    "inference_algorithm",
    "num_steps",
    "initial_state",
    "initial_position",
    "progress_bar",
    "transform"
  ],
  "store_only_expectation_values": [
    "sampling_algorithm",
    "state_transform",
    "incremental_value_transform",
    "burn_in"
  ],
  "safediv": [
    "x",
    "y"
  ],
  "incremental_value_update": [
    "expectation",
    "incremental_val",
    "weight",
    "zero_prevention"
  ],
  "Array": [],
  "ArrayTree": [],
  "ArrayLikeTree": [],
  "PRNGKey": [],
  "Scalar": [],
  "Numeric": [],
  "TYPE_CHECKING": [],
  "__version__": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "__commit_id__": [],
  "commit_id": [],
  "init": [
    "position",
    "logdensity_fn"
  ],
  "build_kernel": [
    "logdensity_fn",
    "integrator",
    "divergence_threshold",
    "inverse_mass_matrix"
  ],
  "as_top_level_api": [
    "logdensity_fn",
    "step_size",
    "L_proposal_factor",
    "inverse_mass_matrix"
  ],
  "adjusted_mclmc_proposal": [
    "integrator",
    "step_size",
    "L_proposal_factor",
    "num_integration_steps",
    "divergence_threshold"
  ],
  "BarkerState": {},
  "BarkerInfo": {},
  "_generate_bernoulli": [
    "rng_key",
    "position",
    "p"
  ],
  "_barker_sample": [
    "key",
    "mean",
    "a",
    "scale",
    "metric"
  ],
  "_log1pexp": [
    "a"
  ],
  "_barker_logpdf": [
    "x",
    "mean",
    "a",
    "scale"
  ],
  "_barker_pdf": [
    "x",
    "mean",
    "a",
    "scale"
  ],
  "PeriodicOrbitalState": {},
  "PeriodicOrbitalInfo": {},
  "periodic_orbital_proposal": [
    "bijection",
    "kinetic_energy_fn",
    "period",
    "step_size"
  ],
  "DiffusionState": {},
  "overdamped_langevin": [
    "logdensity_grad_fn"
  ],
  "KineticEnergy": {
    "__call__": [
      "self",
      "momentum",
      "position"
    ]
  },
  "CheckTurning": {
    "__call__": [
      "self",
      "momentum_left",
      "momentum_right",
      "momentum_sum",
      "position_left",
      "position_right"
    ]
  },
  "Scale": {
    "__call__": [
      "self",
      "position",
      "element"
    ]
  },
  "Metric": {},
  "MetricTypes": [],
  "default_metric": [
    "metric"
  ],
  "gaussian_euclidean": [
    "inverse_mass_matrix"
  ],
  "gaussian_riemannian": [
    "mass_matrix_fn"
  ],
  "_format_covariance": [
    "cov",
    "is_inv"
  ],
  "_energy": [
    "x",
    "mean",
    "cov_sqrt",
    "inv_cov_sqrt",
    "diag"
  ],
  "rescale": [
    "mu"
  ],
  "trajectory_length": [
    "t",
    "mu"
  ],
  "MCLMCInfo": {},
  "IntegratorState": {},
  "Integrator": [],
  "GeneralIntegrator": [],
  "generalized_two_stage_integrator": [
    "operator1",
    "operator2",
    "coefficients",
    "format_output_fn"
  ],
  "new_integrator_state": [
    "logdensity_fn",
    "position",
    "momentum"
  ],
  "euclidean_position_update_fn": [
    "logdensity_fn"
  ],
  "euclidean_momentum_update_fn": [
    "kinetic_energy_fn"
  ],
  "format_euclidean_state_output": [
    "position",
    "momentum",
    "logdensity",
    "logdensity_grad",
    "kinetic_grad",
    "position_update_info",
    "momentum_update_info"
  ],
  "generate_euclidean_integrator": [
    "coefficients"
  ],
  "velocity_verlet_coefficients": [],
  "velocity_verlet": [],
  "b1": [],
  "a1": [],
  "b2": [],
  "mclachlan_coefficients": [],
  "mclachlan": [],
  "a2": [],
  "yoshida_coefficients": [],
  "yoshida": [],
  "b3": [],
  "a3": [],
  "omelyan_coefficients": [],
  "omelyan": [],
  "_normalized_flatten_array": [
    "x",
    "tol"
  ],
  "esh_dynamics_momentum_update_one_step": [
    "inverse_mass_matrix"
  ],
  "format_isokinetic_state_output": [
    "position",
    "momentum",
    "logdensity",
    "logdensity_grad",
    "kinetic_grad",
    "position_update_info",
    "momentum_update_info"
  ],
  "generate_isokinetic_integrator": [
    "coefficients"
  ],
  "isokinetic_velocity_verlet": [],
  "isokinetic_yoshida": [],
  "isokinetic_mclachlan": [],
  "isokinetic_omelyan": [],
  "partially_refresh_momentum": [
    "momentum",
    "rng_key",
    "step_size",
    "L"
  ],
  "with_isokinetic_maruyama": [
    "integrator"
  ],
  "FixedPointSolver": [],
  "FixedPointIterationInfo": {},
  "solve_fixed_point_iteration": [
    "func",
    "x0"
  ],
  "implicit_midpoint": [
    "logdensity_fn",
    "kinetic_energy_fn"
  ],
  "DynamicHMCState": {},
  "halton_sequence": [
    "i",
    "max_bits"
  ],
  "halton_trajectory_length": [
    "i",
    "trajectory_length_adjustment",
    "max_bits"
  ],
  "IterativeUTurnState": {},
  "iterative_uturn_numpyro": [
    "is_turning"
  ],
  "Trajectory": {},
  "append_to_trajectory": [
    "trajectory",
    "state"
  ],
  "reorder_trajectories": [
    "direction",
    "trajectory",
    "new_trajectory"
  ],
  "merge_trajectories": [
    "left_trajectory",
    "right_trajectory"
  ],
  "static_integration": [
    "integrator",
    "direction"
  ],
  "DynamicIntegrationState": {},
  "dynamic_progressive_integration": [
    "integrator",
    "kinetic_energy",
    "update_termination_state",
    "is_criterion_met",
    "divergence_threshold"
  ],
  "dynamic_recursive_integration": [
    "integrator",
    "kinetic_energy",
    "uturn_check_fn",
    "divergence_threshold",
    "use_robust_uturn_check"
  ],
  "DynamicExpansionState": {},
  "dynamic_multiplicative_expansion": [
    "trajectory_integrator",
    "uturn_check_fn",
    "max_num_expansions",
    "rate"
  ],
  "hmc_energy": [
    "kinetic_energy"
  ],
  "EllipSliceState": {},
  "EllipSliceInfo": {},
  "elliptical_proposal": [
    "logdensity_fn",
    "momentum_generator",
    "mean"
  ],
  "ellipsis": [
    "position",
    "momentum",
    "theta",
    "mean"
  ],
  "HMCState": {},
  "HMCInfo": {},
  "hmc_proposal": [
    "integrator",
    "kinetic_energy",
    "step_size",
    "num_integration_steps",
    "divergence_threshold"
  ],
  "flip_momentum": [
    "state"
  ],
  "MALAState": {},
  "MALAInfo": {},
  "NUTSInfo": {},
  "iterative_nuts_proposal": [
    "integrator",
    "kinetic_energy",
    "uturn_check_fn",
    "max_num_expansions",
    "divergence_threshold"
  ],
  "MarginalState": {},
  "CovarianceSVD": {},
  "svd_from_covariance": [
    "covariance"
  ],
  "MarginalInfo": {},
  "generate_mean_shifted_logprob": [
    "logdensity_fn",
    "mean",
    "covariance"
  ],
  "GHMCState": {},
  "update_momentum": [
    "rng_key",
    "state",
    "alpha",
    "momentum_generator"
  ],
  "normal": [
    "sigma"
  ],
  "RWState": {},
  "RWInfo": {},
  "build_additive_step": [],
  "normal_random_walk": [
    "logdensity_fn",
    "sigma"
  ],
  "build_irmh": [],
  "irmh_as_top_level_api": [
    "logdensity_fn",
    "proposal_distribution",
    "proposal_logdensity_fn"
  ],
  "build_rmh": [],
  "rmh_as_top_level_api": [
    "logdensity_fn",
    "proposal_generator",
    "proposal_logdensity_fn"
  ],
  "build_rmh_transition_energy": [
    "proposal_logdensity_fn"
  ],
  "rmh_proposal": [
    "logdensity_fn",
    "transition_distribution",
    "compute_acceptance_ratio",
    "sample_proposal"
  ],
  "TrajectoryState": [],
  "Proposal": {},
  "safe_energy_diff": [
    "initial_energy",
    "new_energy"
  ],
  "proposal_generator": [
    "energy_fn"
  ],
  "progressive_uniform_sampling": [
    "rng_key",
    "proposal",
    "new_proposal"
  ],
  "progressive_biased_sampling": [
    "rng_key",
    "proposal",
    "new_proposal"
  ],
  "compute_asymmetric_acceptance_ratio": [
    "transition_energy_fn"
  ],
  "static_binomial_sampling": [
    "rng_key",
    "log_p_accept",
    "proposal",
    "new_proposal"
  ],
  "nonreversible_slice_sampling": [
    "slice",
    "delta_energy",
    "proposal",
    "new_proposal"
  ],
  "MFVIState": {},
  "MFVIInfo": {},
  "step": [
    "rng_key",
    "state",
    "logdensity_fn",
    "optimizer",
    "num_samples",
    "stl_estimator"
  ],
  "sample": [
    "rng_key",
    "state",
    "num_samples"
  ],
  "_sample": [
    "rng_key",
    "mu",
    "rho",
    "num_samples"
  ],
  "generate_meanfield_logdensity": [
    "mu",
    "rho"
  ],
  "PathfinderState": {},
  "PathfinderInfo": {},
  "PathFinderAlgorithm": {},
  "approximate": [
    "rng_key",
    "logdensity_fn",
    "initial_position",
    "num_samples"
  ],
  "SVGDState": {},
  "rbf_kernel": [
    "x",
    "y",
    "length_scale"
  ],
  "median_heuristic": [
    "kernel_parameters",
    "particles"
  ],
  "update_median_heuristic": [
    "state"
  ],
  "SchrodingerFollmerState": {},
  "SchrodingerFollmerInfo": {},
  "_log_fn_corrected": [
    "position",
    "logdensity_fn"
  ],
  "ContourSGLDState": {},
  "SGNHTState": {},
  "logdensity_estimator": [
    "logprior_fn",
    "loglikelihood_fn",
    "data_size"
  ],
  "grad_estimator": [
    "logprior_fn",
    "loglikelihood_fn",
    "data_size"
  ],
  "control_variates": [
    "logdensity_grad_estimator",
    "centering_position",
    "data"
  ],
  "INIT_STEP_SIZE": [],
  "MIN_STEP_SIZE": [],
  "LBFGSHistory": {},
  "minimize_lbfgs": [
    "fun",
    "x0",
    "maxiter",
    "maxcor",
    "gtol",
    "ftol",
    "maxls"
  ],
  "_minimize_lbfgs": [
    "fun",
    "x0",
    "maxiter",
    "maxcor",
    "gtol",
    "ftol",
    "maxls"
  ],
  "lbfgs_recover_alpha": [
    "alpha_lm1",
    "s_l",
    "z_l",
    "epsilon"
  ],
  "lbfgs_inverse_hessian_factors": [
    "S",
    "Z",
    "alpha"
  ],
  "lbfgs_inverse_hessian_formula_1": [
    "alpha",
    "beta",
    "gamma"
  ],
  "lbfgs_inverse_hessian_formula_2": [
    "alpha",
    "beta",
    "gamma"
  ],
  "bfgs_sample": [
    "rng_key",
    "num_samples",
    "position",
    "grad_position",
    "alpha",
    "beta",
    "gamma"
  ],
  "DualAveragingState": {},
  "dual_averaging": [
    "t0",
    "gamma",
    "kappa"
  ],
  "SMCState": {},
  "SMCInfo": {},
  "extend_params": [
    "params"
  ],
  "update_and_take_last": [
    "mcmc_init_fn",
    "tempered_logposterior_fn",
    "shared_mcmc_step_fn",
    "num_mcmc_steps",
    "n_particles"
  ],
  "_resampling_func": [
    "func",
    "name",
    "desc",
    "additional_params"
  ],
  "systematic": [
    "rng_key",
    "weights",
    "num_samples"
  ],
  "stratified": [
    "rng_key",
    "weights",
    "num_samples"
  ],
  "multinomial": [
    "rng_key",
    "weights",
    "num_samples"
  ],
  "residual": [
    "rng_key",
    "weights",
    "num_samples"
  ],
  "_systematic_or_stratified": [
    "rng_key",
    "weights",
    "num_samples",
    "is_systematic"
  ],
  "_sorted_uniforms": [
    "rng_key",
    "n"
  ],
  "ess": [
    "log_weights"
  ],
  "log_ess": [
    "log_weights"
  ],
  "ess_solver": [
    "logdensity_fn",
    "particles",
    "target_ess",
    "max_delta",
    "root_solver"
  ],
  "PartialPosteriorsSMCState": {},
  "unshared_parameters_and_step_fn": [
    "mcmc_parameters",
    "mcmc_step_fn"
  ],
  "StateWithParameterOverride": {},
  "PersistentSMCState": {
    "particles": [
      "self"
    ],
    "tempering_param": [
      "self"
    ],
    "log_Z": [
      "self"
    ],
    "persistent_weights": [
      "self"
    ],
    "num_particles": [
      "self"
    ]
  },
  "PersistentStateInfo": {},
  "remove_padding": [
    "state"
  ],
  "compute_log_Z": [
    "log_weights",
    "iteration"
  ],
  "compute_log_persistent_weights": [
    "persistent_log_likelihoods",
    "persistent_log_Z",
    "tempering_schedule",
    "iteration",
    "include_current",
    "normalize_to_one"
  ],
  "resample_from_persistent": [
    "rng_key",
    "persistent_particles",
    "persistent_weights",
    "resample_fn"
  ],
  "compute_persistent_ess": [
    "log_persistent_weights",
    "normalize_weights"
  ],
  "dichotomy": [
    "fun",
    "min_delta",
    "max_delta",
    "eps",
    "max_iter"
  ],
  "update_waste_free": [
    "mcmc_init_fn",
    "logposterior_fn",
    "mcmc_step_fn",
    "n_particles",
    "p",
    "num_resampled",
    "num_mcmc_steps"
  ],
  "waste_free_smc": [
    "n_particles",
    "p"
  ],
  "TemperedSMCState": {},
  "SMCInfoWithParameterDistribution": {},
  "esjd": [
    "m"
  ],
  "update_parameter_distribution": [
    "key",
    "previous_param_samples",
    "previous_particles",
    "latest_particles",
    "measure_of_chain_mixing",
    "alpha",
    "sigma_parameters",
    "acceptance_probability"
  ],
  "default_measure_factory": [
    "state"
  ],
  "build_pretune": [
    "mcmc_init_fn",
    "mcmc_step_fn",
    "alpha",
    "sigma_parameters",
    "n_particles",
    "performance_of_chain_measure_factory",
    "natural_parameters",
    "positive_parameters"
  ],
  "particles_stds": [
    "particles"
  ],
  "particles_means": [
    "particles"
  ],
  "particles_covariance_matrix": [
    "particles"
  ],
  "inverse_mass_matrix_from_particles": [
    "particles"
  ],
  "particles_as_rows": [
    "particles"
  ],
  "update_scale_from_acceptance_rate": [
    "scales",
    "acceptance_rates",
    "target_acceptance_rate"
  ],
  "WindowAdaptationState": {},
  "base": [
    "is_mass_matrix_diagonal",
    "target_acceptance_rate"
  ],
  "window_adaptation": [
    "algorithm",
    "logdensity_fn",
    "is_mass_matrix_diagonal",
    "initial_step_size",
    "target_acceptance_rate",
    "progress_bar",
    "adaptation_info_fn",
    "integrator"
  ],
  "build_schedule": [
    "num_steps",
    "initial_buffer_size",
    "final_buffer_size",
    "first_window_size"
  ],
  "AdaptationResults": {},
  "AdaptationInfo": {},
  "return_all_adapt_info": [
    "state",
    "info",
    "adaptation_state"
  ],
  "get_filter_adapt_info_fn": [
    "state_keys",
    "info_keys",
    "adapt_state_keys"
  ],
  "MCLMCAdaptationState": {},
  "mclmc_find_L_and_step_size": [
    "mclmc_kernel",
    "num_steps",
    "state",
    "rng_key",
    "frac_tune1",
    "frac_tune2",
    "frac_tune3",
    "desired_energy_var",
    "trust_in_estimate",
    "num_effective_samples",
    "diagonal_preconditioning",
    "params"
  ],
  "make_L_step_size_adaptation": [
    "kernel",
    "dim",
    "frac_tune1",
    "frac_tune2",
    "diagonal_preconditioning",
    "desired_energy_var",
    "trust_in_estimate",
    "num_effective_samples"
  ],
  "make_adaptation_L": [
    "kernel",
    "frac",
    "Lfactor"
  ],
  "handle_nans": [
    "previous_state",
    "next_state",
    "step_size",
    "step_size_max",
    "kinetic_change",
    "key"
  ],
  "DualAveragingAdaptationState": {},
  "dual_averaging_adaptation": [
    "target",
    "t0",
    "gamma",
    "kappa"
  ],
  "ReasonableStepSizeState": {},
  "find_reasonable_step_size": [
    "rng_key",
    "kernel_generator",
    "reference_state",
    "initial_step_size",
    "target_accept"
  ],
  "OPTIMAL_TARGET_ACCEPTANCE_RATE": [],
  "LOG_UPDATE_CLIP": [],
  "EPS_FLOAT": [],
  "ChEESAdaptationState": {},
  "weighted_empirical_mean": [
    "x",
    "w"
  ],
  "chees_adaptation": [
    "logdensity_fn",
    "num_chains"
  ],
  "PathfinderAdaptationState": {},
  "pathfinder_adaptation": [
    "algorithm",
    "logdensity_fn",
    "initial_step_size",
    "target_acceptance_rate",
    "adaptation_info_fn"
  ],
  "Lratio_lowerbound": [],
  "Lratio_upperbound": [],
  "adjusted_mclmc_find_L_and_step_size": [
    "mclmc_kernel",
    "num_steps",
    "state",
    "rng_key",
    "target",
    "frac_tune1",
    "frac_tune2",
    "frac_tune3",
    "diagonal_preconditioning",
    "params",
    "max",
    "num_windows",
    "tuning_factor"
  ],
  "adjusted_mclmc_make_L_step_size_adaptation": [
    "kernel",
    "dim",
    "frac_tune1",
    "frac_tune2",
    "target",
    "diagonal_preconditioning",
    "fix_L_first_da",
    "max",
    "tuning_factor"
  ],
  "adjusted_mclmc_make_adaptation_L": [
    "kernel",
    "frac",
    "Lfactor",
    "max",
    "eigenvector"
  ],
  "MEADSAdaptationState": {},
  "meads_adaptation": [
    "logdensity_fn",
    "num_chains",
    "adaptation_info_fn"
  ],
  "maximum_eigenvalue": [
    "matrix"
  ],
  "WelfordAlgorithmState": {},
  "MassMatrixAdaptationState": {},
  "mass_matrix_adaptation": [
    "is_diagonal_matrix"
  ],
  "welford_algorithm": [
    "is_diagonal_matrix"
  ]
}