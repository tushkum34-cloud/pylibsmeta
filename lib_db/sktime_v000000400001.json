{
  "__author__": [],
  "find_py_files": [
    "folder_path"
  ],
  "extract_docstrings": [
    "filename"
  ],
  "find_invalid_backtick_text": [
    "docstring"
  ],
  "main": [],
  "ROOT_DIR": [],
  "PACKAGE_NAME": [],
  "URLs": {
    "DOCS_LOCAL": [],
    "DOCS_ONLINE": [],
    "PYPI": []
  },
  "read": [],
  "find_version": [],
  "open_website": [
    "website"
  ],
  "colored": [
    "msg",
    "color",
    "style"
  ],
  "cprint": [
    "msg",
    "color",
    "style"
  ],
  "wait_for_enter": [],
  "Step": {
    "pre": [
      "self",
      "context"
    ],
    "post": [
      "self",
      "context"
    ],
    "run": [
      "self",
      "context"
    ],
    "instruct": [
      "msg"
    ],
    "print_run": [
      "self",
      "msg"
    ],
    "print_cmd": [
      "msg"
    ],
    "do_cmd": [
      "cmd"
    ],
    "action": [
      "self",
      "context"
    ]
  },
  "ConfirmGitStatus": {
    "__init__": [
      "self",
      "branch"
    ],
    "action": [
      "self",
      "context"
    ]
  },
  "UpdateChangelog": {
    "action": [
      "self",
      "context"
    ]
  },
  "UpdateReadme": {
    "action": [
      "self",
      "context"
    ]
  },
  "UpdateVersion": {
    "action": [
      "self",
      "context"
    ],
    "post": [
      "self",
      "context"
    ]
  },
  "MakeClean": {
    "action": [
      "self",
      "context"
    ]
  },
  "MakeDocs": {
    "action": [
      "self",
      "context"
    ]
  },
  "MakeDist": {
    "action": [
      "self",
      "context"
    ]
  },
  "UploadToTestPyPI": {
    "action": [
      "self",
      "context"
    ]
  },
  "InstallFromTestPyPI": {
    "action": [
      "self",
      "context"
    ]
  },
  "CheckVersionNumber": {
    "action": [
      "self",
      "context"
    ]
  },
  "GitTagRelease": {
    "action": [
      "self",
      "context"
    ]
  },
  "GitTagPreRelease": {
    "action": [
      "self",
      "context"
    ]
  },
  "PushToGitHub": {
    "action": [
      "self",
      "context"
    ]
  },
  "CheckCIStatus": {
    "action": [
      "self",
      "context"
    ]
  },
  "CheckOnlineDocs": {
    "action": [
      "self",
      "context"
    ]
  },
  "CheckLocalDocs": {
    "action": [
      "self",
      "context"
    ]
  },
  "CheckPyPIFiles": {
    "action": [
      "self",
      "context"
    ]
  },
  "PushTagToGitHub": {
    "action": [
      "self",
      "context"
    ]
  },
  "HEADERS": [],
  "OWNER": [],
  "REPO": [],
  "GITHUB_REPOS": [],
  "fetch_merged_pull_requests": [
    "page"
  ],
  "fetch_latest_release": [],
  "fetch_pull_requests_since_last_release": [],
  "github_compare_tags": [
    "tag_left",
    "tag_right"
  ],
  "render_row": [
    "pr"
  ],
  "assign_prs": [
    "prs",
    "categs"
  ],
  "render_changelog": [
    "prs",
    "assigned",
    "label_to_subsection",
    "module_order"
  ],
  "render_contributors": [
    "prs",
    "fmt"
  ],
  "format_nb_json": [
    "notebook_path",
    "indent"
  ],
  "MyEarlyTimeSeriesClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_update_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_update_predict_proba": [
      "self",
      "X"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc",
      "broadcasting"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyAligner": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyTrafoPwPanel": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyDetector": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyTimeSeriesClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyTimeSeriesParamFitter": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "_update": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyClusterer": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MySplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyTrafoPw": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MyMetric": {
    "_tags": [],
    "__init__": [
      "self",
      "parama",
      "paramb",
      "paramc"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ON_READTHEDOCS": [],
  "current_year": [],
  "project": [],
  "project_copyright": [],
  "author": [],
  "CURRENT_VERSION": [],
  "extensions": [],
  "myst_enable_extensions": [],
  "nbsphinx_thumbnails": [],
  "panels_add_bootstrap_css": [],
  "templates_path": [],
  "source_suffix": [],
  "master_doc": [],
  "language": [],
  "exclude_patterns": [],
  "add_module_names": [],
  "pygments_style": [],
  "numpydoc_show_class_members": [],
  "numpydoc_class_members_toctree": [],
  "numpydoc_validation_checks": [],
  "autosummary_generate": [],
  "autodoc_default_options": [],
  "add_function_parentheses": [],
  "suppress_warnings": [],
  "show_warning_types": [],
  "issues_github_path": [],
  "linkcode_resolve": [
    "domain",
    "info"
  ],
  "html_theme": [],
  "html_theme_options": [],
  "html_logo": [],
  "html_context": [],
  "html_favicon": [],
  "html_sidebars": [],
  "html_static_path": [],
  "html_css_files": [],
  "html_extra_path": [],
  "html_show_sourcelink": [],
  "htmlhelp_basename": [],
  "latex_elements": [],
  "latex_documents": [],
  "man_pages": [],
  "texinfo_documents": [],
  "_make_estimator_overview": [
    "app"
  ],
  "_process_in_page_toc": [
    "app",
    "exception"
  ],
  "setup": [
    "app"
  ],
  "nbsphinx_execute": [],
  "nbsphinx_allow_errors": [],
  "nbsphinx_timeout": [],
  "current_file": [],
  "binder_url": [],
  "nbsphinx_prolog": [],
  "notebook_url": [],
  "nbsphinx_epilog": [],
  "intersphinx_mapping": [],
  "todo_include_todos": [],
  "copybutton_prompt_text": [],
  "copybutton_prompt_is_regexp": [],
  "copybutton_line_continuation_character": [],
  "fetch_spx": [],
  "results": [],
  "__version__": [],
  "__all__": [],
  "NotEvaluatedError": {},
  "FitFailedWarning": {},
  "_WddtwDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "compute_derivative",
      "g"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "compute_derivative",
      "g"
    ]
  },
  "_edr_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "epsilon"
  ],
  "compute_min_return_path": [
    "cost_matrix",
    "bounding_matrix"
  ],
  "compute_twe_return_path": [
    "cost_matrix",
    "bounding_matrix"
  ],
  "compute_lcss_return_path": [
    "x",
    "y",
    "epsilon",
    "bounding_matrix",
    "cost_matrix"
  ],
  "DerivativeCallable": [],
  "average_of_slope_transform": [
    "X"
  ],
  "_DdtwDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "compute_derivative"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "compute_derivative"
    ]
  },
  "_MsmDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "c",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "c",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ]
  },
  "_EuclideanDistance": {
    "_distance_factory": [
      "self",
      "x",
      "y"
    ]
  },
  "_cost": [
    "_x",
    "_y",
    "_z",
    "_c"
  ],
  "_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "c"
  ],
  "_DtwDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ]
  },
  "_numba_squared_distance": [
    "x",
    "y"
  ],
  "_local_squared_distance": [
    "x",
    "y"
  ],
  "_TweDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "lmbda",
      "nu",
      "p"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "lmbda",
      "nu",
      "p"
    ]
  },
  "_local_euclidean_distance": [
    "x",
    "y"
  ],
  "_numba_euclidean_distance": [
    "x",
    "y"
  ],
  "_ErpDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ]
  },
  "_weighted_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "g"
  ],
  "assign": [],
  "_vectorize_distance": [
    "distance"
  ],
  "_extend_docstring_3d": [
    "docstring"
  ],
  "_WdtwDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ]
  },
  "LowerBounding": {
    "NO_BOUNDING": [],
    "SAKOE_CHIBA": [],
    "ITAKURA_PARALLELOGRAM": [],
    "__init__": [
      "self",
      "int_val"
    ],
    "create_bounding_matrix": [
      "self",
      "x",
      "y",
      "sakoe_chiba_window_radius",
      "itakura_max_slope"
    ],
    "_check_input_timeseries": [
      "x"
    ]
  },
  "resolve_bounding_matrix": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix"
  ],
  "_EdrDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "epsilon"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "epsilon"
    ]
  },
  "_sequence_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "epsilon"
  ],
  "pad_ts": [
    "x"
  ],
  "_twe_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "lmbda",
    "nu",
    "p"
  ],
  "_resolve_dist_instance": [
    "metric",
    "x",
    "y",
    "known_metric_dict"
  ],
  "_resolve_metric_to_factory": [
    "metric",
    "x",
    "y",
    "known_metric_dict"
  ],
  "_resolve_str_metric": [
    "metric",
    "known_metric_dict"
  ],
  "_is_distance_factory_callable": [
    "metric"
  ],
  "_is_no_python_distance_callable": [
    "metric"
  ],
  "_SquaredDistance": {
    "_distance_factory": [
      "self",
      "x",
      "y"
    ]
  },
  "_LcssDistance": {
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix",
      "epsilon",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y",
      "epsilon",
      "window",
      "itakura_max_slope",
      "bounding_matrix"
    ]
  },
  "_erp_cost_matrix": [
    "x",
    "y",
    "bounding_matrix",
    "g"
  ],
  "erp_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "g"
  ],
  "edr_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "epsilon"
  ],
  "lcss_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "epsilon"
  ],
  "wddtw_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "compute_derivative",
    "g"
  ],
  "wdtw_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "g"
  ],
  "ddtw_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "compute_derivative"
  ],
  "dtw_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix"
  ],
  "msm_distance": [
    "x",
    "y",
    "c",
    "window",
    "itakura_max_slope",
    "bounding_matrix"
  ],
  "twe_distance": [
    "x",
    "y",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "lmbda",
    "nu",
    "p"
  ],
  "squared_distance": [
    "x",
    "y"
  ],
  "euclidean_distance": [
    "x",
    "y"
  ],
  "dtw_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix"
  ],
  "wdtw_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "g"
  ],
  "ddtw_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "compute_derivative"
  ],
  "wddtw_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "compute_derivative",
    "g"
  ],
  "edr_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "epsilon"
  ],
  "erp_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "g"
  ],
  "lcss_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "epsilon"
  ],
  "msm_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "c",
    "window",
    "itakura_max_slope",
    "bounding_matrix"
  ],
  "twe_alignment_path": [
    "x",
    "y",
    "return_cost_matrix",
    "window",
    "itakura_max_slope",
    "bounding_matrix",
    "lmbda",
    "nu",
    "p"
  ],
  "distance": [
    "x",
    "y",
    "metric"
  ],
  "distance_factory": [
    "x",
    "y",
    "metric"
  ],
  "pairwise_distance": [
    "x",
    "y",
    "metric"
  ],
  "distance_alignment_path": [
    "x",
    "y",
    "metric",
    "return_cost_matrix"
  ],
  "distance_alignment_path_factory": [
    "x",
    "y",
    "metric",
    "return_cost_matrix"
  ],
  "_METRIC_INFOS": [],
  "_METRICS": [],
  "_METRIC_ALIAS": [],
  "_METRIC_CALLABLES": [],
  "_METRICS_NAMES": [],
  "ALL_DISTANCES": [],
  "sliding_dot_products": [
    "q",
    "t",
    "q_len",
    "t_len"
  ],
  "calculate_distance_profile": [
    "dot_prod",
    "q_mean",
    "q_std",
    "t_mean",
    "t_std",
    "q_len",
    "n_t_subs"
  ],
  "stomp_ab": [
    "ts1",
    "ts2",
    "m"
  ],
  "mpdist": [
    "ts1",
    "ts2",
    "m"
  ],
  "_make_3d_series": [
    "x"
  ],
  "_compute_pairwise_distance": [
    "x",
    "y",
    "symmetric",
    "distance_callable"
  ],
  "is_no_python_compiled_callable": [
    "no_python_callable",
    "raise_error"
  ],
  "to_numba_timeseries": [
    "x"
  ],
  "_numba_to_timeseries": [
    "x"
  ],
  "average_of_slope": [
    "q"
  ],
  "create_shape_on_matrix": [
    "bounding_matrix",
    "y_upper_line",
    "y_lower_line",
    "x_step_size",
    "start_val"
  ],
  "_check_line_steps": [
    "line"
  ],
  "no_bounding": [
    "x",
    "y"
  ],
  "sakoe_chiba": [
    "x",
    "y",
    "window"
  ],
  "itakura_parallelogram": [
    "x",
    "y",
    "itakura_max_slope"
  ],
  "numba_create_bounding_matrix": [
    "x",
    "y",
    "window",
    "itakura_max_slope"
  ],
  "create_test_distance_numpy": [
    "n_instance",
    "n_columns",
    "n_timepoints",
    "random_state"
  ],
  "_create_test_distances": [
    "n_instance",
    "n_columns",
    "n_timepoints",
    "random_state"
  ],
  "_time_distance": [
    "callable",
    "average"
  ],
  "_test_metric_parameters": [
    "distance_func"
  ],
  "_test_incorrect_parameters": [
    "distance_func"
  ],
  "_ran_once": [],
  "_validate_distance_result": [
    "x",
    "y",
    "metric_str",
    "distance_factory",
    "distance_function",
    "distance_numba_class",
    "kwargs_dict",
    "expected_result"
  ],
  "test_distance": [
    "dist"
  ],
  "test_metric_parameters": [],
  "test_incorrect_parameters": [],
  "test_distance_factory_1d": [],
  "distance_parameters": [],
  "distance_param_name": [],
  "unit_test_distances": [],
  "basic_motions_distances": [],
  "test_correctness": [
    "dist",
    "uni_multi"
  ],
  "_test_distance_params": [
    "param_list",
    "distance_func",
    "distance_str"
  ],
  "BASIC_BOUNDING_PARAMS": [],
  "_test_derivative": [
    "q"
  ],
  "DIST_PARAMS": [],
  "test_distance_params": [
    "dist"
  ],
  "_expected_distance_results": [],
  "_expected_distance_results_params": [],
  "_validate_distance_alignment_path_result": [
    "x",
    "y",
    "metric_str",
    "distance_path_callable",
    "kwargs_dict"
  ],
  "test_distance_alignment_path": [
    "dist"
  ],
  "_validate_bounding_result": [
    "matrix",
    "x",
    "y",
    "all_finite",
    "all_infinite",
    "is_gradient_bounding"
  ],
  "_validate_bounding": [
    "x",
    "y"
  ],
  "test_lower_bounding": [],
  "_check_symmetric": [
    "x",
    "rtol",
    "atol"
  ],
  "_validate_pairwise_result": [
    "x",
    "y",
    "metric_str",
    "distance_factory",
    "distance_function",
    "distance_numba_class",
    "kwargs_dict"
  ],
  "_test_pw_equal_single_dists": [
    "x",
    "y",
    "distance_function",
    "conical_name"
  ],
  "test_pairwise_distance": [
    "dist"
  ],
  "NumbaDistance": {
    "distance": [
      "self",
      "x",
      "y"
    ],
    "distance_alignment_path": [
      "self",
      "x",
      "y",
      "return_cost_matrix"
    ],
    "distance_factory": [
      "self",
      "x",
      "y"
    ],
    "distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix"
    ],
    "_validate_factory_timeseries": [
      "x"
    ],
    "_distance_factory": [
      "self",
      "x",
      "y"
    ],
    "_distance_alignment_path_factory": [
      "self",
      "x",
      "y",
      "return_cost_matrix"
    ]
  },
  "MetricInfo": {},
  "DistanceCallable": [],
  "AlignmentPathReturn": [],
  "DistanceAlignmentPathCallable": [],
  "DistanceFactoryCallable": [],
  "DistancePairwiseCallable": [],
  "ValidCallableTypes": [],
  "keras": [],
  "K": [],
  "ResidualScaledDotProductAttention": {
    "__init__": [
      "self",
      "return_attention",
      "history_only"
    ],
    "get_config": [
      "self"
    ],
    "compute_mask": [
      "self",
      "inputs",
      "mask"
    ],
    "call": [
      "self",
      "inputs",
      "mask"
    ]
  },
  "SeqWeightedAttention": {
    "__init__": [
      "self",
      "use_bias",
      "return_attention"
    ],
    "get_config": [
      "self"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "x",
      "mask"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "compute_mask": [
      "self",
      "_",
      "input_mask"
    ],
    "get_custom_objects": []
  },
  "__authors__": [],
  "ScaledDotProductAttention": {
    "__init__": [
      "self",
      "return_attention",
      "history_only"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "compute_mask": [
      "self",
      "inputs",
      "mask"
    ],
    "call": [
      "self",
      "inputs",
      "mask"
    ]
  },
  "SeqSelfAttention": {
    "ATTENTION_TYPE_ADD": [],
    "ATTENTION_TYPE_MUL": [],
    "__init__": [
      "self",
      "units",
      "attention_width",
      "attention_type",
      "return_attention",
      "history_only",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "use_additive_bias",
      "use_attention_bias",
      "attention_activation",
      "attention_regularizer_weight"
    ],
    "get_config": [
      "self"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "_build_additive_attention": [
      "self",
      "input_shape"
    ],
    "_build_multiplicative_attention": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "mask"
    ],
    "_call_additive_emission": [
      "self",
      "inputs"
    ],
    "_call_multiplicative_emission": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "compute_mask": [
      "self",
      "inputs",
      "mask"
    ],
    "_attention_regularizer": [
      "self",
      "attention"
    ],
    "get_custom_objects": []
  },
  "TestMul": {
    "test_multiplicative": [
      "self"
    ],
    "test_not_implemented": [
      "self"
    ]
  },
  "TestMask": {
    "test_return_attention": [
      "self"
    ]
  },
  "TestLocal": {
    "check_local_range": [
      "self",
      "attention_type"
    ],
    "test_add": [
      "self"
    ],
    "test_mul": [
      "self"
    ]
  },
  "TestMaskShape": {
    "get_input_data": [],
    "get_model": [
      "attention",
      "token_dict"
    ],
    "check_mask_shape": [
      "self",
      "attention"
    ]
  },
  "TestSaveLoad": {
    "test_save_load": [
      "self"
    ],
    "test_save_load_with_loss": [
      "self"
    ]
  },
  "TestBias": {
    "test_no_bias": [
      "self"
    ]
  },
  "TestHistory": {
    "test_history": [
      "self"
    ],
    "test_infinite_history": [
      "self"
    ]
  },
  "TestActivation": {
    "test_attention_activation": [
      "self"
    ]
  },
  "TestLoss": {
    "test_loss": [
      "self"
    ]
  },
  "TestAttention": {
    "test_sample": [
      "self"
    ]
  },
  "TestResidualScaledDotProductAttention": {
    "test_history": [
      "self"
    ],
    "test_sample": [
      "self"
    ]
  },
  "TASKS": {},
  "NamespaceWithDefaults": {
    "from_namespace": [
      "cls",
      "namespace"
    ],
    "getattr": [
      "self",
      "key",
      "default"
    ]
  },
  "parse_config": [
    "config"
  ],
  "make_dir_if_not_exists": [
    "path",
    "verbose"
  ],
  "is_directory": [
    "path"
  ],
  "f1_score": [
    "predict",
    "actual"
  ],
  "adjust_predicts": [
    "score",
    "label",
    "threshold",
    "pred",
    "calc_latency"
  ],
  "adjbestf1": [
    "y_true",
    "y_scores",
    "n_splits"
  ],
  "load_from_tsfile": [
    "full_file_path_and_name",
    "replace_missing_vals_with",
    "return_meta_data",
    "return_type"
  ],
  "_load_header_info": [
    "file"
  ],
  "_load_data": [
    "file",
    "meta_data",
    "replace_missing_vals_with"
  ],
  "TimeseriesOutputs": {},
  "SUPPORTED_HUGGINGFACE_MODELS": [],
  "MAX_WINDOW": [],
  "_distance_to_holiday": [
    "holiday"
  ],
  "EasterSunday": [],
  "NewYearsDay": [],
  "SuperBowl": [],
  "MothersDay": [],
  "IndependenceDay": [],
  "ChristmasEve": [],
  "ChristmasDay": [],
  "NewYearsEve": [],
  "BlackFriday": [],
  "CyberMonday": [],
  "HOLIDAYS": [],
  "TimeCovariates": {
    "__init__": [
      "self",
      "datetimes",
      "normalized",
      "holiday"
    ],
    "_minute_of_hour": [
      "self"
    ],
    "_hour_of_day": [
      "self"
    ],
    "_day_of_week": [
      "self"
    ],
    "_day_of_month": [
      "self"
    ],
    "_day_of_year": [
      "self"
    ],
    "_month_of_year": [
      "self"
    ],
    "_week_of_year": [
      "self"
    ],
    "_get_holidays": [
      "self"
    ],
    "get_covariates": [
      "self"
    ]
  },
  "es": [],
  "jnp": [],
  "lax": [],
  "base_layer": [],
  "layers": [],
  "pax_fiddle": [],
  "py_utils": [],
  "BaseLayer": [],
  "BaseModel": [],
  "activations": [],
  "embedding_softmax": [],
  "linears": [],
  "normalizations": [],
  "stochastics": [],
  "transformers": [],
  "NestedMap": [],
  "LayerTpl": [],
  "template_field": [],
  "PAD_VAL": [],
  "DEFAULT_QUANTILES": [],
  "_INPUT_TS": [],
  "_TARGET_FUTURE": [],
  "_INPUT_PADDING": [],
  "_OUTPUT_TS": [],
  "_FREQ": [],
  "_OUTPUT_TOKENS": [],
  "_STATS": [],
  "_TOLERANCE": [],
  "_shift_padded_seq": [
    "mask",
    "seq"
  ],
  "ResidualBlock": {
    "setup": [
      "self"
    ],
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "_masked_mean_std": [
    "inputs",
    "padding"
  ],
  "_create_quantiles": [],
  "PatchedTimeSeriesDecoder": {
    "setup": [
      "self"
    ],
    "transform_decode_state": [
      "self",
      "transform_fn"
    ],
    "_forward_transform": [
      "self",
      "inputs",
      "patched_pads"
    ],
    "_reverse_transform": [
      "self",
      "outputs",
      "stats"
    ],
    "_preprocess_input": [
      "self",
      "input_ts",
      "input_padding",
      "pos_emb"
    ],
    "_postprocess_output": [
      "self",
      "model_output",
      "num_outputs",
      "stats"
    ],
    "__call__": [
      "self",
      "inputs"
    ],
    "decode": [
      "self",
      "inputs",
      "horizon_len",
      "output_patch_len",
      "max_len",
      "return_forecast_on_context"
    ]
  },
  "PatchedDecoderFinetuneModel": {
    "__init__": [
      "self"
    ],
    "setup": [
      "self"
    ],
    "compute_predictions": [
      "self",
      "input_batch"
    ],
    "_quantile_loss": [
      "self",
      "pred",
      "actual",
      "quantile"
    ],
    "compute_loss": [
      "self",
      "prediction_output",
      "input_batch"
    ]
  },
  "TimeSeriesdata": {
    "__init__": [
      "self",
      "data_path",
      "datetime_col",
      "num_cov_cols",
      "cat_cov_cols",
      "ts_cols",
      "train_range",
      "val_range",
      "test_range",
      "hist_len",
      "pred_len",
      "batch_size",
      "freq",
      "normalize",
      "epoch_len",
      "holiday",
      "permute"
    ],
    "_get_cat_cols": [
      "self",
      "cat_cov_cols"
    ],
    "_normalize_data": [
      "self"
    ],
    "train_gen": [
      "self"
    ],
    "test_val_gen": [
      "self",
      "mode",
      "shift"
    ],
    "_get_features_and_ts": [
      "self",
      "dtimes",
      "tsidx",
      "hist_len"
    ],
    "tf_dataset": [
      "self",
      "mode",
      "shift"
    ]
  },
  "_TOL": [],
  "_unnest": [
    "nested"
  ],
  "_repeat": [
    "elements",
    "counts"
  ],
  "_to_padded_jax_array": [
    "x"
  ],
  "BatchedInContextXRegBase": {
    "__init__": [
      "self",
      "targets",
      "train_lens",
      "test_lens",
      "train_dynamic_numerical_covariates",
      "train_dynamic_categorical_covariates",
      "test_dynamic_numerical_covariates",
      "test_dynamic_categorical_covariates",
      "static_numerical_covariates",
      "static_categorical_covariates"
    ],
    "_assert_covariates": [
      "self",
      "assert_covariate_shapes"
    ],
    "create_covariate_matrix": [
      "self",
      "one_hot_encoder_drop",
      "use_intercept",
      "assert_covariates",
      "assert_covariate_shapes"
    ],
    "fit": [
      "self"
    ]
  },
  "BatchedInContextXRegLinear": {
    "fit": [
      "self",
      "ridge",
      "one_hot_encoder_drop",
      "use_intercept",
      "force_on_cpu",
      "max_rows_per_col",
      "max_rows_per_col_sample_seed",
      "debug_info",
      "assert_covariates",
      "assert_covariate_shapes"
    ]
  },
  "jax": [],
  "snapshot_download": [],
  "checkpoints": [],
  "tasks_lib": [],
  "FLAX": [],
  "base_hyperparams": [],
  "pytypes": [],
  "instantiate": [],
  "JTensor": [],
  "make_future_dataframe": [],
  "process_group": [
    "key",
    "group",
    "value_name",
    "forecast_context_len"
  ],
  "moving_average": [
    "arr",
    "window_size"
  ],
  "freq_map": [
    "freq"
  ],
  "_normalize": [
    "batch"
  ],
  "_renormalize": [
    "batch",
    "stats"
  ],
  "TimesFm": {
    "_logging": [
      "self",
      "s"
    ],
    "__init__": [
      "self",
      "context_len",
      "horizon_len",
      "input_patch_len",
      "output_patch_len",
      "num_layers",
      "model_dims",
      "per_core_batch_size",
      "backend",
      "quantiles",
      "verbose"
    ],
    "_get_sample_inputs": [
      "self"
    ],
    "load_from_checkpoint": [
      "self",
      "checkpoint_path",
      "repo_id",
      "checkpoint_type",
      "step"
    ],
    "jit_decode": [
      "self"
    ],
    "_preprocess": [
      "self",
      "inputs",
      "freq"
    ],
    "forecast": [
      "self",
      "inputs",
      "freq",
      "window_size",
      "forecast_context_len",
      "return_forecast_on_context"
    ],
    "forecast_with_covariates": [
      "self",
      "inputs",
      "dynamic_numerical_covariates",
      "dynamic_categorical_covariates",
      "static_numerical_covariates",
      "static_categorical_covariates",
      "freq",
      "window_size",
      "forecast_context_len",
      "xreg_mode",
      "normalize_xreg_target_per_input",
      "ridge",
      "max_rows_per_col",
      "force_on_cpu"
    ],
    "forecast_on_df": [
      "self",
      "inputs",
      "freq",
      "forecast_context_len",
      "value_name",
      "model_name",
      "window_size",
      "num_jobs",
      "verbose"
    ]
  },
  "VMD": [
    "f",
    "alpha",
    "tau",
    "K",
    "DC",
    "init",
    "tol"
  ],
  "_safe_average": [
    "x",
    "weights"
  ],
  "test_readme_example": [],
  "array1d": [
    "X",
    "dtype",
    "order"
  ],
  "array2d": [
    "X",
    "dtype",
    "order"
  ],
  "log_multivariate_normal_density": [
    "X",
    "means",
    "covars",
    "min_covar"
  ],
  "check_random_state": [
    "seed"
  ],
  "Bunch": {
    "__init__": [
      "self"
    ]
  },
  "get_params": [
    "obj"
  ],
  "preprocess_arguments": [
    "argsets",
    "converters"
  ],
  "DIM": [],
  "_arg_or_default": [
    "arg",
    "default",
    "dim",
    "name"
  ],
  "_determine_dimensionality": [
    "variables",
    "default"
  ],
  "_last_dims": [
    "X",
    "t",
    "ndims"
  ],
  "_loglikelihoods": [
    "observation_matrices",
    "observation_offsets",
    "observation_covariance",
    "predicted_state_means",
    "predicted_state_covariances",
    "observations"
  ],
  "_filter_predict": [
    "transition_matrix",
    "transition_covariance",
    "transition_offset",
    "current_state_mean",
    "current_state_covariance"
  ],
  "_filter_correct": [
    "observation_matrix",
    "observation_covariance",
    "observation_offset",
    "predicted_state_mean",
    "predicted_state_covariance",
    "observation"
  ],
  "_filter": [
    "transition_matrices",
    "observation_matrices",
    "transition_covariance",
    "observation_covariance",
    "transition_offsets",
    "observation_offsets",
    "initial_state_mean",
    "initial_state_covariance",
    "observations"
  ],
  "_smooth_update": [
    "transition_matrix",
    "filtered_state_mean",
    "filtered_state_covariance",
    "predicted_state_mean",
    "predicted_state_covariance",
    "next_smoothed_state_mean",
    "next_smoothed_state_covariance"
  ],
  "_smooth": [
    "transition_matrices",
    "filtered_state_means",
    "filtered_state_covariances",
    "predicted_state_means",
    "predicted_state_covariances"
  ],
  "_smooth_pair": [
    "smoothed_state_covariances",
    "kalman_smoothing_gain"
  ],
  "_em": [
    "observations",
    "transition_offsets",
    "observation_offsets",
    "smoothed_state_means",
    "smoothed_state_covariances",
    "pairwise_covariances",
    "given"
  ],
  "_em_observation_matrix": [
    "observations",
    "observation_offsets",
    "smoothed_state_means",
    "smoothed_state_covariances"
  ],
  "_em_observation_covariance": [
    "observations",
    "observation_offsets",
    "transition_matrices",
    "smoothed_state_means",
    "smoothed_state_covariances"
  ],
  "_em_transition_matrix": [
    "transition_offsets",
    "smoothed_state_means",
    "smoothed_state_covariances",
    "pairwise_covariances"
  ],
  "_em_transition_covariance": [
    "transition_matrices",
    "transition_offsets",
    "smoothed_state_means",
    "smoothed_state_covariances",
    "pairwise_covariances"
  ],
  "_em_initial_state_mean": [
    "smoothed_state_means"
  ],
  "_em_initial_state_covariance": [
    "initial_state_mean",
    "smoothed_state_means",
    "smoothed_state_covariances"
  ],
  "_em_transition_offset": [
    "transition_matrices",
    "smoothed_state_means"
  ],
  "_em_observation_offset": [
    "observation_matrices",
    "smoothed_state_means",
    "observations"
  ],
  "KalmanFilter": {
    "__init__": [
      "self",
      "transition_matrices",
      "observation_matrices",
      "transition_covariance",
      "observation_covariance",
      "transition_offsets",
      "observation_offsets",
      "initial_state_mean",
      "initial_state_covariance",
      "random_state",
      "em_vars",
      "n_dim_state",
      "n_dim_obs"
    ],
    "sample": [
      "self",
      "n_timesteps",
      "initial_state",
      "random_state"
    ],
    "filter": [
      "self",
      "X"
    ],
    "filter_update": [
      "self",
      "filtered_state_mean",
      "filtered_state_covariance",
      "observation",
      "transition_matrix",
      "transition_offset",
      "transition_covariance",
      "observation_matrix",
      "observation_offset",
      "observation_covariance"
    ],
    "smooth": [
      "self",
      "X"
    ],
    "em": [
      "self",
      "X",
      "y",
      "n_iter",
      "em_vars"
    ],
    "loglikelihood": [
      "self",
      "X"
    ],
    "_initialize_parameters": [
      "self"
    ],
    "_parse_observations": [
      "self",
      "obs"
    ]
  },
  "SigmaPoints": [],
  "Moments": [],
  "points2moments": [
    "points",
    "sigma_noise"
  ],
  "moments2points": [
    "moments",
    "alpha",
    "beta",
    "kappa"
  ],
  "unscented_transform": [
    "points",
    "f",
    "points_noise",
    "sigma_noise"
  ],
  "unscented_correct": [
    "cross_sigma",
    "moments_pred",
    "obs_moments_pred",
    "z"
  ],
  "augmented_points": [
    "momentses"
  ],
  "augmented_unscented_filter_points": [
    "mean_state",
    "covariance_state",
    "covariance_transition",
    "covariance_observation"
  ],
  "unscented_filter_predict": [
    "transition_function",
    "points_state",
    "points_transition",
    "sigma_transition"
  ],
  "unscented_filter_correct": [
    "observation_function",
    "moments_pred",
    "points_pred",
    "observation",
    "points_observation",
    "sigma_observation"
  ],
  "augmented_unscented_filter": [
    "mu_0",
    "sigma_0",
    "f",
    "g",
    "Q",
    "R",
    "Z"
  ],
  "augmented_unscented_smoother": [
    "mu_filt",
    "sigma_filt",
    "f",
    "Q"
  ],
  "additive_unscented_filter": [
    "mu_0",
    "sigma_0",
    "f",
    "g",
    "Q",
    "R",
    "Z"
  ],
  "additive_unscented_smoother": [
    "mu_filt",
    "sigma_filt",
    "f",
    "Q"
  ],
  "UnscentedMixin": {
    "__init__": [
      "self",
      "transition_functions",
      "observation_functions",
      "transition_covariance",
      "observation_covariance",
      "initial_state_mean",
      "initial_state_covariance",
      "n_dim_state",
      "n_dim_obs",
      "random_state"
    ],
    "_initialize_parameters": [
      "self"
    ],
    "_parse_observations": [
      "self",
      "obs"
    ],
    "_converters": [
      "self"
    ]
  },
  "UnscentedKalmanFilter": {
    "sample": [
      "self",
      "n_timesteps",
      "initial_state",
      "random_state"
    ],
    "filter": [
      "self",
      "Z"
    ],
    "filter_update": [
      "self",
      "filtered_state_mean",
      "filtered_state_covariance",
      "observation",
      "transition_function",
      "transition_covariance",
      "observation_function",
      "observation_covariance"
    ],
    "smooth": [
      "self",
      "Z"
    ],
    "_default_parameters": [
      "self"
    ]
  },
  "AdditiveUnscentedKalmanFilter": {
    "sample": [
      "self",
      "n_timesteps",
      "initial_state",
      "random_state"
    ],
    "filter": [
      "self",
      "Z"
    ],
    "filter_update": [
      "self",
      "filtered_state_mean",
      "filtered_state_covariance",
      "observation",
      "transition_function",
      "transition_covariance",
      "observation_function",
      "observation_covariance"
    ],
    "smooth": [
      "self",
      "Z"
    ],
    "_default_parameters": [
      "self"
    ]
  },
  "numpy2": [],
  "newbyteorder": [
    "arr",
    "new_order"
  ],
  "data": [],
  "build_unscented_filter": [
    "cls"
  ],
  "check_unscented_prediction": [
    "method",
    "mu_true",
    "sigma_true"
  ],
  "check_dims": [
    "n_dim_state",
    "n_dim_obs",
    "n_func_args",
    "kf_cls",
    "kwargs"
  ],
  "test_unscented_sample": [],
  "test_unscented_filter": [],
  "test_unscented_filter_update": [],
  "test_unscented_smoother": [],
  "test_additive_sample": [],
  "test_additive_filter": [],
  "test_additive_filter_update": [],
  "test_additive_smoother": [],
  "test_unscented_initialize_parameters": [],
  "test_additive_initialize_parameters": [],
  "KALMAN_FILTERS": [],
  "kf_cls": [
    "request"
  ],
  "TestKalmanFilter": {
    "test_kalman_sampling": [
      "self",
      "kf_cls",
      "data"
    ],
    "test_kalman_filter_update": [
      "self",
      "kf_cls",
      "data"
    ],
    "test_kalman_filter": [
      "self",
      "kf_cls",
      "data"
    ],
    "test_kalman_predict": [
      "self",
      "kf_cls",
      "data"
    ],
    "test_kalman_fit": [
      "self",
      "kf_cls",
      "data"
    ],
    "test_kalman_initialize_parameters": [
      "self",
      "kf_cls"
    ],
    "check_dims": [
      "self",
      "n_dim_state",
      "n_dim_obs",
      "kwargs",
      "kf_cls"
    ],
    "test_kalman_pickle": [
      "self",
      "kf_cls",
      "data"
    ]
  },
  "_reconstruct_covariances": [
    "covariance2s"
  ],
  "CholeskyKalmanFilter": {
    "filter": [
      "self",
      "X"
    ],
    "filter_update": [
      "self",
      "filtered_state_mean",
      "filtered_state_covariance",
      "observation",
      "transition_matrix",
      "transition_offset",
      "transition_covariance",
      "observation_matrix",
      "observation_offset",
      "observation_covariance"
    ],
    "smooth": [
      "self",
      "X"
    ],
    "em": [
      "self",
      "X",
      "y",
      "n_iter",
      "em_vars"
    ],
    "loglikelihood": [
      "self",
      "X"
    ]
  },
  "cholupdate": [
    "A2",
    "X",
    "weight"
  ],
  "qr": [
    "A"
  ],
  "_unscented_transform": [
    "points",
    "f",
    "points_noise",
    "sigma2_noise"
  ],
  "_unscented_correct": [
    "cross_sigma",
    "moments_pred",
    "obs_moments_pred",
    "z"
  ],
  "_additive_unscented_filter": [
    "mu_0",
    "sigma_0",
    "f",
    "g",
    "Q",
    "R",
    "Z"
  ],
  "_additive_unscented_smoother": [
    "mu_filt",
    "sigma2_filt",
    "f",
    "Q"
  ],
  "UDU_decomposition": {
    "__init__": [
      "self",
      "U",
      "D"
    ],
    "reconstruct": [
      "self"
    ]
  },
  "udu": [
    "M"
  ],
  "decorrelate_observations": [
    "observation_matrices",
    "observation_offsets",
    "observation_covariance",
    "observations"
  ],
  "_filter_correct_single": [
    "UDU",
    "h",
    "R"
  ],
  "BiermanKalmanFilter": {
    "filter": [
      "self",
      "X"
    ],
    "filter_update": [
      "self",
      "filtered_state_mean",
      "filtered_state_covariance",
      "observation",
      "transition_matrix",
      "transition_offset",
      "transition_covariance",
      "observation_matrix",
      "observation_offset",
      "observation_covariance"
    ],
    "smooth": [
      "self",
      "X"
    ],
    "em": [
      "self",
      "X",
      "y",
      "n_iter",
      "em_vars"
    ],
    "loglikelihood": [
      "self",
      "X"
    ]
  },
  "test_cholupdate": [],
  "test_qr": [],
  "load_robot": [],
  "torch": [],
  "GenerationMixin": [],
  "LogitsProcessorList": [],
  "StoppingCriteriaList": [],
  "EosTokenCriteria": [],
  "validate_stopping_criteria": [],
  "GenerateDecoderOnlyOutput": [],
  "GenerateEncoderDecoderOutput": [],
  "TSGenerationMixin": {
    "_greedy_search": [
      "self",
      "input_ids",
      "logits_processor",
      "stopping_criteria",
      "max_length",
      "pad_token_id",
      "eos_token_id",
      "output_attentions",
      "output_hidden_states",
      "output_scores",
      "output_logits",
      "return_dict_in_generate",
      "synced_gpus",
      "streamer"
    ],
    "_update_model_kwargs_for_generation": [
      "self",
      "outputs",
      "model_kwargs",
      "horizon_length",
      "is_encoder_decoder",
      "standardize_cache_format"
    ]
  },
  "PretrainedConfig": [],
  "TimeMoeConfig": {
    "model_type": [],
    "keys_to_ignore_at_inference": [],
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "intermediate_size",
      "horizon_lengths",
      "num_hidden_layers",
      "num_attention_heads",
      "num_key_value_heads",
      "hidden_act",
      "num_experts_per_tok",
      "num_experts",
      "max_position_embeddings",
      "initializer_range",
      "rms_norm_eps",
      "use_cache",
      "use_dense",
      "rope_theta",
      "attention_dropout",
      "apply_aux_loss",
      "router_aux_loss_factor",
      "tie_word_embeddings"
    ]
  },
  "nn": [],
  "F": [],
  "Cache": [],
  "DynamicCache": [],
  "PreTrainedModel": [],
  "StaticCache": [],
  "ACT2FN": [],
  "_prepare_4d_causal_attention_mask": [],
  "MoeCausalLMOutputWithPast": [],
  "MoeModelOutputWithPast": [],
  "_get_unpad_data": [
    "attention_mask"
  ],
  "load_balancing_loss_func": [
    "gate_logits",
    "top_k",
    "num_experts",
    "attention_mask"
  ],
  "repeat_kv": [
    "hidden_states",
    "n_rep"
  ],
  "rotate_half": [
    "x"
  ],
  "apply_rotary_pos_emb": [
    "q",
    "k",
    "cos",
    "sin",
    "position_ids",
    "unsqueeze_dim"
  ],
  "TimeMoeInputEmbedding": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeMoeRotaryEmbedding": {
    "__init__": [
      "self",
      "dim",
      "max_position_embeddings",
      "base",
      "device"
    ],
    "_set_cos_sin_cache": [
      "self",
      "seq_len",
      "device",
      "dtype"
    ],
    "forward": [
      "self",
      "x",
      "seq_len"
    ]
  },
  "TimeMoeRMSNorm": {
    "__init__": [
      "self",
      "hidden_size",
      "eps"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "TimeMoeTemporalBlock": {
    "__init__": [
      "self",
      "hidden_size",
      "intermediate_size",
      "hidden_act"
    ],
    "forward": [
      "self",
      "hidden_state"
    ]
  },
  "TimeMoeMLP": {
    "__init__": [
      "self",
      "hidden_size",
      "intermediate_size",
      "hidden_act"
    ],
    "forward": [
      "self",
      "hidden_state"
    ]
  },
  "TimeMoeSparseExpertsLayer": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "TimeMoeAttention": {
    "__init__": [
      "self",
      "config",
      "layer_idx"
    ],
    "forward": [
      "self",
      "hidden_states",
      "attention_mask",
      "position_ids",
      "past_key_value",
      "output_attentions"
    ]
  },
  "TIME_MOE_ATTENTION_CLASSES": [],
  "TimeMoeDecoderLayer": {
    "__init__": [
      "self",
      "config",
      "layer_idx"
    ],
    "forward": [
      "self",
      "hidden_states",
      "attention_mask",
      "position_ids",
      "past_key_value",
      "output_attentions",
      "use_cache"
    ]
  },
  "TimeMoePreTrainedModel": {
    "config_class": [],
    "base_model_prefix": [],
    "supports_gradient_checkpointing": [],
    "_no_split_modules": [],
    "_skip_keys_device_placement": [],
    "_supports_flash_attn_2": [],
    "_supports_sdpa": [],
    "_supports_cache_class": [],
    "_init_weights": [
      "self",
      "module"
    ]
  },
  "TimeMoeModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "input_ids",
      "attention_mask",
      "position_ids",
      "past_key_values",
      "inputs_embeds",
      "use_cache",
      "output_attentions",
      "output_hidden_states",
      "return_dict"
    ]
  },
  "TimeMoeOutputLayer": {
    "__init__": [
      "self",
      "hidden_size",
      "horizon_length",
      "input_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeMoeForPrediction": {
    "__init__": [
      "self",
      "config"
    ],
    "set_decoder": [
      "self",
      "decoder"
    ],
    "get_decoder": [
      "self"
    ],
    "forward": [
      "self",
      "input_ids",
      "attention_mask",
      "position_ids",
      "past_key_values",
      "inputs_embeds",
      "labels",
      "loss_masks",
      "use_cache",
      "output_attentions",
      "output_hidden_states",
      "return_dict",
      "max_horizon_length"
    ],
    "calc_ar_loss": [
      "self",
      "predictions",
      "labels",
      "loss_masks",
      "horizon_length"
    ],
    "prepare_inputs_for_generation": [
      "self",
      "input_ids",
      "past_key_values",
      "attention_mask",
      "inputs_embeds"
    ],
    "_reorder_cache": [
      "past_key_values",
      "beam_idx"
    ]
  },
  "ModelOutput": [],
  "nn_module": [],
  "torch_tensor": [],
  "torch_float": [],
  "TinyTimeMixerGatedAttention": {
    "__init__": [
      "self",
      "in_size",
      "out_size"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TinyTimeMixerBatchNorm": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TinyTimeMixerPositionalEncoding": {
    "__init__": [
      "self",
      "config"
    ],
    "_init_pe": [
      "config"
    ],
    "forward": [
      "self",
      "patch_input"
    ]
  },
  "TinyTimeMixerNormLayer": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TinyTimeMixerMLP": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "config"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TinyTimeMixerChannelFeatureMixerBlock": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TinyTimeMixerAttention": {
    "__init__": [
      "self",
      "embed_dim",
      "num_heads",
      "dropout",
      "is_decoder",
      "bias",
      "is_causal",
      "config"
    ],
    "_shape": [
      "self",
      "tensor",
      "seq_len",
      "bsz"
    ],
    "forward": [
      "self",
      "hidden_states",
      "key_value_states",
      "past_key_value",
      "attention_mask",
      "layer_head_mask",
      "output_attentions"
    ]
  },
  "PatchMixerBlock": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden_state"
    ]
  },
  "FeatureMixerBlock": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden"
    ]
  },
  "TinyTimeMixerLayer": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden"
    ]
  },
  "TinyTimeMixerAdaptivePatchingBlock": {
    "__init__": [
      "self",
      "config",
      "adapt_patch_level"
    ],
    "forward": [
      "self",
      "hidden"
    ]
  },
  "TinyTimeMixerBlock": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden_state",
      "output_hidden_states"
    ]
  },
  "TinyTimeMixerDecoder": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden_state",
      "patch_input",
      "output_hidden_states"
    ]
  },
  "TinyTimeMixerForPredictionHead": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "hidden_features",
      "past_values",
      "future_values"
    ]
  },
  "TinyTimeMixerPreTrainedModel": {
    "config_class": [],
    "base_model_prefix": [],
    "main_input_name": [],
    "supports_gradient_checkpointing": [],
    "_init_weights": [
      "self",
      "module"
    ]
  },
  "TinyTimeMixerPatchify": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past_values"
    ]
  },
  "TinyTimeMixerStdScaler": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "data",
      "observed_indicator"
    ]
  },
  "TinyTimeMixerMeanScaler": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "data",
      "observed_indicator"
    ]
  },
  "TinyTimeMixerNOPScaler": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "data",
      "observed_indicator"
    ]
  },
  "TinyTimeMixerEncoderOutput": {},
  "TinyTimeMixerEncoder": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past_values",
      "output_hidden_states",
      "return_dict",
      "freq_token"
    ]
  },
  "TinyTimeMixerModelOutput": {},
  "TinyTimeMixerModel": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past_values",
      "observed_mask",
      "output_hidden_states",
      "return_dict",
      "freq_token"
    ]
  },
  "TinyTimeMixerForPredictionOutput": {},
  "TinyTimeMixerForPrediction": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "past_values",
      "future_values",
      "observed_mask",
      "output_hidden_states",
      "return_loss",
      "return_dict",
      "freq_token"
    ]
  },
  "TinyTimeMixerConfig": {
    "model_type": [],
    "attribute_map": [],
    "__init__": [
      "self",
      "context_length",
      "patch_length",
      "num_input_channels",
      "prediction_length",
      "patch_stride",
      "prediction_channel_indices",
      "d_model",
      "expansion_factor",
      "num_layers",
      "dropout",
      "mode",
      "gated_attn",
      "norm_mlp",
      "self_attn",
      "self_attn_heads",
      "use_positional_encoding",
      "positional_encoding_type",
      "scaling",
      "loss",
      "init_std",
      "post_init",
      "norm_eps",
      "adaptive_patching_levels",
      "resolution_prefix_tuning",
      "frequency_token_vocab_size",
      "head_dropout",
      "decoder_num_layers",
      "decoder_d_model",
      "decoder_adaptive_patching_levels",
      "decoder_raw_residual",
      "decoder_mode",
      "use_decoder",
      "prediction_filter_length"
    ],
    "check_and_init_preprocessing": [
      "self"
    ]
  },
  "AutoConfig": [],
  "AutoModelForCausalLM": [],
  "AutoModelForSeq2SeqLM": [],
  "GenerationConfig": [],
  "ChronosConfig": {
    "__post_init__": [
      "self"
    ],
    "create_tokenizer": [
      "self"
    ]
  },
  "ChronosTokenizer": {
    "context_input_transform": [
      "self",
      "context"
    ],
    "label_input_transform": [
      "self",
      "label",
      "tokenizer_state"
    ],
    "output_transform": [
      "self",
      "samples",
      "tokenizer_state"
    ]
  },
  "MeanScaleUniformBins": {
    "__init__": [
      "self",
      "low_limit",
      "high_limit",
      "config"
    ],
    "_input_transform": [
      "self",
      "context",
      "scale"
    ],
    "_append_eos_token": [
      "self",
      "token_ids",
      "attention_mask"
    ],
    "context_input_transform": [
      "self",
      "context"
    ],
    "label_input_transform": [
      "self",
      "label",
      "scale"
    ],
    "output_transform": [
      "self",
      "samples",
      "scale"
    ]
  },
  "ChronosModel": {
    "__init__": [
      "self",
      "config",
      "model"
    ],
    "device": [
      "self"
    ],
    "encode": [
      "self",
      "input_ids",
      "attention_mask"
    ],
    "forward": [
      "self",
      "input_ids",
      "attention_mask",
      "prediction_length",
      "num_samples",
      "temperature",
      "top_k",
      "top_p"
    ]
  },
  "left_pad_and_stack_1D": [
    "tensors"
  ],
  "ChronosPipeline": {
    "_prepare_and_validate_context": [
      "self",
      "context"
    ],
    "embed": [
      "self",
      "context"
    ],
    "predict": [
      "self",
      "context",
      "prediction_length",
      "num_samples",
      "temperature",
      "top_k",
      "top_p",
      "limit_prediction_length"
    ],
    "from_pretrained": [
      "cls"
    ]
  },
  "T5LayerNorm": [],
  "T5PreTrainedModel": [],
  "T5Stack": [],
  "logger": [],
  "ChronosBoltConfig": {},
  "ChronosBoltOutput": {},
  "Patch": {
    "__init__": [
      "self",
      "patch_size",
      "patch_stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "InstanceNorm": {
    "__init__": [
      "self",
      "eps"
    ],
    "forward": [
      "self",
      "x",
      "loc_scale"
    ],
    "inverse": [
      "self",
      "x",
      "loc_scale"
    ]
  },
  "ChronosBoltModelForForecasting": {
    "_keys_to_ignore_on_load_missing": [],
    "_keys_to_ignore_on_load_unexpected": [],
    "_tied_weights_keys": [],
    "__init__": [
      "self",
      "config"
    ],
    "_init_weights": [
      "self",
      "module"
    ],
    "encode": [
      "self",
      "context",
      "mask"
    ],
    "forward": [
      "self",
      "context",
      "mask",
      "target",
      "target_mask"
    ],
    "_init_decoder": [
      "self",
      "config"
    ],
    "decode": [
      "self",
      "input_embeds",
      "attention_mask",
      "hidden_states",
      "output_attentions"
    ]
  },
  "ChronosBoltPipeline": {
    "_prepare_and_validate_context": [
      "self",
      "context"
    ],
    "embed": [
      "self",
      "context"
    ],
    "predict": [
      "self",
      "context",
      "prediction_length",
      "limit_prediction_length"
    ],
    "from_pretrained": [
      "cls"
    ]
  },
  "BertConfig": [],
  "BertModel": [],
  "BertTokenizer": [],
  "GPT2Config": [],
  "GPT2Model": [],
  "GPT2Tokenizer": [],
  "LlamaConfig": [],
  "LlamaModel": [],
  "LlamaTokenizer": [],
  "FlattenHead": {
    "__init__": [
      "self",
      "n_vars",
      "nf",
      "target_window",
      "head_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "Model": {
    "__init__": [
      "self",
      "configs",
      "patch_len",
      "stride"
    ],
    "forward": [
      "self",
      "x_enc",
      "x_mark_enc",
      "x_dec",
      "x_mark_dec",
      "mask"
    ],
    "forecast": [
      "self",
      "x_enc",
      "x_mark_enc",
      "x_dec",
      "x_mark_dec"
    ],
    "calcute_lags": [
      "self",
      "x_enc"
    ]
  },
  "ReprogrammingLayer": {
    "__init__": [
      "self",
      "d_model",
      "n_heads",
      "d_keys",
      "d_llm",
      "attention_dropout"
    ],
    "forward": [
      "self",
      "target_embedding",
      "source_embedding",
      "value_embedding"
    ],
    "reprogramming": [
      "self",
      "target_embedding",
      "source_embedding",
      "value_embedding"
    ]
  },
  "Tensor": [],
  "PositionalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TokenEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FixedEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TemporalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "TimeFeatureEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "embed_type",
      "freq"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DataEmbedding": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "DataEmbedding_wo_pos": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "x_mark"
    ]
  },
  "ReplicationPad1d": {
    "__init__": [
      "self",
      "padding"
    ],
    "forward": [
      "self",
      "input"
    ]
  },
  "PatchEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "patch_len",
      "stride",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DataEmbedding_wo_time": {
    "__init__": [
      "self",
      "c_in",
      "d_model",
      "embed_type",
      "freq",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "Normalize": {
    "__init__": [
      "self",
      "num_features",
      "eps",
      "affine",
      "subtract_last",
      "non_norm"
    ],
    "forward": [
      "self",
      "x",
      "mode"
    ],
    "_init_params": [
      "self"
    ],
    "_get_statistics": [
      "self",
      "x"
    ],
    "_normalize": [
      "self",
      "x"
    ],
    "_denormalize": [
      "self",
      "x"
    ]
  },
  "___all__": [],
  "fdiff_coef": [
    "d",
    "window"
  ],
  "fdiff": [
    "a",
    "n",
    "axis",
    "prepend",
    "append",
    "window",
    "mode"
  ],
  "_combine_pre_append": [
    "a",
    "prepend",
    "append",
    "axis"
  ],
  "TestFdiff": {
    "_pochhammer": [
      "d",
      "n"
    ],
    "_coef": [
      "n",
      "window"
    ],
    "test_coef": [
      "self",
      "n",
      "window"
    ],
    "test_error_0dim": [
      "self"
    ],
    "test_error_invalid_mode": [
      "self"
    ],
    "test_integer_n": [
      "self",
      "n",
      "ndim"
    ],
    "test_one": [
      "self",
      "n",
      "window",
      "n_blanks_1",
      "n_blanks_2",
      "n_features"
    ],
    "test_axis": [
      "self",
      "n"
    ],
    "test_mode": [
      "self",
      "n",
      "window"
    ],
    "test_prepend": [
      "self",
      "n",
      "window",
      "mode"
    ],
    "test_append": [
      "self",
      "n",
      "window",
      "mode"
    ],
    "test_linearity_add": [
      "self",
      "n",
      "window",
      "mode"
    ],
    "test_linearity_mul": [
      "self",
      "n",
      "window",
      "mode",
      "const"
    ],
    "test_full_deprecated": [
      "self"
    ]
  },
  "TestScikitLearn": {
    "test_sample_fit_transform": [
      "self",
      "seed",
      "n_samples",
      "n_features",
      "d"
    ],
    "test_sample_pipeline": [
      "self",
      "seed",
      "n_samples",
      "n_features",
      "d"
    ]
  },
  "test_window_from_tol_coef": [],
  "test_window_from_tol_memory": [],
  "TestFracdiff": {
    "test_repr": [
      "self"
    ],
    "test_transform": [
      "self",
      "d",
      "window",
      "mode"
    ],
    "test_sklearn_compatible_estimator": [
      "self",
      "estimator",
      "check"
    ]
  },
  "TestTol": {
    "LARGE": [],
    "test_tol_coef": [
      "self",
      "d",
      "tol"
    ],
    "test_tol_memory": [
      "self",
      "d",
      "tol"
    ]
  },
  "T": [],
  "sklearn_ge_16": [],
  "_sklearn_check_input": [],
  "Fracdiff": {
    "__init__": [
      "self",
      "d",
      "window",
      "mode",
      "window_policy"
    ],
    "__repr__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "window_from_tol_coef": [
    "n",
    "tol_coef",
    "max_window"
  ],
  "window_from_tol_memory": [
    "n",
    "tol_memory",
    "max_window"
  ],
  "EnbPI": {
    "__init__": [
      "self",
      "aggregation_fun"
    ],
    "conformal_interval": [
      "self",
      "bootstrap_indices",
      "bootstrap_train_preds",
      "bootstrap_test_preds",
      "train_targets",
      "error",
      "return_residuals"
    ]
  },
  "Input": [],
  "InputSpec": [],
  "PyTorchPredictor": [],
  "AddObservedValuesIndicator": [],
  "AsNumpyArray": [],
  "ExpandDimArray": [],
  "TestSplitSampler": [],
  "TFTInstanceSplitter": [],
  "SampleNLLLoss": {
    "reduce_loss": [
      "self",
      "loss",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "MoiraiForecast": {
    "__init__": [
      "self",
      "prediction_length",
      "target_dim",
      "feat_dynamic_real_dim",
      "past_feat_dynamic_real_dim",
      "context_length",
      "module_kwargs",
      "module",
      "patch_size",
      "num_samples"
    ],
    "hparams_context": [
      "self",
      "prediction_length",
      "target_dim",
      "feat_dynamic_real_dim",
      "past_feat_dynamic_real_dim",
      "context_length",
      "patch_size",
      "num_samples"
    ],
    "create_predictor": [
      "self",
      "batch_size",
      "device"
    ],
    "describe_inputs": [
      "self",
      "batch_size"
    ],
    "prediction_input_names": [
      "self"
    ],
    "training_input_names": [
      "self"
    ],
    "past_length": [
      "self"
    ],
    "context_token_length": [
      "self",
      "patch_size"
    ],
    "prediction_token_length": [
      "self",
      "patch_size"
    ],
    "max_patch_size": [
      "self"
    ],
    "forward": [
      "self",
      "past_target",
      "past_observed_target",
      "past_is_pad",
      "feat_dynamic_real",
      "observed_feat_dynamic_real",
      "past_feat_dynamic_real",
      "past_observed_feat_dynamic_real",
      "num_samples"
    ],
    "_val_loss": [
      "self",
      "patch_size",
      "target",
      "observed_target",
      "is_pad",
      "feat_dynamic_real",
      "observed_feat_dynamic_real",
      "past_feat_dynamic_real",
      "past_observed_feat_dynamic_real"
    ],
    "_get_distr": [
      "self",
      "patch_size",
      "past_target",
      "past_observed_target",
      "past_is_pad",
      "feat_dynamic_real",
      "observed_feat_dynamic_real",
      "past_feat_dynamic_real",
      "past_observed_feat_dynamic_real"
    ],
    "_patched_seq_pad": [
      "patch_size",
      "x",
      "dim",
      "left",
      "value"
    ],
    "_generate_time_id": [
      "self",
      "patch_size",
      "past_observed_target"
    ],
    "_convert": [
      "self",
      "patch_size",
      "past_target",
      "past_observed_target",
      "past_is_pad",
      "future_target",
      "future_observed_target",
      "future_is_pad",
      "feat_dynamic_real",
      "observed_feat_dynamic_real",
      "past_feat_dynamic_real",
      "past_observed_feat_dynamic_real"
    ],
    "_format_preds": [
      "self",
      "patch_size",
      "preds",
      "target_dim"
    ],
    "get_default_transform": [
      "self"
    ]
  },
  "encode_distr_output": [
    "distr_output"
  ],
  "decode_distr_output": [
    "config"
  ],
  "MoiraiModule": {
    "__init__": [
      "self",
      "distr_output",
      "d_model",
      "num_layers",
      "patch_sizes",
      "max_seq_len",
      "attn_dropout_p",
      "dropout_p",
      "scaling"
    ],
    "forward": [
      "self",
      "target",
      "observed_mask",
      "sample_id",
      "time_id",
      "variate_id",
      "prediction_mask",
      "patch_size"
    ]
  },
  "LogNormalOutput": {
    "distr_cls": [],
    "args_dim": [],
    "domain_map": [
      "self"
    ],
    "_loc": [
      "loc"
    ],
    "_scale": [
      "scale"
    ]
  },
  "Mixture": {
    "arg_constraints": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "weights",
      "components",
      "validate_args"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "support": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ],
    "cdf": [
      "self",
      "value"
    ]
  },
  "MixtureOutput": {
    "distr_cls": [],
    "__init__": [
      "self",
      "components"
    ],
    "_distribution": [
      "self",
      "distr_params",
      "validate_args"
    ],
    "args_dim": [
      "self"
    ],
    "domain_map": [
      "self"
    ]
  },
  "tree_map_multi": [
    "func",
    "tree"
  ],
  "convert_to_module": [
    "tree"
  ],
  "convert_to_container": [
    "tree"
  ],
  "DistrParamProj": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "args_dim",
      "domain_map",
      "proj_layer"
    ],
    "forward": [
      "self"
    ]
  },
  "AffineTransformed": {
    "__init__": [
      "self",
      "base_dist",
      "loc",
      "scale",
      "validate_args"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "DistributionOutput": {
    "distribution": [
      "self",
      "distr_params",
      "loc",
      "scale",
      "validate_args"
    ],
    "_distribution": [
      "self",
      "distr_params",
      "validate_args"
    ],
    "args_dim": [
      "self"
    ],
    "domain_map": [
      "self"
    ],
    "get_param_proj": [
      "self",
      "in_features",
      "out_features",
      "proj_layer"
    ]
  },
  "StudentTOutput": {
    "distr_cls": [],
    "args_dim": [],
    "domain_map": [
      "self"
    ],
    "_df": [
      "df"
    ],
    "_loc": [
      "loc"
    ],
    "_scale": [
      "scale"
    ]
  },
  "NormalOutput": {
    "distr_cls": [],
    "args_dim": [],
    "domain_map": [
      "self"
    ],
    "_loc": [
      "loc"
    ],
    "_scale": [
      "scale"
    ]
  },
  "NormalFixedScaleOutput": {
    "distr_cls": [],
    "args_dim": [],
    "__init__": [
      "self",
      "scale"
    ],
    "domain_map": [
      "self"
    ],
    "_loc": [
      "loc"
    ],
    "_distribution": [
      "self",
      "distr_params",
      "validate_args"
    ]
  },
  "NegativeBinomial": {
    "arg_constraints": [],
    "support": [],
    "has_rsample": [],
    "__init__": [
      "self",
      "total_count",
      "logits",
      "validate_args"
    ],
    "expand": [
      "self",
      "batch_shape",
      "_instance"
    ],
    "probs": [
      "self"
    ],
    "sample": [
      "self",
      "sample_shape"
    ],
    "log_prob": [
      "self",
      "value"
    ],
    "_lbeta": [
      "self",
      "x",
      "y"
    ],
    "mean": [
      "self"
    ],
    "variance": [
      "self"
    ]
  },
  "NegativeBinomialOutput": {
    "distr_cls": [],
    "args_dim": [],
    "domain_map": [
      "self"
    ],
    "_total_count": [
      "total_count"
    ],
    "_logits": [
      "logits"
    ]
  },
  "PackedLoss": {
    "__call__": [
      "self",
      "pred",
      "target",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ],
    "_loss_func": [
      "self",
      "pred",
      "target",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ],
    "reduce_loss": [
      "self",
      "loss",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ],
    "__repr__": [
      "self"
    ]
  },
  "PackedDistributionLoss": {
    "_loss_func": [
      "self",
      "pred",
      "target",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "PackedNLLLoss": {
    "_loss_func": [
      "self",
      "pred",
      "target",
      "prediction_mask",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "packed_attention_mask": [
    "sample_id"
  ],
  "mask_fill": [
    "tensor",
    "mask",
    "value"
  ],
  "safe_div": [
    "numer",
    "denom"
  ],
  "size_to_mask": [
    "max_size",
    "sizes"
  ],
  "unsqueeze_trailing_dims": [
    "x",
    "shape"
  ],
  "abstract_class_property": [],
  "RMSNorm": {
    "__init__": [
      "self",
      "normalized_shape",
      "eps",
      "weight",
      "dtype"
    ],
    "forward": [
      "self",
      "x"
    ],
    "extra_repr": [
      "self"
    ]
  },
  "fs2idx": [
    "feat_size",
    "feat_sizes"
  ],
  "MultiInSizeLinear": {
    "__init__": [
      "self",
      "in_features_ls",
      "out_features",
      "bias",
      "dtype"
    ],
    "reset_parameters": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "in_feat_size"
    ],
    "extra_repr": [
      "self"
    ]
  },
  "MultiOutSizeLinear": {
    "__init__": [
      "self",
      "in_features",
      "out_features_ls",
      "dim",
      "bias",
      "dtype"
    ],
    "reset_parameters": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "out_feat_size"
    ],
    "extra_repr": [
      "self"
    ]
  },
  "PackedScaler": {
    "forward": [
      "self",
      "target",
      "observed_mask",
      "sample_id",
      "variate_id"
    ],
    "_get_loc_scale": [
      "self",
      "target",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "PackedNOPScaler": {
    "_get_loc_scale": [
      "self",
      "target",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "PackedStdScaler": {
    "__init__": [
      "self",
      "correction",
      "minimum_scale"
    ],
    "_get_loc_scale": [
      "self",
      "target",
      "observed_mask",
      "sample_id",
      "variate_id"
    ]
  },
  "native_scaled_dot_product_attention": [
    "query",
    "key",
    "value",
    "attn_mask",
    "dropout_p",
    "scale"
  ],
  "GroupedQueryAttention": {
    "__init__": [
      "self",
      "dim",
      "num_heads",
      "num_groups",
      "bias",
      "norm_layer",
      "softmax_scale",
      "attn_dropout_p",
      "var_attn_bias",
      "time_attn_bias",
      "var_qk_proj",
      "time_qk_proj"
    ],
    "_get_var_id": [
      "self",
      "query",
      "key",
      "query_var_id",
      "kv_var_id"
    ],
    "_get_time_id": [
      "self",
      "query",
      "key",
      "query_time_id",
      "kv_time_id"
    ],
    "_update_attn_mask": [
      "self",
      "attn_mask",
      "query",
      "key",
      "query_var_id",
      "kv_var_id",
      "query_time_id",
      "kv_time_id"
    ],
    "_qk_proj": [
      "self",
      "query",
      "key",
      "query_var_id",
      "kv_var_id",
      "query_time_id",
      "kv_time_id"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "value",
      "attn_mask",
      "query_var_id",
      "kv_var_id",
      "query_time_id",
      "kv_time_id"
    ]
  },
  "TransformerEncoderLayer": {
    "__init__": [
      "self",
      "self_attn",
      "ffn",
      "norm1",
      "norm2",
      "post_attn_dropout_p",
      "pre_norm"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask",
      "var_id",
      "time_id"
    ],
    "_sa_block": [
      "self",
      "x",
      "attn_mask",
      "var_id",
      "time_id"
    ]
  },
  "TransformerEncoder": {
    "__init__": [
      "self",
      "d_model",
      "num_layers",
      "num_heads",
      "num_groups",
      "pre_norm",
      "attn_dropout_p",
      "dropout_p",
      "norm_layer",
      "activation",
      "use_glu",
      "use_qk_norm",
      "var_attn_bias_layer",
      "time_attn_bias_layer",
      "var_qk_proj_layer",
      "time_qk_proj_layer",
      "shared_var_attn_bias",
      "shared_time_attn_bias",
      "shared_var_qk_proj",
      "shared_time_qk_proj",
      "d_ff"
    ],
    "get_layer": [
      "dim",
      "num_heads",
      "num_groups",
      "layer",
      "shared_layer"
    ],
    "forward": [
      "self",
      "x",
      "attn_mask",
      "var_id",
      "time_id"
    ]
  },
  "FeedForward": {
    "__init__": [
      "self",
      "in_dim",
      "hidden_dim",
      "out_dim",
      "activation",
      "bias",
      "ffn_dropout_p"
    ],
    "forward": [
      "self",
      "x"
    ],
    "_in_proj": [
      "self",
      "x"
    ]
  },
  "GatedLinearUnitFeedForward": {
    "__init__": [
      "self",
      "in_dim",
      "hidden_dim",
      "out_dim",
      "activation",
      "bias",
      "ffn_dropout_p"
    ],
    "adjust_hidden_dim": [
      "dim"
    ],
    "_in_proj": [
      "self",
      "x"
    ]
  },
  "AttentionBias": {
    "__init__": [
      "self",
      "dim",
      "num_heads",
      "num_groups"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "query_id",
      "kv_id"
    ]
  },
  "BinaryAttentionBias": {
    "__init__": [
      "self",
      "dim",
      "num_heads",
      "num_groups"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "query_id",
      "kv_id"
    ]
  },
  "Projection": {
    "__init__": [
      "self",
      "proj_width",
      "num_heads",
      "num_groups"
    ],
    "forward": [
      "self",
      "x",
      "seq_id"
    ]
  },
  "RotaryProjection": {
    "__init__": [
      "self"
    ],
    "_init_freq": [
      "self",
      "max_len"
    ],
    "_rotate": [
      "x"
    ],
    "forward": [
      "self",
      "x",
      "seq_id"
    ]
  },
  "QueryKeyProjection": {
    "__init__": [
      "self",
      "dim",
      "num_heads",
      "num_groups",
      "proj_layer",
      "kwargs",
      "key_proj_layer",
      "key_kwargs",
      "partial_factor"
    ],
    "proj_width": [
      "self"
    ],
    "split_sizes": [
      "self"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "query_id",
      "kv_id"
    ]
  },
  "PresplitFilesCV": {
    "__init__": [
      "self",
      "cv"
    ],
    "split": [
      "self",
      "data",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self"
    ]
  },
  "SingleSplit": {
    "__init__": [
      "self",
      "test_size",
      "train_size",
      "random_state",
      "shuffle",
      "stratify"
    ],
    "split": [
      "self",
      "data",
      "y",
      "groups"
    ],
    "get_n_splits": []
  },
  "_check_id_format": [
    "id_format",
    "id"
  ],
  "run_clustering_experiment": [
    "trainX",
    "clusterer",
    "results_path",
    "trainY",
    "testX",
    "testY",
    "cls_name",
    "dataset_name",
    "resample_id",
    "overwrite"
  ],
  "load_and_run_clustering_experiment": [
    "problem_path",
    "results_path",
    "dataset",
    "clusterer",
    "resample_id",
    "cls_name",
    "overwrite",
    "format",
    "train_file"
  ],
  "run_classification_experiment": [
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "classifier",
    "results_path",
    "cls_name",
    "dataset",
    "resample_id",
    "train_file",
    "test_file"
  ],
  "load_and_run_classification_experiment": [
    "problem_path",
    "results_path",
    "dataset",
    "classifier",
    "resample_id",
    "cls_name",
    "overwrite",
    "build_train",
    "predefined_resample"
  ],
  "BaseTask": {
    "__init__": [
      "self",
      "target",
      "features",
      "metadata"
    ],
    "target": [
      "self"
    ],
    "features": [
      "self"
    ],
    "metadata": [
      "self"
    ],
    "set_metadata": [
      "self",
      "metadata"
    ],
    "check_data_compatibility": [
      "self",
      "metadata"
    ],
    "_get_param_names": [
      "cls"
    ],
    "_get_params": [
      "self"
    ]
  },
  "TSCTask": {
    "__init__": [
      "self",
      "target",
      "features",
      "metadata"
    ]
  },
  "TSRTask": {
    "__init__": [
      "self",
      "target",
      "features",
      "metadata"
    ]
  },
  "RAMResults": {
    "__init__": [
      "self"
    ],
    "save_predictions": [
      "self",
      "strategy_name",
      "dataset_name",
      "y_true",
      "y_pred",
      "y_proba",
      "index",
      "cv_fold",
      "train_or_test",
      "fit_estimator_start_time",
      "fit_estimator_end_time",
      "predict_estimator_start_time",
      "predict_estimator_end_time"
    ],
    "load_predictions": [
      "self",
      "cv_fold",
      "train_or_test"
    ],
    "check_predictions_exist": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ],
    "save_fitted_strategy": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold"
    ],
    "load_fitted_strategy": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold"
    ],
    "check_fitted_strategy_exists": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold"
    ],
    "save": [
      "self"
    ],
    "_generate_key": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ]
  },
  "HDDResults": {
    "save_predictions": [
      "self",
      "strategy_name",
      "dataset_name",
      "y_true",
      "y_pred",
      "y_proba",
      "index",
      "cv_fold",
      "train_or_test",
      "fit_estimator_start_time",
      "fit_estimator_end_time",
      "predict_estimator_start_time",
      "predict_estimator_end_time"
    ],
    "load_predictions": [
      "self",
      "cv_fold",
      "train_or_test"
    ],
    "save_fitted_strategy": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold"
    ],
    "load_fitted_strategy": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold"
    ],
    "check_fitted_strategy_exists": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold"
    ],
    "check_predictions_exist": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ],
    "_generate_key": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ]
  },
  "Evaluator": {
    "__init__": [
      "self",
      "results"
    ],
    "metric_names": [
      "self"
    ],
    "metrics": [
      "self"
    ],
    "metrics_by_strategy": [
      "self"
    ],
    "metrics_by_strategy_dataset": [
      "self"
    ],
    "evaluate": [
      "self",
      "metric",
      "train_or_test",
      "cv_fold"
    ],
    "plot_boxplots": [
      "self",
      "metric_name"
    ],
    "rank": [
      "self",
      "metric_name",
      "ascending"
    ],
    "t_test": [
      "self",
      "metric_name"
    ],
    "sign_test": [
      "self",
      "metric_name"
    ],
    "ranksum_test": [
      "self",
      "metric_name"
    ],
    "t_test_with_bonferroni_correction": [
      "self",
      "metric_name",
      "alpha"
    ],
    "wilcoxon_test": [
      "self",
      "metric_name"
    ],
    "friedman_test": [
      "self",
      "metric_name"
    ],
    "nemenyi": [
      "self",
      "metric_name"
    ],
    "fit_runtime": [
      "self",
      "unit",
      "train_or_test",
      "cv_fold"
    ],
    "plot_critical_difference_diagram": [
      "self",
      "metric_name",
      "alpha"
    ],
    "_get_column_name": [
      "self",
      "metric_name",
      "suffix"
    ],
    "_check_is_evaluated": [
      "self"
    ],
    "_validate_metric_name": [
      "self",
      "metric_name"
    ],
    "_get_metrics_per_estimator_dataset": [
      "self",
      "metric_name"
    ],
    "_get_metrics_per_estimator": [
      "self",
      "metric_name"
    ]
  },
  "ForecastingBenchmark": {
    "add_task": [
      "self",
      "dataset_loader",
      "cv_splitter",
      "scorers",
      "task_id",
      "cv_global",
      "error_score",
      "strategy",
      "cv_global_temporal"
    ],
    "_run_validation": [
      "self",
      "task",
      "estimator"
    ]
  },
  "BaseDataset": {
    "__init__": [
      "self",
      "name"
    ],
    "__repr__": [
      "self"
    ],
    "load": [
      "self"
    ],
    "name": [
      "self"
    ]
  },
  "HDDBaseDataset": {
    "__init__": [
      "self",
      "path",
      "name"
    ],
    "path": [
      "self"
    ],
    "_validate_path": [
      "path"
    ]
  },
  "BaseResults": {
    "__init__": [
      "self"
    ],
    "save_predictions": [
      "self",
      "strategy_name",
      "dataset_name",
      "y_true",
      "y_pred",
      "y_proba",
      "index",
      "cv_fold",
      "train_or_test"
    ],
    "load_predictions": [
      "self",
      "cv_fold",
      "train_or_test"
    ],
    "check_predictions_exist": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ],
    "save_fitted_strategy": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold"
    ],
    "load_fitted_strategy": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold"
    ],
    "check_fitted_strategy_exists": [
      "self",
      "strategy",
      "dataset_name",
      "cv_fold"
    ],
    "_append_key": [
      "self",
      "strategy_name",
      "dataset_name"
    ],
    "_generate_key": [
      "self",
      "strategy_name",
      "dataset_name",
      "cv_fold",
      "train_or_test"
    ],
    "__repr__": [
      "self"
    ],
    "save": [
      "self"
    ],
    "_iter": [
      "self"
    ]
  },
  "HDDBaseResults": {
    "__init__": [
      "self",
      "path"
    ],
    "path": [
      "self"
    ],
    "save": [
      "self"
    ],
    "_validate_path": [
      "path"
    ]
  },
  "_PredictionsWrapper": {
    "__init__": [
      "self",
      "strategy_name",
      "dataset_name",
      "index",
      "y_true",
      "y_pred",
      "fit_estimator_start_time",
      "fit_estimator_end_time",
      "predict_estimator_start_time",
      "predict_estimator_end_time",
      "y_proba"
    ]
  },
  "BaseMetric": {
    "__init__": [
      "self",
      "name"
    ],
    "compute": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "PairwiseMetric": {
    "__init__": [
      "self",
      "func",
      "name"
    ],
    "compute": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "AggregateMetric": {
    "__init__": [
      "self",
      "func",
      "method",
      "name"
    ],
    "compute": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_compute_jackknife_stderr": [
      "x"
    ],
    "_jackknife_resampling": [
      "x"
    ]
  },
  "BaseStorageHandler": {
    "__init__": [
      "self",
      "path"
    ],
    "save": [
      "self",
      "results"
    ],
    "load": [
      "self"
    ],
    "_load": [
      "self"
    ],
    "is_applicable": [
      "path"
    ]
  },
  "JSONStorageHandler": {
    "save": [
      "self",
      "results"
    ],
    "_load": [
      "self"
    ],
    "is_applicable": [
      "path"
    ]
  },
  "ParquetStorageHandler": {
    "save": [
      "self",
      "results"
    ],
    "_load": [
      "self"
    ],
    "is_applicable": [
      "path"
    ]
  },
  "CSVStorageHandler": {
    "save": [
      "self",
      "results"
    ],
    "_load": [
      "self"
    ],
    "is_applicable": [
      "path"
    ]
  },
  "NullStorageHandler": {
    "save": [
      "self",
      "results"
    ],
    "_load": [
      "self"
    ],
    "is_applicable": [
      "path"
    ]
  },
  "STORAGE_HANDLERS": [],
  "get_storage_backend": [
    "path"
  ],
  "_get_folds": [
    "row",
    "extract_data"
  ],
  "_create_df": [
    "fold_gts"
  ],
  "_check_friedman": [
    "n_strategies",
    "n_datasets",
    "ranked_data",
    "alpha"
  ],
  "plot_critical_difference": [
    "scores",
    "labels",
    "cliques",
    "is_errors",
    "alpha",
    "width",
    "textspace",
    "reverse"
  ],
  "log": [],
  "console": [],
  "Orchestrator": {
    "__init__": [
      "self",
      "tasks",
      "datasets",
      "strategies",
      "cv",
      "results"
    ],
    "_iter": [
      "self"
    ],
    "fit": [
      "self",
      "overwrite_fitted_strategies",
      "verbose"
    ],
    "predict": [
      "self",
      "overwrite_predictions",
      "predict_on_train",
      "verbose"
    ],
    "fit_predict": [
      "self",
      "overwrite_predictions",
      "predict_on_train",
      "save_fitted_strategies",
      "overwrite_fitted_strategies",
      "verbose"
    ],
    "_predict_proba_one": [
      "strategy",
      "task",
      "data",
      "y_true",
      "y_pred"
    ],
    "_validate_strategy_names": [
      "strategies"
    ],
    "_validate_tasks_and_datasets": [
      "tasks",
      "datasets"
    ],
    "_print_progress": [
      "self",
      "dataset_name",
      "strategy_name",
      "cv_fold",
      "train_or_test",
      "fit_or_predict",
      "verbose"
    ]
  },
  "_is_initialised_estimator": [
    "estimator"
  ],
  "_check_estimators_type": [
    "objs"
  ],
  "_coerce_estimator_and_id": [
    "estimators",
    "estimator_id"
  ],
  "_BenchmarkingResults": {
    "__post_init__": [
      "self"
    ],
    "update": [
      "self",
      "new_result"
    ],
    "save": [
      "self"
    ],
    "contains": [
      "self",
      "task_id",
      "model_id"
    ],
    "to_dataframe": [
      "self"
    ]
  },
  "_SktimeRegistry": {
    "__init__": [
      "self",
      "entity_id_format"
    ],
    "register": [
      "self",
      "entity_id",
      "entity"
    ]
  },
  "BaseBenchmark": {
    "__init__": [
      "self",
      "id_format",
      "backend",
      "backend_params",
      "return_data"
    ],
    "add_estimator": [
      "self",
      "estimator",
      "estimator_id"
    ],
    "_add_estimator": [
      "self",
      "estimator",
      "estimator_id"
    ],
    "_add_task": [
      "self",
      "task_id",
      "task"
    ],
    "add_task": [
      "self"
    ],
    "_run": [
      "self",
      "results_path",
      "force_rerun"
    ],
    "_generate_experiments": [
      "self"
    ],
    "run": [
      "self",
      "output_file",
      "force_rerun"
    ],
    "_run_validation": [
      "self",
      "task",
      "estimator"
    ]
  },
  "REGRESSOR_TYPES": [],
  "CLASSIFIER_TYPES": [],
  "FORECASTER_TYPES": [],
  "ESTIMATOR_TYPES": [],
  "CASES": [],
  "BaseStrategy": {
    "__init__": [
      "self",
      "estimator",
      "name"
    ],
    "name": [
      "self"
    ],
    "estimator": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "fit": [
      "self",
      "task",
      "data"
    ],
    "_check_task_compatibility": [
      "self",
      "task"
    ],
    "_check_estimator_compatibility": [
      "self",
      "estimator"
    ],
    "_validate_data": [
      "data"
    ],
    "save": [
      "self",
      "path"
    ],
    "load": [
      "self",
      "path"
    ],
    "__repr__": [
      "self"
    ]
  },
  "BaseSupervisedLearningStrategy": {
    "_fit": [
      "self",
      "data"
    ],
    "predict": [
      "self",
      "data"
    ]
  },
  "TSCStrategy": {
    "__init__": [
      "self",
      "estimator",
      "name"
    ]
  },
  "TSRStrategy": {
    "__init__": [
      "self",
      "estimator",
      "name"
    ]
  },
  "ClassificationBenchmark": {
    "add_task": [
      "self",
      "dataset_loader",
      "cv_splitter",
      "scorers",
      "task_id",
      "error_score"
    ],
    "_run_validation": [
      "self",
      "task",
      "estimator"
    ]
  },
  "UEADataset": {
    "__init__": [
      "self",
      "path",
      "name",
      "suffix_train",
      "suffix_test",
      "fmt",
      "target_name"
    ],
    "load": [
      "self"
    ]
  },
  "RAMDataset": {
    "__init__": [
      "self",
      "dataset",
      "name"
    ],
    "load": [
      "self"
    ]
  },
  "make_datasets": [
    "path",
    "dataset_cls",
    "names"
  ],
  "_coerce_data_for_evaluate": [
    "dataset_loader",
    "task_type"
  ],
  "TaskObject": {
    "cv_X": [],
    "get_y_X": [
      "self",
      "task_type"
    ]
  },
  "FoldResults": {
    "__post_init__": [
      "self"
    ]
  },
  "ResultObject": {
    "__post_init__": [
      "self"
    ],
    "to_dataframe": [
      "self"
    ]
  },
  "asdict": [
    "obj"
  ],
  "_asdict_inner": [
    "obj",
    "dict_factory",
    "pd_orient"
  ],
  "REPOPATH": [],
  "DATAPATH": [],
  "make_reduction_pipeline": [
    "estimator"
  ],
  "test_automated_orchestration_vs_manual": [
    "data_loader"
  ],
  "test_single_dataset_single_strategy_against_sklearn": [
    "dataset",
    "cv",
    "metric_func",
    "estimator",
    "results_cls",
    "tmpdir"
  ],
  "test_stat": [],
  "test_classification_benchmark": [
    "tmp_path",
    "write_file"
  ],
  "test_add_list_estimators": [
    "tmp_path"
  ],
  "test_add_dict_estimators": [
    "tmp_path"
  ],
  "test_add_estimator_twice": [
    "tmp_path"
  ],
  "test_add_multiple_task": [
    "tmp_path"
  ],
  "test_multiple_dataset_format": [
    "tmp_path"
  ],
  "gunpoint": [],
  "shampoo_sales": [],
  "BASE_READONLY_ATTRS": [],
  "test_readonly_attributes": [
    "attr"
  ],
  "test_check_data_compatibility": [
    "task"
  ],
  "check_set_metadata": [
    "task",
    "target",
    "metadata"
  ],
  "test_set_metadata_supervised": [
    "task"
  ],
  "classifier": [],
  "DATASET_LOADERS": [],
  "test_TSCStrategy": [
    "dataset"
  ],
  "test_run_clustering_experiment": [
    "tmp_path"
  ],
  "test_run_classification_experiment": [
    "tmp_path"
  ],
  "RESULT_OBJECT_LISTS": [],
  "test_store_load_results": [
    "tmp_path",
    "storage_handler",
    "file_extension",
    "sample_results"
  ],
  "test_store_load_results_empty_training": [
    "tmp_path",
    "storage_handler",
    "file_extension"
  ],
  "EXPECTED_RESULTS_1": [],
  "EXPECTED_RESULTS_2": [],
  "EXPECTED_RESULTS_GLOBAL_1": [],
  "EXPECTED_RESULTS_GLOBAL_2": [],
  "COER_CASES": [],
  "data_loader_simple": [],
  "data_loader_global": [],
  "test_forecastingbenchmark": [
    "tmp_path",
    "expected_results_df",
    "scorers"
  ],
  "test_forecastingbenchmark_global_mode": [
    "tmp_path",
    "expected_results_df",
    "scorers"
  ],
  "test_coerce_estimator_and_id": [
    "estimator",
    "estimator_id",
    "expected_output"
  ],
  "test_multiple_estimators": [
    "estimators"
  ],
  "test_dataset_different_format": [
    "tmp_path"
  ],
  "test_raise_id_restraint": [],
  "test_dataset_classes": [
    "tmp_path"
  ],
  "dummy_results": [],
  "evaluator_setup": [
    "score_function"
  ],
  "test_rank": [],
  "test_accuracy_score": [],
  "test_sign_test": [],
  "test_ranksum_test": [],
  "test_t_test_bonfer": [],
  "test_nemenyi": [],
  "test_plots": [],
  "test_wilcoxon": [],
  "test_run_times": [],
  "AlignerDtwNumba": {
    "_tags": [],
    "__init__": [
      "self",
      "weighted",
      "derivative",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AlignerDTW": {
    "_tags": [],
    "__init__": [
      "self",
      "dist_method",
      "step_pattern",
      "window_type",
      "window_size",
      "open_begin",
      "open_end",
      "variable_to_align"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AlignerDTWfromDist": {
    "_tags": [],
    "__init__": [
      "self",
      "dist_trafo",
      "step_pattern",
      "window_type",
      "window_size",
      "open_begin",
      "open_end"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AlignerNaive": {
    "_tags": [],
    "__init__": [
      "self",
      "strategy"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseAligner": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "Z"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "get_alignment": [
      "self"
    ],
    "_get_alignment": [
      "self"
    ],
    "get_alignment_loc": [
      "self"
    ],
    "_get_alignment_loc": [
      "self"
    ],
    "get_aligned": [
      "self"
    ],
    "_get_aligned": [
      "self"
    ],
    "get_distance": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "get_distance_matrix": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "_check_capabilities": [
      "self",
      "X_metadata"
    ]
  },
  "AlignerLuckyDtw": {
    "_tags": [],
    "__init__": [
      "self",
      "window"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AlignerDtwDtai": {
    "_tags": [],
    "__init__": [
      "self",
      "use_c",
      "window",
      "max_dist",
      "max_step",
      "max_length_diff",
      "penalty",
      "psi",
      "inner_dist"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AlignerEditNumba": {
    "_tags": [],
    "ALLOWED_DISTANCE_STR": [],
    "__init__": [
      "self",
      "distance",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "epsilon",
      "g",
      "lmbda",
      "nu",
      "p"
    ],
    "_fit": [
      "self",
      "X",
      "Z"
    ],
    "_get_alignment": [
      "self"
    ],
    "_get_distance": [
      "self"
    ],
    "_get_distance_matrix": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "INVALID_X_INPUT_TYPES": [],
  "INVALID_y_INPUT_TYPES": [],
  "AlignerFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllAligners": {
    "test_get_alignment": [
      "self",
      "estimator_instance"
    ],
    "test_get_alignment_loc": [
      "self",
      "estimator_instance"
    ],
    "test_get_aligned": [
      "self",
      "estimator_instance"
    ],
    "test_get_distance": [
      "self",
      "estimator_instance"
    ],
    "test_get_distance_matrix": [
      "self",
      "estimator_instance"
    ]
  },
  "reindex_iloc": [
    "df",
    "inds",
    "copy"
  ],
  "convert_align_to_align_loc": [
    "align",
    "X",
    "align_name",
    "df_name",
    "copy"
  ],
  "MATRIXDESIGN": [],
  "ONLY_CHANGED_MODULES": [],
  "EXCLUDE_ESTIMATORS": [],
  "EXCLUDED_TESTS": [],
  "EXCLUDED_TESTS_BY_TEST": [],
  "EXCLUDE_SOFT_DEPS": [],
  "VALID_ESTIMATOR_TAGS": [],
  "NON_STATE_CHANGING_METHODS_ARRAYLIKE": [],
  "NON_STATE_CHANGING_METHODS": [],
  "EXCLUDE_MODULES_STARTING_WITH": [],
  "_all_functions": [
    "module_name"
  ],
  "_all_functions_cached": [
    "module_name",
    "only_changed_modules"
  ],
  "pytest_generate_tests": [
    "metafunc"
  ],
  "test_all_functions_doctest": [
    "func"
  ],
  "run_test_vm": [
    "cls_name"
  ],
  "get_test_class_registry": [],
  "get_test_classes_for_obj": [
    "obj"
  ],
  "SOFT_DEPENDENCIES": [],
  "MODULES_TO_IGNORE": [],
  "EXCEPTED_FROM_NO_DEP_CHECK": [],
  "_is_test": [
    "module"
  ],
  "_is_ignored": [
    "module"
  ],
  "_is_private": [
    "module"
  ],
  "_extract_dependency_from_error_msg": [
    "msg"
  ],
  "modules": [],
  "is_soft_dep_missing_message": [
    "msg"
  ],
  "test_module_softdeps": [
    "module"
  ],
  "_has_soft_dep": [
    "est"
  ],
  "_coerce_list_of_str": [
    "obj"
  ],
  "_get_soft_deps": [
    "est"
  ],
  "_is_in_env": [
    "modules"
  ],
  "_python_compat": [
    "est"
  ],
  "all_ests": [],
  "est_python_incompatible": [],
  "est_with_soft_dep": [],
  "est_pyok_with_soft_dep": [],
  "est_without_soft_dep": [],
  "est_pyok_without_soft_dep": [],
  "test_python_error": [
    "estimator"
  ],
  "test_softdep_error": [
    "estimator"
  ],
  "test_est_construct_if_softdep_available": [
    "estimator"
  ],
  "test_est_get_params_without_modulenotfound": [
    "estimator"
  ],
  "test_est_construct_without_modulenotfound": [
    "estimator"
  ],
  "test_est_fit_without_modulenotfound": [
    "estimator"
  ],
  "test_check_python_version": [
    "mock_sys",
    "mock_release_version",
    "prereleases",
    "expect_exception"
  ],
  "subsample_by_version_os": [
    "x"
  ],
  "ValidProbaErrors": {
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "traceback"
    ]
  },
  "BaseFixtureGenerator": {
    "estimator_type_filter": [],
    "fixture_sequence": [],
    "indirect_fixtures": [],
    "pytest_generate_tests": [
      "self",
      "metafunc"
    ],
    "_all_estimators": [
      "self"
    ],
    "generator_dict": [
      "self"
    ],
    "is_excluded": [
      "test_name",
      "est"
    ],
    "_generate_estimator_class": [
      "self",
      "test_name"
    ],
    "_generate_estimator_instance": [
      "self",
      "test_name"
    ],
    "estimator_instance": [
      "self",
      "request"
    ],
    "_generate_scenario": [
      "self",
      "test_name"
    ],
    "_excluded_scenario": [
      "test_name",
      "scenario"
    ],
    "_generate_method_nsc": [
      "self",
      "test_name"
    ],
    "_generate_method_nsc_arraylike": [
      "self",
      "test_name"
    ]
  },
  "QuickTester": {
    "run_tests": [
      "self",
      "estimator",
      "raise_exceptions",
      "tests_to_run",
      "fixtures_to_run",
      "tests_to_exclude",
      "fixtures_to_exclude",
      "verbose"
    ],
    "_check_None_str_or_list_of_str": [
      "obj",
      "var_name"
    ],
    "_get_pytest_mark_args": [
      "fun"
    ],
    "_product_fixtures": [
      "fixture_vars",
      "fixture_prod",
      "fixture_names",
      "pytest_fixture_vars",
      "pytest_fixture_prod",
      "pytest_fixture_names"
    ],
    "_make_builtin_fixture_equivalents": [
      "self",
      "name"
    ]
  },
  "TestAllObjects": {
    "estimator_type_filter": [],
    "test_doctest_examples": [
      "self",
      "estimator_class"
    ],
    "test_create_test_instance": [
      "self",
      "estimator_class"
    ],
    "test_get_test_params": [
      "self",
      "estimator_class"
    ],
    "test_get_test_params_coverage": [
      "self",
      "estimator_class"
    ],
    "test_create_test_instances_and_names": [
      "self",
      "estimator_class"
    ],
    "test_estimator_tags": [
      "self",
      "estimator_class"
    ],
    "test_inheritance": [
      "self",
      "estimator_class"
    ],
    "test_has_common_interface": [
      "self",
      "estimator_class"
    ],
    "test_no_cross_test_side_effects_part1": [
      "self",
      "estimator_instance"
    ],
    "test_no_cross_test_side_effects_part2": [
      "self",
      "estimator_instance"
    ],
    "test_no_between_test_case_side_effects": [
      "self",
      "estimator_instance",
      "scenario",
      "a"
    ],
    "test_get_params": [
      "self",
      "estimator_instance"
    ],
    "test_set_params": [
      "self",
      "estimator_instance"
    ],
    "test_set_params_sklearn": [
      "self",
      "estimator_class"
    ],
    "test_clone": [
      "self",
      "estimator_instance"
    ],
    "test_repr": [
      "self",
      "estimator_instance"
    ],
    "test_repr_html": [
      "self",
      "estimator_instance"
    ],
    "test_constructor": [
      "self",
      "estimator_class"
    ],
    "test_valid_estimator_class_tags": [
      "self",
      "estimator_class"
    ],
    "test_valid_estimator_tags": [
      "self",
      "estimator_instance"
    ],
    "test_random_tags": [
      "self",
      "estimator_class"
    ],
    "test_obj_vs_cls_signature": [
      "self",
      "estimator_class"
    ]
  },
  "TestAllEstimators": {
    "test_fit_updates_state": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_fit_returns_self": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_raises_not_fitted_error": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc"
    ],
    "test_fit_idempotent": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc_arraylike"
    ],
    "test_fit_does_not_overwrite_hyper_params": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_non_state_changing_method_contract": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc"
    ],
    "test_methods_have_no_side_effects": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc"
    ],
    "test_persistence_via_pickle": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc_arraylike"
    ],
    "test_save_estimators_to_file": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc_arraylike"
    ],
    "test_multiprocessing_idempotent": [
      "self",
      "estimator_instance",
      "scenario",
      "method_nsc_arraylike"
    ],
    "test_dl_constructor_initializes_deeply": [
      "self",
      "estimator_class"
    ]
  },
  "LOCAL_PACKAGE": [],
  "run_test_for_class": [
    "cls",
    "return_reason"
  ],
  "_flatten_list": [
    "nested_list"
  ],
  "_run_test_for_class": [
    "cls",
    "ignore_deps",
    "only_changed_modules",
    "only_vm_required"
  ],
  "run_test_module_changed": [
    "module",
    "only_changed_modules"
  ],
  "_get_all_changed_classes": [
    "vm"
  ],
  "test_excluded_tests_by_test": [],
  "test_exclude_estimators": [],
  "test_run_test_for_class": [],
  "Primitive": [],
  "Primitives": [],
  "Tabular": [],
  "UnivariateSeries": [],
  "MultivariateSeries": [],
  "Series": [],
  "Panel": [],
  "_coerce_to_list": [
    "obj"
  ],
  "BaseTransformer": {
    "_tags": [],
    "_config": [],
    "_config_doc": [],
    "ALLOWED_INPUT_MTYPES": [],
    "__init__": [
      "self"
    ],
    "_is_transformer": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__invert__": [
      "self"
    ],
    "__neg__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "update": [
      "self",
      "X",
      "y",
      "update_params"
    ],
    "get_fitted_params": [
      "self",
      "deep"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y",
      "return_metadata"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_convert_output": [
      "self",
      "X",
      "metadata",
      "inverse"
    ],
    "_vectorize": [
      "self",
      "methodname"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ]
  },
  "_SeriesToPrimitivesTransformer": {
    "_tags": []
  },
  "_SeriesToSeriesTransformer": {
    "_tags": []
  },
  "_PanelToTabularTransformer": {
    "_tags": []
  },
  "_PanelToPanelTransformer": {
    "_tags": []
  },
  "_DelegatedTransformer": {
    "_delegate_name": [],
    "_get_delegate": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y",
      "update_params"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "Merger": {
    "_tags": [],
    "__init__": [
      "self",
      "method",
      "stride"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_align_temporal": [
      "self",
      "horizon",
      "x"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "est_tuples": [],
  "_online_shapelet_distance": [
    "series",
    "shapelet",
    "sorted_indices",
    "position",
    "length"
  ],
  "_calc_early_binary_ig": [
    "orderline",
    "c1_traversed",
    "c2_traversed",
    "c1_to_add",
    "c2_to_add",
    "worst_quality"
  ],
  "_calc_binary_ig": [
    "orderline",
    "c1",
    "c2"
  ],
  "_binary_entropy": [
    "c1",
    "c2"
  ],
  "_is_self_similar": [
    "s1",
    "s2"
  ],
  "_find_shapelet_quality": [
    "X",
    "y",
    "shapelet",
    "sorted_indices",
    "position",
    "length",
    "dim",
    "inst_idx",
    "this_cls_count",
    "other_cls_count",
    "worst_quality"
  ],
  "_merge_shapelets": [
    "shapelet_heap",
    "candidate_shapelets",
    "max_shapelets_per_class",
    "cls_idx"
  ],
  "_remove_self_similar_shapelets": [
    "shapelet_heap"
  ],
  "_remove_identical_shapelets": [
    "shapelets"
  ],
  "HOG1DTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "num_intervals",
      "num_bins",
      "scaling_factor"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_calculate_hog1ds": [
      "self",
      "X"
    ],
    "_get_hog1d": [
      "self",
      "X"
    ],
    "_split_time_series": [
      "self",
      "X"
    ],
    "_check_parameters": [
      "self",
      "num_atts"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DistanceFeatures": {
    "_tags": [],
    "__init__": [
      "self",
      "distance",
      "distance_mtype",
      "flatten_hierarchy"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_histogram_mode": [
    "X",
    "num_bins",
    "smin",
    "smax"
  ],
  "_long_stretch": [
    "X_binary",
    "val"
  ],
  "_outlier_include": [
    "X"
  ],
  "_autocorr": [
    "X",
    "X_fft"
  ],
  "_multiply_complex_arr": [
    "X_fft"
  ],
  "_get_acf": [
    "X",
    "ca"
  ],
  "_summaries_welch_rect": [
    "X",
    "centroid",
    "X_fft"
  ],
  "_complex_magnitude": [
    "c"
  ],
  "_local_simple_mean": [
    "X",
    "train_length"
  ],
  "_ac_first_zero": [
    "X_ac"
  ],
  "_fluct_prop": [
    "X",
    "og_length",
    "dfa"
  ],
  "_linear_regression": [
    "X",
    "y",
    "n",
    "lag"
  ],
  "_spline_fit": [
    "X"
  ],
  "_normalise_series": [
    "X",
    "mean"
  ],
  "_perform_fft": [
    "series",
    "smean"
  ],
  "_DN_HistogramMode_5": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_DN_HistogramMode_10": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SB_BinaryStats_diff_longstretch0": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_DN_OutlierInclude_p_001_mdrmd": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_DN_OutlierInclude_n_001_mdrmd": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_CO_f1ecac": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_CO_FirstMin_ac": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SP_Summaries_welch_rect_area_5_1": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SP_Summaries_welch_rect_centroid": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_FC_LocalSimple_mean3_stderr": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_CO_trev_1_num": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_CO_HistogramAMI_even_2_5": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_IN_AutoMutualInfoStats_40_gaussian_fmmi": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_MD_hrv_classic_pnn40": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SB_BinaryStats_mean_longstretch1": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SB_MotifThree_quantile_hh": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_FC_LocalSimple_mean1_tauresrat": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_CO_Embed2_Dist_tau_d_expfit_meandiff": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SC_FluctAnal_2_dfa_50_1_2_logi_prop_r1": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SC_FluctAnal_2_rsrangefit_50_1_logi": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_SB_TransitionMatrix_3ac_sumdiagcov": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_PD_PeriodicityWang_th0_01": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_catch24_mean": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "_catch24_std": [
    "series",
    "smin",
    "smax",
    "smean",
    "std",
    "outlier_series",
    "ac",
    "acfz"
  ],
  "TSInterpolator": {
    "_tags": [],
    "__init__": [
      "self",
      "length"
    ],
    "_resize_cell": [
      "self",
      "cell"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "PCATransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_components",
      "copy",
      "whiten",
      "svd_solver",
      "tol",
      "iterated_power",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ColumnTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "transformers",
      "remainder",
      "sparse_threshold",
      "n_jobs",
      "transformer_weights",
      "preserve_dataframe"
    ],
    "_hstack": [
      "self",
      "Xs"
    ],
    "_validate_output": [
      "self",
      "result"
    ],
    "get_test_params": [
      "cls"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ColumnConcatenator": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_eu_dist": [
    "x",
    "y"
  ],
  "_detect_knee_point": [
    "values",
    "indices"
  ],
  "_distance_matrix": {
    "distance": [
      "self",
      "centroid_frame"
    ]
  },
  "_shrunk_centroid": {
    "__init__": [
      "self",
      "shrink"
    ],
    "create_centroid": [
      "self",
      "X",
      "y"
    ]
  },
  "ElbowClassSum": {
    "_tags": [],
    "__init__": [
      "self",
      "distance"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ElbowClassPairwise": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_sliding_dot_products": [
    "q",
    "t",
    "q_len",
    "t_len"
  ],
  "_calculate_distance_profile": [
    "dot_prod",
    "q_mean",
    "q_std",
    "t_mean",
    "t_std",
    "q_len",
    "n_t_subs"
  ],
  "_minimum_distance": [
    "mp",
    "ip",
    "dp",
    "i",
    "m",
    "dp_len"
  ],
  "_stomp_self": [
    "ts",
    "m"
  ],
  "MatrixProfile": {
    "_tags": [],
    "__init__": [
      "self",
      "m"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "Tabularizer": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TimeBinner": {
    "_tags": [],
    "__init__": [
      "self",
      "idx",
      "aggfunc"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PaddingTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "pad_length",
      "fill_value"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_create_pad": [
      "self",
      "series"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_get_max_length": [
    "X"
  ],
  "SlopeTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "num_intervals"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_gradients_of_lines": [
      "self",
      "X"
    ],
    "_get_gradient": [
      "self",
      "Y"
    ],
    "_split_time_series": [
      "self",
      "X"
    ],
    "_check_parameters": [
      "self",
      "n_timepoints"
    ]
  },
  "TruncationTransformer": {
    "_tags": [],
    "error_messages": [],
    "__init__": [
      "self",
      "lower",
      "upper"
    ],
    "_get_min_length": [
      "X"
    ],
    "_validate_parameters": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DWTTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "num_levels"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_extract_wavelet_coefficients": [
      "self",
      "data"
    ],
    "_check_parameters": [
      "self"
    ],
    "_get_approx_coefficients": [
      "self",
      "arr"
    ],
    "_get_wavelet_coefficients": [
      "self",
      "arr"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Catch22Wrapper": {
    "_tags": [],
    "__init__": [
      "self",
      "features",
      "catch24",
      "outlier_norm",
      "replace_nans",
      "col_names"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_fun_with_ix": [
      "self",
      "ix"
    ],
    "_transform_case": [
      "self",
      "X",
      "f_idx"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "feature_names": [],
  "SupervisedIntervals": {
    "_tags": [],
    "__init__": [
      "self",
      "n_intervals",
      "min_interval_length",
      "features",
      "randomised_split_point",
      "random_state",
      "n_jobs",
      "parallel_backend"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit_setup": [
      "self",
      "X",
      "y"
    ],
    "_generate_intervals": [
      "self",
      "X",
      "X_norm",
      "y",
      "idx",
      "keep_transform"
    ],
    "_transform_intervals": [
      "self",
      "X",
      "idx"
    ],
    "_supervised_search": [
      "self",
      "X",
      "y",
      "ini_idx",
      "feature",
      "dim",
      "X_ori",
      "rng",
      "keep_transform"
    ],
    "set_features_to_transform": [
      "self",
      "arr"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IntervalSegmenter": {
    "_tags": [],
    "__init__": [
      "self",
      "intervals"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RandomIntervalSegmenter": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "n_intervals",
      "min_length",
      "max_length",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_rand_intervals_rand_n": [
    "x",
    "random_state"
  ],
  "_rand_intervals_fixed_n": [
    "x",
    "n_intervals",
    "min_length",
    "max_length",
    "random_state"
  ],
  "SlidingWindowSegmenter": {
    "_tags": [],
    "__init__": [
      "self",
      "window_length"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_extract_subsequences": [
      "self",
      "instance",
      "n_timepoints"
    ],
    "_check_parameters": [
      "self",
      "n_timepoints"
    ]
  },
  "_get_n_from_n_timepoints": [
    "n_timepoints",
    "n"
  ],
  "_TSFreshFeatureExtractor": {
    "_tags": [],
    "__init__": [
      "self",
      "default_fc_parameters",
      "kind_to_fc_parameters",
      "chunksize",
      "n_jobs",
      "show_warnings",
      "disable_progressbar",
      "impute_function",
      "profiling",
      "profiling_filename",
      "profiling_sorting",
      "distributor"
    ],
    "_get_extraction_params": [
      "self"
    ]
  },
  "TSFreshFeatureExtractor": {
    "_tags": [],
    "__init__": [
      "self",
      "default_fc_parameters",
      "kind_to_fc_parameters",
      "chunksize",
      "n_jobs",
      "show_warnings",
      "disable_progressbar",
      "impute_function",
      "profiling",
      "profiling_filename",
      "profiling_sorting",
      "distributor"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSFreshRelevantFeatureExtractor": {
    "_tags": [],
    "__init__": [
      "self",
      "default_fc_parameters",
      "kind_to_fc_parameters",
      "chunksize",
      "n_jobs",
      "show_warnings",
      "disable_progressbar",
      "impute_function",
      "profiling",
      "profiling_filename",
      "profiling_sorting",
      "distributor",
      "test_for_binary_target_binary_feature",
      "test_for_binary_target_real_feature",
      "test_for_real_target_binary_feature",
      "test_for_real_target_real_feature",
      "fdr_level",
      "hypotheses_independent",
      "ml_task"
    ],
    "_get_selection_params": [
      "self"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "get_methods_dict": [
    "which"
  ],
  "SHORT_FEATURE_NAMES_DICT": [],
  "ALL_FEATURE_NAMES": [],
  "ALL_SHORT_FEATURE_NAMES": [],
  "CATCH22_FEATURE_NAMES": [],
  "CATCH22_SHORT_FEATURE_NAMES": [],
  "FEATURE_NAMES": [],
  "_verify_features": [
    "features",
    "catch24"
  ],
  "Catch22": {
    "_tags": [],
    "__init__": [
      "self",
      "features",
      "catch24",
      "outlier_norm",
      "replace_nans",
      "col_names"
    ],
    "_set_col_names": [
      "self",
      "col_names"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_transform_single_feature": [
      "self",
      "X",
      "feature",
      "case_id"
    ],
    "_transform_case": [
      "self",
      "X",
      "f_idx"
    ],
    "_get_feature_function": [
      "self",
      "feature"
    ],
    "__get_feature_function_str": [
      "self",
      "feature"
    ],
    "__get_feature_function_int": [
      "self",
      "feature"
    ],
    "_prepare_output_col_names": [
      "self",
      "n_features"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RandomIntervals": {
    "_tags": [],
    "__init__": [
      "self",
      "n_intervals",
      "transformers",
      "random_state",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiRocketMultivariate": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "max_dilations_per_kernel",
      "n_features_per_kernel",
      "normalise",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_parameter": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_generate_kernels": [
    "n_timepoints",
    "num_kernels",
    "n_columns",
    "seed"
  ],
  "_apply_kernel_univariate": [
    "X",
    "weights",
    "length",
    "bias",
    "dilation",
    "padding"
  ],
  "_apply_kernel_multivariate": [
    "X",
    "weights",
    "length",
    "bias",
    "dilation",
    "padding",
    "num_channel_indices",
    "channel_indices"
  ],
  "_apply_kernels": [
    "X",
    "kernels"
  ],
  "_fit_biases": [
    "X",
    "dilations",
    "num_features_per_dilation",
    "quantiles",
    "seed"
  ],
  "_fit_dilations": [
    "n_timepoints",
    "num_features",
    "max_dilations_per_kernel"
  ],
  "_quantiles": [
    "n"
  ],
  "_fit": [
    "X",
    "num_features",
    "max_dilations_per_kernel",
    "seed"
  ],
  "_transform": [
    "X",
    "parameters"
  ],
  "RocketPyts": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_kernels",
      "kernel_sizes",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MiniRocket": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "max_dilations_per_kernel",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiRocket": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "max_dilations_per_kernel",
      "n_features_per_kernel",
      "normalise",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_parameter": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MiniRocketMultivariateVariable": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "max_dilations_per_kernel",
      "reference_length",
      "pad_value_short_series",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_nested_dataframe_to_transposed2D_array_and_len_list": [
    "X",
    "pad"
  ],
  "Rocket": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "normalise",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MiniRocketMultivariate": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "max_dilations_per_kernel",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_fit_biases_multi_var": [
    "X",
    "L",
    "num_channels_per_combination",
    "channel_indices",
    "dilations",
    "num_features_per_dilation",
    "quantiles",
    "seed"
  ],
  "_fit_dilations_multi_var": [
    "reference_length",
    "num_features",
    "max_dilations_per_kernel"
  ],
  "_quantiles_multi_var": [
    "n"
  ],
  "_fit_multi_var": [
    "X",
    "L",
    "reference_length",
    "num_features",
    "max_dilations_per_kernel",
    "seed"
  ],
  "_transform_multi_var": [
    "X",
    "L",
    "parameters"
  ],
  "_fit_biases_multi": [
    "X",
    "num_channels_per_combination",
    "channel_indices",
    "dilations",
    "num_features_per_dilation",
    "quantiles",
    "seed"
  ],
  "_fit_multi": [
    "X",
    "num_features",
    "max_dilations_per_kernel",
    "seed"
  ],
  "_transform_multi": [
    "X",
    "parameters"
  ],
  "test_minirocket_multivariate_variable_on_japanese_vowels": [],
  "test_multirocket_multivariate_on_basic_motions": [],
  "test_minirocket_multivariate_on_basic_motions": [],
  "test_rocket_on_gunpoint": [],
  "test_minirocket_on_gunpoint": [],
  "test_multirocket_on_gunpoint": [],
  "ShapeletTransformPyts": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_shapelets",
      "criterion",
      "window_sizes",
      "window_steps",
      "remove_similar",
      "sort",
      "verbose",
      "random_state",
      "n_jobs"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Shapelet": {
    "__init__": [
      "self",
      "series_id",
      "start_pos",
      "length",
      "info_gain",
      "data"
    ],
    "__str__": [
      "self"
    ]
  },
  "ShapeletPQ": {
    "__init__": [
      "self"
    ],
    "push": [
      "self",
      "shapelet"
    ],
    "pop": [
      "self"
    ],
    "peek": [
      "self"
    ],
    "get_size": [
      "self"
    ],
    "get_array": [
      "self"
    ]
  },
  "ShapeletTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "min_shapelet_length",
      "max_shapelet_length",
      "max_shapelets_to_store_per_class",
      "random_state",
      "verbose",
      "remove_self_similar"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "remove_self_similar_shapelets": [
      "shapelet_list"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_shapelets": [
      "self"
    ],
    "binary_entropy": [
      "num_this_class",
      "num_other_class"
    ],
    "calc_binary_ig": [
      "orderline",
      "total_num_this_class",
      "total_num_other_class"
    ],
    "calc_early_binary_ig": [
      "orderline",
      "num_this_class_in_orderline",
      "num_other_class_in_orderline",
      "num_to_add_this_class",
      "num_to_add_other_class"
    ],
    "zscore": [
      "a",
      "axis",
      "ddof"
    ],
    "euclidean_distance_early_abandon": [
      "u",
      "v",
      "min_dist"
    ]
  },
  "RandomShapeletTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "n_shapelet_samples",
      "max_shapelets",
      "min_shapelet_length",
      "max_shapelet_length",
      "remove_self_similar",
      "time_limit_in_minutes",
      "contract_max_n_shapelet_samples",
      "n_jobs",
      "parallel_backend",
      "batch_size",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_extract_random_shapelet": [
      "self",
      "X",
      "y",
      "i",
      "shapelets",
      "max_shapelets_per_class"
    ]
  },
  "test_st_on_unit_test": [],
  "test_st_on_basic_motions": [],
  "shapelet_transform_unit_test_data": [],
  "shapelet_transform_basic_motions_data": [],
  "test_stp_on_unit_test": [],
  "test_TimeSeriesConcatenator": [],
  "test_bad_input_args": [
    "bad_window_length"
  ],
  "test_output_of_transformer": [],
  "test_output_dimensions": [
    "time_series_length",
    "window_length"
  ],
  "convert_list_to_dataframe": [
    "list_to_convert"
  ],
  "check_if_dataframes_are_equal": [
    "df1",
    "df2"
  ],
  "test_random_intervals_on_basic_motions": [],
  "test_supervised_intervals_on_basic_motions": [],
  "random_intervals_basic_motions_data": [],
  "supervised_intervals_basic_motions_data": [],
  "test_timebinner": [],
  "test_timebinner2": [],
  "test_timebinner3": [],
  "test_cs_basic_motions": [],
  "test_tsfresh_extractor": [
    "default_fc_parameters"
  ],
  "test_docs_tsfresh_extractor": [],
  "test_kind_tsfresh_extractor": [],
  "cut_X_ts": [
    "X"
  ],
  "test_resizing": [],
  "test_truncation_constructor_arg_validation": [
    "lower",
    "upper",
    "error",
    "message"
  ],
  "test_truncation_transformer_multi_index": [
    "lower",
    "upper",
    "expected_length"
  ],
  "test_truncation_transformer": [],
  "test_truncation_parameterised_transformer": [],
  "test_truncation_pd_multiindex": [],
  "N_ITER": [],
  "test_output_format_dim": [
    "n_timepoints",
    "n_instances",
    "n_intervals"
  ],
  "test_rand_intervals_fixed_n": [
    "random_state",
    "n_intervals"
  ],
  "test_rand_intervals_rand_n": [
    "random_state"
  ],
  "test_rand_intervals_fixed_n_min_max_length": [
    "n_intervals",
    "min_length",
    "max_length"
  ],
  "test_bad_num_intervals": [
    "bad_num_intervals"
  ],
  "test_bad_num_bins": [
    "bad_num_bins"
  ],
  "test_bad_scaling_factor": [
    "bad_scaling_factor"
  ],
  "test_hog1d_performs_correctly_along_each_dim": [],
  "test_padding_transformer": [],
  "test_padding_parameterised_transformer": [],
  "test_padding_fill_value_transformer": [],
  "test_ColumnTransformer_pipeline": [],
  "test_catch22_on_basic_motions": [],
  "test_catch22_wrapper_on_basic_motions": [],
  "catch22_basic_motions_data": [],
  "catch22wrapper_basic_motions_data": [],
  "test_feature_names": [],
  "test_no_levels_does_no_change": [],
  "test_dwt_performs_correctly_along_each_dim": [],
  "test_slope_performs_correctly_along_each_dim": [],
  "PlateauFinder": {
    "_tags": [],
    "__init__": [
      "self",
      "value",
      "min_length"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "DerivativeSlopeTransformer": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_check_features": [
    "features"
  ],
  "RandomIntervalFeatureExtractor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_intervals",
      "min_length",
      "max_length",
      "features",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "FittedParamExtractor": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "param_names",
      "n_jobs"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_check_param_names": [
      "param_names"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_FittedParamExtractor": [
    "param_names"
  ],
  "test_PlateauFinder": [
    "value"
  ],
  "test_bad_n_intervals": [
    "bad_n_intervals"
  ],
  "test_bad_features": [
    "bad_features"
  ],
  "test_results": [
    "n_instances",
    "n_timepoints",
    "n_intervals"
  ],
  "test_different_implementations": [],
  "test_different_pipelines": [],
  "SignatureTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "augmentation_list",
      "window_name",
      "window_depth",
      "window_length",
      "window_step",
      "rescaling",
      "sig_tfm",
      "depth",
      "backend"
    ],
    "setup_feature_pipeline": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_handle_sktime_signatures": [
    "check_fitted",
    "force_numpy"
  ],
  "_Pair": [],
  "_window_getter": [
    "window_name",
    "window_depth",
    "window_length",
    "window_step"
  ],
  "_Window": {
    "num_windows": [
      "self",
      "length"
    ]
  },
  "_Global": {
    "__call__": [
      "self",
      "length"
    ]
  },
  "_ExpandingSliding": {
    "__init__": [
      "self",
      "initial_length",
      "start_step",
      "end_step"
    ],
    "__call__": [
      "self",
      "length"
    ]
  },
  "_Sliding": {
    "__init__": [
      "self",
      "length",
      "step"
    ]
  },
  "_Expanding": {
    "__init__": [
      "self",
      "length",
      "step"
    ]
  },
  "_Dyadic": {
    "__init__": [
      "self",
      "depth"
    ],
    "__call__": [
      "self",
      "length"
    ],
    "call": [
      "self",
      "length",
      "_offset",
      "_depth",
      "_out"
    ]
  },
  "_make_augmentation_pipeline": [
    "augmentation_list"
  ],
  "_AddTime": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_InvisibilityReset": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_LeadLag": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_CumulativeSum": {
    "_tags": [],
    "__init__": [
      "self",
      "append_zero"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_BasePoint": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_WindowSignatureTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "window_name",
      "window_depth",
      "window_length",
      "window_step",
      "sig_tfm",
      "sig_depth",
      "rescaling",
      "backend"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_rescale_path": [
    "path",
    "depth"
  ],
  "_rescale_signature": [
    "signature",
    "channels",
    "depth"
  ],
  "OBJS_TO_TEST": [],
  "test_augmentations": [],
  "test_generalised_signature_method": [],
  "test_window_error": [],
  "SAXlegacy": {
    "_tags": [],
    "__init__": [
      "self",
      "word_length",
      "alphabet_size",
      "window_size",
      "remove_repeat_words",
      "save_words",
      "return_pandas_data_series"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_create_word": [
      "self",
      "pattern",
      "breakpoints"
    ],
    "_add_to_bag": [
      "self",
      "bag",
      "word",
      "last_word"
    ],
    "_generate_breakpoints": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "binning_methods": [],
  "_binning_dft": [
    "X",
    "window_size",
    "series_length",
    "dft_length",
    "norm",
    "inverse_sqrt_win_size",
    "lower_bounding"
  ],
  "_fast_fourier_transform": [
    "X",
    "norm",
    "dft_length",
    "inverse_sqrt_win_size"
  ],
  "_transform_case": [
    "X",
    "window_size",
    "dft_length",
    "word_length",
    "norm",
    "remove_repeat_words",
    "support",
    "anova",
    "variance",
    "breakpoints",
    "letter_bits",
    "bigrams",
    "skip_grams",
    "inverse_sqrt_win_size",
    "lower_bounding"
  ],
  "remove_repeating_words": [
    "words"
  ],
  "_calc_incremental_mean_std": [
    "series",
    "end",
    "window_size"
  ],
  "_get_phis": [
    "window_size",
    "length"
  ],
  "generate_words": [
    "dfts",
    "bigrams",
    "skip_grams",
    "window_size",
    "breakpoints",
    "word_length",
    "letter_bits"
  ],
  "create_feature_names": [
    "sfa_words"
  ],
  "_mft": [
    "X",
    "window_size",
    "dft_length",
    "norm",
    "support",
    "anova",
    "variance",
    "inverse_sqrt_win_size",
    "lower_bounding"
  ],
  "create_bag_none": [
    "breakpoints",
    "n_instances",
    "sfa_words",
    "word_length",
    "remove_repeat_words"
  ],
  "create_bag_feature_selection": [
    "n_instances",
    "relevant_features_idx",
    "feature_names",
    "sfa_words",
    "remove_repeat_words"
  ],
  "create_bag_transform": [
    "feature_count",
    "feature_selection",
    "relevant_features",
    "sfa_words",
    "bigrams",
    "remove_repeat_words"
  ],
  "shorten_words": [
    "words",
    "amount",
    "letter_bits"
  ],
  "PAAlegacy": {
    "_tags": [],
    "__init__": [
      "self",
      "num_intervals"
    ],
    "set_num_intervals": [
      "self",
      "n"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_perform_paa_along_dim": [
      "self",
      "X"
    ],
    "_check_parameters": [
      "self",
      "num_atts"
    ]
  },
  "SFAFast": {
    "_tags": [],
    "__init__": [
      "self",
      "word_length",
      "alphabet_size",
      "window_size",
      "norm",
      "binning_method",
      "anova",
      "variance",
      "bigrams",
      "skip_grams",
      "remove_repeat_words",
      "lower_bounding",
      "save_words",
      "feature_selection",
      "max_feature_count",
      "p_threshold",
      "random_state",
      "return_sparse",
      "return_pandas_data_series",
      "n_jobs"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "transform_to_bag": [
      "self",
      "words",
      "word_len",
      "y"
    ],
    "_binning": [
      "self",
      "X",
      "y"
    ],
    "_k_bins_discretizer": [
      "self",
      "dft"
    ],
    "_mcb": [
      "self",
      "dft"
    ],
    "_igb": [
      "self",
      "dft",
      "y"
    ],
    "_shorten_bags": [
      "self",
      "word_len",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "set_fitted": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "SFA": {
    "_tags": [],
    "__init__": [
      "self",
      "word_length",
      "alphabet_size",
      "window_size",
      "norm",
      "binning_method",
      "anova",
      "bigrams",
      "skip_grams",
      "remove_repeat_words",
      "levels",
      "lower_bounding",
      "save_words",
      "keep_binning_dft",
      "return_pandas_data_series",
      "use_fallback_dft",
      "typed_dict",
      "n_jobs"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_transform_case": [
      "self",
      "X",
      "supplied_dft"
    ],
    "_binning": [
      "self",
      "X",
      "y"
    ],
    "_k_bins_discretizer": [
      "self",
      "dft"
    ],
    "_mcb": [
      "self",
      "dft"
    ],
    "_igb": [
      "self",
      "dft",
      "y"
    ],
    "_binning_dft": [
      "self",
      "series",
      "num_windows_per_inst"
    ],
    "_fast_fourier_transform": [
      "self",
      "series"
    ],
    "_mft": [
      "self",
      "series"
    ],
    "_shorten_bags": [
      "self",
      "word_len"
    ],
    "_shorten_case": [
      "self",
      "word_len",
      "i"
    ],
    "_add_to_bag": [
      "self",
      "bag",
      "word",
      "last_word"
    ],
    "_add_to_pyramid": [
      "self",
      "bag",
      "word",
      "last_word",
      "window_ind"
    ],
    "_add_level_large": [
      "self",
      "word",
      "start",
      "level",
      "window_ind"
    ],
    "_create_word_large": [
      "self",
      "dft"
    ],
    "_create_bigram_words": [
      "self",
      "word_raw",
      "word"
    ],
    "_create_bigram_word_large": [
      "self",
      "word",
      "other_word"
    ],
    "_shorten_words": [
      "self",
      "word",
      "word_len"
    ],
    "_shorten_word_large": [
      "self",
      "word",
      "amount"
    ],
    "bag_to_string": [
      "self",
      "bag"
    ],
    "word_list": [
      "self",
      "word"
    ],
    "word_list_typed": [
      "self",
      "word"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_discrete_fourier_transform": [
    "series",
    "dft_length",
    "norm",
    "inverse_sqrt_win_size",
    "lower_bounding",
    "apply_normalising_factor",
    "cut_start_if_norm"
  ],
  "_iterate_mft": [
    "series",
    "mft_data",
    "phis",
    "window_size",
    "stds",
    "transformed",
    "inverse_sqrt_win_size"
  ],
  "_add_level": [
    "word",
    "start",
    "level",
    "window_ind",
    "window_size",
    "series_length",
    "level_bits"
  ],
  "_add_level_typed": [
    "word",
    "start",
    "level",
    "window_ind",
    "window_size",
    "series_length"
  ],
  "_create_word": [
    "dft",
    "word_length",
    "alphabet_size",
    "breakpoints",
    "letter_bits"
  ],
  "_create_bigram_word": [
    "word",
    "other_word",
    "word_bits"
  ],
  "_shorten_word": [
    "word",
    "amount",
    "letter_bits"
  ],
  "test_paa_performs_correctly_along_each_dim": [],
  "test_transformer": [
    "binning_method"
  ],
  "test_dft_mft": [
    "use_fallback_dft",
    "norm"
  ],
  "test_sfa_anova": [
    "binning_method"
  ],
  "test_word_lengths": [
    "word_length",
    "alphabet_size",
    "window_size",
    "bigrams",
    "levels",
    "use_fallback_dft"
  ],
  "test_bit_size": [],
  "test_typed_dict": [],
  "test_transform_fitintransform": [],
  "mean_transformer": [],
  "std_transformer": [],
  "test_FeatureUnion_pipeline": [],
  "test_FeatureUnion": [],
  "test_optionalpassthrough": [],
  "test_passthrough_does_not_broadcast_variables": [],
  "test_passthrough_does_not_broadcast_instances": [],
  "TransformerFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllTransformers": {
    "test_capability_inverse_tag_is_correct": [
      "self",
      "estimator_instance"
    ],
    "test_remember_data_tag_is_correct": [
      "self",
      "estimator_instance"
    ],
    "_expected_trafo_output_scitype": [
      "self",
      "X_scitype",
      "trafo_input",
      "trafo_output"
    ],
    "test_fit_transform_output": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_transform_inverse_transform_equivalent": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_categorical_X_raises_error": [
      "self",
      "estimator_instance"
    ],
    "test_categorical_y_raises_error": [
      "self",
      "estimator_instance"
    ],
    "test_categorical_X_passes": [
      "self",
      "estimator_instance"
    ]
  },
  "_TransformChangeNInstances": {
    "_tags": [],
    "__init__": [
      "self",
      "n",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_transformation_can_return_new_instances": [
    "obj",
    "test_name"
  ],
  "test_hampel_filter_series": [],
  "test_hampel_filter_panel": [],
  "test_CFFilter_wrapper": [],
  "test_pipeline_with_categorical": [],
  "test_ColumnEnsemble_with_categorical": [],
  "RELEVANT_MODULES": [],
  "test_multiplex_transformer_alone": [],
  "_find_best_transformer": [
    "forecaster",
    "transformers",
    "cv",
    "y"
  ],
  "test_multiplex_transformer_in_grid": [],
  "test_multiplex_or_dunder": [],
  "test_conditional_deseasonalization": [],
  "test_HPFilter_wrapper": [],
  "ReconciliationTransformerFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllReconciliationTransformers": {
    "test_hierarchical_reconcilers": [
      "self",
      "estimator_instance",
      "no_levels",
      "flatten_single_levels",
      "unnamed_levels",
      "aggregate"
    ],
    "test_implement_inverse_transform": [
      "self",
      "estimator_instance"
    ],
    "test_behaves_as_identity_if_input_not_hierarchical": [
      "self",
      "estimator_instance",
      "n_instances"
    ]
  },
  "test_dunder_mul": [],
  "test_dunder_add": [],
  "test_add_sklearn_autoadapt": [],
  "test_mul_sklearn_autoadapt": [],
  "test_missing_unequal_tag_inference": [],
  "test_featureunion_transform_cols": [],
  "test_featureunion_primitives": [],
  "test_sklearn_after_primitives": [],
  "test_pipeline_column_vectorization": [],
  "test_pipeline_inverse": [],
  "test_subset_getitem": [],
  "test_dunder_invert": [],
  "test_dunder_neg": [],
  "test_input_output_series_panel_chain": [],
  "test_requires_tags_trafopipe": [],
  "test_ixtox": [],
  "test_BKFilter_wrapper": [],
  "BACKENDS": [],
  "inner_X_scitypes": [
    "est"
  ],
  "test_series_in_series_out_supported": [],
  "test_series_in_series_out_supported_fit_in_transform": [],
  "test_series_in_series_out_not_supported_but_panel": [],
  "test_panel_in_panel_out_supported": [],
  "test_panel_in_panel_out_not_supported_but_series": [
    "backend"
  ],
  "test_series_in_primitives_out_supported_fit_in_transform": [],
  "test_panel_in_primitives_out_not_supported_fit_in_transform": [
    "backend"
  ],
  "test_series_in_primitives_out_not_supported_fit_in_transform": [],
  "test_panel_in_primitives_out_supported_with_y_in_fit_but_not_transform": [],
  "test_hierarchical_in_hierarchical_out_not_supported_but_series": [
    "backend"
  ],
  "test_hierarchical_in_hierarchical_out_not_supported_but_series_fit_in_transform": [],
  "test_vectorization_multivariate_no_row_vectorization": [
    "backend"
  ],
  "test_vectorization_multivariate_and_hierarchical": [
    "backend"
  ],
  "test_vectorization_multivariate_no_row_vectorization_empty_fit": [
    "backend"
  ],
  "test_vectorization_multivariate_and_hierarchical_empty_fit": [
    "backend"
  ],
  "test_vectorize_reconstruct_unique_columns": [],
  "test_vectorize_reconstruct_correct_hierarchy": [],
  "test_wrong_y_is_not_passed_to_transformer": [],
  "test_series_to_primitives_hierarchical": [],
  "test_functrafo_and_default_capability_categorical_in_X": [],
  "_sliding_window": [
    "X",
    "m"
  ],
  "_sliding_mean_std": [
    "X",
    "m"
  ],
  "_compute_distances_iterative": [
    "X",
    "m",
    "k"
  ],
  "_calc_knn_labels": [
    "knn_mask",
    "split_idx",
    "m"
  ],
  "_binary_f1_score": [
    "y_true",
    "y_pred"
  ],
  "_roc_auc_score": [
    "y_score",
    "y_true"
  ],
  "_calc_profile": [
    "m",
    "knn_mask",
    "score",
    "exclusion_zone"
  ],
  "clasp": [
    "X",
    "m",
    "k_neighbours",
    "score",
    "interpolate",
    "exclusion_radius"
  ],
  "DOBIN": {
    "_tags": [],
    "__init__": [
      "self",
      "frac",
      "k"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "close_distance_matrix": [
    "X",
    "k",
    "frac"
  ],
  "PAA": {
    "_tags": [],
    "__init__": [
      "self",
      "frames",
      "frame_size"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_transform_frames": [
      "self",
      "X"
    ],
    "_transform_frame_size": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_check_params": [
      "self"
    ]
  },
  "FABBA": {
    "_tags": [],
    "__init__": [
      "self",
      "method",
      "tolerance",
      "alpha",
      "auto_digitize",
      "sorting",
      "k",
      "batch_size",
      "scl",
      "max_iter",
      "if_partition",
      "partition_rate",
      "num_partition",
      "partition_idx",
      "max_len",
      "random_state",
      "return_as_strings",
      "return_start_values",
      "alphabet_set",
      "n_jobs"
    ],
    "_custom_compress": [
      "self",
      "ts"
    ],
    "_custom_parallel_compress": [
      "self",
      "X"
    ],
    "_custom_aggregate": [
      "self",
      "data"
    ],
    "_custom_assign_symbols": [
      "self",
      "labels"
    ],
    "_custom_strings_separation": [
      "self",
      "strings",
      "num_pieces"
    ],
    "_custom_labels_separation": [
      "self",
      "labels",
      "num_pieces"
    ],
    "_custom_len_centers": [
      "self",
      "len_pieces",
      "labels"
    ],
    "_custom_symbolize": [
      "self",
      "X",
      "pieces"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_custom_pieces_to_symbols": [
      "self",
      "pieces"
    ],
    "_transform_single_series": [
      "self",
      "ts"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_custom_inverse_symbolize": [
      "self",
      "symbol_sequence"
    ],
    "_custom_quantize_lengths": [
      "self",
      "pieces"
    ],
    "_custom_inverse_compress": [
      "self",
      "pieces",
      "start_value"
    ],
    "_inverse_transform_single_series": [
      "self",
      "start_value",
      "symbol_sequence"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Filter": {
    "_tags": [],
    "__init__": [
      "self",
      "sfreq",
      "l_freq",
      "h_freq",
      "filter_kwargs"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ScaledAsinhTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "mad_normalization_factor"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TabularToSeriesAdaptor": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "fit_in_transform",
      "pass_y",
      "input_type",
      "pooling"
    ],
    "_trafo_has_param_and_default": [
      "self",
      "method",
      "arg"
    ],
    "_get_args": [
      "self",
      "X",
      "y",
      "method"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PandasTransformAdaptor": {
    "_tags": [],
    "__init__": [
      "self",
      "method",
      "kwargs",
      "apply_to"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SeasonalDummiesOneHot": {
    "_tags": [],
    "__init__": [
      "self",
      "sp",
      "freq",
      "drop"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CosineTransformer": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "FeatureSelection": {
    "_tags": [],
    "__init__": [
      "self",
      "method",
      "n_columns",
      "regressor",
      "random_state",
      "columns"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_check_n_columns": [
      "self",
      "Z"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ADICVTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "features",
      "adi_threshold",
      "cv_threshold",
      "adi_trim_handling"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MatrixProfileTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "window_length"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ExponentTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "power",
      "offset"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_offset": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SqrtTransformer": {
    "__init__": [
      "self",
      "offset"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SAX": {
    "_tags": [],
    "__init__": [
      "self",
      "word_size",
      "alphabet_size",
      "frame_size"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_breakpoints": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_check_params": [
      "self"
    ]
  },
  "TimeSince": {
    "_tags": [],
    "__init__": [
      "self",
      "start"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_get_period_diff_as_int": [
    "x",
    "y"
  ],
  "_remove_digits_from_str": [
    "x"
  ],
  "_get_time_index": [
    "X"
  ],
  "_identity": [
    "X"
  ],
  "FunctionTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "func",
      "inverse_func"
    ],
    "_check_inverse_transform": [
      "self",
      "Z"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_apply_function": [
      "self",
      "Z",
      "func",
      "kw_args"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SignatureMoments": {
    "_tags": [],
    "__init__": [
      "self",
      "degree",
      "use_index",
      "normalize_prod"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_compute_signature": [
      "self",
      "data"
    ],
    "_compute_mean_product": [
      "self",
      "data",
      "indices"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DilationMappingTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "dilation"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_dilate_series": [
      "self",
      "x",
      "d"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_AugmenterTags": {
    "_tags": []
  },
  "WhiteNoiseAugmenter": {
    "_tags": [],
    "_allowed_statistics": [],
    "__init__": [
      "self",
      "scale",
      "random_state"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ReverseAugmenter": {
    "__init__": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "InvertAugmenter": {
    "__init__": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "RandomSamplesAugmenter": {
    "_tags": [],
    "__init__": [
      "self",
      "n",
      "without_replacement",
      "random_state"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "VmdTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "K",
      "kMax",
      "alpha",
      "tau",
      "DC",
      "init",
      "tol",
      "energy_loss_coefficient",
      "returned_decomp"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "__runVMDUntilCoefficientThreshold": [
      "self",
      "data"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ScaledLogitTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "lower_bound",
      "upper_bound"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BKFilter": {
    "_tags": [],
    "__init__": [
      "self",
      "low",
      "high",
      "K"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FourierFeatures": {
    "_tags": [],
    "__init__": [
      "self",
      "sp_list",
      "fourier_terms_list",
      "freq",
      "keep_original_columns"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_offset_frac_since_prev_offset": [
      "self",
      "datetime_index",
      "period_str"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FourierTransform": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "ClearSky": {
    "_tags": [],
    "__init__": [
      "self",
      "quantile_prob",
      "bw_diurnal",
      "bw_annual",
      "min_thresh",
      "n_jobs",
      "backend"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_clearskypower": [
    "y",
    "q",
    "tod_i",
    "doy_i",
    "tod_vec",
    "doy_vec",
    "bw_tod",
    "bw_doy"
  ],
  "_check_index": [
    "X"
  ],
  "Hidalgo": {
    "_tags": [],
    "__init__": [
      "self",
      "metric",
      "K",
      "zeta",
      "q",
      "n_iter",
      "n_replicas",
      "burn_in",
      "fixed_Z",
      "use_Potts",
      "estimate_zeta",
      "sampling_rate",
      "a",
      "b",
      "c",
      "f",
      "seed"
    ],
    "_get_neighbourhood_params": [
      "self",
      "X"
    ],
    "_update_zeta_prior": [
      "self",
      "Z",
      "N",
      "Iin"
    ],
    "_initialise_params": [
      "self",
      "N",
      "mu",
      "Iin",
      "_rng"
    ],
    "_gibbs_sampling": [
      "self",
      "N",
      "mu",
      "Iin",
      "Iout",
      "Iout_count",
      "Iout_track",
      "V",
      "NN",
      "a1",
      "b1",
      "c1",
      "Z",
      "f1",
      "N_in",
      "_rng"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "binom": [
    "N",
    "q"
  ],
  "partition_function": [
    "N",
    "N1",
    "zeta",
    "q"
  ],
  "DropNA": {
    "_tags": [],
    "VALID_AXIS_VALUES": [],
    "VALID_HOW_VALUES": [],
    "VALID_THRESH_TYPES": [],
    "VALID_REMEMBER_TYPES": [],
    "__init__": [
      "self",
      "axis",
      "how",
      "thresh",
      "remember"
    ],
    "_check_axis": [
      "self",
      "axis"
    ],
    "_check_how": [
      "self",
      "how"
    ],
    "_check_thresh": [
      "self",
      "thresh",
      "how"
    ],
    "_check_remember": [
      "self",
      "remember"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TemporianTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "function",
      "compile"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_test_function_single_op": [
    "evset"
  ],
  "_test_function_many_ops": [
    "evset"
  ],
  "_coerce_to_int": [
    "obj"
  ],
  "Lag": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "freq",
      "index_out",
      "flatten_transform_index",
      "keep_column_names",
      "remember_data"
    ],
    "_yield_shift_params": [
      "self"
    ],
    "_yield_shift_param_names": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ReducerTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "freq",
      "shifted_vars",
      "shifted_vars_lag",
      "shifted_vars_freq",
      "transformers",
      "impute_method"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "HampelFilter": {
    "_tags": [],
    "__init__": [
      "self",
      "window_length",
      "n_sigma",
      "k",
      "return_bool"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_transform_series": [
      "self",
      "Z"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_hampel_filter": [
    "Z",
    "cv",
    "n_sigma",
    "half_window_length",
    "k"
  ],
  "_compare": [
    "value",
    "cv_median",
    "cv_sigma",
    "n_sigma"
  ],
  "TimeBinAggregate": {
    "_tags": [],
    "__init__": [
      "self",
      "bins",
      "aggfunc",
      "return_index"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RBFTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "centers",
      "gamma",
      "rbf_type",
      "apply_to",
      "use_torch"
    ],
    "_check_torch": [
      "self"
    ],
    "_get_torch": [
      "self"
    ],
    "_rbf_torch": [
      "self",
      "x",
      "c"
    ],
    "_rbf_numpy": [
      "self",
      "x",
      "c"
    ],
    "_rbf": [
      "self",
      "x",
      "c"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_time_index": [
      "self",
      "X"
    ],
    "_get_values": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_calc_uniform_order_statistic_medians": [
    "n"
  ],
  "_box_norm": [
    "X",
    "bounds",
    "method"
  ],
  "BoxCoxTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "bounds",
      "method",
      "sp",
      "lambda_fixed",
      "enforce_positive"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LogTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "offset",
      "scale"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_make_boxcox_optimizer": [
    "bounds",
    "brack"
  ],
  "_boxcox_normmax": [
    "x",
    "bounds",
    "brack",
    "method"
  ],
  "_guerrero": [
    "x",
    "sp",
    "bounds"
  ],
  "_boxcox": [
    "x",
    "lmbda",
    "bounds"
  ],
  "_check_lags": [
    "lags"
  ],
  "_diff_transform": [
    "X",
    "lags"
  ],
  "_diff_to_seq": [
    "X",
    "lags"
  ],
  "_shift": [
    "ix",
    "periods"
  ],
  "_inverse_diff": [
    "X",
    "lags",
    "X_diff_seq"
  ],
  "Differencer": {
    "_tags": [],
    "VALID_NA_HANDLING_STR": [],
    "__init__": [
      "self",
      "lags",
      "na_handling",
      "memory"
    ],
    "_check_na_handling": [
      "self",
      "na_handling"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_check_freq": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_RAW_DUMMIES": [],
  "DateTimeFeatures": {
    "_tags": [],
    "__init__": [
      "self",
      "ts_freq",
      "feature_scope",
      "manual_selection",
      "keep_original_columns"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_check_manual_selection": [
    "manual_selection",
    "DUMMIES"
  ],
  "_check_feature_scope": [
    "feature_scope"
  ],
  "_check_ts_freq": [
    "ts_freq",
    "DUMMIES"
  ],
  "_calendar_dummies": [
    "x",
    "funcs"
  ],
  "_get_supported_calendar": [
    "ts_freq",
    "DUMMIES"
  ],
  "_prep_dummies": [
    "DUMMIES"
  ],
  "HPFilter": {
    "_tags": [],
    "__init__": [
      "self",
      "lamb"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AutoCorrelationTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "adjusted",
      "n_lags",
      "fft",
      "missing"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PartialAutoCorrelationTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_lags",
      "method"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Bollinger": {
    "_tags": [],
    "__init__": [
      "self",
      "window",
      "k",
      "memory"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_bollinger_transform": [
    "df",
    "window",
    "k"
  ],
  "CFFilter": {
    "_tags": [],
    "__init__": [
      "self",
      "low",
      "high",
      "drift"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ClaSPTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "window_length",
      "scoring_metric",
      "exclusion_radius"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_check_scoring_metric": [
      "self",
      "scoring_metric"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IndexSubset": {
    "_tags": [],
    "__init__": [
      "self",
      "index_treatment"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ColumnSelect": {
    "_tags": [],
    "__init__": [
      "self",
      "columns",
      "integer_treatment",
      "index_treatment"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PeakTimeFeature": {
    "_tags": [],
    "__init__": [
      "self",
      "ts_freq",
      "peak_hour_start",
      "peak_hour_end",
      "peak_day_start",
      "peak_day_end",
      "peak_week_start",
      "peak_week_end",
      "peak_month_start",
      "peak_month_end",
      "peak_quarter_start",
      "peak_quarter_end",
      "peak_year_start",
      "peak_year_end",
      "working_hour_start",
      "working_hour_end",
      "keep_original_columns",
      "keep_original_peaktime_data_columns"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_extract_peaktime_features": [
      "self",
      "calendar_features",
      "datetime_freq"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_datetime_frequency_rank": [],
  "_extract_datetime_features": [
    "x_df"
  ],
  "_check_inputs": [
    "start_values",
    "end_values",
    "feature_name",
    "start_range",
    "end_range"
  ],
  "Imputer": {
    "_tags": [],
    "__init__": [
      "self",
      "method",
      "random_state",
      "value",
      "forecaster",
      "missing_values"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_check_method": [
      "self"
    ],
    "_create_random_distribution": [
      "self",
      "z"
    ],
    "_impute_with_forecaster": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_has_missing_values": [
    "X"
  ],
  "ThetaLinesTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "theta"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_theta_transform": [
    "Z",
    "trend",
    "theta"
  ],
  "_check_theta": [
    "theta"
  ],
  "HurstExponentTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "method",
      "min_lag",
      "max_lag",
      "fit_trend",
      "confidence_level"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_get_effective_lags": [
      "self",
      "series_length"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_hurst_exponent": [
      "self",
      "ts"
    ],
    "_rs_method": [
      "self",
      "ts"
    ],
    "_dfa_method": [
      "self",
      "ts"
    ],
    "_calculate_rs": [
      "self",
      "ts",
      "lag"
    ],
    "_calculate_dfa": [
      "self",
      "ts",
      "lag"
    ],
    "_fit_hurst": [
      "self",
      "lags",
      "tau"
    ],
    "_calculate_confidence_interval": [
      "self",
      "slope",
      "std_err",
      "n"
    ],
    "plot_log_log": [
      "self",
      "ts"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SubsequenceExtractionTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "aggregate_fn",
      "subseq_len",
      "kwargs",
      "selector"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "KinematicFeatures": {
    "_tags": [],
    "__init__": [
      "self",
      "features"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "WindowSummarizer": {
    "_tags": [],
    "__init__": [
      "self",
      "lag_feature",
      "n_jobs",
      "target_cols",
      "truncate"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "pd_rolling": [],
  "get_name_list": [
    "Z"
  ],
  "_window_feature": [
    "Z",
    "summarizer",
    "window",
    "bfill"
  ],
  "ALLOWED_SUM_FUNCS": [],
  "_check_summary_function": [
    "summary_function"
  ],
  "_check_quantiles": [
    "quantiles"
  ],
  "SummaryTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "summary_function",
      "quantiles",
      "flatten_transform_index"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SplitterSummarizer": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "splitter",
      "index",
      "fit_on",
      "transform_on"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_init_matrix": [
    "matrices",
    "transform_func",
    "default_val"
  ],
  "_validate_param_shape": [
    "param_name",
    "matrix_shape",
    "actual_shape",
    "time_steps"
  ],
  "BaseKalmanFilter": {
    "_tags": [],
    "__init__": [
      "self",
      "state_dim",
      "state_transition",
      "process_noise",
      "measurement_noise",
      "measurement_function",
      "initial_state",
      "initial_state_covariance"
    ],
    "_get_shapes": [
      "self",
      "state_dim",
      "measurement_dim"
    ],
    "_get_init_values": [
      "self",
      "measurement_dim",
      "state_dim"
    ],
    "_set_attribute": [
      "self",
      "param_name",
      "attr_name",
      "value",
      "matrix_shape",
      "time_steps"
    ]
  },
  "_get_t_matrix": [
    "time_t",
    "matrices",
    "shape",
    "time_steps"
  ],
  "_check_conditional_dependency": [
    "obj",
    "condition",
    "package",
    "severity",
    "msg"
  ],
  "_validate_estimate_matrices": [
    "input_ems",
    "all_ems"
  ],
  "KalmanFilterTransformerPK": {
    "_tags": [],
    "__init__": [
      "self",
      "state_dim",
      "state_transition",
      "transition_offsets",
      "measurement_offsets",
      "process_noise",
      "measurement_noise",
      "measurement_function",
      "initial_state",
      "initial_state_covariance",
      "estimate_matrices",
      "denoising"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_em": [
      "self",
      "X",
      "measurement_dim",
      "state_dim"
    ],
    "_get_estimate_matrices": [
      "self"
    ],
    "_get_shapes": [
      "self",
      "state_dim",
      "measurement_dim"
    ]
  },
  "KalmanFilterTransformerFP": {
    "_tags": [],
    "__init__": [
      "self",
      "state_dim",
      "state_transition",
      "control_transition",
      "process_noise",
      "measurement_noise",
      "measurement_function",
      "initial_state",
      "initial_state_covariance",
      "estimate_matrices",
      "denoising"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_get_iter_t_matrices": [
      "self",
      "X",
      "G",
      "u",
      "t",
      "time_steps",
      "shapes"
    ],
    "_get_shapes": [
      "self",
      "state_dim",
      "measurement_dim",
      "u_dim"
    ]
  },
  "KalmanFilterTransformerSIMD": {
    "_tags": [],
    "__init__": [
      "self",
      "state_dim",
      "state_transition",
      "process_noise",
      "measurement_noise",
      "measurement_function",
      "initial_state",
      "initial_state_covariance",
      "denoising",
      "hidden"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "params_list": [],
  "apply_to_str": [],
  "test_pandastransformadaptor_consistency": [
    "param",
    "apply_to"
  ],
  "test_indexsubset_indextreatment": [
    "index_treatment"
  ],
  "test_columnselect_indextreatment": [
    "index_treatment"
  ],
  "test_columnselect_int": [],
  "test_columnselect_as_first_step_in_transformedtargetforecaster": [],
  "X": [],
  "test_X": [],
  "test_get_neighbourhood_params": [],
  "test_initialise_params": [],
  "test_gibbs": [],
  "test_theta_0": [],
  "test_theta_1": [],
  "test_thetalines_shape": [
    "theta"
  ],
  "z": [],
  "test_imputer": [
    "method",
    "Z",
    "value",
    "forecaster"
  ],
  "test_impute_multiindex": [
    "method"
  ],
  "test_imputer_forecaster_y": [],
  "ts": [],
  "create_data": [
    "shape",
    "missing_values",
    "p",
    "mult",
    "covariance"
  ],
  "rand_list": [
    "shape",
    "length",
    "mult"
  ],
  "params_3_3_dynamic": [],
  "params_3_3_static": [],
  "params_2_3_": [],
  "params_1_1_arrays": [],
  "params_1_1_lists": [],
  "params_3_1_lists": [],
  "params_2_1_static": [],
  "get_params_mapping": [
    "params"
  ],
  "init_kf_pykalman": [
    "state_dim",
    "measurement_dim",
    "state_transition",
    "process_noise",
    "measurement_noise",
    "measurement_function",
    "initial_state",
    "initial_state_covariance",
    "transition_offsets",
    "measurement_offsets",
    "estimate_matrices",
    "denoising"
  ],
  "init_kf_filterpy": [
    "measurements",
    "adapter",
    "n",
    "y"
  ],
  "test_transform_and_smooth_pk": [
    "params",
    "measurements"
  ],
  "test_em": [
    "classes",
    "params",
    "measurements"
  ],
  "test_bad_inputs": [
    "classes",
    "params",
    "measurements"
  ],
  "test_transform_and_smooth_fp": [
    "params",
    "measurements",
    "y"
  ],
  "test_transform_and_smooth_simd": [
    "hidden",
    "denoising",
    "params",
    "measurements"
  ],
  "test_panel_transform_simd": [
    "smooth",
    "params",
    "n_columns"
  ],
  "Y": [],
  "Y_datetime": [],
  "test_fourier_list_length_mismatch": [],
  "test_fourier_k_larger_than_sp": [],
  "test_fourier_redundant_terms_dropped": [],
  "test_fit_transform_outputs": [],
  "test_fit_transform_keep_original_columns_false": [],
  "test_fit_transform_datetime_outputs": [],
  "test_fit_transform_behaviour": [],
  "test_flat_univariate": [],
  "test_panel": [],
  "test_hier": [],
  "test_dtypes": [],
  "test_compiled": [],
  "test_compile_already_compiled": [],
  "test_multiple_output": [],
  "test_multiple_input": [],
  "test_change_sampling": [],
  "test_complex_function": [],
  "load_split_data": [],
  "featurescope_step": [
    "load_split_data"
  ],
  "featurescope_step_output": [],
  "reduced_featurescope_step": [
    "load_split_data"
  ],
  "reduced_featurescope_step_output": [],
  "test_changing_frequency_step": [
    "load_split_data"
  ],
  "test_changing_frequency_step_output": [],
  "test_manspec_with_tsfreq_step": [
    "load_split_data"
  ],
  "test_manspec_with_tsfreq_step_output": [],
  "test_manspec_wo_tsfreq_step": [
    "load_split_data"
  ],
  "test_manspec_wo_tsfreq_step_output": [],
  "test_multivariate_eval": [
    "test_input",
    "expected",
    "request"
  ],
  "all_args": [],
  "test_univariate_data_step": [],
  "test_univariate_data_step_output": [],
  "test_diffdateformat": [],
  "test_diffdateformat_output": [],
  "test_comprehensive_transform": [],
  "test_comprehensive_transform_output": [],
  "test_types": [
    "test_comprehensive_transform"
  ],
  "test_types_output": [],
  "test_uniivariate_eval": [
    "test_input",
    "expected",
    "request"
  ],
  "df_datetime_daily_idx": [],
  "df_panel": [],
  "test_manual_selection_is_weekend": [
    "df_datetime_daily_idx"
  ],
  "test_transform_panel": [
    "df_panel"
  ],
  "test_keep_original_columns": [
    "df_panel"
  ],
  "test_month_of_quarter": [
    "df_panel"
  ],
  "test_manual_selection_hour_of_week": [
    "df_panel"
  ],
  "X_few_na": [],
  "X_few_na_expected": [
    "X_few_na"
  ],
  "X_many_na": [],
  "X_many_na_expected": [
    "X_many_na"
  ],
  "test_dropna_few_na": [
    "axis",
    "how",
    "X_few_na",
    "X_few_na_expected"
  ],
  "test_dropna_many_na": [
    "axis",
    "how",
    "X_many_na",
    "X_many_na_expected"
  ],
  "test_dropna_conflicting_arguments": [
    "axis",
    "how",
    "thresh",
    "remember"
  ],
  "test_dropna_invalid_arguments_how": [
    "axis",
    "how",
    "remember"
  ],
  "test_dropna_invalid_arguments_thresh_type": [
    "axis",
    "thresh",
    "remember"
  ],
  "test_dropna_invalid_arguments_thresh_value": [
    "axis",
    "thresh",
    "remember"
  ],
  "test_bollinger_against_raw_implementation": [
    "window",
    "k"
  ],
  "test_bollinger_input_error": [
    "window",
    "k"
  ],
  "output_chk": [],
  "test_clearsky_trafo_vals": [],
  "test_clearsky_trafo_range_exception": [],
  "test_clearsky_trafo_nofreq_exception": [],
  "test_clearsky_trafo_grdaily_exception": [],
  "sum_funcs_to_test": [],
  "quantiles_to_test": [],
  "incorrect_sum_funcs_to_test": [],
  "incorrect_quantiles_to_test": [],
  "_make_test_data": [
    "i"
  ],
  "test_summary_transformer_output_type": [
    "data_id",
    "summary_arg",
    "quantile_arg"
  ],
  "test_summary_transformer_incorrect_summary_function_raises_error": [
    "summary_arg"
  ],
  "test_summary_transformer_incorrect_quantile_raises_error": [
    "quantile_arg"
  ],
  "test_summarize_no_lossy_setitem": [],
  "test_seasonal_dummies": [],
  "test_featurized_values": [],
  "power_transformers": [],
  "test_wrong_offset_type_raises_error": [
    "power_transformer",
    "_offset"
  ],
  "test_wrong_power_type_raises_error": [
    "power_transformer",
    "_power"
  ],
  "test_boxcox_transform": [],
  "_load_test_data": [],
  "_calc_checksum": [
    "X"
  ],
  "expected_checksum_X": [],
  "test_loaded_data": [],
  "expected_checksums_white_noise": [],
  "test_white_noise": [
    "parameter"
  ],
  "expected_checksum_reverse": [],
  "test_reverse": [],
  "expected_checksum_invert": [],
  "test_invert": [],
  "expected_checksums_random_samples": [],
  "test_random_samples": [
    "parameter"
  ],
  "X_range_idx": [],
  "X_range_idx_mv": [],
  "X_time_idx": [],
  "X_time_idx_mv": [],
  "X_fixtures": [],
  "X_time_fixtures": [],
  "index_outs": [],
  "test_lag_fit_transform_out_index": [
    "X",
    "index_out"
  ],
  "test_lag_fit_transform_out_values": [
    "X",
    "index_out",
    "remember_data"
  ],
  "test_lag_fit_transform_columns": [
    "X",
    "index_out",
    "lag"
  ],
  "test_lag_fit_transform_column_names": [
    "X",
    "index_out",
    "lags"
  ],
  "TEST_SERIES": [],
  "test_scaledlogit_transform": [
    "lower",
    "upper",
    "output"
  ],
  "test_scaledlogit_bound_errors": [
    "lower",
    "upper",
    "message"
  ],
  "test_passthrough": [
    "passthrough"
  ],
  "y_airline": [],
  "y_airline_df": [],
  "test_cases": [],
  "lags_to_test": [],
  "y_simple": [],
  "y_simple_expected_diff": [],
  "test_differencer_produces_expected_results": [
    "na_handling"
  ],
  "test_differencer_transform_memory": [
    "na_handling",
    "lags"
  ],
  "test_differencer_same_series": [
    "y",
    "lags",
    "index_type"
  ],
  "test_differencer_remove_missing_false": [
    "y",
    "lags",
    "na_handling",
    "index_type"
  ],
  "test_differencer_prediction": [
    "y",
    "lags",
    "index_type"
  ],
  "test_differencer_cutoff": [],
  "test_inverse_train_data_fill_zero": [
    "lags",
    "index_type"
  ],
  "test_differencer_inverse_does_not_memorize": [],
  "test_dropna_pipeline": [],
  "_generate_vmd_testdata": [
    "T",
    "f_1",
    "f_2",
    "f_3",
    "noise"
  ],
  "test_vmd_in_pipeline": [],
  "test_vmd_sequence_length": [
    "length"
  ],
  "_generate_smooth_series": [
    "size",
    "seed"
  ],
  "_generate_erratic_series": [
    "size",
    "seed"
  ],
  "_generate_intermittent_series": [
    "size",
    "seed"
  ],
  "_generate_lumpy_series": [
    "size",
    "seed"
  ],
  "test_adi_cv_extractor": [
    "demand_series",
    "expected_adi",
    "expected_cv",
    "expected_class",
    "adi_trim_handling"
  ],
  "test_fit_default": [],
  "test_fit_median_standardization": [],
  "test_pca_reduction": [],
  "test_zero_variance": [],
  "check_eval": [
    "test_input",
    "expected"
  ],
  "get_test_data": [
    "var_name"
  ],
  "y_multi": [],
  "y_multi_index": [],
  "kwargs": [],
  "kwargs_alternames": [],
  "kwargs_variant": [],
  "count_gt100": [
    "x"
  ],
  "kwargs_custom": [],
  "kwargs_negative_lags": [],
  "Xtmvar": [],
  "Xtmvar_none": [],
  "test_windowsummarizer": [
    "kwargs",
    "column_names",
    "y",
    "target_cols",
    "truncate"
  ],
  "test_wrong_column": [],
  "count_unique": [
    "x"
  ],
  "count_greater_zero": [
    "x"
  ],
  "kwargs_custom_function": [],
  "kwargs_lag_custom_function": [],
  "test_windowsummarizer_with_output": [
    "kwargs",
    "column_names",
    "y",
    "X",
    "target_cols",
    "truncate"
  ],
  "df_int_idx": [],
  "df_datetime_15mins_idx": [],
  "df_datetime_weekly_wed_idx": [],
  "df_datetime_monthly_idx": [],
  "df_period_monthly_idx": [],
  "df_datetime_daily_idx_panel": [],
  "test_fit_transform_int_idx_output": [
    "df_int_idx"
  ],
  "test_fit_transform_datetime_15mins_idx_numeric_output": [
    "df_datetime_15mins_idx"
  ],
  "test_fit_transform_datetime_weekly_wed_idx_numeric_output": [
    "df_datetime_weekly_wed_idx"
  ],
  "test_fit_transform_datetime_monthly_idx_numeric_output": [
    "df_datetime_monthly_idx"
  ],
  "test_fit_transform_datetime_monthly_idx_datetime_output": [
    "df_datetime_monthly_idx"
  ],
  "test_fit_transform_period_monthly_idx_numeric_output": [
    "df_period_monthly_idx"
  ],
  "test_fit_transform_period_monthly_idx_period_output": [
    "df_period_monthly_idx"
  ],
  "test_fit_transform_datetime_monthly_idx_multiple_starts_output": [
    "df_datetime_monthly_idx"
  ],
  "test_fit_transform_datetime_monthly_idx_multiple_starts_positive_only_output": [
    "df_datetime_monthly_idx"
  ],
  "test_fit_transform_datetime_daily_idx_panel_output": [
    "df_datetime_daily_idx_panel"
  ],
  "test_fit_transform_datetime_daily_idx_panel_multiple_starts_output": [
    "df_datetime_daily_idx_panel"
  ],
  "test_boxcox_against_scipy": [],
  "test_lambda_bounds": [
    "bounds",
    "method",
    "sp"
  ],
  "test_guerrero_against_r_implementation": [
    "bounds",
    "r_lambda"
  ],
  "test_bad_input_types": [
    "bad_size"
  ],
  "test_bad_input_values": [
    "attribute",
    "bad_size"
  ],
  "test_kinematic_expected_output": [],
  "HolidayFeatures": {
    "_required_parameters": [],
    "_tags": [],
    "__init__": [
      "self",
      "calendar",
      "holiday_windows",
      "include_bridge_days",
      "include_weekend",
      "return_dummies",
      "return_categorical",
      "return_indicator",
      "keep_original_columns"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_generate_holidays": [
    "index",
    "calendar",
    "holiday_windows",
    "include_bridge_days",
    "include_weekend",
    "return_dummies",
    "return_categorical",
    "return_indicator",
    "warning_instance"
  ],
  "_check_params": [
    "index",
    "calendar",
    "holiday_windows",
    "include_bridge_days",
    "include_weekend",
    "return_dummies",
    "return_categorical",
    "return_indicator",
    "keep_original_columns"
  ],
  "_check_holiday_windows": [
    "holiday_windows"
  ],
  "_check_calendar": [
    "calendar"
  ],
  "CountryHolidaysTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "country",
      "subdiv",
      "years",
      "expand",
      "observed",
      "categories",
      "name"
    ],
    "_name": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FinancialHolidaysTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "market",
      "years",
      "expand",
      "observed",
      "name"
    ],
    "_name": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "calendar": [],
  "test_return_dummies": [
    "calendar"
  ],
  "test_return_categorical": [
    "calendar"
  ],
  "test_return_indicator": [
    "calendar"
  ],
  "test_keep_original_column": [
    "calendar"
  ],
  "test_include_weekend": [
    "calendar"
  ],
  "test_holiday_not_in_window": [],
  "test_period_index": [
    "calendar"
  ],
  "Detrender": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "model"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_get_fh_from_X": [
      "self",
      "X"
    ],
    "_get_fitted_forecaster": [
      "self",
      "X",
      "y",
      "fh"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Deseasonalizer": {
    "_tags": [],
    "__init__": [
      "self",
      "sp",
      "model"
    ],
    "_align_seasonal": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_private_transform": [
      "self",
      "y",
      "seasonal"
    ],
    "_private_inverse_transform": [
      "self",
      "y",
      "seasonal"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ConditionalDeseasonalizer": {
    "__init__": [
      "self",
      "seasonality_test",
      "sp",
      "model"
    ],
    "_check_condition": [
      "self",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "STLTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "sp",
      "seasonal",
      "trend",
      "low_pass",
      "seasonal_deg",
      "trend_deg",
      "low_pass_deg",
      "robust",
      "seasonal_jump",
      "trend_jump",
      "low_pass_jump",
      "return_components"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_make_return_object": [
      "self",
      "X",
      "stl"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "MSTL": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_make_return_object": [
      "self",
      "X",
      "mstl"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_coerce_to_df": [
    "x"
  ],
  "y_series": [],
  "y_dataframe": [],
  "test_polynomial_detrending": [],
  "test_multiplicative_detrending_series": [
    "y_series"
  ],
  "test_multiplicative_detrending_dataframe": [
    "y_dataframe"
  ],
  "test_additive_detrending_series": [
    "y_series"
  ],
  "test_additive_detrending_dataframe": [
    "y_dataframe"
  ],
  "MODELS": [],
  "test_deseasonalised_values": [
    "sp"
  ],
  "test_transform_time_index": [
    "sp",
    "model"
  ],
  "test_inverse_transform_time_index": [
    "sp",
    "model"
  ],
  "test_transform_inverse_transform_equivalence": [
    "sp",
    "model"
  ],
  "test_deseasonalizer_in_pipeline": [],
  "test_stl_inverse": [
    "return_components"
  ],
  "test_transform_returns_correct_components": [],
  "test_mstl_deseason_pipeline": [],
  "test_mstl_component_pipeline": [],
  "Aggregator": {
    "_tags": [],
    "__init__": [
      "self",
      "flatten_single_levels",
      "bypass_inverse_transform"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_check_index_no_total": [
    "X"
  ],
  "_flatten_single_indexes": [
    "X"
  ],
  "SqueezeHierarchy": {
    "_tags": [],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_assert_no_inconsistent_duplicated_indexes": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "test_aggregator_fit_transform_index": [
    "flatten_single_levels"
  ],
  "test_aggregator_flatten": [],
  "test_aggregator_inverse_transform": [],
  "_generate_hier_data": [
    "flatten_single_levels",
    "no_levels",
    "no_bottom_nodes"
  ],
  "test_reconcilers_keep_immutable_levels": [
    "reconciler",
    "expected_immutable_level",
    "flatten_single_levels",
    "no_levels"
  ],
  "test_optimal_reconciliation_ols": [],
  "test_get_series_for_each_hierarchical_level": [
    "hierarchical_level_nodes"
  ],
  "test_walk_up_hierarchical_levels": [
    "idx_tuple",
    "expected_result"
  ],
  "example_data_for_topdown_all_ones": [],
  "example_data_for_topdown_varied": [],
  "test_recursively_propagate_topdown": [
    "example_func"
  ],
  "hierarchical_data": [],
  "create_redundant_hierarchical_indexes": [
    "n_hier_levels",
    "n_redundant",
    "n_instances_per_level"
  ],
  "test_fit": [
    "n_redundant",
    "n_hier_levels",
    "n_instances_per_level"
  ],
  "test_transform": [
    "n_redundant",
    "n_hier_levels",
    "n_instances_per_level"
  ],
  "test_inverse_transform": [
    "n_redundant",
    "n_hier_levels",
    "n_instances_per_level"
  ],
  "test_no_hierarchy_handling": [],
  "small_hier_index": [],
  "test_create_summing_matrix_from_index": [
    "small_hier_index"
  ],
  "test_nonnegative_reconciliation": [
    "hierarchical_levels"
  ],
  "test_mint_kills_weighted_rowspace_perturbation": [
    "W",
    "Reconciler"
  ],
  "_loc_series_idxs": [
    "y",
    "idxs"
  ],
  "_get_bottom_level_idxs": [
    "y"
  ],
  "_get_total_level_idxs": [
    "y"
  ],
  "_is_ancestor": [
    "agg",
    "bot"
  ],
  "_filter_descendants": [
    "X",
    "aggregator_node"
  ],
  "_get_index_level_aggregators": [
    "X",
    "index_level"
  ],
  "_promote_hierarchical_indexes": [
    "idx_tuple"
  ],
  "_promote_hierarchical_indexes_and_keep_timeindex": [
    "idx_tuple"
  ],
  "_recursively_propagate_topdown": [
    "X"
  ],
  "_get_series_for_each_hierarchical_level": [
    "idx"
  ],
  "TopdownReconciler": {
    "__init__": [
      "self",
      "method"
    ],
    "_fit_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_reconcile_td_share": [
      "self",
      "X"
    ],
    "_reconcile_td_fcst": [
      "self",
      "X"
    ],
    "_transform_non_total_to_ratios": [
      "self",
      "X"
    ],
    "_coerce_children_sum_to_one": [
      "self",
      "X"
    ],
    "_transform_to_td_fcst_ratios": [
      "self",
      "X"
    ],
    "_split_total_and_non_total": [
      "self",
      "X"
    ],
    "get_test_params": [
      "self",
      "parameter_set"
    ]
  },
  "_has_hierarchy": [
    "X"
  ],
  "_ReconcilerTransformer": {
    "_tags": [],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ]
  },
  "BottomUpReconciler": {
    "_tags": [],
    "_fit_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ]
  },
  "MiddleOutReconciler": {
    "_tags": [],
    "__init__": [
      "self",
      "middle_level",
      "middle_bottom_reconciler"
    ],
    "_fit_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_get_middle_bottom_subtrees": [
      "self",
      "X"
    ],
    "_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Reconciler": {
    "_tags": [],
    "METHOD_LIST": [],
    "__init__": [
      "self",
      "method"
    ],
    "_add_totals": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_check_method": [
      "self"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_get_s_matrix": [
    "X"
  ],
  "_get_g_matrix_bu": [
    "X"
  ],
  "_get_g_matrix_ols": [
    "X"
  ],
  "_get_g_matrix_wls_str": [
    "X"
  ],
  "_get_g_matrix_td_fcst": [
    "X"
  ],
  "_update_td_fcst": [
    "g_matrix",
    "x_sf",
    "conn_df"
  ],
  "_parent_child_df": [
    "s_matrix"
  ],
  "OptimalReconciler": {
    "__init__": [
      "self",
      "error_covariance_matrix",
      "alpha"
    ],
    "_fit_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_n_bottom": [
      "self"
    ],
    "_n_not_bottom": [
      "self"
    ],
    "_n_series": [
      "self"
    ],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ],
    "_get_error_covariance_matrix": [
      "self",
      "error_covariance_matrix"
    ],
    "_get_arrays": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NonNegativeOptimalReconciler": {
    "_tags": [],
    "_inverse_transform_reconciler": [
      "self",
      "X",
      "y"
    ]
  },
  "_create_summing_matrix_from_index": [
    "hier_index"
  ],
  "_dataframe_to_ndarray": [
    "df"
  ],
  "_split_summing_matrix": [
    "S"
  ],
  "_get_bottom_and_aggregated_idxs": [
    "S"
  ],
  "_get_permutation_matrix": [
    "S"
  ],
  "_get_unique_series_from_df": [
    "X"
  ],
  "TransformerPipeline": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "steps"
    ],
    "_steps": [
      "self",
      "value"
    ],
    "_check_steps": [
      "self",
      "estimators"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_to_dim": [
      "self",
      "x"
    ],
    "_dim_diff": [
      "self",
      "obj"
    ],
    "_dim_to_sci": [
      "self",
      "d"
    ],
    "_trafo_out": [
      "self"
    ]
  },
  "OptionalPassthrough": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "passthrough"
    ],
    "_delegate_name": [],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PANDAS_MTYPES": [],
  "ColumnEnsembleTransformer": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "transformers",
      "remainder",
      "feature_names_out"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_check_transformers": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "ColumnwiseTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "columns"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "update": [
      "self",
      "X",
      "y",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_check_columns": [
    "z",
    "selected_columns"
  ],
  "InvertTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer"
    ],
    "_delegate_name": [],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiplexTransformer": {
    "_tags": [],
    "_delegate_name": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "transformers",
      "selected_transformer"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_check_selected_transformer": [
      "self"
    ],
    "_set_transformer": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ]
  },
  "CORE_MTYPES": [],
  "_coerce_to_sktime": [
    "other"
  ],
  "YtoX": {
    "_tags": [],
    "__init__": [
      "self",
      "subset_index"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FitInTransform": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "skip_inverse_transform"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CombineTransformers": {
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "_tags": [],
    "__init__": [
      "self",
      "transformers",
      "op"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Logger": {
    "_tags": [],
    "__init__": [
      "self",
      "logger",
      "logger_backend",
      "log_methods",
      "level",
      "log_fitted_params"
    ],
    "get_logger": [
      "self"
    ],
    "_write_log": [
      "self",
      "key",
      "obj"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DataLog": {
    "__init__": [
      "self",
      "key"
    ],
    "log": [
      "self",
      "log_key",
      "data"
    ],
    "reset": [
      "self"
    ],
    "get_log": [
      "self"
    ]
  },
  "TransformIf": {
    "_tags": [],
    "__init__": [
      "self",
      "if_estimator",
      "param",
      "condition",
      "condition_value",
      "then_trafo",
      "else_trafo"
    ],
    "_delegate_name": [],
    "_evaluate_condition": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Id": {
    "_tags": [],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "TransformByLevel": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "transformer",
      "groupby",
      "raise_warnings"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FeatureUnion": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "transformer_list",
      "n_jobs",
      "transformer_weights",
      "flatten_transform_index"
    ],
    "_transformer_list": [
      "self",
      "value"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IxToX": {
    "_tags": [],
    "__init__": [
      "self",
      "coerce_to_type",
      "level",
      "ix_source"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "STLBootstrapTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_series",
      "sp",
      "block_length",
      "sampling_replacement",
      "return_actual",
      "lambda_bounds",
      "lambda_method",
      "seasonal",
      "trend",
      "low_pass",
      "seasonal_deg",
      "trend_deg",
      "low_pass_deg",
      "robust",
      "seasonal_jump",
      "trend_jump",
      "low_pass_jump",
      "inner_iter",
      "outer_iter",
      "random_state",
      "return_indices"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MovingBlockBootstrapTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_series",
      "block_length",
      "sampling_replacement",
      "return_actual",
      "random_state",
      "return_indices"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_moving_block_bootstrap": [
    "ts",
    "block_length",
    "replacement",
    "random_state",
    "return_indices"
  ],
  "_get_series_name": [
    "ts"
  ],
  "RepeatBootstrapTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_series"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SplitterBootstrapTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "splitter",
      "fold",
      "shuffle",
      "subsample",
      "replace",
      "random_state"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSBootstrapAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "bootstrap",
      "include_actual",
      "return_indices"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "y": [],
  "y_index": [],
  "test_bootstrapping_transformer_no_seasonal_period": [],
  "test_bootstrapping_transformer_series_shorter_than_sp": [],
  "test_block_length_exception": [
    "transformer_class"
  ],
  "index_return_actual_true": [],
  "index_return_actual_false": [],
  "test_bootstrap_transformers_panel_format": [
    "transformer_class",
    "return_actual",
    "expected_index"
  ],
  "test_moving_block_bootstrap": [
    "block_length",
    "replacement"
  ],
  "test_get_series_name": [
    "ts"
  ],
  "MODULE": [],
  "fpp3": [],
  "tsibble": [],
  "tsibbledata": [],
  "DATASET_NAMES_FPP3": [],
  "_decompress_file_to_temp": [
    "datafile",
    "archivedir",
    "temp_folder",
    "robust"
  ],
  "_find_dataset": [
    "temp_folder",
    "dataset_name"
  ],
  "_yearweek_constructor": [
    "obj",
    "attrs"
  ],
  "_yearmonth_constructor": [
    "obj",
    "attrs"
  ],
  "_yearquarter_constructor": [
    "obj",
    "attrs"
  ],
  "_date_constructor": [
    "obj",
    "attrs"
  ],
  "_import_rda": [
    "path"
  ],
  "_dataset_to_mtype": [
    "dataset_name",
    "obj"
  ],
  "_process_dataset": [
    "dataset_name",
    "temp_folder",
    "robust"
  ],
  "_load_fpp3": [
    "dataset",
    "temp_folder",
    "robust"
  ],
  "load_fpp3": [
    "dataset",
    "temp_folder"
  ],
  "tsf_all": [],
  "tsf_all_datasets": [],
  "___author__": [],
  "configuration": [
    "parent_package",
    "top_path"
  ],
  "DatasetDownloadStrategy": {
    "download": [
      "self",
      "download_path",
      "force_download"
    ],
    "_get_dataset_folder_path": [
      "self",
      "download_path"
    ],
    "_download": [
      "self",
      "download_path",
      "force_download"
    ]
  },
  "HuggingFaceDownloader": {
    "_tags": [],
    "__init__": [
      "self",
      "hf_repo_name",
      "folder_name",
      "repo_type",
      "token"
    ],
    "_get_dataset_folder_path": [
      "self",
      "download_path"
    ],
    "_download": [
      "self",
      "download_path",
      "force_download"
    ]
  },
  "URLDownloader": {
    "__init__": [
      "self",
      "base_urls"
    ],
    "_get_dataset_folder_path": [
      "self",
      "download_path"
    ],
    "_download": [
      "self",
      "download_path",
      "force_download"
    ],
    "_download_and_extract": [
      "self",
      "url",
      "root_path",
      "force"
    ]
  },
  "DatasetDownloader": {
    "__init__": [
      "self",
      "hf_repo_name",
      "folder_name",
      "fallback_urls",
      "retries"
    ],
    "_get_dataset_folder_path": [
      "self",
      "download_path"
    ],
    "_download": [
      "self",
      "download_path",
      "force_download"
    ]
  },
  "DIRNAME": [],
  "CLASSIF_URLS": [],
  "_list_available_datasets": [
    "extract_path",
    "origin_repo"
  ],
  "_cache_dataset": [
    "url",
    "name",
    "extract_path",
    "repeats",
    "verbose"
  ],
  "_mkdir_if_not_exist": [],
  "_load_dataset": [
    "name",
    "split",
    "return_X_y",
    "return_type",
    "extract_path",
    "y_dtype"
  ],
  "_load_provided_dataset": [
    "name",
    "split",
    "return_X_y",
    "return_type",
    "extract_path",
    "y_dtype"
  ],
  "generate_example_long_table": [
    "num_cases",
    "series_len",
    "num_dims"
  ],
  "make_multi_index_dataframe": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "_reduce_memory_usage": [
    "df",
    "category",
    "n_jobs"
  ],
  "load_UCR_UEA_dataset": [
    "name",
    "split",
    "return_X_y",
    "return_type",
    "extract_path",
    "y_dtype"
  ],
  "load_tecator": [
    "split",
    "return_X_y",
    "return_type",
    "y_dtype"
  ],
  "load_plaid": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_gunpoint": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_osuleaf": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_italy_power_demand": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_unit_test": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_japanese_vowels": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_arrow_head": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_acsf1": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "load_basic_motions": [
    "split",
    "return_X_y",
    "return_type"
  ],
  "_coerce_to_monthly_period_index": [
    "ix"
  ],
  "load_shampoo_sales": [],
  "load_longley": [
    "y_name"
  ],
  "load_lynx": [],
  "load_airline": [],
  "load_uschange": [
    "y_name"
  ],
  "load_gun_point_segmentation": [],
  "load_electric_devices_segmentation": [],
  "load_PBS_dataset": [],
  "load_macroeconomic": [],
  "load_unit_test_tsf": [],
  "load_solar": [
    "start",
    "end",
    "normalise",
    "return_full_df",
    "api_version"
  ],
  "load_covid_3month": [
    "split",
    "return_X_y",
    "y_dtype"
  ],
  "load_forecastingdata": [
    "name",
    "replace_missing_vals",
    "value_column_name",
    "return_type",
    "extract_path"
  ],
  "load_m5": [
    "extract_path",
    "include_events",
    "merged",
    "test"
  ],
  "load_hierarchical_sales_toydata": [],
  "univariate": [],
  "multivariate": [],
  "univariate_equal_length": [],
  "univariate_variable_length": [],
  "univariate_missing_values": [],
  "multivariate_equal_length": [],
  "multivariate_unequal_length": [],
  "UNIVARIATE_PROBLEMS": [],
  "MULTIVARIATE_PROBLEMS": [],
  "UNEQUAL_LENGTH_PROBLEMS": [],
  "test_load_dataframe": [
    "loader"
  ],
  "test_load_numpy3d": [
    "loader",
    "split"
  ],
  "test_load_numpy2d_univariate": [
    "loader"
  ],
  "test_load_numpy2d_multivariate_raises": [
    "loader"
  ],
  "_tag_constraints": [],
  "ForecastingDatasetFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllForecastingDatasets": {
    "test_tag_is_one_series": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_panels": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_hierarchy_levels": [
      "self",
      "estimator_instance"
    ],
    "test_tag_constraints": [
      "self",
      "estimator_instance"
    ],
    "test_tag_is_univariate": [
      "self",
      "estimator_instance"
    ]
  },
  "test_load_macroeconomic": [],
  "MTYPE_LIST_PANEL": [],
  "_TO_DISABLE": [],
  "test_load_provided_dataset": [
    "return_X_y",
    "return_type"
  ],
  "test_load_basic_motions": [
    "return_X_y",
    "return_type"
  ],
  "test_load_UCR_UEA_dataset": [],
  "test_load_UCR_UEA_local": [],
  "_CHECKS": [],
  "test_data_loaders": [
    "dataset"
  ],
  "test_list_available_datasets": [
    "origin_repo"
  ],
  "test_load_hierarchical_sales_toydata": [],
  "N_TSF_SUBSAMPLE": [],
  "TSF_SUBSAMPLE": [],
  "TSF_SUBSAMPLE_SMALL": [],
  "test_load_solar": [],
  "test_load_UEA": [],
  "test_load_forecastingdata": [],
  "test_load_forecastingdata_check_freq_for_hier_data": [],
  "test_load_forecastingdata_hier": [
    "name"
  ],
  "test_check_link_downloadable": [
    "name"
  ],
  "test_load_forecasting_data_invalid_name": [
    "name"
  ],
  "test_load_fpp3_private": [],
  "test_load_fpp3_public": [],
  "test_load_m5": [],
  "RegressionDatasetFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllRegressionDatasets": {
    "test_tag_is_univariate": [
      "self",
      "estimator_instance"
    ]
  },
  "HF_REPO_NAME": [],
  "FOLDER_NAME": [],
  "URL": [],
  "EXPECTED_FILES": [],
  "test_downloader_strategy_behavior": [
    "tmp_path",
    "strategy"
  ],
  "test_load_from_tsfile_to_dataframe": [],
  "test_load_from_tsfile": [],
  "test_load_from_long_to_dataframe": [
    "tmpdir"
  ],
  "test_load_from_long_incorrect_format": [
    "tmpdir"
  ],
  "test_load_tsf_to_dataframe": [
    "input_path",
    "return_type",
    "output_df"
  ],
  "test_convert_tsf_to_multiindex": [
    "freq"
  ],
  "test_write_panel_to_tsfile_equal_length": [
    "dataset_name",
    "return_type",
    "tmpdir"
  ],
  "test_write_panel_to_tsfile_unequal_length": [
    "dataset_name",
    "tmpdir"
  ],
  "test_write_dataframe_to_ts_success": [
    "tmp_path",
    "dataset"
  ],
  "test_write_dataframe_to_ts_fail": [
    "tmp_path"
  ],
  "is_generator": [
    "obj"
  ],
  "DatasetFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllDatasets": {
    "test_load_output_type": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_instances": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_instances_train": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_instances_test": [
      "self",
      "estimator_instance"
    ],
    "test_tag_n_splits": [
      "self",
      "estimator_instance"
    ]
  },
  "ClassificationDatasetFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllClassificationDatasets": {
    "test_tag_n_classes": [
      "self",
      "estimator_instance"
    ],
    "test_tag_is_univariate": [
      "self",
      "estimator_instance"
    ]
  },
  "load_from_tsfile_to_dataframe": [
    "full_file_path_and_name",
    "return_separate_X_and_y",
    "replace_missing_vals_with",
    "encoding",
    "y_dtype"
  ],
  "write_dataframe_to_tsfile": [
    "data",
    "path",
    "problem_name",
    "class_label",
    "class_value_list",
    "equal_length",
    "series_length",
    "missing_values",
    "comment",
    "fold"
  ],
  "write_ndarray_to_tsfile": [
    "data",
    "path",
    "problem_name",
    "class_label",
    "class_value_list",
    "equal_length",
    "series_length",
    "missing_values",
    "comment",
    "fold"
  ],
  "write_panel_to_tsfile": [
    "data",
    "path",
    "target",
    "problem_name",
    "header"
  ],
  "_alias_mtype_check": [
    "return_type"
  ],
  "_read_header": [
    "file",
    "full_file_path_and_name"
  ],
  "_write_header": [
    "path",
    "problem_name",
    "univariate",
    "equal_length",
    "series_length",
    "class_label",
    "fold",
    "comment"
  ],
  "write_results_to_uea_format": [
    "estimator_name",
    "dataset_name",
    "y_pred",
    "output_path",
    "full_path",
    "y_true",
    "predicted_probs",
    "split",
    "resample_seed",
    "timing_type",
    "first_line_comment",
    "second_line",
    "third_line"
  ],
  "get_path": [
    "path",
    "suffix"
  ],
  "load_from_ucr_tsv_to_dataframe": [
    "full_file_path_and_name",
    "return_separate_X_and_y"
  ],
  "_convert_tsf_to_hierarchical": [
    "data",
    "metadata",
    "freq",
    "value_column_name"
  ],
  "create_range_index": [
    "value_column_name",
    "df"
  ],
  "load_tsf_to_dataframe": [
    "full_file_path_and_name",
    "replace_missing_vals_with",
    "value_column_name",
    "return_type"
  ],
  "load_from_arff_to_dataframe": [
    "full_file_path_and_name",
    "has_class_labels",
    "return_separate_X_and_y",
    "replace_missing_vals_with"
  ],
  "write_tabular_transformation_to_arff": [
    "data",
    "transformation",
    "path",
    "problem_name",
    "class_label",
    "class_value_list",
    "comment",
    "fold",
    "fit_transform"
  ],
  "load_from_long_to_dataframe": [
    "full_file_path_and_name",
    "separator"
  ],
  "M5Dataset": {
    "_tags": [],
    "__init__": [
      "self",
      "extract_path"
    ],
    "cache_files_directory": [
      "self"
    ],
    "path_to_data_dir": [
      "self"
    ],
    "_download": [
      "self"
    ],
    "_load": [
      "self"
    ],
    "_return_sets": [
      "self",
      "sets_to_return",
      "cache"
    ],
    "_process_raw_data": [
      "self",
      "target_variable",
      "sell_prices",
      "calendar"
    ]
  },
  "USChange": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self",
      "y_name"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "HierarchicalSalesToydata": {
    "_tags": [],
    "loader_func": []
  },
  "Solar": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self",
      "start",
      "end",
      "normalise",
      "return_full_df",
      "api_version"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Macroeconomic": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self"
    ]
  },
  "BaseForecastingDataset": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_load": [
      "self"
    ]
  },
  "_ForecastingDatasetFromLoader": {
    "_load_dataset": [
      "self"
    ],
    "_split_into_y_and_X": [
      "self",
      "loader_output"
    ]
  },
  "PBS": {
    "_tags": [],
    "loader_func": []
  },
  "ShampooSales": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self"
    ]
  },
  "Airline": {
    "_tags": [],
    "loader_func": []
  },
  "Longley": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self",
      "y_name"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Lynx": {
    "_tags": [],
    "loader_func": [],
    "__init__": [
      "self"
    ]
  },
  "FORCE_RANGEINDEX": [],
  "ForecastingData": {
    "__init__": [
      "self",
      "name"
    ],
    "_encode_args": [
      "self",
      "code"
    ],
    "_load": [
      "self"
    ],
    "_load_dataset": [
      "self"
    ],
    "_to_sktime_multiindex": [
      "self",
      "y",
      "metadata"
    ],
    "_split_into_y_and_X": [
      "self",
      "loader_output"
    ],
    "all_datasets": [],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DATASET_TAGS": [],
  "ACSF1": {
    "_tags": [],
    "loader_func": []
  },
  "OSULeaf": {
    "_tags": [],
    "loader_func": []
  },
  "JapaneseVowels": {
    "_tags": [],
    "loader_func": []
  },
  "BaseClassificationDataset": {
    "_tags": [],
    "__init__": [
      "self",
      "return_mtype"
    ],
    "_load": [
      "self"
    ]
  },
  "_ClassificationDatasetFromLoader": {},
  "PLAID": {
    "_tags": [],
    "loader_func": []
  },
  "GunPoint": {
    "_tags": [],
    "loader_func": []
  },
  "ArrowHead": {
    "_tags": [],
    "loader_func": []
  },
  "ItalyPowerDemand": {
    "_tags": [],
    "loader_func": []
  },
  "BasicMotions": {
    "_tags": [],
    "loader_func": []
  },
  "UCRUEADataset": {
    "__init__": [
      "self",
      "name",
      "return_mtype"
    ],
    "_encode_args": [
      "self",
      "code"
    ],
    "_load": [
      "self"
    ],
    "_load_dataset": [
      "self"
    ],
    "list_all": [],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "classification_data": [],
  "InvalidSetError": {
    "__init__": [
      "self",
      "set_name",
      "valid_set_names"
    ],
    "__str__": [
      "self"
    ]
  },
  "_DatasetFromLoaderMixin": {
    "loader_func": [],
    "_encode_args": [
      "self",
      "code"
    ],
    "get_loader_func": [
      "self"
    ],
    "_load": [
      "self"
    ],
    "_load_dataset": [
      "self"
    ]
  },
  "Tecator": {
    "_tags": [],
    "loader_func": []
  },
  "BaseRegressionDataset": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_load": [
      "self"
    ]
  },
  "_RegressionDatasetFromLoader": {},
  "convert_dict": [],
  "convert": [
    "obj",
    "from_type",
    "to_type",
    "as_scitype",
    "store",
    "store_behaviour",
    "return_to_mtype"
  ],
  "convert_to": [
    "obj",
    "to_type",
    "as_scitype",
    "store",
    "store_behaviour",
    "return_to_mtype"
  ],
  "_get_first_mtype_of_same_scitype": [
    "from_mtype",
    "to_mtypes",
    "varname"
  ],
  "_conversions_defined": [
    "scitype"
  ],
  "_check_str_or_list_of_str": [
    "obj",
    "obj_name"
  ],
  "_get_index": [
    "x"
  ],
  "get_time_index": [
    "X"
  ],
  "get_index_for_series": [
    "obj",
    "cutoff"
  ],
  "GET_CUTOFF_SUPPORTED_MTYPES": [],
  "_get_cutoff_from_index": [
    "idx",
    "return_index",
    "reverse_order"
  ],
  "get_cutoff": [
    "obj",
    "cutoff",
    "return_index",
    "reverse_order",
    "check_input",
    "convert_input"
  ],
  "UPDATE_DATA_INTERNAL_MTYPES": [],
  "update_data": [
    "X",
    "X_new"
  ],
  "GET_WINDOW_SUPPORTED_MTYPES": [],
  "get_window": [
    "obj",
    "window_length",
    "lag"
  ],
  "get_slice": [
    "obj",
    "start",
    "end",
    "start_inclusive",
    "end_inclusive"
  ],
  "DtypeKind": {
    "INT": [],
    "UINT": [],
    "FLOAT": [],
    "BOOL": [],
    "STRING": [],
    "DATETIME": [],
    "CATEGORICAL": []
  },
  "_pandas_dtype_to_kind": [
    "col_dtypes"
  ],
  "_polars_dtype_to_kind": [
    "col_dtypes"
  ],
  "_get_series_dtypekind": [
    "obj",
    "mtype"
  ],
  "_get_panel_dtypekind": [
    "obj",
    "mtype"
  ],
  "_get_table_dtypekind": [
    "obj",
    "mtype"
  ],
  "_get_feature_kind": [
    "col_dtypekinds"
  ],
  "__getattr__": [
    "name"
  ],
  "_only_core_deps": [
    "cls"
  ],
  "generate_mtype_cls_list": [
    "soft_deps"
  ],
  "_generate_mtype_cls_list": [
    "soft_deps"
  ],
  "generate_mtype_register": [
    "scitype",
    "soft_deps"
  ],
  "_generate_mtype_register_subset": [
    "scitype",
    "soft_deps"
  ],
  "_generate_mtype_register": [
    "soft_deps"
  ],
  "generate_mtype_list": [
    "scitype",
    "soft_deps"
  ],
  "MTYPE_SOFT_DEPS_SERIES": [],
  "MTYPE_SOFT_DEPS_PANEL": [],
  "MTYPE_SOFT_DEPS_HIERARCHICAL": [],
  "MTYPE_SOFT_DEPS": [],
  "AMBIGUOUS_MTYPES": [],
  "SCITYPE_REGISTER": [],
  "SCITYPE_LIST": [],
  "mtype_to_scitype": [
    "mtype",
    "return_unique",
    "coerce_to_list"
  ],
  "scitype_to_mtype": [
    "scitype",
    "softdeps"
  ],
  "generate_example_dicts": [
    "soft_deps"
  ],
  "get_examples": [
    "mtype",
    "as_scitype",
    "return_lossy",
    "return_metadata"
  ],
  "VectorizedDF": {
    "SERIES_SCITYPES": [],
    "__init__": [
      "self",
      "X",
      "y",
      "iterate_as",
      "is_scitype",
      "iterate_cols",
      "remember_data"
    ],
    "_check_iterate_cols": [
      "self",
      "iterate_cols"
    ],
    "_check_iterate_as": [
      "self",
      "iterate_as"
    ],
    "_coerce_to_df": [
      "self",
      "obj",
      "scitype",
      "store",
      "store_behaviour"
    ],
    "_init_conversion": [
      "self",
      "X"
    ],
    "_init_iter_indices": [
      "self"
    ],
    "index": [
      "self"
    ],
    "get_iter_indices": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ],
    "items": [
      "self",
      "iterate_as",
      "iterate_cols"
    ],
    "_iter_levels": [
      "self",
      "iterate_as"
    ],
    "_iter_shape": [
      "self",
      "iterate_as",
      "iterate_cols"
    ],
    "as_list": [
      "self"
    ],
    "reconstruct": [
      "self",
      "df_list",
      "convert_back",
      "overwrite_index",
      "col_multiindex"
    ],
    "vectorize_est": [
      "self",
      "estimator",
      "method",
      "args",
      "args_rowvec",
      "return_type",
      "rowname_default",
      "colname_default",
      "varname_of_self",
      "backend",
      "backend_params"
    ],
    "_vectorize_est_single": [
      "self",
      "vec_tuple",
      "meta"
    ]
  },
  "_enforce_index_freq": [
    "item"
  ],
  "get_check_dict": [
    "soft_deps"
  ],
  "generate_check_dict": [
    "soft_deps"
  ],
  "_check_scitype_valid": [
    "scitype"
  ],
  "check_is_mtype": [
    "obj",
    "mtype",
    "scitype",
    "return_metadata",
    "var_name",
    "msg_return_dict"
  ],
  "check_raise": [
    "obj",
    "mtype",
    "scitype",
    "var_name"
  ],
  "mtype": [
    "obj",
    "as_scitype",
    "exclude_mtypes"
  ],
  "check_is_scitype": [
    "obj",
    "scitype",
    "return_metadata",
    "var_name",
    "exclude_mtypes"
  ],
  "check_is_error_msg": [
    "msg",
    "var_name",
    "allowed_msg",
    "raise_exception"
  ],
  "scitype": [
    "obj",
    "candidate_scitypes",
    "exclude_mtypes"
  ],
  "MTYPE_LIST_HIERARCHICAL": [],
  "convert_identity": [
    "obj",
    "store"
  ],
  "ScitypeHierarchical": {
    "_tags": [],
    "__init__": [
      "self",
      "is_univariate",
      "is_equally_spaced",
      "is_equal_length",
      "is_empty",
      "is_one_series",
      "is_one_panel",
      "has_nans",
      "n_instances",
      "n_panels",
      "n_features",
      "feature_names",
      "dtypekind_dfip",
      "feature_kind"
    ]
  },
  "_HierMultivEqspl": {
    "_tags": []
  },
  "_HierMultivEqsplPdMiHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_HierMultivEqsplDaskHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_HierMultivEqsplPolarsHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_HierUnivEqspl": {
    "_tags": []
  },
  "_HierUnivEqsplPdMiHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_HierUnivEqsplDaskHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_HierUnivEqsplPolarsHier": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_list_all_equal": [
    "obj"
  ],
  "HierarchicalPdMultiIndex": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "HierarchicalDask": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "HierarchicalPolarsEager": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "MTYPE_LIST_PROBA": [],
  "convert_pred_interval_to_quantiles": [
    "y_pred",
    "inplace"
  ],
  "convert_interval_to_quantiles": [
    "obj",
    "store"
  ],
  "convert_pred_quantiles_to_interval": [
    "y_pred",
    "inplace"
  ],
  "convert_quantiles_to_interval": [
    "obj",
    "store"
  ],
  "ScitypeProba": {
    "_tags": [],
    "__init__": [
      "self",
      "is_univariate",
      "is_empty",
      "has_nans"
    ]
  },
  "_ProbaUniv": {
    "_tags": []
  },
  "_ProbaUnivPredQ": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_ProbaUnivPredInt": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_ProbaMulti": {
    "_tags": []
  },
  "_ProbaMultiPredQ": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_ProbaMultiPredInt": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "ProbaPredQuantiles": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "ProbaPredInterval": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "MTYPE_LIST_SERIES": [],
  "convert_UvS_to_MvS_as_Series": [
    "obj",
    "store"
  ],
  "convert_MvS_to_UvS_as_Series": [
    "obj",
    "store"
  ],
  "convert_MvS_to_np_as_Series": [
    "obj",
    "store"
  ],
  "convert_UvS_to_np_as_Series": [
    "obj",
    "store"
  ],
  "convert_np_to_MvS_as_Series": [
    "obj",
    "store"
  ],
  "convert_np_to_UvS_as_Series": [
    "obj",
    "store"
  ],
  "ScitypeSeries": {
    "_tags": [],
    "__init__": [
      "self",
      "is_univariate",
      "is_equally_spaced",
      "is_empty",
      "has_nans",
      "n_features",
      "feature_names",
      "dtypekind_dfip",
      "feature_kind"
    ]
  },
  "infer_mtype_dict": [],
  "infer_mtype_Series": [
    "obj"
  ],
  "_SeriesUniv": {
    "_tags": []
  },
  "_SeriesUnivPdSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPdDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivNpArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivXrDataArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivDaskSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPlDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivGluontsListDataset": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMulti": {
    "_tags": []
  },
  "_SeriesMultiPdSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPdDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiNpArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiXrDataArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiDaskSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPlDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiGluontsListDataset": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPos": {
    "_tags": []
  },
  "_SeriesMultiPosPdSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosPdDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosNpArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosXrDataArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosDaskSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosPlDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesMultiPosGluontsListDataset": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPos": {
    "_tags": []
  },
  "_SeriesUnivPosPdSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPosPdDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPosNpArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPosXrDataArray": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPosPlDataFrame": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_SeriesUnivPosGluontsListDataset": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "VALID_INDEX_TYPES": [],
  "FREQ_SET_CHECK": [],
  "SeriesPdDataFrame": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_pddataframe_series": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "SeriesPdSeries": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "SeriesNp2D": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_index_equally_spaced": [
    "index"
  ],
  "SeriesXarray": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "SeriesDask": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "SeriesPolarsEager": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "SeriesGluontsList": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "SeriesGluontsPandas": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "convert_gluonts_result_to_multiindex": [
    "gluonts_result"
  ],
  "convert_from_multiindex_to_listdataset": [
    "trainDF",
    "class_val_list"
  ],
  "get_mi_cols": [
    "obj"
  ],
  "is_monotonically_increasing": [
    "obj"
  ],
  "_convert_period_index_to_datetime_index": [
    "obj"
  ],
  "convert_pandas_to_polars": [
    "obj",
    "schema_overrides",
    "rechunk",
    "nan_to_null",
    "lazy"
  ],
  "convert_polars_to_pandas": [
    "obj",
    "infer_freq"
  ],
  "check_polars_frame": [
    "obj",
    "return_metadata",
    "var_name",
    "lazy",
    "scitype"
  ],
  "convert_pandas_to_listDataset": [
    "pd_dataframe"
  ],
  "convert_listDataset_to_pandas": [
    "list_dataset"
  ],
  "convert_pandas_dataframe_to_pandasDataset": [
    "pd_dataframe"
  ],
  "convert_pandasDataset_to_pandas_dataframe": [
    "pandasDataset"
  ],
  "convert_pandas_multiindex_to_pandasDataset": [
    "pd_dataframe",
    "target",
    "item_id",
    "timepoints",
    "freq"
  ],
  "convert_pandasDataset_to_pandas": [
    "pandasDataset",
    "item_id",
    "timepoints",
    "convert_time"
  ],
  "convert_pandas_collection_to_pandasDataset": [
    "collection_dataframe",
    "timepoints",
    "freq",
    "target"
  ],
  "_is_mi_col": [
    "x"
  ],
  "convert_dask_to_pandas": [
    "obj"
  ],
  "convert_pandas_to_dask": [
    "obj",
    "npartitions",
    "chunksize",
    "sort"
  ],
  "check_dask_frame": [
    "obj",
    "return_metadata",
    "var_name",
    "freq_set_check",
    "scitype"
  ],
  "pd_fixture_simple": [],
  "pd_fixture_multiindex": [],
  "PANDAS_FIXTURES": [],
  "test_check_dask_frame": [],
  "test_convert_dask_to_pd_multiindex": [],
  "test_convert_pd_multiindex_to_dask": [],
  "test_convert_pd_dask_inverse": [
    "pd_fixture"
  ],
  "test_pandas_to_ListDataset": [
    "pandas_df"
  ],
  "test_pandas_df_to_PandasDataset": [
    "pandas_obj",
    "conversion_function"
  ],
  "test_convert_polars_to_pandas_multiindex": [],
  "test_convert_pd_multiindex_to_polars": [],
  "test_convert_pd_polars_inverse": [
    "pd_fixture"
  ],
  "test_convert_pd_polars_inverse_lazy": [
    "pd_fixture"
  ],
  "test_pandas_to_polars_with_pandas_period_index_and_inverse": [],
  "test_pd_multiindex_to_polars_with_pandas_period_index_and_inverse": [],
  "N_INSTANCES": [],
  "N_COLUMNS": [],
  "N_TIMEPOINTS": [],
  "N_CLASSES": [],
  "test_are_columns_nested": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_nested_to_3d_numpy": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_3d_numpy_to_nested": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_nested_to_2d_array": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_3d_numpy_to_2d_array": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_multi_index_to_3d_numpy": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_3d_numpy_to_multi_index": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_multi_index_to_nested": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_nested_to_multi_index": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_is_nested_dataframe": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_2d_array_to_nested": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_long_to_nested": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_nested_to_long": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "test_from_multiindex_to_listdataset": [
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "SCITYPES": [],
  "MTYPES_SERIES": [],
  "MTYPES_PANEL": [],
  "test_convert_to_simple": [],
  "test_convert_to_without_scitype": [],
  "test_convert_to_mtype_list": [],
  "test_convert_to_mtype_list_different_scitype": [],
  "SCITYPE_MTYPE_PAIRS": [],
  "test_get_time_index": [
    "scitype",
    "mtype"
  ],
  "test_get_cutoff": [
    "scitype",
    "mtype",
    "return_index",
    "reverse_order",
    "convert_input"
  ],
  "test_get_cutoff_from_index": [
    "reverse_order"
  ],
  "test_get_cutoff_wrong_input": [
    "bad_inputs"
  ],
  "test_get_cutoff_inferred_freq": [],
  "test_get_cutoff_inferred_freq_small_series": [],
  "test_get_window_output_type": [
    "scitype",
    "mtype",
    "window_length",
    "lag"
  ],
  "test_get_window_expected_result": [],
  "test_get_slice_output_type": [
    "scitype",
    "mtype"
  ],
  "test_get_slice_expected_result": [],
  "test_retain_series_freq_on_update": [],
  "_get_all_mtypes_for_scitype": [
    "scitype"
  ],
  "_is_valid_iterate_as": [
    "scitype",
    "iterate_as"
  ],
  "_generate_scitype_mtype_combinations": [],
  "_generate_scitype_mtype_fixtureindex_combinations": [],
  "test_construct_vectorizeddf": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_cols",
    "iterate_as"
  ],
  "test_construct_vectorizeddf_errors": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "test_item_len": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_as",
    "iterate_cols"
  ],
  "test_iteration": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_as",
    "iterate_cols"
  ],
  "test_series_item_mtype": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_as",
    "iterate_cols"
  ],
  "test_reconstruct_identical": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_as",
    "iterate_cols"
  ],
  "test_enforce_index_freq": [
    "item",
    "freq"
  ],
  "test_vectorize_est": [
    "scitype",
    "mtype",
    "fixture_index",
    "iterate_as",
    "iterate_cols",
    "varname_used",
    "backend"
  ],
  "SCITYPES_NO_CONVERSIONS": [],
  "_generate_fixture_tuples": [],
  "test_convert": [
    "scitype",
    "from_mtype",
    "to_mtype",
    "fixture_index"
  ],
  "test_convert_numpy_series_to_panel": [],
  "test_convert_numpy_panel_to_series": [],
  "test_convert_df_series_to_panel": [],
  "test_convert_df_panel_to_series": [],
  "test_multiindex_to_df_list_large_level_values": [],
  "test_convert_MvS_to_UvS_as_Series": [],
  "SCITYPES_AMBIGUOUS_MTYPE": [],
  "test_check_positive": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "test_check_positive_check_scitype": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "test_check_metadata_inference": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "test_check_negative": [
    "scitype",
    "mtype"
  ],
  "test_mtype_infer": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "SKIP_SCITYPES": [],
  "SCITYPES_FOR_INFER_TEST": [],
  "test_scitype_infer": [
    "scitype",
    "mtype",
    "fixture_index"
  ],
  "test_object_support_for_series_scitype": [],
  "test_feature_kind_for_series": [],
  "test_feature_kind_for_panel": [],
  "test_feature_kind_for_hierarchical": [],
  "test_feature_kind_for_table": [],
  "test_mtype_to_scitype": [
    "mtype",
    "scitype"
  ],
  "test_mtype_to_scitype_list": [],
  "test_scitype_to_mtype": [
    "mtype",
    "scitype"
  ],
  "MTYPE_LIST_TABLE": [],
  "convert_1D_to_2D_numpy_as_Table": [
    "obj",
    "store"
  ],
  "convert_2D_to_1D_numpy_as_Table": [
    "obj",
    "store"
  ],
  "convert_df_to_2Dnp_as_Table": [
    "obj",
    "store"
  ],
  "convert_df_to_1Dnp_as_Table": [
    "obj",
    "store"
  ],
  "convert_2Dnp_to_df_as_Table": [
    "obj",
    "store"
  ],
  "convert_1Dnp_to_df_as_Table": [
    "obj",
    "store"
  ],
  "convert_s_to_df_as_table": [
    "obj",
    "store"
  ],
  "convert_df_to_s_as_table": [
    "obj",
    "store"
  ],
  "convert_list_of_dict_to_df_as_table": [
    "obj",
    "store"
  ],
  "convert_df_to_list_of_dict_as_table": [
    "obj",
    "store"
  ],
  "ScitypeTable": {
    "_tags": [],
    "__init__": [
      "self",
      "is_univariate",
      "is_empty",
      "has_nans",
      "n_instances",
      "n_features",
      "feature_names",
      "dtypekind_dfip",
      "feature_kind"
    ]
  },
  "_UnivTable": {
    "_tags": []
  },
  "_UnivTableDf": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTableNumpy2D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTableNumpy1D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTableSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTableListOfDict": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTablePolarsEager": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_UnivTablePolarsLazy": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTable": {
    "_tags": []
  },
  "_MultivTableDf": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTableNumpy2D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTableNumpy1D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTableSeries": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTableListOfDict": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTablePolarsEager": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_MultivTablePolarsLazy": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "PRIMITIVE_TYPES": [],
  "TablePdDataFrame": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_pddataframe_table": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "TablePdSeries": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_pdseries_table": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "TableNp1D": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_numpy1d_table": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "TableNp2D": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_numpy2d_table": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "TableListOfDict": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_list_of_dict_table": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "TablePolarsEager": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "TablePolarsLazy": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "BaseDatatype": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "obj",
      "return_metadata",
      "var_name",
      "return_metadata_type"
    ],
    "check": [
      "self",
      "obj",
      "return_metadata",
      "var_name",
      "return_metadata_type"
    ],
    "_precheck": [
      "self",
      "obj",
      "var_name"
    ],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "get": [
      "self",
      "key",
      "default"
    ],
    "_get_key": [
      "self"
    ]
  },
  "BaseConverter": {
    "_tags": [],
    "__init__": [
      "self",
      "mtype_from",
      "mtype_to"
    ],
    "__call__": [
      "self",
      "obj",
      "store"
    ],
    "convert": [
      "self",
      "obj",
      "store"
    ],
    "_convert": [
      "self",
      "obj",
      "store"
    ],
    "get_conversions": [
      "cls"
    ],
    "_get_cls_from_to": [
      "self"
    ],
    "_get_key": [
      "self"
    ]
  },
  "BaseExample": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_get_key": [
      "self"
    ],
    "build": [
      "self"
    ]
  },
  "_coerce_str_to_cls": [
    "cls_or_str"
  ],
  "_metadata_requested": [
    "return_metadata"
  ],
  "_ret": [
    "valid",
    "msg",
    "metadata",
    "return_metadata"
  ],
  "_req": [
    "key",
    "return_metadata"
  ],
  "_wr": [
    "d",
    "key",
    "val",
    "return_metadata"
  ],
  "convert_Series_to_Panel": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_Panel_to_Series": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_Series_to_Hierarchical": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_Hierarchical_to_Series": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_Panel_to_Hierarchical": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_Hierarchical_to_Panel": [
    "obj",
    "store",
    "return_to_mtype"
  ],
  "convert_to_scitype": [
    "obj",
    "to_scitype",
    "from_scitype",
    "store",
    "return_to_mtype"
  ],
  "convert_coerce": [
    "obj",
    "store"
  ],
  "_cell_is_series_or_array": [
    "cell"
  ],
  "_nested_cell_mask": [
    "X"
  ],
  "are_columns_nested": [
    "X"
  ],
  "_nested_cell_timepoints": [
    "cell"
  ],
  "_check_equal_index": [
    "X"
  ],
  "from_3d_numpy_to_2d_array": [
    "X"
  ],
  "from_3d_numpy_to_2d_array_adp": [
    "obj",
    "store"
  ],
  "from_nested_to_2d_array": [
    "X",
    "return_numpy"
  ],
  "from_nested_to_pdwide": [
    "obj",
    "store"
  ],
  "from_nested_to_2d_np_array": [
    "obj",
    "store"
  ],
  "from_2d_array_to_nested": [
    "X",
    "index",
    "columns",
    "time_index",
    "cells_as_numpy"
  ],
  "from_pd_wide_to_nested": [
    "obj",
    "store"
  ],
  "convert_from_dictionary": [
    "ts_dict"
  ],
  "_concat_nested_arrays": [
    "arrs",
    "cells_as_numpy"
  ],
  "_make_column_names": [
    "column_count"
  ],
  "_get_column_names": [
    "X"
  ],
  "from_nested_to_long": [
    "X",
    "instance_column_name",
    "time_column_name",
    "dimension_column_name"
  ],
  "from_nested_to_long_adp": [
    "obj",
    "store"
  ],
  "from_long_to_nested": [
    "X_long",
    "instance_column_name",
    "time_column_name",
    "dimension_column_name",
    "value_column_name",
    "column_names"
  ],
  "from_long_to_nested_adp": [
    "obj",
    "store"
  ],
  "from_multiindex_to_long": [
    "obj",
    "store"
  ],
  "from_long_to_multiindex": [
    "obj",
    "store"
  ],
  "from_multi_index_to_3d_numpy": [
    "X"
  ],
  "from_multi_index_to_3d_numpy_adp": [
    "obj",
    "store"
  ],
  "from_3d_numpy_to_multi_index": [
    "X",
    "instance_index",
    "time_index",
    "column_names"
  ],
  "from_3d_numpy_to_multi_index_adp": [
    "obj",
    "store"
  ],
  "from_multi_index_to_nested": [
    "multi_ind_dataframe",
    "instance_index",
    "cells_as_numpy"
  ],
  "from_multi_index_to_nested_adp": [
    "obj",
    "store"
  ],
  "from_nested_to_multi_index": [
    "X",
    "instance_index",
    "time_index"
  ],
  "from_nested_to_multi_index_adp": [
    "obj",
    "store"
  ],
  "_convert_series_cell_to_numpy": [
    "cell"
  ],
  "from_nested_to_3d_numpy": [
    "X"
  ],
  "from_nested_to_3d_numpy_adp": [
    "obj",
    "store"
  ],
  "from_3d_numpy_to_nested": [
    "X",
    "column_names",
    "cells_as_numpy"
  ],
  "from_3d_numpy_to_nested_adp": [
    "obj",
    "store"
  ],
  "from_dflist_to_multiindex": [
    "obj",
    "store"
  ],
  "from_multiindex_to_dflist": [
    "obj",
    "store"
  ],
  "from_dflist_to_numpy3D": [
    "obj",
    "store"
  ],
  "from_numpy3d_to_dflist": [
    "obj",
    "store"
  ],
  "from_nested_to_df_list_adp": [
    "obj",
    "store"
  ],
  "from_df_list_to_nested_adp": [
    "obj",
    "store"
  ],
  "from_numpy3d_to_numpyflat": [
    "obj",
    "store"
  ],
  "from_numpyflat_to_numpy3d": [
    "obj",
    "store"
  ],
  "ScitypePanel": {
    "_tags": [],
    "__init__": [
      "self",
      "is_univariate",
      "is_equally_spaced",
      "is_equal_length",
      "is_empty",
      "is_one_series",
      "has_nans",
      "n_instances",
      "n_features",
      "feature_names",
      "dtypekind_dfip",
      "feature_kind"
    ]
  },
  "_PanelMultivEqspl": {
    "_tags": []
  },
  "_PanelMultivEqsplNumpy3D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplNumpyFlat": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplDfList": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplPdMultiindex": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplNestedUniv": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplDaskPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplPolarsPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplGluontsListDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelMultivEqsplGluontsPandasDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqspl": {
    "_tags": []
  },
  "_PanelUnivEqsplNumpy3D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplNumpyFlat": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplDfList": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplPdMultiindex": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplNestedUniv": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplDaskPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplPolarsPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplGluontsListDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplGluontsPandasDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeries": {
    "_tags": []
  },
  "_PanelUnivEqsplOneSeriesNumpy3D": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesNumpyFlat": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesDfList": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesPdMultiindex": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesNestedUniv": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesDaskPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesPolarsPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesGluontsListDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplOneSeriesGluontsPandasDatasetPanel": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_PanelUnivEqsplLossy": {
    "_tags": []
  },
  "_PanelUnivEqsplLossyPdMultiindex": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "VALID_MULTIINDEX_TYPES": [],
  "is_in_valid_multiindex_types": [
    "x"
  ],
  "PanelDfList": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_dflist_panel": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "PanelNp3D": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_numpy3d_panel": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "PanelPdMultiIndex": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_pdmultiindex_panel": [
    "obj",
    "return_metadata",
    "var_name",
    "panel"
  ],
  "_nested_dataframe_has_unequal": [
    "X"
  ],
  "_nested_dataframe_has_nans": [
    "X"
  ],
  "PanelNestedDf": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_is_nested_dataframe": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "PanelNumpyFlat": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_numpyflat_Panel": [
    "obj",
    "return_metadata",
    "var_name"
  ],
  "PanelDask": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "PanelPolarsEager": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_check_polars_panel": [
    "obj",
    "return_metadata",
    "var_name",
    "scitype"
  ],
  "PanelGluontsList": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "PanelGluontsPandas": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "PanelPdWide": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "PanelPdLong": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_concat": [
    "fun1",
    "fun2"
  ],
  "_extend_conversions": [
    "mtype",
    "anchor_mtype",
    "convert_dict",
    "mtype_universe"
  ],
  "_is_nullable_numeric": [
    "dtype"
  ],
  "_coerce_df_dtypes": [
    "obj"
  ],
  "ScitypeAlignment": {
    "_tags": [],
    "__init__": [
      "self",
      "is_multiple"
    ]
  },
  "_AlignmentSimple": {
    "_tags": []
  },
  "_AlignmentSimpleAlignment": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "_AlignmentSimpleAlignmentLoc": {
    "_tags": [],
    "build": [
      "self"
    ]
  },
  "check_align": [
    "align_df",
    "name",
    "index",
    "return_metadata"
  ],
  "AlignmentIloc": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "AlignmentLoc": {
    "_tags": [],
    "_check": [
      "self",
      "obj",
      "return_metadata",
      "var_name"
    ]
  },
  "_path_mask": [
    "cost_matrix",
    "path",
    "ax",
    "theme"
  ],
  "_pairwise_path": [
    "x",
    "y",
    "metric"
  ],
  "_plot_path": [
    "x",
    "y",
    "metric",
    "dist_kwargs",
    "title",
    "plot_over_pw"
  ],
  "_plot_alignment": [
    "x",
    "y",
    "metric",
    "dist_kwargs",
    "title"
  ],
  "set_classifier": [
    "cls",
    "resample_id",
    "train_file"
  ],
  "demo_loading": [],
  "expected_rand_unit_test": [],
  "expected_rand_basic_motions": [],
  "distances": [],
  "time_clusterers": [],
  "debug_clusterers": [],
  "generate_test_results_clusterers": [],
  "difference_test": [],
  "build_classifiers": [],
  "make_toy_2d_problem": [],
  "make_toy_3d_problem": [],
  "compare_classifiers": [],
  "df_columns": [],
  "df": [],
  "config_clusterer": [
    "clusterer"
  ],
  "tune_window": [
    "metric",
    "train_X"
  ],
  "set_clusterer": [
    "cls",
    "resample_id"
  ],
  "ElasticEnsemblePostProcess": {
    "__init__": [
      "self",
      "results_path",
      "dataset_name",
      "distance_measures",
      "resample_id",
      "alpha"
    ],
    "write_files": [
      "self",
      "output_results_path",
      "output_classifier_name",
      "write_train",
      "write_test",
      "overwrite"
    ]
  },
  "TestStats": {
    "__init__": [
      "self",
      "unit_test_acc",
      "multivariate",
      "unequal_length",
      "missing_values"
    ]
  },
  "expected_capabilities": [],
  "plot_dba_example": [],
  "form_cluster_list": [
    "clusters",
    "n"
  ],
  "EditDist": {
    "_tags": [],
    "ALLOWED_DISTANCE_STR": [],
    "__init__": [
      "self",
      "distance",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "epsilon",
      "g",
      "lmbda",
      "nu",
      "p"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SUPPORTED_MTYPES": [],
  "ConstantPwTrafoPanel": {
    "_tags": [],
    "__init__": [
      "self",
      "constant"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_trafo_diag": [
    "fun"
  ],
  "KernelFromDist": {
    "_tags": [],
    "__init__": [
      "self",
      "dist",
      "dist_diag"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DistFromKernel": {
    "_tags": [],
    "__init__": [
      "self",
      "kernel"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PwTrafoPanelPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "pw_trafo",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LuckyDtwDist": {
    "_tags": [],
    "__init__": [
      "self",
      "window"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ScipyDist": {
    "_tags": [],
    "__init__": [
      "self",
      "metric",
      "p",
      "colalign",
      "var_weights",
      "metric_kwargs"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AggrDist": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer",
      "aggfunc",
      "aggfunc_is_symm"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FlatDist": {
    "_tags": [],
    "__init__": [
      "self",
      "transformer"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CombinedDistance": {
    "_tags": [],
    "_steps_attr": [],
    "__init__": [
      "self",
      "pw_trafos",
      "operation"
    ],
    "_resolve_operation": [
      "self",
      "operation"
    ],
    "_pw_trafos": [
      "self",
      "value"
    ],
    "_algebra_dunder_concat": [
      "self",
      "other",
      "operation"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_coerce_to_list_or_tuple": [
    "i"
  ],
  "cumsum_rev_first": [
    "array"
  ],
  "cumsum_rev": [
    "array"
  ],
  "cumsum_mult": [
    "array",
    "dims"
  ],
  "roll_mult": [
    "array",
    "shift",
    "dims"
  ],
  "makeinds": [
    "indlist"
  ],
  "cumsum_shift_mult": [
    "array",
    "dims"
  ],
  "rankreduce": [
    "array",
    "rankbound"
  ],
  "rankreduce_batch": [
    "arrays",
    "rankbound"
  ],
  "sqdist": [
    "X",
    "Y"
  ],
  "k_polynom": [
    "x",
    "y",
    "scale",
    "deg"
  ],
  "k_gauss": [
    "x",
    "y",
    "scale"
  ],
  "k_euclid": [
    "x",
    "y",
    "scale"
  ],
  "k_laplace": [
    "x",
    "y",
    "scale"
  ],
  "k_tanh": [
    "x",
    "y",
    "off",
    "scale"
  ],
  "mirror": [
    "K"
  ],
  "sqize_kernel": [
    "K",
    "L",
    "theta",
    "normalize"
  ],
  "sqize_kernel_ho": [
    "K",
    "L",
    "D",
    "theta",
    "normalize"
  ],
  "LRdec": [],
  "get_low_rank_matrix": [
    "K"
  ],
  "add_low_rank": [
    "K",
    "R"
  ],
  "add_low_rank_one": [
    "U",
    "P"
  ],
  "mult_low_rank": [
    "K",
    "theta"
  ],
  "hadamard_low_rank": [
    "K",
    "R"
  ],
  "hadamard_low_rank_batch": [
    "U",
    "P"
  ],
  "hadamard_low_rank_subsample": [
    "U",
    "P",
    "rho"
  ],
  "cumsum_rev_low_rank": [
    "K"
  ],
  "sum_low_rank": [
    "K"
  ],
  "sqize_kernel_low_rank": [
    "K",
    "L",
    "theta",
    "normalize",
    "rankbound"
  ],
  "sqize_kernel_low_rank_fast": [
    "K",
    "L",
    "theta",
    "normalize",
    "rankbound"
  ],
  "seq_kernel": [
    "X",
    "kernelfun",
    "L",
    "D",
    "theta",
    "normalize",
    "lowrank",
    "rankbound"
  ],
  "seq_kernel_XY": [
    "X",
    "Y",
    "kernelfun",
    "L",
    "D",
    "theta",
    "normalize",
    "lowrank",
    "rankbound"
  ],
  "data_tabulator": [
    "X"
  ],
  "time_series_reshaper": [
    "Xflat",
    "numfeatures",
    "subsample",
    "differences"
  ],
  "SeqKernelizer": {
    "__init__": [
      "self",
      "level",
      "degree",
      "theta",
      "kernel",
      "scale",
      "deg",
      "numfeatures",
      "subsample",
      "differences",
      "normalize",
      "lowrank",
      "rankbound"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "SignatureKernel": {
    "_tags": [],
    "__init__": [
      "self",
      "kernel",
      "level",
      "degree",
      "theta",
      "normalize",
      "lowrank",
      "rankbound"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IndepDist": {
    "_tags": [],
    "__init__": [
      "self",
      "dist",
      "aggfun"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_testfun": [
    "x"
  ],
  "DistFromAligner": {
    "_tags": [],
    "__init__": [
      "self",
      "aligner"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GAKernel": {
    "_tags": [],
    "__init__": [
      "self",
      "sigma",
      "n_jobs",
      "verbose"
    ],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CtwDistTslearn": {
    "_tags": [],
    "__init__": [
      "self",
      "max_iter",
      "n_components",
      "global_constraint",
      "sakoe_chiba_radius",
      "itakura_max_slope",
      "n_jobs",
      "verbose"
    ],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LcssTslearn": {
    "_tags": [],
    "_is_cdist": [],
    "__init__": [
      "self",
      "eps",
      "global_constraint",
      "sakoe_chiba_radius",
      "itakura_max_slope"
    ],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DtwPythonDist": {
    "_tags": [],
    "__init__": [
      "self",
      "dist",
      "step_pattern",
      "window_type",
      "open_begin",
      "open_end"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DtwDtaidistUniv": {
    "_tags": [],
    "__init__": [
      "self",
      "use_c",
      "window",
      "max_dist",
      "max_step",
      "max_length_diff",
      "penalty",
      "psi",
      "use_pruning"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DtwDtaidistMultiv": {
    "_tags": [],
    "__init__": [
      "self",
      "use_c",
      "window",
      "max_dist",
      "max_step",
      "max_length_diff",
      "penalty",
      "psi",
      "use_pruning"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DtwDist": {
    "_tags": [],
    "__init__": [
      "self",
      "weighted",
      "derivative",
      "window",
      "itakura_max_slope",
      "bounding_matrix",
      "g"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DtwDistTslearn": {
    "_tags": [],
    "__init__": [
      "self",
      "global_constraint",
      "sakoe_chiba_radius",
      "itakura_max_slope",
      "n_jobs",
      "verbose"
    ],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SoftDtwDistTslearn": {
    "_tags": [],
    "_inner_params": [],
    "__init__": [
      "self",
      "normalized",
      "gamma"
    ],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TransformerPairwiseFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllPairwiseTransformers": {
    "test_pairwise_transformers_tabular": [
      "self",
      "estimator_instance",
      "scenario"
    ]
  },
  "TransformerPairwisePanelFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllPanelTransformers": {
    "test_pairwise_transformers_panel": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_transform_diag": [
      "self",
      "estimator_instance",
      "scenario"
    ]
  },
  "pw_trafo_tab": [],
  "AGGFUNCS": [],
  "X1_X2": [
    "request"
  ],
  "test_aggr": [
    "X1_X2",
    "pw_trafo_tab",
    "aggfunc"
  ],
  "X1": [],
  "X2": [],
  "test_mul_algebra_dunder": [
    "X1",
    "X2"
  ],
  "test_add_algebra_dunder": [
    "X1",
    "X2"
  ],
  "test_mixed_algebra_dunders": [
    "X1",
    "X2"
  ],
  "test_pw_trafo_pipeline_mul_dunder": [
    "X1",
    "X2"
  ],
  "test_dunders_with_constants": [
    "constant",
    "X1",
    "X2"
  ],
  "test_getitem_dunder": [
    "X1",
    "X2"
  ],
  "X1_df": [],
  "X2_df": [],
  "_get_kul_name": [],
  "METRIC_VALUES": [],
  "P_VALUES": [],
  "COLALIGN_VALUES": [],
  "test_scipydist": [
    "X1",
    "X2",
    "X1_df",
    "X2_df"
  ],
  "_run_scipy_dist_test": [
    "x",
    "y"
  ],
  "BasePairwiseTransformer": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "X2"
    ],
    "transform": [
      "self",
      "X",
      "X2"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "fit": [
      "self",
      "X",
      "X2"
    ],
    "_pairwise_table_x_check": [
      "self",
      "X",
      "var_name"
    ]
  },
  "BasePairwiseTransformerPanel": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "X2"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "transform": [
      "self",
      "X",
      "X2"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ],
    "transform_diag": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "X2"
    ],
    "_pairwise_panel_x_check": [
      "self",
      "X",
      "var_name"
    ]
  },
  "_DelegatedPairwiseTransformerPanel": {
    "_delegate_name": [],
    "_get_delegate": [
      "self"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ]
  },
  "_SklearnDistanceAdapter": {
    "__init__": [
      "self",
      "distance",
      "distance_params",
      "n_vars",
      "is_equal_length"
    ],
    "__call__": [
      "self",
      "x",
      "y"
    ],
    "_distance": [
      "self",
      "X",
      "X2"
    ],
    "_one_element_distance_npdist": [
      "self",
      "x",
      "y",
      "n_vars"
    ],
    "_one_element_distance_sktime_dist": [
      "self",
      "x",
      "y",
      "n_vars"
    ],
    "_convert_X_to_sklearn": [
      "self",
      "X"
    ]
  },
  "_subset_dict": [
    "d",
    "keys"
  ],
  "_TslearnPwTrafoAdapter": {
    "_tags": [],
    "_inner_params": [],
    "_is_cdist": [],
    "_get_tslearn_pwtrafo": [
      "self"
    ],
    "_eval_tslearn_pwtrafo": [
      "self",
      "X",
      "X2"
    ],
    "_coerce_df_list_to_list_of_arr": [
      "self",
      "X"
    ],
    "_eval_tslearn_pwtrafo_vectorized": [
      "self",
      "X",
      "X2"
    ],
    "_transform": [
      "self",
      "X",
      "X2"
    ]
  },
  "ReconcilerForecaster": {
    "_tags": [],
    "TRFORM_METHOD_MAP": [],
    "METHOD_LIST": [],
    "RETURN_TOTALS_LIST": [],
    "__init__": [
      "self",
      "forecaster",
      "method",
      "return_totals",
      "alpha"
    ],
    "_add_totals": [
      "self",
      "y"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_requires_residuals": [
      "self"
    ],
    "_get_error_covariance_matrix": [
      "self",
      "shrink",
      "diag_only"
    ],
    "_check_method": [
      "self"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "ConvTimeNetForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "context_window",
      "patch_ks",
      "patch_sd",
      "dw_ks",
      "d_model",
      "d_ff",
      "norm",
      "dropout",
      "act",
      "head_dropout",
      "padding_patch",
      "revin",
      "affine",
      "subtract_last",
      "deformable",
      "enable_res_param",
      "re_param",
      "re_param_kernel",
      "num_epochs",
      "batch_size",
      "criterion_kwargs",
      "criterion",
      "optimizer",
      "optimizer_kwargs",
      "lr",
      "device",
      "random_state"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "build_pytorch_train_dataloader": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Dataset": [],
  "ESRNNTrainDataset": {
    "__init__": [
      "self",
      "y",
      "pred_len",
      "window",
      "stride"
    ],
    "_get_data": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "ESRNNPredDataset": {
    "__init__": [
      "self",
      "y",
      "window"
    ],
    "_get_data": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "ESRNNForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "hidden_size",
      "num_layer",
      "season1_length",
      "season2_length",
      "seasonality_type",
      "window",
      "stride",
      "batch_size",
      "num_epochs",
      "criterion",
      "optimizer",
      "lr",
      "optimizer_kwargs",
      "criterion_kwargs",
      "custom_dataset_train",
      "custom_dataset_pred"
    ],
    "_instantiate_criterion": [
      "self"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "build_pytorch_train_dataloader": [
      "self",
      "y"
    ],
    "build_pytorch_pred_dataloader": [
      "self",
      "y",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimesFMForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "context_len",
      "horizon_len",
      "freq",
      "repo_id",
      "input_patch_len",
      "output_patch_len",
      "num_layers",
      "model_dims",
      "per_core_batch_size",
      "backend",
      "verbose",
      "broadcasting",
      "use_source_package",
      "ignore_deps"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_timesfm_kwargs": [
      "self"
    ],
    "_get_unique_timesfm_key": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_same_index": [
    "data"
  ],
  "_frame2numpy": [
    "data"
  ],
  "_CachedTimesFM": {
    "__init__": [
      "self",
      "key",
      "timesfm_kwargs",
      "use_source_package",
      "repo_id"
    ],
    "load_from_checkpoint": [
      "self"
    ]
  },
  "Prophetverse": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "trend",
      "exogenous_effects",
      "default_effect",
      "feature_transformer",
      "noise_scale",
      "likelihood",
      "scale",
      "rng_key",
      "inference_engine",
      "broadcast_mode"
    ]
  },
  "HierarchicalProphet": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "trend",
      "feature_transformer",
      "exogenous_effects",
      "default_effect",
      "shared_features",
      "noise_scale",
      "correlation_matrix_concentration",
      "rng_key",
      "inference_engine",
      "likelihood"
    ]
  },
  "_tirex_cache_key": [
    "model",
    "device"
  ],
  "_cached_TiRex": {
    "__init__": [
      "self",
      "key",
      "model",
      "device"
    ],
    "load": [
      "self"
    ]
  },
  "TiRexForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "model",
      "device",
      "license_accepted"
    ],
    "print_license": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TinyTimeMixerForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "model_path",
      "revision",
      "validation_split",
      "config",
      "training_args",
      "compute_metrics",
      "callbacks",
      "broadcasting",
      "use_source_package",
      "fit_strategy"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_pad_truncate": [
    "data",
    "seq_len",
    "pad_value"
  ],
  "PyTorchDataset": {
    "__init__": [
      "self",
      "y",
      "context_length",
      "prediction_length",
      "X"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "ConformalIntervals": {
    "_tags": [],
    "ALLOWED_METHODS": [],
    "__init__": [
      "self",
      "forecaster",
      "method",
      "initial_window",
      "sample_frac",
      "verbose",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_interval_series": [
      "self",
      "fh",
      "coverage",
      "y_pred"
    ],
    "_parse_initial_window": [
      "self",
      "y",
      "initial_window"
    ],
    "_compute_sliding_residuals": [
      "self",
      "y",
      "X",
      "forecaster",
      "initial_window",
      "sample_frac",
      "update"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TotoForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seed",
      "num_samples",
      "samples_per_batch",
      "prediction_type",
      "scale_factor_exponent",
      "stabilize_with_global",
      "use_memory_efficient_attention",
      "model_path",
      "device"
    ],
    "_get_toto_key": [
      "self"
    ],
    "_get_toto_kwargs": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_CachedTotoForecaster": {
    "__init__": [
      "self",
      "key",
      "toto_kwargs",
      "device"
    ],
    "load_from_checkpoint": [
      "self"
    ]
  },
  "ForecastKnownValues": {
    "_tags": [],
    "__init__": [
      "self",
      "y_known",
      "method",
      "fill_value",
      "limit"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AutoTS": {
    "_tags": [],
    "__init__": [
      "self",
      "model_name",
      "model_list",
      "frequency",
      "prediction_interval",
      "max_generations",
      "no_negatives",
      "constraint",
      "ensemble",
      "initial_template",
      "random_seed",
      "holiday_country",
      "subset",
      "aggfunc",
      "na_tolerance",
      "metric_weighting",
      "drop_most_recent",
      "drop_data_older_than_periods",
      "transformer_list",
      "transformer_max_depth",
      "models_mode",
      "num_validations",
      "models_to_validate",
      "max_per_model_class",
      "validation_method",
      "min_allowed_train_percent",
      "remove_leading_zeroes",
      "prefill_na",
      "introduce_na",
      "preclean",
      "model_interrupt",
      "generation_timeout",
      "current_model_file",
      "verbose",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_convert_input_to_date": [
      "self",
      "y"
    ],
    "_convert_int_to_date": [
      "self",
      "y"
    ],
    "_get_forecast_length": [
      "self"
    ],
    "_fh_cutoff_transformation": [
      "self",
      "cutoff"
    ]
  },
  "LTSFLinearForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LTSFDLinearForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LTSFNLinearForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LTSFTransformerForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "context_len",
      "pred_len"
    ],
    "build_pytorch_train_dataloader": [
      "self",
      "y"
    ],
    "build_pytorch_pred_dataloader": [
      "self",
      "y",
      "fh"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SCINetForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "UnobservedComponents": {
    "_tags": [],
    "__init__": [
      "self",
      "level",
      "trend",
      "seasonal",
      "freq_seasonal",
      "cycle",
      "autoregressive",
      "irregular",
      "stochastic_level",
      "stochastic_trend",
      "stochastic_seasonal",
      "stochastic_freq_seasonal",
      "stochastic_cycle",
      "damped_cycle",
      "cycle_period_bounds",
      "mle_regression",
      "use_exact_diffuse",
      "start_params",
      "transformed",
      "includes_fixed",
      "cov_type",
      "cov_kwds",
      "method",
      "maxiter",
      "full_output",
      "disp",
      "callback",
      "return_params",
      "optim_score",
      "optim_complex_step",
      "optim_hessian",
      "flags",
      "low_memory",
      "random_state"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_extract_conf_int": [
      "prediction_results",
      "alpha"
    ],
    "summary": [
      "self"
    ],
    "simulate": [
      "self",
      "nsimulations",
      "X",
      "measurement_shocks",
      "state_shocks",
      "initial_state",
      "anchor",
      "repetitions"
    ],
    "plot_diagnostics": [
      "self",
      "variable",
      "lags",
      "fig",
      "figsize",
      "truncate_endog_names"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DynamicFactor": {
    "_tags": [],
    "__init__": [
      "self",
      "k_factors",
      "factor_order",
      "error_cov_type",
      "error_order",
      "error_var",
      "enforce_stationarity",
      "start_params",
      "transformed",
      "includes_fixed",
      "cov_type",
      "cov_kwds",
      "method",
      "maxiter",
      "full_output",
      "disp",
      "callback",
      "return_params",
      "optim_score",
      "optim_complex_step",
      "optim_hessian",
      "flags",
      "low_memory"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "summary": [
      "self"
    ],
    "simulate": [
      "self",
      "nsimulations",
      "measurement_shocks",
      "state_shocks",
      "initial_state",
      "anchor",
      "repetitions",
      "X",
      "extend_model",
      "extend_kwargs",
      "transformed",
      "includes_fixed"
    ],
    "plot_diagnostics": [
      "self",
      "variable",
      "lags",
      "fig",
      "figsize",
      "truncate_endog_names",
      "auto_ylims",
      "bartlett_confint",
      "acf_kwargs"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "VAR": {
    "_fitted_param_names": [],
    "_tags": [],
    "__init__": [
      "self",
      "maxlags",
      "method",
      "verbose",
      "trend",
      "missing",
      "dates",
      "freq",
      "ic",
      "random_state"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Prophet": {
    "__init__": [
      "self",
      "freq",
      "add_seasonality",
      "add_country_holidays",
      "growth",
      "growth_floor",
      "growth_cap",
      "changepoints",
      "n_changepoints",
      "changepoint_range",
      "yearly_seasonality",
      "weekly_seasonality",
      "daily_seasonality",
      "holidays",
      "seasonality_mode",
      "seasonality_prior_scale",
      "holidays_prior_scale",
      "changepoint_prior_scale",
      "mcmc_samples",
      "alpha",
      "uncertainty_samples",
      "stan_backend",
      "verbose",
      "fit_kwargs"
    ],
    "_instantiate_model": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "EnbPIForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "bootstrap_transformer",
      "random_state",
      "aggregation_function"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "fh"
    ],
    "_predict": [
      "self",
      "X",
      "fh"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "StatsForecastAutoARIMA": {
    "_tags": [],
    "__init__": [
      "self",
      "start_p",
      "d",
      "start_q",
      "max_p",
      "max_d",
      "max_q",
      "start_P",
      "D",
      "start_Q",
      "max_P",
      "max_D",
      "max_Q",
      "max_order",
      "sp",
      "seasonal",
      "stationary",
      "information_criterion",
      "test",
      "seasonal_test",
      "stepwise",
      "n_jobs",
      "trend",
      "method",
      "offset_test_args",
      "seasonal_test_args",
      "trace",
      "n_fits",
      "with_intercept",
      "approximation",
      "truncate",
      "blambda",
      "biasadj",
      "parallel"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastAutoTheta": {
    "_tags": [],
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "model"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastAutoETS": {
    "_tags": [],
    "__init__": [
      "self",
      "season_length",
      "model",
      "damped",
      "phi"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastAutoCES": {
    "_tags": [],
    "__init__": [
      "self",
      "season_length",
      "model"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastAutoTBATS": {
    "_tags": [],
    "__init__": [
      "self",
      "seasonal_periods",
      "use_boxcox",
      "use_trend",
      "use_damped_trend",
      "use_arma_errors",
      "bc_lower_bound",
      "bc_upper_bound"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastMSTL": {
    "_tags": [],
    "__init__": [
      "self",
      "season_length",
      "trend_forecaster",
      "stl_kwargs",
      "pred_int_kwargs"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "_calculate_fh_for_MSTL": [
      "self",
      "fh",
      "y"
    ],
    "_set_fh_to_trend_forecaster": [
      "self",
      "fh",
      "y"
    ],
    "check_fh": [
      "self",
      "fh"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastADIDA": {
    "_tags": [],
    "__init__": [
      "self",
      "prediction_intervals"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ChronosModelStrategy": {
    "initialize_config": [
      "self"
    ],
    "create_pipeline": [
      "self",
      "key",
      "kwargs",
      "use_source_package"
    ],
    "predict": [
      "self",
      "pipeline",
      "y_tensor",
      "predictions_length",
      "config"
    ]
  },
  "ChronosDefaultStrategy": {
    "initialize_config": [
      "self"
    ],
    "create_pipeline": [
      "self",
      "key",
      "kwargs",
      "use_source_package"
    ],
    "predict": [
      "self",
      "pipeline",
      "y_tensor",
      "prediction_length",
      "config"
    ]
  },
  "ChronosBoltStrategy": {
    "initialize_config": [
      "self"
    ],
    "create_pipeline": [
      "self",
      "key",
      "kwargs",
      "use_source_package"
    ],
    "predict": [
      "self",
      "pipeline",
      "y_tensor",
      "prediction_length",
      "config"
    ]
  },
  "ChronosForecaster": {
    "_tags": [],
    "_default_chronos_config": [],
    "_default_chronos_bolt_config": [],
    "__init__": [
      "self",
      "model_path",
      "config",
      "seed",
      "use_source_package",
      "ignore_deps"
    ],
    "_initialize_model_type": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_chronos_kwargs": [
      "self"
    ],
    "_get_unique_chronos_key": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "_ensure_model_pipeline_loaded": [
      "self"
    ],
    "_load_pipeline": [
      "self"
    ],
    "predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "fh",
      "y",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_CachedChronos": {
    "__init__": [
      "self",
      "key",
      "chronos_kwargs",
      "use_source_package"
    ],
    "load_from_checkpoint": [
      "self"
    ]
  },
  "_CachedChronosBolt": {
    "__init__": [
      "self",
      "key",
      "chronos_bolt_kwargs",
      "use_source_package"
    ],
    "load_from_checkpoint": [
      "self"
    ]
  },
  "ExponentialSmoothing": {
    "_tags": [],
    "_fitted_param_names": [],
    "__init__": [
      "self",
      "trend",
      "damped_trend",
      "seasonal",
      "sp",
      "initial_level",
      "initial_trend",
      "initial_seasonal",
      "use_boxcox",
      "initialization_method",
      "smoothing_level",
      "smoothing_trend",
      "smoothing_seasonal",
      "damping_trend",
      "optimized",
      "remove_bias",
      "start_params",
      "method",
      "minimize_kwargs",
      "use_brute",
      "random_state"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PytorchForecastingTFT": {
    "_tags": [],
    "__init__": [
      "self",
      "model_params",
      "allowed_encoder_known_variable_names",
      "dataset_params",
      "train_to_dataloader_params",
      "validation_to_dataloader_params",
      "trainer_params",
      "model_path",
      "random_log_path",
      "broadcasting"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PytorchForecastingNBeats": {
    "_tags": [],
    "__init__": [
      "self",
      "model_params",
      "dataset_params",
      "train_to_dataloader_params",
      "validation_to_dataloader_params",
      "trainer_params",
      "model_path",
      "random_log_path",
      "broadcasting"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "_implementation_counts": [
      "cls"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PytorchForecastingDeepAR": {
    "_tags": [],
    "__init__": [
      "self",
      "model_params",
      "allowed_encoder_known_variable_names",
      "dataset_params",
      "train_to_dataloader_params",
      "validation_to_dataloader_params",
      "trainer_params",
      "model_path",
      "deterministic",
      "random_log_path",
      "broadcasting"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PytorchForecastingNHiTS": {
    "_tags": [],
    "__init__": [
      "self",
      "model_params",
      "dataset_params",
      "train_to_dataloader_params",
      "validation_to_dataloader_params",
      "trainer_params",
      "model_path",
      "random_log_path",
      "broadcasting"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MOIRAIForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "checkpoint_path",
      "context_length",
      "patch_size",
      "num_samples",
      "num_feat_dynamic_real",
      "num_past_feat_dynamic_real",
      "map_location",
      "target_dim",
      "broadcasting",
      "deterministic",
      "batch_size",
      "use_source_package"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "y",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_get_prediction_df": [
      "self",
      "forecast_iter",
      "df_config"
    ],
    "create_pandas_dataset": [
      "self",
      "df",
      "target",
      "dynamic_features",
      "forecast_horizon"
    ],
    "infer_freq": [
      "self",
      "index"
    ],
    "return_time_index": [
      "self",
      "df"
    ],
    "check_range_index": [
      "self",
      "df"
    ],
    "check_period_index": [
      "self",
      "df"
    ],
    "handle_range_index": [
      "self",
      "index"
    ],
    "_series_to_df": [
      "self",
      "y"
    ],
    "_convert_hierarchical_to_panel": [
      "self",
      "df"
    ],
    "_convert_panel_to_hierarchical": [
      "self",
      "df",
      "original_index_names"
    ],
    "_get_future_length": [
      "self",
      "X"
    ]
  },
  "VECM": {
    "_tags": [],
    "__init__": [
      "self",
      "dates",
      "freq",
      "missing",
      "k_ar_diff",
      "coint_rank",
      "deterministic",
      "seasons",
      "first_season",
      "method",
      "exog_coint",
      "exog_coint_fc"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "empty_cache": [],
  "MomentFMForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "pretrained_model_name_or_path",
      "freeze_encoder",
      "freeze_embedder",
      "freeze_head",
      "dropout",
      "head_dropout",
      "seq_len",
      "batch_size",
      "eval_batch_size",
      "epochs",
      "max_lr",
      "device",
      "pct_start",
      "max_norm",
      "train_val_split",
      "transformer_backbone",
      "criterion",
      "config",
      "return_model_to_cpu"
    ],
    "_fit": [
      "self",
      "fh",
      "y",
      "X"
    ],
    "_predict": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_create_padding": [
    "x",
    "pad_shape"
  ],
  "_create_mask": [
    "ones_length",
    "zeros_length"
  ],
  "_run_epoch": [
    "cur_epoch",
    "accelerator",
    "criterion",
    "optimizer",
    "scheduler",
    "model",
    "max_norm",
    "train_dataloader",
    "val_dataloader"
  ],
  "_check_device": [
    "device"
  ],
  "MomentPytorchDataset": {
    "__init__": [
      "self",
      "y",
      "fh",
      "seq_len",
      "device"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "BoxCoxBiasAdjustedForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "lambda_fixed"
    ],
    "_get_delegate": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_apply_bias_adjustment": [
      "self",
      "y",
      "variance"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_all_": [],
  "ARDL": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "order",
      "fixed",
      "causal",
      "trend",
      "seasonal",
      "deterministic",
      "hold_back",
      "period",
      "missing",
      "cov_type",
      "cov_kwds",
      "use_t",
      "auto_ardl",
      "maxlag",
      "maxorder",
      "ic",
      "glob",
      "fixed_oos",
      "X_oos",
      "dynamic"
    ],
    "check_param_validity": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "summary": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MAPAForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "aggregation_levels",
      "base_forecaster",
      "agg_method",
      "decompose_type",
      "forecast_combine",
      "imputation_method",
      "sp",
      "weights"
    ],
    "_initialize_base_forecaster": [
      "self",
      "base_forecaster"
    ],
    "_handle_missing_data": [
      "self",
      "y"
    ],
    "_ensure_positive_values": [
      "self",
      "y"
    ],
    "_aggregate": [
      "self",
      "y",
      "level"
    ],
    "_decompose": [
      "self",
      "y",
      "level"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_get_seasonal_pattern": [
      "self",
      "level"
    ],
    "_combine_forecasts": [
      "self",
      "forecasts"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "VARMAX": {
    "_tags": [],
    "__init__": [
      "self",
      "order",
      "trend",
      "error_cov_type",
      "measurement_error",
      "enforce_stationarity",
      "enforce_invertibility",
      "trend_offset",
      "start_params",
      "transformed",
      "includes_fixed",
      "cov_type",
      "cov_kwds",
      "method",
      "maxiter",
      "full_output",
      "disp",
      "callback",
      "return_params",
      "optim_score",
      "optim_complex_step",
      "optim_hessian",
      "flags",
      "low_memory",
      "dynamic",
      "information_set",
      "signal_only",
      "suppress_warnings"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RBFForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "window_length",
      "hidden_size",
      "batch_size",
      "centers",
      "gamma",
      "rbf_type",
      "hidden_layers",
      "optimizer",
      "lr",
      "epochs",
      "stride",
      "criterion",
      "device",
      "mode",
      "activation",
      "dropout_rate"
    ],
    "_get_device": [
      "self",
      "device"
    ],
    "_build_network": [
      "self",
      "input_size"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_create_windows": [
      "self",
      "y"
    ],
    "_instantiate_optimizer": [
      "self"
    ],
    "_instantiate_criterion": [
      "self"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "TimeMoEForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "model_path",
      "config",
      "seed",
      "use_source_package",
      "ignore_deps"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_timemoe_kwargs": [
      "self"
    ],
    "_get_unique_timemoe_key": [
      "self"
    ],
    "_get_default_config": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_default"
    ]
  },
  "_CachedTimeMoE": {
    "__init__": [
      "self",
      "key",
      "timemoe_kwargs",
      "use_source_package"
    ],
    "load_from_checkpoint": [
      "self"
    ]
  },
  "PyKANForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "hidden_layers",
      "input_layer_size",
      "grids",
      "model_params",
      "fit_params",
      "val_size",
      "device"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PyTorchTrainDataset": {
    "__init__": [
      "self",
      "y",
      "seq_len",
      "fh",
      "X"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "AutoETS": {
    "_fitted_param_names": [],
    "_tags": [],
    "__init__": [
      "self",
      "error",
      "trend",
      "damped_trend",
      "seasonal",
      "sp",
      "initialization_method",
      "initial_level",
      "initial_trend",
      "initial_seasonal",
      "bounds",
      "dates",
      "freq",
      "missing",
      "start_params",
      "maxiter",
      "full_output",
      "disp",
      "callback",
      "return_params",
      "auto",
      "information_criterion",
      "allow_multiplicative_trend",
      "restrict",
      "additive_only",
      "ignore_inf_ic",
      "n_jobs",
      "random_state"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_extract_conf_int": [
      "prediction_results",
      "alpha"
    ],
    "summary": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Croston": {
    "_tags": [],
    "__init__": [
      "self",
      "smoothing"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GreykiteForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecast_config",
      "date_format",
      "model_template",
      "coverage"
    ],
    "_create_forecast_config": [
      "self",
      "y"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "VARReduce": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "regressor"
    ],
    "_prepare_for_fit": [
      "self",
      "data",
      "return_as_ndarray"
    ],
    "_prepare_for_predict": [
      "self",
      "data",
      "return_as_ndarray"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SquaringResiduals": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "residual_forecaster",
      "initial_window",
      "strategy",
      "distr",
      "distr_kwargs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AutoREG": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "seasonal",
      "hold_back",
      "period",
      "missing",
      "deterministic",
      "cov_type",
      "cov_kwds",
      "use_t",
      "dynamic"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PatchTSTConfig": [],
  "PatchTSTForPrediction": [],
  "PatchTSTModel": [],
  "Trainer": [],
  "TrainingArguments": [],
  "PatchTSTForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "model_path",
      "fit_strategy",
      "validation_split",
      "config",
      "training_args",
      "compute_metrics",
      "callbacks"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SARIMAX": {
    "_tags": [],
    "__init__": [
      "self",
      "order",
      "seasonal_order",
      "trend",
      "measurement_error",
      "time_varying_regression",
      "mle_regression",
      "simple_differencing",
      "enforce_stationarity",
      "enforce_invertibility",
      "hamilton_representation",
      "concentrate_scale",
      "trend_offset",
      "use_exact_diffuse",
      "dates",
      "freq",
      "missing",
      "validate_specification",
      "disp",
      "random_state",
      "start_params",
      "transformed",
      "includes_fixed",
      "cov_type",
      "cov_kwds",
      "method",
      "maxiter",
      "full_output",
      "callback",
      "return_params",
      "optim_score",
      "optim_complex_step",
      "optim_hessian",
      "low_memory"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "summary": [
      "self"
    ],
    "_extract_conf_int": [
      "prediction_results",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSB": {
    "_tags": [],
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ThetaForecaster": {
    "_fitted_param_names": [],
    "_tags": [],
    "__init__": [
      "self",
      "initial_level",
      "deseasonalize",
      "sp",
      "deseasonalize_model"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_compute_trend": [
      "y"
    ],
    "_compute_drift": [
      "self"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_zscore": [
    "level",
    "two_tailed"
  ],
  "ThetaModularForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "theta_values",
      "aggfunc",
      "weights"
    ],
    "_check_forecasters": [
      "self",
      "forecasters"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "return_pred_int"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TBATS": {
    "_fitted_param_names": [],
    "_create_model_class": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ResidualBoostingForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "base_forecaster",
      "residual_forecaster"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DataLoader": [],
  "default_sine": [
    "x",
    "amplitude",
    "phase",
    "offset",
    "amplitude2",
    "amplitude3",
    "phase2"
  ],
  "CINNForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "n_coupling_layers",
      "hidden_dim_size",
      "sample_dim",
      "batch_size",
      "encoded_cond_size",
      "lr",
      "weight_decay",
      "sp_list",
      "fourier_terms_list",
      "window_size",
      "num_epochs",
      "verbose",
      "f_statistic",
      "init_param_f_statistic",
      "deterministic",
      "lag_feature",
      "patience",
      "delta",
      "val_split"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_build_network": [
      "self",
      "fh"
    ],
    "_run_epoch": [
      "self",
      "epoch",
      "data_loader",
      "val_data_loader_nll",
      "early_stopper"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_prepare_data": [
      "self",
      "yz",
      "X",
      "z"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "save": [
      "self",
      "path",
      "serialization_format"
    ],
    "load_from_serial": [
      "cls",
      "serial"
    ],
    "load_from_path": [
      "cls",
      "path"
    ]
  },
  "_test_function": [
    "x",
    "a",
    "b"
  ],
  "PyTorchCinnTestDataset": {
    "__init__": [
      "self",
      "y",
      "seq_len",
      "fh",
      "X"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "_EarlyStopper": {
    "__init__": [
      "self",
      "patience",
      "min_delta"
    ],
    "early_stop": [
      "self",
      "validation_loss",
      "model"
    ]
  },
  "HFTransformersForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "model_path",
      "fit_strategy",
      "validation_split",
      "config",
      "training_args",
      "compute_metrics",
      "deterministic",
      "callbacks",
      "peft_config"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NeuralForecastRNN": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "input_size",
      "inference_input_size",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_activation",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "scaler_type",
      "random_seed",
      "num_workers_loader",
      "drop_last_loader",
      "trainer_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "broadcasting",
      "lr_scheduler",
      "lr_scheduler_kwargs"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NeuralForecastLSTM": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "input_size",
      "inference_input_size",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "scaler_type",
      "random_seed",
      "num_workers_loader",
      "drop_last_loader",
      "trainer_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "broadcasting",
      "lr_scheduler",
      "lr_scheduler_kwargs"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NeuralForecastGRU": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "input_size",
      "inference_input_size",
      "encoder_n_layers",
      "encoder_hidden_size",
      "encoder_bias",
      "encoder_dropout",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "scaler_type",
      "random_seed",
      "num_workers_loader",
      "drop_last_loader",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "trainer_kwargs",
      "broadcasting"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NeuralForecastDilatedRNN": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "input_size",
      "inference_input_size",
      "cell_type",
      "dilations",
      "encoder_hidden_size",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "step_size",
      "scaler_type",
      "random_seed",
      "num_workers_loader",
      "drop_last_loader",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "broadcasting",
      "trainer_kwargs"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NeuralForecastTCN": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "input_size",
      "inference_input_size",
      "kernel_size",
      "dilations",
      "encoder_hidden_size",
      "encoder_activation",
      "context_size",
      "decoder_hidden_size",
      "decoder_layers",
      "loss",
      "valid_loss",
      "max_steps",
      "learning_rate",
      "num_lr_decays",
      "early_stop_patience_steps",
      "val_check_steps",
      "batch_size",
      "valid_batch_size",
      "scaler_type",
      "random_seed",
      "num_workers_loader",
      "drop_last_loader",
      "optimizer",
      "optimizer_kwargs",
      "lr_scheduler",
      "lr_scheduler_kwargs",
      "trainer_kwargs",
      "broadcasting"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeLLMForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "task_name",
      "pred_len",
      "seq_len",
      "llm_model",
      "llm_layers",
      "llm_dim",
      "patch_len",
      "stride",
      "d_model",
      "d_ff",
      "n_heads",
      "dropout",
      "device",
      "prompt_domain"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_unique_time_llm_key": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_CachedTimeLLM": {
    "__init__": [
      "self",
      "key",
      "time_llm_kwargs"
    ],
    "load_model": [
      "self"
    ]
  },
  "DartsRegressionModel": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "model",
      "multi_models",
      "use_static_covariates",
      "past_covariates",
      "num_samples"
    ],
    "_create_forecaster": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DartsXGBModel": {
    "_tags": [],
    "__init__": [
      "self",
      "past_covariates",
      "num_samples",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "kwargs"
    ],
    "_create_forecaster": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DartsLinearRegressionModel": {
    "_tags": [],
    "__init__": [
      "self",
      "past_covariates",
      "num_samples",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "kwargs"
    ],
    "_create_forecaster": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BATS": {
    "_fitted_param_names": [],
    "_create_model_class": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_PredictionWeightedEnsembler": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "loss_func"
    ],
    "_predict": [
      "self",
      "y_pred"
    ],
    "_modify_weights": [
      "self",
      "new_array"
    ],
    "_update": [
      "self",
      "y_pred",
      "y_true"
    ],
    "_uniform_weights": [
      "self",
      "n_estimators"
    ]
  },
  "HedgeExpertEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "T",
      "a",
      "loss_func"
    ]
  },
  "NormalHedgeEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "a",
      "loss_func"
    ],
    "update": [
      "self",
      "y_pred",
      "y_true",
      "low_c"
    ],
    "_update_weights": [
      "self",
      "low_c"
    ]
  },
  "NNLSEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "loss_func"
    ],
    "update": [
      "self",
      "y_pred",
      "y_true"
    ]
  },
  "OnlineEnsembleForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "ensemble_algorithm",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_fit_ensemble": [
      "self",
      "y",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "cv": [],
  "test_weights_for_airline_averaging": [],
  "test_weights_for_airline_normal_hedge": [],
  "test_weights_for_airline_nnls": [],
  "DoubleMLForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "outcome_fcst",
      "treatment_fcst",
      "residual_fcst",
      "exposure_vars",
      "starting_window"
    ],
    "_update_tags_from_components": [
      "self"
    ],
    "_split_exogenous_data": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_compute_X_exposure_res": [
      "self",
      "X_exposure",
      "X_confounder",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "METHOD_LIST": [],
  "level_list": [],
  "flatten_list": [],
  "test_reconciler_fit_predict": [
    "method",
    "flatten",
    "no_levels"
  ],
  "test_reconcilerforecaster_exog": [
    "n_columns"
  ],
  "test_reconcilerforecaster_return_totals": [
    "method",
    "return_totals"
  ],
  "test_reconcilerforecaster_singular": [
    "alpha"
  ],
  "test_predictive_performance_on_airline": [],
  "test_pred_errors_against_y_test": [
    "fh"
  ],
  "test_forecaster_with_initial_level": [],
  "test_theta_and_thetamodular": [],
  "check_panel_theta_quantiles": [],
  "test_VARMAX_against_statsmodels": [],
  "test_VARMAX_against_statsmodels_with_exog": [],
  "test_against_statsmodels": [],
  "test_against_statsmodels_fit_results": [],
  "test_against_statsmodels_exog": [],
  "INTERVAL_WRAPPERS": [],
  "CV_SPLITTERS": [],
  "EVALUATE_STRATEGY": [],
  "SAMPLE_FRACS": [],
  "test_wrapper_series_mtype": [
    "wrapper",
    "override_y_mtype",
    "mtype"
  ],
  "test_evaluate_with_window_splitters": [
    "wrapper",
    "splitter",
    "strategy",
    "sample_frac"
  ],
  "y_known": [],
  "test_multiindex": [
    "fh",
    "y_known"
  ],
  "test_singleindex": [
    "fh",
    "y_known"
  ],
  "test_neural_forecast_univariate_y_without_X": [
    "model_class"
  ],
  "test_neural_forecast_univariate_y_with_X": [
    "model_class"
  ],
  "test_neural_forecast_multivariate_y_without_X": [
    "model_class"
  ],
  "test_neural_forecast_with_non_default_loss": [
    "model_class"
  ],
  "test_neural_forecast_fail_with_multiple_predictions": [
    "model_class"
  ],
  "test_neural_forecast_with_auto_freq": [
    "model_class"
  ],
  "test_neural_forecast_with_auto_against_given_freq": [
    "model_class",
    "freq"
  ],
  "test_neural_forecast_with_auto_freq_on_valid_index": [
    "index",
    "freq",
    "model_class"
  ],
  "test_neural_forecast_with_auto_freq_on_missing_int_like": [
    "index",
    "model_class"
  ],
  "test_neural_forecast_with_auto_freq_on_missing_date_like": [
    "index",
    "model_class"
  ],
  "TEST_CUTOFFS_INT_LIST": [],
  "TEST_CUTOFFS_INT_ARR": [],
  "TEST_CUTOFFS_TIMESTAMP": [],
  "TEST_CUTOFFS": [],
  "TEST_WINDOW_LENGTHS_INT": [],
  "TEST_WINDOW_LENGTHS_TIMEDELTA": [],
  "TEST_WINDOW_LENGTHS_DATEOFFSET": [],
  "TEST_WINDOW_LENGTHS": [],
  "TEST_INITIAL_WINDOW_INT": [],
  "TEST_INITIAL_WINDOW_TIMEDELTA": [],
  "TEST_INITIAL_WINDOW_DATEOFFSET": [],
  "TEST_INITIAL_WINDOW": [],
  "TEST_STEP_LENGTHS_INT": [],
  "TEST_STEP_LENGTHS_TIMEDELTA": [],
  "TEST_STEP_LENGTHS_DATEOFFSET": [],
  "TEST_STEP_LENGTHS": [],
  "TEST_OOS_FHS": [],
  "TEST_INS_FHS": [],
  "TEST_FHS": [],
  "TEST_OOS_FHS_TIMEDELTA": [],
  "TEST_INS_FHS_TIMEDELTA": [],
  "TEST_FHS_TIMEDELTA": [],
  "TEST_SPS": [],
  "TEST_ALPHAS": [],
  "TEST_YS": [],
  "TEST_RANDOM_SEEDS": [],
  "TEST_N_ITERS": [],
  "VALID_INDEX_FH_COMBINATIONS": [],
  "INDEX_TYPE_LOOKUP": [],
  "test_set_params": [],
  "check_panel_expsmooth": [],
  "check_panel_with_freq": [],
  "test_prophet_nonnative_index": [
    "indextype"
  ],
  "test_prophet_period_fh": [
    "convert_to_datetime"
  ],
  "test_prophet_fit_kwargs_are_passed_down": [
    "fit_kwargs"
  ],
  "test_prophet_added_seasonality_is_not_regressor": [],
  "test_prophet_added_seasonalities_are_not_regressors": [],
  "test_prophet_fitted_params": [
    "constant_timeseries"
  ],
  "ModelSpec": {
    "__init__": [
      "self",
      "level",
      "params"
    ],
    "generate_parametrized_sample_data": [
      "self",
      "n",
      "sigma_zeta",
      "sigma_eta",
      "sigma_epsilon"
    ]
  },
  "level_sample_data": [
    "request"
  ],
  "level_sample_data_split": [
    "level_sample_data"
  ],
  "y_airlines": [],
  "test_results_consistency": [
    "level",
    "fh_length",
    "y_airlines"
  ],
  "test_result_consistency_exog": [
    "level_sample_data_split"
  ],
  "test_prediction_intervals_no_exog": [
    "alpha",
    "coverage",
    "fh_length",
    "y_airlines"
  ],
  "test_prediction_intervals_exog": [
    "alpha",
    "coverage",
    "level_sample_data_split"
  ],
  "test_evaluate_exog": [],
  "test_timesfmforecaster": [],
  "test_load_model_from_disk": [
    "model_class"
  ],
  "test_statsforecast_mstl": [
    "mock_autoets"
  ],
  "test_statsforecast_mstl_with_fh": [
    "request",
    "fh"
  ],
  "test_constant_series_prediction_with_ces": [],
  "test_ARIMA_pred_quantiles_insample": [],
  "FH0": [],
  "WINDOW_FORECASTERS": [],
  "test_last_window": [
    "Forecaster"
  ],
  "test_insample_and_outofsample_forecasting": [],
  "test_SARIMAX_against_statsmodels": [],
  "test_SARIMAX_single_interval_against_statsmodels": [],
  "test_SARIMAX_multiple_intervals_against_statsmodels": [],
  "test_SARIMAX_for_exogeneous_features": [],
  "test_SARIMAX_update_with_exogenous_variables": [],
  "model_kwargs": [],
  "import_mappings": [],
  "test_darts_regression_model_without_X": [
    "model"
  ],
  "_darts_to_series": [
    "obj"
  ],
  "test_darts_regression_models_with_weather_dataset": [
    "model"
  ],
  "test_darts_regression_model_with_X": [
    "model"
  ],
  "test_darts_regression_with_weather_dataset": [
    "model"
  ],
  "test_VECM_against_statsmodels": [],
  "sample_data": [],
  "test_decompose": [
    "sample_data",
    "sp",
    "level",
    "expected_seasonal"
  ],
  "test_combine_forecasts": [
    "combine_method",
    "weights",
    "expected"
  ],
  "test_combine_forecasts_invalid": [],
  "test_aggregate": [
    "level",
    "agg_method",
    "expected"
  ],
  "base_forecaster_params": [],
  "test_predict": [
    "sample_data",
    "forecaster_params"
  ],
  "test_invalid_aggregation_levels": [
    "invalid_level"
  ],
  "HISTORY_LENGTH": [],
  "PREDICTION_LENGTH": [],
  "K_FACTORS": [],
  "FACTOR_ORDER": [],
  "COVERAGES": [],
  "TARGET_COLUMNS": [],
  "FEATURE_COLUMNS": [],
  "ENDOGENOUS_DF": [],
  "EXOGENOUS_DF": [],
  "TRAIN_Y": [],
  "TRAIN_X": [],
  "PREDICT_X": [],
  "compare_predictions_against_statsmodels": [
    "sktime_point_predictions",
    "sktime_interval_predictions",
    "statsmodels_predictions"
  ],
  "test_DynamicFactor_without_exogenous_variables": [],
  "test_DynamicFactor_with_exogenous_variables": [],
  "test_VAR_against_statsmodels": [],
  "test_dummy_est_with_categorical_capability": [],
  "create_mixed_dtype_df": [],
  "test_skforecast_with_categorical": [],
  "test_YfromX_with_categorical": [],
  "test_against_statsmodels_2": [],
  "test_against_statsmodels_3": [],
  "test_against_statsmodels_4": [],
  "test_auto_ardl": [],
  "test_against_statsmodels_5": [],
  "test_TSB": [
    "alpha",
    "beta",
    "fh",
    "expected_forecast"
  ],
  "test_tbats_long_fh": [],
  "index_fh_comb_names": [],
  "pytest_skip_msg": [],
  "ForecasterFixtureGenerator": {
    "estimator_type_filter": [],
    "fixture_sequence": [],
    "_generate_n_columns": [
      "self",
      "test_name"
    ],
    "_generate_update_params": [
      "self",
      "test_name"
    ],
    "_generate_step_length": [
      "self",
      "test_name"
    ]
  },
  "_get_expected_columns": [
    "y_test"
  ],
  "_check_predict_intervals": [
    "pred_ints",
    "y_test",
    "fh",
    "coverage"
  ],
  "_check_predict_quantiles": [
    "pred_quantiles",
    "y_test",
    "fh",
    "alpha"
  ],
  "_check_predict_proba": [
    "pred_dist",
    "y_test",
    "fh_int"
  ],
  "TestAllForecasters": {
    "test_get_fitted_params": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_raises_not_fitted_error": [
      "self",
      "estimator_instance"
    ],
    "test_y_multivariate_raises_error": [
      "self",
      "estimator_instance"
    ],
    "test_y_invalid_type_raises_error": [
      "self",
      "estimator_instance",
      "y"
    ],
    "test_X_invalid_type_raises_error": [
      "self",
      "estimator_instance",
      "n_columns",
      "X"
    ],
    "test_categorical_X_raises_error": [
      "self",
      "estimator_instance"
    ],
    "test_categorical_y_raises_error": [
      "self",
      "estimator_instance"
    ],
    "test_predict_time_index": [
      "self",
      "estimator_instance",
      "n_columns",
      "index_fh_comb",
      "fh_int"
    ],
    "test_predict_time_index_with_X": [
      "self",
      "estimator_instance",
      "n_columns",
      "index_fh_comb",
      "fh_int_oos"
    ],
    "test_predict_time_index_in_sample_full": [
      "self",
      "estimator_instance",
      "n_columns",
      "index_fh_comb"
    ],
    "test_predict_series_name_preserved": [
      "self",
      "estimator_instance"
    ],
    "test_predict_interval": [
      "self",
      "estimator_instance",
      "n_columns",
      "index_type",
      "fh_int_oos",
      "coverage"
    ],
    "test_predict_quantiles": [
      "self",
      "estimator_instance",
      "n_columns",
      "fh_int_oos",
      "alpha"
    ],
    "test_predict_proba": [
      "self",
      "estimator_instance",
      "n_columns",
      "fh_int_oos"
    ],
    "test_pred_int_tag": [
      "self",
      "estimator_instance"
    ],
    "test_score": [
      "self",
      "estimator_instance",
      "n_columns",
      "fh_int_oos"
    ],
    "test_update_predict_single": [
      "self",
      "estimator_instance",
      "n_columns",
      "fh_int_oos",
      "update_params"
    ],
    "test_update_predict_predicted_index": [
      "self",
      "estimator_instance",
      "n_columns",
      "fh_int_oos",
      "step_length",
      "initial_window",
      "update_params"
    ],
    "test__y_and_cutoff": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_update_with_exogenous_variables": [
      "self",
      "estimator_instance",
      "n_columns",
      "update_params"
    ],
    "test__y_when_refitting": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_fh_attribute": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_fh_not_passed_error_handling": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_different_fh_in_fit_and_predict_error_handling": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_hierarchical_with_exogeneous": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_fit_predict": [
      "self",
      "estimator_instance",
      "n_columns"
    ]
  },
  "TestAllGlobalForecasters": {
    "estimator_type_filter": [],
    "test_global_forecasting_tag": [
      "self",
      "estimator_class"
    ],
    "test_pridect_signature": [
      "self",
      "estimator_class"
    ],
    "_check_global_tag": [
      "self",
      "estimator_instance"
    ],
    "test_global_forecasting_multiindex_hier": [
      "self",
      "estimator_instance"
    ],
    "test_global_forecasting_multiindex": [
      "self",
      "estimator_instance"
    ],
    "test_global_forecasting_series": [
      "self",
      "estimator_instance",
      "n_columns"
    ],
    "test_global_forecasting_hier_series": [
      "self",
      "estimator_instance"
    ],
    "test_global_forecasting_different_timestamps": [
      "self",
      "estimator_instance"
    ],
    "test_global_forecasting_no_X": [
      "self",
      "estimator_instance"
    ],
    "test_global_predict_interval": [
      "self",
      "estimator_instance",
      "index_type",
      "fh_int_oos",
      "coverage"
    ],
    "test_global_predict_quantiles": [
      "self",
      "estimator_instance",
      "fh_int_oos",
      "alpha"
    ],
    "test_global_predict_proba": [
      "self",
      "estimator_instance",
      "fh_int_oos"
    ],
    "_remove_last_n": [
      "self",
      "data",
      "n"
    ],
    "_multiindex_data": [
      "self",
      "max_prediction_length",
      "data_length"
    ],
    "_multiindex_hier_data": [
      "self",
      "max_prediction_length",
      "data_length"
    ],
    "_check_consistency": [
      "self",
      "y_test",
      "y_pred"
    ]
  },
  "test_ARCH_against_arch_model": [],
  "test_ARCH_insample": [],
  "test_arar_forecaster_simple": [],
  "test_arar_forecaster_with_params": [],
  "test_arar_forecaster_prediction_intervals": [],
  "test_arar_forecaster_quantiles": [],
  "test_arar_forecaster_short_series": [],
  "test_arar_forecaster_airline_data": [],
  "n_timepoints": [],
  "n_train": [],
  "s": [],
  "y_train": [],
  "y_test": [],
  "test_strategy_last": [
    "fh"
  ],
  "test_strategy_mean": [
    "fh",
    "window_length"
  ],
  "test_strategy_last_seasonal": [
    "fh",
    "sp"
  ],
  "test_strategy_mean_seasonal": [
    "fh",
    "sp",
    "window_length"
  ],
  "test_strategy_mean_seasonal_simple": [
    "n_seasons",
    "sp"
  ],
  "test_strategy_drift_unit_slope": [
    "fh",
    "window_length"
  ],
  "test_strategy_drift_flat_line": [
    "fh",
    "window_length"
  ],
  "test_strategy_drift_window_length": [
    "fh",
    "window_length"
  ],
  "test_strategy_mean_and_last_seasonal_additional_combinations": [
    "n",
    "window_length",
    "sp",
    "strategy"
  ],
  "test_naive_predict_var_backwards": [
    "strategy",
    "sp",
    "window_length",
    "n_periods"
  ],
  "test_naive_predict_interval_mean": [
    "strategy",
    "sp",
    "window_length",
    "fh"
  ],
  "test_naive_predict_interval_against_R_naive": [
    "strategy",
    "sp",
    "lower",
    "upper"
  ],
  "test_naive_sp_greater_1_not_nan": [
    "freq"
  ],
  "test_insample_with_numpy_input": [],
  "test_conformal_standard": [],
  "test_conformal_with_gscv": [],
  "test_conformal_with_hierarchical": [],
  "test_initialized_model": [],
  "inf_ic_ts": [],
  "test_airline_default": [],
  "test_airline_allow_multiplicative_trend": [],
  "test_inf_ic_true": [],
  "test_inf_ic_false": [],
  "test_Croston_against_r_implementation": [
    "smoothing",
    "fh",
    "r_forecast"
  ],
  "NaiveForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "strategy",
      "window_length",
      "sp"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X",
      "return_pred_int",
      "alpha"
    ],
    "_reshape_last_window_for_sp": [
      "self",
      "last_window"
    ],
    "_tile_seasonal_prediction": [
      "self",
      "y_pred",
      "fh"
    ],
    "_predict_naive": [
      "self",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NaiveVariance": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "initial_window",
      "verbose"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_compute_sliding_residuals": [
      "self",
      "y",
      "X",
      "forecaster",
      "initial_window"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_setup_params": [
    "y_in",
    "max_ar_depth",
    "max_lag"
  ],
  "_fit_arar": [
    "y_in",
    "max_ar_depth",
    "max_lag",
    "safe"
  ],
  "_forecast_arar": [
    "model_tuple",
    "h",
    "level"
  ],
  "ARARForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "max_ar_depth",
      "max_lag",
      "safe"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsModelsARIMA": {
    "_tags": [],
    "__init__": [
      "self",
      "order",
      "seasonal_order",
      "trend",
      "enforce_stationarity",
      "enforce_invertibility",
      "concentrate_scale",
      "trend_offset",
      "dates",
      "freq",
      "missing",
      "validate_specification",
      "start_params",
      "transformed",
      "includes_fixed",
      "method",
      "method_kwargs",
      "gls",
      "gls_kwargs",
      "cov_type",
      "cov_kwds",
      "return_params",
      "low_memory"
    ],
    "_fit_forecaster": [
      "self",
      "y",
      "X"
    ],
    "summary": [
      "self"
    ],
    "_extract_conf_int": [
      "prediction_results",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AutoARIMA": {
    "_tags": [],
    "SARIMAX_KWARGS_KEYS": [],
    "__init__": [
      "self",
      "start_p",
      "d",
      "start_q",
      "max_p",
      "max_d",
      "max_q",
      "start_P",
      "D",
      "start_Q",
      "max_P",
      "max_D",
      "max_Q",
      "max_order",
      "sp",
      "seasonal",
      "stationary",
      "information_criterion",
      "alpha",
      "test",
      "seasonal_test",
      "stepwise",
      "n_jobs",
      "start_params",
      "trend",
      "method",
      "maxiter",
      "offset_test_args",
      "seasonal_test_args",
      "suppress_warnings",
      "error_action",
      "trace",
      "random",
      "random_state",
      "n_fits",
      "out_of_sample_size",
      "scoring",
      "scoring_args",
      "with_intercept",
      "update_pdq",
      "time_varying_regression",
      "enforce_stationarity",
      "enforce_invertibility",
      "simple_differencing",
      "measurement_error",
      "mle_regression",
      "hamilton_representation",
      "concentrate_scale"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ARIMA": {
    "_tags": [],
    "SARIMAX_KWARGS_KEYS": [],
    "__init__": [
      "self",
      "order",
      "seasonal_order",
      "start_params",
      "method",
      "maxiter",
      "suppress_warnings",
      "out_of_sample_size",
      "scoring",
      "scoring_args",
      "trend",
      "with_intercept",
      "time_varying_regression",
      "enforce_stationarity",
      "enforce_invertibility",
      "simple_differencing",
      "measurement_error",
      "mle_regression",
      "hamilton_representation",
      "concentrate_scale"
    ],
    "_instantiate_model": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_Pipeline": {
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "_get_forecaster_index": [
      "self",
      "estimators"
    ],
    "_check_steps": [
      "self",
      "estimators",
      "allow_postproc"
    ],
    "_iter_transformers": [
      "self",
      "reverse",
      "fc_idx"
    ],
    "__len__": [
      "self"
    ],
    "_get_inverse_transform": [
      "self",
      "transformers",
      "y",
      "X",
      "mode"
    ],
    "named_steps": [
      "self"
    ],
    "_steps": [
      "self",
      "value"
    ],
    "_components": [
      "self",
      "base_class"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ForecastingPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "steps"
    ],
    "forecaster_": [
      "self"
    ],
    "__rpow__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TransformedTargetForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "steps"
    ],
    "forecaster_": [
      "self"
    ],
    "transformers_pre_": [
      "self"
    ],
    "transformers_post_": [
      "self"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "transform": [
      "self",
      "Z",
      "X"
    ],
    "inverse_transform": [
      "self",
      "Z",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ]
  },
  "ForecastX": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster_y",
      "forecaster_X",
      "fh_X",
      "behaviour",
      "columns",
      "fit_behaviour",
      "forecaster_X_exogeneous",
      "predict_behaviour"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_Xcols": [
      "self",
      "X"
    ],
    "_check_unknown_exog": [
      "self",
      "X"
    ],
    "_get_forecaster_X_prediction": [
      "self",
      "X",
      "fh",
      "method"
    ],
    "_get_X_for_fcX": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "Permute": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "estimator",
      "permutation",
      "steps_arg"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "_set_permuted_estimator": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_check_nan_policy_option": [
    "nan_predict_policy"
  ],
  "FallbackForecaster": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "forecasters",
      "verbose",
      "nan_predict_policy"
    ],
    "_validate_y_pred": [
      "self",
      "y_pred"
    ],
    "_get_delegate": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_try_fit_forecasters": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "HierarchyEnsembleForecaster": {
    "_tags": [],
    "BY_LIST": [],
    "_steps_attr": [],
    "__init__": [
      "self",
      "forecasters",
      "by",
      "default",
      "backend",
      "backend_params"
    ],
    "_forecasters": [
      "self",
      "value"
    ],
    "_aggregate": [
      "self",
      "y"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_hier_dict": [
      "self",
      "z"
    ],
    "_get_node_dict": [
      "self",
      "z"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_check_forecasters": [
      "self",
      "y",
      "z"
    ],
    "_ensure_clone": [
      "self",
      "forecasters"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_level_fit": [
    "params",
    "meta"
  ],
  "_node_fit": [
    "params",
    "meta"
  ],
  "_predict_one_forecaster": [
    "params",
    "meta"
  ],
  "SkforecastAutoreg": {
    "_tags": [],
    "__init__": [
      "self",
      "regressor",
      "lags",
      "transformer_y",
      "transformer_exog",
      "weight_func",
      "differentiation",
      "fit_kwargs",
      "binner_kwargs"
    ],
    "_clone_estimators": [
      "self"
    ],
    "_create_forecaster": [
      "self"
    ],
    "_coerce_column_names": [
      "X"
    ],
    "_coerce_int_to_range_index": [
      "df"
    ],
    "_coerce_period_to_datetime_index": [
      "df"
    ],
    "_make_index_compatible": [
      "self",
      "df",
      "input_var"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_horizon_details": [
      "self",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SkforecastRecursive": {
    "_tags": [],
    "__init__": [
      "self",
      "regressor",
      "lags",
      "window_features",
      "transformer_y",
      "transformer_X",
      "weight_func",
      "differentiation",
      "fit_kwargs",
      "binner_kwargs",
      "store_in_sample_residuals"
    ],
    "_clone_estimators": [
      "self"
    ],
    "_create_forecaster": [
      "self"
    ],
    "_coerce_column_names": [
      "X"
    ],
    "_coerce_int_to_range_index": [
      "df"
    ],
    "_coerce_period_to_datetime_index": [
      "df"
    ],
    "_make_index_compatible": [
      "self",
      "df",
      "input_var"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_horizon_details": [
      "self",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiplexForecaster": {
    "_tags": [],
    "_delegate_name": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "forecasters",
      "selected_forecaster"
    ],
    "_forecasters": [
      "self",
      "value"
    ],
    "_check_selected_forecaster": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "_set_forecaster": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IgnoreX": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "ignore_x"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TransformSelectForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "transformer",
      "fallback_forecaster"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_forecasters": [
      "self",
      "new_forecasters"
    ]
  },
  "_predict_interval": [
    "self",
    "fh",
    "X",
    "coverage"
  ],
  "_predict_var": [
    "self",
    "fh",
    "X",
    "cov"
  ],
  "_predict_proba": [
    "self",
    "fh",
    "X",
    "marginal"
  ],
  "BaggingForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "bootstrap_transformer",
      "forecaster",
      "sp",
      "random_state"
    ],
    "_check_transformer": [
      "self",
      "transformer"
    ],
    "_check_forecaster": [
      "self",
      "forecaster"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_gen_X_bootstraps": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls"
    ],
    "_calculate_data_quantiles": [
      "self",
      "df",
      "alpha"
    ]
  },
  "_concat_y_X": [
    "y",
    "X"
  ],
  "_check_fh": [
    "fh"
  ],
  "_sliding_window_transform": [
    "y",
    "window_length",
    "fh",
    "X",
    "transformers",
    "scitype",
    "pooling",
    "windows_identical"
  ],
  "_sliding_window_transform_local": [
    "y",
    "window_length",
    "fh",
    "X",
    "windows_identical"
  ],
  "_sliding_window_transform_global": [
    "y",
    "window_length",
    "X",
    "transformers"
  ],
  "_Reducer": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "transformers",
      "pooling"
    ],
    "_is_predictable": [
      "self",
      "last_window"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_in_sample": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_get_shifted_window": [
      "self",
      "shift",
      "y_update",
      "X_update"
    ]
  },
  "_DirectReducer": {
    "strategy": [],
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "transformers",
      "pooling",
      "windows_identical"
    ],
    "_transform": [
      "self",
      "y",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X"
    ]
  },
  "_MultioutputReducer": {
    "strategy": [],
    "_tags": [],
    "_transform": [
      "self",
      "y",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X"
    ]
  },
  "_RecursiveReducer": {
    "strategy": [],
    "_transform": [
      "self",
      "y",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X"
    ]
  },
  "_DirRecReducer": {
    "strategy": [],
    "_tags": [],
    "_transform": [
      "self",
      "y",
      "X"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X"
    ]
  },
  "DirectTabularRegressionForecaster": {
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "transformers",
      "pooling",
      "windows_identical"
    ],
    "_estimator_scitype": []
  },
  "MultioutputTabularRegressionForecaster": {
    "_estimator_scitype": []
  },
  "RecursiveTabularRegressionForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "transformers",
      "pooling"
    ],
    "_estimator_scitype": []
  },
  "DirRecTabularRegressionForecaster": {
    "_estimator_scitype": []
  },
  "DirectTimeSeriesRegressionForecaster": {
    "_estimator_scitype": []
  },
  "MultioutputTimeSeriesRegressionForecaster": {
    "_estimator_scitype": []
  },
  "RecursiveTimeSeriesRegressionForecaster": {
    "_tags": [],
    "_estimator_scitype": []
  },
  "DirRecTimeSeriesRegressionForecaster": {
    "_estimator_scitype": []
  },
  "make_reduction": [
    "estimator",
    "strategy",
    "window_length",
    "scitype",
    "transformers",
    "pooling",
    "windows_identical"
  ],
  "_check_scitype": [
    "scitype"
  ],
  "_infer_scitype": [
    "estimator"
  ],
  "_check_strategy": [
    "strategy"
  ],
  "_get_forecaster": [
    "scitype",
    "strategy"
  ],
  "_cut_df": [
    "X",
    "n_obs",
    "type"
  ],
  "_create_fcst_df": [
    "target_date",
    "origin_df",
    "fill"
  ],
  "slice_at_ix": [
    "df",
    "ix"
  ],
  "_get_notna_idx": [
    "df"
  ],
  "_ReducerMixin": {
    "_get_expected_pred_idx": [
      "self",
      "fh"
    ]
  },
  "DirectReductionForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "transformers",
      "X_treatment",
      "impute_method",
      "pooling",
      "windows_identical"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_fit_multioutput": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_multioutput": [
      "self",
      "fh",
      "X"
    ],
    "_fit_multiple": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_multiple": [
      "self",
      "X",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RecursiveReductionForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "window_length",
      "impute_method",
      "pooling"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_out_of_sample": [
      "self",
      "X_pool",
      "fh"
    ],
    "_predict_in_sample": [
      "self",
      "X_pool",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "YfromX": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "pooling"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "_get_pred_X": [
      "self",
      "X",
      "fh_idx"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PANDAS_TS_MTYPES": [],
  "FhPlexForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "fh_params",
      "fh_lookup",
      "fh_contiguous"
    ],
    "_forecasters": [
      "self"
    ],
    "_plexfun": [
      "self"
    ],
    "_get_fh_keys": [
      "self",
      "fh"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_preds": [
      "self",
      "fh_keys",
      "method"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_update_predict_single": [
      "self",
      "y",
      "fh",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "VALID_AGG_FUNCS": [],
  "AutoEnsembleForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "method",
      "regressor",
      "test_size",
      "random_state",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_get_weights": [
    "regressor"
  ],
  "EnsembleForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "n_jobs",
      "aggfunc",
      "weights"
    ],
    "_parse_fc_multiplicities": [
      "self",
      "forecasters"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_aggregate": [
    "y",
    "aggfunc",
    "weights"
  ],
  "_check_aggfunc": [
    "aggfunc",
    "weighted"
  ],
  "ColumnEnsembleForecaster": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "forecasters"
    ],
    "_forecasters": [
      "self",
      "value"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_check_forecasters": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StackingForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "regressor",
      "random_state",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ForecastByLevel": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "forecaster",
      "groupby"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GroupbyCategoryForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "forecasters",
      "transformer",
      "fallback_forecaster"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_iterate_predict_method_over_categories": [
      "self",
      "methodname",
      "X"
    ],
    "_forecasters": [
      "self",
      "new_forecasters"
    ],
    "_loc_group": [
      "self",
      "df",
      "group"
    ]
  },
  "test_pipeline": [],
  "test_skip_inverse_transform": [],
  "test_nesting_pipelines": [],
  "test_pipeline_with_detrender": [],
  "test_pipeline_with_dimension_changing_transformer": [],
  "test_nested_pipeline_with_index_creation_y_before_X": [],
  "test_nested_pipeline_with_index_creation_X_before_y": [],
  "test_forecasting_pipeline_dunder_endog": [],
  "test_forecasting_pipeline_dunder_exog": [],
  "test_tag_handles_missing_data": [],
  "test_featurizer_forecastingpipeline_logic": [],
  "test_exogenousx_ignore_tag_set": [],
  "test_pipeline_exogenous_none": [],
  "test_pipeline_featurizer_noexog": [],
  "test_pipeline_display": [],
  "test_pipeline_with_gf_tag": [],
  "test_forecasting_pipeline_with_hierarchical_data": [],
  "PredefinedCategory": {
    "_tags": [],
    "__init__": [
      "self",
      "transform_output"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "timeseries_index": [],
  "categories": [
    "timeseries_index"
  ],
  "timeseries": [
    "timeseries_index"
  ],
  "test_predefined_output": [
    "timeseries"
  ],
  "test_predefined_output_groupby": [
    "timeseries",
    "categories"
  ],
  "test_series_without_panel_level": [],
  "test_forecastx_logic": [],
  "test_forecastx_fit_behavior": [],
  "test_forecastx_attrib_broadcast": [],
  "test_forecastx_skip_forecaster_X_fitting_logic": [],
  "test_forecastx_flow_known_unknown_columns": [
    "forecasting_algorithm",
    "future_unknown_columns"
  ],
  "test_forecastx_exog_for_forecaster_x": [],
  "test_use_of_passed_unknown_X": [
    "predict_behaviour_option"
  ],
  "test_forecaster_X_exogeneous": [
    "cols_to_forecast"
  ],
  "N_VARIABLES": [],
  "STRATEGIES": [],
  "FH": [],
  "test_sliding_window_transform_against_cv": [
    "n_timepoints",
    "window_length",
    "fh",
    "scitype"
  ],
  "_make_y_X": [
    "n_timepoints",
    "n_variables"
  ],
  "test_sliding_window_transform_tabular": [
    "n_timepoints",
    "window_length",
    "n_variables",
    "fh"
  ],
  "test_sliding_window_transform_panel": [
    "n_timepoints",
    "window_length",
    "n_variables",
    "fh"
  ],
  "test_sliding_window_transform_explicit": [],
  "_make_y": [
    "start",
    "end",
    "method",
    "slope"
  ],
  "test_linear_extrapolation_endogenous_only": [
    "fh",
    "window_length",
    "strategy",
    "method",
    "slope",
    "regressor",
    "scitype"
  ],
  "test_dummy_regressor_mean_prediction_endogenous_only": [
    "fh",
    "window_length",
    "strategy",
    "scitype"
  ],
  "_REGISTRY": [],
  "_Recorder": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_TestTabularRegressor": {},
  "_TestTimeSeriesRegressor": {
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "test_consistent_data_passing_to_component_estimators_in_fit_and_predict": [
    "estimator",
    "window_length",
    "strategy"
  ],
  "test_make_reduction_construct_instance": [
    "scitype",
    "strategy",
    "klass",
    "window_length"
  ],
  "test_make_reduction_infer_scitype": [
    "estimator",
    "scitype"
  ],
  "test_make_reduction_infer_scitype_for_sklearn_pipeline": [],
  "test_make_reduction_with_catboost": [],
  "test_multioutput_direct_equivalence_tabular_linear_regression": [
    "fh"
  ],
  "EXPECTED_AIRLINE_LINEAR_RECURSIVE": [],
  "EXPECTED_AIRLINE_LINEAR_DIRECT": [],
  "test_reductions_airline_data": [
    "forecaster",
    "expected"
  ],
  "test_dirrec_against_recursive_accumulated_error": [],
  "test_direct_vs_recursive": [],
  "test_recursive_reducer_X_not_fit_to_fh": [],
  "test_make_reduction_proba": [],
  "test_reduction_without_X": [
    "strategy"
  ],
  "test_direct_reduction_with_X": [
    "x_treatment"
  ],
  "test_recursive_reduction_with_X": [],
  "test_recursive_reduction_with_period_index": [],
  "test_autoensembler": [
    "forecasters",
    "method"
  ],
  "_score_forecasters": [
    "forecasters",
    "cv",
    "y"
  ],
  "test_multiplex_forecaster_alone": [],
  "test_multiplex_with_grid_search": [],
  "test_bagging_forecaster_transformer_type_error": [
    "transformer"
  ],
  "test_bagging_forecaster_forecaster_type_error": [
    "forecaster"
  ],
  "test_calculate_data_quantiles": [],
  "sklearn_zero_x": [],
  "y_dict": [],
  "test_recursive_reduction": [
    "y",
    "index_names",
    "y_dict"
  ],
  "test_direct_reduction": [
    "y",
    "index_names",
    "y_dict"
  ],
  "test_list_reduction": [
    "y",
    "index_names",
    "y_dict"
  ],
  "test_equality_transfo_nontranso": [
    "regressor"
  ],
  "test_nofreq_pass": [],
  "test_timezoneaware_index": [],
  "test_forecaster_selection": [
    "forecasters",
    "series_generator",
    "horizon",
    "chosen_forecaster"
  ],
  "test_fallback_forecaster": [
    "forecasters",
    "series_generator",
    "horizon",
    "fallback_forecaster"
  ],
  "test_get_params": [
    "forecasters",
    "fallback_forecaster",
    "transformer",
    "horizon",
    "series_generator",
    "params"
  ],
  "test_SkforecastAutoreg_predict_against_ForecasterAutoreg": [],
  "test_SkforecastAutoreg_predict_with_exog_against_ForecasterAutoreg": [],
  "test_SkforecastAutoreg_predict_interval_against_ForecasterAutoreg": [],
  "test_SkforecastAutoreg_predict_quantile_against_ForecasterAutoreg": [],
  "test_SkforecastRecursive_predict_against_ForecasterRecursive": [],
  "test_SkforecastRecursive_predict_with_exog_against_ForecasterRecursive": [],
  "test_SkforecastRecursive_predict_interval_against_ForecasterRecursive": [
    "store_in_sample_residuals"
  ],
  "test_SkforecastRecursive_predict_quantile_against_ForecasterRecursive": [
    "store_in_sample_residuals"
  ],
  "test_SkforecastRecursive_capability_tags": [],
  "test_ignoreX": [
    "ignore_x"
  ],
  "test_column_ensemble_shape": [
    "forecasters",
    "fh"
  ],
  "test_invalid_forecasters_indices": [
    "forecasters"
  ],
  "test_column_ensemble_string_cols": [],
  "test_column_ensemble_multivariate_and_int": [],
  "test_column_ensemble_hierarchical": [],
  "test_hierarchy_ensemble_level_predict": [
    "forecasters"
  ],
  "test_hierarchy_ensemble_level_predict_parallel": [
    "forecasters"
  ],
  "test_hierarchy_ensemble_node_predict_parallel": [
    "forecasters"
  ],
  "test_hierarchy_ensemble_node_predict": [
    "forecasters"
  ],
  "test_hierarchy_ensemble_exog": [
    "forecasters"
  ],
  "test_level_one_data": [
    "forecasters",
    "default"
  ],
  "test_get_fitted_params": [],
  "ForecastingError": {
    "__init__": [
      "self",
      "message"
    ]
  },
  "DummyForecaster": {
    "__init__": [
      "self",
      "raise_at",
      "predict_nans"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ]
  },
  "test_raises_at_fit": [],
  "test_raises_at_predict": [],
  "test_raises_at_update": [],
  "test_predicts_nans": [],
  "test_fallbackforecaster_fails_at_fit": [],
  "test_fallbackforecaster_fails_at_predict": [],
  "test_fallbackforecaster_fails_twice": [],
  "test_fallbackforecaster_fails_fit_twice": [],
  "test_all_forecasters_fail1": [],
  "test_all_forecasters_fail2": [],
  "test_all_forecasters_fail3": [],
  "test_many_forecasters_fail1": [],
  "test_fallbackforecaster_fails_twice_simple": [],
  "test_fallbackforecaster_fails_many_simple": [],
  "test_fallbackforecaster_pred_int": [],
  "test_fallbackforecaster_pred_int_raises": [],
  "test_fallbackforecaster_predict_nan_allow": [],
  "test_fallbackforecaster_predict_nan": [],
  "test_fallbackforecaster_warns": [],
  "test_fallbackforecaster_raises": [],
  "test_forecastbylevel_nan_predict": [],
  "test_avg_mean": [
    "forecasters"
  ],
  "test_aggregation_unweighted": [
    "forecasters",
    "y",
    "aggfunc"
  ],
  "test_aggregation_weighted": [
    "forecasters",
    "y",
    "aggfunc",
    "weights"
  ],
  "test_invalid_aggfuncs": [
    "forecasters",
    "aggfunc"
  ],
  "_adapt_y_X": [
    "y",
    "X"
  ],
  "_get_X_pred": [
    "X_pred",
    "index"
  ],
  "_adapt_y_pred": [
    "y_pred"
  ],
  "HCrystalBallAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "model"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_check_scores": [
    "metrics"
  ],
  "_get_column_order_and_datatype": [
    "metric_types",
    "return_data",
    "cutoff_dtype",
    "old_naming",
    "return_model"
  ],
  "_split": [
    "y",
    "X",
    "train",
    "test",
    "freq"
  ],
  "_select_fh_from_y": [
    "y"
  ],
  "_get_pred_args_from_metric": [
    "scitype",
    "metric"
  ],
  "_evaluate_window": [
    "x",
    "meta"
  ],
  "gen_y_X_train_test_global": [
    "y",
    "X",
    "cv",
    "cv_X",
    "cv_global",
    "cv_global_temporal"
  ],
  "evaluate": [
    "forecaster",
    "cv",
    "y",
    "X",
    "strategy",
    "scoring",
    "return_data",
    "error_score",
    "backend",
    "cv_X",
    "backend_params",
    "return_model",
    "cv_global",
    "cv_global_temporal"
  ],
  "METRICS": [],
  "METRICS_GLOBAL": [],
  "PROBA_METRICS": [],
  "INTERVAL_METRICS_WITH_PARAMS": [],
  "STRATEGY": [],
  "_check_evaluate_output": [
    "out",
    "cv",
    "y",
    "scoring",
    "return_data",
    "return_model",
    "cv_global"
  ],
  "test_evaluate_common_configs": [
    "CV",
    "fh",
    "window_length",
    "step_length",
    "strategy",
    "scoring",
    "backend"
  ],
  "test_evaluate_global_mode": [
    "scoring",
    "strategy",
    "backend"
  ],
  "test_evaluate_global_mode_with_temporal_split": [],
  "test_scoring_list": [
    "return_data",
    "return_model",
    "scores"
  ],
  "test_evaluate_initial_window": [],
  "test_evaluate_no_exog_against_with_exog": [],
  "test_evaluate_error_score": [
    "error_score",
    "return_data",
    "return_model",
    "strategy",
    "backend",
    "scores"
  ],
  "test_evaluate_hierarchical": [
    "backend"
  ],
  "ARIMA_MODELS": [],
  "test_evaluate_bigger_X": [
    "cls"
  ],
  "test_evaluate_probabilistic": [
    "n_columns",
    "scoring"
  ],
  "test_evaluate_probabilistic_with_params": [
    "n_columns",
    "scoring"
  ],
  "test_evaluate_hierarchical_unequal_X_y": [],
  "_get_X_numpy_int_from_pandas": [
    "x"
  ],
  "ProphetPiecewiseLinearTrendForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "changepoints",
      "n_changepoints",
      "changepoint_range",
      "changepoint_prior_scale",
      "verbose",
      "yearly_seasonality",
      "weekly_seasonality",
      "daily_seasonality"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TrendForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "regressor"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "STLForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "sp",
      "seasonal",
      "trend",
      "low_pass",
      "seasonal_deg",
      "trend_deg",
      "low_pass_deg",
      "robust",
      "seasonal_jump",
      "trend_jump",
      "low_pass_jump",
      "inner_iter",
      "outer_iter",
      "forecaster_trend",
      "forecaster_seasonal",
      "forecaster_resid"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "plot_components": [
      "self",
      "title"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CurveFitForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "function",
      "curve_fit_params",
      "origin",
      "normalise_index"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_test_function_2": [
    "x",
    "a",
    "b",
    "c"
  ],
  "PolynomialTrendForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "regressor",
      "degree",
      "with_intercept",
      "prediction_intervals"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SplineTrendForecaster": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "regressor",
      "n_knots",
      "degree",
      "knots",
      "extrapolation",
      "with_intercept"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_get_X_numpy": [],
  "get_expected_polynomial_coefs": [
    "y",
    "degree",
    "with_intercept"
  ],
  "_test_trend": [
    "degree",
    "with_intercept"
  ],
  "test_trend": [
    "degree",
    "with_intercept"
  ],
  "test_zero_trend": [],
  "test_constant_trend": [],
  "test_trendforecaster_with_datetimeindex": [],
  "test_predict_var": [],
  "test_plot_components": [],
  "test_for_changes_in_original": [],
  "test_pred_errors_against_linear": [],
  "test_pred_with_explicit_changepoints": [],
  "test_pwl_trend_nonnative_index": [
    "indextype"
  ],
  "BaseGridSearch": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "strategy",
      "backend",
      "refit",
      "scoring",
      "verbose",
      "return_n_best_forecasters",
      "update_behaviour",
      "error_score",
      "tune_by_instance",
      "tune_by_variable",
      "backend_params",
      "n_jobs"
    ],
    "_delegate_name": [],
    "_extend_to_all_scitypes": [
      "self",
      "tagname"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ]
  },
  "_fit_and_score": [
    "params",
    "meta"
  ],
  "ForecastingRandomizedSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "param_distributions",
      "n_iter",
      "scoring",
      "strategy",
      "refit",
      "verbose",
      "return_n_best_forecasters",
      "random_state",
      "backend",
      "update_behaviour",
      "error_score",
      "tune_by_instance",
      "tune_by_variable",
      "backend_params",
      "n_jobs"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ForecastingGridSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "param_grid",
      "scoring",
      "strategy",
      "refit",
      "verbose",
      "return_n_best_forecasters",
      "backend",
      "update_behaviour",
      "error_score",
      "tune_by_instance",
      "tune_by_variable",
      "backend_params",
      "n_jobs"
    ],
    "_check_param_grid": [
      "self",
      "param_grid"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "temporal_train_test_split": [
    "y",
    "X",
    "test_size",
    "train_size",
    "fh",
    "anchor"
  ],
  "ExpandingWindowSplitter": [
    "fh",
    "initial_window",
    "step_length"
  ],
  "SlidingWindowSplitter": [
    "fh",
    "window_length",
    "step_length",
    "initial_window",
    "start_with_window"
  ],
  "ForecastingSkoptSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "param_distributions",
      "n_iter",
      "n_points",
      "random_state",
      "scoring",
      "optimizer_kwargs",
      "strategy",
      "refit",
      "verbose",
      "return_n_best_forecasters",
      "backend",
      "update_behaviour",
      "error_score",
      "tune_by_instance",
      "tune_by_variable",
      "backend_params",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_run_search": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_evaluate_step": [
      "self",
      "y",
      "X",
      "optimizer",
      "n_points",
      "mapping"
    ],
    "_create_optimizer": [
      "self",
      "params_space"
    ],
    "_check_search_space": [
      "self",
      "search_space"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_fit_and_score_skopt": [
    "params",
    "meta"
  ],
  "ForecastingOptunaSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "cv",
      "param_grid",
      "scoring",
      "strategy",
      "refit",
      "verbose",
      "return_n_best_forecasters",
      "backend",
      "update_behaviour",
      "error_score",
      "n_evals",
      "sampler"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_get_score": [
      "self",
      "out",
      "scoring_name"
    ],
    "_run_search": [
      "self",
      "y",
      "X",
      "cv",
      "scoring",
      "scoring_name",
      "sampler"
    ]
  },
  "ForecastingOptCV": {
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "optimizer",
      "cv",
      "strategy",
      "update_behaviour",
      "scoring",
      "refit",
      "error_score",
      "cv_X",
      "backend",
      "backend_params"
    ],
    "get_test_params": [
      "self",
      "parameter_set"
    ]
  },
  "TEST_METRICS": [],
  "TEST_METRICS_PROBA": [],
  "TUNER_CLASSES": [],
  "_get_expected_scores": [
    "forecaster",
    "cv",
    "param_grid",
    "y",
    "X",
    "scoring"
  ],
  "_check_fitted_params_keys": [
    "fitted_params"
  ],
  "_check_cv": [
    "forecaster",
    "tuner",
    "cv",
    "param_grid",
    "y",
    "X",
    "scoring"
  ],
  "_create_hierarchical_data": [
    "n_columns"
  ],
  "NAIVE": [],
  "NAIVE_GRID": [],
  "PIPE": [],
  "PIPE_GRID": [],
  "CVs": [],
  "ERROR_SCORES": [],
  "test_gscv": [
    "forecaster",
    "param_grid",
    "cv",
    "scoring",
    "error_score",
    "multivariate"
  ],
  "test_rscv": [
    "forecaster",
    "param_grid",
    "cv",
    "scoring",
    "error_score",
    "n_iter",
    "random_state"
  ],
  "test_gscv_hierarchical": [
    "forecaster",
    "param_grid",
    "cv",
    "scoring",
    "error_score",
    "n_cols"
  ],
  "test_gscv_proba": [
    "cv",
    "scoring",
    "error_score"
  ],
  "test_skoptcv": [
    "forecaster",
    "param_grid",
    "cv",
    "scoring",
    "error_score",
    "n_iter"
  ],
  "test_skoptcv_multiple_forecaster": [],
  "optuna_param_grids": [],
  "optuna_samplers": [],
  "forecasters_optuna_test": [],
  "test_optuna": [
    "forecaster_key",
    "grid_key",
    "cv",
    "scoring",
    "error_score",
    "n_iter",
    "sampler",
    "optuna_param_grids"
  ],
  "BACKEND_TEST": [],
  "test_gscv_backends": [
    "backend_set"
  ],
  "TEST_PARAMS_DICT": [],
  "TEST_PARAMS_LIST": [],
  "test_return_n_best_forecasters": [
    "Forecaster",
    "return_n_best_forecasters",
    "kwargs"
  ],
  "UpdateRefitsEvery": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "refit_interval",
      "refit_window_size",
      "refit_window_lag"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "UpdateEvery": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "forecaster",
      "update_interval"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "DontUpdate": {
    "_delegate_name": [],
    "_tags": [],
    "__init__": [
      "self",
      "forecaster"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "_is_time_offset": [
    "obj"
  ],
  "_is_time_difference": [
    "obj"
  ],
  "_geq": [
    "a",
    "b"
  ],
  "DEFAULT_ALPHA": [],
  "BaseForecaster": {
    "_tags": [],
    "_config": [],
    "_config_doc": [],
    "__init__": [
      "self"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__rpow__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "predict": [
      "self",
      "fh",
      "X"
    ],
    "fit_predict": [
      "self",
      "y",
      "X",
      "fh",
      "X_pred"
    ],
    "predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "update_predict": [
      "self",
      "y",
      "cv",
      "X",
      "update_params",
      "reset_forecaster"
    ],
    "update_predict_single": [
      "self",
      "y",
      "fh",
      "X",
      "update_params"
    ],
    "predict_residuals": [
      "self",
      "y",
      "X"
    ],
    "score": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "get_fitted_params": [
      "self",
      "deep"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_update_X": [
      "self",
      "X",
      "enforce_index_type"
    ],
    "_update_y_X": [
      "self",
      "y",
      "X",
      "enforce_index_type"
    ],
    "cutoff": [
      "self"
    ],
    "_set_cutoff": [
      "self",
      "cutoff"
    ],
    "_set_cutoff_from_y": [
      "self",
      "y"
    ],
    "fh": [
      "self"
    ],
    "_check_fh": [
      "self",
      "fh",
      "pred_int"
    ],
    "_vectorize": [
      "self",
      "methodname"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_update_predict_single": [
      "self",
      "y",
      "fh",
      "X",
      "update_params"
    ],
    "_predict_moving_cutoff": [
      "self",
      "y",
      "cv",
      "X",
      "update_params",
      "reset_forecaster"
    ],
    "_get_varnames": [
      "self",
      "y"
    ],
    "_get_columns": [
      "self",
      "method"
    ]
  },
  "_BaseGlobalForecaster": {
    "_tags": [],
    "predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha",
      "y"
    ],
    "predict_interval": [
      "self",
      "fh",
      "X",
      "coverage",
      "y"
    ],
    "predict_var": [
      "self",
      "fh",
      "X",
      "cov",
      "y"
    ],
    "predict_proba": [
      "self",
      "fh",
      "X",
      "marginal",
      "y"
    ]
  },
  "_format_moving_cutoff_predictions": [
    "y_preds",
    "cutoffs"
  ],
  "_DelegatedForecaster": {
    "_delegate_name": [],
    "_get_delegate": [
      "self"
    ],
    "_set_delegated_tags": [
      "self",
      "delegate"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_update_predict_single": [
      "self",
      "y",
      "fh",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "fh",
      "X",
      "marginal"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "VALID_FORECASTING_HORIZON_TYPES": [],
  "DELEGATED_METHODS": [],
  "_delegator": [
    "method"
  ],
  "_check_values": [
    "values"
  ],
  "_check_freq": [
    "obj"
  ],
  "_extract_freq_from_cutoff": [
    "x"
  ],
  "ForecastingHorizon": {
    "__new__": [
      "cls",
      "values",
      "is_relative",
      "freq"
    ],
    "__init__": [
      "self",
      "values",
      "is_relative",
      "freq"
    ],
    "_new": [
      "self",
      "values",
      "is_relative",
      "freq"
    ],
    "is_relative": [
      "self"
    ],
    "freq": [
      "self",
      "obj"
    ],
    "to_pandas": [
      "self"
    ],
    "to_numpy": [
      "self"
    ],
    "_coerce_cutoff_to_index": [
      "self",
      "cutoff"
    ],
    "to_relative": [
      "self",
      "cutoff"
    ],
    "to_absolute": [
      "self",
      "cutoff"
    ],
    "to_absolute_index": [
      "self",
      "cutoff"
    ],
    "to_absolute_int": [
      "self",
      "start",
      "cutoff"
    ],
    "to_in_sample": [
      "self",
      "cutoff"
    ],
    "to_out_of_sample": [
      "self",
      "cutoff"
    ],
    "_is_in_sample": [
      "self",
      "cutoff"
    ],
    "is_all_in_sample": [
      "self",
      "cutoff"
    ],
    "_is_out_of_sample": [
      "self",
      "cutoff"
    ],
    "is_all_out_of_sample": [
      "self",
      "cutoff"
    ],
    "to_indexer": [
      "self",
      "cutoff",
      "from_cutoff"
    ],
    "get_expected_pred_idx": [
      "self",
      "y",
      "cutoff",
      "sort_by_time"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_HashIndex": {
    "__init__": [
      "self",
      "index"
    ],
    "__hash__": [
      "self"
    ]
  },
  "_to_relative": [
    "fh",
    "cutoff"
  ],
  "_to_absolute": [
    "fh",
    "cutoff"
  ],
  "_check_cutoff": [
    "cutoff",
    "index"
  ],
  "_coerce_to_period": [
    "x",
    "freq"
  ],
  "_index_range": [
    "relative",
    "cutoff"
  ],
  "_is_pandas_arithmetic_bug_fixed": [],
  "_BaseWindowForecaster": {
    "__init__": [
      "self",
      "window_length"
    ],
    "_predict_boilerplate": [
      "self",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_fixed_cutoff": [
      "self",
      "fh",
      "X"
    ],
    "_predict_in_sample": [
      "self",
      "fh",
      "X"
    ],
    "_predict_last_window": [
      "self",
      "fh",
      "X"
    ],
    "_get_last_window": [
      "self"
    ],
    "_predict_nan": [
      "self",
      "fh",
      "method"
    ]
  },
  "_HeterogenousEnsembleForecaster": {
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "forecasters",
      "n_jobs",
      "fc_alt"
    ],
    "_initialize_forecaster_tuples": [
      "self",
      "forecasters"
    ],
    "_check_forecasters_init": [
      "self",
      "estimators"
    ],
    "_get_forecaster_list": [
      "self"
    ],
    "_get_forecaster_names": [
      "self"
    ],
    "_fit_forecasters": [
      "self",
      "forecasters",
      "y",
      "X",
      "fh"
    ],
    "_predict_forecasters": [
      "self",
      "fh",
      "X",
      "forecasters"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ]
  },
  "test_heterogeneous_get_fitted_params": [],
  "test_predict_residuals_conversion": [],
  "_assert_index_equal": [
    "a",
    "b"
  ],
  "good_absolute_input_arg": [
    "request"
  ],
  "good_relative_input_arg": [
    "request"
  ],
  "timepoint": [
    "request"
  ],
  "length1_index": [
    "request"
  ],
  "test_fh": [
    "index_type",
    "fh_type",
    "is_relative",
    "steps"
  ],
  "test_fh_method_delegation": [],
  "BAD_INPUT_ARGS": [],
  "test_check_fh_values_bad_input_types": [
    "arg"
  ],
  "DUPLICATE_INPUT_ARGS": [],
  "test_check_fh_values_duplicate_input_values": [
    "arg"
  ],
  "test_check_fh_absolute_input_conversion_to_pandas_index": [
    "good_absolute_input_arg"
  ],
  "test_check_fh_relative_values_conversion_to_pandas_index": [
    "good_relative_input_arg"
  ],
  "test_shift": [
    "timepoint",
    "by"
  ],
  "test_shift_index": [
    "length1_index",
    "by"
  ],
  "DURATIONS_ALLOWED": [],
  "DURATIONS_NOT_ALLOWED": [],
  "test_coerce_duration_to_int": [
    "duration"
  ],
  "test_coerce_duration_to_int_with_non_allowed_durations": [
    "duration"
  ],
  "test_get_duration": [
    "n_timepoints",
    "index_type"
  ],
  "FIXED_FREQUENCY_STRINGS": [],
  "NON_FIXED_FREQUENCY_STRINGS": [],
  "FREQUENCY_STRINGS": [],
  "_get_expected_freqstr": [
    "freqstr"
  ],
  "test_to_absolute_freq": [
    "freqstr"
  ],
  "test_absolute_to_absolute_with_integer_horizon": [
    "freqstr"
  ],
  "test_absolute_to_absolute_with_timedelta_horizon": [
    "freqstr"
  ],
  "test_relative_to_relative_with_integer_horizon": [
    "freqstr"
  ],
  "test_relative_to_relative_with_timedelta_horizon": [
    "freqstr"
  ],
  "test_to_relative": [
    "freq"
  ],
  "test_to_absolute_int": [
    "idx",
    "freq"
  ],
  "test_to_absolute_int_fh_with_freq": [
    "idx",
    "freq"
  ],
  "test_to_absolute_with_multiple_freq": [
    "freq"
  ],
  "test_estimator_fh": [
    "freqstr"
  ],
  "test_error_with_incorrect_string_frequency": [
    "freq"
  ],
  "test_frequency_setter": [
    "freqstr"
  ],
  "test_auto_ets": [],
  "test_auto_ets_case_with_naive": [],
  "test_exponential_smoothing": [],
  "test_exponential_smoothing_case_with_naive": [],
  "test_auto_arima": [],
  "test_auto_arima_case_with_naive": [],
  "test_extract_freq_from_inputs": [],
  "test_extract_freq_from_cutoff": [
    "freq"
  ],
  "test_extract_freq_from_cutoff_with_wrong_input": [
    "x"
  ],
  "test_regular_spaced_fh_of_different_periodicity": [],
  "test_standard_range_in_fh": [],
  "test_range_with_positive_step_in_fh": [],
  "test_range_with_negative_step_in_fh": [],
  "test_range_sorting_in_fh": [],
  "test_empty_range_in_fh": [],
  "test_fh_expected_pred": [],
  "test_tz_preserved": [],
  "FREQ_STR_FOR_PD22": [],
  "test_pandas22_freq": [
    "freq"
  ],
  "test_pandas22_freq_roundtrip": [
    "ts"
  ],
  "test_timestamp_format_to_absolute": [],
  "fh": [],
  "y_1": [],
  "test_random_state": [
    "model"
  ],
  "PANEL_MTYPES": [],
  "HIER_MTYPES": [],
  "test_vectorization_series_to_panel": [
    "mtype",
    "backend"
  ],
  "test_vectorization_series_to_hier": [
    "mtype",
    "backend"
  ],
  "PROBA_DF_METHODS": [],
  "test_vectorization_series_to_panel_proba": [
    "method",
    "mtype"
  ],
  "test_vectorization_series_to_hier_proba": [
    "method",
    "mtype"
  ],
  "test_vectorization_preserves_row_index_names": [
    "method"
  ],
  "test_vectorization_multivariate": [
    "mtype",
    "exogeneous"
  ],
  "test_col_vectorization_correct_col_order": [],
  "test_row_vectorization_correct_row_order": [],
  "test_dynamic_tags_reset_properly": [],
  "test_predict_residuals": [],
  "test_nullable_dtypes": [
    "nullable_type"
  ],
  "test_range_fh_in_fit": [],
  "test_range_fh_in_predict": [],
  "test_remember_data": [],
  "test_panel_with_inner_freq": [],
  "_get_exog_proba_fcst": [],
  "_StatsModelsAdapter": {
    "_fitted_param_names": [],
    "_tags": [],
    "__init__": [
      "self",
      "random_state"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_fit_forecaster": [
      "self",
      "y_train",
      "X_train"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_extract_conf_int": [
      "prediction_results",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "_get_fitted_param_names": [
      "self"
    ]
  },
  "_coerce_int_to_range_index": [
    "y",
    "X"
  ],
  "_StatsForecastAdapter": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_in_sample": [
      "self",
      "fh",
      "X",
      "return_pred_int",
      "alpha"
    ],
    "_predict_fixed_cutoff": [
      "self",
      "fh",
      "X",
      "return_pred_int",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ]
  },
  "_ProphetAdapter": {
    "_tags": [],
    "_convert_int_to_date": [
      "self",
      "y"
    ],
    "_convert_input_to_date": [
      "self",
      "y"
    ],
    "_remember_y_input_index_type": [
      "self",
      "y"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_prophet_fh": [
      "self"
    ],
    "_convert_X_for_exog": [
      "self",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "_check_changepoints": [
      "self"
    ]
  },
  "_merge_X": [
    "df",
    "X"
  ],
  "_suppress_stdout_stderr": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "BaseDeepNetworkPyTorch": {
    "_tags": [],
    "__init__": [
      "self",
      "num_epochs",
      "batch_size",
      "in_channels",
      "individual",
      "criterion_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "lr"
    ],
    "_fit": [
      "self",
      "y",
      "fh",
      "X"
    ],
    "_run_epoch": [
      "self",
      "epoch",
      "dataloader"
    ],
    "_instantiate_optimizer": [
      "self"
    ],
    "_instantiate_criterion": [
      "self"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "build_pytorch_train_dataloader": [
      "self",
      "y"
    ],
    "build_pytorch_pred_dataloader": [
      "self",
      "y",
      "fh"
    ],
    "get_y_true": [
      "self",
      "y"
    ],
    "_build_network": [
      "self",
      "fh"
    ]
  },
  "PyTorchPredDataset": {
    "__init__": [
      "self",
      "y",
      "seq_len",
      "X"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "_PytorchForecastingAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "model_params",
      "dataset_params",
      "train_to_dataloader_params",
      "validation_to_dataloader_params",
      "trainer_params",
      "model_path",
      "random_log_path",
      "broadcasting"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "_instantiate_model": [
      "self",
      "data"
    ],
    "_gen_random_log_dir": [
      "self",
      "data"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha",
      "y"
    ],
    "_Xy_precheck": [
      "self",
      "X",
      "y"
    ],
    "_Xy_to_dataset": [
      "self",
      "X",
      "y",
      "dataset_params",
      "max_prediction_length"
    ],
    "_predictions_to_dataframe": [
      "self",
      "predictions",
      "max_prediction_length",
      "alpha"
    ],
    "_dummy_X": [
      "self",
      "X",
      "y"
    ],
    "_extend_y": [
      "self",
      "y",
      "fh"
    ]
  },
  "_series_to_frame": [
    "data"
  ],
  "_SUPPORTED_LOCAL_SCALAR_TYPES": [],
  "_NeuralForecastAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "freq",
      "local_scaler_type",
      "futr_exog_list",
      "verbose_fit",
      "verbose_predict",
      "broadcasting"
    ],
    "algorithm_exogenous_support": [
      "self"
    ],
    "algorithm_name": [
      "self"
    ],
    "algorithm_class": [
      "self"
    ],
    "algorithm_parameters": [
      "self"
    ],
    "_ignore_invalid_parameters": [
      "self"
    ],
    "_instantiate_model": [
      "self",
      "fh"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_id_idx": [
      "self",
      "indices"
    ],
    "_handle_PeriodIndex": [
      "self",
      "data"
    ],
    "_predict": [
      "self",
      "fh",
      "X",
      "y"
    ]
  },
  "_GeneralisedStatsForecastAdapter": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "_get_init_statsforecast_params": [
      "self"
    ],
    "_get_statsforecast_default_params": [
      "self"
    ],
    "_get_validated_statsforecast_params": [
      "self"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict_in_or_out_of_sample": [
      "self",
      "fh",
      "fh_type",
      "X",
      "levels"
    ],
    "_split_horizon": [
      "self",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_check_supports_pred_int": [
      "self"
    ]
  },
  "StatsForecastBackAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator"
    ],
    "__repr__": [
      "self"
    ],
    "new": [
      "self"
    ],
    "set_fh": [
      "self",
      "fh"
    ],
    "_get_MSTL_fh": [
      "self"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "format_pred_int": [
      "self",
      "y_pred_name",
      "y_pred",
      "pred_int",
      "coverage",
      "level"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_TbatsAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "use_box_cox",
      "box_cox_bounds",
      "use_trend",
      "use_damped_trend",
      "sp",
      "use_arma_errors",
      "show_warnings",
      "n_jobs",
      "multiprocessing_start_method",
      "context"
    ],
    "_create_model_class": [
      "self"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_get_y_pred": [
      "self",
      "y_in_sample",
      "y_out_sample"
    ],
    "_tbats_forecast": [
      "self",
      "fh"
    ],
    "_tbats_forecast_interval": [
      "self",
      "fh",
      "conf_lev"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "_get_fitted_param_names": [
      "self"
    ]
  },
  "nans": [
    "length"
  ],
  "_PmdArimaAdapter": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_instantiate_model": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_in_sample": [
      "self",
      "fh",
      "X",
      "return_pred_int",
      "alpha"
    ],
    "_predict_fixed_cutoff": [
      "self",
      "fh",
      "X",
      "return_pred_int",
      "alpha"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "_get_fitted_params_arima_res": [
      "self"
    ],
    "_get_fitted_param_names": [
      "self"
    ],
    "summary": [
      "self"
    ]
  },
  "LAGS_TYPE": [],
  "PAST_LAGS_TYPE": [],
  "FUTURE_LAGS_TYPE": [],
  "_DartsRegressionAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "model",
      "multi_models",
      "use_static_covariates",
      "past_covariates",
      "num_samples"
    ],
    "convert_dataframe_to_timeseries": [
      "dataset"
    ],
    "convert_exogenous_dataset": [
      "self",
      "dataset"
    ],
    "_create_forecaster": [
      "self"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ]
  },
  "_get_darts_quantiles": [
    "obj",
    "q"
  ],
  "_DartsRegressionModelsAdapter": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "multi_models",
      "use_static_covariates",
      "past_covariates",
      "num_samples"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ]
  },
  "_handle_input_index": [
    "dataset"
  ],
  "_is_int64_type": [
    "index"
  ],
  "StatsForecastGARCH": {
    "_tags": [],
    "__init__": [
      "self",
      "p",
      "q"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StatsForecastARCH": {
    "_tags": [],
    "__init__": [
      "self",
      "p"
    ],
    "_get_statsforecast_class": [
      "self"
    ],
    "_get_statsforecast_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ARCH": {
    "_tags": [],
    "__init__": [
      "self",
      "mean",
      "lags",
      "vol",
      "p",
      "o",
      "q",
      "power",
      "dist",
      "hold_back",
      "rescale",
      "update_freq",
      "disp",
      "starting_values",
      "cov_type",
      "show_warning",
      "first_obs",
      "last_obs",
      "tol",
      "options",
      "backcast",
      "params",
      "start",
      "align",
      "method",
      "simulations",
      "rng",
      "random_state",
      "reindex"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_get_arch_result_object": [
      "self",
      "fh",
      "X"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_predict_interval": [
      "self",
      "fh",
      "X",
      "coverage"
    ],
    "_predict_var": [
      "self",
      "fh",
      "X",
      "cov"
    ],
    "_predict_out_of_sample": [
      "self",
      "fh",
      "X",
      "type"
    ],
    "_predict_in_sample": [
      "self",
      "fh",
      "X",
      "type"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls"
    ],
    "summary": [
      "self"
    ]
  },
  "strtobool": [
    "val"
  ],
  "check_estimator": [
    "estimator",
    "raise_exceptions",
    "tests_to_run",
    "fixtures_to_run",
    "verbose",
    "tests_to_exclude",
    "fixtures_to_exclude"
  ],
  "_get_test_names_from_class": [
    "test_cls"
  ],
  "_get_test_names_for_obj": [
    "obj"
  ],
  "parametrize_with_checks": [
    "objs",
    "obj_varname",
    "check_varname"
  ],
  "random_ss_ix": [
    "ix",
    "size",
    "replace"
  ],
  "profile_classifier": [
    "est",
    "n_instances_grid",
    "n_timepoints_grid",
    "n_replicates",
    "return_replicates"
  ],
  "plot_series": [],
  "plot_interval": [
    "ax",
    "interval_df"
  ],
  "plot_lags": [
    "series",
    "lags",
    "suptitle"
  ],
  "plot_correlations": [
    "series",
    "lags",
    "alpha",
    "zero_lag",
    "acf_fft",
    "acf_adjusted",
    "pacf_method",
    "suptitle",
    "series_title",
    "acf_title",
    "pacf_title"
  ],
  "_check_colors": [
    "colors",
    "n_series"
  ],
  "_get_windows": [
    "cv",
    "y"
  ],
  "plot_folds_global_forecasting": [
    "cv",
    "cv_global",
    "cv_global_temporal",
    "y"
  ],
  "plot_windows": [
    "cv",
    "y",
    "title",
    "ax"
  ],
  "plot_calibration": [
    "y_true",
    "y_pred",
    "ax"
  ],
  "get_module_from_class": [
    "cls"
  ],
  "get_path_from_module": [
    "module_str"
  ],
  "is_module_changed": [
    "module_str"
  ],
  "is_class_changed": [
    "cls"
  ],
  "get_changed_lines": [
    "file_path",
    "only_indented"
  ],
  "get_packages_with_changed_specs": [],
  "_get_packages_with_changed_specs": [],
  "stratified_resample": [
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "random_state"
  ],
  "random_partition": [
    "n",
    "k",
    "seed"
  ],
  "_fit_trend": [
    "x",
    "order"
  ],
  "_slope": [
    "y",
    "axis"
  ],
  "set_random_state": [
    "estimator",
    "random_state"
  ],
  "_weighted_percentile": [
    "array",
    "sample_weight",
    "percentile"
  ],
  "_weighted_geometric_mean": [
    "y",
    "weights",
    "axis"
  ],
  "_weighted_median": [
    "y",
    "axis",
    "weights"
  ],
  "_weighted_min": [
    "y",
    "axis",
    "weights"
  ],
  "_weighted_max": [
    "y",
    "axis",
    "weights"
  ],
  "_make_strings_unique": [
    "strlist",
    "new_str",
    "counter"
  ],
  "_all_classes": [
    "module_name"
  ],
  "_all_cond": [
    "module_name",
    "cond"
  ],
  "_coerce_duration_to_int": [
    "duration",
    "freq"
  ],
  "_get_intervals_count_and_unit": [
    "freq"
  ],
  "_get_freq": [
    "x"
  ],
  "set_hier_freq": [
    "x"
  ],
  "infer_freq": [
    "y"
  ],
  "_": [
    "y"
  ],
  "_infer_freq_from_index": [
    "index"
  ],
  "_get_duration": [
    "x",
    "y",
    "coerce_to_int",
    "unit"
  ],
  "_VisualBlock": {
    "__init__": [
      "self",
      "kind",
      "estimators"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "_write_label_html": [
    "out",
    "name",
    "name_details",
    "outer_class",
    "inner_class",
    "checked",
    "doc_link"
  ],
  "_get_visual_block": [
    "base_object"
  ],
  "_write_base_object_html": [
    "out",
    "base_object",
    "base_object_label",
    "base_object_label_details",
    "first_call"
  ],
  "_object_html_repr": [
    "base_object"
  ],
  "_get_reduced_path": [
    "input_path_string"
  ],
  "_HTMLDocumentationLinkMixin": {
    "_doc_link_module": [],
    "_generate_doc_link": [
      "cls"
    ],
    "_get_doc_link": [
      "self"
    ],
    "_repr_html_": [
      "self"
    ],
    "_repr_html_inner": [
      "self"
    ],
    "_repr_mimebundle_": [
      "self"
    ]
  },
  "underscore_join": [
    "iterable"
  ],
  "flatten_multiindex": [
    "idx"
  ],
  "rename_multiindex": [
    "idx",
    "feature_names_out",
    "idx_name"
  ],
  "apply_split": [
    "y",
    "iloc_ix"
  ],
  "apply_method_per_series": [
    "y",
    "method_name"
  ],
  "is_hierarchical": [
    "multiindex",
    "raise_if_false"
  ],
  "_singleton": [
    "cls"
  ],
  "_multiton": [
    "cls"
  ],
  "FLAVOR_NAME": [],
  "PYFUNC_PREDICT_CONF": [],
  "PYFUNC_PREDICT_CONF_KEY": [],
  "SKTIME_PREDICT": [],
  "SKTIME_PREDICT_INTERVAL": [],
  "SKTIME_PREDICT_PROBA": [],
  "SKTIME_PREDICT_QUANTILES": [],
  "SKTIME_PREDICT_VAR": [],
  "SUPPORTED_SKTIME_PREDICT_METHODS": [],
  "SERIALIZATION_FORMAT_PICKLE": [],
  "SERIALIZATION_FORMAT_CLOUDPICKLE": [],
  "SUPPORTED_SERIALIZATION_FORMATS": [],
  "_logger": [],
  "get_default_pip_requirements": [
    "include_cloudpickle"
  ],
  "get_default_conda_env": [
    "include_cloudpickle"
  ],
  "save_model": [
    "sktime_model",
    "path",
    "conda_env",
    "code_paths",
    "mlflow_model",
    "signature",
    "input_example",
    "pip_requirements",
    "extra_pip_requirements",
    "serialization_format"
  ],
  "log_model": [
    "sktime_model",
    "artifact_path",
    "conda_env",
    "code_paths",
    "registered_model_name",
    "signature",
    "input_example",
    "await_registration_for",
    "pip_requirements",
    "extra_pip_requirements",
    "serialization_format"
  ],
  "load_model": [
    "model_uri",
    "dst_path"
  ],
  "_save_model": [
    "model",
    "path",
    "serialization_format"
  ],
  "_load_model": [
    "path",
    "serialization_format"
  ],
  "_load_pyfunc": [
    "path"
  ],
  "_SktimeModelWrapper": {
    "__init__": [
      "self",
      "sktime_model"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "df_map": [
    "x"
  ],
  "parallelize": [
    "fun",
    "iter",
    "meta",
    "backend",
    "backend_params"
  ],
  "backend_dict": [],
  "para_dict": [],
  "_parallelize_none": [
    "fun",
    "iter",
    "meta",
    "backend",
    "backend_params"
  ],
  "_parallelize_joblib": [
    "fun",
    "iter",
    "meta",
    "backend",
    "backend_params"
  ],
  "_parallelize_dask": [
    "fun",
    "iter",
    "meta",
    "backend",
    "backend_params"
  ],
  "_parallelize_ray": [
    "fun",
    "iter",
    "meta",
    "backend",
    "backend_params"
  ],
  "SKIP_FIXTURES": [],
  "_get_parallel_test_fixtures": [
    "naming"
  ],
  "autocorrelation_seasonality_test": [
    "y",
    "sp"
  ],
  "_pivot_sp": [
    "df",
    "sp",
    "anchor",
    "freq",
    "anchor_side"
  ],
  "_make_period_index_df": [
    "df",
    "freq"
  ],
  "_unpivot_sp": [
    "df",
    "template"
  ],
  "warn": [
    "msg",
    "category",
    "obj",
    "stacklevel"
  ],
  "_SuppressWarningPattern": {
    "__init__": [
      "self",
      "warning_type",
      "message_pattern"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "_suppress_pd22_warning": [],
  "_list_required_methods": [
    "est_scitype",
    "is_est"
  ],
  "_make_primitives": [
    "n_columns",
    "random_state"
  ],
  "_make_tabular_X": [
    "n_instances",
    "n_columns",
    "return_numpy",
    "random_state"
  ],
  "_compare_nested_frame": [
    "func",
    "x",
    "y"
  ],
  "_assert_array_almost_equal": [
    "x",
    "y",
    "decimal",
    "err_msg"
  ],
  "_assert_array_equal": [
    "x",
    "y",
    "err_msg"
  ],
  "_get_args": [
    "function",
    "varargs"
  ],
  "_has_capability": [
    "est",
    "method"
  ],
  "_get_n_columns": [
    "tag"
  ],
  "_get_expected_index_for_update_predict": [
    "y",
    "fh",
    "step_length",
    "initial_window"
  ],
  "_generate_polynomial_series": [
    "n",
    "order",
    "coefs"
  ],
  "make_forecasting_problem": [
    "n_timepoints",
    "all_positive",
    "index_type",
    "make_X",
    "n_columns",
    "random_state"
  ],
  "_assert_correct_pred_time_index": [
    "y_pred_index",
    "cutoff",
    "fh"
  ],
  "_assert_correct_columns": [
    "y_pred",
    "y_train"
  ],
  "_make_fh": [
    "cutoff",
    "steps",
    "fh_type",
    "is_relative"
  ],
  "scenarios": [],
  "retrieve_scenarios": [
    "obj",
    "filter_tags"
  ],
  "_check_tag_cond": [
    "obj",
    "filter_tags"
  ],
  "_make_series": [
    "n_timepoints",
    "n_columns",
    "all_positive",
    "index_type",
    "return_numpy",
    "random_state",
    "add_nan",
    "return_mtype"
  ],
  "_make_index": [
    "n_timepoints",
    "index_type"
  ],
  "RAND_SEED": [],
  "ForecasterTestScenario": {
    "is_applicable": [
      "self",
      "obj"
    ],
    "get_args": [
      "self",
      "key",
      "obj",
      "deepcopy_args"
    ]
  },
  "ForecasterFitPredictUnivariateNoX": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictUnivariateNoXEarlyFh": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictUnivariateNoXLateFh": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictUnivariateNoXLongFh": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictUnivariateWithX": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictUnivariateWithXLongFh": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictMultivariateNoX": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictMultivariateWithX": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictPanelSimple": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ForecasterFitPredictHierarchicalSimple": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "forecasting_scenarios_simple": [],
  "forecasting_scenarios_extended": [],
  "scenarios_forecasting": [],
  "RAND_SD2": [],
  "get_tag": [
    "obj",
    "tag_name"
  ],
  "ParamFitterTestScenario": {
    "is_applicable": [
      "self",
      "obj"
    ]
  },
  "ParamFitterUnivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ParamFitterMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ParamFitterPairwiseUnivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_param_est": [],
  "ClustererTestScenario": {
    "get_args": [
      "self",
      "key",
      "obj",
      "deepcopy_args"
    ],
    "is_applicable": [
      "self",
      "obj"
    ]
  },
  "ClustererFitPredict": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ClustererFitPredictOutOfSample": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "ClustererFitPredictUnequalLength": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClustererFitPredictUnequalLengthOutOfSample": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClustererFitPredictMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "scenarios_clustering": [],
  "make_detection_problem": [
    "n_timepoints",
    "all_positive",
    "index_type",
    "make_X",
    "n_columns",
    "random_state",
    "estimator_type"
  ],
  "AlignerTestScenario": {},
  "AlignerPairwiseMultivariateEqual": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "AlignerPairwiseUnivariateUnequal": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "AlignerMultipleUnivariateUnequal": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_aligners": [],
  "FixtureGenerationError": {
    "__init__": [
      "self",
      "fixture_name",
      "err"
    ]
  },
  "create_conditional_fixtures_and_names": [
    "test_name",
    "fixture_vars",
    "generator_dict",
    "fixture_sequence",
    "raise_exceptions",
    "deepcopy_fixtures"
  ],
  "_check_list_of_str": [
    "obj",
    "name"
  ],
  "_remove_single": [
    "x"
  ],
  "TransformerPairwiseTestScenario": {},
  "TransformerPairwisePanelTestScenario": {},
  "TransformerPairwiseTransformSymm": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerPairwiseTransformAsymm": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerPairwiseTransformNumpy": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_transformers_pairwise": [],
  "TransformerPairwisePanelTransformSymm": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerPairwisePanelTransformAsymm": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerPairwisePanelTransformListdf": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerPairwisePanelTransformNumpy": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_transformers_pairwise_panel": [],
  "OLD_MIXINS": [],
  "OLD_PANEL_MIXINS": [],
  "RAND_SEED2": [],
  "N_T": [],
  "_is_child_of": [
    "obj",
    "class_or_tuple"
  ],
  "TransformerTestScenario": {
    "is_applicable": [
      "self",
      "obj"
    ],
    "get_args": [
      "self",
      "key",
      "obj",
      "deepcopy_args"
    ]
  },
  "TransformerFitTransformSeriesUnivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformSeriesMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformSeriesUnivariateWithY": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformPanelUnivariateNumpyWithClassYOnlyFit": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformPanelUnivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformPanelMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformPanelUnivariateWithClassY": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformPanelUnivariateWithClassYOnlyFit": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformHierarchicalUnivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "TransformerFitTransformHierarchicalMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_transformers": [],
  "_make_panel": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "y",
    "all_positive",
    "random_state",
    "return_mtype"
  ],
  "_make_panel_X": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "y",
    "all_positive",
    "return_numpy",
    "random_state"
  ],
  "_make_regression_y": [
    "n_instances",
    "return_numpy",
    "random_state"
  ],
  "_make_classification_y": [
    "n_instances",
    "n_classes",
    "return_numpy",
    "random_state"
  ],
  "make_classification_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "n_classes",
    "return_numpy",
    "random_state"
  ],
  "make_regression_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "return_numpy",
    "random_state"
  ],
  "make_clustering_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "return_numpy",
    "random_state"
  ],
  "make_transformer_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "return_numpy",
    "random_state",
    "panel"
  ],
  "_make_nested_from_array": [
    "array",
    "n_instances",
    "n_columns"
  ],
  "DetectorTestScenario": {
    "is_applicable": [
      "self",
      "obj"
    ]
  },
  "DetectorUnivariateSimple": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": []
  },
  "scenarios_detectors": [],
  "_make_hierarchical": [
    "hierarchy_levels",
    "max_timepoints",
    "min_timepoints",
    "same_cutoff",
    "n_columns",
    "all_positive",
    "index_type",
    "random_state",
    "add_nan"
  ],
  "_bottom_hier_datagen": [
    "no_levels",
    "no_bottom_nodes",
    "intercept_max",
    "coef_1_max",
    "coef_2_max",
    "random_seed",
    "length"
  ],
  "_sample_node": [
    "index_table",
    "level",
    "sampler"
  ],
  "TestScenario": {
    "__init__": [
      "self",
      "args",
      "default_method_sequence",
      "default_arg_sequence"
    ],
    "get_args": [
      "self",
      "key",
      "obj",
      "deepcopy_args"
    ],
    "run": [
      "self",
      "obj",
      "method_sequence",
      "arg_sequence",
      "return_all",
      "return_args",
      "deepcopy_return"
    ],
    "is_applicable": [
      "self",
      "obj"
    ]
  },
  "_check_dict_of_dict": [
    "obj",
    "name"
  ],
  "ClassifierTestScenario": {
    "get_args": [
      "self",
      "key",
      "obj",
      "deepcopy_args"
    ],
    "is_applicable": [
      "self",
      "obj"
    ]
  },
  "ClassifierFitPredict": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClassifierFitPredictThreeClasses": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClassifierFitPredictNumpy": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClassifierFitPredictMultivariate": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "ClassifierFitPredictUnequalLength": {
    "_tags": [],
    "args": [
      "self"
    ],
    "default_method_sequence": [],
    "default_arg_sequence": []
  },
  "scenarios_classification": [],
  "scenarios_early_classification": [],
  "scenarios_regression": [],
  "MockTestedClass": {
    "__init__": [
      "self",
      "a"
    ],
    "foo": [
      "self",
      "b"
    ],
    "bar": [
      "self",
      "c",
      "d"
    ],
    "baz": [
      "cls"
    ]
  },
  "test_testscenario_object_args_only": [],
  "test_testscenario_object_default_method_sequence": [],
  "test_testscenario_object_default_arg_sequence": [],
  "test_testscenario_object_return_all": [],
  "test_testscenario_object_multi_call_defaults": [],
  "test_testscenario_object_multi_call_in_run": [],
  "test_testscenario_class_full_options": [],
  "test_testscenario_class_simple": [],
  "test_make_forecasting_problem": [
    "n_timepoints"
  ],
  "_check_X_y_pandas": [
    "X",
    "y",
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "_check_X_y_numpy": [
    "X",
    "y",
    "n_instances",
    "n_columns",
    "n_timepoints"
  ],
  "_check_X_y": [
    "X",
    "y",
    "n_instances",
    "n_columns",
    "n_timepoints",
    "check_numpy"
  ],
  "MTYPES": [],
  "test_make_panel": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "return_mtype"
  ],
  "test_make_classification_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "n_classes",
    "return_numpy"
  ],
  "test_make_regression_problem": [
    "n_instances",
    "n_columns",
    "n_timepoints",
    "return_numpy"
  ],
  "test_check_soft_dependencies_raises_error": [],
  "estimator_class": [
    "request"
  ],
  "test_get_scenarios_for_class": [
    "estimator_class"
  ],
  "test_get_scenarios_for_string": [
    "scitype_string"
  ],
  "test_get_scenarios_errors": [],
  "_MockEstimatorMixin": {
    "log": [
      "self"
    ],
    "add_log_item": [
      "self",
      "value"
    ]
  },
  "_method_logger": [
    "method"
  ],
  "make_mock_estimator": [
    "estimator_class",
    "method_regex"
  ],
  "construct_dispatch": [
    "cls",
    "params"
  ],
  "MockUnivariateForecasterLogger": {
    "_tags": [],
    "__init__": [
      "self",
      "prediction_constant"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ]
  },
  "MockForecaster": {
    "_tags": [],
    "__init__": [
      "self",
      "prediction_constant"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_predict": [
      "self",
      "fh",
      "X"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "_predict_quantiles": [
      "self",
      "fh",
      "X",
      "alpha"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "y_frame": [],
  "X_series_train": [],
  "X_series_pred": [],
  "X_frame_train": [],
  "X_frame_pred": [],
  "fh_absolute": [],
  "fh_relative": [],
  "test_mock_univariate_forecaster_log": [
    "y",
    "X_train",
    "X_pred",
    "fh"
  ],
  "test_mixin": [
    "base"
  ],
  "test_add_log_item": [],
  "test_log_is_property": [],
  "test_method_logger_exception": [],
  "test_method_logger": [],
  "test_make_mock_estimator": [
    "estimator_class",
    "method_regex",
    "logged_methods"
  ],
  "test_make_mock_estimator_with_kwargs": [
    "estimator_class",
    "estimator_kwargs"
  ],
  "_should_run": [],
  "square": [
    "x"
  ],
  "test_parallelize_simple_loop": [
    "fixture"
  ],
  "_TestSingleton": {
    "__init__": [
      "self",
      "a"
    ],
    "set_b": [
      "self",
      "b"
    ]
  },
  "_TestMultiton": {
    "__init__": [
      "self",
      "key",
      "a"
    ],
    "set_b": [
      "self",
      "b"
    ]
  },
  "test_singleton": [],
  "test_multiton": [],
  "ALLOW_NUMPY": [],
  "series_to_plot": [
    "request"
  ],
  "invalid_input_types": [
    "request"
  ],
  "univariate_plots": [],
  "_plot_series": [
    "series",
    "ax"
  ],
  "all_plots": [],
  "valid_data_types": [],
  "test_plot_series_runs_without_error": [
    "series_to_plot"
  ],
  "test_plot_series_invalid_input_type_raises_error": [
    "invalid_input_types",
    "valid_data_types"
  ],
  "test_plot_series_with_unequal_index_type_raises_error": [],
  "test_plot_series_invalid_marker_kwarg_len_raises_error": [
    "series_to_plot"
  ],
  "test_plot_series_invalid_label_kwarg_len_raises_error": [
    "series_to_plot"
  ],
  "test_plot_series_output_type": [
    "series_to_plot"
  ],
  "test_plot_series_uniform_treatment_of_int64_range_index_types": [],
  "test_plot_series_interval": [],
  "test_univariate_plots_run_without_error": [
    "y_airline",
    "plot_func"
  ],
  "test_univariate_plots_invalid_input_type_raises_error": [
    "invalid_input_types",
    "plot_func",
    "valid_data_types"
  ],
  "test_univariate_plots_output_type": [
    "y_airline",
    "plot_func"
  ],
  "test_plot_lags_arguments": [
    "y_airline",
    "lags",
    "suptitle"
  ],
  "test_plot_correlations_arguments": [
    "y_airline",
    "lags",
    "suptitle",
    "series_title"
  ],
  "test_plotting_dataframe_with_unused_levels": [],
  "test_plotting_basic_dataframe": [],
  "NK_FIXTURES": [],
  "SEED_FIXTURES": [],
  "test_partition": [
    "n",
    "k"
  ],
  "test_seed": [
    "n",
    "k",
    "seed"
  ],
  "test_stratified_resample": [],
  "EXAMPLE_CLASSES": [],
  "EXAMPLE_INSTANCES": [],
  "test_check_estimator_passed": [
    "estimator_class"
  ],
  "_check_none_failed_and_only_few_skipped": [
    "result"
  ],
  "test_check_estimator_does_not_raise": [
    "estimator_class"
  ],
  "test_check_estimator_subset_tests": [],
  "test_get_test_names": [],
  "test_parametrize_with_checks_objects": [
    "obj",
    "test_name"
  ],
  "test_parametrize_with_checks_instances": [
    "foo",
    "bar"
  ],
  "model_path": [
    "tmp_path"
  ],
  "mock_s3_bucket": [],
  "sktime_custom_env": [
    "tmp_path"
  ],
  "test_data_airline": [],
  "test_data_longley": [],
  "test_data_arrow_head": [],
  "auto_arima_model": [
    "test_data_airline"
  ],
  "cnn_model": [
    "test_data_arrow_head"
  ],
  "naive_forecaster_model_with_regressor": [
    "test_data_longley"
  ],
  "test_auto_arima_model_save_and_load": [
    "auto_arima_model",
    "model_path",
    "serialization_format"
  ],
  "test_auto_arima_model_pyfunc_output": [
    "auto_arima_model",
    "model_path",
    "serialization_format"
  ],
  "test_cnn_model_save_and_load": [
    "cnn_model",
    "test_data_arrow_head",
    "model_path",
    "serialization_format"
  ],
  "test_auto_arima_model_pyfunc_with_params_output": [
    "auto_arima_model",
    "model_path"
  ],
  "test_auto_arima_model_pyfunc_without_params_output": [
    "auto_arima_model",
    "model_path"
  ],
  "test_auto_arima_model_pyfunc_without_conf_output": [
    "auto_arima_model",
    "model_path"
  ],
  "test_naive_forecaster_model_with_regressor_pyfunc_output": [
    "naive_forecaster_model_with_regressor",
    "model_path",
    "test_data_longley"
  ],
  "test_signature_and_examples_saved_correctly": [
    "auto_arima_model",
    "test_data_airline",
    "model_path",
    "use_signature",
    "use_example"
  ],
  "test_predict_var_signature_saved_correctly": [
    "auto_arima_model",
    "test_data_airline",
    "model_path",
    "use_signature"
  ],
  "test_signature_and_example_for_pyfunc_predict": [
    "auto_arima_model",
    "model_path",
    "test_data_airline",
    "use_signature",
    "use_example"
  ],
  "test_load_from_remote_uri_succeeds": [
    "auto_arima_model",
    "model_path",
    "mock_s3_bucket"
  ],
  "test_log_model": [
    "auto_arima_model",
    "tmp_path",
    "should_start_run",
    "serialization_format"
  ],
  "test_log_model_calls_register_model": [
    "auto_arima_model",
    "tmp_path"
  ],
  "test_log_model_no_registered_model_name": [
    "auto_arima_model",
    "tmp_path"
  ],
  "test_pyfunc_raises_invalid_attribute_type": [
    "auto_arima_model",
    "model_path"
  ],
  "test_pyfunc_raises_invalid_dict_key": [
    "auto_arima_model",
    "model_path"
  ],
  "test_pyfunc_raises_invalid_dict_value_type": [
    "auto_arima_model",
    "model_path"
  ],
  "test_pyfunc_raises_invalid_dict_value": [
    "auto_arima_model",
    "model_path"
  ],
  "test_pyfunc_predict_proba_raises_invalid_attribute_type": [
    "auto_arima_model",
    "model_path"
  ],
  "test_pyfunc_predict_proba_raises_invalid_dict_value": [
    "auto_arima_model",
    "model_path"
  ],
  "test_all_functions": [],
  "test_all_classes": [],
  "test_custom_showwarning_no_recursion": [],
  "test_pivot_sp": [
    "sp",
    "index_type",
    "n_timepoints",
    "anchor_side"
  ],
  "test_unpivot_sp": [
    "sp",
    "index_type",
    "n_timepoints",
    "anchor_side"
  ],
  "test_pivot_sp_consistent": [
    "sp",
    "index_type",
    "n_timepoints",
    "anchor_side"
  ],
  "test_doc_link_generator": [
    "mock_version"
  ],
  "test_get_doc_link": [],
  "test_ray_leaves_params_invariant": [],
  "test_time_series_slope_against_scipy_linregress": [
    "trend_order"
  ],
  "test_time_series_slope_against_simple_cases": [
    "slope"
  ],
  "test_fit_remove_add_trend": [
    "order",
    "n_instances",
    "n_timepoints"
  ],
  "test_flatten_multiindex": [],
  "test_rename_multiindex": [],
  "test_apply_split": [],
  "test_is_hierarchical": [],
  "test_get_freq": [],
  "test_infer_freq": [],
  "test_set_freq_hier": [],
  "_safe_import": [
    "import_path",
    "pkg_name"
  ],
  "CommonMagicMeta": {
    "__getattr__": [
      "cls",
      "name"
    ],
    "__setattr__": [
      "cls",
      "name",
      "value"
    ]
  },
  "MagicAttribute": {
    "__getattr__": [
      "self",
      "name"
    ],
    "__setattr__": [
      "self",
      "name",
      "value"
    ],
    "__call__": [
      "self"
    ]
  },
  "_create_mock_class": [
    "name",
    "bases"
  ],
  "_isinstance_by_name": [
    "obj",
    "cls_name"
  ],
  "_check_soft_dependencies": [],
  "_check_dl_dependencies": [
    "msg",
    "severity"
  ],
  "_check_mlflow_dependencies": [
    "msg",
    "severity"
  ],
  "_get_installed_packages_private": [],
  "_get_installed_packages": [],
  "_get_pkg_version": [
    "package_name"
  ],
  "_check_python_version": [
    "obj",
    "package",
    "msg",
    "severity",
    "prereleases"
  ],
  "_check_env_marker": [
    "obj",
    "package",
    "msg",
    "severity"
  ],
  "_check_estimator_deps": [
    "obj",
    "msg",
    "severity"
  ],
  "_normalize_requirement": [
    "req"
  ],
  "_normalize_version": [
    "version"
  ],
  "_raise_at_severity": [
    "msg",
    "severity",
    "exception_type",
    "warning_type",
    "stacklevel",
    "caller"
  ],
  "_placeholder_record": [
    "module_name",
    "obj_name",
    "dependencies",
    "condition"
  ],
  "_attempt_import": [
    "module_name",
    "obj_name"
  ],
  "test_import_present_module": [],
  "test_import_missing_module": [],
  "test_import_without_pkg_name": [],
  "test_import_with_different_pkg_name_1": [],
  "test_import_with_different_pkg_name_2": [],
  "test_import_submodule": [],
  "test_import_class": [],
  "test_import_existing_object": [],
  "test_multiple_inheritance_from_mock": [],
  "test_soft_dependency_chains": [],
  "test_safe_import_pkg_with_different_name": [],
  "test_check_soft_dependencies": [],
  "_check_reg_targets": [
    "y_true",
    "y_pred",
    "multioutput",
    "dtype",
    "xp"
  ],
  "_check_reg_targets_post_16": [
    "y_true",
    "y_pred",
    "multioutput",
    "dtype",
    "xp"
  ],
  "_check_reg_targets_pre16": [
    "y_true",
    "y_pred",
    "multioutput",
    "dtype"
  ],
  "prep_skl_df": [
    "df",
    "copy_df"
  ],
  "_SklVersionBridgeMixin": {
    "_sklearn_15_or_lower": [
      "self"
    ],
    "_validate_data_version_safe": [
      "self"
    ]
  },
  "is_in_sklearn": [
    "obj"
  ],
  "is_sklearn_object": [
    "obj"
  ],
  "is_sklearn_estimator": [
    "obj"
  ],
  "mixin_to_scitype": [],
  "sklearn_scitype": [
    "obj",
    "var_name"
  ],
  "is_sklearn_transformer": [
    "obj"
  ],
  "is_sklearn_classifier": [
    "obj"
  ],
  "is_sklearn_regressor": [
    "obj"
  ],
  "is_sklearn_clusterer": [
    "obj"
  ],
  "is_sklearn_splitter": [
    "obj"
  ],
  "is_sklearn_metric": [
    "obj",
    "return_type"
  ],
  "get_sklearn_tag": [
    "estimator",
    "tagname"
  ],
  "test_prep_skl_df_coercion": [
    "copy_df"
  ],
  "test_prep_skl_df_non_coercion": [
    "copy_df"
  ],
  "CORRECT_SCITYPES": [],
  "sklearn_estimators": [],
  "sktime_estimators": [],
  "test_is_sklearn_estimator_positive": [
    "estimator"
  ],
  "test_is_sklearn_estimator_negative": [
    "estimator"
  ],
  "test_sklearn_scitype": [
    "estimator"
  ],
  "deep_equals": [
    "x",
    "y",
    "return_msg",
    "plugins"
  ],
  "_fh_equals_plugin": [
    "x",
    "y",
    "return_msg",
    "deep_equals"
  ],
  "_csr_matrix_equals_plugin": [
    "x",
    "y",
    "return_msg",
    "deep_equals"
  ],
  "_dask_dataframe_equals_plugin": [
    "x",
    "y",
    "return_msg",
    "deep_equals"
  ],
  "_gluonts_PandasDataset_equals_plugin": [
    "x",
    "y",
    "return_msg",
    "deep_equals"
  ],
  "_polars_equals_plugin": [
    "x",
    "y",
    "return_msg"
  ],
  "EXAMPLES": [],
  "test_deep_equals_positive": [
    "fixture"
  ],
  "n": [],
  "DIFFERENT_PAIRS": [],
  "test_deep_equals_negative": [
    "fixture1",
    "fixture2"
  ],
  "_safe_call": [
    "method",
    "args",
    "kwargs"
  ],
  "_method_has_arg": [
    "method",
    "arg"
  ],
  "_method_has_param_and_default": [
    "method",
    "arg"
  ],
  "_clone_fitted_params": [
    "to_obj",
    "from_obj",
    "overwrite"
  ],
  "_get_fitted_params_safe": [
    "obj"
  ],
  "mean": [
    "X"
  ],
  "row_mean": [
    "X"
  ],
  "count_mean_crossing": [
    "X"
  ],
  "row_count_mean_crossing": [
    "X"
  ],
  "count_above_mean": [
    "X"
  ],
  "row_count_above_mean": [
    "X"
  ],
  "median": [
    "X"
  ],
  "row_median": [
    "X"
  ],
  "std": [
    "X"
  ],
  "std2": [
    "X",
    "X_mean"
  ],
  "row_std": [
    "X"
  ],
  "numba_min": [
    "X"
  ],
  "row_numba_min": [
    "X"
  ],
  "numba_max": [
    "X"
  ],
  "row_numba_max": [
    "X"
  ],
  "slope": [
    "X"
  ],
  "row_slope": [
    "X"
  ],
  "iqr": [
    "X"
  ],
  "row_iqr": [
    "X"
  ],
  "ppv": [
    "X"
  ],
  "row_ppv": [
    "X"
  ],
  "fisher_score": [
    "X",
    "y"
  ],
  "unique_count": [
    "X"
  ],
  "first_order_differences": [
    "X"
  ],
  "row_first_order_differences": [
    "X"
  ],
  "z_normalise_series": [
    "X"
  ],
  "z_normalise_series_2d": [
    "X"
  ],
  "z_normalise_series_3d": [
    "X"
  ],
  "DATATYPES": [],
  "test_z_normalise_series": [
    "type"
  ],
  "_get_sys_info": [],
  "DEFAULT_DEPS_TO_SHOW": [],
  "_get_deps_info": [
    "deps",
    "source"
  ],
  "show_versions": [],
  "test_show_versions_runs": [],
  "test_deps_info": [],
  "test_deps_info_deps_missing_package_present_directory": [],
  "VALID_CUTOFF_TYPES": [],
  "check_y_X": [
    "y",
    "X",
    "allow_empty",
    "allow_constant",
    "enforce_index_type"
  ],
  "check_X": [
    "X",
    "allow_empty",
    "enforce_univariate",
    "enforce_index_type"
  ],
  "check_y": [
    "y",
    "allow_empty",
    "allow_constant",
    "enforce_index_type"
  ],
  "check_cv": [
    "cv",
    "enforce_start_with_window"
  ],
  "check_step_length": [
    "step_length"
  ],
  "check_sp": [
    "sp",
    "enforce_list"
  ],
  "check_fh": [
    "fh",
    "enforce_relative",
    "freq"
  ],
  "check_alpha": [
    "alpha",
    "name"
  ],
  "check_cutoffs": [
    "cutoffs"
  ],
  "check_scoring": [
    "scoring",
    "allow_y_pred_benchmark",
    "obj"
  ],
  "check_regressor": [
    "regressor",
    "random_state"
  ],
  "check_interval_df": [
    "interval_df",
    "index_to_match"
  ],
  "VALID_DATA_TYPES": [],
  "RELATIVE_INDEX_TYPES": [],
  "ABSOLUTE_INDEX_TYPES": [],
  "is_integer_index": [
    "x"
  ],
  "is_in_valid_index_types": [
    "x"
  ],
  "is_in_valid_relative_index_types": [
    "x"
  ],
  "is_in_valid_absolute_index_types": [
    "x"
  ],
  "_check_is_univariate": [
    "y",
    "var_name"
  ],
  "_check_is_multivariate": [
    "Z",
    "var_name"
  ],
  "check_series": [
    "Z",
    "enforce_univariate",
    "enforce_multivariate",
    "allow_empty",
    "allow_numpy",
    "allow_None",
    "enforce_index_type",
    "allow_index_names",
    "var_name"
  ],
  "check_time_index": [
    "index",
    "allow_empty",
    "enforce_index_type",
    "var_name"
  ],
  "check_equal_time_index": [],
  "check_consistent_index_type": [
    "a",
    "b"
  ],
  "ACCEPTED_DATETIME_TYPES": [],
  "ACCEPTED_TIMEDELTA_TYPES": [],
  "ACCEPTED_DATEOFFSET_TYPES": [],
  "ACCEPTED_WINDOW_LENGTH_TYPES": [],
  "NON_FLOAT_WINDOW_LENGTH_TYPES": [],
  "is_array": [
    "x"
  ],
  "is_int": [
    "x"
  ],
  "is_float": [
    "x"
  ],
  "is_timedelta": [
    "x"
  ],
  "is_datetime": [
    "x"
  ],
  "is_date_offset": [
    "x"
  ],
  "is_timedelta_or_date_offset": [
    "x"
  ],
  "array_is_int": [
    "x"
  ],
  "array_is_datetime64": [
    "x"
  ],
  "array_is_timedelta_or_date_offset": [
    "x"
  ],
  "is_iterable": [
    "x"
  ],
  "is_iloc_like": [
    "x"
  ],
  "is_time_like": [
    "x"
  ],
  "all_inputs_are_iloc_like": [
    "args"
  ],
  "all_inputs_are_time_like": [
    "args"
  ],
  "check_n_jobs": [
    "n_jobs"
  ],
  "check_window_length": [
    "window_length",
    "n_timepoints",
    "name"
  ],
  "check_fmt": [
    "fmt"
  ],
  "check_labels": [
    "labels"
  ],
  "check_task": [
    "task"
  ],
  "check_learning_type": [
    "learning_type"
  ],
  "VALID_X_TYPES": [],
  "VALID_Y_TYPES": [],
  "check_X_y": [
    "X",
    "y",
    "enforce_univariate",
    "enforce_min_instances",
    "enforce_min_columns",
    "coerce_to_numpy",
    "coerce_to_pandas"
  ],
  "_enforce_min_instances": [
    "x",
    "min_instances"
  ],
  "test_check_window_length": [
    "window_length",
    "n_timepoints",
    "expected"
  ],
  "test_window_length_bad_arg": [
    "window_length",
    "n_timepoints"
  ],
  "first_arrays": [],
  "second_arrays": [],
  "test_check_equal_time_index": [
    "first_array",
    "second_array"
  ],
  "empty_input": [],
  "test_check_fh_empty_input": [
    "arg"
  ],
  "test_check_X_bad_input_args": [
    "X"
  ],
  "test_check_enforce_min_instances": [],
  "test_check_X_enforce_univariate": [],
  "test_check_X_enforce_min_columns": [],
  "BaseClusterer": {
    "_tags": [],
    "__init__": [
      "self",
      "n_clusters"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_check_capabilities": [
      "self",
      "missing",
      "multivariate",
      "unequal"
    ],
    "_initial_conversion": [
      "X"
    ],
    "_check_clusterer_input": [
      "self",
      "X",
      "enforce_min_instances"
    ]
  },
  "TimeSeriesKShapes": {
    "_tags": [],
    "_estimator_attr": [],
    "__init__": [
      "self",
      "n_clusters",
      "init_algorithm",
      "n_init",
      "max_iter",
      "tol",
      "verbose",
      "random_state"
    ],
    "_get_tslearn_class": [
      "self"
    ],
    "_get_tslearn_object": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ]
  },
  "TimeSeriesKMedoids": {
    "_tags": [],
    "__init__": [
      "self",
      "n_clusters",
      "init_algorithm",
      "metric",
      "n_init",
      "max_iter",
      "tol",
      "verbose",
      "random_state",
      "distance_params"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_compute_new_cluster_centers": [
      "self",
      "X",
      "assignment_indexes"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesKernelKMeans": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_clusters",
      "kernel",
      "n_init",
      "max_iter",
      "tol",
      "kernel_params",
      "verbose",
      "n_jobs",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ]
  },
  "TimeSeriesDBSCAN": {
    "_tags": [],
    "DELEGATED_PARAMS": [],
    "DELEGATED_FITTED_PARAMS": [],
    "__init__": [
      "self",
      "distance",
      "eps",
      "min_samples",
      "algorithm",
      "leaf_size",
      "distance_params",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesKvisibility": {
    "_tags": [],
    "DELEGATED_PARAMS": [],
    "DELEGATED_FITTED_PARAMS": [],
    "__init__": [
      "self",
      "n_clusters",
      "init",
      "n_init"
    ],
    "_ts_to_graph": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_fit_predict": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "STDBSCAN": {
    "_tags": [],
    "DELEGATED_FITTED_PARAMS": [],
    "__init__": [
      "self",
      "eps1",
      "eps2",
      "min_samples",
      "metric",
      "sparse_matrix_threshold",
      "frame_size",
      "frame_overlap",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_fit_one_frame": [
      "self",
      "X"
    ],
    "_fit_dense": [
      "self",
      "X"
    ],
    "_fit_sparse": [
      "self",
      "X"
    ],
    "_fit_frame_split": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_forgy_center_initializer": [
    "X",
    "n_clusters",
    "random_state"
  ],
  "_random_center_initializer": [
    "X",
    "n_clusters",
    "random_state"
  ],
  "_kmeans_plus_plus": [
    "X",
    "n_clusters",
    "random_state",
    "distance_metric",
    "n_local_trials",
    "distance_params"
  ],
  "BaseTimeSeriesLloyds": {
    "_tags": [],
    "_init_algorithms": [],
    "__init__": [
      "self",
      "n_clusters",
      "init_algorithm",
      "metric",
      "n_init",
      "max_iter",
      "tol",
      "verbose",
      "random_state",
      "distance_params"
    ],
    "_check_params": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "_fit_one_init": [
      "self",
      "X"
    ],
    "_assign_clusters": [
      "self",
      "X",
      "cluster_centres"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "_compute_new_cluster_centers": [
      "self",
      "X",
      "assignment_indexes"
    ]
  },
  "ClustererFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllClusterers": {
    "test_multivariate_input_exception": [
      "self",
      "estimator_instance"
    ],
    "test_clusterer_output": [
      "self",
      "estimator_instance",
      "scenario"
    ]
  },
  "expected_results": [],
  "expected_score": [],
  "expected_iters": [],
  "expected_labels": [],
  "test_kernel_k_means": [],
  "expected_train_result": [],
  "test_kmeans": [],
  "test_kmeans_dba": [],
  "_test_class": {
    "_compute_new_cluster_centers": [
      "self",
      "X",
      "assignment_indexes"
    ],
    "__init__": [
      "self"
    ]
  },
  "test_lloyds": [],
  "CENTER_INIT_ALGO": [],
  "test_center_init": [
    "center_init_callable"
  ],
  "inertia": [],
  "test_kshapes": [],
  "train_expected_score": [],
  "expected_inertia": [],
  "test_kmedoids": [],
  "_rename_labels": [
    "X",
    "centers_origin",
    "y_pred",
    "n_labels"
  ],
  "test_st_dbscan": [
    "n_times",
    "sparse_matrix_threshold",
    "n_jobs"
  ],
  "test_st_dbscan_data_not_sorted_by_time": [],
  "test_st_dbscan_frame_split": [
    "n_times",
    "frame_size",
    "frame_overlap"
  ],
  "test_st_dbscan_data_with_noise": [
    "frame_size",
    "sparse_matrix_threshold"
  ],
  "test_medoids": [],
  "expected_dba": [],
  "test_dba": [],
  "medoids": [
    "X",
    "precomputed_pairwise_distance",
    "distance_metric"
  ],
  "mean_average": [
    "X"
  ],
  "_AVERAGE_DICT": [],
  "_resolve_average_callable": [
    "averaging_method"
  ],
  "dba": [
    "X",
    "max_iters",
    "tol",
    "averaging_distance_metric",
    "medoids_distance_metric",
    "precomputed_medoids_pairwise_distance",
    "verbose"
  ],
  "_dba_update": [
    "center",
    "X",
    "path_callable"
  ],
  "TimeSeriesKMeans": {
    "_tags": [],
    "__init__": [
      "self",
      "n_clusters",
      "init_algorithm",
      "metric",
      "n_init",
      "max_iter",
      "tol",
      "verbose",
      "random_state",
      "averaging_method",
      "distance_params",
      "average_params"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_compute_new_cluster_centers": [
      "self",
      "X",
      "assignment_indexes"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesKMeansTslearn": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_clusters",
      "max_iter",
      "tol",
      "n_init",
      "metric",
      "max_iter_barycenter",
      "metric_params",
      "n_jobs",
      "dtw_inertia",
      "verbose",
      "random_state",
      "init"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ]
  },
  "ClustererPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "clusterer",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SklearnClustererPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "clusterer",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_convert_X_to_sklearn": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ClustererAsTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "clusterer"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_map_hier_to_panel": [
      "self",
      "X"
    ],
    "_map_primitive_to_hier_idx": [
      "self",
      "X",
      "mapping"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_plot": [
    "cluster_values",
    "center",
    "axes"
  ],
  "_get_cluster_values": [
    "cluster_indexes",
    "X",
    "k"
  ],
  "plot_cluster_algorithm": [
    "model",
    "X",
    "k"
  ],
  "make_moving_blobs": [
    "n_times",
    "n_samples",
    "cluster_std",
    "random_state",
    "centers_origin",
    "movement_mode",
    "movement_speed"
  ],
  "BaseClassifier": {
    "_tags": [],
    "METADATA_REQ_IN_CHECKS": [],
    "VECTORIZATION_ATTR": [],
    "TASK": [],
    "EST_TYPE": [],
    "EST_TYPE_PLURAL": [],
    "__init__": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "cv",
      "change_state"
    ],
    "fit_predict_proba": [
      "self",
      "X",
      "y",
      "cv",
      "change_state"
    ],
    "_single_class_y_pred": [
      "self",
      "X",
      "method"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ]
  },
  "_DelegatedClassifier": {
    "_delegate_name": [],
    "_get_delegate": [
      "self"
    ],
    "_set_delegated_tags": [
      "self",
      "delegate"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "DummyClassifier": {
    "_tags": [],
    "VALID_STRATEGIES": [],
    "__init__": [
      "self",
      "strategy",
      "random_state",
      "constant"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_dummy_classifier": [],
  "accelerate": [],
  "CrossEntropyLoss": [],
  "Adam": [],
  "OneCycleLR": [],
  "MomentFMClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "pretrained_model_name_or_path",
      "head_dropout",
      "batch_size",
      "eval_batch_size",
      "epochs",
      "max_lr",
      "device",
      "pct_start",
      "max_norm",
      "train_val_split",
      "config",
      "to_cpu_after_fit"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_transform_labels": [
    "y",
    "y_test"
  ],
  "MomentFMClassifierPytorchDataset": {
    "__init__": [
      "self",
      "y",
      "X",
      "device"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "TimeSeriesForestClassifier": {
    "_feature_types": [],
    "_base_estimator": [],
    "_tags": [],
    "__init__": [
      "self",
      "min_interval",
      "n_estimators",
      "inner_series_length",
      "n_jobs",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "_extract_feature_importance_by_feature_type_per_tree": [
      "self",
      "tree_feature_importance",
      "feature_type"
    ],
    "feature_importances_": [
      "self"
    ]
  },
  "_predict_single_classifier_proba": [
    "X",
    "estimator",
    "intervals"
  ],
  "SupervisedTimeSeriesForest": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X",
      "intervals"
    ],
    "_get_intervals": [
      "self",
      "X",
      "y",
      "rng"
    ],
    "_supervised_interval_search": [
      "self",
      "X",
      "y",
      "function",
      "function_intervals",
      "classes",
      "class_counts",
      "start",
      "end"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "X_p",
      "X_d",
      "y",
      "balance_cases",
      "idx"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "X_p",
      "X_d",
      "intervals",
      "estimator"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_fisher_score": [
    "X",
    "y",
    "classes",
    "class_counts"
  ],
  "_parallel_build_trees": [
    "X",
    "y",
    "tree",
    "interval",
    "lag",
    "acf_min_values"
  ],
  "_predict_proba_for_estimator": [
    "X",
    "estimator",
    "interval",
    "lag"
  ],
  "_make_estimator": [
    "base_estimator",
    "random_state"
  ],
  "_select_interval": [
    "min_interval",
    "max_interval",
    "series_length",
    "rng",
    "method"
  ],
  "_produce_intervals": [
    "n_estimators",
    "min_interval",
    "max_interval",
    "series_length",
    "rng",
    "method"
  ],
  "RandomIntervalSpectralEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "max_interval",
      "min_interval",
      "acf_lag",
      "acf_min_values",
      "n_jobs",
      "random_state"
    ],
    "feature_importances_": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ps": [
    "x",
    "sign",
    "n",
    "pad"
  ],
  "CanonicalIntervalForest": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "n_intervals",
      "att_subsample_size",
      "min_interval",
      "max_interval",
      "base_estimator",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "y",
      "idx"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "classifier",
      "intervals",
      "dims",
      "atts"
    ],
    "_temporal_importance_curves": [
      "self",
      "normalise_time_points"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "acf": [
    "x",
    "max_lag"
  ],
  "matrix_acf": [
    "x",
    "num_cases",
    "max_lag"
  ],
  "_round_to_nearest_power_of_two": [
    "n"
  ],
  "DrCIF": {
    "_tags": [],
    "__init__": [
      "self",
      "n_estimators",
      "n_intervals",
      "att_subsample_size",
      "min_interval",
      "max_interval",
      "base_estimator",
      "time_limit_in_minutes",
      "contract_max_n_estimators",
      "save_transformed_data",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "X_p",
      "X_d",
      "y",
      "idx"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "X_p",
      "X_d",
      "classifier",
      "intervals",
      "dims",
      "atts"
    ],
    "_train_probas_for_estimator": [
      "self",
      "y",
      "idx"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TESTED_MODULE": [],
  "test_time_series_forest_classifier_feature_importance": [
    "extract_feature_importance_of_feature_mock",
    "n_estimators"
  ],
  "test__extract_feature_importance_by_feature_type_per_tree": [
    "number_of_intervals",
    "feature_type"
  ],
  "test_contracted_drcif": [],
  "Arsenal": {
    "_tags": [],
    "__init__": [
      "self",
      "num_kernels",
      "n_estimators",
      "rocket_transform",
      "max_dilations_per_kernel",
      "n_features_per_kernel",
      "time_limit_in_minutes",
      "contract_max_n_estimators",
      "save_transformed_data",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "_fit_estimator": [
      "self",
      "rocket",
      "X",
      "y"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "classifier",
      "idx"
    ],
    "_train_probas_for_estimator": [
      "self",
      "y",
      "idx"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesSVCTslearn": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "C",
      "kernel",
      "degree",
      "gamma",
      "coef0",
      "shrinking",
      "probability",
      "tol",
      "cache_size",
      "class_weight",
      "n_jobs",
      "verbose",
      "max_iter",
      "decision_function_shape",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RocketClassifier": {
    "_tags": [],
    "VALID_ROCKET_STRINGS": [],
    "VALID_MULTIVAR_VALUES": [],
    "__init__": [
      "self",
      "num_kernels",
      "rocket_transform",
      "max_dilations_per_kernel",
      "n_features_per_kernel",
      "use_multivariate",
      "n_jobs",
      "random_state"
    ],
    "estimator_": [
      "self"
    ],
    "_get_delegate": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesSVC": {
    "_tags": [],
    "DELEGATED_PARAMS": [],
    "__init__": [
      "self",
      "kernel",
      "kernel_params",
      "kernel_mtype",
      "C",
      "shrinking",
      "probability",
      "tol",
      "cache_size",
      "class_weight",
      "verbose",
      "max_iter",
      "decision_function_shape",
      "break_ties",
      "random_state"
    ],
    "_kernel": [
      "self",
      "X",
      "X2"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_contracted_arsenal": [],
  "KNeighborsTimeSeriesClassifierPyts": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_neighbors",
      "weights",
      "algorithm",
      "leaf_size",
      "p",
      "metric",
      "metric_params",
      "n_jobs"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "KNeighborsTimeSeriesClassifierTslearn": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_neighbors",
      "weights",
      "metric",
      "metric_params",
      "n_jobs",
      "verbose"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ElasticEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "distance_measures",
      "proportion_of_param_options",
      "proportion_train_in_param_finding",
      "proportion_train_for_test",
      "n_jobs",
      "random_state",
      "verbose",
      "majority_vote"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X",
      "return_preds_and_probas"
    ],
    "get_metric_params": [
      "self"
    ],
    "_get_100_param_options": [
      "distance_measure",
      "train_x",
      "data_dim_to_use"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_CachedTransformer": {
    "__init__": [
      "self",
      "transformer"
    ],
    "clear": [
      "self"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "__str__": [
      "self"
    ]
  },
  "_derivative_distance": [
    "distance_measure",
    "transformer"
  ],
  "distance_predefined_params": [
    "distance_measure"
  ],
  "numba_wrapper": [
    "distance_measure"
  ],
  "pure": [
    "y"
  ],
  "gini_gain": [
    "y",
    "y_subs"
  ],
  "gini": [
    "y"
  ],
  "dtw_distance_measure_getter": [
    "X"
  ],
  "msm_distance_measure_getter": [
    "X"
  ],
  "erp_distance_measure_getter": [
    "X"
  ],
  "lcss_distance_measure_getter": [
    "X"
  ],
  "wdtw_distance_measure_getter": [
    "X"
  ],
  "euclidean_distance_measure_getter": [
    "X"
  ],
  "setup_wddtw_distance_measure_getter": [
    "transformer"
  ],
  "setup_ddtw_distance_measure_getter": [
    "transformer"
  ],
  "pick_rand_param_perm_from_dict": [
    "param_pool",
    "random_state"
  ],
  "pick_rand_param_perm_from_list": [
    "params",
    "random_state"
  ],
  "TRANSFORMER": [],
  "DISTANCE_MEASURE_GETTERS": [],
  "ProximityStump": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "distance_measure",
      "verbosity",
      "n_jobs"
    ],
    "pick_distance_measure": [
      "self",
      "random_state"
    ],
    "_distance_to_exemplars_inst_wrapper": [
      "self",
      "exemplars",
      "instance",
      "distance_measure_seed",
      "X_for_measure"
    ],
    "_distance_to_exemplars_inst": [
      "exemplars",
      "instance",
      "distance_measure"
    ],
    "get_exemplars": [
      "self"
    ],
    "_distance_measure": [
      "self"
    ],
    "distance_to_exemplars": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "find_closest_exemplar_indices": [
      "self",
      "X"
    ],
    "grow": [
      "self"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ProximityTree": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "distance_measure",
      "max_depth",
      "is_leaf",
      "verbosity",
      "n_jobs",
      "n_stump_evaluations"
    ],
    "pick_distance_measure": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "find_stump": [
      "self"
    ],
    "get_exemplars": [
      "self"
    ],
    "_distance_measure": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ProximityForest": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "n_estimators",
      "distance_measure",
      "verbosity",
      "max_depth",
      "is_leaf",
      "n_jobs",
      "n_stump_evaluations"
    ],
    "pick_distance_measure": [
      "self"
    ],
    "_fit_tree": [
      "self",
      "X",
      "y",
      "index",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba_tree": [
      "X",
      "tree"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_exemplars": [
      "self"
    ],
    "_distance_measure": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "arg_bests": [
    "array",
    "comparator"
  ],
  "_pick_from_indices": [
    "array",
    "indices"
  ],
  "_bests": [
    "array",
    "comparator"
  ],
  "_mins": [
    "array",
    "getter"
  ],
  "maxs": [
    "array",
    "getter"
  ],
  "min": [
    "array",
    "rand",
    "getter"
  ],
  "_arg_max": [
    "array",
    "rand",
    "getter"
  ],
  "_max": [
    "array",
    "rand",
    "getter"
  ],
  "_best": [
    "array",
    "comparator",
    "rand"
  ],
  "_arg_best": [
    "array",
    "comparator",
    "rand"
  ],
  "_arg_min": [
    "array",
    "rand",
    "getter"
  ],
  "_arg_mins": [
    "array",
    "getter"
  ],
  "_arg_maxs": [
    "array",
    "getter"
  ],
  "_chain": [
    "func",
    "getter"
  ],
  "_more_than": [
    "a",
    "b"
  ],
  "_less_than": [
    "a",
    "b"
  ],
  "_negative_dataframe_indices": [
    "X"
  ],
  "_positive_dataframe_indices": [
    "X"
  ],
  "_stdp": [
    "X"
  ],
  "_bin_instances_by_class": [
    "X",
    "class_labels"
  ],
  "_max_instance_dimension_length": [
    "X",
    "dimension"
  ],
  "_max_instance_length": [
    "X"
  ],
  "KNeighborsTimeSeriesClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_neighbors",
      "weights",
      "algorithm",
      "distance",
      "distance_params",
      "distance_mtype",
      "pass_train_distances",
      "leaf_size",
      "n_jobs"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_predict_proba_dist": [
      "self",
      "X"
    ],
    "_predict_proba_precomp": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ShapeDTW": {
    "_tags": [],
    "__init__": [
      "self",
      "n_neighbors",
      "subsequence_length",
      "shape_descriptor_function",
      "shape_descriptor_functions",
      "metric_params",
      "n_splits"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_calculate_weighting_factor_value": [
      "self",
      "X",
      "y"
    ],
    "_preprocess": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_generate_shape_descriptors": [
      "self",
      "data"
    ],
    "_get_transformer": [
      "self",
      "tName"
    ],
    "_check_metric_params": [
      "self",
      "parameters"
    ],
    "_combine_data_frames": [
      "self",
      "dataFrames",
      "weighting_factor",
      "col_names"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "distance_functions": [],
  "expected_correct": [],
  "expected_correct_window": [],
  "test_knn_on_unit_test": [
    "distance_key"
  ],
  "test_knn_bounding_matrix": [
    "distance_key"
  ],
  "test_knn_with_aligner": [],
  "test_knn_with_aggrdistance": [],
  "test_knn_kneighbors": [],
  "plot_curves": [
    "curves",
    "curve_names",
    "top_curves_shown",
    "plot_mean"
  ],
  "plot_cif": [
    "cif",
    "normalise_time_points",
    "top_curves_shown",
    "plot_mean"
  ],
  "unit_test_proba": [],
  "basic_motions_proba": [],
  "DATA_ARGS": [],
  "CROSS_VALIDATION_METHODS": [],
  "PARAMETER_TUNING_METHODS": [],
  "test_sklearn_cross_validation": [
    "data_args"
  ],
  "test_sklearn_cross_validation_iterators": [
    "data_args",
    "cross_validation_method"
  ],
  "test_sklearn_parameter_tuning": [
    "data_args",
    "parameter_tuning_method"
  ],
  "test_sklearn_composite_classifiers": [
    "data_args",
    "composite_classifier"
  ],
  "_reproduce_classification_unit_test": [
    "estimator"
  ],
  "_reproduce_classification_basic_motions": [
    "estimator"
  ],
  "_reproduce_early_classification_unit_test": [
    "estimator"
  ],
  "_reproduce_transform_unit_test": [
    "estimator"
  ],
  "_reproduce_transform_basic_motions": [
    "estimator"
  ],
  "_print_array": [
    "test_name",
    "array"
  ],
  "_DummyClassifier": {
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ]
  },
  "_DummyComposite": {
    "__init__": [
      "self",
      "foo"
    ]
  },
  "_DummyDeepClassifierEmpty": {
    "__init__": [
      "self"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_DummyDeepClassifierFull": {
    "__init__": [
      "self",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_DummyHandlesAllInput": {
    "_tags": [],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ]
  },
  "_DummyConvertPandas": {
    "_tags": [],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ]
  },
  "multivariate_message": [],
  "missing_message": [],
  "unequal_message": [],
  "test_base_classifier_fit": [],
  "TF": [],
  "test_check_capabilities": [
    "missing",
    "multivariate",
    "unequal"
  ],
  "test_convert_input": [],
  "test__check_classifier_input": [],
  "_create_example_dataframe": [
    "cases",
    "dimensions",
    "length"
  ],
  "_create_nested_dataframe": [
    "cases",
    "dimensions",
    "length"
  ],
  "_create_unequal_length_nested_dataframe": [
    "cases",
    "dimensions",
    "length"
  ],
  "test_input_conversion_fit_predict": [
    "mtype"
  ],
  "test_fit_predict_change_state": [
    "method"
  ],
  "test_fit_predict_cv": [
    "method",
    "y_multivariate"
  ],
  "test_predict_single_class": [
    "method"
  ],
  "test_fit_predict_single_class": [
    "method",
    "cv"
  ],
  "test_deep_estimator_empty": [],
  "test_deep_estimator_full": [
    "optimizer"
  ],
  "DUMMY_EST_PARAMETERS_FOO": [],
  "test_save_estimator_using_cloudpickle": [
    "foo"
  ],
  "ClassifierFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllClassifiers": {
    "test_multivariate_input_exception": [
      "self",
      "estimator_instance"
    ],
    "test_classifier_output": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_classifier_on_unit_test_data": [
      "self",
      "estimator_class"
    ],
    "test_classifier_on_basic_motions": [
      "self",
      "estimator_class"
    ],
    "test_handles_single_class": [
      "self",
      "estimator_instance"
    ],
    "test_multioutput": [
      "self",
      "estimator_instance"
    ],
    "test_class_weight": [
      "self",
      "estimator_instance",
      "scenario"
    ]
  },
  "ContinuousIntervalTree": {
    "__init__": [
      "self",
      "max_depth",
      "thresholds",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_predict_proba_cif": [
      "self",
      "X",
      "c22",
      "intervals",
      "dims",
      "atts"
    ],
    "_predict_proba_drcif": [
      "self",
      "X",
      "X_p",
      "X_d",
      "c22",
      "n_intervals",
      "intervals",
      "dims",
      "atts"
    ],
    "tree_node_splits_and_gain": [
      "self"
    ],
    "_find_splits_gain": [
      "self",
      "node",
      "splits",
      "gains"
    ]
  },
  "_TreeNode": {
    "__init__": [
      "self",
      "random_state"
    ],
    "build_tree": [
      "self",
      "X",
      "y",
      "thresholds",
      "entropy",
      "distribution",
      "depth",
      "max_depth",
      "n_classes",
      "leaf"
    ],
    "predict_proba": [
      "self",
      "X",
      "n_classes"
    ],
    "predict_proba_cif": [
      "self",
      "X",
      "c22",
      "intervals",
      "dims",
      "atts",
      "n_classes"
    ],
    "predict_proba_drcif": [
      "self",
      "X",
      "c22",
      "n_intervals",
      "intervals",
      "dims",
      "atts",
      "n_classes"
    ]
  },
  "RotationForest": {
    "__init__": [
      "self",
      "n_estimators",
      "min_group",
      "max_group",
      "remove_proportion",
      "base_estimator",
      "time_limit_in_minutes",
      "contract_max_n_estimators",
      "save_transformed_data",
      "n_jobs",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "X_cls_split",
      "y",
      "idx"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "clf",
      "pcas",
      "groups"
    ],
    "_train_probas_for_estimator": [
      "self",
      "y",
      "idx"
    ],
    "_generate_groups": [
      "self",
      "rng"
    ]
  },
  "_summary_stat": [
    "X",
    "att"
  ],
  "_entropy": [
    "x",
    "s"
  ],
  "_drcif_feature": [
    "X",
    "interval",
    "dim",
    "att",
    "c22",
    "case_id"
  ],
  "information_gain": [
    "X",
    "y",
    "attribute",
    "threshold",
    "parent_entropy",
    "n_classes"
  ],
  "margin_gain": [
    "X",
    "attribute",
    "threshold"
  ],
  "split_data": [
    "X",
    "best_split",
    "best_threshold"
  ],
  "remaining_classes": [
    "distribution"
  ],
  "test_nan_values": [],
  "test_sklearn_compatible_estimator": [
    "estimator",
    "check"
  ],
  "test_contracted_rotf": [],
  "ALL_SKLEARN_CLASSIFIERS": [],
  "INSTANCES_TO_TEST": [],
  "_handle_test_stepouts": [
    "estimator",
    "error"
  ],
  "MrSEQL": {
    "_tags": [],
    "__init__": [
      "self",
      "seql_mode",
      "symrep",
      "custom_config"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ShapeletTransformClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_shapelet_samples",
      "max_shapelets",
      "max_shapelet_length",
      "estimator",
      "transform_limit_in_minutes",
      "time_limit_in_minutes",
      "contract_max_n_shapelet_samples",
      "save_transformed_data",
      "n_jobs",
      "batch_size",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MrSQM": {
    "_tags": [],
    "__init__": [
      "self",
      "strat",
      "features_per_rep",
      "selection_per_rep",
      "nsax",
      "nsfa",
      "custom_config",
      "random_state",
      "sfa_norm"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ShapeletLearningClassifierPyts": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "_get_pyts_object": [
      "self"
    ],
    "__init__": [
      "self",
      "loss",
      "n_shapelets_per_size",
      "min_shapelet_length",
      "shapelet_scale",
      "penalty",
      "tol",
      "C",
      "learning_rate",
      "max_iter",
      "multi_class",
      "alpha",
      "fit_intercept",
      "intercept_scaling",
      "class_weight",
      "n_jobs",
      "verbose",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ShapeletLearningClassifierTslearn": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "n_shapelets_per_size",
      "max_iter",
      "batch_size",
      "optimizer",
      "weight_regularizer",
      "shapelet_length",
      "total_lengths",
      "max_size",
      "scale",
      "verbose",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_contracted_stc": [],
  "FCNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ConvTimeNetClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "d_model",
      "patch_size",
      "patch_stride",
      "dropout",
      "d_ff",
      "dw_ks",
      "device",
      "num_epochs",
      "batch_size",
      "criterion",
      "criterion_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_build_network": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "InceptionTimeClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "n_filters",
      "use_residual",
      "use_bottleneck",
      "bottleneck_size",
      "depth",
      "callbacks",
      "random_state",
      "verbose",
      "loss",
      "metrics",
      "class_weight",
      "activation",
      "activation_hidden",
      "activation_inception"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_check_callbacks": [
      "self",
      "callbacks"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ResNetClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "batch_size",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MCDCNNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "pool_size",
      "filter_sizes",
      "dense_units",
      "conv_padding",
      "pool_padding",
      "loss",
      "activation",
      "activation_hidden",
      "use_bias",
      "callbacks",
      "metrics",
      "optimizer",
      "verbose",
      "random_state"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ]
  },
  "MLPClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CNTCClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "filter_sizes",
      "kernel_sizes",
      "rnn_size",
      "lstm_size",
      "dense_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_attention",
      "activation_hidden"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "prepare_input": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseDeepClassifierPytorch": {
    "_tags": [],
    "__init__": [
      "self",
      "num_epochs",
      "batch_size",
      "criterion",
      "criterion_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_run_epoch": [
      "self",
      "epoch",
      "dataloader"
    ],
    "_instantiate_optimizer": [
      "self"
    ],
    "_instantiate_criterion": [
      "self"
    ],
    "_build_network": [
      "self"
    ],
    "_build_dataloader": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_encode_y": [
      "self",
      "y"
    ],
    "_decode_y": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PytorchDataset": {
    "__init__": [
      "self",
      "X",
      "y"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "i"
    ]
  },
  "MVTSTransformerClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "d_model",
      "n_heads",
      "num_layers",
      "dim_feedforward",
      "dropout",
      "pos_encoding",
      "activation",
      "norm",
      "freeze",
      "num_epochs",
      "batch_size",
      "criterion",
      "criterion_kwargs",
      "optimizer",
      "optimizer_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_build_network": [
      "self",
      "X",
      "y"
    ],
    "_build_dataloader": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GRUClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "hidden_dim",
      "n_layers",
      "batch_first",
      "bias",
      "init_weights",
      "dropout",
      "fc_dropout",
      "bidirectional",
      "num_epochs",
      "batch_size",
      "optimizer",
      "criterion",
      "criterion_kwargs",
      "optimizer_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_build_network": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GRUFCNNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "hidden_dim",
      "gru_layers",
      "batch_first",
      "bias",
      "init_weights",
      "dropout",
      "gru_dropout",
      "bidirectional",
      "conv_layers",
      "kernel_sizes",
      "num_epochs",
      "batch_size",
      "optimizer",
      "criterion",
      "criterion_kwargs",
      "optimizer_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_build_network": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CNNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "avg_pool_size",
      "n_conv_layers",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer",
      "filter_sizes",
      "padding"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LSTMFCNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "dropout",
      "kernel_sizes",
      "filter_sizes",
      "lstm_size",
      "attention",
      "callbacks",
      "random_state",
      "verbose",
      "activation",
      "activation_hidden"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TapNetClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "dropout",
      "filter_sizes",
      "kernel_size",
      "dilation",
      "layers",
      "use_rp",
      "rp_params",
      "activation",
      "activation_hidden",
      "use_bias",
      "use_att",
      "use_lstm",
      "use_cnn",
      "random_state",
      "padding",
      "loss",
      "optimizer",
      "metrics",
      "callbacks",
      "verbose"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MACNNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "padding",
      "pool_size",
      "strides",
      "repeats",
      "filter_sizes",
      "kernel_size",
      "reduction",
      "loss",
      "activation",
      "activation_hidden",
      "use_bias",
      "metrics",
      "optimizer",
      "callbacks",
      "random_state",
      "verbose"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SimpleRNNClassifierTorch": {
    "_tags": [],
    "__init__": [
      "self",
      "hidden_dim",
      "n_layers",
      "activation",
      "activation_hidden",
      "batch_first",
      "bias",
      "init_weights",
      "dropout",
      "fc_dropout",
      "bidirectional",
      "num_epochs",
      "batch_size",
      "optimizer",
      "criterion",
      "callbacks",
      "optimizer_kwargs",
      "criterion_kwargs",
      "callback_kwargs",
      "lr",
      "verbose",
      "random_state"
    ],
    "_build_network": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SimpleRNNClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "units",
      "callbacks",
      "add_default_callback",
      "random_state",
      "verbose",
      "loss",
      "metrics",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseDeepClassifier": {
    "_tags": [],
    "build_model": [
      "self",
      "input_shape",
      "n_classes"
    ],
    "summary": [
      "self"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_convert_y_to_keras": [
      "self",
      "y"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "save": [
      "self",
      "path",
      "serialization_format"
    ],
    "_serialize_using_dump_func": [
      "self",
      "path",
      "dump",
      "dumps"
    ],
    "load_from_serial": [
      "cls",
      "serial"
    ],
    "load_from_path": [
      "cls",
      "serial"
    ]
  },
  "ReduceLROnPlateau": [],
  "HIVECOTEV1": {
    "_tags": [],
    "__init__": [
      "self",
      "stc_params",
      "tsf_params",
      "rise_params",
      "cboss_params",
      "verbose",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "HIVECOTEV2": {
    "_tags": [],
    "__init__": [
      "self",
      "stc_params",
      "drcif_params",
      "arsenal_params",
      "tde_params",
      "time_limit_in_minutes",
      "save_component_probas",
      "verbose",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X",
      "return_component_probas"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_contracted_hivecote_v2": [],
  "ClassifierPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "classifier",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SklearnClassifierPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "classifier",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_convert_X_to_sklearn": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiplexClassifier": {
    "_tags": [],
    "_delegate_name": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "classifiers",
      "selected_classifier"
    ],
    "_classifiers": [
      "self",
      "value"
    ],
    "_check_selected_classifier": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "_set_classifier": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseColumnEnsembleClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "estimators",
      "remainder",
      "verbose"
    ],
    "_estimators": [
      "self",
      "value"
    ],
    "_validate_estimators": [
      "self"
    ],
    "_validate_column_callables": [
      "self",
      "X"
    ],
    "_validate_remainder": [
      "self",
      "X"
    ],
    "_iter": [
      "self",
      "replace_strings"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_collect_probas": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "ColumnEnsembleClassifier": {
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "estimators",
      "remainder",
      "verbose"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_get_column": [
    "X",
    "key"
  ],
  "_check_key_type": [
    "key",
    "superclass"
  ],
  "_get_column_indices": [
    "X",
    "key"
  ],
  "_is_empty_column_selection": [
    "column"
  ],
  "test_multiplex_classifier": [],
  "_is_proba_classification_score": [
    "metric"
  ],
  "_evaluate_fold": [
    "x",
    "meta"
  ],
  "TestEvaluate": {
    "test_evaluate_basic_functionality": [
      "self"
    ],
    "test_evaluate_with_multiple_metrics": [
      "self"
    ],
    "test_evaluate_with_probabilistic_metrics": [
      "self"
    ],
    "test_evaluate_with_return_data": [
      "self"
    ],
    "test_evaluate_different_cv_splits": [
      "self"
    ],
    "test_evaluate_with_different_classifiers": [
      "self"
    ],
    "test_evaluate_timing_measurements": [
      "self"
    ],
    "test_evaluate_parallel_backend": [
      "self",
      "backend"
    ],
    "test_evaluate_parallel_backend_none": [
      "self"
    ]
  },
  "ComposableTimeSeriesForestClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "n_estimators",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "bootstrap",
      "oob_score",
      "n_jobs",
      "random_state",
      "verbose",
      "warm_start",
      "class_weight",
      "max_samples",
      "criterion"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_repr_html_inner": [
      "self"
    ],
    "_repr_mimebundle_": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_validate_estimator": [
      "self"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y"
    ],
    "_validate_y_class_weight": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaggingClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "n_estimators",
      "n_samples",
      "n_features",
      "bootstrap",
      "bootstrap_features",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_random_ss_ix": [
    "ix",
    "size",
    "replace"
  ],
  "WeightedEnsembleClassifier": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "classifiers",
      "weights",
      "cv",
      "metric",
      "metric_type",
      "random_state"
    ],
    "_classifiers": [
      "self",
      "value"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "n_classes": [],
  "test_tsf_predict_proba": [],
  "test_equivalent_model_specifications": [
    "n_intervals",
    "n_estimators"
  ],
  "test_tsf_predictions": [
    "n_estimators",
    "n_intervals"
  ],
  "BaseEarlyClassifier": {
    "_tags": [],
    "METADATA_REQ_IN_CHECKS": [],
    "VECTORIZATION_ATTR": [],
    "TASK": [],
    "EST_TYPE": [],
    "EST_TYPE_PLURAL": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "update_predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "update_predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "get_state_info": [
      "self"
    ],
    "reset_state_info": [
      "self"
    ],
    "filter_X": [
      "X",
      "decisions"
    ],
    "filter_X_y": [
      "X",
      "y",
      "decisions"
    ],
    "split_indices": [
      "indices",
      "decisions"
    ],
    "split_indices_and_filter": [
      "X",
      "indices",
      "decisions"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_update_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_update_predict_proba": [
      "self",
      "X"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "_check_convert_X_for_predict": [
      "self",
      "X"
    ],
    "_check_capabilities": [
      "self",
      "X_metadata"
    ],
    "_convert_X": [
      "self",
      "X",
      "X_mtype"
    ],
    "_check_y": [
      "self",
      "y",
      "return_to_mtype"
    ],
    "_check_input": [
      "self",
      "X",
      "y",
      "enforce_min_instances",
      "return_metadata"
    ],
    "_internal_convert": [
      "self",
      "X",
      "y"
    ]
  },
  "TEASER": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "one_class_classifier",
      "one_class_param_grid",
      "classification_points",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_update_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_update_predict_proba": [
      "self",
      "X"
    ],
    "_score": [
      "self",
      "X",
      "y"
    ],
    "_get_next_idx": [
      "self",
      "series_length"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "y",
      "i"
    ],
    "_predict_proba_for_estimator": [
      "self",
      "X",
      "i"
    ],
    "_generate_one_class_features": [
      "self",
      "X",
      "preds",
      "probas"
    ],
    "_predict_oc_classifier_n_timestamps": [
      "self",
      "estimator_preds",
      "X_oc",
      "n_consecutive_predictions",
      "last_idx",
      "next_idx",
      "state_info"
    ],
    "_predict_oc_classifier": [
      "self",
      "X_oc",
      "n_consecutive_predictions",
      "idx",
      "estimator_preds",
      "state_info"
    ],
    "_compute_harmonic_mean": [
      "self",
      "state_info",
      "y"
    ],
    "_update_state_info": [
      "self",
      "accept_decision",
      "preds",
      "state_info",
      "idx",
      "time_stamp"
    ],
    "_proba_output_to_preds": [
      "self",
      "out"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ProbabilityThresholdEarlyClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "probability_threshold",
      "consecutive_predictions",
      "estimator",
      "classification_points",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "decide_prediction_safety": [
      "self",
      "X",
      "X_probabilities",
      "state_info"
    ],
    "_fit_estimator": [
      "self",
      "X",
      "y",
      "i"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "EarlyClassifierFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllEarlyClassifiers": {
    "test_multivariate_input_exception": [
      "self",
      "estimator_instance"
    ],
    "test_classifier_output": [
      "self",
      "estimator_instance",
      "scenario"
    ]
  },
  "load_unit_data": [],
  "test_teaser_on_unit_test_data": [],
  "test_teaser_with_different_decision_maker": [],
  "test_teaser_near_classification_points": [],
  "test_teaser_full_length": [],
  "teaser_unit_test_probas": [],
  "teaser_if_unit_test_probas": [],
  "test_prob_threshold_on_unit_test_data": [],
  "pt_unit_test_probas": [],
  "Catch22Classifier": {
    "_tags": [],
    "__init__": [
      "self",
      "outlier_norm",
      "replace_nans",
      "estimator",
      "n_jobs",
      "random_state"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FreshPRINCE": {
    "_tags": [],
    "__init__": [
      "self",
      "default_fc_parameters",
      "n_estimators",
      "save_transformed_data",
      "verbose",
      "n_jobs",
      "chunksize",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MatrixProfileClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "subsequence_length",
      "estimator",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SignatureClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "augmentation_list",
      "window_name",
      "window_depth",
      "window_length",
      "window_step",
      "rescaling",
      "sig_tfm",
      "depth",
      "random_state"
    ],
    "_setup_classification_pipeline": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSFreshClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "default_fc_parameters",
      "relevant_feature_extractor",
      "estimator",
      "verbose",
      "n_jobs",
      "chunksize",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SummaryClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "summary_functions",
      "summary_quantiles",
      "estimator",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RandomIntervalClassifier": {
    "_tags": [],
    "__init__": [
      "self",
      "n_intervals",
      "interval_transformers",
      "estimator",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_tsfresh_predict_proba_feature_order_consistency": [],
  "TSCGridSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "param_grid",
      "scoring",
      "n_jobs",
      "refit",
      "cv",
      "verbose",
      "pre_dispatch",
      "error_score",
      "return_train_score",
      "tune_by_variable"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSCOptCV": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "optimizer",
      "cv",
      "scoring",
      "refit",
      "error_score",
      "backend",
      "backend_params"
    ],
    "get_test_params": [
      "self",
      "parameter_set"
    ]
  },
  "MUSE": {
    "_tags": [],
    "__init__": [
      "self",
      "anova",
      "variance",
      "bigrams",
      "window_inc",
      "alphabet_size",
      "use_first_order_differences",
      "feature_selection",
      "p_threshold",
      "support_probabilities",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_transform_words": [
      "self",
      "X"
    ],
    "_add_first_order_differences": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_compute_window_inc": [
    "series_length",
    "window_inc"
  ],
  "_parallel_transform_words": [
    "X",
    "window_sizes",
    "SFA_transformers",
    "ind"
  ],
  "_parallel_fit": [
    "X",
    "y",
    "ind",
    "min_window",
    "max_window",
    "window_inc",
    "word_lengths",
    "alphabet_size",
    "norm_options",
    "anova",
    "variance",
    "binning_strategies",
    "bigrams",
    "n_jobs",
    "p_threshold",
    "feature_selection",
    "random_state"
  ],
  "WEASEL": {
    "_tags": [],
    "__init__": [
      "self",
      "anova",
      "bigrams",
      "binning_strategy",
      "window_inc",
      "p_threshold",
      "alphabet_size",
      "n_jobs",
      "feature_selection",
      "support_probabilities",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_transform_words": [
      "self",
      "X"
    ],
    "_compute_window_inc": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TemporalDictionaryEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "n_parameter_samples",
      "max_ensemble_size",
      "max_win_len_prop",
      "min_window",
      "randomly_selected_params",
      "bigrams",
      "dim_threshold",
      "max_dims",
      "time_limit_in_minutes",
      "contract_max_n_parameter_samples",
      "typed_dict",
      "save_train_predictions",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_worst_ensemble_acc": [
      "self"
    ],
    "_unique_parameters": [
      "self",
      "max_window",
      "win_inc"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y",
      "train_estimate_method"
    ],
    "_individual_train_acc": [
      "self",
      "tde",
      "y",
      "train_size",
      "lowest_acc"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IndividualTDE": {
    "_tags": [],
    "__init__": [
      "self",
      "window_size",
      "word_length",
      "norm",
      "levels",
      "igb",
      "alphabet_size",
      "bigrams",
      "dim_threshold",
      "max_dims",
      "typed_dict",
      "n_jobs",
      "random_state"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_test_nn": [
      "self",
      "test_bag"
    ],
    "_select_dims": [
      "self",
      "X",
      "y"
    ],
    "_train_predict": [
      "self",
      "train_num",
      "bags"
    ]
  },
  "histogram_intersection": [
    "first",
    "second"
  ],
  "ContractableBOSS": {
    "_tags": [],
    "__init__": [
      "self",
      "n_parameter_samples",
      "max_ensemble_size",
      "max_win_len_prop",
      "min_window",
      "time_limit_in_minutes",
      "contract_max_n_parameter_samples",
      "save_train_predictions",
      "feature_selection",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_worst_ensemble_acc": [
      "self"
    ],
    "_unique_parameters": [
      "self",
      "max_window",
      "win_inc"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "_individual_train_acc": [
      "self",
      "boss",
      "y",
      "train_size",
      "lowest_acc"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_histogram_intersection_dict": [
    "first",
    "second"
  ],
  "BOSSEnsemble": {
    "_tags": [],
    "__init__": [
      "self",
      "threshold",
      "max_ensemble_size",
      "max_win_len_prop",
      "min_window",
      "save_train_predictions",
      "feature_selection",
      "use_boss_distance",
      "alphabet_size",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_proba": [
      "self",
      "X"
    ],
    "_include_in_ensemble": [
      "self",
      "acc",
      "max_acc",
      "min_max_acc",
      "size"
    ],
    "_worst_ensemble_acc": [
      "self"
    ],
    "_get_train_probs": [
      "self",
      "X",
      "y"
    ],
    "_individual_train_acc": [
      "self",
      "boss",
      "y",
      "train_size",
      "lowest_acc"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "IndividualBOSS": {
    "_tags": [],
    "__init__": [
      "self",
      "window_size",
      "word_length",
      "norm",
      "alphabet_size",
      "save_words",
      "typed_dict",
      "use_boss_distance",
      "feature_selection",
      "store_histogram",
      "n_jobs",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_create_histograms": [
      "self"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_train_predict": [
      "self",
      "train_num",
      "distance_matrix"
    ],
    "_shorten_bags": [
      "self",
      "word_len",
      "y"
    ],
    "_clean": [
      "self"
    ],
    "_set_word_len": [
      "self",
      "X",
      "y",
      "word_len"
    ]
  },
  "_dist_wrapper": [
    "dist_matrix",
    "X",
    "Y",
    "s",
    "XX_all",
    "XY_all"
  ],
  "pairwise_distances": [
    "X",
    "Y",
    "use_boss_distance",
    "n_jobs"
  ],
  "boss_distance": [
    "X",
    "Y",
    "i",
    "XX_all",
    "XY_all"
  ],
  "BOSSVSClassifierPyts": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "__init__": [
      "self",
      "word_size",
      "n_bins",
      "window_size",
      "window_step",
      "anova",
      "drop_sum",
      "norm_mean",
      "norm_std",
      "strategy",
      "alphabet",
      "numerosity_reduction",
      "use_idf",
      "smooth_idf",
      "sublinear_tf"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_tde_train_estimate": [],
  "test_contracted_tde": [],
  "dataset": [],
  "test_individual_boss_classes": [
    "dataset",
    "new_class",
    "expected_dtype"
  ],
  "test_boss_ensemble_classes": [
    "dataset",
    "new_class",
    "expected_dtype"
  ],
  "test_individual_boss_histograms": [
    "dataset"
  ],
  "test_individual_boss_no_histograms": [
    "dataset"
  ],
  "rng": [],
  "RANDOM_STATES": [],
  "Y1": [],
  "Y2": [],
  "Y3": [],
  "Y_TEST_CASES": [],
  "LOSS_RESULTS": [],
  "_call_metrics": [
    "metric_func",
    "metric_class",
    "y_true",
    "y_pred",
    "y_train",
    "y_pred_benchmark"
  ],
  "test_univariate_loss_expected_zero": [
    "n_test_case",
    "metric_func_name"
  ],
  "test_univariate_loss_against_expected_value": [
    "n_test_case",
    "metric_func_name"
  ],
  "test_univariate_metric_function_class_equality": [
    "metric_func_name",
    "random_state"
  ],
  "_is_numeric_scalar": [
    "value"
  ],
  "test_univariate_function_output_type": [
    "metric_func_name",
    "random_state"
  ],
  "test_y_true_y_pred_inconsistent_n_outputs_raises_error": [
    "metric_func_name"
  ],
  "test_y_true_y_pred_inconsistent_n_timepoints_raises_error": [
    "metric_func_name"
  ],
  "test_y_true_y_pred_inconsistent_n_variables_raises_error": [
    "metric_func_name"
  ],
  "test_sample_weight_generator_has_no_effect_on_metric_function": [
    "metric_func_name",
    "random_state"
  ],
  "test_sample_weight_generator_is_passed_to_func": [
    "metric_class",
    "random_state"
  ],
  "MULTIOUTPUT": [],
  "test_metric_hierarchical": [
    "multioutput",
    "multilevel",
    "n_columns",
    "backend"
  ],
  "test_custom_metric": [
    "greater_is_better"
  ],
  "RANDOM_SEED": [],
  "TEST_YS_ZERO": [],
  "test_padded_f1_with_sklearn": [],
  "test_padded_f1_for_perfect_score": [
    "true_cps",
    "pred_cps",
    "pad"
  ],
  "test_padded_f1_for_worst_score": [
    "true_cps",
    "pred_cps",
    "threshold"
  ],
  "test_padded_f1_against_known_score": [
    "true_cps",
    "pred_cps",
    "thresh",
    "expected_value"
  ],
  "exact_match": [],
  "different_lengths": [],
  "test_count_error_exact": [
    "exact_match"
  ],
  "test_hausdorff_error_exact": [
    "exact_match"
  ],
  "test_prediction_ratio_exact": [
    "exact_match"
  ],
  "test_count_error": [
    "different_lengths"
  ],
  "test_hausdorff_error": [
    "different_lengths"
  ],
  "test_prediction_ratio": [
    "different_lengths"
  ],
  "numpy_metrics": [],
  "exclude_starts_with": [],
  "test_metric_output": [
    "metric",
    "multioutput",
    "n_columns"
  ],
  "MedianAbsoluteScaledError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "sp",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanSquaredError": {
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "square_root",
      "by_index"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MedianAbsolutePercentageError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "symmetric",
      "by_index",
      "relative_to",
      "eps"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanAsymmetricError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "asymmetric_threshold",
      "left_error_function",
      "right_error_function",
      "left_error_penalty",
      "right_error_penalty",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GeometricMeanSquaredError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "square_root",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanSquaredErrorPercentage": {
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "square_root",
      "by_index"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanLinexError": {
    "func": [],
    "__init__": [
      "self",
      "a",
      "b",
      "multioutput",
      "multilevel",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MedianRelativeAbsoluteError": {
    "_tags": [],
    "func": []
  },
  "RelativeLoss": {
    "_tags": [],
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "relative_loss_function",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MedianSquaredScaledError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "sp",
      "square_root",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_is_average": [
    "multilevel_or_multioutput"
  ],
  "BaseForecastingErrorMetric": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "by_index"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_apply_sample_weight_to_kwargs": [
      "self",
      "y_true",
      "y_pred"
    ],
    "evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_vectorized": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_by_index_vectorized": [
      "self",
      "y_true",
      "y_pred"
    ],
    "evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_check_consistent_input": [
      "self",
      "y_true",
      "y_pred",
      "multioutput",
      "multilevel"
    ],
    "_check_ys": [
      "self",
      "y_true",
      "y_pred",
      "multioutput",
      "multilevel"
    ],
    "_set_sample_weight_on_kwargs": [
      "self"
    ],
    "_get_weighted_df": [
      "self",
      "df"
    ],
    "_handle_multioutput": [
      "self",
      "df",
      "multioutput"
    ]
  },
  "BaseForecastingErrorMetricFunc": {
    "_evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "_evaluate_func": [
      "self",
      "func",
      "y_true",
      "y_pred"
    ]
  },
  "_DynamicForecastingErrorMetric": {
    "__init__": [
      "self",
      "func",
      "name",
      "multioutput",
      "multilevel",
      "lower_is_better",
      "by_index"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_ScaledMetricTags": {
    "_tags": []
  },
  "make_forecasting_scorer": [
    "func",
    "name",
    "greater_is_better",
    "multioutput",
    "multilevel"
  ],
  "MeanAbsoluteError": {
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "GeometricMeanRelativeAbsoluteError": {
    "_tags": [],
    "func": []
  },
  "_relative_error": [
    "y_true",
    "y_pred",
    "y_pred_benchmark",
    "eps"
  ],
  "_percentage_error": [
    "y_true",
    "y_pred",
    "symmetric",
    "relative_to",
    "eps"
  ],
  "GeometricMeanAbsoluteError": {
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "MeanSquaredPercentageError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "symmetric",
      "square_root",
      "by_index",
      "relative_to",
      "eps"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "mean_arctangent_absolute_percentage_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "relative_to",
    "eps",
    "sample_weight"
  ],
  "MeanArctangentAbsolutePercentageError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "relative_to",
      "eps",
      "by_index"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanRelativeAbsoluteError": {
    "_tags": [],
    "func": []
  },
  "EPS": [],
  "_get_kwarg": [
    "kwarg",
    "metric_name"
  ],
  "_handle_output": [
    "obj",
    "multioutput"
  ],
  "mean_linex_error": [
    "y_true",
    "y_pred",
    "a",
    "b",
    "horizon_weight",
    "multioutput"
  ],
  "mean_asymmetric_error": [
    "y_true",
    "y_pred",
    "asymmetric_threshold",
    "left_error_function",
    "right_error_function",
    "left_error_penalty",
    "right_error_penalty",
    "horizon_weight",
    "multioutput"
  ],
  "mean_absolute_scaled_error": [
    "y_true",
    "y_pred",
    "sp",
    "horizon_weight",
    "multioutput"
  ],
  "median_absolute_scaled_error": [
    "y_true",
    "y_pred",
    "sp",
    "horizon_weight",
    "multioutput"
  ],
  "mean_squared_scaled_error": [
    "y_true",
    "y_pred",
    "sp",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "median_squared_scaled_error": [
    "y_true",
    "y_pred",
    "sp",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "mean_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "mean_squared_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "median_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "median_squared_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "geometric_mean_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "geometric_mean_squared_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "mean_absolute_percentage_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "symmetric",
    "relative_to"
  ],
  "median_absolute_percentage_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "symmetric",
    "relative_to"
  ],
  "mean_squared_percentage_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root",
    "symmetric",
    "relative_to"
  ],
  "median_squared_percentage_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root",
    "symmetric",
    "relative_to"
  ],
  "mean_relative_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "median_relative_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "geometric_mean_relative_absolute_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput"
  ],
  "geometric_mean_relative_squared_error": [
    "y_true",
    "y_pred",
    "horizon_weight",
    "multioutput",
    "square_root"
  ],
  "relative_loss": [
    "y_true",
    "y_pred",
    "relative_loss_function",
    "horizon_weight",
    "multioutput"
  ],
  "_asymmetric_error": [
    "y_true",
    "y_pred",
    "asymmetric_threshold",
    "left_error_function",
    "right_error_function",
    "left_error_penalty",
    "right_error_penalty"
  ],
  "_linex_error": [
    "y_true",
    "y_pred",
    "a",
    "b"
  ],
  "MedianAbsoluteError": {
    "func": [],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "MedianSquaredError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "square_root",
      "by_index"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanSquaredScaledError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "sp",
      "square_root",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MedianSquaredPercentageError": {
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "symmetric",
      "square_root",
      "by_index",
      "relative_to",
      "eps"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_coerce_to_scalar": [
    "obj"
  ],
  "_coerce_to_series": [
    "obj"
  ],
  "_coerce_to_1d_numpy": [
    "obj"
  ],
  "MeanAbsolutePercentageError": {
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "symmetric",
      "by_index",
      "relative_to",
      "eps"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MeanAbsoluteScaledError": {
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "sp",
      "by_index",
      "eps"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GeometricMeanRelativeSquaredError": {
    "_tags": [],
    "func": [],
    "__init__": [
      "self",
      "multioutput",
      "multilevel",
      "square_root",
      "by_index"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_BaseProbaForecastingErrorMetric": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "score_average"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "evaluate": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "_check_consistent_input": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "_check_ys": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "_get_alpha_from": [
      "self",
      "y_pred"
    ],
    "_check_alpha": [
      "self",
      "alpha"
    ],
    "_check_coverage": [
      "self",
      "coverage"
    ],
    "_handle_multioutput": [
      "self",
      "loss",
      "multioutput"
    ]
  },
  "_groupby_dot": [
    "df",
    "weights"
  ],
  "PinballLoss": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "score_average",
      "alpha"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "EmpiricalCoverage": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "score_average",
      "coverage"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "self"
    ]
  },
  "IntervalWidth": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "score_average",
      "coverage"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "self"
    ]
  },
  "ConstraintViolation": {
    "_tags": [],
    "__init__": [
      "self",
      "multioutput",
      "score_average",
      "coverage"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "self"
    ]
  },
  "PANDAS_DF_MTYPES": [],
  "_BaseDistrForecastingMetric": {
    "_tags": [],
    "evaluate": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ]
  },
  "LogLoss": {
    "__init__": [
      "self",
      "multioutput",
      "multivariate"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SquaredDistrLoss": {
    "__init__": [
      "self",
      "multioutput",
      "multivariate"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CRPS": {
    "__init__": [
      "self",
      "multioutput",
      "multivariate"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AUCalibration": {
    "__init__": [
      "self",
      "multioutput",
      "multivariate"
    ],
    "_evaluate_by_index": [
      "self",
      "y_true",
      "y_pred",
      "multioutput"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DISTR_METRICS": [],
  "normal_dists": [],
  "test_distr_evaluate": [
    "normal",
    "metric",
    "multivariate"
  ],
  "quantile_metrics": [],
  "interval_metrics": [],
  "all_metrics": [],
  "alpha_s": [],
  "alpha_m": [],
  "coverage_s": [],
  "coverage_m": [],
  "test_sample_data": [
    "sample_data"
  ],
  "helper_check_output": [
    "metric",
    "score_average",
    "multioutput",
    "sample_data"
  ],
  "test_output_quantiles": [
    "metric",
    "score_average",
    "multioutput",
    "sample_data"
  ],
  "test_output_intervals": [
    "metric",
    "score_average",
    "multioutput",
    "sample_data"
  ],
  "test_evaluate_alpha_positive": [
    "metric",
    "sample_data"
  ],
  "test_evaluate_alpha_negative": [
    "metric",
    "sample_data"
  ],
  "test_multioutput_weighted": [
    "metric",
    "score_average"
  ],
  "test_empirical_coverage_boundary_equality": [
    "y_true_vals",
    "lower_vals",
    "upper_vals"
  ],
  "ForecastingMetricPtFixtureGenerator": {
    "estimator_type_filter": [],
    "fixture_sequence": []
  },
  "TestAllForecastingPtMetrics": {
    "test_metric_output_direct": [
      "self",
      "estimator_instance",
      "multioutput",
      "n_columns"
    ],
    "test_metric_output_by_instance": [
      "self",
      "estimator_instance",
      "multioutput",
      "n_columns"
    ],
    "test_uniform_average_time": [
      "self",
      "estimator_instance"
    ],
    "test_metric_weights": [
      "self",
      "estimator_instance"
    ]
  },
  "test_gmse_class": [],
  "test_gmse_function": [],
  "test_linex_class": [],
  "test_linex_function": [],
  "test_make_scorer": [],
  "test_make_scorer_sklearn": [],
  "test_metric_coercion_bug": [],
  "BaseSampleWeightGenerator": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SampleWeightGenerator": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "check_sample_weight_generator": [
    "obj"
  ],
  "DummyWeightGenerator": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "UniformWeightGenerator": {
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "RecencyWeightGenerator": {
    "__init__": [
      "self",
      "decay_rate"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "DateRangeWeightGenerator": {
    "__init__": [
      "self",
      "date_ranges",
      "default_weight"
    ],
    "_get_dt": [
      "self",
      "date_series"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "test_base_sample_weight_generator": [],
  "test_check_sample_weight_generator": [],
  "test_check_sample_weight_generator_are_invalid": [],
  "test_dummy_weight_generator": [],
  "test_uniform_weight_generator": [],
  "test_recency_weight_generator": [],
  "test_date_range_weight_generator": [],
  "test_sample_weight_generator_with_y_pred": [],
  "test_sample_weight_generator_with_kwargs": [],
  "count_error": [
    "true_change_points",
    "pred_change_points"
  ],
  "hausdorff_error": [
    "true_change_points",
    "pred_change_points",
    "symmetric",
    "seed"
  ],
  "prediction_ratio": [
    "true_change_points",
    "pred_change_points"
  ],
  "padded_f1": [
    "true_change_points",
    "pred_change_points",
    "pad"
  ],
  "RandIndex": {
    "_tags": [],
    "__init__": [
      "self",
      "use_loc"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "_compute_length": [
      "self",
      "start_iloc",
      "end_iloc",
      "X"
    ],
    "_compute_same_cluster_both": [
      "self",
      "y_true_segments",
      "y_pred_segments",
      "X"
    ],
    "_pairs_count": [
      "self",
      "length"
    ],
    "_extract_segments": [
      "self",
      "y",
      "var_name"
    ],
    "_assign_unique_ids": [
      "self",
      "segments",
      "prefix"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseDetectionMetric": {
    "_tags": [],
    "__call__": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "_check_ys": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "_coerce_to_detection_type": [
      "self",
      "y",
      "X",
      "allow_none"
    ]
  },
  "DirectedHausdorff": {
    "_tags": [],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ]
  },
  "DirectedChamfer": {
    "_tags": [],
    "__init__": [
      "self",
      "normalize"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DetectionCount": {
    "_tags": [],
    "__init__": [
      "self",
      "target",
      "excess_only"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "WindowedF1Score": {
    "_tags": [],
    "__init__": [
      "self",
      "margin"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_ts_auprc": [
    "y_true",
    "y_pred",
    "integration",
    "weighted_precision"
  ],
  "TimeSeriesAUPRC": {
    "_tags": [],
    "__init__": [
      "self",
      "integration",
      "weighted_precision",
      "with_scores"
    ],
    "_evaluate": [
      "self",
      "y_true",
      "y_pred",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DetectionMetricFixtureGenerator": {
    "estimator_type_filter": [],
    "fixture_sequence": []
  },
  "TestAllDetectionMetrics": {
    "test_evaluate_output": [
      "self",
      "estimator_instance"
    ]
  },
  "test_chamfer": [],
  "test_input_coercions": [],
  "test_hausdorff": [],
  "_find_closest_elements": [
    "a",
    "b"
  ],
  "_compute_window_indices": [
    "binary_labels"
  ],
  "_compute_overlap": [
    "preds",
    "pred_indices",
    "gt_indices",
    "alpha",
    "bias_fn",
    "cardinality_fn",
    "use_window_weight"
  ],
  "_constant_bias_fn": [
    "inputs"
  ],
  "_inverse_proportional_cardinality_fn": [
    "cardinality",
    "gt_length"
  ],
  "_improved_cardinality_fn": [
    "cardinality",
    "gt_length"
  ],
  "_ts_precision_and_recall": [
    "anomalies",
    "predictions",
    "alpha",
    "recall_bias_fn",
    "recall_cardinality_fn",
    "precision_bias_fn",
    "precision_cardinality_fn",
    "anomaly_ranges",
    "prediction_ranges",
    "weighted_precision"
  ],
  "_BaseScitypeOfObject": {
    "_tags": [],
    "get_test_class": [
      "cls"
    ]
  },
  "object": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "estimator": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "aligner": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "clusterer": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "early_classifier": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "forecaster": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "global_forecaster": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "metric": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "metric_detection": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "metric_forecasting": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "metric_forecasting_proba": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "network": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "param_est": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "regressor": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "detector": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "splitter": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "transformer": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "transformer_pairwise": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "transformer_pairwise_panel": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "dataset_classification": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "dataset_forecasting": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "dataset_regression": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "reconciler": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "_get_base_classes": [
    "mixin"
  ],
  "_construct_child_tree": [
    "mode"
  ],
  "_construct_child_tree_cached": [
    "mode"
  ],
  "_get_all_descendants": [
    "scitype"
  ],
  "_get_all_descendants_cached": [
    "scitype"
  ],
  "_construct_base_class_register": [
    "mixin"
  ],
  "get_base_class_for_str": [
    "scitype_str"
  ],
  "get_base_class_register": [
    "mixin",
    "include_baseobjs"
  ],
  "_construct_scitype_list": [
    "mixin"
  ],
  "get_obj_scitype_list": [
    "mixin",
    "include_baseobjs",
    "return_descriptions"
  ],
  "get_base_class_list": [
    "mixin",
    "include_baseobjs"
  ],
  "get_base_class_lookup": [
    "mixin",
    "include_baseobjs"
  ],
  "series_annotator": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ],
    "get_test_class": [
      "cls"
    ]
  },
  "transformer_series_to_primitives": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "transformer_series_to_series": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "transformer_panel_to_tabular": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "transformer_panel_to_panel": {
    "_tags": [],
    "get_base_class": [
      "cls"
    ]
  },
  "ALIAS_DICT": [],
  "is_scitype": [
    "obj",
    "scitypes"
  ],
  "resolve_alias": [
    "alias"
  ],
  "all_estimators": [
    "estimator_types",
    "filter_tags",
    "exclude_estimators",
    "return_names",
    "as_dataframe",
    "return_tags",
    "suppress_import_stdout"
  ],
  "_check_list_of_str_or_error": [
    "arg_to_check",
    "arg_name"
  ],
  "_get_return_tags": [
    "estimator",
    "return_tags"
  ],
  "all_tags": [
    "estimator_types",
    "as_dataframe"
  ],
  "_check_estimator_types": [
    "estimator_types"
  ],
  "_coerce_register": [],
  "_coerce_transformer_tabular_to_transformer": [
    "obj"
  ],
  "_coerce_series_annotator_to_transformer": [
    "obj"
  ],
  "_coerce_clusterer_to_transformer": [
    "obj"
  ],
  "coerce_scitype": [
    "obj",
    "to_scitype",
    "from_scitype",
    "clone_obj",
    "raise_on_unknown",
    "raise_on_mismatch",
    "msg"
  ],
  "all_coercible_to": [
    "to_scitype"
  ],
  "_extract_class_names": [
    "spec"
  ],
  "craft": [
    "spec"
  ],
  "deps": [
    "spec"
  ],
  "imports": [
    "spec"
  ],
  "_get_public_import": [
    "module_path"
  ],
  "_BaseTag": {
    "_tags": []
  },
  "object_type": {
    "_tags": []
  },
  "maintainers": {
    "_tags": []
  },
  "authors": {
    "_tags": []
  },
  "python_version": {
    "_tags": []
  },
  "python_dependencies": {
    "_tags": []
  },
  "env_marker": {
    "_tags": []
  },
  "requires_cython": {
    "_tags": []
  },
  "tests__core": {
    "_tags": []
  },
  "tests__vm": {
    "_tags": []
  },
  "tests__libs": {
    "_tags": []
  },
  "tests__skip_all": {
    "_tags": []
  },
  "tests__skip_by_name": {
    "_tags": []
  },
  "capability__missing_values": {
    "_tags": []
  },
  "capability__feature_importance": {
    "_tags": []
  },
  "capability__sample_weight": {
    "_tags": []
  },
  "capability__contractable": {
    "_tags": []
  },
  "capability__train_estimate": {
    "_tags": []
  },
  "capability__random_state": {
    "_tags": []
  },
  "fit_is_empty": {
    "_tags": []
  },
  "property__randomness": {
    "_tags": []
  },
  "capability__exogeneous": {
    "_tags": []
  },
  "capability__insample": {
    "_tags": []
  },
  "capability__pred_int": {
    "_tags": []
  },
  "capability__pred_int__insample": {
    "_tags": []
  },
  "requires_fh_in_fit": {
    "_tags": []
  },
  "capability__categorical_in_X": {
    "_tags": []
  },
  "capability__categorical_in_y": {
    "_tags": []
  },
  "capability__multivariate": {
    "_tags": []
  },
  "capability__unequal_length": {
    "_tags": []
  },
  "capability__multioutput": {
    "_tags": []
  },
  "capability__predict": {
    "_tags": []
  },
  "capability__predict_proba": {
    "_tags": []
  },
  "capability__class_weight": {
    "_tags": []
  },
  "capability__out_of_sample": {
    "_tags": []
  },
  "scitype__transform_input": {
    "_tags": []
  },
  "scitype__transform_output": {
    "_tags": []
  },
  "requires_x": {
    "_tags": []
  },
  "requires_y": {
    "_tags": []
  },
  "scitype__transform_labels": {
    "_tags": []
  },
  "capability__inverse_transform": {
    "_tags": []
  },
  "capability__inverse_transform__range": {
    "_tags": []
  },
  "capability__inverse_transform__exact": {
    "_tags": []
  },
  "transform_returns_same_time_index": {
    "_tags": []
  },
  "capability__hierarchical_reconciliation": {
    "_tags": []
  },
  "capability__bootstrap_index": {
    "_tags": []
  },
  "capability__unequal_length__removes": {
    "_tags": []
  },
  "capability__unequal_length__adds": {
    "_tags": []
  },
  "capability__update": {
    "_tags": []
  },
  "task": {
    "_tags": []
  },
  "learning_type": {
    "_tags": []
  },
  "distribution_type": {
    "_tags": []
  },
  "capability__variable_identification": {
    "_tags": []
  },
  "capability__multiple_alignment": {
    "_tags": []
  },
  "capability__distance": {
    "_tags": []
  },
  "capability__distance_matrix": {
    "_tags": []
  },
  "property__alignment_type": {
    "_tags": []
  },
  "capability__pairwise_parameter_estimation": {
    "_tags": []
  },
  "requires_y_true": {
    "_tags": []
  },
  "requires_y_pred_benchmark": {
    "_tags": []
  },
  "requires_y_train": {
    "_tags": []
  },
  "lower_is_better": {
    "_tags": []
  },
  "scitype__y_pred": {
    "_tags": []
  },
  "inner_implements_multilevel": {
    "_tags": []
  },
  "x_inner_mtype": {
    "_tags": []
  },
  "y_inner_mtype": {
    "_tags": []
  },
  "is_univariate": {
    "_tags": []
  },
  "is_one_series": {
    "_tags": []
  },
  "n_panels": {
    "_tags": []
  },
  "is_one_panel": {
    "_tags": []
  },
  "is_equally_spaced": {
    "_tags": []
  },
  "is_equal_length": {
    "_tags": []
  },
  "is_equal_index": {
    "_tags": []
  },
  "is_empty": {
    "_tags": []
  },
  "has_nans": {
    "_tags": []
  },
  "n_instances": {
    "_tags": []
  },
  "n_instances_train": {
    "_tags": []
  },
  "n_instances_test": {
    "_tags": []
  },
  "frequency": {
    "_tags": []
  },
  "has_exogenous": {
    "_tags": []
  },
  "n_hierarchy_levels": {
    "_tags": []
  },
  "n_splits": {
    "_tags": []
  },
  "name": {
    "_tags": []
  },
  "n_timepoints_train": {
    "_tags": []
  },
  "n_timepoints_test": {
    "_tags": []
  },
  "n_dimensions": {
    "_tags": []
  },
  "task_type": {
    "_tags": []
  },
  "visual_block_kind": {
    "_tags": []
  },
  "ESTIMATOR_TAG_REGISTER": [],
  "tag_clses": [],
  "ESTIMATOR_TAG_TABLE": [],
  "ESTIMATOR_TAG_LIST": [],
  "check_tag_is_valid": [
    "tag_name",
    "tag_value"
  ],
  "test_scitype": [
    "coerce_to_list"
  ],
  "test_scitype_generic": [
    "force_single_scitype",
    "coerce_to_list"
  ],
  "test_is_scitype": [],
  "test_sklearn_scitypes": [],
  "test_tag_register_type": [],
  "simple_spec": [],
  "simple_spec_with_dep": [],
  "pipe_spec_no_deps": [],
  "pipe_spec_with_deps": [],
  "dunder_spec_no_deps": [],
  "dunder_spec_with_deps": [],
  "specs": [],
  "test_craft": [
    "spec"
  ],
  "test_deps": [
    "spec"
  ],
  "test_imports": [],
  "test_deps_with_disjunction": [],
  "b": [],
  "BASE_CLASS_SCITYPE_LIST": [],
  "double_estimator_scitypes": [],
  "estimator_scitype_fixture": [],
  "_to_list": [
    "obj"
  ],
  "_get_type_tuple": [
    "estimator_scitype"
  ],
  "test_all_estimators_by_scitype": [
    "estimator_scitype",
    "return_names"
  ],
  "test_all_tags": [
    "estimator_scitype"
  ],
  "test_all_estimators_return_names": [
    "return_names"
  ],
  "test_all_estimators_exclude_estimators": [
    "exclude_estimators"
  ],
  "_get_tag_fixture": [],
  "test_all_estimators_return_tags": [
    "return_tags",
    "return_names"
  ],
  "_get_bad_return_tags": [],
  "test_all_estimators_return_tags_bad_arg": [
    "return_tags"
  ],
  "test_all_estimators_tag_filter": [
    "tag_value",
    "tag_name"
  ],
  "test_scitype_inference": [
    "estimator_scitype"
  ],
  "_check_cutoffs_and_y": [
    "cutoffs",
    "y"
  ],
  "_check_cutoffs_fh_y": [
    "cutoffs",
    "fh",
    "y"
  ],
  "CutoffSplitter": {
    "__init__": [
      "self",
      "cutoffs",
      "fh",
      "window_length"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_cutoffs": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CutoffFhSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "cutoff",
      "fh"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ForecastingHorizonSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "fh"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ExpandingSlidingWindowSplitter": {
    "__init__": [
      "self",
      "fh",
      "step_length",
      "initial_window",
      "max_expanding_window_length"
    ],
    "_initial_window": [
      "self"
    ],
    "_split_windows": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TestPlusTrainSplitter": {
    "__init__": [
      "self",
      "cv"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ExpandingGreedySplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "test_size",
      "folds",
      "step_length"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "InstanceSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "cv"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SlidingGreedySplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "train_size",
      "test_size",
      "folds",
      "step_length"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SameLocSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "cv",
      "y_template"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SingleWindowSplitter": {
    "__init__": [
      "self",
      "fh",
      "window_length"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_cutoffs": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_is_datetimelike": [
    "x"
  ],
  "_is_int": [
    "arg"
  ],
  "_validate_cutoff": [
    "cutoff"
  ],
  "ExpandingCutoffSplitter": {
    "__init__": [
      "self",
      "cutoff",
      "fh",
      "step_length"
    ],
    "_split": [
      "self",
      "y",
      "fh"
    ],
    "_validate_y": [
      "self",
      "y"
    ],
    "_get_first_cutoff_index": [
      "self",
      "y_index"
    ],
    "get_cutoffs": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TemporalTrainTestSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "train_size",
      "test_size",
      "anchor"
    ],
    "_split": [
      "self",
      "y"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_check_expanding_windows": [
    "windows"
  ],
  "test_expanding_window_splitter_start_with_initial_window_zero": [
    "y",
    "fh",
    "step_length"
  ],
  "test_expanding_window_splitter_start_with_empty_window": [
    "y",
    "fh",
    "initial_window",
    "step_length"
  ],
  "test_expanding_window_splitter": [
    "y",
    "fh",
    "initial_window",
    "step_length"
  ],
  "test_expanding_greedy_splitter_lengths": [],
  "test_expanding_greedy_splitter_dates": [],
  "test_expanding_greedy_splitter_hierarchy": [],
  "test_expanding_greedy_splitter_consecutive": [],
  "test_expanding_greedy_splitter_forecast_horizon": [],
  "_check_windows": [
    "windows",
    "allow_empty_window"
  ],
  "_check_cutoffs": [
    "cutoffs"
  ],
  "_check_n_splits": [
    "n_splits"
  ],
  "_check_cutoffs_against_test_windows": [
    "cutoffs",
    "windows",
    "fh",
    "y"
  ],
  "_check_cutoffs_against_train_windows": [
    "cutoffs",
    "windows",
    "y"
  ],
  "_get_n_incomplete_windows": [
    "window_length",
    "step_length"
  ],
  "test_window_splitter_in_sample_fh_smaller_than_window_length": [
    "CV"
  ],
  "test_window_splitter_in_sample_fh_greater_than_window_length": [
    "CV"
  ],
  "test_sliding_greedy_splitter_lengths": [],
  "test_sliding_greedy_splitter_forecast_horizon": [],
  "test_sliding_greedy_splitter_indices": [],
  "test_sliding_greedy_splitter_dates": [],
  "test_sliding_greedy_splitter_hierarchy": [],
  "test_sliding_greedy_splitter_consecutive": [],
  "test_sliding_greedy_splitter_step_length": [],
  "test_expandingcutoff_datelike_index_001": [],
  "test_expandingcutoff_int_index_002": [],
  "test_expandingcutoff_ytype_cutofftype_combos_003a": [],
  "test_expandingcutoff_ytype_cutofftype_combos_003b": [],
  "test_expandingcutoff_ytype_cutofftype_combos_003c": [],
  "test_expandingcutoff_splitloc_004": [],
  "test_expandingcutoff_hierarchical_splitloc_005": [],
  "test_expandingcutoff_hierarchical_forecastbylevel_006": [],
  "test_expandingcutoff_fh_list_007": [],
  "test_expanding_cutoff_period_008": [],
  "_make_splits_listlike": [
    "splits"
  ],
  "test_expanding_cutoff_docstring_examples": [],
  "test_expandingcutoff_fh": [],
  "test_expandingcutoff_step_length": [],
  "test_cutoff_window_splitter": [
    "y",
    "cutoffs",
    "fh",
    "window_length"
  ],
  "test_cutoff_fh_splitter": [],
  "_check_train_test_split_y": [
    "fh",
    "split"
  ],
  "test_split_by_fh": [
    "index_type",
    "fh_type",
    "is_relative",
    "values"
  ],
  "test_temporal_train_test_split_float_only_y": [],
  "test_temporal_train_test_split_int_only_y": [],
  "test_temporal_train_test_split_hierarchical": [],
  "test_single_window_splitter": [
    "y",
    "fh",
    "window_length"
  ],
  "test_single_window_splitter_default_window_length": [
    "y",
    "fh"
  ],
  "SplitterFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllSplitters": {
    "test_split": [
      "self",
      "estimator_instance",
      "hierarchical"
    ],
    "test_split_loc": [
      "self",
      "estimator_instance",
      "hierarchical"
    ],
    "test_split_series": [
      "self",
      "estimator_instance",
      "hierarchical"
    ]
  },
  "test_sliding_window_splitter": [
    "y",
    "fh",
    "window_length",
    "step_length"
  ],
  "test_sliding_window_splitter_with_initial_window": [
    "y",
    "fh",
    "window_length",
    "step_length",
    "initial_window"
  ],
  "test_sliding_window_splitter_start_with_empty_window": [
    "y",
    "fh",
    "window_length",
    "step_length"
  ],
  "test_sliding_window_splitter_initial_window_start_with_empty_window_raises_error": [],
  "test_sliding_window_splitter_initial_window_smaller_than_window_raise_error": [],
  "test_same_loc_splitter": [],
  "test_same_loc_splitter_hierarchical": [],
  "Repeat": {
    "_tags": [],
    "__init__": [
      "self",
      "splitter",
      "times",
      "mode",
      "random_repeat"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "_repeat": [
      "self",
      "y",
      "method"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseSplitter": {
    "_tags": [],
    "__init__": [
      "self",
      "fh",
      "window_length"
    ],
    "split": [
      "self",
      "y"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_vectorized": [
      "self",
      "y"
    ],
    "split_loc": [
      "self",
      "y"
    ],
    "_split_loc": [
      "self",
      "y"
    ],
    "split_series": [
      "self",
      "y"
    ],
    "_coerce_to_index": [
      "self",
      "y"
    ],
    "_check_y": [
      "self",
      "y",
      "allow_index"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_cutoffs": [
      "self",
      "y"
    ],
    "get_fh": [
      "self"
    ],
    "_get_train_window": [
      "y",
      "train_start",
      "split_point"
    ]
  },
  "DEFAULT_STEP_LENGTH": [],
  "DEFAULT_WINDOW_LENGTH": [],
  "DEFAULT_FH": [],
  "ACCEPTED_Y_TYPES": [],
  "FORECASTING_HORIZON_TYPES": [],
  "SPLIT_TYPE": [],
  "SPLIT_ARRAY_TYPE": [],
  "SPLIT_GENERATOR_TYPE": [],
  "_inputs_are_supported": [
    "args"
  ],
  "_check_inputs_for_compatibility": [
    "args"
  ],
  "_get_end": [
    "y_index",
    "fh"
  ],
  "_get_train_window_via_endpoint": [
    "y",
    "train_endpoint",
    "window_length"
  ],
  "_check_window_lengths": [
    "y",
    "fh",
    "window_length",
    "initial_window"
  ],
  "BaseWindowSplitter": {
    "__init__": [
      "self",
      "fh",
      "initial_window",
      "window_length",
      "step_length",
      "start_with_window",
      "max_expanding_window_length"
    ],
    "_initial_window": [
      "self"
    ],
    "_split": [
      "self",
      "y"
    ],
    "_split_for_initial_window": [
      "self",
      "y"
    ],
    "_split_windows": [
      "self",
      "window_length",
      "y",
      "fh"
    ],
    "_split_windows_generic": [
      "self",
      "window_length",
      "y",
      "fh",
      "expanding"
    ],
    "_get_train_start": [
      "start",
      "window_length",
      "y"
    ],
    "_get_start": [
      "self",
      "y",
      "fh"
    ],
    "get_n_splits": [
      "self",
      "y"
    ],
    "get_cutoffs": [
      "self",
      "y"
    ]
  },
  "TEST_Y_PANEL_HIERARCHICAL": [],
  "test_split_series": [],
  "test_split_loc": [],
  "test_split_series_hier": [],
  "test_hierarchical_singlewindowsplitter": [],
  "test_windowbase_splitter_get_n_split_hierarchical": [
    "CV",
    "fh",
    "window_length",
    "step_length"
  ],
  "test_windowbase_splitter_get_n_split_unequal_series": [
    "y",
    "CV"
  ],
  "FCNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_ESRNN": {
    "__init__": [
      "self",
      "input_shape",
      "hidden_size",
      "pred_len",
      "num_layer",
      "season1_length",
      "season2_length",
      "seasonality"
    ],
    "_nonseasonal": [
      "self",
      "x"
    ],
    "_single_seasonal": [
      "self",
      "x"
    ],
    "_double_seasonal": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ESRNN": {
    "_tags": [],
    "__init__": [
      "self",
      "input_shape",
      "hidden_size",
      "pred_len",
      "num_layer",
      "season1_length",
      "season2_length",
      "seasonality"
    ],
    "pin_ball": [
      "self"
    ],
    "_build": [
      "self"
    ]
  },
  "InceptionTimeNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "n_filters",
      "use_residual",
      "use_bottleneck",
      "bottleneck_size",
      "depth",
      "kernel_size",
      "random_state",
      "activation",
      "activation_inception"
    ],
    "_inception_module": [
      "self",
      "input_tensor",
      "activation",
      "activation_output",
      "stride"
    ],
    "_shortcut_layer": [
      "self",
      "input_tensor",
      "out_tensor",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ]
  },
  "BaseDeepNetwork": {
    "_tags": [],
    "build_network": [
      "self",
      "input_shape"
    ]
  },
  "Splitting": {
    "__init__": [
      "self"
    ],
    "_build": [
      "self"
    ]
  },
  "Interactor": {
    "__init__": [
      "self",
      "in_planes",
      "splitting",
      "kernel",
      "dropout",
      "groups",
      "hidden_size",
      "INN"
    ],
    "_build": [
      "self"
    ]
  },
  "InteractorLevel": {
    "__init__": [
      "self",
      "in_planes",
      "kernel",
      "dropout",
      "groups",
      "hidden_size",
      "INN"
    ],
    "_build": [
      "self"
    ]
  },
  "LevelSCINet": {
    "__init__": [
      "self",
      "in_planes",
      "kernel_size",
      "dropout",
      "groups",
      "hidden_size",
      "INN"
    ],
    "_build": [
      "self"
    ]
  },
  "SCINet_Tree": {
    "__init__": [
      "self",
      "in_planes",
      "current_level",
      "kernel_size",
      "dropout",
      "groups",
      "hidden_size",
      "INN"
    ],
    "_build": [
      "self"
    ]
  },
  "EncoderTree": {
    "__init__": [
      "self",
      "in_planes",
      "num_levels",
      "kernel_size",
      "dropout",
      "groups",
      "hidden_size",
      "INN"
    ],
    "_build": [
      "self"
    ]
  },
  "SCINet": {
    "__init__": [
      "self",
      "pred_len",
      "seq_len",
      "input_dim",
      "hid_size",
      "num_stacks",
      "num_levels",
      "num_decoder_layer",
      "concat_len",
      "groups",
      "kernel",
      "dropout",
      "single_step_output_One",
      "positionalE",
      "modified",
      "RIN"
    ],
    "_build": [
      "self"
    ]
  },
  "get_variable": [
    "x"
  ],
  "ResNetNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MCDCNNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "kernel_size",
      "pool_size",
      "filter_sizes",
      "dense_units",
      "conv_padding",
      "pool_padding",
      "random_state",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "_prepare_input": [
      "self",
      "X"
    ]
  },
  "MLPNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ]
  },
  "CNTCNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "random_state",
      "rnn_layer",
      "filter_sizes",
      "kernel_sizes",
      "lstm_size",
      "dense_size",
      "activation",
      "activation_attention"
    ],
    "build_network": [
      "self",
      "input_shape"
    ]
  },
  "RBFLayer": {
    "__init__": [
      "self",
      "in_features",
      "out_features",
      "centers",
      "gamma",
      "rbf_type"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "RBFNetwork": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "output_size",
      "centers",
      "gamma",
      "rbf_type",
      "hidden_layers",
      "mode",
      "activation",
      "dropout_rate"
    ],
    "_get_activation_fn": [
      "self",
      "activation_name"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_get_activation_fn": [
    "activation"
  ],
  "FixedPositionalEncoding": {
    "__init__": [
      "self",
      "d_model",
      "dropout",
      "max_len",
      "scale_factor"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "LearnablePositionalEncoding": {
    "__init__": [
      "self",
      "d_model",
      "dropout",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "get_pos_encoder": [
    "pos_encoding"
  ],
  "TransformerBatchNormEncoderLayer": {
    "__init__": [
      "self",
      "d_model",
      "nhead",
      "dim_feedforward",
      "dropout",
      "activation"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "forward": [
      "self",
      "src",
      "src_mask",
      "src_key_padding_mask",
      "is_causal"
    ]
  },
  "TSTransformerEncoder": {
    "__init__": [
      "self",
      "feat_dim",
      "max_len",
      "d_model",
      "n_heads",
      "num_layers",
      "dim_feedforward",
      "dropout",
      "pos_encoding",
      "activation",
      "norm",
      "freeze"
    ],
    "forward": [
      "self",
      "X",
      "padding_masks"
    ]
  },
  "TSTransformerEncoderClassiregressor": {
    "__init__": [
      "self",
      "feat_dim",
      "max_len",
      "d_model",
      "n_heads",
      "num_layers",
      "dim_feedforward",
      "num_classes",
      "dropout",
      "pos_encoding",
      "activation",
      "norm",
      "freeze"
    ],
    "build_output_module": [
      "self",
      "d_model",
      "max_len",
      "num_classes"
    ],
    "forward": [
      "self",
      "X",
      "padding_masks"
    ]
  },
  "GRU": {
    "_tags": [],
    "__init__": [
      "self",
      "input_size",
      "hidden_dim",
      "n_layers",
      "batch_first",
      "bias",
      "num_classes",
      "init_weights",
      "dropout",
      "fc_dropout",
      "bidirectional"
    ],
    "_init_weights": [
      "self",
      "module"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "GRUFCNN": {
    "_tags": [],
    "__init__": [
      "self",
      "input_size",
      "hidden_dim",
      "gru_layers",
      "batch_first",
      "bias",
      "num_classes",
      "init_weights",
      "dropout",
      "gru_dropout",
      "bidirectional",
      "conv_layers",
      "kernel_sizes"
    ],
    "_init_gru_weights": [
      "self",
      "module"
    ],
    "_init_conv_weights": [
      "self",
      "module"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "Conv": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "padding"
    ]
  },
  "Concat": {
    "__init__": [
      "self",
      "dim"
    ],
    "forward": [
      "self",
      "x1",
      "x2"
    ]
  },
  "CNNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "kernel_size",
      "avg_pool_size",
      "n_conv_layers",
      "filter_sizes",
      "activation",
      "padding",
      "random_state"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LSTMFCNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "kernel_sizes",
      "filter_sizes",
      "random_state",
      "lstm_size",
      "dropout",
      "attention",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CINNNetwork": {
    "__init__": [
      "self",
      "horizon",
      "cond_features",
      "encoded_cond_size",
      "num_coupling_layers",
      "hidden_dim_size",
      "activation"
    ],
    "build": [
      "self"
    ]
  },
  "TapNetNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "dropout",
      "filter_sizes",
      "kernel_size",
      "dilation",
      "layers",
      "use_rp",
      "rp_params",
      "use_att",
      "use_lstm",
      "use_cnn",
      "random_state",
      "padding",
      "activation"
    ],
    "output_conv_size": [
      "in_size",
      "kernel_size",
      "strides",
      "padding"
    ],
    "euclidean_dist": [
      "x",
      "y"
    ],
    "build_network": [
      "self",
      "input_shape"
    ]
  },
  "MACNNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "padding",
      "pool_size",
      "strides",
      "repeats",
      "filter_sizes",
      "kernel_size",
      "reduction",
      "random_state",
      "activation"
    ],
    "_macnn_block": [
      "self",
      "x",
      "kernels",
      "reduce"
    ],
    "_stack": [
      "self",
      "x",
      "repeats",
      "kernels",
      "reduce"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "NetworkFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllNetworks": {
    "test_dummy": [
      "self",
      "estimator_instance"
    ]
  },
  "get_activation_fn": [
    "activation"
  ],
  "SublayerConnection": {
    "__init__": [
      "self",
      "enable_res_parameter",
      "dropout"
    ],
    "forward": [
      "self",
      "x",
      "out_x"
    ]
  },
  "_ConvEncoderLayer": {
    "__init__": [
      "self",
      "kernel_size",
      "d_model",
      "d_ff",
      "dropout",
      "activation",
      "enable_res_param",
      "norm",
      "small_ks",
      "re_param",
      "device"
    ],
    "_get_merge_param": [
      "self"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "_ConvEncoder": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "kernel_size",
      "dropout",
      "activation",
      "n_layers",
      "enable_res_param",
      "norm",
      "re_param",
      "device"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "ConvTimeNet_backbone": {
    "__init__": [
      "self",
      "c_in",
      "c_out",
      "seq_len",
      "n_layers",
      "d_model",
      "d_ff",
      "dropout",
      "act",
      "pooling_tp",
      "fc_dropout",
      "enable_res_param",
      "dw_ks",
      "norm",
      "use_embed",
      "re_param",
      "device"
    ],
    "create_head": [
      "self",
      "nf",
      "c_out",
      "act",
      "pooling_tp",
      "fc_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "weights_init": [
    "mod"
  ],
  "PositionalEncoding": {
    "__init__": [
      "self",
      "d_model",
      "dropout",
      "max_len"
    ],
    "forward": [
      "self",
      "x",
      "seqlen",
      "pos"
    ]
  },
  "SimplePatch": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "seq_len",
      "patch_size",
      "stride",
      "norm",
      "padding_tp",
      "device"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "BoxCoder": {
    "__init__": [
      "self",
      "patch_count",
      "patch_stride",
      "patch_size",
      "seq_len",
      "channels",
      "weights",
      "tanh",
      "device"
    ],
    "_generate_anchor": [
      "self",
      "device"
    ],
    "forward": [
      "self",
      "boxes"
    ],
    "decode": [
      "self",
      "rel_codes"
    ],
    "meshgrid": [
      "self",
      "boxes"
    ]
  },
  "OffsetPredictor": {
    "__init__": [
      "self",
      "in_feats",
      "patch_size",
      "stride",
      "act",
      "mod"
    ],
    "forward": [
      "self",
      "X"
    ]
  },
  "DeformablePatch": {
    "__init__": [
      "self",
      "in_feats",
      "out_feats",
      "seq_len",
      "patch_size",
      "stride",
      "padding_tp",
      "norm",
      "act",
      "offset_mod"
    ],
    "get_sampling_location": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X",
      "return_bound"
    ]
  },
  "ConvTimeNet": {
    "_tags": [],
    "__init__": [
      "self",
      "enc_in",
      "d_model",
      "seq_len",
      "patch_size",
      "patch_stride",
      "n_classes",
      "dropout",
      "d_ff",
      "dw_ks",
      "device"
    ],
    "build": [
      "self"
    ]
  },
  "tensor": [],
  "Flatten_Head": {
    "__init__": [
      "self",
      "n_vars",
      "nf",
      "target_window",
      "head_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ConviEncoder": {
    "__init__": [
      "self",
      "patch_num",
      "patch_len",
      "kernel_size",
      "n_layers",
      "d_model",
      "d_ff",
      "norm",
      "dropout",
      "act",
      "enable_res_param",
      "re_param",
      "re_param_kernel",
      "device"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ConvEncoder": {
    "__init__": [
      "self",
      "kernel_size",
      "d_model",
      "d_ff",
      "norm",
      "dropout",
      "activation",
      "enable_res_param",
      "n_layers",
      "re_param",
      "re_param_kernel",
      "device"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "ConvEncoderLayer": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "kernel_size",
      "dropout",
      "activation",
      "enable_res_param",
      "norm",
      "re_param",
      "small_ks",
      "device"
    ],
    "_get_merged_param": [
      "self"
    ],
    "forward": [
      "self",
      "src"
    ]
  },
  "RevIN": {
    "__init__": [
      "self",
      "num_features",
      "eps",
      "affine",
      "subtract_last"
    ],
    "forward": [
      "self",
      "x",
      "mode"
    ],
    "_init_params": [
      "self"
    ],
    "_get_statistics": [
      "self",
      "x"
    ],
    "_normalize": [
      "self",
      "x"
    ],
    "_denormalize": [
      "self",
      "x"
    ]
  },
  "zero_init": [
    "m"
  ],
  "DepatchSampling": {
    "__init__": [
      "self",
      "in_feats",
      "seq_len",
      "patch_size",
      "stride",
      "device"
    ],
    "get_sampling_location": [
      "self",
      "X"
    ],
    "forward": [
      "self",
      "X",
      "return_bound"
    ]
  },
  "NNModule": [],
  "RNNNetworkTorch": {
    "_tags": [],
    "__init__": [
      "self",
      "input_size",
      "num_classes",
      "hidden_dim",
      "n_layers",
      "activation",
      "activation_hidden",
      "bias",
      "batch_first",
      "init_weights",
      "dropout",
      "fc_dropout",
      "bidirectional",
      "random_state"
    ],
    "forward": [
      "self",
      "X"
    ],
    "_init_weights": [
      "self",
      "module"
    ],
    "_instantiate_activation": [
      "self"
    ]
  },
  "RNNNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "units",
      "random_state",
      "activation"
    ],
    "build_network": [
      "self",
      "input_shape"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LTSFTriangularCausalMask": {
    "__init__": [
      "self",
      "B",
      "L",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "LTSFProbMask": {
    "__init__": [
      "self",
      "B",
      "H",
      "L",
      "index",
      "scores",
      "device"
    ],
    "mask": [
      "self"
    ]
  },
  "fn_month_embed": [
    "x"
  ],
  "fn_day_embed": [
    "x"
  ],
  "fn_weekday_embed": [
    "x"
  ],
  "fn_hour_embed": [
    "x"
  ],
  "fn_second": [
    "x"
  ],
  "fn_minute": [
    "x"
  ],
  "fn_hour": [
    "x"
  ],
  "fn_dayofweek": [
    "x"
  ],
  "fn_day": [
    "x"
  ],
  "fn_dayofyear": [
    "x"
  ],
  "fn_month": [
    "x"
  ],
  "fn_week": [
    "x"
  ],
  "features_by_offsets": [],
  "get_mapping_functions": [
    "temporal_encoding_type",
    "freq"
  ],
  "generate_temporal_features": [
    "index",
    "temporal_encoding_type",
    "freq"
  ],
  "get_mark_vocab_sizes": [
    "temporal_encoding_type",
    "freq"
  ],
  "SeriesDecomposer": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "_build": [
      "self"
    ]
  },
  "MovingAverage": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTransformerConvLayer": {
    "__init__": [
      "self",
      "in_channels"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTransformerEncoderLayer": {
    "__init__": [
      "self",
      "attention",
      "d_model",
      "d_ff",
      "dropout",
      "activation"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTransformerEncoder": {
    "__init__": [
      "self",
      "attn_layers",
      "conv_layers",
      "norm_layer"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTransformerDecoderLayer": {
    "__init__": [
      "self",
      "self_attention",
      "cross_attention",
      "d_model",
      "d_ff",
      "dropout",
      "activation"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTransformerDecoder": {
    "__init__": [
      "self",
      "layers",
      "norm_layer",
      "projection"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFFullAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFProbAttention": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFAttentionLayer": {
    "__init__": [
      "self",
      "attention",
      "d_model",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "_build": [
      "self"
    ]
  },
  "AutoCorrelation": {
    "__init__": [
      "self",
      "mask_flag",
      "factor",
      "scale",
      "attention_dropout",
      "output_attention"
    ],
    "_build": [
      "self"
    ]
  },
  "AutoCorrelationLayer": {
    "__init__": [
      "self",
      "correlation",
      "d_model",
      "n_heads",
      "d_keys",
      "d_values"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFPositionalEmbedding": {
    "__init__": [
      "self",
      "d_model",
      "max_len"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTokenEmbedding": {
    "__init__": [
      "self",
      "in_channels",
      "d_model"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFTemporalEmbedding": {
    "__init__": [
      "self",
      "temporal_encoding_type",
      "mark_vocab_sizes",
      "d_model"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFDataEmbedding": {
    "__init__": [
      "self",
      "in_channels",
      "d_model",
      "dropout",
      "mark_vocab_sizes",
      "position_encoding",
      "temporal_encoding",
      "temporal_encoding_type"
    ],
    "_build": [
      "self"
    ]
  },
  "PytorchFormerDataset": {
    "__init__": [
      "self",
      "y",
      "seq_len",
      "context_len",
      "pred_len",
      "freq",
      "temporal_encoding",
      "temporal_encoding_type"
    ],
    "_prepare_data": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "LTSFTransformerNetwork": {
    "__init__": [
      "self",
      "seq_len",
      "context_len",
      "pred_len",
      "output_attention",
      "mark_vocab_sizes",
      "position_encoding",
      "temporal_encoding",
      "temporal_encoding_type",
      "enc_in",
      "dec_in",
      "d_model",
      "n_heads",
      "d_ff",
      "e_layers",
      "d_layers",
      "factor",
      "dropout",
      "activation",
      "c_out"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFLinearNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len",
      "in_channels",
      "individual"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFDLinearNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len",
      "in_channels",
      "individual"
    ],
    "_build": [
      "self"
    ]
  },
  "LTSFNLinearNetwork": {
    "_tags": [],
    "__init__": [
      "self",
      "seq_len",
      "pred_len",
      "in_channels",
      "individual"
    ],
    "_build": [
      "self"
    ]
  },
  "sklearn_to_sktime": [
    "estimator"
  ],
  "make_pipeline": [],
  "MethodNotImplementedError": {
    "__init__": [
      "self",
      "message"
    ]
  },
  "Pipeline": {
    "__init__": [
      "self",
      "steps"
    ],
    "_get_unique_id": [
      "self",
      "skobject"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_get_step": [
      "self",
      "name"
    ],
    "add_step": [
      "self",
      "skobject",
      "name",
      "edges",
      "method"
    ],
    "_assemble_steps": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_set_attributes": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "y"
    ],
    "predict_interval": [
      "self",
      "X",
      "y"
    ],
    "predict_quantiles": [
      "self",
      "X",
      "y"
    ],
    "predict_residuals": [
      "self",
      "X",
      "y"
    ],
    "_initiate_call": [
      "self",
      "X",
      "y",
      "kwargs"
    ],
    "_method_allowed": [
      "self",
      "method"
    ],
    "_create_subsetter": [
      "self",
      "edg"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ALLOWED_METHODS": [],
  "StepResult": {
    "__init__": [
      "self",
      "result",
      "mode"
    ]
  },
  "test_add_steps": [
    "steps"
  ],
  "test_add_steps_name_conflict": [],
  "test_add_step_cloned": [],
  "test_method": [
    "method",
    "mro",
    "allowed_method"
  ],
  "test_pipeline_call_not_available": [
    "steps",
    "method",
    "expected_message"
  ],
  "test_get_result_none_predecessor": [],
  "test_get_results_predecessors": [],
  "test_get_allowed_methods": [
    "skobject",
    "allowed_methods"
  ],
  "test_transformer_regression": [],
  "test_classifier_regression": [],
  "test_forecaster_regression": [
    "method"
  ],
  "test_exogenous_transform_regression": [],
  "test_endogenous_exogenous_transform_regression": [],
  "test_feature_union_regression": [],
  "test_feature_union_subsetting_regression": [],
  "test_varying_mtypes": [
    "data",
    "testing_method"
  ],
  "test_forecasterX_regression": [],
  "test_lagged_y_prediction": [],
  "_get_fcst_with_exog_and_proba": [],
  "load": [
    "serial"
  ],
  "SERIALIZATION_FORMATS": [],
  "BaseObject": {
    "_tags": [],
    "_config": [],
    "_config_doc": [],
    "__eq__": [
      "self",
      "other"
    ],
    "_get_set_config_doc": [
      "cls"
    ],
    "_init_dynamic_doc": [
      "cls"
    ],
    "save": [
      "self",
      "path",
      "serialization_format"
    ],
    "load_from_serial": [
      "cls",
      "serial"
    ],
    "load_from_path": [
      "cls",
      "serial"
    ]
  },
  "TagAliaserMixin": {
    "alias_dict": [],
    "deprecate_dict": [],
    "get_class_tag": [
      "cls",
      "tag_name",
      "tag_value_default"
    ],
    "get_tag": [
      "self",
      "tag_name",
      "tag_value_default",
      "raise_error"
    ],
    "set_tags": [
      "self"
    ],
    "_complete_dict": [
      "cls",
      "tag_dict",
      "direction"
    ],
    "_translate_tags": [
      "cls",
      "new_tag_dict",
      "tag_dict",
      "old_tag",
      "direction"
    ],
    "_package_name": [],
    "FLIPPED_TAGS": []
  },
  "BaseEstimator": {
    "GET_FITTED_PARAMS_NESTING": []
  },
  "_clone_estimator": [
    "base_estimator",
    "random_state"
  ],
  "_safe_clone": [
    "object"
  ],
  "deepcopy_func": [
    "f",
    "name"
  ],
  "BasePanelMixin": {
    "METADATA_REQ_IN_CHECKS": [],
    "VECTORIZATION_ATTR": [],
    "TASK": [],
    "EST_TYPE": [],
    "EST_TYPE_PLURAL": [],
    "_vectorize": [
      "self",
      "methodname"
    ],
    "_fit_predict_boilerplate": [
      "self",
      "X",
      "y",
      "cv",
      "change_state",
      "method",
      "return_type"
    ],
    "_subset": [
      "self",
      "obj",
      "ix"
    ],
    "_pool": [
      "self",
      "y_preds",
      "tt_ixx",
      "y"
    ],
    "_check_convert_X_for_predict": [
      "self",
      "X"
    ],
    "_check_capabilities": [
      "self",
      "X_metadata"
    ],
    "_convert_X": [
      "self",
      "X",
      "X_mtype"
    ],
    "_check_y": [
      "self",
      "y",
      "return_to_mtype"
    ],
    "_get_output_mtype": [
      "self",
      "y"
    ],
    "_convert_output_y": [
      "self",
      "y"
    ],
    "_check_input": [
      "self",
      "X",
      "y",
      "enforce_min_instances",
      "return_metadata"
    ],
    "_internal_convert": [
      "self",
      "X",
      "y"
    ]
  },
  "_HeterogenousMetaEstimator": {
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "_tags": [],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "is_composite": [
      "self"
    ],
    "_get_params": [
      "self",
      "attr",
      "deep",
      "fitted"
    ],
    "_set_params": [
      "self",
      "attr"
    ],
    "_replace_estimator": [
      "self",
      "attr",
      "name",
      "new_val"
    ],
    "_check_names": [
      "self",
      "names"
    ],
    "_subset_dict_keys": [
      "self",
      "dict_to_subset",
      "keys",
      "prefix"
    ],
    "_is_name_and_est": [
      "obj",
      "cls_type"
    ],
    "_check_estimators": [
      "self",
      "estimators",
      "attr_name",
      "cls_type",
      "allow_dict",
      "allow_mix",
      "allow_empty",
      "clone_ests"
    ],
    "_coerce_estimator_tuple": [
      "self",
      "obj",
      "clone_est"
    ],
    "_get_estimator_list": [
      "self",
      "estimators"
    ],
    "_get_estimator_names": [
      "self",
      "estimators",
      "make_unique"
    ],
    "_get_estimator_tuples": [
      "self",
      "estimators",
      "clone_ests"
    ],
    "_make_strings_unique": [
      "self",
      "strlist"
    ],
    "_dunder_concat": [
      "self",
      "other",
      "base_class",
      "composite_class",
      "attr_name",
      "concat_order",
      "composite_params"
    ],
    "_anytagis": [
      "self",
      "tag_name",
      "value",
      "estimators"
    ],
    "_anytagis_then_set": [
      "self",
      "tag_name",
      "value",
      "value_if_not",
      "estimators"
    ],
    "_anytag_notnone_val": [
      "self",
      "tag_name",
      "estimators"
    ],
    "_anytag_notnone_set": [
      "self",
      "tag_name",
      "estimators"
    ],
    "_tagchain_is_linked": [
      "self",
      "left_tag_name",
      "mid_tag_name",
      "estimators",
      "left_tag_val",
      "mid_tag_val"
    ],
    "_tagchain_is_linked_set": [
      "self",
      "left_tag_name",
      "mid_tag_name",
      "estimators",
      "left_tag_val",
      "mid_tag_val",
      "left_tag_val_not",
      "mid_tag_val_not"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "flatten": [
    "obj"
  ],
  "unflatten": [
    "obj",
    "template"
  ],
  "unflat_len": [
    "obj"
  ],
  "is_flat": [
    "obj"
  ],
  "_ColumnEstimator": {
    "_coerce_to_pd_index": [
      "self",
      "obj",
      "ref"
    ],
    "_get_indices": [
      "self",
      "y",
      "idx"
    ],
    "_by_column": [
      "self",
      "methodname"
    ],
    "_check_col_estimators": [
      "self",
      "X",
      "X_name",
      "est_attr",
      "cls"
    ]
  },
  "Normal": {
    "_tags": [],
    "__init__": [
      "self",
      "mu",
      "sigma",
      "index",
      "columns"
    ],
    "energy": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "var": [
      "self"
    ],
    "pdf": [
      "self",
      "x"
    ],
    "log_pdf": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "ppf": [
      "self",
      "p"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseDistribution": {
    "_tags": [],
    "__init__": [
      "self",
      "index",
      "columns"
    ],
    "loc": [
      "self"
    ],
    "iloc": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "_loc": [
      "self",
      "rowidx",
      "colidx"
    ],
    "_subset_params": [
      "self",
      "rowidx",
      "colidx"
    ],
    "_iloc": [
      "self",
      "rowidx",
      "colidx"
    ],
    "_get_dist_params": [
      "self"
    ],
    "to_str": [
      "self"
    ],
    "_method_error_msg": [
      "self",
      "method",
      "severity",
      "fill_in"
    ],
    "_get_bc_params": [
      "self"
    ],
    "pdf": [
      "self",
      "x"
    ],
    "log_pdf": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "ppf": [
      "self",
      "p"
    ],
    "energy": [
      "self",
      "x"
    ],
    "mean": [
      "self"
    ],
    "var": [
      "self"
    ],
    "pdfnorm": [
      "self",
      "a"
    ],
    "_coerce_to_self_index_df": [
      "self",
      "x"
    ],
    "quantile": [
      "self",
      "alpha"
    ],
    "sample": [
      "self",
      "n_samples"
    ]
  },
  "_Indexer": {
    "__init__": [
      "self",
      "ref",
      "method"
    ],
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "_BaseTFDistribution": {
    "_tags": [],
    "__init__": [
      "self",
      "index",
      "columns",
      "distr"
    ],
    "__str__": [
      "self"
    ],
    "pdf": [
      "self",
      "x"
    ],
    "log_pdf": [
      "self",
      "x"
    ],
    "cdf": [
      "self",
      "x"
    ],
    "sample": [
      "self",
      "n_samples"
    ]
  },
  "_prod_multiindex": [
    "ix1",
    "ix2"
  ],
  "_PredictProbaMixin": {
    "_predict_interval": [
      "self",
      "coverage"
    ],
    "_predict_quantiles": [
      "self",
      "alpha"
    ],
    "_predict_var": [
      "self",
      "cov"
    ],
    "_predict_proba": [
      "self",
      "marginal"
    ],
    "_add_det_to_proba": [
      "self",
      "y_proba",
      "y_pred"
    ]
  },
  "AliaserTestClass": {
    "_tags": [],
    "alias_dict": [],
    "deprecate_dict": [],
    "__init__": [
      "self"
    ]
  },
  "test_tag_aliaser": [],
  "test_get_fitted_params_sklearn": [],
  "test_get_fitted_params_sklearn_nested": [],
  "test_clone_nested_sklearn": [],
  "FixtureClassParent": {
    "_tags": []
  },
  "FixtureClassChild": {
    "_tags": []
  },
  "FIXTURE_CLASSCHILD": [],
  "FIXTURE_CLASSCHILD_TAGS": [],
  "FIXTURE_OBJECT": [],
  "FIXTURE_OBJECT_TAGS": [],
  "DEFAULT_TAGS": [],
  "test_get_class_tags": [],
  "test_get_class_tag": [],
  "test_get_tags": [],
  "test_get_tag": [],
  "test_get_tag_raises": [],
  "FIXTURE_TAG_SET": [],
  "FIXTURE_OBJECT_SET": [],
  "FIXTURE_OBJECT_SET_TAGS": [],
  "FIXTURE_OBJECT_SET_DYN": [],
  "test_set_tags": [],
  "CompositionDummy": {
    "__init__": [
      "self",
      "foo",
      "bar"
    ]
  },
  "test_is_composite": [],
  "ResetTester": {
    "clsvar": [],
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "foo": [
      "self",
      "d"
    ]
  },
  "test_reset": [],
  "test_reset_composite": [],
  "test_components": [],
  "AliasTester": {
    "__init__": [
      "self",
      "a",
      "bar"
    ]
  },
  "test_param_alias": [],
  "test_nested_set_params_and_alias": [],
  "FittableCompositionDummy": {
    "__init__": [
      "self",
      "foo",
      "bar"
    ],
    "fit": [
      "self"
    ]
  },
  "ConfigTester": {
    "_config": [],
    "clsvar": [],
    "__init__": [
      "self",
      "a",
      "b"
    ]
  },
  "test_set_get_config": [],
  "test_eq_dunder": [],
  "_TslearnAdapter": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "_get_tslearn_object": [
      "self"
    ],
    "_init_tslearn_object": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "_PytsAdapter": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_pyts_class": [
      "self"
    ],
    "_get_pyts_object": [
      "self"
    ],
    "_init_pyts_object": [
      "self"
    ],
    "_call_with_y_optional": [
      "self",
      "method",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "_predict_proba": [
      "self",
      "X",
      "y"
    ]
  },
  "DISTANCES_SUPPORTED": [],
  "_BaseKnnTimeSeriesEstimator": {
    "__init__": [
      "self",
      "n_neighbors",
      "weights",
      "algorithm",
      "distance",
      "distance_params",
      "distance_mtype",
      "pass_train_distances",
      "leaf_size",
      "n_jobs"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_fit_dist": [
      "self",
      "X",
      "y"
    ],
    "_fit_precomp": [
      "self",
      "X",
      "y"
    ],
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_dist": [
      "self",
      "X"
    ],
    "_predict_precomp": [
      "self",
      "X"
    ]
  },
  "BaseTimeSeriesForest": {
    "__init__": [
      "self",
      "min_interval",
      "n_estimators",
      "n_jobs",
      "inner_series_length",
      "random_state"
    ],
    "_estimator": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "_get_intervals": [
    "n_intervals",
    "min_interval",
    "series_length",
    "rng",
    "inner_series_length"
  ],
  "compute_interval_length": [
    "capped_min_interval",
    "current_interval_start",
    "inner_intervals_step",
    "interval_max_length",
    "rng"
  ],
  "_fit_estimator": [
    "estimator",
    "X",
    "y",
    "intervals"
  ],
  "test_get_intervals": [
    "number_of_intervals",
    "min_interval",
    "number_of_series",
    "inner_series_length",
    "expected_intervals"
  ],
  "test_get_intervals_should_produce_as_much_interval_as_given": [
    "number_of_intervals",
    "min_interval",
    "inner_series_length",
    "number_of_series"
  ],
  "test_get_intervals_at_least_greater_than_min_interval_given": [
    "number_of_intervals",
    "min_interval",
    "inner_series_length",
    "number_of_series"
  ],
  "test_get_intervals_equals_to_inner_series_length_given_too_high_min_interval": [
    "number_of_intervals",
    "min_interval",
    "inner_series_length",
    "number_of_series"
  ],
  "test_get_intervals_should_produce_valid_intervals": [
    "number_of_intervals",
    "min_interval",
    "inner_series_length",
    "number_of_series"
  ],
  "test_get_intervals_should_produce_intervals_contained_in_inner_series_bins": [
    "number_of_intervals",
    "min_interval",
    "inner_series_length",
    "number_of_series"
  ],
  "test_feature_importances_single_feature_interval_and_estimator": [],
  "test_feature_importances_multi_intervals_estimators": [
    "n_intervals",
    "n_estimators"
  ],
  "BaseParamFitter": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "update": [
      "self",
      "X",
      "y"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y"
    ],
    "_validate_data": [
      "self",
      "data",
      "var_name"
    ],
    "_update_X_y": [
      "self",
      "X",
      "y"
    ],
    "_update_data": [
      "self",
      "data",
      "self_data"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ]
  },
  "FixedParams": {
    "_tags": [],
    "__init__": [
      "self",
      "param_dict"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SeasonalityACF": {
    "_tags": [],
    "__init__": [
      "self",
      "candidate_sp",
      "p_threshold",
      "adjusted",
      "nlags",
      "fft",
      "missing"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SeasonalityACFqstat": {
    "_tags": [],
    "__init__": [
      "self",
      "candidate_sp",
      "p_threshold",
      "p_adjust",
      "adjusted",
      "nlags",
      "fft",
      "missing"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SeasonalityPeriodogram": {
    "_tags": [],
    "__init__": [
      "self",
      "min_period",
      "max_period",
      "thresh"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityADF": {
    "_tags": [],
    "__init__": [
      "self",
      "p_threshold",
      "maxlag",
      "regression",
      "autolag"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityKPSS": {
    "_tags": [],
    "__init__": [
      "self",
      "p_threshold",
      "regression",
      "nlags"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BreakvarHeteroskedasticityTest": {
    "_tags": [],
    "__init__": [
      "self",
      "subset_length",
      "alternative",
      "use_f"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityADFArch": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "max_lags",
      "method",
      "low_memory",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityDFGLS": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "max_lags",
      "method",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityPhillipsPerron": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "test_type",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityKPSSArch": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityZivotAndrews": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "trim",
      "max_lags",
      "method",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "StationarityVarianceRatio": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "trend",
      "overlap",
      "robust",
      "debiased",
      "p_threshold"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_seasonality_acf": [],
  "test_paramplugin_dict": [],
  "test_seasonality_acf_pipeline": [],
  "test_seasonality_acf_qstat": [],
  "test_stationarity_adf": [],
  "test_stationarity_kpss": [],
  "ParamFitterFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllParamFitters": {
    "test_get_fitted_params": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_update": [
      "self",
      "estimator_instance"
    ]
  },
  "JarqueBera": {
    "_tags": [],
    "__init__": [
      "self",
      "axis"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_resolve_param_map": [
    "param_est",
    "estimator",
    "params"
  ],
  "PluginParamsForecaster": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "param_est",
      "forecaster",
      "params",
      "update_params"
    ],
    "_fit": [
      "self",
      "y",
      "X",
      "fh"
    ],
    "_update": [
      "self",
      "y",
      "X",
      "update_params"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PluginParamsTransformer": {
    "_tags": [],
    "_delegate_name": [],
    "__init__": [
      "self",
      "param_est",
      "transformer",
      "params",
      "update_params"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_plugin_fcst": [],
  "test_plugin_trafo": [],
  "AcorrLjungbox": {
    "_tags": [],
    "__init__": [
      "self",
      "lags",
      "boxpierce"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ARLagOrderSelector": {
    "_tags": [],
    "__init__": [
      "self",
      "maxlag",
      "ic",
      "glob",
      "trend",
      "seasonal",
      "hold_back",
      "period",
      "missing"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ParamFitterPipeline": {
    "_tags": [],
    "__init__": [
      "self",
      "param_est",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "_update": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "FunctionParamFitter": {
    "_tags": [],
    "__init__": [
      "self",
      "param",
      "func",
      "kw_args",
      "X_type"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_lambda_test_simple": [
    "X"
  ],
  "_lambda_test_kwarg": [
    "X",
    "kwarg"
  ],
  "BaseRegressor": {
    "_tags": [],
    "METADATA_REQ_IN_CHECKS": [],
    "VECTORIZATION_ATTR": [],
    "TASK": [],
    "EST_TYPE": [],
    "EST_TYPE_PLURAL": [],
    "__init__": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "multioutput"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "_DelegatedRegressor": {
    "_delegate_name": [],
    "_get_delegate": [
      "self"
    ],
    "_set_delegated_tags": [
      "self",
      "delegate"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ]
  },
  "DummyRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "strategy",
      "constant",
      "quantile"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "test_dummy_regressor": [],
  "TimeSeriesForestRegressor": {
    "_tags": [],
    "_base_estimator": [],
    "__init__": [
      "self",
      "min_interval",
      "n_estimators",
      "n_jobs",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_predict": [
    "X",
    "estimator",
    "intervals"
  ],
  "RocketRegressor": {
    "_tags": [],
    "VALID_ROCKET_STRINGS": [],
    "VALID_MULTIVAR_VALUES": [],
    "__init__": [
      "self",
      "num_kernels",
      "rocket_transform",
      "max_dilations_per_kernel",
      "n_features_per_kernel",
      "use_multivariate",
      "n_jobs",
      "random_state"
    ],
    "estimator_": [
      "self"
    ],
    "_get_delegate": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TimeSeriesSVRTslearn": {
    "_tags": [],
    "_estimator_attr": [],
    "_get_tslearn_class": [
      "self"
    ],
    "__init__": [
      "self",
      "C",
      "kernel",
      "degree",
      "gamma",
      "coef0",
      "shrinking",
      "tol",
      "epsilon",
      "cache_size",
      "n_jobs",
      "verbose",
      "max_iter"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "KNeighborsTimeSeriesRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_neighbors",
      "weights",
      "algorithm",
      "distance",
      "distance_params",
      "distance_mtype",
      "pass_train_distances",
      "leaf_size",
      "n_jobs"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "test_gridsearch_with_categorical": [],
  "RegressorFixtureGenerator": {
    "estimator_type_filter": []
  },
  "TestAllRegressors": {
    "test_multivariate_input_exception": [
      "self",
      "estimator_instance"
    ],
    "test_regressor_output": [
      "self",
      "estimator_instance",
      "scenario"
    ],
    "test_multioutput": [
      "self",
      "estimator_instance"
    ]
  },
  "_DummyRegressor": {
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "_DummyDeepRegressorEmpty": {
    "__init__": [
      "self"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_DummyDeepRegressorFull": {
    "__init__": [
      "self",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_base_regressor_fit": [],
  "test__check_regressor_input": [],
  "FCNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "InceptionTimeRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "n_filters",
      "use_residual",
      "use_bottleneck",
      "bottleneck_size",
      "depth",
      "callbacks",
      "random_state",
      "verbose",
      "loss",
      "metrics",
      "activation",
      "activation_hidden",
      "activation_inception"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_check_callbacks": [
      "self",
      "callbacks"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseDeepRegressor": {
    "_tags": [],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "save": [
      "self",
      "path"
    ],
    "get_custom_objects": [],
    "load_from_serial": [
      "cls",
      "serial"
    ],
    "load_from_path": [
      "cls",
      "serial"
    ]
  },
  "ResNetRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "batch_size",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MCDCNNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "pool_size",
      "filter_sizes",
      "dense_units",
      "conv_padding",
      "pool_padding",
      "loss",
      "activation",
      "activation_hidden",
      "use_bias",
      "callbacks",
      "metrics",
      "optimizer",
      "verbose",
      "random_state"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ]
  },
  "MLPRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CNTCRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "filter_sizes",
      "kernel_sizes",
      "rnn_size",
      "lstm_size",
      "dense_size",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "activation_attention"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "prepare_input": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ],
    "get_custom_objects": []
  },
  "SimpleRNNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "units",
      "callbacks",
      "add_default_callback",
      "random_state",
      "verbose",
      "loss",
      "metrics",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "CNNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "kernel_size",
      "avg_pool_size",
      "n_conv_layers",
      "callbacks",
      "verbose",
      "loss",
      "metrics",
      "random_state",
      "activation",
      "activation_hidden",
      "use_bias",
      "optimizer",
      "filter_sizes",
      "padding"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "LSTMFCNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "dropout",
      "kernel_sizes",
      "filter_sizes",
      "lstm_size",
      "attention",
      "callbacks",
      "random_state",
      "verbose",
      "activation",
      "activation_hidden"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TapNetRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "dropout",
      "filter_sizes",
      "kernel_size",
      "dilation",
      "layers",
      "use_rp",
      "activation",
      "activation_hidden",
      "rp_params",
      "use_bias",
      "use_att",
      "use_lstm",
      "use_cnn",
      "random_state",
      "padding",
      "loss",
      "optimizer",
      "metrics",
      "callbacks",
      "verbose"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MACNNRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "n_epochs",
      "batch_size",
      "padding",
      "pool_size",
      "strides",
      "repeats",
      "filter_sizes",
      "kernel_size",
      "reduction",
      "loss",
      "use_bias",
      "metrics",
      "optimizer",
      "callbacks",
      "random_state",
      "verbose",
      "activation",
      "activation_hidden"
    ],
    "build_model": [
      "self",
      "input_shape"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "RegressorPipeline": {
    "_tags": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "regressor",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SklearnRegressorPipeline": {
    "_tags": [],
    "_required_parameters": [],
    "__init__": [
      "self",
      "regressor",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "_steps": [
      "self"
    ],
    "steps_": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "_convert_X_to_sklearn": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MultiplexRegressor": {
    "_tags": [],
    "_delegate_name": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "regressors",
      "selected_regressor"
    ],
    "_regressors": [
      "self",
      "value"
    ],
    "_check_selected_regressor": [
      "self"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__ror__": [
      "self",
      "other"
    ],
    "_set_regressor": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ComposableTimeSeriesForestRegressor": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "n_estimators",
      "criterion",
      "max_depth",
      "min_samples_split",
      "min_samples_leaf",
      "min_weight_fraction_leaf",
      "max_features",
      "max_leaf_nodes",
      "min_impurity_decrease",
      "bootstrap",
      "oob_score",
      "n_jobs",
      "random_state",
      "verbose",
      "warm_start",
      "max_samples"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_repr_html_inner": [
      "self"
    ],
    "_repr_mimebundle_": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_validate_estimator": [
      "self"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y"
    ],
    "_validate_y_class_weight": [
      "self",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "TSRGridSearchCV": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "param_grid",
      "scoring",
      "n_jobs",
      "refit",
      "cv",
      "verbose",
      "pre_dispatch",
      "error_score",
      "return_train_score",
      "tune_by_variable"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_get_fitted_params": [
      "self"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BinarySegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "threshold",
      "min_cp_distance",
      "max_iter"
    ],
    "_cumsum_statistic": [
      "self",
      "X",
      "start",
      "end",
      "change_point"
    ],
    "_find_change_points": [
      "self",
      "X",
      "threshold",
      "min_cp_distance",
      "max_iter"
    ],
    "_predict": [
      "self",
      "X",
      "Y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "STRAY": {
    "_tags": [],
    "__init__": [
      "self",
      "alpha",
      "k",
      "knn_algorithm",
      "p",
      "size_threshold",
      "outlier_tail"
    ],
    "_find_threshold": [
      "self",
      "outlier_score",
      "n"
    ],
    "_find_outliers_kNN": [
      "self",
      "X",
      "n"
    ],
    "_find_outliers": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "HMM": {
    "_tags": [],
    "__init__": [
      "self",
      "emission_funcs",
      "transition_prob_mat",
      "initial_probs"
    ],
    "_validate_init": [
      "self"
    ],
    "_calculate_trans_mats": [
      "initial_probs",
      "emi_probs",
      "transition_prob_mat",
      "num_obs",
      "num_states"
    ],
    "_make_emission_probs": [
      "emission_funcs",
      "observations"
    ],
    "_hmm_viterbi_label": [
      "num_obs",
      "states",
      "trans_prob",
      "trans_id"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "_overlapping_window": [
    "window_size",
    "step_size",
    "X"
  ],
  "_window_timeseries": [
    "window_size",
    "X"
  ],
  "_window": [
    "window_size",
    "X"
  ],
  "_flattenSegments": [
    "sub_seg"
  ],
  "_finalLabels": [
    "labels",
    "window_size",
    "X"
  ],
  "_overlap_final_label": [
    "labels",
    "window_size",
    "step_size",
    "X"
  ],
  "_aggregate_labels": [
    "flabel"
  ],
  "WindowSegmenter": {
    "_tags": [],
    "__init__": [
      "self",
      "clusterer",
      "window_size",
      "overlap",
      "step_size",
      "return_segments"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ChangePointResult": {},
  "entropy": [
    "X"
  ],
  "generate_segments": [
    "X",
    "change_points"
  ],
  "generate_segments_pandas": [
    "X",
    "change_points"
  ],
  "IGTS": {
    "identity": [
      "self",
      "X"
    ],
    "get_candidates": [
      "self",
      "n_samples",
      "change_points"
    ],
    "information_gain_score": [
      "X",
      "change_points"
    ],
    "find_change_points": [
      "self",
      "X"
    ]
  },
  "SegmentationMixin": {
    "to_classification": [
      "self",
      "change_points"
    ],
    "to_clusters": [
      "self",
      "change_points"
    ]
  },
  "InformationGainSegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "k_max",
      "step"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "piecewise_normal_multivariate": [
    "means",
    "lengths",
    "variances",
    "covariances",
    "random_state"
  ],
  "piecewise_normal": [
    "means",
    "lengths",
    "std_dev",
    "random_state"
  ],
  "piecewise_multinomial": [
    "n_trials",
    "lengths",
    "p_vals",
    "random_state"
  ],
  "piecewise_poisson": [
    "lambdas",
    "lengths",
    "random_state"
  ],
  "labels_with_repeats": [
    "means",
    "std_dev"
  ],
  "label_piecewise_normal": [
    "means",
    "lengths",
    "std_dev",
    "repeated_labels"
  ],
  "GenBasicGauss": {
    "__init__": [
      "self",
      "means",
      "lengths",
      "std_dev",
      "random_state"
    ],
    "sample": [
      "self"
    ]
  },
  "GGS": {
    "initialize_intermediates": [
      "self"
    ],
    "log_likelihood": [
      "self",
      "data"
    ],
    "cumulative_log_likelihood": [
      "self",
      "data",
      "change_points"
    ],
    "add_new_change_point": [
      "self",
      "data"
    ],
    "adjust_change_points": [
      "self",
      "data",
      "change_points",
      "new_index"
    ],
    "identity_segmentation": [
      "self",
      "data"
    ],
    "find_change_points": [
      "self",
      "data"
    ]
  },
  "GreedyGaussianSegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "k_max",
      "lamb",
      "max_shuffles",
      "verbose",
      "random_state"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "SubLOF": {
    "_tags": [],
    "__init__": [
      "self",
      "n_neighbors",
      "window_size"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_split_into_intervals": [
      "x",
      "interval_size"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "find_dominant_window_sizes": [
    "X",
    "offset"
  ],
  "_is_trivial_match": [
    "candidate",
    "change_points",
    "n_timepoints",
    "exclusion_radius"
  ],
  "_segmentation": [
    "X",
    "clasp",
    "n_change_points",
    "exclusion_radius"
  ],
  "ClaSPSegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "period_length",
      "n_cps",
      "exclusion_radius"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_scores": [
      "self",
      "X"
    ],
    "_transform_scores": [
      "self",
      "X"
    ],
    "get_fitted_params": [
      "self"
    ],
    "_run_clasp": [
      "self",
      "X"
    ],
    "_get_interval_series": [
      "self",
      "X",
      "found_cps"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ClusterSegmenter": {
    "_tags": [],
    "__init__": [
      "self",
      "clusterer"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "EAgglo": {
    "_tags": [],
    "__init__": [
      "self",
      "member",
      "alpha",
      "penalty"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_initialize_params": [
      "self",
      "X"
    ],
    "_gof_update": [
      "self",
      "i"
    ],
    "_find_closest": [
      "self",
      "K"
    ],
    "_update_distances": [
      "self",
      "i",
      "j",
      "K"
    ],
    "_get_penalty_func": [
      "self"
    ],
    "get_test_params": [
      "cls"
    ]
  },
  "get_distance": [
    "X",
    "Y",
    "alpha"
  ],
  "len_penalty": [
    "x"
  ],
  "mean_diff_penalty": [
    "x"
  ],
  "DummyRegularAnomalies": {
    "_tags": [],
    "__init__": [
      "self",
      "step_size"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "ZeroAnomalies": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "DummyRegularChangePoints": {
    "_tags": []
  },
  "ZeroChangePoints": {
    "_tags": []
  },
  "ZeroSegments": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "plot_time_series_with_change_points": [
    "ts_name",
    "ts",
    "true_cps",
    "font_size"
  ],
  "plot_time_series_with_profiles": [
    "ts_name",
    "ts",
    "profiles",
    "true_cps",
    "found_cps",
    "score_name",
    "font_size"
  ],
  "time_series_data": [],
  "test_plot_time_series_with_change_points": [
    "time_series_data"
  ],
  "test_plot_time_series_with_profiles": [
    "time_series_data"
  ],
  "test_cut_into_intervals": [
    "x",
    "interval_size",
    "expected_intervals"
  ],
  "test_sublof_does_not_mutate_input": [],
  "test_find_change_points": [
    "X",
    "expected_change_points"
  ],
  "test_fit_predict": [
    "X",
    "expected_change_points"
  ],
  "test_min_seg_length": [
    "X",
    "expected_change_points",
    "min_cp_distance"
  ],
  "test_clasp_sparse": [],
  "test_clasp_dense": [],
  "test_clasp_predict_segments": [],
  "multivariate_mean_shift": [],
  "test_entropy": [],
  "test_igts_identity": [],
  "test_igts_get_candidates": [],
  "test_IGTS_find_change_points": [
    "multivariate_mean_shift"
  ],
  "test_InformationGainSegmentation": [
    "multivariate_mean_shift"
  ],
  "DetectorFixtureGenerator": {
    "estimator_type_filter": [],
    "fixture_sequence": []
  },
  "TestAllDetectors": {
    "test_output_type": [
      "self",
      "estimator_instance"
    ],
    "test_transform_output_type": [
      "self",
      "estimator_instance"
    ],
    "test_predict_points": [
      "self",
      "estimator_instance"
    ],
    "test_predict_segments": [
      "self",
      "estimator_instance"
    ],
    "test_detector_tags": [
      "self",
      "estimator_class"
    ]
  },
  "test_piecewise_poisson": [
    "lambdas",
    "lengths",
    "random_state",
    "output"
  ],
  "test_GaussianHMM_wrapper": [],
  "test_GMMHMM_wrapper": [],
  "test_PoissonHMM_wrapper": [],
  "test_dummy_changepoints": [],
  "test_fit_default_params_univariate": [],
  "test_fit_other_params_univariate": [],
  "test_fit_default_params_multivariate": [],
  "test_len_penalty": [],
  "test_custom_penalty": [],
  "test_default_1D": [],
  "test_default_2D": [],
  "test_1D_score_with_na": [],
  "test_1D_bool_with_na": [],
  "test_2D_score_with_na": [],
  "test_2D_bool_with_na": [],
  "test_2D_score_with_standardize": [],
  "univariate_mean_shift": [],
  "test_GGS_find_change_points": [
    "univariate_mean_shift"
  ],
  "test_GreedyGaussianSegmentation": [
    "univariate_mean_shift"
  ],
  "test_sparse_to_dense": [
    "y_sparse",
    "y_dense_expected",
    "index"
  ],
  "test_dense_to_sparse": [
    "y_dense",
    "y_sparse_expected"
  ],
  "test_change_points_to_segments": [
    "change_points",
    "expected_segments",
    "start",
    "end"
  ],
  "test_segments_to_change_points": [
    "segments",
    "expected_change_points"
  ],
  "test_sparse_segments_to_dense": [
    "y_sparse",
    "index",
    "y_dense_expected"
  ],
  "test_sparse_points_to_dense": [
    "y_sparse",
    "index",
    "y_dense_expected"
  ],
  "test_hmm_basic_gauss": [],
  "test_reject_bad_inputs": [],
  "test_hmm_behaves_as_expected_on_simple_input": [],
  "ThresholdDetector": {
    "_tags": [],
    "__init__": [
      "self",
      "upper",
      "lower",
      "mode"
    ],
    "_predict": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "MovingWindow": {
    "_tags": [],
    "__init__": [
      "self",
      "change_score",
      "bandwidth",
      "threshold_scale",
      "level",
      "min_detection_interval"
    ]
  },
  "SeededBinarySegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "change_score",
      "threshold_scale",
      "level",
      "min_segment_length",
      "max_interval_length",
      "growth_factor"
    ]
  },
  "PELT": {
    "_tags": [],
    "__init__": [
      "self",
      "cost",
      "penalty_scale",
      "min_segment_length"
    ]
  },
  "GMMHMM": {
    "__init__": [
      "self",
      "n_components",
      "n_mix",
      "min_covar",
      "startprob_prior",
      "transmat_prior",
      "weights_prior",
      "means_prior",
      "means_weight",
      "covars_prior",
      "covars_weight",
      "algorithm",
      "covariance_type",
      "random_state",
      "n_iter",
      "tol",
      "verbose",
      "params",
      "init_params",
      "implementation"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "BaseHMMLearn": {
    "_tags": [],
    "_hmm_estimator": [],
    "__init__": [
      "self"
    ],
    "_fix_input": [
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "sample": [
      "self",
      "n_samples",
      "random_state",
      "currstate"
    ]
  },
  "PoissonHMM": {
    "_tags": [],
    "__init__": [
      "self",
      "n_components",
      "startprob_prior",
      "transmat_prior",
      "lambdas_prior",
      "lambdas_weight",
      "algorithm",
      "random_state",
      "n_iter",
      "tol",
      "verbose",
      "params",
      "init_params",
      "implementation"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "GaussianHMM": {
    "__init__": [
      "self",
      "n_components",
      "covariance_type",
      "min_covar",
      "startprob_prior",
      "transmat_prior",
      "means_prior",
      "means_weight",
      "covars_prior",
      "covars_weight",
      "algorithm",
      "random_state",
      "n_iter",
      "tol",
      "verbose",
      "params",
      "init_params",
      "implementation"
    ],
    "_fit": [
      "self",
      "X",
      "Y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "DetectorPipeline": {
    "_tags": [],
    "_steps_attr": [],
    "_steps_fitted_attr": [],
    "__init__": [
      "self",
      "steps"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "estimator_": [
      "self"
    ],
    "_get_pipeline_scitypes": [
      "self",
      "estimators"
    ],
    "_get_first_detector_index": [
      "self",
      "estimators"
    ],
    "_check_steps": [
      "self",
      "estimators",
      "allow_postproc"
    ],
    "_iter_transformers": [
      "self",
      "reverse",
      "an_idx"
    ],
    "__len__": [
      "self"
    ],
    "named_steps": [
      "self"
    ],
    "_steps": [
      "self",
      "value"
    ],
    "_components": [
      "self",
      "base_class"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_segments": [
      "self",
      "X"
    ],
    "_predict_points": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AnnotatorPipeline": [],
  "MTYPE_LIST_FOR_DETECTORS": [],
  "DetectorAsTransformer": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "y"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "AnnotatorAsTransformer": [],
  "MVCAPA": {
    "_tags": [],
    "__init__": [
      "self",
      "collective_saving",
      "point_saving",
      "collective_penalty",
      "collective_penalty_scale",
      "point_penalty",
      "point_penalty_scale",
      "min_segment_length",
      "max_segment_length",
      "ignore_point_anomalies"
    ]
  },
  "CircularBinarySegmentation": {
    "_tags": [],
    "__init__": [
      "self",
      "anomaly_score",
      "threshold_scale",
      "level",
      "min_segment_length",
      "max_interval_length",
      "growth_factor"
    ]
  },
  "StatThresholdAnomaliser": {
    "_tags": [],
    "__init__": [
      "self",
      "change_detector",
      "stat",
      "stat_lower",
      "stat_upper"
    ],
    "get_test_params": []
  },
  "CAPA": {
    "_tags": [],
    "__init__": [
      "self",
      "collective_saving",
      "point_saving",
      "collective_penalty_scale",
      "point_penalty_scale",
      "min_segment_length",
      "max_segment_length",
      "ignore_point_anomalies"
    ]
  },
  "seg_middlepoint": [
    "seg_df"
  ],
  "arr_to_seg": [
    "arr"
  ],
  "sparse_pts_to_seg": [
    "arr"
  ],
  "PyODDetector": {
    "_tags": [],
    "__init__": [
      "self",
      "estimator",
      "labels"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "get_test_params": [
      "cls",
      "parameter_set"
    ]
  },
  "PyODAnnotator": [],
  "_convert_points_to_segments": [
    "points_df",
    "len_X",
    "include_labels"
  ],
  "_convert_segments_to_points": [
    "seg_df",
    "len_X"
  ],
  "_get_example_segments_0": [],
  "_get_example_segments_1": [],
  "_get_example_segments_2": [],
  "_get_example_points_2": [],
  "_get_example_segments_3": [],
  "_get_example_points_3": [],
  "_is_valid_detection": [
    "obj",
    "type"
  ],
  "_is_points_dtype": [
    "obj"
  ],
  "_is_segments_dtype": [
    "obj"
  ],
  "test_convert_points_to_segments": [],
  "test_convert_segments_to_points": [],
  "BaseDetector": {
    "_tags": [],
    "__init__": [
      "self"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "transform_scores": [
      "self",
      "X"
    ],
    "predict_scores": [
      "self",
      "X"
    ],
    "update": [
      "self",
      "X",
      "y"
    ],
    "update_predict": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_coerce_to_df": [
      "self",
      "y",
      "columns"
    ],
    "_coerce_intervals_to_values": [
      "self",
      "y"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_predict_scores": [
      "self",
      "X"
    ],
    "_transform_scores": [
      "self",
      "X"
    ],
    "_update": [
      "self",
      "X",
      "y"
    ],
    "predict_segments": [
      "self",
      "X"
    ],
    "predict_points": [
      "self",
      "X"
    ],
    "_predict_segments": [
      "self",
      "X"
    ],
    "_predict_points": [
      "self",
      "X"
    ],
    "sparse_to_dense": [
      "y_sparse",
      "index"
    ],
    "_sparse_points_to_dense": [
      "y_sparse",
      "index"
    ],
    "_sparse_segments_to_dense": [
      "y_sparse",
      "index"
    ],
    "dense_to_sparse": [
      "y_dense"
    ],
    "_empty_sparse": [],
    "_empty_segments": [],
    "change_points_to_segments": [
      "y_sparse",
      "start",
      "end"
    ],
    "segments_to_change_points": [
      "y_sparse"
    ]
  },
  "test_fit_transform_numpy": []
}