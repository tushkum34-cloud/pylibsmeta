{
  "ROOT_DIR": [],
  "QISKIT_DIR": [],
  "_minimal_ext_cmd": [
    "cmd"
  ],
  "git_version": [],
  "get_version_info": [],
  "__version__": [],
  "VariationalAlgorithm": {
    "initial_point": [
      "self",
      "initial_point"
    ]
  },
  "VariationalResult": {
    "__init__": [
      "self"
    ],
    "optimizer_evals": [
      "self",
      "value"
    ],
    "optimizer_time": [
      "self",
      "value"
    ],
    "optimal_value": [
      "self",
      "value"
    ],
    "optimal_point": [
      "self",
      "value"
    ],
    "optimal_parameters": [
      "self",
      "value"
    ],
    "optimizer_result": [
      "self",
      "value"
    ],
    "optimal_circuit": [
      "self",
      "optimal_circuit"
    ]
  },
  "_T": [],
  "ListOrDict": [],
  "AlgorithmJob": {},
  "_Circuits": [],
  "Transpiler": {
    "run": [
      "self",
      "circuits"
    ]
  },
  "__all__": [],
  "run_estimator_job": [
    "estimator",
    "pubs"
  ],
  "AlgorithmError": {},
  "QiskitAlgorithmsWarning": {
    "__init__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "QiskitAlgorithmsOptimizersWarning": {},
  "AlgorithmResult": {
    "__str__": [
      "self"
    ],
    "combine": [
      "self",
      "result"
    ]
  },
  "estimate_observables": [
    "estimator",
    "quantum_state",
    "observables",
    "parameter_values",
    "threshold"
  ],
  "_handle_zero_ops": [
    "observables_list"
  ],
  "_prepare_result": [
    "observables_results",
    "observables"
  ],
  "HamiltonianPhaseEstimation": {
    "__init__": [
      "self",
      "num_evaluation_qubits",
      "sampler"
    ],
    "_get_scale": [
      "self",
      "hamiltonian",
      "bound"
    ],
    "_get_unitary": [
      "self",
      "hamiltonian",
      "pe_scale",
      "evolution"
    ],
    "estimate": [
      "self",
      "hamiltonian",
      "state_preparation",
      "evolution",
      "bound"
    ]
  },
  "_remove_identity": [
    "pauli_sum"
  ],
  "PhaseEstimationResult": {
    "__init__": [
      "self",
      "num_evaluation_qubits",
      "circuit_result",
      "phases"
    ],
    "phases": [
      "self"
    ],
    "circuit_result": [
      "self"
    ],
    "phase": [
      "self"
    ],
    "filter_phases": [
      "self",
      "cutoff",
      "as_float"
    ]
  },
  "_bit_string_to_phase": [
    "binary_string"
  ],
  "_sort_phases": [
    "phases"
  ],
  "PhaseEstimator": {
    "estimate": [
      "self",
      "unitary",
      "state_preparation"
    ]
  },
  "PhaseEstimatorResult": {
    "phase": [
      "self"
    ]
  },
  "IterativePhaseEstimation": {
    "__init__": [
      "self",
      "num_iterations",
      "sampler"
    ],
    "construct_circuit": [
      "self",
      "unitary",
      "state_preparation",
      "k",
      "omega",
      "measurement"
    ],
    "_estimate_phase_iteratively": [
      "self",
      "unitary",
      "state_preparation"
    ],
    "estimate": [
      "self",
      "unitary",
      "state_preparation"
    ]
  },
  "IterativePhaseEstimationResult": {
    "__init__": [
      "self",
      "num_iterations",
      "phase"
    ],
    "phase": [
      "self"
    ],
    "num_iterations": [
      "self"
    ]
  },
  "PhaseEstimationScale": {
    "__init__": [
      "self",
      "bound"
    ],
    "scale": [
      "self"
    ],
    "scale_phase": [
      "self",
      "phi",
      "id_coefficient"
    ],
    "scale_phases": [
      "self",
      "phases",
      "id_coefficient"
    ],
    "from_pauli_sum": [
      "cls",
      "pauli_sum"
    ]
  },
  "HamiltonianPhaseEstimationResult": {
    "__init__": [
      "self",
      "phase_estimation_result",
      "phase_estimation_scale",
      "id_coefficient"
    ],
    "filter_phases": [
      "self",
      "cutoff",
      "scaled",
      "as_float"
    ],
    "phase": [
      "self"
    ],
    "most_likely_eigenvalue": [
      "self"
    ]
  },
  "PhaseEstimation": {
    "__init__": [
      "self",
      "num_evaluation_qubits",
      "sampler"
    ],
    "construct_circuit": [
      "self",
      "unitary",
      "state_preparation"
    ],
    "_add_measurement_if_required": [
      "self",
      "pe_circuit"
    ],
    "_compute_phases": [
      "self",
      "circuit_result"
    ],
    "estimate_from_pe_circuit": [
      "self",
      "pe_circuit"
    ],
    "estimate": [
      "self",
      "unitary",
      "state_preparation"
    ]
  },
  "QFI": {
    "__init__": [
      "self",
      "qgt",
      "precision"
    ],
    "run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "precision": [
      "self",
      "precision"
    ]
  },
  "DerivativeType": {
    "REAL": [],
    "IMAG": [],
    "COMPLEX": []
  },
  "GradientCircuit": {},
  "LinearCombGradientCircuit": {},
  "_make_param_shift_parameter_values": [
    "circuit",
    "parameter_values",
    "parameters"
  ],
  "_make_lin_comb_gradient_circuit": [
    "circuit",
    "add_measurement"
  ],
  "_gate_gradient": [
    "gate"
  ],
  "_make_lin_comb_qgt_circuit": [
    "circuit",
    "add_measurement"
  ],
  "_make_lin_comb_observables": [
    "observable",
    "derivative_type"
  ],
  "_assign_unique_parameters": [
    "circuit"
  ],
  "_make_gradient_parameter_values": [
    "circuit",
    "gradient_circuit",
    "parameter_values"
  ],
  "_make_gradient_parameters": [
    "gradient_circuit",
    "parameters"
  ],
  "QFIResult": {},
  "LinCombSamplerGradient": {
    "SUPPORTED_GATES": [],
    "__init__": [
      "self",
      "sampler",
      "shots"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ]
  },
  "LinCombQGT": {
    "SUPPORTED_GATES": [],
    "__init__": [
      "self",
      "estimator",
      "phase_fix",
      "derivative_type",
      "precision"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ]
  },
  "LinCombEstimatorGradient": {
    "SUPPORTED_GATES": [],
    "__init__": [
      "self",
      "estimator",
      "precision",
      "derivative_type"
    ],
    "derivative_type": [
      "self",
      "derivative_type"
    ],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ]
  },
  "SPSAEstimatorGradient": {
    "__init__": [
      "self",
      "estimator",
      "epsilon",
      "batch_size",
      "seed",
      "precision"
    ],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ]
  },
  "SPSASamplerGradient": {
    "__init__": [
      "self",
      "sampler",
      "epsilon",
      "batch_size",
      "seed",
      "shots"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ]
  },
  "gradient_lookup": [
    "gate"
  ],
  "derive_circuit": [
    "circuit",
    "parameter",
    "check"
  ],
  "split": [
    "circuit",
    "parameters"
  ],
  "bind": [
    "circuits",
    "parameter_binds",
    "inplace"
  ],
  "logger": [],
  "ReverseQGT": {
    "SUPPORTED_GATES": [],
    "__init__": [
      "self",
      "phase_fix",
      "derivative_type"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "parameter_values",
      "parameter_sets"
    ],
    "_to_derivtype": [
      "self",
      "qgt"
    ]
  },
  "_l_term": [
    "coeffs_i",
    "states_i",
    "coeffs_j",
    "states_j"
  ],
  "_phasefix_term": [
    "chi",
    "coeffs",
    "states"
  ],
  "_extract_parameter": [
    "expression"
  ],
  "ReverseEstimatorGradient": {
    "SUPPORTED_GATES": [],
    "__init__": [
      "self",
      "derivative_type"
    ],
    "derivative_type": [
      "self",
      "derivative_type"
    ],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_to_derivtype": [
      "self",
      "gradient"
    ]
  },
  "_evolve_by_operator": [
    "operator",
    "state"
  ],
  "ParamShiftEstimatorGradient": {
    "SUPPORTED_GATES": [],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ]
  },
  "ParamShiftSamplerGradient": {
    "SUPPORTED_GATES": [],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run_unique": [
      "self",
      "circuits",
      "parameter_values",
      "parameters",
      "shots"
    ]
  },
  "FiniteDiffEstimatorGradient": {
    "__init__": [
      "self",
      "estimator",
      "epsilon",
      "precision"
    ],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ]
  },
  "FiniteDiffSamplerGradient": {
    "__init__": [
      "self",
      "sampler",
      "epsilon",
      "shots"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ]
  },
  "BaseEstimatorGradient": {
    "__init__": [
      "self",
      "estimator",
      "precision",
      "derivative_type"
    ],
    "derivative_type": [
      "self"
    ],
    "run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_run": [
      "self",
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "_preprocess": [
      "self",
      "circuits",
      "parameter_values",
      "parameters",
      "supported_gates"
    ],
    "_postprocess": [
      "self",
      "results",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_validate_arguments": [
      "circuits",
      "observables",
      "parameter_values",
      "parameters"
    ],
    "precision": [
      "self",
      "precision"
    ]
  },
  "BaseSamplerGradient": {
    "__init__": [
      "self",
      "sampler",
      "shots"
    ],
    "run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_preprocess": [
      "self",
      "circuits",
      "parameter_values",
      "parameters",
      "supported_gates"
    ],
    "_postprocess": [
      "self",
      "results",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_validate_arguments": [
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "shots": [
      "self",
      "shots"
    ]
  },
  "QGTResult": {},
  "BaseQGT": {
    "__init__": [
      "self",
      "estimator",
      "phase_fix",
      "derivative_type",
      "precision"
    ],
    "derivative_type": [
      "self",
      "derivative_type"
    ],
    "run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_run": [
      "self",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_preprocess": [
      "self",
      "circuits",
      "parameter_values",
      "parameters",
      "supported_gates"
    ],
    "_postprocess": [
      "self",
      "results",
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "_validate_arguments": [
      "circuits",
      "parameter_values",
      "parameters"
    ],
    "precision": [
      "self",
      "precision"
    ]
  },
  "EstimatorGradientResult": {},
  "SamplerGradientResult": {},
  "VQD": {
    "__init__": [
      "self",
      "estimator",
      "fidelity",
      "ansatz",
      "optimizer"
    ],
    "initial_point": [
      "self",
      "initial_point"
    ],
    "ansatz": [
      "self",
      "value"
    ],
    "_check_operator_ansatz": [
      "self",
      "operator"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "compute_eigenvalues": [
      "self",
      "operator",
      "aux_operators"
    ],
    "_get_evaluate_energy": [
      "self",
      "step",
      "operator",
      "betas",
      "current_optimal_point",
      "prev_states"
    ],
    "_build_vqd_result": [],
    "_update_vqd_result": [
      "result",
      "opt_result",
      "eval_time",
      "ansatz",
      "optimal_point"
    ]
  },
  "VQDResult": {
    "__init__": [
      "self"
    ],
    "cost_function_evals": [
      "self",
      "value"
    ],
    "optimizer_times": [
      "self",
      "value"
    ],
    "optimal_values": [
      "self",
      "value"
    ],
    "optimal_points": [
      "self",
      "value"
    ],
    "optimal_parameters": [
      "self",
      "value"
    ],
    "optimizer_results": [
      "self",
      "value"
    ],
    "optimal_circuits": [
      "self",
      "optimal_circuits"
    ]
  },
  "Eigensolver": {
    "compute_eigenvalues": [
      "self",
      "operator",
      "aux_operators"
    ],
    "supports_aux_operators": [
      "cls"
    ]
  },
  "EigensolverResult": {
    "__init__": [
      "self"
    ],
    "eigenvalues": [
      "self",
      "value"
    ],
    "aux_operators_evaluated": [
      "self",
      "value"
    ]
  },
  "FilterType": [],
  "NumPyEigensolver": {
    "__init__": [
      "self",
      "k",
      "filter_criterion"
    ],
    "k": [
      "self",
      "k"
    ],
    "filter_criterion": [
      "self",
      "filter_criterion"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "_check_set_k": [
      "self",
      "operator"
    ],
    "_solve": [
      "self",
      "operator"
    ],
    "_solve_sparse": [
      "op_matrix",
      "k"
    ],
    "_solve_dense": [
      "op_matrix"
    ],
    "_eval_aux_operators": [
      "aux_operators",
      "wavefn",
      "threshold"
    ],
    "compute_eigenvalues": [
      "self",
      "operator",
      "aux_operators"
    ]
  },
  "NumPyEigensolverResult": {
    "__init__": [
      "self"
    ],
    "eigenstates": [
      "self",
      "value"
    ]
  },
  "validate_bounds": [
    "circuit"
  ],
  "_bits_key": [
    "bits",
    "circuit"
  ],
  "_format_params": [
    "param"
  ],
  "_circuit_key": [
    "circuit",
    "functional"
  ],
  "QiskitAlgorithmGlobals": {
    "__init__": [
      "self"
    ],
    "random_seed": [
      "self",
      "seed"
    ],
    "random": [
      "self"
    ]
  },
  "algorithm_globals": [],
  "_set_default_batchsize": [
    "optimizer"
  ],
  "validate_in_set": [
    "name",
    "value",
    "values"
  ],
  "validate_min": [
    "name",
    "value",
    "minimum"
  ],
  "validate_min_exclusive": [
    "name",
    "value",
    "minimum"
  ],
  "validate_max": [
    "name",
    "value",
    "maximum"
  ],
  "validate_max_exclusive": [
    "name",
    "value",
    "maximum"
  ],
  "validate_range": [
    "name",
    "value",
    "minimum",
    "maximum"
  ],
  "validate_range_exclusive": [
    "name",
    "value",
    "minimum",
    "maximum"
  ],
  "validate_range_exclusive_min": [
    "name",
    "value",
    "minimum",
    "maximum"
  ],
  "validate_range_exclusive_max": [
    "name",
    "value",
    "minimum",
    "maximum"
  ],
  "validate_initial_point": [
    "point",
    "circuit"
  ],
  "HAS_NLOPT": [],
  "HAS_SKQUANT": [],
  "HAS_SQSNOBFIT": [],
  "CAN_USE_PHASE_ORACLE": [],
  "StateFidelityResult": {},
  "ComputeUncompute": {
    "__init__": [
      "self",
      "sampler",
      "shots",
      "local"
    ],
    "create_fidelity_circuit": [
      "self",
      "circuit_1",
      "circuit_2"
    ],
    "_run": [
      "self",
      "circuits_1",
      "circuits_2",
      "values_1",
      "values_2"
    ],
    "_call": [
      "job",
      "circuits",
      "local"
    ],
    "shots": [
      "self",
      "shots"
    ],
    "_get_global_fidelity": [
      "probability_distribution"
    ],
    "_get_local_fidelity": [
      "probability_distribution",
      "num_qubits"
    ]
  },
  "BaseStateFidelity": {
    "__init__": [
      "self"
    ],
    "_preprocess_values": [
      "circuits",
      "values"
    ],
    "_check_qubits_match": [
      "self",
      "circuit_1",
      "circuit_2"
    ],
    "create_fidelity_circuit": [
      "self",
      "circuit_1",
      "circuit_2"
    ],
    "_construct_circuits": [
      "self",
      "circuits_1",
      "circuits_2"
    ],
    "_construct_value_list": [
      "self",
      "circuits_1",
      "circuits_2",
      "values_1",
      "values_2"
    ],
    "_run": [
      "self",
      "circuits_1",
      "circuits_2",
      "values_1",
      "values_2"
    ],
    "run": [
      "self",
      "circuits_1",
      "circuits_2",
      "values_1",
      "values_2"
    ],
    "_truncate_fidelities": [
      "fidelities"
    ]
  },
  "BOBYQA": {
    "__init__": [
      "self",
      "maxiter"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "AQGD": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "eta",
      "tol",
      "momentum",
      "param_tol",
      "averaging",
      "max_evals_grouped"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "_compute_objective_fn_and_gradient": [
      "self",
      "params",
      "obj"
    ],
    "_update": [
      "self",
      "params",
      "gradient",
      "mprev",
      "step_size",
      "momentum_coeff"
    ],
    "_converged_objective": [
      "self",
      "objval",
      "tol",
      "window_size"
    ],
    "_converged_parameter": [
      "self",
      "parameter",
      "tol"
    ],
    "_converged_alt": [
      "self",
      "gradient",
      "tol",
      "window_size"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "P_BFGS": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxfun",
      "ftol",
      "iprint",
      "max_processes",
      "options",
      "max_evals_grouped"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "_optimize": [
      "self",
      "objective_function",
      "initial_point",
      "gradient_function",
      "variable_bounds"
    ]
  },
  "COBYLA": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "disp",
      "rhobeg",
      "tol",
      "options"
    ]
  },
  "L_BFGS_B": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxfun",
      "maxiter",
      "ftol",
      "iprint",
      "eps",
      "options",
      "max_evals_grouped"
    ]
  },
  "FIDELITY": [],
  "QNSPSA": {
    "__init__": [
      "self",
      "fidelity",
      "maxiter",
      "blocking",
      "allowed_increase",
      "learning_rate",
      "perturbation",
      "resamplings",
      "perturbation_dims",
      "regularization",
      "hessian_delay",
      "lse_solver",
      "initial_hessian",
      "callback",
      "termination_checker"
    ],
    "_point_sample": [
      "self",
      "loss",
      "x",
      "eps",
      "delta1",
      "delta2"
    ],
    "settings": [
      "self"
    ],
    "get_fidelity": [
      "circuit",
      "sampler"
    ]
  },
  "IMFIL": {
    "__init__": [
      "self",
      "maxiter"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "ADAM": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "tol",
      "lr",
      "beta_1",
      "beta_2",
      "noise_factor",
      "eps",
      "amsgrad",
      "snapshot_dir"
    ],
    "settings": [
      "self"
    ],
    "get_support_level": [
      "self"
    ],
    "save_params": [
      "self",
      "snapshot_dir"
    ],
    "load_params": [
      "self",
      "load_dir"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "TNC": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "disp",
      "accuracy",
      "ftol",
      "xtol",
      "gtol",
      "tol",
      "eps",
      "options",
      "max_evals_grouped"
    ]
  },
  "CALLBACK": [],
  "TERMINATIONCHECKER": [],
  "SPSA": {
    "__init__": [
      "self",
      "maxiter",
      "blocking",
      "allowed_increase",
      "trust_region",
      "learning_rate",
      "perturbation",
      "last_avg",
      "resamplings",
      "perturbation_dims",
      "second_order",
      "regularization",
      "hessian_delay",
      "lse_solver",
      "initial_hessian",
      "callback",
      "termination_checker"
    ],
    "calibrate": [
      "loss",
      "initial_point",
      "c",
      "stability_constant",
      "target_magnitude",
      "alpha",
      "gamma",
      "modelspace",
      "max_evals_grouped"
    ],
    "estimate_stddev": [
      "loss",
      "initial_point",
      "avg",
      "max_evals_grouped"
    ],
    "settings": [
      "self"
    ],
    "_point_sample": [
      "self",
      "loss",
      "x",
      "eps",
      "delta1",
      "delta2"
    ],
    "_point_estimate": [
      "self",
      "loss",
      "x",
      "eps",
      "num_samples"
    ],
    "_compute_update": [
      "self",
      "loss",
      "x",
      "k",
      "eps",
      "lse_solver"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "get_support_level": [
      "self"
    ]
  },
  "bernoulli_perturbation": [
    "dim",
    "perturbation_dims"
  ],
  "powerseries": [
    "eta",
    "power",
    "offset"
  ],
  "constant": [
    "eta"
  ],
  "_batch_evaluate": [
    "function",
    "points",
    "max_evals_grouped",
    "unpack_points"
  ],
  "_as_list": [
    "obj"
  ],
  "_repack_points": [
    "points"
  ],
  "_make_spd": [
    "matrix",
    "bias"
  ],
  "_validate_pert_and_learningrate": [
    "perturbation",
    "learning_rate"
  ],
  "NELDER_MEAD": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "maxfev",
      "disp",
      "xatol",
      "tol",
      "adaptive",
      "options"
    ]
  },
  "UMDA": {
    "ELITE_FACTOR": [],
    "STD_BOUND": [],
    "__init__": [
      "self",
      "maxiter",
      "size_gen",
      "alpha",
      "callback"
    ],
    "_initialization": [
      "self"
    ],
    "_new_generation": [
      "self"
    ],
    "_truncation": [
      "self"
    ],
    "_check_generation": [
      "self",
      "objective_function"
    ],
    "_update_vector": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "size_gen": [
      "self",
      "value"
    ],
    "maxiter": [
      "self",
      "value"
    ],
    "alpha": [
      "self",
      "value"
    ],
    "settings": [
      "self"
    ],
    "get_support_level": [
      "self"
    ]
  },
  "AskData": {},
  "TellData": {},
  "OptimizerState": {
    "__eq__": [
      "self",
      "other"
    ]
  },
  "SteppableOptimizer": {
    "__init__": [
      "self",
      "maxiter"
    ],
    "state": [
      "self",
      "state"
    ],
    "ask": [
      "self"
    ],
    "tell": [
      "self",
      "ask_data",
      "tell_data"
    ],
    "evaluate": [
      "self",
      "ask_data"
    ],
    "_callback_wrapper": [
      "self"
    ],
    "step": [
      "self"
    ],
    "start": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "create_result": [
      "self"
    ],
    "continue_condition": [
      "self"
    ]
  },
  "SLSQP": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "disp",
      "ftol",
      "tol",
      "eps",
      "options",
      "max_evals_grouped"
    ]
  },
  "NFT": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "maxfev",
      "disp",
      "reset_interval",
      "options"
    ]
  },
  "nakanishi_fujii_todo": [
    "fun",
    "x0",
    "args",
    "maxiter",
    "maxfev",
    "reset_interval",
    "eps",
    "callback"
  ],
  "SciPyOptimizer": {
    "_bounds_support_methods": [],
    "_gradient_support_methods": [],
    "__init__": [
      "self",
      "method",
      "options",
      "max_evals_grouped"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "_wrap_gradient": [
      "gradient_function"
    ]
  },
  "GSLS": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "max_eval",
      "disp",
      "sampling_radius",
      "sample_size_factor",
      "initial_step_size",
      "min_step_size",
      "step_size_multiplier",
      "armijo_parameter",
      "min_gradient_norm",
      "max_failed_rejection_sampling"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "ls_optimize": [
      "self",
      "n",
      "obj_fun",
      "initial_point",
      "var_lb",
      "var_ub"
    ],
    "sample_points": [
      "self",
      "n",
      "x",
      "num_points"
    ],
    "sample_set": [
      "self",
      "n",
      "x",
      "var_lb",
      "var_ub",
      "num_points"
    ],
    "gradient_approximation": [
      "self",
      "n",
      "x",
      "x_value",
      "directions",
      "sample_set_x",
      "sample_set_y"
    ]
  },
  "SNOBFIT": {
    "__init__": [
      "self",
      "maxiter",
      "maxfail",
      "maxmp",
      "verbose"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "GradientDescentState": {
    "__eq__": [
      "self",
      "other"
    ]
  },
  "GradientDescent": {
    "__init__": [
      "self",
      "maxiter",
      "learning_rate",
      "tol",
      "callback",
      "perturbation"
    ],
    "state": [
      "self",
      "state"
    ],
    "tol": [
      "self",
      "tol"
    ],
    "perturbation": [
      "self",
      "perturbation"
    ],
    "_callback_wrapper": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "ask": [
      "self"
    ],
    "tell": [
      "self",
      "ask_data",
      "tell_data"
    ],
    "evaluate": [
      "self",
      "ask_data"
    ],
    "create_result": [
      "self"
    ],
    "start": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "continue_condition": [
      "self"
    ],
    "get_support_level": [
      "self"
    ]
  },
  "POWELL": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "maxfev",
      "disp",
      "xtol",
      "tol",
      "options"
    ]
  },
  "POINT": [],
  "OptimizerResult": {
    "__init__": [
      "self"
    ],
    "x": [
      "self",
      "x"
    ],
    "fun": [
      "self",
      "fun"
    ],
    "jac": [
      "self",
      "jac"
    ],
    "nfev": [
      "self",
      "nfev"
    ],
    "njev": [
      "self",
      "njev"
    ],
    "nit": [
      "self",
      "nit"
    ]
  },
  "Minimizer": {
    "__call__": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "OptimizerSupportLevel": {
    "not_supported": [],
    "ignored": [],
    "supported": [],
    "required": []
  },
  "Optimizer": {
    "__init__": [
      "self"
    ],
    "get_support_level": [
      "self"
    ],
    "set_options": [
      "self"
    ],
    "gradient_num_diff": [
      "x_center",
      "f",
      "epsilon",
      "max_evals_grouped"
    ],
    "wrap_function": [
      "function",
      "args"
    ],
    "setting": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ],
    "gradient_support_level": [
      "self"
    ],
    "is_gradient_ignored": [
      "self"
    ],
    "is_gradient_supported": [
      "self"
    ],
    "is_gradient_required": [
      "self"
    ],
    "bounds_support_level": [
      "self"
    ],
    "is_bounds_ignored": [
      "self"
    ],
    "is_bounds_supported": [
      "self"
    ],
    "is_bounds_required": [
      "self"
    ],
    "initial_point_support_level": [
      "self"
    ],
    "is_initial_point_ignored": [
      "self"
    ],
    "is_initial_point_supported": [
      "self"
    ],
    "is_initial_point_required": [
      "self"
    ],
    "print_options": [
      "self"
    ],
    "set_max_evals_grouped": [
      "self",
      "limit"
    ]
  },
  "CG": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "maxiter",
      "disp",
      "gtol",
      "tol",
      "eps",
      "options",
      "max_evals_grouped"
    ]
  },
  "LearningRate": {
    "__init__": [
      "self",
      "learning_rate"
    ],
    "send": [
      "self",
      "value"
    ],
    "throw": [
      "self",
      "typ",
      "val",
      "tb"
    ],
    "current": [
      "self"
    ]
  },
  "ISRES": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "DIRECT_L": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "DIRECT_L_RAND": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "CRS": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "ESCH": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "SBPLX": {
    "get_nlopt_optimizer": [
      "self"
    ]
  },
  "NLoptOptimizerType": {
    "GN_CRS2_LM": [],
    "GN_DIRECT_L_RAND": [],
    "GN_DIRECT_L": [],
    "GN_ESCH": [],
    "GN_ISRES": [],
    "LN_SBPLX": []
  },
  "NLoptOptimizer": {
    "_OPTIONS": [],
    "__init__": [
      "self",
      "max_evals"
    ],
    "get_nlopt_optimizer": [
      "self"
    ],
    "get_support_level": [
      "self"
    ],
    "settings": [
      "self"
    ],
    "minimize": [
      "self",
      "fun",
      "x0",
      "jac",
      "bounds"
    ]
  },
  "AmplificationProblem": {
    "__init__": [
      "self",
      "oracle",
      "state_preparation",
      "grover_operator",
      "post_processing",
      "objective_qubits",
      "is_good_state"
    ],
    "oracle": [
      "self",
      "oracle"
    ],
    "state_preparation": [
      "self",
      "state_preparation"
    ],
    "post_processing": [
      "self",
      "post_processing"
    ],
    "objective_qubits": [
      "self",
      "objective_qubits"
    ],
    "is_good_state": [
      "self",
      "is_good_state"
    ],
    "grover_operator": [
      "self",
      "grover_operator"
    ]
  },
  "Grover": {
    "__init__": [
      "self",
      "iterations",
      "growth_rate",
      "sample_from_iterations",
      "sampler"
    ],
    "sampler": [
      "self",
      "sampler"
    ],
    "amplify": [
      "self",
      "amplification_problem"
    ],
    "optimal_num_iterations": [
      "num_solutions",
      "num_qubits"
    ],
    "construct_circuit": [
      "self",
      "problem",
      "power",
      "measurement"
    ]
  },
  "GroverResult": {
    "__init__": [
      "self"
    ],
    "iterations": [
      "self",
      "value"
    ]
  },
  "AmplitudeAmplifier": {
    "amplify": [
      "self",
      "amplification_problem"
    ]
  },
  "AmplitudeAmplifierResult": {
    "__init__": [
      "self"
    ],
    "top_measurement": [
      "self",
      "value"
    ],
    "assignment": [
      "self",
      "value"
    ],
    "oracle_evaluation": [
      "self",
      "value"
    ],
    "circuit_results": [
      "self",
      "value"
    ],
    "max_probability": [
      "self",
      "value"
    ]
  },
  "TimeEvolutionProblem": {
    "__init__": [
      "self",
      "hamiltonian",
      "time",
      "initial_state",
      "aux_operators",
      "truncation_threshold",
      "t_param",
      "param_value_map"
    ],
    "time": [
      "self",
      "time"
    ]
  },
  "ImaginaryTimeEvolver": {
    "evolve": [
      "self",
      "evolution_problem"
    ]
  },
  "TimeEvolutionResult": {
    "__init__": [
      "self",
      "evolved_state",
      "aux_ops_evaluated",
      "observables",
      "times"
    ]
  },
  "RealTimeEvolver": {
    "evolve": [
      "self",
      "evolution_problem"
    ]
  },
  "TrotterQRTE": {
    "__init__": [
      "self",
      "product_formula",
      "estimator",
      "num_timesteps"
    ],
    "product_formula": [
      "self",
      "product_formula"
    ],
    "estimator": [
      "self",
      "estimator"
    ],
    "num_timesteps": [
      "self",
      "num_timesteps"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "evolve": [
      "self",
      "evolution_problem"
    ]
  },
  "SciPyRealEvolver": {
    "__init__": [
      "self",
      "num_timesteps"
    ],
    "evolve": [
      "self",
      "evolution_problem"
    ]
  },
  "SciPyImaginaryEvolver": {
    "__init__": [
      "self",
      "num_timesteps"
    ],
    "evolve": [
      "self",
      "evolution_problem"
    ]
  },
  "_create_observable_output": [
    "ops_ev_mean",
    "evolution_problem"
  ],
  "_create_obs_final": [
    "ops_ev_mean",
    "evolution_problem"
  ],
  "_evaluate_aux_ops": [
    "aux_ops",
    "state"
  ],
  "_operator_to_matrix": [
    "operator"
  ],
  "_build_scipy_operators": [
    "evolution_problem",
    "num_timesteps",
    "real_time"
  ],
  "_evolve": [
    "evolution_problem",
    "num_timesteps",
    "real_time"
  ],
  "VarQTEResult": {
    "__init__": [
      "self",
      "evolved_state",
      "aux_ops_evaluated",
      "observables",
      "times",
      "parameter_values"
    ]
  },
  "VarQITE": {
    "__init__": [
      "self",
      "ansatz",
      "initial_parameters",
      "variational_principle",
      "estimator",
      "ode_solver",
      "lse_solver",
      "num_timesteps",
      "imag_part_tol",
      "num_instability_tol"
    ]
  },
  "VarQTE": {
    "__init__": [
      "self",
      "ansatz",
      "initial_parameters",
      "variational_principle",
      "estimator",
      "ode_solver",
      "lse_solver",
      "num_timesteps",
      "imag_part_tol",
      "num_instability_tol"
    ],
    "ansatz": [
      "self",
      "value"
    ],
    "evolve": [
      "self",
      "evolution_problem"
    ],
    "_evolve": [
      "self",
      "init_state_param_dict",
      "hamiltonian",
      "time",
      "t_param"
    ],
    "_create_init_state_param_dict": [
      "param_values",
      "init_state_parameters"
    ],
    "_validate_aux_ops": [
      "self",
      "evolution_problem"
    ]
  },
  "VarQRTE": {
    "__init__": [
      "self",
      "ansatz",
      "initial_parameters",
      "variational_principle",
      "estimator",
      "ode_solver",
      "lse_solver",
      "num_timesteps",
      "imag_part_tol",
      "num_instability_tol"
    ]
  },
  "VariationalPrinciple": {
    "__init__": [
      "self",
      "qgt",
      "gradient"
    ],
    "metric_tensor": [
      "self",
      "ansatz",
      "param_values"
    ],
    "evolution_gradient": [
      "self",
      "hamiltonian",
      "ansatz",
      "param_values",
      "gradient_params"
    ]
  },
  "RealVariationalPrinciple": {},
  "ImaginaryMcLachlanPrinciple": {
    "__init__": [
      "self",
      "qgt",
      "gradient"
    ],
    "evolution_gradient": [
      "self",
      "hamiltonian",
      "ansatz",
      "param_values",
      "gradient_params"
    ],
    "_validate_grad_settings": [
      "gradient"
    ]
  },
  "ImaginaryVariationalPrinciple": {},
  "RealMcLachlanPrinciple": {
    "__init__": [
      "self",
      "qgt",
      "gradient"
    ],
    "evolution_gradient": [
      "self",
      "hamiltonian",
      "ansatz",
      "param_values",
      "gradient_params"
    ],
    "_construct_modified_hamiltonian": [
      "hamiltonian",
      "energy"
    ],
    "_validate_grad_settings": [
      "gradient"
    ]
  },
  "VarQTELinearSolver": {
    "__init__": [
      "self",
      "var_principle",
      "hamiltonian",
      "ansatz",
      "gradient_params",
      "t_param",
      "lse_solver",
      "imag_part_tol"
    ],
    "lse_solver": [
      "self",
      "lse_solver"
    ],
    "solve_lse": [
      "self",
      "param_dict",
      "time_value"
    ]
  },
  "OdeFunctionType": {
    "STANDARD_ODE": []
  },
  "OdeFunctionFactory": {
    "__init__": [
      "self",
      "ode_function_type"
    ],
    "_build": [
      "self",
      "varqte_linear_solver",
      "param_dict",
      "t_param"
    ]
  },
  "ForwardEulerSolver": {
    "__init__": [
      "self",
      "function",
      "t0",
      "y0",
      "t_bound",
      "vectorized",
      "support_complex",
      "num_t_steps"
    ],
    "_step_impl": [
      "self"
    ],
    "_dense_output_impl": [
      "self"
    ]
  },
  "AbstractOdeFunction": {
    "__init__": [
      "self",
      "varqte_linear_solver",
      "param_dict",
      "t_param"
    ],
    "var_qte_ode_function": [
      "self",
      "time",
      "parameter_values"
    ]
  },
  "OdeFunction": {
    "var_qte_ode_function": [
      "self",
      "time",
      "parameter_values"
    ]
  },
  "VarQTEOdeSolver": {
    "__init__": [
      "self",
      "init_params",
      "ode_function",
      "ode_solver",
      "num_timesteps"
    ],
    "run": [
      "self",
      "evolution_time"
    ]
  },
  "PVQDResult": {
    "__init__": [
      "self",
      "evolved_state",
      "aux_ops_evaluated",
      "times",
      "parameters",
      "fidelities",
      "estimated_error",
      "observables"
    ]
  },
  "PVQD": {
    "__init__": [
      "self",
      "fidelity",
      "ansatz",
      "initial_parameters",
      "estimator",
      "optimizer",
      "num_timesteps",
      "evolution",
      "use_parameter_shift",
      "initial_guess"
    ],
    "ansatz": [
      "self",
      "value"
    ],
    "step": [
      "self",
      "hamiltonian",
      "ansatz",
      "theta",
      "dt",
      "initial_guess"
    ],
    "get_loss": [
      "self",
      "hamiltonian",
      "ansatz",
      "dt",
      "current_parameters"
    ],
    "_transpose_param_dicts": [
      "self",
      "params"
    ],
    "evolve": [
      "self",
      "evolution_problem"
    ],
    "_validate_setup": [
      "self",
      "skip"
    ]
  },
  "_is_gradient_supported": [
    "ansatz"
  ],
  "_get_observable_evaluator": [
    "ansatz",
    "observables",
    "estimator"
  ],
  "AmplitudeEstimation": {
    "__init__": [
      "self",
      "num_eval_qubits",
      "phase_estimation_circuit",
      "iqft",
      "sampler"
    ],
    "sampler": [
      "self",
      "sampler"
    ],
    "construct_circuit": [
      "self",
      "estimation_problem",
      "measurement"
    ],
    "evaluate_measurements": [
      "self",
      "circuit_results",
      "threshold"
    ],
    "_evaluate_quasi_probabilities_results": [
      "self",
      "circuit_results"
    ],
    "_evaluate_count_results": [
      "self",
      "counts"
    ],
    "compute_mle": [
      "result",
      "apply_post_processing"
    ],
    "estimate": [
      "self",
      "estimation_problem"
    ],
    "compute_confidence_interval": [
      "result",
      "alpha",
      "kind"
    ]
  },
  "AmplitudeEstimationResult": {
    "__init__": [
      "self"
    ],
    "num_evaluation_qubits": [
      "self",
      "num_evaluation_qubits"
    ],
    "mle_processed": [
      "self",
      "value"
    ],
    "samples_processed": [
      "self",
      "value"
    ],
    "mle": [
      "self",
      "value"
    ],
    "samples": [
      "self",
      "value"
    ],
    "measurements": [
      "self",
      "value"
    ],
    "max_probability": [
      "self",
      "value"
    ]
  },
  "_compute_fisher_information": [
    "result",
    "observed"
  ],
  "_fisher_confint": [
    "result",
    "alpha",
    "observed"
  ],
  "_likelihood_ratio_confint": [
    "result",
    "alpha"
  ],
  "EstimationProblem": {
    "__init__": [
      "self",
      "state_preparation",
      "objective_qubits",
      "grover_operator",
      "post_processing",
      "is_good_state"
    ],
    "state_preparation": [
      "self",
      "state_preparation"
    ],
    "objective_qubits": [
      "self",
      "objective_qubits"
    ],
    "post_processing": [
      "self",
      "post_processing"
    ],
    "has_good_state": [
      "self"
    ],
    "is_good_state": [
      "self",
      "is_good_state"
    ],
    "grover_operator": [
      "self",
      "grover_operator"
    ],
    "rescale": [
      "self",
      "scaling_factor"
    ]
  },
  "_rescale_amplitudes": [
    "circuit",
    "scaling_factor"
  ],
  "MINIMIZER": [],
  "MaximumLikelihoodAmplitudeEstimation": {
    "__init__": [
      "self",
      "evaluation_schedule",
      "minimizer",
      "sampler"
    ],
    "sampler": [
      "self",
      "sampler"
    ],
    "construct_circuits": [
      "self",
      "estimation_problem",
      "measurement"
    ],
    "compute_confidence_interval": [
      "result",
      "alpha",
      "kind",
      "apply_post_processing"
    ],
    "compute_mle": [
      "self",
      "circuit_results",
      "estimation_problem",
      "num_state_qubits",
      "return_counts"
    ],
    "estimate": [
      "self",
      "estimation_problem"
    ]
  },
  "MaximumLikelihoodAmplitudeEstimationResult": {
    "__init__": [
      "self"
    ],
    "theta": [
      "self",
      "value"
    ],
    "minimizer": [
      "self",
      "value"
    ],
    "good_counts": [
      "self",
      "counts"
    ],
    "evaluation_schedule": [
      "self",
      "evaluation_schedule"
    ],
    "fisher_information": [
      "self",
      "value"
    ]
  },
  "_safe_min": [
    "array",
    "default"
  ],
  "_safe_max": [
    "array",
    "default"
  ],
  "_get_counts": [
    "circuit_results",
    "estimation_problem"
  ],
  "bisect_max": [
    "f",
    "a",
    "b",
    "steps",
    "minwidth",
    "retval"
  ],
  "_circ_dist": [
    "x",
    "p"
  ],
  "_derivative_circ_dist": [
    "x",
    "p"
  ],
  "_amplitude_to_angle": [
    "a"
  ],
  "_derivative_amplitude_to_angle": [
    "a"
  ],
  "_alpha": [
    "x",
    "p"
  ],
  "_derivative_alpha": [
    "x",
    "p"
  ],
  "_beta": [
    "x",
    "p"
  ],
  "_derivative_beta": [
    "x",
    "p"
  ],
  "_pdf_a_single_angle": [
    "x",
    "p",
    "m",
    "pi_delta"
  ],
  "pdf_a": [
    "x",
    "p",
    "m"
  ],
  "derivative_log_pdf_a": [
    "x",
    "p",
    "m"
  ],
  "IterativeAmplitudeEstimation": {
    "__init__": [
      "self",
      "epsilon_target",
      "alpha",
      "confint_method",
      "min_ratio",
      "sampler"
    ],
    "sampler": [
      "self",
      "sampler"
    ],
    "epsilon_target": [
      "self",
      "epsilon"
    ],
    "_find_next_k": [
      "self",
      "k",
      "upper_half_circle",
      "theta_interval",
      "min_ratio"
    ],
    "construct_circuit": [
      "self",
      "estimation_problem",
      "k",
      "measurement"
    ],
    "_good_state_probability": [
      "self",
      "problem",
      "counts_dict"
    ],
    "estimate": [
      "self",
      "estimation_problem"
    ]
  },
  "IterativeAmplitudeEstimationResult": {
    "__init__": [
      "self"
    ],
    "alpha": [
      "self",
      "value"
    ],
    "epsilon_target": [
      "self",
      "value"
    ],
    "epsilon_estimated": [
      "self",
      "value"
    ],
    "epsilon_estimated_processed": [
      "self",
      "value"
    ],
    "estimate_intervals": [
      "self",
      "value"
    ],
    "theta_intervals": [
      "self",
      "value"
    ],
    "powers": [
      "self",
      "value"
    ],
    "ratios": [
      "self",
      "value"
    ],
    "confidence_interval_processed": [
      "self",
      "value"
    ]
  },
  "_chernoff_confint": [
    "value",
    "shots",
    "max_rounds",
    "alpha"
  ],
  "_clopper_pearson_confint": [
    "counts",
    "shots",
    "alpha"
  ],
  "AmplitudeEstimator": {
    "estimate": [
      "self",
      "estimation_problem"
    ]
  },
  "AmplitudeEstimatorResult": {
    "__init__": [
      "self"
    ],
    "circuit_results": [
      "self",
      "value"
    ],
    "shots": [
      "self",
      "value"
    ],
    "estimation": [
      "self",
      "value"
    ],
    "estimation_processed": [
      "self",
      "value"
    ],
    "num_oracle_queries": [
      "self",
      "value"
    ],
    "post_processing": [
      "self",
      "post_processing"
    ],
    "confidence_interval": [
      "self",
      "confidence_interval"
    ],
    "confidence_interval_processed": [
      "self",
      "confidence_interval"
    ]
  },
  "FasterAmplitudeEstimation": {
    "__init__": [
      "self",
      "delta",
      "maxiter",
      "rescale",
      "sampler"
    ],
    "sampler": [
      "self",
      "sampler"
    ],
    "_cos_estimate": [
      "self",
      "estimation_problem",
      "k",
      "shots"
    ],
    "_chernoff": [
      "self",
      "cos",
      "shots"
    ],
    "construct_circuit": [
      "self",
      "estimation_problem",
      "k",
      "measurement"
    ],
    "estimate": [
      "self",
      "estimation_problem"
    ]
  },
  "FasterAmplitudeEstimationResult": {
    "__init__": [
      "self"
    ],
    "success_probability": [
      "self",
      "probability"
    ],
    "num_steps": [
      "self",
      "num_steps"
    ],
    "num_first_state_steps": [
      "self",
      "num_steps"
    ],
    "theta_intervals": [
      "self",
      "value"
    ]
  },
  "VQE": {
    "__init__": [
      "self",
      "estimator",
      "ansatz",
      "optimizer"
    ],
    "initial_point": [
      "self",
      "value"
    ],
    "ansatz": [
      "self",
      "value"
    ],
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "_get_evaluate_energy": [
      "self",
      "ansatz",
      "operator"
    ],
    "_get_evaluate_gradient": [
      "self",
      "ansatz",
      "operator"
    ],
    "_check_operator_ansatz": [
      "self",
      "operator"
    ],
    "_build_vqe_result": [
      "self",
      "ansatz",
      "optimizer_result",
      "aux_operators_evaluated",
      "optimizer_time"
    ]
  },
  "VQEResult": {
    "__init__": [
      "self"
    ],
    "cost_function_evals": [
      "self",
      "value"
    ]
  },
  "MinimumEigensolver": {
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ],
    "supports_aux_operators": [
      "cls"
    ]
  },
  "MinimumEigensolverResult": {
    "__init__": [
      "self"
    ],
    "eigenvalue": [
      "self",
      "value"
    ],
    "aux_operators_evaluated": [
      "self",
      "value"
    ]
  },
  "SamplingMinimumEigensolver": {
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ],
    "supports_aux_operators": [
      "cls"
    ]
  },
  "SamplingMinimumEigensolverResult": {
    "__init__": [
      "self"
    ],
    "eigenvalue": [
      "self",
      "value"
    ],
    "eigenstate": [
      "self",
      "value"
    ],
    "aux_operators_evaluated": [
      "self",
      "value"
    ],
    "best_measurement": [
      "self",
      "value"
    ]
  },
  "QAOA": {
    "__init__": [
      "self",
      "sampler",
      "optimizer"
    ],
    "_check_operator_ansatz": [
      "self",
      "operator"
    ]
  },
  "_DiagonalEstimatorResult": {
    "__init__": [
      "self",
      "data",
      "metadata",
      "best_measurements"
    ]
  },
  "_DiagonalEstimator": {
    "__init__": [
      "self",
      "sampler",
      "aggregation",
      "callback"
    ],
    "run": [
      "self",
      "pubs"
    ],
    "_run": [
      "self",
      "pubs"
    ],
    "_run_pub": [
      "self",
      "pub"
    ]
  },
  "_get_cvar_aggregation": [
    "alpha"
  ],
  "_PARITY": [],
  "_evaluate_sparsepauli": [
    "state",
    "observable"
  ],
  "_check_observable_is_diagonal": [
    "observable"
  ],
  "SamplingVQE": {
    "__init__": [
      "self",
      "sampler",
      "ansatz",
      "optimizer"
    ],
    "initial_point": [
      "self",
      "value"
    ],
    "_check_operator_ansatz": [
      "self",
      "operator"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ],
    "_get_evaluate_energy": [
      "self",
      "operator",
      "ansatz",
      "return_best_measurement"
    ],
    "_build_sampling_vqe_result": [
      "self",
      "ansatz",
      "optimizer_result",
      "aux_operators_evaluated",
      "best_measurement",
      "final_state",
      "optimizer_time"
    ]
  },
  "SamplingVQEResult": {
    "__init__": [
      "self"
    ],
    "cost_function_evals": [
      "self",
      "value"
    ]
  },
  "_compare_measurements": [
    "candidate",
    "current_best"
  ],
  "NumPyMinimumEigensolver": {
    "__init__": [
      "self",
      "filter_criterion"
    ],
    "filter_criterion": [
      "self",
      "filter_criterion"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ]
  },
  "NumPyMinimumEigensolverResult": {
    "__init__": [
      "self"
    ],
    "eigenstate": [
      "self",
      "value"
    ]
  },
  "TerminationCriterion": {
    "CONVERGED": [],
    "CYCLICITY": [],
    "MAXIMUM": []
  },
  "AdaptVQE": {
    "__init__": [
      "self",
      "solver"
    ],
    "initial_point": [
      "self",
      "value"
    ],
    "supports_aux_operators": [
      "cls"
    ],
    "_compute_gradients": [
      "self",
      "theta",
      "operator"
    ],
    "_check_cyclicity": [
      "indices"
    ],
    "_build_ansatz": [
      "self"
    ],
    "compute_minimum_eigenvalue": [
      "self",
      "operator",
      "aux_operators"
    ]
  },
  "AdaptVQEResult": {
    "__init__": [
      "self"
    ],
    "num_iterations": [
      "self",
      "value"
    ],
    "final_max_gradient": [
      "self",
      "value"
    ],
    "termination_criterion": [
      "self",
      "value"
    ],
    "eigenvalue_history": [
      "self",
      "eigenvalue_history"
    ]
  }
}