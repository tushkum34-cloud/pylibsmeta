{
  "Aux": [],
  "Out": [],
  "SolverState": [],
  "SearchState": [],
  "DescentState": [],
  "HessianUpdateState": [],
  "Y": [],
  "AbstractIterativeSolver": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_zero": [
    "x"
  ],
  "_iterate": [
    "inputs"
  ],
  "iterative_solve": [
    "fn",
    "solver",
    "y0",
    "args",
    "options"
  ],
  "AbstractRootFinder": {},
  "_rewrite_fn": [
    "root",
    "_",
    "inputs"
  ],
  "_to_minimise_fn": [
    "root_fn",
    "norm",
    "y",
    "args"
  ],
  "_to_lstsq_fn": [
    "root_fn",
    "y",
    "args"
  ],
  "_ToRoot": {
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ],
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_MinimToRoot": {
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "_LstsqToRoot": {
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "root_find": [
    "fn",
    "solver",
    "y0",
    "args",
    "options"
  ],
  "AbstractLeastSquaresSolver": {},
  "_ToMinimiseFn": {
    "__call__": [
      "self",
      "y",
      "args"
    ]
  },
  "least_squares": [
    "fn",
    "solver",
    "y0",
    "args",
    "options"
  ],
  "AbstractAdjoint": {
    "apply": [
      "self",
      "primal_fn",
      "rewrite_fn",
      "inputs",
      "tags"
    ]
  },
  "RecursiveCheckpointAdjoint": {
    "apply": [
      "self",
      "primal_fn",
      "rewrite_fn",
      "inputs",
      "tags"
    ]
  },
  "ImplicitAdjoint": {
    "apply": [
      "self",
      "primal_fn",
      "rewrite_fn",
      "inputs",
      "tags"
    ]
  },
  "_is_global_function": [
    "x"
  ],
  "_Inputs": [],
  "_Root": [],
  "_Residual": [],
  "implicit_jvp": [
    "fn_primal",
    "fn_rewrite",
    "inputs",
    "tags",
    "linear_solver"
  ],
  "_implicit_impl": [
    "fn_primal",
    "fn_rewrite",
    "inputs",
    "tags",
    "linear_solver"
  ],
  "_assert_false": [
    "x"
  ],
  "_is_none": [
    "x"
  ],
  "_for_jac": [
    "root",
    "args"
  ],
  "_implicit_impl_jvp": [
    "primals",
    "tangents"
  ],
  "AbstractFixedPointSolver": {},
  "_ToRootFn": {
    "__call__": [
      "self",
      "y",
      "args"
    ]
  },
  "fixed_point": [
    "fn",
    "solver",
    "y0",
    "args",
    "options"
  ],
  "__version__": [],
  "FunctionInfo": {
    "as_min": [
      "self"
    ]
  },
  "Eval": {
    "as_min": [
      "self"
    ]
  },
  "EvalGrad": {
    "as_min": [
      "self"
    ],
    "compute_grad_dot": [
      "self",
      "y"
    ]
  },
  "EvalGradHessian": {
    "as_min": [
      "self"
    ],
    "compute_grad_dot": [
      "self",
      "y"
    ]
  },
  "EvalGradHessianInv": {
    "as_min": [
      "self"
    ],
    "compute_grad_dot": [
      "self",
      "y"
    ]
  },
  "Residual": {
    "as_min": [
      "self"
    ]
  },
  "ResidualJac": {
    "as_min": [
      "self"
    ],
    "compute_grad": [
      "self"
    ],
    "compute_grad_dot": [
      "self",
      "y"
    ]
  },
  "_FnInfo": [],
  "_FnEvalInfo": [],
  "AbstractDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "AbstractSearch": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "step": [
      "self",
      "first_step",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "state"
    ]
  },
  "RESULTS": {
    "successful": [],
    "nonlinear_max_steps_reached": [],
    "nonlinear_divergence": []
  },
  "Solution": {},
  "_wrap": [
    "fn"
  ],
  "default_floating_dtype": [],
  "max_norm": [],
  "rms_norm": [],
  "sum_squares": [],
  "tree_dot": [],
  "two_norm": [],
  "tree_full_like": [
    "struct",
    "fill_value",
    "allow_static"
  ],
  "tree_where": [
    "pred",
    "true",
    "false"
  ],
  "tree_dtype": [
    "tree"
  ],
  "tree_clip": [
    "tree",
    "lower",
    "upper"
  ],
  "tree_min": [
    "tree"
  ],
  "tree_max": [
    "tree"
  ],
  "feasible_step_length": [
    "current",
    "proposed_step",
    "lower_bound",
    "upper_bound"
  ],
  "resolve_rcond": [
    "rcond",
    "n",
    "m",
    "dtype"
  ],
  "NoneAux": {
    "__call__": [
      "self"
    ]
  },
  "OutAsArray": {
    "__call__": [
      "self"
    ]
  },
  "lin_to_grad": [
    "lin_fn",
    "y_eval",
    "autodiff_mode"
  ],
  "_asarray": [],
  "_asarray_jvp": [
    "dtype",
    "x",
    "tx"
  ],
  "asarray": [
    "x"
  ],
  "inexact_asarray": [
    "x"
  ],
  "_F": [],
  "cauchy_termination": [
    "rtol",
    "atol",
    "norm",
    "y",
    "y_diff",
    "f",
    "f_diff"
  ],
  "_JaxprEqual": {
    "__init__": [
      "self",
      "jaxpr"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "_wrap_jaxpr_leaf": [
    "leaf"
  ],
  "wrap_jaxpr": [
    "tree"
  ],
  "_unwrap_jaxpr_leaf": [
    "leaf"
  ],
  "unwrap_jaxpr": [
    "tree"
  ],
  "filter_cond": [
    "pred",
    "true_fun",
    "false_fun"
  ],
  "verbose_print": [],
  "AbstractMinimiser": {},
  "minimise": [
    "fn",
    "solver",
    "y0",
    "args",
    "options"
  ],
  "OptimizeResults": {},
  "minimize": [
    "fun",
    "x0",
    "args"
  ],
  "_FixedPointState": {},
  "FixedPointIteration": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_OptaxState": {},
  "OptaxMinimiser": {
    "__init__": [
      "self",
      "optim",
      "rtol",
      "atol",
      "norm",
      "verbose"
    ],
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_SteepestDescentState": {},
  "SteepestDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "_GradientDescentState": {},
  "AbstractGradientDescent": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "GradientDescent": {
    "__init__": [
      "self",
      "learning_rate",
      "rtol",
      "atol",
      "norm"
    ]
  },
  "_BisectionState": {},
  "_ExpansionCarry": {},
  "_interval_contains_root": [],
  "_expand_interval": [],
  "_expand_interval_repeatedly": [
    "lower",
    "upper"
  ],
  "Bisection": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_GoldenSearchState": {},
  "GoldenSearch": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_Hessian": [],
  "_identity_pytree": [
    "pytree"
  ],
  "_outer": [
    "tree1",
    "tree2"
  ],
  "_QuasiNewtonState": {},
  "AbstractQuasiNewton": {
    "init_hessian": [
      "self",
      "y",
      "f",
      "grad"
    ],
    "update_hessian": [
      "self",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "hessian_update_state"
    ],
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "AbstractBFGS": {
    "init_hessian": [
      "self",
      "y",
      "f",
      "grad"
    ],
    "update_hessian": [
      "self",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "hessian_update_state"
    ]
  },
  "BFGS": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "use_inverse",
      "verbose"
    ]
  },
  "AbstractDFP": {
    "init_hessian": [
      "self",
      "y",
      "f",
      "grad"
    ],
    "update_hessian": [
      "self",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "hessian_update_state"
    ]
  },
  "DFP": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "use_inverse",
      "verbose"
    ]
  },
  "polak_ribiere": [
    "grad_vector",
    "grad_prev",
    "y_diff_prev"
  ],
  "fletcher_reeves": [
    "grad",
    "grad_prev",
    "y_diff_prev"
  ],
  "hestenes_stiefel": [
    "grad",
    "grad_prev",
    "y_diff_prev"
  ],
  "dai_yuan": [
    "grad",
    "grad_prev",
    "y_diff_prev"
  ],
  "_NonlinearCGDescentState": {},
  "NonlinearCGDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "NonlinearCG": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "method",
      "search"
    ]
  },
  "_small": [
    "diffsize"
  ],
  "_diverged": [
    "rate"
  ],
  "_converged": [
    "factor",
    "tol"
  ],
  "_NewtonChordState": {},
  "_NoAux": {
    "__call__": [
      "self",
      "y",
      "args"
    ]
  },
  "_AbstractNewtonChord": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "Newton": {
    "_is_newton": []
  },
  "Chord": {
    "_is_newton": []
  },
  "_init_doc": [],
  "_NMStats": {},
  "_NelderMeadState": {},
  "_update_stats": [
    "stats",
    "reflect",
    "inner_contract",
    "outer_contract",
    "expand",
    "shrink"
  ],
  "NelderMead": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "_BacktrackingState": {},
  "BacktrackingArmijo": {
    "__post_init__": [
      "self"
    ],
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "step": [
      "self",
      "first_step",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "state"
    ]
  },
  "newton_step": [
    "f_info",
    "linear_solver"
  ],
  "_NewtonDescentState": {},
  "NewtonDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "_GaussNewtonState": {},
  "_make_f_info": [
    "fn",
    "y",
    "args",
    "tags",
    "jac"
  ],
  "AbstractGaussNewton": {
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "GaussNewton": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "linear_solver",
      "verbose"
    ]
  },
  "_Damped": {
    "__call__": [
      "self",
      "y"
    ]
  },
  "damped_newton_step": [
    "step_size",
    "f_info",
    "linear_solver"
  ],
  "_DampedNewtonDescentState": {},
  "DampedNewtonDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "_IndirectDampedNewtonDescentState": {},
  "IndirectDampedNewtonDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "LevenbergMarquardt": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "linear_solver",
      "verbose"
    ]
  },
  "IndirectLevenbergMarquardt": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "lambda_0",
      "linear_solver",
      "root_finder",
      "verbose"
    ]
  },
  "_DoglegDescentState": {},
  "DoglegDescent": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "query": [
      "self",
      "y",
      "f_info",
      "state"
    ],
    "step": [
      "self",
      "step_size",
      "state"
    ]
  },
  "Dogleg": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "linear_solver",
      "verbose"
    ]
  },
  "_TrustRegionState": {},
  "_AbstractTrustRegion": {
    "__post_init__": [
      "self"
    ],
    "predict_reduction": [
      "self",
      "y_diff",
      "f_info"
    ],
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "step": [
      "self",
      "first_step",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "state"
    ]
  },
  "ClassicalTrustRegion": {
    "predict_reduction": [
      "self",
      "y_diff",
      "f_info"
    ]
  },
  "LinearTrustRegion": {
    "predict_reduction": [
      "self",
      "y_diff",
      "f_info"
    ]
  },
  "_typed_asarray": [
    "x"
  ],
  "LearningRate": {
    "init": [
      "self",
      "y",
      "f_info_struct"
    ],
    "step": [
      "self",
      "first_step",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "state"
    ]
  },
  "_BestSoFarState": {},
  "_auxmented": [
    "fn",
    "y",
    "args"
  ],
  "_AbstractBestSoFarSolver": {
    "_to_loss": [
      "self",
      "y",
      "f"
    ],
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ],
    "init": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "f_struct",
      "aux_struct",
      "tags"
    ],
    "step": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "terminate": [
      "self",
      "fn",
      "y",
      "args",
      "options",
      "state",
      "tags"
    ],
    "postprocess": [
      "self",
      "fn",
      "y",
      "aux",
      "args",
      "options",
      "state",
      "tags",
      "result"
    ]
  },
  "BestSoFarMinimiser": {
    "__init__": [
      "self",
      "solver"
    ],
    "_to_loss": [
      "self",
      "y",
      "f"
    ],
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "BestSoFarLeastSquares": {
    "__init__": [
      "self",
      "solver"
    ],
    "_to_loss": [
      "self",
      "y",
      "f"
    ],
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "BestSoFarRootFinder": {
    "__init__": [
      "self",
      "solver"
    ],
    "_to_loss": [
      "self",
      "y",
      "f"
    ],
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "BestSoFarFixedPoint": {
    "__init__": [
      "self",
      "solver"
    ],
    "_to_loss": [
      "self",
      "y",
      "f"
    ],
    "rtol": [
      "self"
    ],
    "atol": [
      "self"
    ],
    "norm": [
      "self"
    ]
  },
  "_LBFGSInverseHessianUpdateState": {},
  "_LBFGSHessianUpdateState": {},
  "_LBFGSUpdateState": [],
  "v_tree_dot": [],
  "_lbfgs_inverse_hessian_operator_fn": [
    "grad",
    "state"
  ],
  "_lbfgs_hessian_operator_fn": [
    "proposed_step",
    "state"
  ],
  "_batched_tree_zeros_like": [
    "y",
    "batch_dimension"
  ],
  "AbstractLBFGS": {
    "init_hessian": [
      "self",
      "y",
      "f",
      "grad"
    ],
    "update_hessian": [
      "self",
      "y",
      "y_eval",
      "f_info",
      "f_eval_info",
      "hessian_update_state"
    ]
  },
  "LBFGS": {
    "__init__": [
      "self",
      "rtol",
      "atol",
      "norm",
      "use_inverse",
      "history_length",
      "verbose"
    ]
  }
}