{
  "T": [],
  "foo_async": [
    "x"
  ],
  "foo": [],
  "Bar": {
    "baz_async": [
      "self",
      "x"
    ],
    "baz": []
  },
  "b": [],
  "CompleteOnFlush": {
    "__init__": [
      "self"
    ],
    "flush": [
      "self"
    ]
  },
  "make_task": [
    "future"
  ],
  "TestReadySet": {
    "test_get_all_returns_all_ready_tasks": [
      "self"
    ],
    "test_task_added_at_most_once": [
      "self"
    ],
    "test_futures_flushed_if_no_task_ready": [
      "self"
    ],
    "test_futures_not_flushed_if_tasks_ready": [
      "self"
    ]
  },
  "Interrupt": {
    "__init__": [
      "self",
      "task",
      "error"
    ]
  },
  "TaskState": {
    "WAITING": [],
    "SUCCEEDED": [],
    "FAILED": []
  },
  "TaskStateError": {
    "__init__": [
      "self",
      "state",
      "expected_state"
    ]
  },
  "LOCALS_TASK_SCHEDULER": [],
  "Task": {
    "__init__": [
      "self",
      "awaitable",
      "scheduler",
      "main_task"
    ],
    "_check_state": [
      "self",
      "expected_state"
    ],
    "future": [
      "self"
    ],
    "result": [
      "self"
    ],
    "done": [
      "self"
    ],
    "add_ready_callback": [
      "self",
      "callback"
    ],
    "advance": [
      "self"
    ],
    "push_deadline": [
      "self",
      "deadline",
      "timeout_error"
    ],
    "pop_deadline": [
      "self"
    ],
    "deadline_entry": [
      "self"
    ],
    "interrupt": [
      "self",
      "task",
      "error"
    ],
    "close": [
      "self"
    ]
  },
  "current_task": [],
  "current_scheduler": [],
  "any_ready": [
    "tasks"
  ],
  "ReadySet": {
    "__init__": [
      "self"
    ],
    "register": [
      "self",
      "task"
    ],
    "_add": [
      "self",
      "task"
    ],
    "get_all": [
      "self",
      "timeout"
    ],
    "_pop_tasks": [
      "self"
    ],
    "interrupt": [
      "self"
    ]
  },
  "DeadlineEntry": {
    "_counter": [],
    "__init__": [
      "self",
      "task",
      "deadline",
      "timeout_error"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Scheduler": {
    "__init__": [
      "self"
    ],
    "spawn": [
      "self",
      "awaitable",
      "main_task"
    ],
    "time": [
      "self"
    ],
    "add_deadline": [
      "self",
      "entry"
    ],
    "get_next_deadline": [
      "self"
    ],
    "get_deadline_entries": [
      "self",
      "deadline"
    ],
    "tick": [
      "self"
    ],
    "_interrupt": [
      "self",
      "signum",
      "frame"
    ],
    "_in_task": [
      "self",
      "frame"
    ],
    "init_signals": [
      "self"
    ],
    "cleanup_signals": [
      "self"
    ]
  },
  "test_awaitable_future": [],
  "test_awaitable_future_propagates_cancellation": [],
  "test_awaitable_grpc_future": [],
  "U": [],
  "run": [
    "func"
  ],
  "sync": [
    "f"
  ],
  "awaitable": [
    "value"
  ],
  "_awaitable_value": [
    "value"
  ],
  "awaitable_func": [
    "function"
  ],
  "pmap_async": [
    "func",
    "iterable",
    "limit"
  ],
  "pmap": [],
  "pstarmap_async": [
    "func",
    "iterable",
    "limit"
  ],
  "pstarmap": [],
  "pmap_aiter": [
    "scope",
    "func",
    "iterable",
    "limit"
  ],
  "pstarmap_aiter": [
    "scope",
    "func",
    "iterable",
    "limit"
  ],
  "sleep": [
    "time"
  ],
  "deadline_scope": [
    "deadline"
  ],
  "timeout_scope": [
    "timeout"
  ],
  "new_scope": [],
  "Scope": {
    "__init__": [
      "self",
      "main_task",
      "scheduler",
      "tasks"
    ],
    "cancel": [
      "self"
    ],
    "spawn": [
      "self",
      "func"
    ],
    "_run": [
      "self",
      "func"
    ]
  },
  "Limiter": {
    "__init__": [
      "self",
      "capacity"
    ],
    "is_available": [
      "self"
    ],
    "__aenter__": [
      "self"
    ],
    "acquire": [
      "self"
    ],
    "__aexit__": [
      "self",
      "exc_type",
      "exc",
      "tb"
    ],
    "_release": [
      "self"
    ],
    "available": [
      "self"
    ],
    "throttle": [
      "self",
      "iterable"
    ],
    "capacity": [
      "self",
      "capacity"
    ]
  },
  "Slot": {
    "__init__": [
      "self",
      "release_func"
    ],
    "release": [
      "self"
    ]
  },
  "LimitedScope": {
    "scope": [
      "self"
    ],
    "limiter": [
      "self"
    ],
    "spawn": [
      "self",
      "func"
    ],
    "pmap_async": [
      "self",
      "func",
      "iterable"
    ],
    "pmap_aiter": [
      "self",
      "func",
      "iterable"
    ],
    "pstarmap_async": [
      "self",
      "func",
      "iterable"
    ],
    "pstarmap_aiter": [
      "self",
      "func",
      "iterable"
    ]
  },
  "AnyIterable": [],
  "aenumerate": [
    "iterable",
    "start"
  ],
  "aiter": [
    "iterable"
  ],
  "azip": [],
  "AsyncCollector": {
    "__init__": [
      "self"
    ],
    "add": [
      "self",
      "value"
    ],
    "done": [
      "self"
    ],
    "error": [
      "self",
      "error"
    ],
    "__aiter__": [
      "self"
    ],
    "__anext__": [
      "self"
    ]
  },
  "duet_sync_callback": [
    "ctx"
  ],
  "modify_callable": [
    "func_type",
    "ctx"
  ],
  "DuetPlugin": {
    "get_function_hook": [
      "self",
      "fullname"
    ]
  },
  "plugin": [
    "version"
  ],
  "FutureLike": {
    "result": [
      "self"
    ],
    "exception": [
      "self"
    ],
    "add_done_callback": [
      "self",
      "fn"
    ],
    "cancel": [
      "self"
    ],
    "cancelled": [
      "self"
    ]
  },
  "AwaitableFuture": {
    "isfuture": [
      "value"
    ],
    "wrap": [
      "future"
    ],
    "__await__": [
      "self"
    ],
    "try_set_result": [
      "self",
      "result"
    ],
    "try_set_exception": [
      "self",
      "exception"
    ]
  },
  "BufferedFuture": {
    "flush": [
      "self"
    ],
    "result": [
      "self",
      "timeout"
    ],
    "exception": [
      "self",
      "timeout"
    ]
  },
  "BufferGroup": {
    "__init__": [
      "self",
      "latch"
    ],
    "add": [
      "self",
      "future"
    ],
    "flush": [
      "self"
    ]
  },
  "FutureList": {
    "__init__": [
      "self",
      "futures"
    ],
    "_handle_result": [
      "self",
      "future",
      "index"
    ],
    "flush": [
      "self"
    ]
  },
  "completed_future": [
    "data"
  ],
  "failed_future": [
    "error"
  ],
  "__version__": [],
  "mul": [
    "a",
    "b"
  ],
  "add": [
    "a",
    "b"
  ],
  "Fail": {},
  "fail_after_await": [],
  "fail_before_await": [],
  "fail_funcs": [],
  "TestAwaitableFunc": {
    "test_wrap_async_func": [
      "self"
    ],
    "test_wrap_sync_func": [
      "self"
    ]
  },
  "TestRun": {
    "test_future": [
      "self"
    ],
    "test_function": [
      "self"
    ],
    "test_function_returning_none": [
      "self"
    ],
    "test_nested_functions": [
      "self"
    ],
    "test_nested_functions_returning_none": [
      "self"
    ],
    "test_failed_future": [
      "self"
    ],
    "test_failed_nested_generator": [
      "self"
    ],
    "test_failure_propagates": [
      "self",
      "fail_func"
    ]
  },
  "TestPmap": {
    "test_ordering": [
      "self"
    ],
    "test_failure": [
      "self",
      "limit"
    ]
  },
  "TestPstarmap": {
    "test_ordering": [
      "self"
    ]
  },
  "TestPmapAsync": {
    "test_ordering": [
      "self"
    ],
    "test_laziness": [
      "self"
    ]
  },
  "TestPstarmapAsync": {
    "test_ordering": [
      "self"
    ]
  },
  "TestLimiter": {
    "test_ordering": [
      "self"
    ],
    "test_resize_capacity": [
      "self"
    ],
    "test_cancel": [
      "self"
    ]
  },
  "test_sleep": [],
  "test_sleep_with_timeout": [],
  "test_repeated_sleep": [],
  "test_repeated_sleep_with_timeout": [],
  "TestScope": {
    "test_run_all": [
      "self"
    ],
    "test_failure_in_spawned_task": [
      "self",
      "fail_func"
    ],
    "test_sync_failure_in_main_task": [
      "self"
    ],
    "test_async_failure_in_main_task": [
      "self"
    ],
    "test_interrupt_not_included_in_stack_trace": [
      "self"
    ],
    "test_timeout": [
      "self"
    ],
    "test_deadline": [
      "self"
    ],
    "test_timeout_completes_within_timeout": [
      "self"
    ],
    "test_scope_timeout_cancels_all_subtasks": [
      "self"
    ],
    "test_cancel": [
      "self"
    ]
  },
  "test_multiple_calls_to_future_set_result": [],
  "TestSync": {
    "test_sync_on_overridden_method": [
      "self"
    ],
    "test_sync_on_abstract_method": [
      "self"
    ],
    "test_sync_on_classmethod": [
      "self"
    ]
  }
}