{
  "_T": [],
  "Notification": {
    "__init__": [
      "self"
    ],
    "accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "to_observable": [
      "self",
      "scheduler"
    ],
    "equals": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "OnNext": {
    "__init__": [
      "self",
      "value"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "OnError": {
    "__init__": [
      "self",
      "error"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "OnCompleted": {
    "__init__": [
      "self"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "from_notifier": [
    "handler"
  ],
  "_A": [],
  "_B": [],
  "_C": [],
  "_D": [],
  "_E": [],
  "_F": [],
  "_G": [],
  "_H": [],
  "_J": [],
  "compose": [],
  "pipe": [
    "__value"
  ],
  "__all__": [],
  "_T1": [],
  "_T2": [],
  "_TKey": [],
  "_TState": [],
  "amb": [],
  "case": [
    "mapper",
    "sources",
    "default_source"
  ],
  "catch": [],
  "catch_with_iterable": [
    "sources"
  ],
  "create": [
    "subscribe"
  ],
  "combine_latest": [],
  "concat": [],
  "concat_with_iterable": [
    "sources"
  ],
  "defer": [
    "factory"
  ],
  "empty": [
    "scheduler"
  ],
  "for_in": [
    "values",
    "mapper"
  ],
  "fork_join": [],
  "from_callable": [
    "supplier",
    "scheduler"
  ],
  "from_callback": [
    "func",
    "mapper"
  ],
  "from_future": [
    "future"
  ],
  "from_iterable": [
    "iterable",
    "scheduler"
  ],
  "from_": [],
  "from_list": [],
  "from_marbles": [
    "string",
    "timespan",
    "scheduler",
    "lookup",
    "error"
  ],
  "cold": [],
  "generate_with_relative_time": [
    "initial_state",
    "condition",
    "iterate",
    "time_mapper"
  ],
  "generate": [
    "initial_state",
    "condition",
    "iterate"
  ],
  "hot": [
    "string",
    "timespan",
    "duetime",
    "scheduler",
    "lookup",
    "error"
  ],
  "if_then": [
    "condition",
    "then_source",
    "else_source"
  ],
  "interval": [
    "period",
    "scheduler"
  ],
  "merge": [],
  "never": [],
  "of": [],
  "on_error_resume_next": [],
  "range": [
    "start",
    "stop",
    "step",
    "scheduler"
  ],
  "return_value": [
    "value",
    "scheduler"
  ],
  "just": [],
  "repeat_value": [
    "value",
    "repeat_count"
  ],
  "start": [
    "func",
    "scheduler"
  ],
  "start_async": [
    "function_async"
  ],
  "throw": [
    "exception",
    "scheduler"
  ],
  "timer": [
    "duetime",
    "period",
    "scheduler"
  ],
  "to_async": [
    "func",
    "scheduler"
  ],
  "using": [
    "resource_factory",
    "observable_factory"
  ],
  "with_latest_from": [],
  "zip": [],
  "Action": [],
  "Mapper": [],
  "MapperIndexed": [],
  "Predicate": [],
  "PredicateIndexed": [],
  "Comparer": [],
  "SubComparer": [],
  "Accumulator": [],
  "Startable": [],
  "StartableTarget": [],
  "StartableFactory": [],
  "scheduler": [],
  "run": [
    "source"
  ],
  "__version__": [],
  "MockObserver": {
    "__init__": [
      "self",
      "scheduler"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ]
  },
  "TestScheduler": {
    "__test__": [],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "start": [
      "self",
      "create",
      "created",
      "subscribed",
      "disposed"
    ],
    "create_hot_observable": [
      "self"
    ],
    "create_cold_observable": [
      "self"
    ],
    "create_observer": [
      "self"
    ]
  },
  "is_prime": [
    "i"
  ],
  "OnNextPredicate": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "OnErrorPredicate": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "ReactiveTest": {
    "created": [],
    "subscribed": [],
    "disposed": [],
    "on_next": [
      "ticks",
      "value"
    ],
    "on_error": [
      "ticks",
      "error"
    ],
    "on_completed": [
      "ticks"
    ],
    "subscribe": [
      "start",
      "end"
    ]
  },
  "Subscription": {
    "__init__": [
      "self",
      "start",
      "end"
    ],
    "equals": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "new_thread_scheduler": [],
  "MarblesContext": {},
  "marbles_testing": [
    "timespan"
  ],
  "messages_to_records": [
    "messages"
  ],
  "MockDisposable": {
    "__init__": [
      "self",
      "scheduler"
    ],
    "dispose": [
      "self"
    ]
  },
  "Recorded": {
    "__init__": [
      "self",
      "time",
      "value"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "equals": [],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ColdObservable": {
    "__init__": [
      "self",
      "scheduler",
      "messages"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "HotObservable": {
    "__init__": [
      "self",
      "scheduler",
      "messages"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "AbsoluteTime": [],
  "RelativeTime": [],
  "AbsoluteOrRelativeTime": [],
  "ScheduledAction": [],
  "SchedulerBase": {
    "__slots__": [],
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "to_seconds": [
      "cls",
      "value"
    ],
    "to_datetime": [
      "cls",
      "value"
    ],
    "to_timedelta": [
      "cls",
      "value"
    ]
  },
  "SubjectBase": {
    "__slots__": [],
    "subscribe": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ]
  },
  "DisposableBase": {
    "__slots__": [],
    "dispose": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exctype",
      "excinst",
      "exctb"
    ]
  },
  "ScheduledPeriodicAction": [],
  "ScheduledSingleOrPeriodicAction": [],
  "PeriodicSchedulerBase": {
    "__slots__": [],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "_T_in": [],
  "ObserverBase": {
    "__slots__": [],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ]
  },
  "_T_out": [],
  "ObservableBase": {
    "__slots__": [],
    "subscribe": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ]
  },
  "StartableBase": {
    "__slots__": [],
    "start": [
      "self"
    ]
  },
  "_P": [],
  "add_ref": [
    "xs",
    "r"
  ],
  "infinite": [],
  "alias": [
    "name",
    "doc",
    "fun"
  ],
  "NotSet": {
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "noop": [],
  "identity": [
    "x"
  ],
  "default_now": [],
  "default_comparer": [
    "x",
    "y"
  ],
  "default_sub_comparer": [
    "x",
    "y"
  ],
  "default_key_serializer": [
    "x"
  ],
  "default_error": [
    "err"
  ],
  "default_thread_factory": [
    "target"
  ],
  "synchronized": [
    "lock"
  ],
  "SequenceContainsNoElementsError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "ArgumentOutOfRangeException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "DisposedException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "ReEntracyException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "CompletedException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "WouldBlockException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "DELTA_ZERO": [],
  "UTC_ZERO": [],
  "PriorityQueue": {
    "MIN_COUNT": [],
    "__init__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "peek": [
      "self"
    ],
    "dequeue": [
      "self"
    ],
    "enqueue": [
      "self",
      "item"
    ],
    "remove": [
      "self",
      "item"
    ],
    "clear": [
      "self"
    ]
  },
  "on_error_resume_next_": [
    "second"
  ],
  "skip_last_": [
    "count"
  ],
  "_TValue": [],
  "pluck_": [
    "key"
  ],
  "pluck_attr_": [
    "prop"
  ],
  "concat_": [],
  "last_": [
    "predicate"
  ],
  "partition_": [
    "predicate"
  ],
  "partition_indexed_": [
    "predicate_indexed"
  ],
  "skip_while_": [
    "predicate"
  ],
  "skip_while_indexed_": [
    "predicate"
  ],
  "AverageValue": {},
  "average_": [
    "key_mapper"
  ],
  "buffer_": [
    "boundaries"
  ],
  "buffer_when_": [
    "closing_mapper"
  ],
  "buffer_toggle_": [
    "openings",
    "closing_mapper"
  ],
  "buffer_with_count_": [
    "count",
    "skip"
  ],
  "take_": [
    "count"
  ],
  "skip_with_time_": [
    "duration",
    "scheduler"
  ],
  "buffer_with_time_or_count_": [
    "timespan",
    "count",
    "scheduler"
  ],
  "take_while_": [
    "predicate",
    "inclusive"
  ],
  "take_while_indexed_": [
    "predicate",
    "inclusive"
  ],
  "take_last_buffer_": [
    "count"
  ],
  "do_action_": [
    "on_next",
    "on_error",
    "on_completed"
  ],
  "do_": [
    "observer"
  ],
  "do_after_next": [
    "source",
    "after_next"
  ],
  "do_on_subscribe": [
    "source",
    "on_subscribe"
  ],
  "do_on_dispose": [
    "source",
    "on_dispose"
  ],
  "do_on_terminate": [
    "source",
    "on_terminate"
  ],
  "do_after_terminate": [
    "source",
    "after_terminate"
  ],
  "do_finally": [
    "finally_action"
  ],
  "subscribe_on_": [
    "scheduler"
  ],
  "first_or_default_async_": [
    "has_default",
    "default_value"
  ],
  "first_or_default_": [
    "predicate",
    "default_value"
  ],
  "array_index_of_comparer": [
    "array",
    "item",
    "comparer"
  ],
  "HashSet": {
    "__init__": [
      "self",
      "comparer"
    ],
    "push": [
      "self",
      "value"
    ]
  },
  "distinct_": [
    "key_mapper",
    "comparer"
  ],
  "filter_": [
    "predicate"
  ],
  "filter_indexed_": [
    "predicate_indexed"
  ],
  "materialize": [],
  "log": [],
  "window_toggle_": [
    "openings",
    "closing_mapper"
  ],
  "window_": [
    "boundaries"
  ],
  "window_when_": [
    "closing_mapper"
  ],
  "ignore_elements_": [],
  "find_value_": [
    "predicate",
    "yield_index"
  ],
  "pairwise_": [],
  "skip_until_": [
    "other"
  ],
  "contains_": [
    "value",
    "comparer"
  ],
  "with_latest_from_": [],
  "slice_": [
    "start",
    "stop",
    "step"
  ],
  "max_by_": [
    "key_mapper",
    "comparer"
  ],
  "TimeInterval": {},
  "time_interval_": [
    "scheduler"
  ],
  "_TSource": [],
  "_TResult": [],
  "replay_": [
    "mapper",
    "buffer_size",
    "window",
    "scheduler"
  ],
  "do_while_": [
    "condition"
  ],
  "skip_last_with_time_": [
    "duration",
    "scheduler"
  ],
  "join_": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "scan_": [
    "accumulator",
    "seed"
  ],
  "timeout_": [
    "duetime",
    "other",
    "scheduler"
  ],
  "repeat_": [
    "repeat_count"
  ],
  "__all": [],
  "multicast_": [
    "subject"
  ],
  "window_with_time_": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "Timestamp": {},
  "timestamp_": [
    "scheduler"
  ],
  "as_observable_": [],
  "to_dict_": [
    "key_mapper",
    "element_mapper"
  ],
  "delay_subscription_": [
    "duetime",
    "scheduler"
  ],
  "_TRight": [],
  "_TLeft": [],
  "all": [
    "predicate"
  ],
  "as_observable": [],
  "average": [
    "key_mapper"
  ],
  "buffer": [
    "boundaries"
  ],
  "buffer_when": [
    "closing_mapper"
  ],
  "buffer_toggle": [
    "openings",
    "closing_mapper"
  ],
  "buffer_with_count": [
    "count",
    "skip"
  ],
  "buffer_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "buffer_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "concat_map": [
    "project"
  ],
  "contains": [
    "value",
    "comparer"
  ],
  "count": [
    "predicate"
  ],
  "debounce": [
    "duetime",
    "scheduler"
  ],
  "throttle_with_timeout": [],
  "default_if_empty": [
    "default_value"
  ],
  "delay_subscription": [
    "duetime",
    "scheduler"
  ],
  "delay_with_mapper": [
    "subscription_delay",
    "delay_duration_mapper"
  ],
  "dematerialize": [],
  "delay": [
    "duetime",
    "scheduler"
  ],
  "distinct": [
    "key_mapper",
    "comparer"
  ],
  "distinct_until_changed": [
    "key_mapper",
    "comparer"
  ],
  "do": [
    "observer"
  ],
  "do_action": [
    "on_next",
    "on_error",
    "on_completed"
  ],
  "do_while": [
    "condition"
  ],
  "element_at": [
    "index"
  ],
  "element_at_or_default": [
    "index",
    "default_value"
  ],
  "exclusive": [],
  "expand": [
    "mapper"
  ],
  "filter": [
    "predicate"
  ],
  "filter_indexed": [
    "predicate_indexed"
  ],
  "finally_action": [
    "action"
  ],
  "find": [
    "predicate"
  ],
  "find_index": [
    "predicate"
  ],
  "first": [
    "predicate"
  ],
  "first_or_default": [
    "predicate",
    "default_value"
  ],
  "flat_map": [
    "mapper"
  ],
  "flat_map_indexed": [
    "mapper_indexed"
  ],
  "flat_map_latest": [
    "mapper"
  ],
  "group_by": [
    "key_mapper",
    "element_mapper",
    "subject_mapper"
  ],
  "group_by_until": [
    "key_mapper",
    "element_mapper",
    "duration_mapper",
    "subject_mapper"
  ],
  "group_join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "ignore_elements": [],
  "is_empty": [],
  "join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "last": [
    "predicate"
  ],
  "last_or_default": [
    "default_value",
    "predicate"
  ],
  "map": [
    "mapper"
  ],
  "map_indexed": [
    "mapper_indexed"
  ],
  "max": [
    "comparer"
  ],
  "max_by": [
    "key_mapper",
    "comparer"
  ],
  "merge_all": [],
  "min": [
    "comparer"
  ],
  "min_by": [
    "key_mapper",
    "comparer"
  ],
  "multicast": [
    "subject"
  ],
  "observe_on": [
    "scheduler"
  ],
  "pairwise": [],
  "partition": [
    "predicate"
  ],
  "partition_indexed": [
    "predicate_indexed"
  ],
  "pluck": [
    "key"
  ],
  "pluck_attr": [
    "prop"
  ],
  "publish": [
    "mapper"
  ],
  "publish_value": [
    "initial_value",
    "mapper"
  ],
  "reduce": [
    "accumulator",
    "seed"
  ],
  "ref_count": [],
  "repeat": [
    "repeat_count"
  ],
  "replay": [
    "buffer_size",
    "window"
  ],
  "retry": [
    "retry_count"
  ],
  "sample": [
    "sampler",
    "scheduler"
  ],
  "scan": [
    "accumulator",
    "seed"
  ],
  "sequence_equal": [
    "second",
    "comparer"
  ],
  "share": [],
  "single": [
    "predicate"
  ],
  "single_or_default": [
    "predicate",
    "default_value"
  ],
  "single_or_default_async": [
    "has_default",
    "default_value"
  ],
  "skip": [
    "count"
  ],
  "skip_last": [
    "count"
  ],
  "skip_last_with_time": [
    "duration",
    "scheduler"
  ],
  "skip_until": [
    "other"
  ],
  "skip_until_with_time": [
    "start_time",
    "scheduler"
  ],
  "skip_while": [
    "predicate"
  ],
  "skip_while_indexed": [
    "predicate"
  ],
  "skip_with_time": [
    "duration",
    "scheduler"
  ],
  "slice": [
    "start",
    "stop",
    "step"
  ],
  "some": [
    "predicate"
  ],
  "starmap": [
    "mapper"
  ],
  "starmap_indexed": [
    "mapper"
  ],
  "start_with": [],
  "subscribe_on": [
    "scheduler"
  ],
  "sum": [
    "key_mapper"
  ],
  "switch_latest": [],
  "switch_map": [
    "project"
  ],
  "switch_map_indexed": [
    "project"
  ],
  "take": [
    "count"
  ],
  "take_last": [
    "count"
  ],
  "take_last_buffer": [
    "count"
  ],
  "take_last_with_time": [
    "duration",
    "scheduler"
  ],
  "take_until": [
    "other"
  ],
  "take_until_with_time": [
    "end_time",
    "scheduler"
  ],
  "take_while": [
    "predicate",
    "inclusive"
  ],
  "take_while_indexed": [
    "predicate",
    "inclusive"
  ],
  "take_with_time": [
    "duration",
    "scheduler"
  ],
  "throttle_first": [
    "window_duration",
    "scheduler"
  ],
  "throttle_with_mapper": [
    "throttle_duration_mapper"
  ],
  "timestamp": [
    "scheduler"
  ],
  "timeout": [
    "duetime",
    "other",
    "scheduler"
  ],
  "timeout_with_mapper": [
    "first_timeout",
    "timeout_duration_mapper",
    "other"
  ],
  "time_interval": [
    "scheduler"
  ],
  "to_dict": [
    "key_mapper",
    "element_mapper"
  ],
  "to_future": [
    "future_ctor"
  ],
  "to_iterable": [],
  "to_list": [],
  "to_marbles": [
    "timespan",
    "scheduler"
  ],
  "to_set": [],
  "while_do": [
    "condition"
  ],
  "window": [
    "boundaries"
  ],
  "window_when": [
    "closing_mapper"
  ],
  "window_toggle": [
    "openings",
    "closing_mapper"
  ],
  "window_with_count": [
    "count",
    "skip"
  ],
  "window_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "window_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "zip_with_iterable": [
    "second"
  ],
  "zip_with_list": [],
  "default_if_empty_": [
    "default_value"
  ],
  "reduce_": [
    "accumulator",
    "seed"
  ],
  "exclusive_": [],
  "combine_latest_": [],
  "fork_join_": [],
  "take_until_with_time_": [
    "end_time",
    "scheduler"
  ],
  "map_": [
    "mapper"
  ],
  "map_indexed_": [
    "mapper_indexed"
  ],
  "first_": [
    "predicate"
  ],
  "_TOther": [],
  "zip_": [],
  "zip_with_iterable_": [
    "seq"
  ],
  "is_empty_": [],
  "first_only": [
    "x"
  ],
  "min_": [
    "comparer"
  ],
  "to_future_": [
    "future_ctor",
    "scheduler"
  ],
  "debounce_": [
    "duetime",
    "scheduler"
  ],
  "throttle_with_mapper_": [
    "throttle_duration_mapper"
  ],
  "amb_": [
    "right_source"
  ],
  "all_": [
    "predicate"
  ],
  "single_": [
    "predicate"
  ],
  "take_last_": [
    "count"
  ],
  "start_with_": [],
  "observe_on_": [
    "scheduler"
  ],
  "publish_value_": [
    "initial_value",
    "mapper"
  ],
  "group_by_until_": [
    "key_mapper",
    "element_mapper",
    "duration_mapper",
    "subject_mapper"
  ],
  "take_with_time_": [
    "duration",
    "scheduler"
  ],
  "observable_delay_timespan": [
    "source",
    "duetime",
    "scheduler"
  ],
  "delay_": [
    "duetime",
    "scheduler"
  ],
  "stringify": [
    "value"
  ],
  "skip_": [
    "count"
  ],
  "last_or_default_async": [
    "source",
    "has_default",
    "default_value"
  ],
  "single_or_default_async_": [
    "has_default",
    "default_value"
  ],
  "single_or_default_": [
    "predicate",
    "default_value"
  ],
  "element_at_or_default_": [
    "index",
    "has_default",
    "default_value"
  ],
  "take_until_": [
    "other"
  ],
  "finally_action_": [
    "action"
  ],
  "catch_handler": [
    "source",
    "handler"
  ],
  "catch_": [
    "handler"
  ],
  "sequence_equal_": [
    "second",
    "comparer"
  ],
  "group_by_": [
    "key_mapper",
    "element_mapper",
    "subject_mapper"
  ],
  "dematerialize_": [],
  "to_iterable_": [],
  "merge_": [],
  "merge_all_": [],
  "delay_with_mapper_": [
    "subscription_delay",
    "delay_duration_mapper"
  ],
  "publish_": [
    "mapper"
  ],
  "share_": [],
  "count_": [
    "predicate"
  ],
  "timeout_with_mapper_": [
    "first_timeout",
    "timeout_duration_mapper",
    "other"
  ],
  "window_with_time_or_count_": [
    "timespan",
    "count",
    "scheduler"
  ],
  "sample_observable": [
    "source",
    "sampler"
  ],
  "sample_": [
    "sampler",
    "scheduler"
  ],
  "max_": [
    "comparer"
  ],
  "group_join_": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "retry_": [
    "retry_count"
  ],
  "extrema_by": [
    "source",
    "key_mapper",
    "comparer"
  ],
  "min_by_": [
    "key_mapper",
    "comparer"
  ],
  "skip_until_with_time_": [
    "start_time",
    "scheduler"
  ],
  "buffer_with_time_": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "sum_": [
    "key_mapper"
  ],
  "to_set_": [],
  "switch_latest_": [],
  "throttle_first_": [
    "window_duration",
    "scheduler"
  ],
  "while_do_": [
    "condition"
  ],
  "_flat_map_internal": [
    "source",
    "mapper",
    "mapper_indexed"
  ],
  "flat_map_": [
    "mapper"
  ],
  "flat_map_indexed_": [
    "mapper_indexed"
  ],
  "flat_map_latest_": [
    "mapper"
  ],
  "window_with_count_": [
    "count",
    "skip"
  ],
  "expand_": [
    "mapper"
  ],
  "some_": [
    "predicate"
  ],
  "distinct_until_changed_": [
    "key_mapper",
    "comparer"
  ],
  "take_last_with_time_": [
    "duration",
    "scheduler"
  ],
  "ref_count_": [],
  "AsyncSubject": {
    "__init__": [
      "self"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "Subject": {
    "__init__": [
      "self"
    ],
    "check_disposed": [
      "self"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "InnerSubscription": {
    "__init__": [
      "self",
      "subject",
      "observer"
    ],
    "dispose": [
      "self"
    ]
  },
  "BehaviorSubject": {
    "__init__": [
      "self",
      "value"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "dispose": [
      "self"
    ]
  },
  "RemovableDisposable": {
    "__init__": [
      "self",
      "subject",
      "observer"
    ],
    "dispose": [
      "self"
    ]
  },
  "QueueItem": {},
  "ReplaySubject": {
    "__init__": [
      "self",
      "buffer_size",
      "window",
      "scheduler"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_trim": [
      "self",
      "now"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "AutoDetachObserver": {
    "__init__": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "subscription": [],
    "dispose": [
      "self"
    ],
    "fail": [
      "self",
      "exn"
    ]
  },
  "ScheduledObserver": {
    "__init__": [
      "self",
      "scheduler",
      "observer"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ],
    "ensure_active": [
      "self"
    ],
    "run": [
      "self",
      "scheduler",
      "state"
    ],
    "dispose": [
      "self"
    ]
  },
  "Observer": {
    "__init__": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ],
    "fail": [
      "self",
      "exn"
    ],
    "throw": [
      "self",
      "error"
    ],
    "to_notifier": [
      "self"
    ],
    "as_observer": [
      "self"
    ]
  },
  "ObserveOnObserver": {
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ]
  },
  "MultipleAssignmentDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "BooleanDisposable": {
    "__init__": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "CompositeDisposable": {
    "__init__": [
      "self"
    ],
    "add": [
      "self",
      "item"
    ],
    "remove": [
      "self",
      "item"
    ],
    "dispose": [
      "self"
    ],
    "clear": [
      "self"
    ],
    "contains": [
      "self",
      "item"
    ],
    "to_list": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "length": [
      "self"
    ]
  },
  "RefCountDisposable": {
    "__init__": [
      "self",
      "disposable"
    ],
    "dispose": [
      "self"
    ],
    "release": [
      "self"
    ],
    "disposable": [
      "self"
    ]
  },
  "SingleAssignmentDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "Disposable": {
    "__init__": [
      "self",
      "action"
    ],
    "dispose": [
      "self"
    ]
  },
  "ScheduledDisposable": {
    "__init__": [
      "self",
      "scheduler",
      "disposable"
    ],
    "is_disposed": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "SerialDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "generate_": [
    "initial_state",
    "condition",
    "iterate"
  ],
  "repeat_value_": [
    "value",
    "repeat_count"
  ],
  "start_": [
    "func",
    "scheduler"
  ],
  "concat_with_iterable_": [
    "sources"
  ],
  "ConnectableObservable": {
    "__init__": [
      "self",
      "source",
      "subject"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "connect": [
      "self",
      "scheduler"
    ],
    "auto_connect": [
      "self",
      "subscriber_count"
    ]
  },
  "catch_with_iterable_": [
    "sources"
  ],
  "return_value_": [
    "value",
    "scheduler"
  ],
  "from_callable_": [
    "supplier",
    "scheduler"
  ],
  "from_iterable_": [
    "iterable",
    "scheduler"
  ],
  "throw_": [
    "exception",
    "scheduler"
  ],
  "using_": [
    "resource_factory",
    "observable_factory"
  ],
  "pattern_group": [],
  "pattern_ticks": [],
  "pattern_comma_error": [],
  "pattern_element": [],
  "pattern": [],
  "tokens": [],
  "parse": [
    "string",
    "timespan",
    "time_shift",
    "lookup",
    "error",
    "raise_stopped"
  ],
  "start_async_": [
    "function_async"
  ],
  "interval_": [
    "period",
    "scheduler"
  ],
  "defer_": [
    "factory"
  ],
  "GroupedObservable": {
    "__init__": [
      "self",
      "key",
      "underlying_observable",
      "merged_disposable"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "empty_": [
    "scheduler"
  ],
  "generate_with_relative_time_": [
    "initial_state",
    "condition",
    "iterate",
    "time_mapper"
  ],
  "never_": [],
  "to_async_": [
    "func",
    "scheduler"
  ],
  "observable_timer_date": [
    "duetime",
    "scheduler"
  ],
  "observable_timer_duetime_and_period": [
    "duetime",
    "period",
    "scheduler"
  ],
  "observable_timer_timespan": [
    "duetime",
    "scheduler"
  ],
  "observable_timer_timespan_and_period": [
    "duetime",
    "period",
    "scheduler"
  ],
  "timer_": [
    "duetime",
    "period",
    "scheduler"
  ],
  "if_then_": [
    "condition",
    "then_source",
    "else_source"
  ],
  "Observable": {
    "__init__": [
      "self",
      "subscribe"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "subscribe": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "pipe": [
      "self"
    ],
    "run": [
      "self"
    ],
    "__await__": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__iadd__": [
      "self",
      "other"
    ],
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "range_": [
    "start",
    "stop",
    "step",
    "scheduler"
  ],
  "from_future_": [
    "future"
  ],
  "_Key": [],
  "case_": [
    "mapper",
    "sources",
    "default_source"
  ],
  "from_callback_": [
    "func",
    "mapper"
  ],
  "TimeoutScheduler": {
    "_lock": [],
    "singleton": [
      "cls"
    ],
    "__new__": [
      "cls"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "NewThreadScheduler": {
    "__init__": [
      "self",
      "thread_factory"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "MAX_SPINNING": [],
  "VirtualTimeScheduler": {
    "__init__": [
      "self",
      "initial_clock"
    ],
    "_get_clock": [
      "self"
    ],
    "clock": [],
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "start": [
      "self"
    ],
    "stop": [
      "self"
    ],
    "advance_to": [
      "self",
      "time"
    ],
    "advance_by": [
      "self",
      "time"
    ],
    "sleep": [
      "self",
      "time"
    ],
    "add": [
      "cls",
      "absolute",
      "relative"
    ]
  },
  "Scheduler": {
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "invoke_action": [
      "self",
      "action",
      "state"
    ],
    "to_seconds": [
      "cls",
      "value"
    ],
    "to_datetime": [
      "cls",
      "value"
    ],
    "to_timedelta": [
      "cls",
      "value"
    ]
  },
  "TrampolineScheduler": {
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_required": [
      "self"
    ],
    "ensure_trampoline": [
      "self",
      "action"
    ]
  },
  "ScheduledItem": {
    "__init__": [
      "self",
      "scheduler",
      "state",
      "action",
      "duetime"
    ],
    "invoke": [
      "self"
    ],
    "cancel": [
      "self"
    ],
    "is_cancelled": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "ImmediateScheduler": {
    "_lock": [],
    "singleton": [
      "cls"
    ],
    "__new__": [
      "cls"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "HistoricalScheduler": {
    "__init__": [
      "self",
      "initial_clock"
    ]
  },
  "PeriodicScheduler": {
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "ThreadPoolScheduler": {
    "__init__": [
      "self",
      "max_workers"
    ]
  },
  "EventLoopScheduler": {
    "__init__": [
      "self",
      "thread_factory",
      "exit_if_empty"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ],
    "_has_thread": [
      "self"
    ],
    "_ensure_thread": [
      "self"
    ],
    "run": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "CatchScheduler": {
    "__init__": [
      "self",
      "scheduler",
      "handler"
    ],
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ],
    "_clone": [
      "self",
      "scheduler"
    ],
    "_wrap": [
      "self",
      "action"
    ],
    "_get_recursive_wrapper": [
      "self",
      "scheduler"
    ]
  },
  "Trampoline": {
    "__init__": [
      "self"
    ],
    "idle": [
      "self"
    ],
    "run": [
      "self",
      "item"
    ],
    "_run": [
      "self"
    ]
  },
  "CurrentThreadScheduler": {
    "singleton": [
      "cls"
    ],
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ]
  },
  "_Local": {
    "__init__": [
      "self"
    ]
  },
  "CurrentThreadSchedulerSingleton": {
    "_local": [],
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ]
  },
  "QtScheduler": {
    "__init__": [
      "self",
      "qtcore"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "TkinterScheduler": {
    "__init__": [
      "self",
      "root"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "WxScheduler": {
    "__init__": [
      "self",
      "wx"
    ],
    "cancel_all": [
      "self"
    ],
    "_wxtimer_schedule": [
      "self",
      "time",
      "action",
      "state",
      "periodic"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "GtkScheduler": {
    "__init__": [
      "self",
      "glib"
    ],
    "_gtk_schedule": [
      "self",
      "time",
      "action",
      "state",
      "periodic"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "PyGameScheduler": {
    "__init__": [
      "self",
      "pygame"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "run": [
      "self"
    ]
  },
  "GEventScheduler": {
    "__init__": [
      "self",
      "gevent"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "EventletScheduler": {
    "__init__": [
      "self",
      "eventlet"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "AsyncIOScheduler": {
    "__init__": [
      "self",
      "loop"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "AsyncIOThreadSafeScheduler": {
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "_on_self_loop_or_not_running": [
      "self"
    ]
  },
  "IOLoopScheduler": {
    "__init__": [
      "self",
      "loop"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "TwistedScheduler": {
    "__init__": [
      "self",
      "reactor"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  }
}