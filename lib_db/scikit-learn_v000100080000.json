{
  "KernelRidge": {
    "__init__": [
      "self",
      "alpha"
    ],
    "_get_kernel": [
      "self",
      "X",
      "Y"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "NUMPY_MIN_VERSION": [],
  "SCIPY_MIN_VERSION": [],
  "JOBLIB_MIN_VERSION": [],
  "THREADPOOLCTL_MIN_VERSION": [],
  "PYTEST_MIN_VERSION": [],
  "CYTHON_MIN_VERSION": [],
  "dependent_packages": [],
  "CalibratedClassifierCV": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_get_estimator": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_fit_classifier_calibrator_pair": [
    "estimator",
    "X",
    "y",
    "train",
    "test",
    "method",
    "classes",
    "xp",
    "sample_weight",
    "fit_params"
  ],
  "_fit_calibrator": [
    "clf",
    "predictions",
    "y",
    "classes",
    "method",
    "xp",
    "sample_weight"
  ],
  "_CalibratedClassifier": {
    "__init__": [
      "self",
      "estimator",
      "calibrators"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "_sigmoid_calibration": [
    "predictions",
    "y",
    "sample_weight",
    "max_abs_prediction_threshold"
  ],
  "_convert_to_logits": [
    "decision_values",
    "eps",
    "xp"
  ],
  "_SigmoidCalibration": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "T"
    ]
  },
  "_TemperatureScaling": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "calibration_curve": [
    "y_true",
    "y_prob"
  ],
  "CalibrationDisplay": {
    "__init__": [
      "self",
      "prob_true",
      "prob_pred",
      "y_prob"
    ],
    "plot": [
      "self"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_prob"
    ]
  },
  "_global_config": [],
  "_threadlocal": [],
  "_get_threadlocal_config": [],
  "get_config": [],
  "set_config": [
    "assume_finite",
    "working_memory",
    "print_changed_only",
    "display",
    "pairwise_dist_chunk_size",
    "enable_cython_pairwise_dist",
    "array_api_dispatch",
    "transform_output",
    "enable_metadata_routing",
    "skip_parameter_validation"
  ],
  "config_context": [],
  "__all__": [],
  "johnson_lindenstrauss_min_dim": [
    "n_samples"
  ],
  "_check_density": [
    "density",
    "n_features"
  ],
  "_check_input_size": [
    "n_components",
    "n_features"
  ],
  "_gaussian_random_matrix": [
    "n_components",
    "n_features",
    "random_state"
  ],
  "_sparse_random_matrix": [
    "n_components",
    "n_features",
    "density",
    "random_state"
  ],
  "BaseRandomProjection": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_make_random_matrix": [
      "self",
      "n_components",
      "n_features"
    ],
    "_compute_inverse_components": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "GaussianRandomProjection": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_make_random_matrix": [
      "self",
      "n_components",
      "n_features"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "SparseRandomProjection": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_make_random_matrix": [
      "self",
      "n_components",
      "n_features"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "clone": [
    "estimator"
  ],
  "_clone_parametrized": [
    "estimator"
  ],
  "BaseEstimator": {
    "__dir__": [
      "self"
    ],
    "_html_repr": [],
    "_get_param_names": [
      "cls"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "_get_params_html": [
      "self",
      "deep",
      "doc_link"
    ],
    "set_params": [
      "self"
    ],
    "__sklearn_clone__": [
      "self"
    ],
    "__repr__": [
      "self",
      "N_CHAR_MAX"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_validate_params": [
      "self"
    ]
  },
  "ClassifierMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "RegressorMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "ClusterMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "BiclusterMixin": {
    "biclusters_": [
      "self"
    ],
    "get_indices": [
      "self",
      "i"
    ],
    "get_shape": [
      "self",
      "i"
    ],
    "get_submatrix": [
      "self",
      "i",
      "data"
    ]
  },
  "TransformerMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "OneToOneFeatureMixin": {
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "ClassNamePrefixFeaturesOutMixin": {
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "DensityMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "OutlierMixin": {
    "__sklearn_tags__": [
      "self"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "MetaEstimatorMixin": {},
  "MultiOutputMixin": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_UnstableArchMixin": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "is_classifier": [
    "estimator"
  ],
  "is_regressor": [
    "estimator"
  ],
  "is_clusterer": [
    "estimator"
  ],
  "is_outlier_detector": [
    "estimator"
  ],
  "_fit_context": [],
  "DummyClassifier": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "DummyRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X",
      "return_std"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "raccoon_face_or_skip": [],
  "dataset_fetchers": [],
  "_SKIP32_MARK": [],
  "global_dtype": [
    "request"
  ],
  "_fetch_fixture": [
    "f"
  ],
  "fetch_20newsgroups_fxt": [],
  "fetch_20newsgroups_vectorized_fxt": [],
  "fetch_california_housing_fxt": [],
  "fetch_covtype_fxt": [],
  "fetch_kddcup99_fxt": [],
  "fetch_lfw_pairs_fxt": [],
  "fetch_lfw_people_fxt": [],
  "fetch_olivetti_faces_fxt": [],
  "fetch_rcv1_fxt": [],
  "fetch_species_distributions_fxt": [],
  "raccoon_face_fxt": [],
  "pytest_collection_modifyitems": [
    "config",
    "items"
  ],
  "pyplot": [],
  "pytest_generate_tests": [
    "metafunc"
  ],
  "pytest_addoption": [
    "parser",
    "pluginmanager"
  ],
  "pytest_configure": [
    "config"
  ],
  "hide_available_pandas": [
    "monkeypatch"
  ],
  "_cov": [
    "X",
    "shrinkage",
    "covariance_estimator"
  ],
  "_class_means": [
    "X",
    "y"
  ],
  "_class_cov": [
    "X",
    "y",
    "priors",
    "shrinkage",
    "covariance_estimator"
  ],
  "DiscriminantAnalysisPredictionMixin": {
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ]
  },
  "LinearDiscriminantAnalysis": {
    "__init__": [
      "self",
      "solver",
      "shrinkage",
      "priors",
      "n_components",
      "store_covariance",
      "tol",
      "covariance_estimator"
    ],
    "_solve_lstsq": [
      "self",
      "X",
      "y",
      "shrinkage",
      "covariance_estimator"
    ],
    "_solve_eigen": [
      "self",
      "X",
      "y",
      "shrinkage",
      "covariance_estimator"
    ],
    "_solve_svd": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "QuadraticDiscriminantAnalysis": {
    "__init__": [
      "self"
    ],
    "_solve_eigen": [
      "self",
      "X"
    ],
    "_solve_svd": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "logger": [],
  "__version__": [],
  "_submodules": [],
  "__dir__": [],
  "__getattr__": [
    "name"
  ],
  "setup_module": [
    "module"
  ],
  "PolynomialCountSketch": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RBFSampler": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SkewedChi2Sampler": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "AdditiveChi2Sampler": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "_transform_dense": [
      "X",
      "sample_steps",
      "sample_interval"
    ],
    "_transform_sparse": [
      "X",
      "sample_steps",
      "sample_interval"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "Nystroem": {
    "__init__": [
      "self",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_get_kernel_params": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_final_estimator_has": [
    "attr"
  ],
  "_cached_transform": [
    "sub_pipeline"
  ],
  "Pipeline": {
    "__init__": [
      "self",
      "steps"
    ],
    "set_output": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_validate_steps": [
      "self"
    ],
    "_iter": [
      "self",
      "with_final",
      "filter_passthrough"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "ind"
    ],
    "named_steps": [
      "self"
    ],
    "_final_estimator": [
      "self"
    ],
    "_log_message": [
      "self",
      "step_idx"
    ],
    "_check_method_params": [
      "self",
      "method",
      "props"
    ],
    "_get_metadata_for_step": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "routed_params",
      "raw_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_can_fit_transform": [
      "self"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "_can_transform": [
      "self"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_can_inverse_transform": [
      "self"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "classes_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "n_features_in_": [
      "self"
    ],
    "feature_names_in_": [
      "self"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "_sk_visual_block_": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_name_estimators": [
    "estimators"
  ],
  "make_pipeline": [],
  "_transform_one": [
    "transformer",
    "X",
    "y",
    "weight",
    "params"
  ],
  "_fit_transform_one": [
    "transformer",
    "X",
    "y",
    "weight",
    "message_clsname",
    "message",
    "params"
  ],
  "_fit_one": [
    "transformer",
    "X",
    "y",
    "weight",
    "message_clsname",
    "message",
    "params"
  ],
  "FeatureUnion": {
    "__init__": [
      "self",
      "transformer_list"
    ],
    "set_output": [
      "self"
    ],
    "named_transformers": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_validate_transformers": [
      "self"
    ],
    "_validate_transformer_weights": [
      "self"
    ],
    "_iter": [
      "self"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "_add_prefix_for_feature_names_out": [
      "self",
      "transformer_with_feature_names_out"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_log_message": [
      "self",
      "name",
      "idx",
      "total"
    ],
    "_parallel_func": [
      "self",
      "X",
      "y",
      "func",
      "routed_params"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_hstack": [
      "self",
      "Xs"
    ],
    "_update_transformer_list": [
      "self",
      "transformers"
    ],
    "n_features_in_": [
      "self"
    ],
    "feature_names_in_": [
      "self"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "_sk_visual_block_": [
      "self"
    ],
    "__getitem__": [
      "self",
      "name"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "make_union": [],
  "_BaseNB": {
    "_joint_log_likelihood": [
      "self",
      "X"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "predict_joint_log_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "GaussianNB": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_update_mean_variance": [
      "n_past",
      "mu",
      "var",
      "X",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "_refit",
      "sample_weight"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_BaseDiscreteNB": {
    "__init__": [
      "self",
      "alpha",
      "fit_prior",
      "class_prior",
      "force_alpha"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y",
      "reset"
    ],
    "_update_class_log_prior": [
      "self",
      "class_prior"
    ],
    "_check_alpha": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_init_counters": [
      "self",
      "n_classes",
      "n_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MultinomialNB": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ]
  },
  "ComplementNB": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ]
  },
  "BernoulliNB": {
    "__init__": [
      "self"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y",
      "reset"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ]
  },
  "CategoricalNB": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y",
      "reset"
    ],
    "_init_counters": [
      "self",
      "n_classes",
      "n_features"
    ],
    "_validate_n_categories": [
      "X",
      "min_categories"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_joint_log_likelihood": [
      "self",
      "X"
    ]
  },
  "UnsetMetadataPassedError": {
    "__init__": [
      "self"
    ]
  },
  "NotFittedError": {},
  "ConvergenceWarning": {},
  "DataConversionWarning": {},
  "DataDimensionalityWarning": {},
  "EfficiencyWarning": {},
  "FitFailedWarning": {},
  "SkipTestWarning": {},
  "UndefinedMetricWarning": {},
  "PositiveSpectrumWarning": {},
  "InconsistentVersionWarning": {
    "__init__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "EstimatorCheckFailedWarning": {
    "__init__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "check_increasing": [
    "x",
    "y"
  ],
  "isotonic_regression": [
    "y"
  ],
  "IsotonicRegression": {
    "__metadata_request__predict": [],
    "__metadata_request__transform": [],
    "__init__": [
      "self"
    ],
    "_check_input_data_shape": [
      "self",
      "X"
    ],
    "_build_f": [
      "self",
      "X",
      "y"
    ],
    "_build_y": [
      "self",
      "X",
      "y",
      "sample_weight",
      "trim_duplicates"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_transform": [
      "self",
      "T"
    ],
    "transform": [
      "self",
      "T"
    ],
    "predict": [
      "self",
      "T"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_fit_binary": [
    "estimator",
    "X",
    "y",
    "fit_params",
    "classes"
  ],
  "_partial_fit_binary": [
    "estimator",
    "X",
    "y",
    "partial_fit_params"
  ],
  "_predict_binary": [
    "estimator",
    "X"
  ],
  "_threshold_for_binary_predict": [
    "estimator"
  ],
  "_ConstantPredictor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "_estimators_has": [
    "attr"
  ],
  "OneVsRestClassifier": {
    "_parameter_constraints": [],
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "multilabel_": [
      "self"
    ],
    "n_classes_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_fit_ovo_binary": [
    "estimator",
    "X",
    "y",
    "i",
    "j",
    "fit_params"
  ],
  "_partial_fit_ovo_binary": [
    "estimator",
    "X",
    "y",
    "i",
    "j",
    "partial_fit_params"
  ],
  "OneVsOneClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "predict": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "n_classes_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "OutputCodeClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_fit_estimator": [
    "estimator",
    "X",
    "y",
    "sample_weight"
  ],
  "_partial_fit_estimator": [
    "estimator",
    "X",
    "y",
    "classes",
    "partial_fit_params",
    "first_time"
  ],
  "_available_if_estimator_has": [
    "attr"
  ],
  "_MultiOutputEstimator": {
    "__init__": [
      "self",
      "estimator"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "MultiOutputRegressor": {
    "__init__": [
      "self",
      "estimator"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "MultiOutputClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "Y",
      "sample_weight"
    ],
    "_check_predict_proba": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_available_if_base_estimator_has": [
    "attr"
  ],
  "_BaseChain": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_get_estimator": [
      "self"
    ],
    "_log_message": [
      "self"
    ],
    "_get_predictions": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "ClassifierChain": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RegressorChain": {
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LIBSVM_IMPL": [],
  "_one_vs_one_coef": [
    "dual_coef",
    "n_support",
    "support_vectors"
  ],
  "BaseLibSVM": {
    "_sparse_kernels": [],
    "__init__": [
      "self",
      "kernel",
      "degree",
      "gamma",
      "coef0",
      "tol",
      "C",
      "nu",
      "epsilon",
      "shrinking",
      "probability",
      "cache_size",
      "class_weight",
      "verbose",
      "max_iter",
      "random_state"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_validate_targets": [
      "self",
      "y"
    ],
    "_warn_from_fit_status": [
      "self"
    ],
    "_dense_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "solver_type",
      "kernel",
      "random_seed"
    ],
    "_sparse_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "solver_type",
      "kernel",
      "random_seed"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_dense_predict": [
      "self",
      "X"
    ],
    "_sparse_predict": [
      "self",
      "X"
    ],
    "_compute_kernel": [
      "self",
      "X"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "_dense_decision_function": [
      "self",
      "X"
    ],
    "_sparse_decision_function": [
      "self",
      "X"
    ],
    "_validate_for_predict": [
      "self",
      "X"
    ],
    "coef_": [
      "self"
    ],
    "_get_coef": [
      "self"
    ],
    "n_support_": [
      "self"
    ]
  },
  "BaseSVC": {
    "__init__": [
      "self",
      "kernel",
      "degree",
      "gamma",
      "coef0",
      "tol",
      "C",
      "nu",
      "shrinking",
      "probability",
      "cache_size",
      "class_weight",
      "verbose",
      "max_iter",
      "decision_function_shape",
      "random_state",
      "break_ties"
    ],
    "_validate_targets": [
      "self",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_check_proba": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "_dense_predict_proba": [
      "self",
      "X"
    ],
    "_sparse_predict_proba": [
      "self",
      "X"
    ],
    "_get_coef": [
      "self"
    ],
    "probA_": [
      "self"
    ],
    "probB_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_get_liblinear_solver_type": [
    "multi_class",
    "penalty",
    "loss",
    "dual"
  ],
  "_fit_liblinear": [
    "X",
    "y",
    "C",
    "fit_intercept",
    "intercept_scaling",
    "class_weight",
    "penalty",
    "dual",
    "verbose",
    "max_iter",
    "tol",
    "random_state",
    "multi_class",
    "loss",
    "epsilon",
    "sample_weight"
  ],
  "_validate_dual_parameter": [
    "dual",
    "loss",
    "penalty",
    "multi_class",
    "X"
  ],
  "LinearSVC": {
    "__init__": [
      "self",
      "penalty",
      "loss"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LinearSVR": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SVC": {
    "_impl": [],
    "__init__": [
      "self"
    ]
  },
  "NuSVC": {
    "_impl": [],
    "__init__": [
      "self"
    ]
  },
  "SVR": {
    "_impl": [],
    "__init__": [
      "self"
    ]
  },
  "NuSVR": {
    "_impl": [],
    "__init__": [
      "self"
    ]
  },
  "OneClassSVM": {
    "_impl": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "l1_min_c": [
    "X",
    "y"
  ],
  "X": [],
  "Y": [],
  "T": [],
  "true_result": [],
  "X2": [],
  "Y2": [],
  "T2": [],
  "true_result2": [],
  "iris": [],
  "rng": [],
  "perm": [],
  "check_svm_model_equal": [
    "dense_svm",
    "X_train",
    "y_train",
    "X_test"
  ],
  "test_svc": [
    "X_train",
    "y_train",
    "X_test",
    "kernel",
    "sparse_container"
  ],
  "test_unsorted_indices": [
    "csr_container"
  ],
  "test_svc_with_custom_kernel": [
    "lil_container"
  ],
  "test_svc_iris": [
    "csr_container",
    "kernel"
  ],
  "test_sparse_decision_function": [
    "csr_container"
  ],
  "test_error": [
    "lil_container"
  ],
  "test_linearsvc": [
    "lil_container",
    "dok_container"
  ],
  "test_linearsvc_iris": [
    "csr_container"
  ],
  "test_weight": [
    "csr_container"
  ],
  "test_sample_weights": [
    "lil_container"
  ],
  "test_sparse_liblinear_intercept_handling": [],
  "test_sparse_oneclasssvm": [
    "X_train",
    "y_train",
    "X_test",
    "kernel",
    "sparse_container"
  ],
  "test_sparse_realdata": [
    "csr_container"
  ],
  "test_sparse_svc_clone_with_callable_kernel": [
    "lil_container"
  ],
  "test_timeout": [
    "lil_container"
  ],
  "test_consistent_proba": [],
  "test_l1_min_c": [
    "X_container",
    "loss",
    "intercept_label"
  ],
  "check_l1_min_c": [
    "X",
    "y",
    "loss",
    "fit_intercept",
    "intercept_scaling"
  ],
  "test_ill_posed_min_c": [],
  "_MAX_UNSIGNED_INT": [],
  "test_newrand_default": [],
  "test_newrand_set_seed": [
    "seed",
    "expected"
  ],
  "test_newrand_set_seed_overflow": [
    "seed"
  ],
  "test_newrand_bounded_rand_int": [
    "range_",
    "n_pts"
  ],
  "test_newrand_bounded_rand_int_limits": [
    "range_"
  ],
  "get_iris_dataset": [
    "random_seed"
  ],
  "test_libsvm_parameters": [],
  "test_libsvm_iris": [
    "global_random_seed"
  ],
  "test_precomputed": [],
  "test_svr": [],
  "test_linearsvr": [],
  "test_linearsvr_fit_sampleweight": [
    "global_random_seed"
  ],
  "test_svr_errors": [],
  "test_oneclass": [],
  "test_oneclass_decision_function": [],
  "test_oneclass_score_samples": [],
  "test_tweak_params": [],
  "test_probability": [
    "global_random_seed"
  ],
  "test_decision_function": [
    "global_random_seed"
  ],
  "test_decision_function_shape": [
    "SVM",
    "global_random_seed"
  ],
  "test_svr_predict": [
    "global_random_seed"
  ],
  "test_svm_classifier_sided_sample_weight": [
    "estimator"
  ],
  "test_svm_regressor_sided_sample_weight": [
    "estimator"
  ],
  "test_svm_equivalence_sample_weight_C": [],
  "test_negative_sample_weights_mask_all_samples": [
    "Estimator",
    "err_msg",
    "sample_weight"
  ],
  "test_negative_weights_svc_leave_just_one_label": [
    "Classifier",
    "err_msg",
    "sample_weight"
  ],
  "test_negative_weights_svc_leave_two_labels": [
    "Classifier",
    "model",
    "sample_weight",
    "mask_side"
  ],
  "test_negative_weight_equal_coeffs": [
    "Estimator",
    "sample_weight"
  ],
  "test_auto_weight": [],
  "test_bad_input": [
    "lil_container",
    "global_random_seed"
  ],
  "test_svc_nonfinite_params": [
    "global_random_seed"
  ],
  "test_unicode_kernel": [
    "global_random_seed"
  ],
  "test_sparse_precomputed": [
    "csr_container"
  ],
  "test_sparse_fit_support_vectors_empty": [
    "csr_container"
  ],
  "test_linearsvc_parameters": [
    "loss",
    "penalty",
    "dual",
    "global_random_seed"
  ],
  "test_linearsvc_crammer_singer": [
    "global_random_seed"
  ],
  "test_linearsvc_fit_sampleweight": [
    "global_random_seed"
  ],
  "test_crammer_singer_binary": [
    "global_random_seed"
  ],
  "test_dense_liblinear_intercept_handling": [
    "classifier",
    "global_random_seed"
  ],
  "test_liblinear_set_coef": [
    "global_random_seed"
  ],
  "test_immutable_coef_property": [
    "global_random_seed"
  ],
  "test_linearsvc_verbose": [],
  "test_svc_clone_with_callable_kernel": [],
  "test_svc_bad_kernel": [],
  "test_libsvm_convergence_warnings": [
    "global_random_seed"
  ],
  "test_unfitted": [],
  "test_linear_svm_convergence_warnings": [
    "global_random_seed"
  ],
  "test_svr_coef_sign": [
    "global_random_seed"
  ],
  "test_lsvc_intercept_scaling_zero": [],
  "test_hasattr_predict_proba": [
    "global_random_seed"
  ],
  "test_decision_function_shape_two_class": [
    "global_random_seed"
  ],
  "test_ovr_decision_function": [],
  "test_svc_invalid_break_ties_param": [
    "SVCClass",
    "global_random_seed"
  ],
  "test_svc_ovr_tie_breaking": [
    "SVCClass",
    "global_random_seed"
  ],
  "test_gamma_scale": [],
  "test_linearsvm_liblinear_sample_weight": [
    "SVM",
    "params",
    "global_random_seed"
  ],
  "test_n_support": [
    "Klass"
  ],
  "test_custom_kernel_not_array_input": [
    "Estimator"
  ],
  "test_svc_raises_error_internal_representation": [],
  "test_n_iter_libsvm": [
    "estimator",
    "expected_n_iter_type",
    "n_classes",
    "global_random_seed"
  ],
  "test_dual_auto": [
    "loss"
  ],
  "test_dual_auto_edge_cases": [],
  "test_svm_with_infinite_C": [
    "Estimator",
    "make_dataset",
    "C_inf",
    "global_random_seed"
  ],
  "_grid_from_X": [
    "X",
    "percentiles",
    "is_categorical",
    "grid_resolution",
    "custom_values"
  ],
  "_partial_dependence_recursion": [
    "est",
    "grid",
    "features"
  ],
  "_partial_dependence_brute": [
    "est",
    "grid",
    "features",
    "X",
    "response_method",
    "sample_weight"
  ],
  "partial_dependence": [
    "estimator",
    "X",
    "features"
  ],
  "_check_feature_names": [
    "X",
    "feature_names"
  ],
  "_get_feature_index": [
    "fx",
    "feature_names"
  ],
  "_weights_scorer": [
    "scorer",
    "estimator",
    "X",
    "y",
    "sample_weight"
  ],
  "_calculate_permutation_scores": [
    "estimator",
    "X",
    "y",
    "sample_weight",
    "col_idx",
    "random_state",
    "n_repeats",
    "scorer",
    "max_samples"
  ],
  "_create_importances_bunch": [
    "baseline_score",
    "permuted_score"
  ],
  "permutation_importance": [
    "estimator",
    "X",
    "y"
  ],
  "test_permutation_importance_correlated_feature_regression": [
    "n_jobs",
    "max_samples",
    "sample_weight"
  ],
  "test_permutation_importance_correlated_feature_regression_pandas": [
    "n_jobs",
    "max_samples"
  ],
  "test_robustness_to_high_cardinality_noisy_feature": [
    "n_jobs",
    "max_samples",
    "seed"
  ],
  "test_permutation_importance_mixed_types": [],
  "test_permutation_importance_mixed_types_pandas": [],
  "test_permutation_importance_linear_regresssion": [],
  "test_permutation_importance_equivalence_sequential_parallel": [
    "max_samples"
  ],
  "test_permutation_importance_equivalence_array_dataframe": [
    "n_jobs",
    "max_samples"
  ],
  "test_permutation_importance_large_memmaped_data": [
    "input_type"
  ],
  "test_permutation_importance_sample_weight": [],
  "test_permutation_importance_no_weights_scoring_function": [],
  "test_permutation_importance_multi_metric": [
    "list_single_scorer",
    "multi_scorer"
  ],
  "test_permutation_importance_max_samples_error": [],
  "y": [],
  "binary_classification_data": [],
  "multiclass_classification_data": [],
  "regression_data": [],
  "multioutput_regression_data": [],
  "test_output_shape": [
    "Estimator",
    "method",
    "data",
    "grid_resolution",
    "features",
    "kind",
    "use_custom_values"
  ],
  "test_grid_from_X": [],
  "test_grid_from_X_with_categorical": [
    "grid_resolution"
  ],
  "test_grid_from_X_heterogeneous_type": [
    "grid_resolution"
  ],
  "test_grid_from_X_error": [
    "grid_resolution",
    "percentiles",
    "err_msg"
  ],
  "test_partial_dependence_helpers": [
    "est",
    "method",
    "target_feature"
  ],
  "test_recursion_decision_tree_vs_forest_and_gbdt": [
    "seed"
  ],
  "test_recursion_decision_function": [
    "est",
    "target_feature"
  ],
  "test_partial_dependence_easy_target": [
    "est",
    "power"
  ],
  "test_multiclass_multioutput": [
    "Estimator"
  ],
  "NoPredictProbaNoDecisionFunction": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_partial_dependence_error": [
    "estimator",
    "params",
    "err_msg"
  ],
  "test_partial_dependence_unknown_feature_indices": [
    "estimator",
    "features"
  ],
  "test_partial_dependence_unknown_feature_string": [
    "estimator"
  ],
  "test_partial_dependence_X_list": [
    "estimator"
  ],
  "test_warning_recursion_non_constant_init": [],
  "test_partial_dependence_sample_weight_of_fitted_estimator": [],
  "test_hist_gbdt_sw_not_supported": [],
  "test_partial_dependence_pipeline": [],
  "test_partial_dependence_binary_model_grid_resolution": [
    "features",
    "grid_resolution",
    "n_vals_expected"
  ],
  "test_partial_dependence_binary_model_custom_values": [
    "features",
    "custom_values",
    "n_vals_expected"
  ],
  "test_partial_dependence_pipeline_custom_values": [
    "features",
    "custom_values",
    "n_vals_expected"
  ],
  "test_partial_dependence_dataframe": [
    "estimator",
    "preprocessor",
    "features"
  ],
  "test_partial_dependence_feature_type": [
    "features",
    "custom_values",
    "expected_pd_shape"
  ],
  "test_partial_dependence_unfitted": [
    "estimator"
  ],
  "test_kind_average_and_average_of_individual": [
    "Estimator",
    "data"
  ],
  "test_partial_dependence_kind_individual_ignores_sample_weight": [
    "Estimator",
    "data"
  ],
  "test_partial_dependence_non_null_weight_idx": [
    "estimator",
    "non_null_weight_idx"
  ],
  "test_partial_dependence_equivalence_equal_sample_weight": [
    "Estimator",
    "data"
  ],
  "test_partial_dependence_sample_weight_size_error": [],
  "test_partial_dependence_sample_weight_with_recursion": [],
  "test_mixed_type_categorical": [],
  "test_reject_array_with_integer_dtype": [],
  "test_reject_pandas_with_integer_dtype": [],
  "test_partial_dependence_empty_categorical_features": [],
  "test_check_feature_names": [
    "feature_names",
    "array_type",
    "expected_feature_names"
  ],
  "test_check_feature_names_error": [],
  "test_get_feature_index": [
    "fx",
    "idx"
  ],
  "test_get_feature_names_error": [
    "fx",
    "feature_names",
    "err_msg"
  ],
  "_check_boundary_response_method": [
    "estimator",
    "response_method",
    "class_of_interest"
  ],
  "DecisionBoundaryDisplay": {
    "__init__": [
      "self"
    ],
    "plot": [
      "self",
      "plot_method",
      "ax",
      "xlabel",
      "ylabel"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X"
    ]
  },
  "PartialDependenceDisplay": {
    "__init__": [
      "self",
      "pd_results"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "features"
    ],
    "_get_sample_count": [
      "self",
      "n_samples"
    ],
    "_plot_ice_lines": [
      "self",
      "preds",
      "feature_values",
      "n_ice_to_plot",
      "ax",
      "pd_plot_idx",
      "n_total_lines_by_plot",
      "individual_line_kw"
    ],
    "_plot_average_dependence": [
      "self",
      "avg_preds",
      "feature_values",
      "ax",
      "pd_line_idx",
      "line_kw",
      "categorical",
      "bar_kw"
    ],
    "_plot_one_way_partial_dependence": [
      "self",
      "kind",
      "preds",
      "avg_preds",
      "feature_values",
      "feature_idx",
      "n_ice_lines",
      "ax",
      "n_cols",
      "pd_plot_idx",
      "n_lines",
      "ice_lines_kw",
      "pd_line_kw",
      "categorical",
      "bar_kw",
      "pdp_lim"
    ],
    "_plot_two_way_partial_dependence": [
      "self",
      "avg_preds",
      "feature_values",
      "feature_idx",
      "ax",
      "pd_plot_idx",
      "Z_level",
      "contour_kw",
      "categorical",
      "heatmap_kw"
    ],
    "plot": [
      "self"
    ]
  },
  "load_iris_2d_scaled": [],
  "fitted_clf": [],
  "test_input_data_dimension": [
    "pyplot"
  ],
  "test_check_boundary_response_method_error": [],
  "test_check_boundary_response_method": [
    "estimator",
    "response_method",
    "class_of_interest",
    "expected_prediction_method"
  ],
  "test_multiclass_predict": [
    "pyplot"
  ],
  "test_input_validation_errors": [
    "pyplot",
    "kwargs",
    "error_msg",
    "fitted_clf"
  ],
  "test_input_validation_errors_multiclass_colors": [
    "pyplot",
    "kwargs",
    "error_msg"
  ],
  "test_display_plot_input_error": [
    "pyplot",
    "fitted_clf"
  ],
  "test_decision_boundary_display_classifier": [
    "pyplot",
    "fitted_clf",
    "response_method",
    "plot_method"
  ],
  "test_decision_boundary_display_outlier_detector": [
    "pyplot",
    "response_method",
    "plot_method"
  ],
  "test_decision_boundary_display_regressor": [
    "pyplot",
    "response_method",
    "plot_method"
  ],
  "test_error_bad_response": [
    "pyplot",
    "response_method",
    "msg"
  ],
  "test_multilabel_classifier_error": [
    "pyplot",
    "response_method"
  ],
  "test_multi_output_multi_class_classifier_error": [
    "pyplot",
    "response_method"
  ],
  "test_multioutput_regressor_error": [
    "pyplot"
  ],
  "test_regressor_unsupported_response": [
    "pyplot",
    "response_method"
  ],
  "test_dataframe_labels_used": [
    "pyplot",
    "fitted_clf"
  ],
  "test_string_target": [
    "pyplot"
  ],
  "test_dataframe_support": [
    "pyplot",
    "constructor_name"
  ],
  "test_class_of_interest_binary": [
    "pyplot",
    "response_method"
  ],
  "test_class_of_interest_multiclass": [
    "pyplot",
    "response_method"
  ],
  "test_multiclass_plot_max_class": [
    "pyplot",
    "response_method"
  ],
  "test_multiclass_colors_cmap": [
    "pyplot",
    "plot_method",
    "multiclass_colors"
  ],
  "test_cmap_and_colors_logic": [
    "pyplot"
  ],
  "test_subclass_named_constructors_return_type_is_subclass": [
    "pyplot"
  ],
  "diabetes": [],
  "clf_diabetes": [
    "diabetes"
  ],
  "custom_values_helper": [
    "feature",
    "grid_resolution"
  ],
  "test_plot_partial_dependence": [
    "use_custom_values",
    "grid_resolution",
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_kind": [
    "pyplot",
    "kind",
    "centered",
    "subsample",
    "shape",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_str_features": [
    "pyplot",
    "use_custom_values",
    "clf_diabetes",
    "diabetes",
    "input_type",
    "feature_names_type"
  ],
  "test_plot_partial_dependence_custom_axes": [
    "use_custom_values",
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_passing_numpy_axes": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "use_custom_values",
    "kind",
    "lines"
  ],
  "test_plot_partial_dependence_incorrent_num_axes": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "use_custom_values",
    "nrows",
    "ncols"
  ],
  "test_plot_partial_dependence_with_same_axes": [
    "use_custom_values",
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_feature_name_reuse": [
    "use_custom_values",
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_multiclass": [
    "use_custom_values",
    "pyplot"
  ],
  "test_plot_partial_dependence_multioutput": [
    "use_custom_values",
    "pyplot",
    "target"
  ],
  "test_plot_partial_dependence_dataframe": [
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "dummy_classification_data": [],
  "test_plot_partial_dependence_error": [
    "pyplot",
    "data",
    "params",
    "err_msg"
  ],
  "test_plot_partial_dependence_multiclass_error": [
    "pyplot",
    "params",
    "err_msg"
  ],
  "test_plot_partial_dependence_does_not_override_ylabel": [
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_plot_partial_dependence_with_categorical": [
    "pyplot",
    "categorical_features",
    "array_type"
  ],
  "test_plot_partial_dependence_legend": [
    "pyplot"
  ],
  "test_plot_partial_dependence_subsampling": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "use_custom_values",
    "kind",
    "expected_shape"
  ],
  "test_partial_dependence_overwrite_labels": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "kind",
    "line_kw",
    "label"
  ],
  "test_grid_resolution_with_categorical": [
    "pyplot",
    "categorical_features",
    "array_type"
  ],
  "test_partial_dependence_plot_limits_one_way": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "kind",
    "centered"
  ],
  "test_partial_dependence_plot_limits_two_way": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "centered"
  ],
  "test_partial_dependence_kind_list": [
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_partial_dependence_kind_error": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "features",
    "kind"
  ],
  "test_plot_partial_dependence_lines_kw": [
    "pyplot",
    "clf_diabetes",
    "diabetes",
    "line_kw",
    "pd_line_kw",
    "ice_lines_kw",
    "expected_colors"
  ],
  "test_partial_dependence_display_wrong_len_kind": [
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "test_partial_dependence_display_kind_centered_interaction": [
    "pyplot",
    "kind",
    "clf_diabetes",
    "diabetes"
  ],
  "test_partial_dependence_display_with_constant_sample_weight": [
    "pyplot",
    "clf_diabetes",
    "diabetes"
  ],
  "_pinv2_old": [
    "a"
  ],
  "_get_first_singular_vectors_power_method": [
    "X",
    "y",
    "mode",
    "max_iter",
    "tol",
    "norm_y_weights"
  ],
  "_get_first_singular_vectors_svd": [
    "X",
    "y"
  ],
  "_center_scale_xy": [
    "X",
    "y",
    "scale"
  ],
  "_svd_flip_1d": [
    "u",
    "v"
  ],
  "_PLS": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y",
      "copy"
    ],
    "inverse_transform": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "copy"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "PLSRegression": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "PLSCanonical": {
    "__init__": [
      "self",
      "n_components"
    ]
  },
  "CCA": {
    "__init__": [
      "self",
      "n_components"
    ]
  },
  "PLSSVD": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "assert_matrix_orthogonal": [
    "M"
  ],
  "test_pls_canonical_basics": [],
  "test_sanity_check_pls_regression": [],
  "test_sanity_check_pls_regression_constant_column_y": [],
  "test_sanity_check_pls_canonical": [],
  "test_sanity_check_pls_canonical_random": [],
  "test_convergence_fail": [],
  "test_attibutes_shapes": [
    "Est"
  ],
  "test_univariate_equivalence": [
    "Est"
  ],
  "test_copy": [
    "Est"
  ],
  "_generate_test_scale_and_stability_datasets": [],
  "test_scale_and_stability": [
    "Est",
    "X",
    "y"
  ],
  "test_n_components_upper_bounds": [
    "Estimator"
  ],
  "test_n_components_upper_PLSRegression": [],
  "test_singular_value_helpers": [
    "n_samples",
    "n_features",
    "global_random_seed"
  ],
  "test_one_component_equivalence": [
    "global_random_seed"
  ],
  "test_svd_flip_1d": [],
  "test_loadings_converges": [
    "global_random_seed"
  ],
  "test_pls_constant_y": [],
  "test_pls_coef_shape": [
    "PLSEstimator"
  ],
  "test_pls_prediction": [
    "PLSEstimator",
    "scale"
  ],
  "test_pls_feature_names_out": [
    "Klass"
  ],
  "test_pls_set_output": [
    "Klass"
  ],
  "test_pls_regression_fit_1d_y": [],
  "test_pls_regression_scaling_coef": [],
  "SOLVE_TRIANGULAR_ARGS": [],
  "lars_path": [
    "X",
    "y",
    "Xy"
  ],
  "lars_path_gram": [
    "Xy",
    "Gram"
  ],
  "_lars_path_solver": [
    "X",
    "y",
    "Xy",
    "Gram",
    "n_samples",
    "max_iter",
    "alpha_min",
    "method",
    "copy_X",
    "eps",
    "copy_Gram",
    "verbose",
    "return_path",
    "return_n_iter",
    "positive"
  ],
  "Lars": {
    "method": [],
    "positive": [],
    "__init__": [
      "self"
    ],
    "_get_gram": [
      "precompute",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "max_iter",
      "alpha",
      "fit_path",
      "Xy"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "Xy"
    ]
  },
  "LassoLars": {
    "method": [],
    "__init__": [
      "self",
      "alpha"
    ]
  },
  "_check_copy_and_writeable": [
    "array",
    "copy"
  ],
  "_lars_path_residues": [
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "Gram",
    "copy",
    "method",
    "verbose",
    "fit_intercept",
    "max_iter",
    "eps",
    "positive"
  ],
  "LarsCV": {
    "method": [],
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "LassoLarsCV": {
    "_parameter_constraints": [],
    "method": [],
    "__init__": [
      "self"
    ]
  },
  "LassoLarsIC": {
    "__init__": [
      "self",
      "criterion"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "copy_X"
    ],
    "_estimate_noise_variance": [
      "self",
      "X",
      "y",
      "positive"
    ]
  },
  "_huber_loss_and_gradient": [
    "w",
    "X",
    "y",
    "epsilon",
    "alpha",
    "sample_weight"
  ],
  "HuberRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_set_order": [
    "X",
    "y",
    "order"
  ],
  "_alpha_grid": [
    "X",
    "y",
    "Xy",
    "l1_ratio",
    "fit_intercept",
    "eps",
    "n_alphas",
    "sample_weight"
  ],
  "lasso_path": [
    "X",
    "y"
  ],
  "enet_path": [
    "X",
    "y"
  ],
  "ElasticNet": {
    "__metadata_request__fit": [],
    "path": [],
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ],
    "sparse_coef_": [
      "self"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "Lasso": {
    "path": [],
    "__init__": [
      "self",
      "alpha"
    ]
  },
  "_path_residuals": [
    "X",
    "y",
    "sample_weight",
    "train",
    "test",
    "fit_intercept",
    "path",
    "path_params",
    "alphas",
    "l1_ratio",
    "X_order",
    "dtype"
  ],
  "LinearModelCV": {
    "__init__": [
      "self",
      "eps",
      "n_alphas",
      "alphas",
      "fit_intercept",
      "precompute",
      "max_iter",
      "tol",
      "copy_X",
      "cv",
      "verbose",
      "n_jobs",
      "positive",
      "random_state",
      "selection"
    ],
    "_get_estimator": [
      "self"
    ],
    "_is_multitask": [
      "self"
    ],
    "path": [
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LassoCV": {
    "path": [],
    "__init__": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "_is_multitask": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "ElasticNetCV": {
    "path": [],
    "__init__": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "_is_multitask": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "MultiTaskElasticNet": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MultiTaskLasso": {
    "__init__": [
      "self",
      "alpha"
    ]
  },
  "MultiTaskElasticNetCV": {
    "path": [],
    "__init__": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "_is_multitask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "MultiTaskLassoCV": {
    "path": [],
    "__init__": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "_is_multitask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_LOGISTIC_SOLVER_CONVERGENCE_MSG": [],
  "_check_solver": [
    "solver",
    "penalty",
    "dual"
  ],
  "_logistic_regression_path": [
    "X",
    "y"
  ],
  "_log_reg_scoring_path": [
    "X",
    "y",
    "train",
    "test"
  ],
  "LogisticRegression": {
    "__init__": [
      "self",
      "penalty"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LogisticRegressionCV": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_scorer": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_EPSILON": [],
  "_dynamic_max_trials": [
    "n_inliers",
    "n_samples",
    "min_samples",
    "probability"
  ],
  "RANSACRegressor": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "QuantileRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SPARSE_INTERCEPT_DECAY": [],
  "make_dataset": [
    "X",
    "y",
    "sample_weight",
    "random_state"
  ],
  "_preprocess_data": [
    "X",
    "y"
  ],
  "_rescale_data": [
    "X",
    "y",
    "sample_weight",
    "inplace"
  ],
  "LinearModel": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_set_intercept": [
      "self",
      "X_offset",
      "y_offset",
      "X_scale"
    ]
  },
  "LinearClassifierMixin": {
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict_proba_lr": [
      "self",
      "X"
    ]
  },
  "SparseCoefMixin": {
    "densify": [
      "self"
    ],
    "sparsify": [
      "self"
    ]
  },
  "LinearRegression": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_precomputed_gram_matrix": [
    "X",
    "precompute",
    "X_offset",
    "X_scale",
    "rtol",
    "atol"
  ],
  "_pre_fit": [
    "X",
    "y",
    "Xy",
    "precompute",
    "fit_intercept",
    "copy",
    "check_gram",
    "sample_weight"
  ],
  "premature": [],
  "_cholesky_omp": [
    "X",
    "y",
    "n_nonzero_coefs",
    "tol",
    "copy_X",
    "return_path"
  ],
  "_gram_omp": [
    "Gram",
    "Xy",
    "n_nonzero_coefs",
    "tol_0",
    "tol",
    "copy_Gram",
    "copy_Xy",
    "return_path"
  ],
  "orthogonal_mp": [
    "X",
    "y"
  ],
  "orthogonal_mp_gram": [
    "Gram",
    "Xy"
  ],
  "OrthogonalMatchingPursuit": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_omp_path_residues": [
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "copy",
    "fit_intercept",
    "max_iter"
  ],
  "OrthogonalMatchingPursuitCV": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "get_auto_step_size": [
    "max_squared_sum",
    "alpha_scaled",
    "loss",
    "fit_intercept",
    "n_samples",
    "is_saga"
  ],
  "sag_solver": [
    "X",
    "y",
    "sample_weight",
    "loss",
    "alpha",
    "beta",
    "max_iter",
    "tol",
    "verbose",
    "random_state",
    "check_input",
    "max_squared_sum",
    "warm_start_mem",
    "is_saga"
  ],
  "Perceptron": {
    "__init__": [
      "self"
    ]
  },
  "sandwich_dot": [
    "X",
    "W"
  ],
  "LinearModelLoss": {
    "__init__": [
      "self",
      "base_loss",
      "fit_intercept"
    ],
    "init_zero_coef": [
      "self",
      "X",
      "dtype"
    ],
    "weight_intercept": [
      "self",
      "coef"
    ],
    "weight_intercept_raw": [
      "self",
      "coef",
      "X"
    ],
    "l2_penalty": [
      "self",
      "weights",
      "l2_reg_strength"
    ],
    "loss": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "l2_reg_strength",
      "n_threads",
      "raw_prediction"
    ],
    "loss_gradient": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "l2_reg_strength",
      "n_threads",
      "raw_prediction"
    ],
    "gradient": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "l2_reg_strength",
      "n_threads",
      "raw_prediction"
    ],
    "gradient_hessian": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "l2_reg_strength",
      "n_threads",
      "gradient_out",
      "hessian_out",
      "raw_prediction"
    ],
    "gradient_hessian_product": [
      "self",
      "coef",
      "X",
      "y",
      "sample_weight",
      "l2_reg_strength",
      "n_threads"
    ]
  },
  "BayesianRidge": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X",
      "return_std"
    ],
    "_update_coef_": [
      "self",
      "X",
      "y",
      "n_samples",
      "n_features",
      "XT_y",
      "U",
      "Vh",
      "eigen_vals_",
      "alpha_",
      "lambda_"
    ],
    "_log_marginal_likelihood": [
      "self",
      "n_samples",
      "n_features",
      "sw_sum",
      "eigen_vals",
      "alpha_",
      "lambda_",
      "coef",
      "sse"
    ]
  },
  "ARDRegression": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_update_sigma_woodbury": [
      "self",
      "X",
      "alpha_",
      "lambda_",
      "keep_lambda"
    ],
    "_update_sigma": [
      "self",
      "X",
      "alpha_",
      "lambda_",
      "keep_lambda"
    ],
    "predict": [
      "self",
      "X",
      "return_std"
    ]
  },
  "_modified_weiszfeld_step": [
    "X",
    "x_old"
  ],
  "_spatial_median": [
    "X",
    "max_iter",
    "tol"
  ],
  "_breakdown_point": [
    "n_samples",
    "n_subsamples"
  ],
  "_lstsq": [
    "X",
    "y",
    "indices",
    "fit_intercept"
  ],
  "TheilSenRegressor": {
    "__init__": [
      "self"
    ],
    "_check_subparams": [
      "self",
      "n_samples",
      "n_features"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_get_rescaled_operator": [
    "X",
    "X_offset",
    "sample_weight_sqrt"
  ],
  "_solve_sparse_cg": [
    "X",
    "y",
    "alpha",
    "max_iter",
    "tol",
    "verbose",
    "X_offset",
    "X_scale",
    "sample_weight_sqrt"
  ],
  "_solve_lsqr": [
    "X",
    "y"
  ],
  "_solve_cholesky": [
    "X",
    "y",
    "alpha"
  ],
  "_solve_cholesky_kernel": [
    "K",
    "y",
    "alpha",
    "sample_weight",
    "copy"
  ],
  "_solve_svd": [
    "X",
    "y",
    "alpha",
    "xp"
  ],
  "_solve_lbfgs": [
    "X",
    "y",
    "alpha",
    "positive",
    "max_iter",
    "tol",
    "X_offset",
    "X_scale",
    "sample_weight_sqrt"
  ],
  "_get_valid_accept_sparse": [
    "is_X_sparse",
    "solver"
  ],
  "ridge_regression": [
    "X",
    "y",
    "alpha"
  ],
  "_ridge_regression": [
    "X",
    "y",
    "alpha",
    "sample_weight",
    "solver",
    "max_iter",
    "tol",
    "verbose",
    "positive",
    "random_state",
    "return_n_iter",
    "return_intercept",
    "return_solver",
    "X_scale",
    "X_offset",
    "check_input",
    "fit_intercept"
  ],
  "resolve_solver": [
    "solver",
    "positive",
    "return_intercept",
    "is_sparse",
    "xp"
  ],
  "resolve_solver_for_numpy": [
    "positive",
    "return_intercept",
    "is_sparse"
  ],
  "_BaseRidge": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "Ridge": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_RidgeClassifierMixin": {
    "_prepare_data": [
      "self",
      "X",
      "y",
      "sample_weight",
      "solver"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_get_scorer_instance": [
      "self"
    ]
  },
  "RidgeClassifier": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_gcv_mode": [
    "X",
    "gcv_mode"
  ],
  "_find_smallest_angle": [
    "query",
    "vectors"
  ],
  "_X_CenterStackOp": {
    "__init__": [
      "self",
      "X",
      "X_mean",
      "sqrt_sw"
    ],
    "_matvec": [
      "self",
      "v"
    ],
    "_matmat": [
      "self",
      "v"
    ],
    "_transpose": [
      "self"
    ]
  },
  "_XT_CenterStackOp": {
    "__init__": [
      "self",
      "X",
      "X_mean",
      "sqrt_sw"
    ],
    "_matvec": [
      "self",
      "v"
    ],
    "_matmat": [
      "self",
      "v"
    ]
  },
  "_IdentityRegressor": {
    "decision_function": [
      "self",
      "y_predict"
    ],
    "predict": [
      "self",
      "y_predict"
    ]
  },
  "_IdentityClassifier": {
    "__init__": [
      "self",
      "classes"
    ],
    "decision_function": [
      "self",
      "y_predict"
    ]
  },
  "_RidgeGCV": {
    "__init__": [
      "self",
      "alphas"
    ],
    "_decomp_diag": [
      "v_prime",
      "Q"
    ],
    "_diag_dot": [
      "D",
      "B"
    ],
    "_compute_gram": [
      "self",
      "X",
      "sqrt_sw"
    ],
    "_compute_covariance": [
      "self",
      "X",
      "sqrt_sw"
    ],
    "_sparse_multidot_diag": [
      "self",
      "X",
      "A",
      "X_mean",
      "sqrt_sw"
    ],
    "_eigen_decompose_gram": [
      "self",
      "X",
      "y",
      "sqrt_sw"
    ],
    "_solve_eigen_gram": [
      "self",
      "alpha",
      "y",
      "sqrt_sw",
      "X_mean",
      "eigvals",
      "Q",
      "QT_y"
    ],
    "_eigen_decompose_covariance": [
      "self",
      "X",
      "y",
      "sqrt_sw"
    ],
    "_solve_eigen_covariance_no_intercept": [
      "self",
      "alpha",
      "y",
      "sqrt_sw",
      "X_mean",
      "eigvals",
      "V",
      "X"
    ],
    "_solve_eigen_covariance_intercept": [
      "self",
      "alpha",
      "y",
      "sqrt_sw",
      "X_mean",
      "eigvals",
      "V",
      "X"
    ],
    "_solve_eigen_covariance": [
      "self",
      "alpha",
      "y",
      "sqrt_sw",
      "X_mean",
      "eigvals",
      "V",
      "X"
    ],
    "_svd_decompose_design_matrix": [
      "self",
      "X",
      "y",
      "sqrt_sw"
    ],
    "_solve_svd_design_matrix": [
      "self",
      "alpha",
      "y",
      "sqrt_sw",
      "X_mean",
      "singvals_sq",
      "U",
      "UT_y"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "score_params"
    ],
    "_score_without_scorer": [
      "self",
      "squared_errors"
    ],
    "_score": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_BaseRidgeCV": {
    "__init__": [
      "self",
      "alphas"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_scorer": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RidgeCV": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_get_scorer_instance": [
      "self"
    ]
  },
  "RidgeClassifierCV": {
    "__init__": [
      "self",
      "alphas"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "LEARNING_RATE_TYPES": [],
  "PENALTY_TYPES": [],
  "DEFAULT_EPSILON": [],
  "MAX_INT": [],
  "_ValidationScoreCallback": {
    "__init__": [
      "self",
      "estimator",
      "X_val",
      "y_val",
      "sample_weight_val",
      "classes"
    ],
    "__call__": [
      "self",
      "coef",
      "intercept"
    ]
  },
  "BaseSGD": {
    "__init__": [
      "self",
      "loss"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_more_validate_params": [
      "self",
      "for_partial_fit"
    ],
    "_get_l1_ratio": [
      "self"
    ],
    "_get_loss_function": [
      "self",
      "loss"
    ],
    "_get_learning_rate_type": [
      "self",
      "learning_rate"
    ],
    "_get_penalty_type": [
      "self",
      "penalty"
    ],
    "_allocate_parameter_mem": [
      "self",
      "n_classes",
      "n_features",
      "input_dtype",
      "coef_init",
      "intercept_init",
      "one_class"
    ],
    "_make_validation_split": [
      "self",
      "y",
      "sample_mask"
    ],
    "_make_validation_score_cb": [
      "self",
      "validation_mask",
      "X",
      "y",
      "sample_weight",
      "classes"
    ]
  },
  "_prepare_fit_binary": [
    "est",
    "y",
    "i",
    "input_dtype",
    "label_encode"
  ],
  "fit_binary": [
    "est",
    "i",
    "X",
    "y",
    "alpha",
    "learning_rate",
    "max_iter",
    "pos_weight",
    "neg_weight",
    "sample_weight",
    "validation_mask",
    "random_state"
  ],
  "_get_plain_sgd_function": [
    "input_dtype"
  ],
  "BaseSGDClassifier": {
    "loss_functions": [],
    "__init__": [
      "self",
      "loss"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y",
      "alpha",
      "loss",
      "learning_rate",
      "max_iter",
      "classes",
      "sample_weight",
      "coef_init",
      "intercept_init"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "alpha",
      "loss",
      "learning_rate",
      "coef_init",
      "intercept_init",
      "sample_weight"
    ],
    "_fit_binary": [
      "self",
      "X",
      "y",
      "alpha",
      "sample_weight",
      "learning_rate",
      "max_iter"
    ],
    "_fit_multiclass": [
      "self",
      "X",
      "y",
      "alpha",
      "learning_rate",
      "sample_weight",
      "max_iter"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "intercept_init",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SGDClassifier": {
    "__init__": [
      "self",
      "loss"
    ],
    "_check_proba": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ]
  },
  "BaseSGDRegressor": {
    "loss_functions": [],
    "__init__": [
      "self",
      "loss"
    ],
    "_partial_fit": [
      "self",
      "X",
      "y",
      "alpha",
      "loss",
      "learning_rate",
      "max_iter",
      "sample_weight",
      "coef_init",
      "intercept_init"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "alpha",
      "loss",
      "learning_rate",
      "coef_init",
      "intercept_init",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "intercept_init",
      "sample_weight"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_fit_regressor": [
      "self",
      "X",
      "y",
      "alpha",
      "loss",
      "learning_rate",
      "sample_weight",
      "max_iter"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SGDRegressor": {
    "__init__": [
      "self",
      "loss"
    ]
  },
  "SGDOneClassSVM": {
    "loss_functions": [],
    "__init__": [
      "self",
      "nu",
      "fit_intercept",
      "max_iter",
      "tol",
      "shuffle",
      "verbose",
      "random_state",
      "learning_rate",
      "eta0",
      "power_t",
      "warm_start",
      "average"
    ],
    "_fit_one_class": [
      "self",
      "X",
      "alpha",
      "sample_weight",
      "learning_rate",
      "max_iter"
    ],
    "_partial_fit": [
      "self",
      "X",
      "alpha",
      "loss",
      "learning_rate",
      "max_iter",
      "sample_weight",
      "coef_init",
      "offset_init"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_fit": [
      "self",
      "X",
      "alpha",
      "loss",
      "learning_rate",
      "coef_init",
      "offset_init",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "offset_init",
      "sample_weight"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "PassiveAggressiveClassifier": {
    "__init__": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "intercept_init"
    ]
  },
  "PassiveAggressiveRegressor": {
    "__init__": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "intercept_init"
    ]
  },
  "NewtonSolver": {
    "__init__": [
      "self"
    ],
    "setup": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "update_gradient_hessian": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "inner_solve": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "fallback_lbfgs_solve": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "line_search": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "check_convergence": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "finalize": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "solve": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "NewtonCholeskySolver": {
    "setup": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "update_gradient_hessian": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "inner_solve": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "finalize": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "_GeneralizedLinearRegressor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_linear_predictor": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_get_loss": [
      "self"
    ]
  },
  "PoissonRegressor": {
    "__init__": [
      "self"
    ],
    "_get_loss": [
      "self"
    ]
  },
  "GammaRegressor": {
    "__init__": [
      "self"
    ],
    "_get_loss": [
      "self"
    ]
  },
  "TweedieRegressor": {
    "__init__": [
      "self"
    ],
    "_get_loss": [
      "self"
    ]
  },
  "SOLVERS": [],
  "BinomialRegressor": {
    "_get_loss": [
      "self"
    ]
  },
  "_special_minimize": [
    "fun",
    "grad",
    "x",
    "tol_NM",
    "tol"
  ],
  "glm_dataset": [
    "global_random_seed",
    "request"
  ],
  "test_glm_regression": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_glm_regression_hstacked_X": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_glm_regression_vstacked_X": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_glm_regression_unpenalized": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_glm_regression_unpenalized_hstacked_X": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_glm_regression_unpenalized_vstacked_X": [
    "solver",
    "fit_intercept",
    "glm_dataset"
  ],
  "test_sample_weights_validation": [],
  "test_glm_wrong_y_range": [
    "glm"
  ],
  "test_glm_identity_regression": [
    "fit_intercept"
  ],
  "test_glm_sample_weight_consistency": [
    "fit_intercept",
    "alpha",
    "GLMEstimator"
  ],
  "test_glm_log_regression": [
    "solver",
    "fit_intercept",
    "estimator"
  ],
  "test_warm_start": [
    "solver",
    "fit_intercept",
    "global_random_seed"
  ],
  "test_normal_ridge_comparison": [
    "n_samples",
    "n_features",
    "fit_intercept",
    "sample_weight",
    "request"
  ],
  "test_poisson_glmnet": [
    "solver"
  ],
  "test_convergence_warning": [
    "regression_data"
  ],
  "test_tweedie_link_argument": [
    "name",
    "link_class"
  ],
  "test_tweedie_link_auto": [
    "power",
    "expected_link_class"
  ],
  "test_tweedie_score": [
    "regression_data",
    "power",
    "link"
  ],
  "test_tags": [
    "estimator",
    "value"
  ],
  "test_linalg_warning_with_newton_solver": [
    "global_random_seed"
  ],
  "test_newton_solver_verbosity": [
    "capsys",
    "verbose"
  ],
  "make_regression_with_outliers": [
    "n_samples",
    "n_features"
  ],
  "test_huber_equals_lr_for_high_epsilon": [],
  "test_huber_max_iter": [],
  "test_huber_gradient": [],
  "test_huber_sample_weights": [
    "csr_container"
  ],
  "test_huber_sparse": [
    "csr_container"
  ],
  "test_huber_scaling_invariant": [],
  "test_huber_and_sgd_same_results": [],
  "test_huber_warm_start": [],
  "test_huber_better_r2_score": [],
  "test_huber_bool": [],
  "random_state": [],
  "indices": [],
  "MyPerceptron": {
    "__init__": [
      "self",
      "n_iter"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "project": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_perceptron_accuracy": [
    "container"
  ],
  "test_perceptron_correctness": [],
  "test_undefined_methods": [],
  "test_perceptron_l1_ratio": [],
  "test_set_order_dense": [
    "order",
    "input_order"
  ],
  "test_set_order_sparse": [
    "order",
    "input_order",
    "coo_container"
  ],
  "test_cython_solver_equivalence": [],
  "test_lasso_zero": [],
  "test_enet_nonfinite_params": [],
  "test_lasso_toy": [],
  "test_enet_toy": [],
  "test_lasso_dual_gap": [],
  "build_dataset": [
    "n_samples",
    "n_features",
    "n_informative_features",
    "n_targets"
  ],
  "test_lasso_cv": [],
  "test_lasso_cv_with_some_model_selection": [],
  "test_lasso_cv_positive_constraint": [],
  "test_lassocv_alphas_validation": [
    "alphas",
    "err_type",
    "err_msg"
  ],
  "test_lasso_path_return_models_vs_new_return_gives_same_coefficients": [],
  "test_enet_path": [],
  "test_lasso_alpha_warning": [],
  "test_lasso_positive_constraint": [],
  "test_enet_positive_constraint": [],
  "test_enet_cv_positive_constraint": [],
  "test_uniform_targets": [],
  "test_multi_task_lasso_vs_skglm": [],
  "test_multi_task_lasso_and_enet": [],
  "test_lasso_readonly_data": [],
  "test_multi_task_lasso_readonly_data": [],
  "test_enet_multitarget": [],
  "test_multioutput_enetcv_error": [],
  "test_multitask_enet_and_lasso_cv": [],
  "test_1d_multioutput_enet_and_multitask_enet_cv": [],
  "test_1d_multioutput_lasso_and_multitask_lasso_cv": [],
  "test_sparse_input_dtype_enet_and_lassocv": [
    "csr_container"
  ],
  "test_elasticnet_precompute_incorrect_gram": [],
  "test_elasticnet_precompute_gram_weighted_samples": [],
  "test_elasticnet_precompute_gram": [],
  "test_warm_start_convergence": [
    "sparse_X"
  ],
  "test_warm_start_convergence_with_regularizer_decrement": [],
  "test_random_descent": [
    "csr_container"
  ],
  "test_enet_path_positive": [],
  "test_sparse_dense_descent_paths": [
    "csr_container"
  ],
  "test_path_unknown_parameter": [
    "path_func"
  ],
  "test_check_input_false": [],
  "test_enet_copy_X_True": [
    "check_input"
  ],
  "test_enet_copy_X_False_check_input_False": [],
  "test_overrided_gram_matrix": [],
  "test_lasso_non_float_y": [
    "model"
  ],
  "test_enet_float_precision": [],
  "test_enet_l1_ratio": [],
  "test_coef_shape_not_zero": [],
  "test_warm_start_multitask_lasso": [],
  "test_enet_coordinate_descent_raises_convergence": [
    "klass",
    "n_classes",
    "kwargs"
  ],
  "test_convergence_warnings": [],
  "test_sparse_input_convergence_warning": [
    "csr_container"
  ],
  "test_lassoCV_does_not_set_precompute": [
    "monkeypatch",
    "precompute",
    "inner_precompute"
  ],
  "test_multi_task_lasso_cv_dtype": [],
  "test_enet_sample_weight_consistency": [
    "fit_intercept",
    "alpha",
    "precompute",
    "sparse_container",
    "global_random_seed"
  ],
  "test_enet_cv_sample_weight_correctness": [
    "fit_intercept",
    "sparse_container",
    "global_random_seed"
  ],
  "test_enet_cv_grid_search": [
    "sample_weight"
  ],
  "test_enet_cv_sample_weight_consistency": [
    "fit_intercept",
    "l1_ratio",
    "precompute",
    "sparse_container"
  ],
  "test_enet_alpha_max": [
    "X_is_sparse",
    "fit_intercept",
    "sample_weight"
  ],
  "test_linear_models_cv_fit_with_loky": [
    "estimator"
  ],
  "test_enet_sample_weight_does_not_overwrite_sample_weight": [
    "check_input"
  ],
  "test_enet_ridge_consistency": [
    "ridge_alpha"
  ],
  "test_sample_weight_invariance": [
    "estimator"
  ],
  "test_cv_estimators_reject_params_with_no_routing_enabled": [
    "EstimatorCV"
  ],
  "test_multitask_cv_estimators_with_sample_weight": [
    "MultiTaskEstimatorCV"
  ],
  "test_linear_model_cv_deprecated_n_alphas": [
    "Estimator"
  ],
  "test_linear_model_cv_deprecated_alphas_none": [
    "Estimator"
  ],
  "test_linear_model_cv_alphas_n_alphas_unset": [
    "Estimator"
  ],
  "test_linear_model_cv_alphas": [
    "Estimator"
  ],
  "no_stdout_stderr": [],
  "gen_toy_problem_1d": [
    "intercept"
  ],
  "gen_toy_problem_2d": [],
  "gen_toy_problem_4d": [],
  "test_modweiszfeld_step_1d": [],
  "test_modweiszfeld_step_2d": [],
  "test_spatial_median_1d": [],
  "test_spatial_median_2d": [],
  "test_theil_sen_1d": [],
  "test_theil_sen_1d_no_intercept": [],
  "test_theil_sen_2d": [],
  "test_calc_breakdown_point": [],
  "test_checksubparams_invalid_input": [
    "param",
    "ExceptionCls",
    "match"
  ],
  "test_checksubparams_n_subsamples_if_less_samples_than_features": [],
  "test_subpopulation": [],
  "test_subsamples": [],
  "test_verbosity": [],
  "test_theil_sen_parallel": [],
  "test_less_samples_than_features": [],
  "X_y_data": [],
  "test_incompatible_solver_for_sparse_input": [
    "X_y_data",
    "solver",
    "csc_container"
  ],
  "test_quantile_toy_example": [
    "quantile",
    "alpha",
    "intercept",
    "coef"
  ],
  "test_quantile_equals_huber_for_low_epsilon": [
    "fit_intercept"
  ],
  "test_quantile_estimates_calibration": [
    "q"
  ],
  "test_quantile_sample_weight": [],
  "test_asymmetric_error": [
    "quantile"
  ],
  "test_equivariance": [
    "quantile"
  ],
  "test_linprog_failure": [],
  "test_sparse_input": [
    "sparse_container",
    "solver",
    "fit_intercept",
    "global_random_seed"
  ],
  "test_error_interior_point_future": [
    "X_y_data",
    "monkeypatch"
  ],
  "SPARSE_SOLVERS_WITH_INTERCEPT": [],
  "SPARSE_SOLVERS_WITHOUT_INTERCEPT": [],
  "ind": [],
  "_accuracy_callable": [
    "y_test",
    "y_pred"
  ],
  "_mean_squared_error_callable": [
    "y_test",
    "y_pred"
  ],
  "ols_ridge_dataset": [
    "global_random_seed",
    "request"
  ],
  "test_ridge_regression": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_hstacked_X": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_vstacked_X": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_unpenalized": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_unpenalized_hstacked_X": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_unpenalized_vstacked_X": [
    "solver",
    "fit_intercept",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_ridge_regression_sample_weights": [
    "solver",
    "fit_intercept",
    "sparse_container",
    "alpha",
    "ols_ridge_dataset",
    "global_random_seed"
  ],
  "test_primal_dual_relationship": [],
  "test_ridge_regression_convergence_fail": [],
  "test_ridge_shapes_type": [],
  "test_ridge_intercept": [],
  "test_ridge_vs_lstsq": [],
  "test_ridge_individual_penalties": [],
  "test_X_CenterStackOp": [
    "n_col",
    "csr_container"
  ],
  "test_compute_gram": [
    "shape",
    "uniform_weights",
    "csr_container"
  ],
  "test_compute_covariance": [
    "shape",
    "uniform_weights",
    "csr_container"
  ],
  "_make_sparse_offset_regression": [
    "n_samples",
    "n_features",
    "proportion_nonzero",
    "n_informative",
    "n_targets",
    "bias",
    "X_offset",
    "noise",
    "shuffle",
    "coef",
    "positive",
    "random_state"
  ],
  "test_solver_consistency": [
    "solver",
    "proportion_nonzero",
    "n_samples",
    "dtype",
    "sparse_container",
    "global_random_seed"
  ],
  "test_ridge_gcv_vs_ridge_loo_cv": [
    "gcv_mode",
    "X_container",
    "X_shape",
    "y_shape",
    "fit_intercept",
    "noise"
  ],
  "test_ridge_loo_cv_asym_scoring": [],
  "test_ridge_gcv_sample_weights": [
    "gcv_mode",
    "X_container",
    "fit_intercept",
    "n_features",
    "y_shape",
    "noise"
  ],
  "test_check_gcv_mode_choice": [
    "sparse_container",
    "mode",
    "mode_n_greater_than_p",
    "mode_p_greater_than_n"
  ],
  "_test_ridge_loo": [
    "sparse_container"
  ],
  "_test_ridge_cv": [
    "sparse_container"
  ],
  "test_ridge_gcv_cv_results_not_stored": [
    "ridge",
    "make_dataset"
  ],
  "test_ridge_best_score": [
    "ridge",
    "make_dataset",
    "cv"
  ],
  "test_ridge_cv_individual_penalties": [],
  "_test_ridge_diabetes": [
    "sparse_container"
  ],
  "_test_multi_ridge_diabetes": [
    "sparse_container"
  ],
  "_test_ridge_classifiers": [
    "sparse_container"
  ],
  "test_ridge_classifier_with_scoring": [
    "sparse_container",
    "scoring",
    "cv"
  ],
  "test_ridge_regression_custom_scoring": [
    "sparse_container",
    "cv"
  ],
  "_test_tolerance": [
    "sparse_container"
  ],
  "check_array_api_attributes": [
    "name",
    "estimator",
    "array_namespace",
    "device",
    "dtype_name",
    "rtol"
  ],
  "test_ridge_array_api_compliance": [
    "estimator",
    "check",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_ridge_classifier_multilabel_array_api": [
    "estimator",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_array_api_error_and_warnings_for_solver_parameter": [
    "array_namespace"
  ],
  "test_array_api_numpy_namespace_no_warning": [
    "array_namespace"
  ],
  "test_dense_sparse": [
    "test_func",
    "csr_container"
  ],
  "test_class_weights": [],
  "test_class_weight_vs_sample_weight": [
    "reg"
  ],
  "test_class_weights_cv": [],
  "test_ridgecv_store_cv_results": [
    "scoring"
  ],
  "test_ridge_classifier_cv_store_cv_results": [
    "scoring"
  ],
  "test_ridgecv_alphas_conversion": [
    "Estimator"
  ],
  "test_ridgecv_alphas_zero": [
    "cv",
    "Estimator"
  ],
  "test_ridgecv_sample_weight": [],
  "test_raises_value_error_if_sample_weights_greater_than_1d": [],
  "test_sparse_design_with_sample_weights": [
    "n_samples",
    "n_features",
    "sparse_container"
  ],
  "test_ridgecv_int_alphas": [],
  "test_ridgecv_alphas_validation": [
    "Estimator",
    "params",
    "err_type",
    "err_msg"
  ],
  "test_ridgecv_alphas_scalar": [
    "Estimator"
  ],
  "test_sparse_cg_max_iter": [],
  "test_n_iter": [],
  "test_ridge_fit_intercept_sparse": [
    "solver",
    "with_sample_weight",
    "global_random_seed",
    "csr_container"
  ],
  "test_ridge_fit_intercept_sparse_error": [
    "solver",
    "csr_container"
  ],
  "test_ridge_fit_intercept_sparse_sag": [
    "with_sample_weight",
    "global_random_seed",
    "csr_container"
  ],
  "test_ridge_regression_check_arguments_validity": [
    "return_intercept",
    "sample_weight",
    "container",
    "solver"
  ],
  "test_dtype_match": [
    "solver"
  ],
  "test_dtype_match_cholesky": [],
  "test_ridge_regression_dtype_stability": [
    "solver",
    "seed"
  ],
  "test_ridge_sag_with_X_fortran": [],
  "test_ridgeclassifier_multilabel": [
    "Classifier",
    "params"
  ],
  "test_ridge_positive_regression_test": [
    "solver",
    "fit_intercept",
    "alpha"
  ],
  "test_ridge_ground_truth_positive_test": [
    "fit_intercept",
    "alpha"
  ],
  "test_ridge_positive_error_test": [
    "solver"
  ],
  "test_positive_ridge_loss": [
    "alpha"
  ],
  "test_lbfgs_solver_consistency": [
    "alpha"
  ],
  "test_lbfgs_solver_error": [],
  "test_ridge_sample_weight_consistency": [
    "fit_intercept",
    "sparse_container",
    "data",
    "solver",
    "global_random_seed"
  ],
  "test_ridge_cv_results_predictions": [
    "with_sample_weight",
    "fit_intercept",
    "n_targets"
  ],
  "test_ridge_cv_multioutput_sample_weight": [
    "global_random_seed"
  ],
  "test_ridge_cv_custom_multioutput_scorer": [],
  "test_metadata_routing_with_default_scoring": [
    "metaestimator"
  ],
  "test_set_score_request_with_default_scoring": [
    "metaestimator",
    "make_dataset"
  ],
  "test_balance_property": [
    "model",
    "with_sample_weight",
    "global_random_seed"
  ],
  "test_linear_model_regressor_coef_shape": [
    "Regressor",
    "ndim"
  ],
  "test_linear_model_classifier_coef_shape": [
    "Classifier",
    "params",
    "n_classes"
  ],
  "test_model_pipeline_same_dense_and_sparse": [
    "LinearModel",
    "params",
    "csr_container"
  ],
  "G": [],
  "Xy": [],
  "n_samples": [],
  "test_simple": [],
  "test_simple_precomputed": [],
  "_assert_same_lars_path_result": [
    "output1",
    "output2"
  ],
  "test_lars_path_gram_equivalent": [
    "method",
    "return_path"
  ],
  "test_x_none_gram_none_raises_value_error": [],
  "test_all_precomputed": [],
  "test_lars_lstsq": [],
  "test_lasso_gives_lstsq_solution": [],
  "test_collinearity": [],
  "test_no_path": [],
  "test_no_path_precomputed": [],
  "test_no_path_all_precomputed": [],
  "test_lars_precompute": [
    "classifier"
  ],
  "test_singular_matrix": [],
  "test_rank_deficient_design": [],
  "test_lasso_lars_vs_lasso_cd": [],
  "test_lasso_lars_vs_lasso_cd_early_stopping": [],
  "test_lasso_lars_path_length": [],
  "test_lasso_lars_vs_lasso_cd_ill_conditioned": [],
  "test_lasso_lars_vs_lasso_cd_ill_conditioned2": [],
  "test_lars_add_features": [],
  "test_lars_n_nonzero_coefs": [
    "verbose"
  ],
  "test_multitarget": [],
  "test_lars_cv": [],
  "test_lars_cv_max_iter": [
    "recwarn"
  ],
  "test_lasso_lars_ic": [],
  "test_lars_path_readonly_data": [],
  "test_lars_path_positive_constraint": [],
  "default_parameter": [],
  "estimator_parameter_map": [],
  "test_estimatorclasses_positive_constraint": [],
  "test_lasso_lars_vs_lasso_cd_positive": [],
  "test_lasso_lars_vs_R_implementation": [],
  "test_lasso_lars_copyX_behaviour": [
    "copy_X"
  ],
  "test_lasso_lars_fit_copyX_behaviour": [
    "copy_X"
  ],
  "test_lars_with_jitter": [
    "est"
  ],
  "test_X_none_gram_not_none": [],
  "test_copy_X_with_auto_gram": [],
  "test_lars_dtype_match": [
    "LARS",
    "has_coef_path",
    "args",
    "dtype"
  ],
  "test_lars_numeric_consistency": [
    "LARS",
    "has_coef_path",
    "args"
  ],
  "test_lassolarsic_alpha_selection": [
    "criterion"
  ],
  "test_lassolarsic_noise_variance": [
    "fit_intercept"
  ],
  "pytestmark": [],
  "Y1": [],
  "check_predictions": [
    "clf",
    "X",
    "y"
  ],
  "test_predict_2_classes": [
    "csr_container"
  ],
  "test_logistic_cv_mock_scorer": [],
  "test_predict_3_classes": [
    "csr_container"
  ],
  "test_predict_iris": [
    "clf",
    "global_random_seed"
  ],
  "test_logistic_glmnet": [
    "solver"
  ],
  "test_check_solver_option": [
    "LR"
  ],
  "test_elasticnet_l1_ratio_err_helpful": [
    "LR",
    "arg"
  ],
  "test_sparsify": [
    "coo_container"
  ],
  "test_inconsistent_input": [],
  "test_write_parameters": [],
  "test_nan": [],
  "test_consistency_path": [
    "global_random_seed"
  ],
  "test_logistic_regression_path_convergence_fail": [],
  "test_liblinear_dual_random_state": [
    "global_random_seed"
  ],
  "test_logistic_cv": [
    "global_random_seed",
    "use_legacy_attributes"
  ],
  "test_logistic_cv_multinomial_score": [
    "global_random_seed",
    "scoring",
    "multiclass_agg_list"
  ],
  "test_multinomial_logistic_regression_string_inputs": [],
  "test_logistic_cv_sparse": [
    "global_random_seed",
    "csr_container"
  ],
  "test_multinomial_cv_iris": [
    "use_legacy_attributes"
  ],
  "test_logistic_regression_solvers": [
    "global_random_seed"
  ],
  "test_logistic_regression_solvers_multiclass": [
    "fit_intercept"
  ],
  "test_logistic_regression_solvers_multiclass_unpenalized": [
    "fit_intercept",
    "global_random_seed"
  ],
  "test_logistic_regressioncv_class_weights": [
    "weight",
    "class_weight",
    "global_random_seed"
  ],
  "test_logistic_regression_sample_weights": [
    "problem",
    "solver",
    "global_random_seed"
  ],
  "test_logistic_regression_solver_class_weights": [
    "solver",
    "global_random_seed"
  ],
  "test_sample_and_class_weight_equivalence_liblinear": [
    "global_random_seed"
  ],
  "_compute_class_weight_dictionary": [
    "y"
  ],
  "test_logistic_regression_class_weights": [
    "global_random_seed",
    "csr_container"
  ],
  "test_logistic_regression_multinomial": [
    "global_random_seed"
  ],
  "test_liblinear_decision_function_zero": [
    "global_random_seed"
  ],
  "test_liblinear_logregcv_sparse": [
    "csr_container",
    "global_random_seed"
  ],
  "test_saga_sparse": [
    "csr_container",
    "global_random_seed"
  ],
  "test_logreg_intercept_scaling_zero": [],
  "test_logreg_l1": [
    "global_random_seed"
  ],
  "test_logreg_l1_sparse_data": [
    "global_random_seed",
    "csr_container"
  ],
  "test_logistic_regression_cv_refit": [
    "global_random_seed",
    "l1_ratio"
  ],
  "test_logreg_predict_proba_multinomial": [
    "global_random_seed"
  ],
  "test_max_iter": [
    "global_random_seed",
    "max_iter",
    "solver",
    "message"
  ],
  "test_warm_start_newton_solver": [
    "global_random_seed",
    "solver",
    "fit_intercept",
    "C"
  ],
  "test_saga_vs_liblinear": [
    "global_random_seed",
    "csr_container",
    "l1_ratio"
  ],
  "test_warm_start_converge_LR": [
    "global_random_seed"
  ],
  "test_elastic_net_coeffs": [
    "global_random_seed"
  ],
  "test_elastic_net_l1_l2_equivalence": [
    "global_random_seed",
    "C",
    "penalty",
    "l1_ratio"
  ],
  "test_elastic_net_vs_l1_l2": [
    "C"
  ],
  "test_LogisticRegression_elastic_net_objective": [
    "C",
    "l1_ratio"
  ],
  "test_LogisticRegressionCV_GridSearchCV_elastic_net": [
    "n_classes"
  ],
  "test_LogisticRegressionCV_no_refit": [
    "l1_ratios",
    "n_classes"
  ],
  "test_LogisticRegressionCV_elasticnet_attribute_shapes": [
    "n_classes"
  ],
  "test_LogisticRegressionCV_on_folds": [],
  "test_l1_ratio_non_elasticnet": [],
  "test_elastic_net_versus_sgd": [
    "global_random_seed",
    "C",
    "l1_ratio"
  ],
  "test_logistic_regression_path_coefs_multinomial": [],
  "test_logistic_regression_path_init_coefs": [],
  "test_penalty_none": [
    "global_random_seed",
    "solver"
  ],
  "test_logisticregression_liblinear_sample_weight": [
    "global_random_seed",
    "params"
  ],
  "test_scores_attribute_layout_elasticnet": [],
  "test_multinomial_identifiability_on_iris": [
    "global_random_seed",
    "solver",
    "fit_intercept"
  ],
  "test_sample_weight_not_modified": [
    "global_random_seed",
    "class_weight"
  ],
  "test_large_sparse_matrix": [
    "solver",
    "global_random_seed",
    "csr_container"
  ],
  "test_liblinear_with_large_values": [],
  "test_single_feature_newton_cg": [],
  "test_liblinear_not_stuck": [
    "global_random_seed"
  ],
  "test_lr_cv_scores_differ_when_sample_weight_is_requested": [
    "global_random_seed"
  ],
  "test_lr_cv_scores_without_enabling_metadata_routing": [],
  "test_zero_max_iter": [
    "solver"
  ],
  "test_passing_params_without_enabling_metadata_routing": [],
  "test_newton_cholesky_fallback_to_lbfgs": [
    "global_random_seed"
  ],
  "test_liblinear_multiclass_raises": [
    "Estimator"
  ],
  "test_penalty_deprecated": [
    "est"
  ],
  "test_logisticregressioncv_warns_with_use_legacy_attributes": [],
  "test_l1_ratio_None_deprecated": [],
  "test_logisticregression_warns_with_n_jobs": [],
  "test_lr_penalty_l1ratio_incompatible": [
    "penalty",
    "l1_ratio"
  ],
  "test_sparse_coef": [],
  "test_enet_toy_list_input": [
    "with_sample_weight",
    "csc_container"
  ],
  "test_enet_toy_explicit_sparse_input": [
    "lil_container"
  ],
  "make_sparse_data": [
    "sparse_container",
    "n_samples",
    "n_features",
    "n_informative",
    "seed",
    "positive",
    "n_targets"
  ],
  "test_sparse_enet_not_as_toy_dataset": [
    "csc_container",
    "alpha",
    "fit_intercept",
    "positive"
  ],
  "test_sparse_lasso_not_as_toy_dataset": [
    "csc_container"
  ],
  "test_path_parameters": [
    "csc_container"
  ],
  "test_sparse_dense_equality": [
    "Model",
    "fit_intercept",
    "n_samples",
    "n_features",
    "with_sample_weight",
    "csc_container"
  ],
  "test_same_output_sparse_dense_lasso_and_enet_cv": [
    "csc_container"
  ],
  "test_same_multiple_output_sparse_dense": [
    "coo_container"
  ],
  "test_sparse_enet_coordinate_descent": [
    "csc_container"
  ],
  "test_sparse_read_only_buffer": [
    "copy_X"
  ],
  "log_dloss": [
    "p",
    "y"
  ],
  "log_loss": [
    "p",
    "y"
  ],
  "squared_dloss": [
    "p",
    "y"
  ],
  "squared_loss": [
    "p",
    "y"
  ],
  "get_pobj": [
    "w",
    "alpha",
    "myX",
    "myy",
    "loss"
  ],
  "sag": [
    "X",
    "y",
    "step_size",
    "alpha",
    "n_iter",
    "dloss",
    "sparse",
    "sample_weight",
    "fit_intercept",
    "saga"
  ],
  "sag_sparse": [
    "X",
    "y",
    "step_size",
    "alpha",
    "n_iter",
    "dloss",
    "sample_weight",
    "sparse",
    "fit_intercept",
    "saga",
    "random_state"
  ],
  "get_step_size": [
    "X",
    "alpha",
    "fit_intercept",
    "classification"
  ],
  "test_classifier_matching": [],
  "test_regressor_matching": [],
  "test_sag_pobj_matches_logistic_regression": [
    "csr_container"
  ],
  "test_sag_pobj_matches_ridge_regression": [
    "csr_container"
  ],
  "test_sag_regressor_computed_correctly": [
    "csr_container"
  ],
  "test_get_auto_step_size": [],
  "test_sag_regressor": [
    "seed",
    "csr_container"
  ],
  "test_sag_classifier_computed_correctly": [
    "csr_container"
  ],
  "test_sag_multiclass_computed_correctly": [
    "csr_container"
  ],
  "test_classifier_results": [
    "csr_container"
  ],
  "test_binary_classifier_class_weight": [
    "csr_container"
  ],
  "test_classifier_single_class": [],
  "test_step_size_alpha_error": [],
  "test_sag_classifier_raises_error": [
    "solver"
  ],
  "test_correct_shapes": [],
  "test_correct_shapes_gram": [],
  "test_n_nonzero_coefs": [],
  "test_tol": [],
  "test_with_without_gram": [],
  "test_with_without_gram_tol": [],
  "test_unreachable_accuracy": [],
  "test_perfect_signal_recovery": [],
  "test_orthogonal_mp_gram_readonly": [],
  "test_estimator": [],
  "test_estimator_n_nonzero_coefs": [],
  "test_identical_regressors": [],
  "test_swapped_regressors": [],
  "test_no_atoms": [],
  "test_omp_path": [],
  "test_omp_return_path_prop_with_gram": [],
  "test_omp_cv": [],
  "test_omp_reaches_least_squares": [],
  "test_omp_gram_dtype_match": [
    "data_type"
  ],
  "test_omp_gram_numerical_consistency": [],
  "LOSSES": [],
  "random_X_y_coef": [
    "linear_model_loss",
    "n_samples",
    "n_features",
    "coef_bound",
    "seed"
  ],
  "test_init_zero_coef": [
    "base_loss",
    "fit_intercept",
    "n_features",
    "dtype",
    "global_random_seed"
  ],
  "test_loss_grad_hess_are_the_same": [
    "base_loss",
    "fit_intercept",
    "sample_weight",
    "l2_reg_strength",
    "csr_container",
    "global_random_seed"
  ],
  "test_loss_gradients_hessp_intercept": [
    "base_loss",
    "sample_weight",
    "l2_reg_strength",
    "X_container",
    "global_random_seed"
  ],
  "test_gradients_hessians_numerically": [
    "base_loss",
    "fit_intercept",
    "sample_weight",
    "l2_reg_strength",
    "global_random_seed"
  ],
  "test_multinomial_coef_shape": [
    "fit_intercept",
    "global_random_seed"
  ],
  "test_multinomial_hessian_3_classes": [
    "sample_weight",
    "global_random_seed"
  ],
  "test_linear_loss_gradient_hessian_raises_wrong_out_parameters": [],
  "MyPassiveAggressive": {
    "__init__": [
      "self",
      "C",
      "epsilon",
      "loss",
      "fit_intercept",
      "n_iter",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "project": [
      "self",
      "X"
    ]
  },
  "test_classifier_accuracy": [
    "csr_container",
    "fit_intercept",
    "average"
  ],
  "test_classifier_partial_fit": [
    "csr_container",
    "average"
  ],
  "test_classifier_refit": [],
  "test_classifier_correctness": [
    "loss",
    "csr_container"
  ],
  "test_classifier_undefined_methods": [
    "response_method"
  ],
  "test_partial_fit_weight_class_balanced": [],
  "test_equal_class_weight": [],
  "test_wrong_class_weight_label": [],
  "test_regressor_mse": [
    "csr_container",
    "fit_intercept",
    "average"
  ],
  "test_regressor_partial_fit": [
    "csr_container",
    "average"
  ],
  "test_regressor_correctness": [
    "loss",
    "csr_container"
  ],
  "test_regressor_undefined_methods": [],
  "test_class_deprecation": [
    "Estimator"
  ],
  "test_passive_aggressive_classifier_vs_sgd": [
    "loss",
    "lr"
  ],
  "test_passive_aggressive_regressor_vs_sgd": [
    "loss",
    "lr"
  ],
  "data": [],
  "outliers": [],
  "test_ransac_inliers_outliers": [],
  "test_ransac_is_data_valid": [],
  "test_ransac_is_model_valid": [],
  "test_ransac_max_trials": [],
  "test_ransac_stop_n_inliers": [],
  "test_ransac_stop_score": [],
  "test_ransac_score": [],
  "test_ransac_predict": [],
  "test_ransac_no_valid_data": [],
  "test_ransac_no_valid_model": [],
  "test_ransac_exceed_max_skips": [],
  "test_ransac_warn_exceed_max_skips": [],
  "test_ransac_sparse": [
    "sparse_container"
  ],
  "test_ransac_none_estimator": [],
  "test_ransac_min_n_samples": [],
  "test_ransac_multi_dimensional_targets": [],
  "test_ransac_residual_loss": [],
  "test_ransac_default_residual_threshold": [],
  "test_ransac_dynamic_max_trials": [],
  "test_ransac_fit_sample_weight": [],
  "test_ransac_final_model_fit_sample_weight": [],
  "test_perfect_horizontal_line": [],
  "_update_kwargs": [
    "kwargs"
  ],
  "_SparseSGDClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ]
  },
  "_SparseSGDRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "_SparseSGDOneClassSVM": {
    "fit": [
      "self",
      "X"
    ],
    "partial_fit": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "SparseSGDClassifier": [],
  "SparseSGDRegressor": [],
  "SparseSGDOneClassSVM": [],
  "X3": [],
  "Y3": [],
  "X4": [],
  "Y4": [],
  "X5": [],
  "Y5": [],
  "true_result5": [],
  "asgd": [
    "klass",
    "X",
    "y",
    "eta",
    "alpha",
    "weight_init",
    "intercept_init"
  ],
  "_test_warm_start": [
    "klass",
    "X",
    "Y",
    "lr"
  ],
  "test_input_format": [
    "klass"
  ],
  "test_learning_rate_PA_raises": [
    "lr",
    "est",
    "loss"
  ],
  "test_clone": [
    "klass"
  ],
  "test_plain_has_no_average_attr": [
    "klass"
  ],
  "test_late_onset_averaging_not_reached": [
    "klass"
  ],
  "test_late_onset_averaging_reached": [
    "klass"
  ],
  "test_early_stopping": [
    "klass"
  ],
  "test_adaptive_longer_than_constant": [
    "klass"
  ],
  "test_validation_set_not_used_for_training": [
    "klass"
  ],
  "test_n_iter_no_change": [
    "klass"
  ],
  "test_not_enough_sample_for_early_stopping": [
    "klass"
  ],
  "test_sgd_l1_ratio_not_used": [
    "Estimator",
    "l1_ratio"
  ],
  "test_sgd_failing_penalty_validation": [
    "Estimator"
  ],
  "test_power_t_limits": [
    "klass"
  ],
  "test_sgd_clf": [
    "klass"
  ],
  "test_provide_coef": [
    "klass"
  ],
  "test_set_intercept_offset": [
    "klass",
    "fit_params"
  ],
  "test_sgd_early_stopping_with_partial_fit": [
    "klass"
  ],
  "test_set_intercept_offset_binary": [
    "klass",
    "fit_params"
  ],
  "test_average_binary_computed_correctly": [
    "klass"
  ],
  "test_set_intercept_to_intercept": [
    "klass"
  ],
  "test_sgd_at_least_two_labels": [
    "klass"
  ],
  "test_sgd_multiclass": [
    "klass"
  ],
  "test_sgd_multiclass_average": [
    "klass"
  ],
  "test_sgd_multiclass_with_init_coef": [
    "klass"
  ],
  "test_sgd_multiclass_njobs": [
    "klass"
  ],
  "test_set_coef_multiclass": [
    "klass"
  ],
  "test_sgd_predict_proba_method_access": [
    "klass"
  ],
  "test_sgd_proba": [
    "klass"
  ],
  "test_sgd_l1": [
    "klass"
  ],
  "test_weights_multiplied": [
    "klass"
  ],
  "test_balanced_weight": [
    "klass"
  ],
  "test_wrong_sample_weights": [
    "klass"
  ],
  "test_partial_fit_exception": [
    "klass"
  ],
  "test_partial_fit_binary": [
    "klass"
  ],
  "test_partial_fit_multiclass": [
    "klass"
  ],
  "test_partial_fit_multiclass_average": [
    "klass"
  ],
  "test_fit_then_partial_fit": [
    "klass"
  ],
  "test_partial_fit_equal_fit_classif": [
    "klass",
    "lr"
  ],
  "test_regression_losses": [
    "klass"
  ],
  "test_warm_start_multiclass": [
    "klass"
  ],
  "test_multiple_fit": [
    "klass"
  ],
  "test_sgd_reg": [
    "klass"
  ],
  "test_sgd_averaged_computed_correctly": [
    "klass"
  ],
  "test_sgd_averaged_partial_fit": [
    "klass"
  ],
  "test_average_sparse": [
    "klass"
  ],
  "test_sgd_least_squares_fit": [
    "klass"
  ],
  "test_sgd_epsilon_insensitive": [
    "klass"
  ],
  "test_sgd_huber_fit": [
    "klass"
  ],
  "test_elasticnet_convergence": [
    "klass"
  ],
  "test_partial_fit": [
    "klass"
  ],
  "test_partial_fit_equal_fit": [
    "klass",
    "lr"
  ],
  "test_loss_function_epsilon": [
    "klass"
  ],
  "asgd_oneclass": [
    "klass",
    "X",
    "eta",
    "nu",
    "coef_init",
    "offset_init"
  ],
  "_test_warm_start_oneclass": [
    "klass",
    "X",
    "lr"
  ],
  "test_warm_start_oneclass": [
    "klass",
    "lr"
  ],
  "test_clone_oneclass": [
    "klass"
  ],
  "test_partial_fit_oneclass": [
    "klass"
  ],
  "test_partial_fit_equal_fit_oneclass": [
    "klass",
    "lr"
  ],
  "test_late_onset_averaging_reached_oneclass": [
    "klass"
  ],
  "test_sgd_averaged_computed_correctly_oneclass": [
    "klass"
  ],
  "test_sgd_averaged_partial_fit_oneclass": [
    "klass"
  ],
  "test_average_sparse_oneclass": [
    "klass"
  ],
  "test_sgd_oneclass": [],
  "test_ocsvm_vs_sgdocsvm": [],
  "test_sgd_oneclass_convergence": [],
  "test_sgd_oneclass_vs_linear_oneclass": [],
  "test_l1_ratio": [],
  "test_underflow_or_overlow": [],
  "test_numerical_stability_large_gradient": [],
  "test_large_regularization": [
    "penalty"
  ],
  "test_tol_parameter": [],
  "_test_loss_common": [
    "loss_function",
    "cases"
  ],
  "test_loss_hinge": [],
  "test_gradient_squared_hinge": [],
  "test_loss_modified_huber": [],
  "test_loss_epsilon_insensitive": [],
  "test_loss_squared_epsilon_insensitive": [],
  "test_multi_thread_multi_class_and_early_stopping": [],
  "test_multi_core_gridsearch_and_early_stopping": [],
  "test_SGDClassifier_fit_for_all_backends": [
    "backend"
  ],
  "test_sgd_random_state": [
    "Estimator",
    "global_random_seed"
  ],
  "test_validation_mask_correctly_subsets": [
    "monkeypatch"
  ],
  "test_sgd_error_on_zero_validation_weight": [],
  "test_sgd_verbose": [
    "Estimator"
  ],
  "test_sgd_dtype_match": [
    "SGDEstimator",
    "data_type"
  ],
  "test_sgd_numerical_consistency": [
    "SGDEstimator"
  ],
  "test_sgd_one_class_svm_estimator_type": [],
  "test_bayesian_ridge_scores": [],
  "test_bayesian_ridge_score_values": [],
  "test_bayesian_ridge_parameter": [],
  "test_bayesian_covariance_matrix": [
    "n_samples",
    "n_features",
    "global_random_seed"
  ],
  "test_bayesian_sample_weights": [],
  "test_toy_bayesian_ridge_object": [],
  "test_bayesian_initial_params": [],
  "test_prediction_bayesian_ridge_ard_with_constant_input": [],
  "test_std_bayesian_ridge_ard_with_constant_input": [],
  "test_update_of_sigma_in_ard": [],
  "test_toy_ard_object": [],
  "test_ard_accuracy_on_easy_problem": [
    "global_random_seed",
    "n_samples",
    "n_features"
  ],
  "test_return_std": [
    "constructor_name"
  ],
  "test_update_sigma": [
    "global_random_seed"
  ],
  "test_dtype_correctness": [
    "Estimator"
  ],
  "rtol": [],
  "test_linear_regression": [],
  "test_linear_regression_sample_weights": [
    "sparse_container",
    "fit_intercept",
    "global_random_seed"
  ],
  "test_raises_value_error_if_positive_and_sparse": [],
  "test_fit_intercept": [],
  "test_linear_regression_sparse": [
    "global_random_seed"
  ],
  "test_linear_regression_sparse_equal_dense": [
    "fit_intercept",
    "csr_container"
  ],
  "test_linear_regression_multiple_outcome": [],
  "test_linear_regression_sparse_multiple_outcome": [
    "global_random_seed",
    "coo_container"
  ],
  "test_linear_regression_positive": [],
  "test_linear_regression_positive_multiple_outcome": [
    "global_random_seed"
  ],
  "test_linear_regression_positive_vs_nonpositive": [
    "global_random_seed"
  ],
  "test_linear_regression_positive_vs_nonpositive_when_positive": [
    "global_random_seed"
  ],
  "test_inplace_data_preprocessing": [
    "sparse_container",
    "use_sw",
    "global_random_seed"
  ],
  "test_linear_regression_pd_sparse_dataframe_warning": [],
  "test_preprocess_data": [
    "global_random_seed"
  ],
  "test_preprocess_data_multioutput": [
    "global_random_seed",
    "sparse_container"
  ],
  "test_preprocess_data_weighted": [
    "rescale_with_sw",
    "sparse_container",
    "global_random_seed"
  ],
  "test_sparse_preprocess_data_offsets": [
    "global_random_seed",
    "lil_container"
  ],
  "test_csr_preprocess_data": [
    "csr_container"
  ],
  "test_preprocess_copy_data_no_checks": [
    "sparse_container",
    "to_copy"
  ],
  "test_dtype_preprocess_data": [
    "rescale_with_sw",
    "fit_intercept",
    "global_random_seed"
  ],
  "test_rescale_data": [
    "n_targets",
    "sparse_container",
    "global_random_seed"
  ],
  "test_fused_types_make_dataset": [
    "csr_container"
  ],
  "test_linear_regression_sample_weight_consistency": [
    "X_shape",
    "sparse_container",
    "fit_intercept",
    "global_random_seed"
  ],
  "inplace_identity": [
    "X"
  ],
  "inplace_exp": [
    "X"
  ],
  "inplace_logistic": [
    "X"
  ],
  "inplace_tanh": [
    "X"
  ],
  "inplace_relu": [
    "X"
  ],
  "inplace_softmax": [
    "X"
  ],
  "ACTIVATIONS": [],
  "inplace_identity_derivative": [
    "Z",
    "delta"
  ],
  "inplace_logistic_derivative": [
    "Z",
    "delta"
  ],
  "inplace_tanh_derivative": [
    "Z",
    "delta"
  ],
  "inplace_relu_derivative": [
    "Z",
    "delta"
  ],
  "DERIVATIVES": [],
  "poisson_loss": [
    "y_true",
    "y_pred",
    "sample_weight"
  ],
  "binary_log_loss": [
    "y_true",
    "y_prob",
    "sample_weight"
  ],
  "LOSS_FUNCTIONS": [],
  "BaseOptimizer": {
    "__init__": [
      "self",
      "learning_rate_init"
    ],
    "update_params": [
      "self",
      "params",
      "grads"
    ],
    "iteration_ends": [
      "self",
      "time_step"
    ],
    "trigger_stopping": [
      "self",
      "msg",
      "verbose"
    ]
  },
  "SGDOptimizer": {
    "__init__": [
      "self",
      "params",
      "learning_rate_init",
      "lr_schedule",
      "momentum",
      "nesterov",
      "power_t"
    ],
    "iteration_ends": [
      "self",
      "time_step"
    ],
    "trigger_stopping": [
      "self",
      "msg",
      "verbose"
    ],
    "_get_updates": [
      "self",
      "grads"
    ]
  },
  "AdamOptimizer": {
    "__init__": [
      "self",
      "params",
      "learning_rate_init",
      "beta_1",
      "beta_2",
      "epsilon"
    ],
    "_get_updates": [
      "self",
      "grads"
    ]
  },
  "_STOCHASTIC_SOLVERS": [],
  "_pack": [
    "coefs_",
    "intercepts_"
  ],
  "BaseMultilayerPerceptron": {
    "__init__": [
      "self",
      "hidden_layer_sizes",
      "activation",
      "solver",
      "alpha",
      "batch_size",
      "learning_rate",
      "learning_rate_init",
      "power_t",
      "max_iter",
      "loss",
      "shuffle",
      "random_state",
      "tol",
      "verbose",
      "warm_start",
      "momentum",
      "nesterovs_momentum",
      "early_stopping",
      "validation_fraction",
      "beta_1",
      "beta_2",
      "epsilon",
      "n_iter_no_change",
      "max_fun"
    ],
    "_unpack": [
      "self",
      "packed_parameters"
    ],
    "_forward_pass": [
      "self",
      "activations"
    ],
    "_forward_pass_fast": [
      "self",
      "X",
      "check_input"
    ],
    "_compute_loss_grad": [
      "self",
      "layer",
      "sw_sum",
      "activations",
      "deltas",
      "coef_grads",
      "intercept_grads"
    ],
    "_loss_grad_lbfgs": [
      "self",
      "packed_coef_inter",
      "X",
      "y",
      "sample_weight",
      "activations",
      "deltas",
      "coef_grads",
      "intercept_grads"
    ],
    "_backprop": [
      "self",
      "X",
      "y",
      "sample_weight",
      "activations",
      "deltas",
      "coef_grads",
      "intercept_grads"
    ],
    "_initialize": [
      "self",
      "y",
      "layer_units",
      "dtype"
    ],
    "_init_coef": [
      "self",
      "fan_in",
      "fan_out",
      "dtype"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "incremental"
    ],
    "_fit_lbfgs": [
      "self",
      "X",
      "y",
      "sample_weight",
      "activations",
      "deltas",
      "coef_grads",
      "intercept_grads",
      "layer_units"
    ],
    "_fit_stochastic": [
      "self",
      "X",
      "y",
      "sample_weight",
      "activations",
      "deltas",
      "coef_grads",
      "intercept_grads",
      "layer_units",
      "incremental"
    ],
    "_update_no_improvement_count": [
      "self",
      "early_stopping",
      "X",
      "y",
      "sample_weight"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_check_solver": [
      "self"
    ],
    "_score_with_function": [
      "self",
      "X",
      "y",
      "sample_weight",
      "score_function"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MLPClassifier": {
    "__init__": [
      "self",
      "hidden_layer_sizes",
      "activation"
    ],
    "_validate_input": [
      "self",
      "X",
      "y",
      "incremental",
      "reset"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X",
      "check_input"
    ],
    "_score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "classes"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MLPRegressor": {
    "__init__": [
      "self",
      "loss",
      "hidden_layer_sizes",
      "activation"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X",
      "check_input"
    ],
    "_score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_validate_input": [
      "self",
      "X",
      "y",
      "incremental",
      "reset"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "BernoulliRBM": {
    "__init__": [
      "self",
      "n_components"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_mean_hiddens": [
      "self",
      "v"
    ],
    "_sample_hiddens": [
      "self",
      "v",
      "rng"
    ],
    "_sample_visibles": [
      "self",
      "h",
      "rng"
    ],
    "_free_energy": [
      "self",
      "v"
    ],
    "gibbs": [
      "self",
      "v"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "v_pos",
      "rng"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "shapes": [],
  "test_base_optimizer": [],
  "test_sgd_optimizer_no_momentum": [],
  "test_sgd_optimizer_momentum": [],
  "test_sgd_optimizer_trigger_stopping": [],
  "test_sgd_optimizer_nesterovs_momentum": [],
  "test_adam_optimizer": [],
  "ACTIVATION_TYPES": [],
  "X_digits_multi": [],
  "y_digits_multi": [],
  "X_digits_binary": [],
  "y_digits_binary": [],
  "classification_datasets": [],
  "y_reg": [],
  "regression_datasets": [],
  "X_iris": [],
  "y_iris": [],
  "test_alpha": [],
  "test_fit": [],
  "test_gradient": [],
  "test_lbfgs_classification": [
    "X",
    "y"
  ],
  "test_lbfgs_regression": [
    "X",
    "y"
  ],
  "test_lbfgs_classification_maxfun": [
    "X",
    "y"
  ],
  "test_lbfgs_regression_maxfun": [
    "X",
    "y"
  ],
  "test_learning_rate_warmstart": [],
  "test_multilabel_classification": [],
  "test_multioutput_regression": [],
  "test_partial_fit_classes_error": [],
  "test_partial_fit_classification": [],
  "test_partial_fit_unseen_classes": [],
  "test_partial_fit_regression": [],
  "test_partial_fit_errors": [],
  "test_nonfinite_params": [],
  "test_predict_proba_binary": [],
  "test_predict_proba_multiclass": [],
  "test_predict_proba_multilabel": [],
  "test_shuffle": [],
  "test_sparse_matrices": [
    "csr_container"
  ],
  "test_tolerance": [],
  "test_verbose_sgd": [
    "capsys"
  ],
  "test_adaptive_learning_rate": [],
  "test_warm_start_full_iteration": [
    "MLPEstimator"
  ],
  "test_n_iter_no_change_inf": [],
  "test_early_stopping_stratified": [],
  "test_mlp_classifier_dtypes_casting": [],
  "test_mlp_regressor_dtypes_casting": [],
  "test_mlp_param_dtypes": [
    "dtype",
    "Estimator"
  ],
  "test_mlp_loading_from_joblib_partial_fit": [
    "tmp_path"
  ],
  "test_preserve_feature_names": [
    "Estimator"
  ],
  "test_mlp_warm_start_with_early_stopping": [
    "MLPEstimator"
  ],
  "test_mlp_warm_start_no_convergence": [
    "MLPEstimator",
    "solver"
  ],
  "test_mlp_partial_fit_after_fit": [
    "MLPEstimator"
  ],
  "test_mlp_diverging_loss": [],
  "test_mlp_sample_weight_with_early_stopping": [],
  "test_mlp_vs_poisson_glm_equivalent": [
    "global_random_seed"
  ],
  "test_minimum_input_sample_size": [],
  "test_transform": [],
  "test_small_sparse": [
    "csr_container"
  ],
  "test_small_sparse_partial_fit": [
    "sparse_container"
  ],
  "test_sample_hiddens": [],
  "test_fit_gibbs": [
    "csc_container"
  ],
  "test_gibbs_smoke": [],
  "test_score_samples": [
    "lil_containers"
  ],
  "test_rbm_verbose": [],
  "test_sparse_and_verbose": [
    "csc_container",
    "capsys"
  ],
  "test_transformer_dtypes_casting": [
    "dtype_in",
    "dtype_out"
  ],
  "test_convergence_dtype_consistency": [],
  "test_feature_names_out": [
    "method"
  ],
  "test_binary_log_loss_1_prob_finite": [],
  "test_log_loss_1_prob_finite": [
    "y_true",
    "y_prob"
  ],
  "test_poisson_loss": [
    "global_random_seed"
  ],
  "JUNK_FOOD_DOCS": [],
  "NoFit": {
    "__init__": [
      "self",
      "a",
      "b"
    ]
  },
  "NoTrans": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "NoInvTransf": {
    "transform": [
      "self",
      "X"
    ]
  },
  "Transf": {
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "TransfFitParams": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "Mult": {
    "__init__": [
      "self",
      "mult"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [],
    "predict_log_proba": [],
    "decision_function": [],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "FitParamT": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "should_succeed"
    ],
    "predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "should_succeed"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "DummyTransf": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "DummyEstimatorParams": {
    "__sklearn_is_fitted__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "got_attribute"
    ],
    "predict_proba": [
      "self",
      "X",
      "got_attribute"
    ],
    "predict_log_proba": [
      "self",
      "X",
      "got_attribute"
    ]
  },
  "test_pipeline_invalid_parameters": [],
  "test_empty_pipeline": [],
  "test_pipeline_init_tuple": [],
  "test_pipeline_methods_anova": [],
  "test_pipeline_fit_params": [],
  "test_pipeline_sample_weight_supported": [],
  "test_pipeline_sample_weight_unsupported": [],
  "test_pipeline_raise_set_params_error": [],
  "test_pipeline_methods_pca_svm": [],
  "test_pipeline_score_samples_pca_lof": [],
  "test_score_samples_on_pipeline_without_score_samples": [],
  "test_pipeline_methods_preprocessing_svm": [],
  "test_fit_predict_on_pipeline": [],
  "test_fit_predict_on_pipeline_without_fit_predict": [],
  "test_fit_predict_with_intermediate_fit_params": [],
  "test_predict_methods_with_predict_params": [
    "method_name"
  ],
  "test_feature_union": [
    "csr_container"
  ],
  "test_feature_union_named_transformers": [],
  "test_make_union": [],
  "test_make_union_kwargs": [],
  "create_mock_transformer": [
    "base_name",
    "n_features"
  ],
  "test_make_union_passes_verbose_feature_names_out": [],
  "test_pipeline_transform": [],
  "test_pipeline_fit_transform": [],
  "test_pipeline_slice": [
    "start",
    "end"
  ],
  "test_pipeline_index": [],
  "test_set_pipeline_steps": [],
  "test_pipeline_named_steps": [],
  "test_pipeline_correctly_adjusts_steps": [
    "passthrough"
  ],
  "test_set_pipeline_step_passthrough": [
    "passthrough"
  ],
  "test_pipeline_ducktyping": [],
  "test_make_pipeline": [],
  "test_pipeline_estimator_type": [
    "pipeline",
    "check_estimator_type"
  ],
  "test_sklearn_tags_with_empty_pipeline": [],
  "test_feature_union_weights": [],
  "test_feature_union_parallel": [],
  "test_feature_union_feature_names": [],
  "test_classes_property": [],
  "test_set_feature_union_steps": [],
  "test_set_feature_union_step_drop": [],
  "test_set_feature_union_passthrough": [],
  "test_feature_union_passthrough_get_feature_names_out_true": [],
  "test_feature_union_passthrough_get_feature_names_out_false": [],
  "test_feature_union_passthrough_get_feature_names_out_false_errors": [],
  "test_feature_union_passthrough_get_feature_names_out_false_errors_overlap_over_5": [],
  "test_step_name_validation": [],
  "test_set_params_nested_pipeline": [],
  "test_pipeline_memory": [],
  "test_make_pipeline_memory": [],
  "FeatureNameSaver": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test_features_names_passthrough": [],
  "test_feature_names_count_vectorizer": [],
  "test_pipeline_feature_names_out_error_without_definition": [],
  "test_pipeline_param_error": [],
  "parameter_grid_test_verbose": [],
  "test_verbose": [
    "est",
    "method",
    "pattern",
    "capsys"
  ],
  "test_n_features_in_pipeline": [],
  "test_n_features_in_feature_union": [],
  "test_feature_union_fit_params": [],
  "test_feature_union_fit_params_without_fit_transform": [],
  "test_pipeline_missing_values_leniency": [],
  "test_feature_union_warns_unknown_transformer_weight": [],
  "test_pipeline_get_tags_none": [
    "passthrough"
  ],
  "test_search_cv_using_minimal_compatible_estimator": [
    "Predictor"
  ],
  "test_pipeline_check_if_fitted": [],
  "test_feature_union_check_if_fitted": [],
  "test_pipeline_get_feature_names_out_passes_names_through": [],
  "test_pipeline_set_output_integration": [],
  "test_feature_union_set_output": [],
  "test_feature_union_getitem": [],
  "test_feature_union_getitem_error": [
    "key"
  ],
  "test_feature_union_feature_names_in_": [],
  "test_feature_union_1d_output": [],
  "test_transform_input_pipeline": [
    "method"
  ],
  "test_transform_input_explicit_value_check": [],
  "test_transform_input_no_slep6": [],
  "test_transform_tuple_input": [],
  "test_pipeline_warns_not_fitted": [
    "method"
  ],
  "SimpleEstimator": {
    "__sklearn_is_fitted__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "prop"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight",
      "prop"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "sample_weight",
      "prop"
    ],
    "predict": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ],
    "predict_proba": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ],
    "predict_log_proba": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ],
    "decision_function": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "prop"
    ],
    "transform": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ],
    "inverse_transform": [
      "self",
      "X",
      "sample_weight",
      "prop"
    ]
  },
  "test_metadata_routing_for_pipeline": [
    "method"
  ],
  "test_metadata_routing_error_for_pipeline": [
    "method"
  ],
  "test_routing_passed_metadata_not_supported": [
    "method"
  ],
  "test_pipeline_with_estimator_with_len": [],
  "test_pipeline_with_no_last_step": [
    "last_step"
  ],
  "test_feature_union_metadata_routing_error": [],
  "test_feature_union_get_metadata_routing_without_fit": [],
  "test_feature_union_metadata_routing": [
    "transformer"
  ],
  "test_openmp_parallelism_enabled": [],
  "all_random_matrix": [],
  "all_RandomProjection": [],
  "make_sparse_random_data": [
    "coo_container",
    "n_samples",
    "n_features",
    "n_nonzeros",
    "random_state",
    "sparse_format"
  ],
  "densify": [
    "matrix"
  ],
  "n_nonzeros": [],
  "test_invalid_jl_domain": [
    "n_samples",
    "eps"
  ],
  "test_input_size_jl_min_dim": [],
  "check_input_size_random_matrix": [
    "random_matrix"
  ],
  "check_size_generated": [
    "random_matrix"
  ],
  "check_zero_mean_and_unit_norm": [
    "random_matrix"
  ],
  "check_input_with_sparse_random_matrix": [
    "random_matrix"
  ],
  "test_basic_property_of_random_matrix": [
    "random_matrix"
  ],
  "test_basic_property_of_sparse_random_matrix": [
    "random_matrix"
  ],
  "test_gaussian_random_matrix": [],
  "test_sparse_random_matrix": [],
  "test_random_projection_transformer_invalid_input": [],
  "test_try_to_transform_before_fit": [
    "coo_container",
    "global_random_seed"
  ],
  "test_too_many_samples_to_find_a_safe_embedding": [
    "coo_container",
    "global_random_seed"
  ],
  "test_random_projection_embedding_quality": [
    "coo_container"
  ],
  "test_SparseRandomProj_output_representation": [
    "coo_container"
  ],
  "test_correct_RandomProjection_dimensions_embedding": [
    "coo_container",
    "global_random_seed"
  ],
  "test_warning_n_components_greater_than_n_features": [
    "coo_container",
    "global_random_seed"
  ],
  "test_works_with_sparse_data": [
    "coo_container",
    "global_random_seed"
  ],
  "test_johnson_lindenstrauss_min_dim": [],
  "test_random_projection_feature_names_out": [
    "coo_container",
    "random_projection_cls",
    "global_random_seed"
  ],
  "test_inverse_transform": [
    "coo_container",
    "n_samples",
    "n_features",
    "random_projection_cls",
    "compute_inverse_components",
    "global_random_seed"
  ],
  "test_random_projection_dtype_match": [
    "random_projection_cls",
    "input_dtype",
    "expected_dtype"
  ],
  "test_random_projection_numerical_consistency": [
    "random_projection_cls"
  ],
  "y_binary": [],
  "classes": [],
  "y_multi": [],
  "classes_multi": [],
  "metadata": [],
  "sample_weight": [],
  "groups": [],
  "METAESTIMATOR_IDS": [],
  "UNSUPPORTED_ESTIMATORS": [],
  "get_init_args": [
    "metaestimator_info",
    "sub_estimator_consumes"
  ],
  "filter_metadata_in_routing_methods": [
    "estimator_routing_methods"
  ],
  "set_requests": [
    "obj"
  ],
  "test_unsupported_estimators_get_metadata_routing": [
    "estimator"
  ],
  "test_unsupported_estimators_fit_with_metadata": [
    "estimator"
  ],
  "test_registry_copy": [],
  "test_default_request": [
    "metaestimator"
  ],
  "test_error_on_missing_requests_for_sub_estimator": [
    "metaestimator"
  ],
  "test_setting_request_on_sub_estimator_removes_error": [
    "metaestimator"
  ],
  "test_non_consuming_estimator_works": [
    "metaestimator"
  ],
  "test_metadata_is_routed_correctly_to_scorer": [
    "metaestimator"
  ],
  "test_metadata_is_routed_correctly_to_splitter": [
    "metaestimator"
  ],
  "test_metadata_routed_to_group_splitter": [
    "metaestimator"
  ],
  "N_SAMPLES": [],
  "test_calibration_method_raises": [
    "data"
  ],
  "test_calibration": [
    "data",
    "method",
    "csr_container",
    "ensemble"
  ],
  "test_calibration_default_estimator": [
    "data"
  ],
  "test_calibration_cv_splitter": [
    "data",
    "ensemble"
  ],
  "test_calibration_cv_nfold": [
    "data"
  ],
  "test_sample_weight": [
    "data",
    "method",
    "ensemble"
  ],
  "test_parallel_execution": [
    "data",
    "method",
    "ensemble"
  ],
  "test_calibration_multiclass": [
    "method",
    "ensemble",
    "seed"
  ],
  "test_calibration_zero_probability": [],
  "test_calibration_frozen": [
    "csr_container",
    "method"
  ],
  "test_calibration_ensemble_false": [
    "data",
    "method",
    "calibrator"
  ],
  "test_sigmoid_calibration": [],
  "test_temperature_scaling": [
    "n_classes",
    "ensemble"
  ],
  "test_temperature_scaling_input_validation": [
    "global_dtype"
  ],
  "test_calibration_curve": [],
  "test_calibration_nan_imputer": [
    "method",
    "ensemble"
  ],
  "test_calibration_prob_sum": [
    "method",
    "ensemble"
  ],
  "test_calibration_less_classes": [
    "ensemble"
  ],
  "test_calibration_accepts_ndarray": [
    "X"
  ],
  "dict_data": [],
  "dict_data_pipeline": [
    "dict_data"
  ],
  "test_calibration_dict_pipeline": [
    "dict_data",
    "dict_data_pipeline"
  ],
  "test_calibration_attributes": [],
  "test_calibration_inconsistent_prefit_n_features_in": [],
  "test_calibration_votingclassifier": [],
  "iris_data": [],
  "iris_data_binary": [
    "iris_data"
  ],
  "test_calibration_display_compute": [
    "pyplot",
    "iris_data_binary",
    "n_bins",
    "strategy"
  ],
  "test_plot_calibration_curve_pipeline": [
    "pyplot",
    "iris_data_binary"
  ],
  "test_calibration_display_default_labels": [
    "pyplot",
    "name",
    "expected_label"
  ],
  "test_calibration_display_label_class_plot": [
    "pyplot"
  ],
  "test_calibration_display_name_multiple_calls": [
    "constructor_name",
    "pyplot",
    "iris_data_binary"
  ],
  "test_calibration_display_ref_line": [
    "pyplot",
    "iris_data_binary"
  ],
  "test_calibration_curve_pos_label_error_str": [
    "dtype_y_str"
  ],
  "test_calibration_curve_pos_label": [
    "dtype_y_str"
  ],
  "test_calibration_display_kwargs": [
    "pyplot",
    "iris_data_binary",
    "kwargs"
  ],
  "test_calibration_display_pos_label": [
    "pyplot",
    "iris_data_binary",
    "pos_label",
    "expected_pos_label"
  ],
  "test_calibrated_classifier_cv_double_sample_weights_equivalence": [
    "method",
    "ensemble"
  ],
  "test_calibration_with_fit_params": [
    "fit_params_type",
    "data"
  ],
  "test_calibration_with_sample_weight_estimator": [
    "sample_weight",
    "data"
  ],
  "test_calibration_without_sample_weight_estimator": [
    "data"
  ],
  "test_calibration_with_non_sample_aligned_fit_param": [
    "data"
  ],
  "test_calibrated_classifier_cv_works_with_large_confidence_scores": [
    "global_random_seed"
  ],
  "test_sigmoid_calibration_max_abs_prediction_threshold": [
    "global_random_seed"
  ],
  "test_float32_predict_proba": [
    "data",
    "use_sample_weight",
    "method"
  ],
  "test_error_less_class_samples_than_folds": [],
  "test_temperature_scaling_array_api_compliance": [
    "ensemble",
    "use_sample_weight",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_temperature_scaling_array_api_with_str_y_estimator_not_prefit": [
    "ensemble",
    "use_sample_weight",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "_DOCSTRING_IGNORES": [],
  "_METHODS_IGNORE_NONE_Y": [],
  "test_docstring_parameters": [],
  "_construct_searchcv_instance": [
    "SearchCV"
  ],
  "_construct_compose_pipeline_instance": [
    "Estimator"
  ],
  "_construct_sparse_coder": [
    "Estimator"
  ],
  "test_fit_docstring_attributes": [
    "name",
    "Estimator"
  ],
  "_get_all_fitted_attributes": [
    "estimator"
  ],
  "DelegatorData": {
    "__init__": [
      "self",
      "name",
      "construct",
      "skip_methods",
      "fit_args"
    ]
  },
  "DELEGATING_METAESTIMATORS": [],
  "test_metaestimator_delegation": [],
  "_get_instance_with_pipeline": [
    "meta_estimator",
    "init_params"
  ],
  "_generate_meta_estimator_instances_with_pipeline": [],
  "DATA_VALIDATION_META_ESTIMATORS_TO_IGNORE": [],
  "DATA_VALIDATION_META_ESTIMATORS": [],
  "_get_meta_estimator_id": [
    "estimator"
  ],
  "test_meta_estimators_delegate_data_validation": [
    "estimator"
  ],
  "_get_func_info": [
    "func_module"
  ],
  "_check_function_param_validation": [
    "func",
    "func_name",
    "func_params",
    "required_params",
    "parameter_constraints"
  ],
  "PARAM_VALIDATION_FUNCTION_LIST": [],
  "test_function_param_validation": [
    "func_module"
  ],
  "PARAM_VALIDATION_CLASS_WRAPPER_LIST": [],
  "test_class_wrapper_param_validation": [
    "func_module",
    "class_module"
  ],
  "DISCRETE_NAIVE_BAYES_CLASSES": [],
  "ALL_NAIVE_BAYES_CLASSES": [],
  "get_random_normal_x_binary_y": [
    "global_random_seed"
  ],
  "get_random_integer_x_three_classes_y": [
    "global_random_seed"
  ],
  "test_gnb": [],
  "test_gnb_prior": [
    "global_random_seed"
  ],
  "test_gnb_sample_weight": [
    "global_random_seed"
  ],
  "test_gnb_neg_priors": [],
  "test_gnb_priors": [],
  "test_gnb_priors_sum_isclose": [],
  "test_gnb_wrong_nb_priors": [],
  "test_gnb_prior_greater_one": [],
  "test_gnb_prior_large_bias": [],
  "test_gnb_check_update_with_no_data": [],
  "test_gnb_partial_fit": [
    "global_dtype"
  ],
  "test_gnb_naive_bayes_scale_invariance": [],
  "test_discretenb_prior": [
    "DiscreteNaiveBayes",
    "global_random_seed"
  ],
  "test_discretenb_partial_fit": [
    "DiscreteNaiveBayes"
  ],
  "test_NB_partial_fit_no_first_classes": [
    "NaiveBayes",
    "global_random_seed"
  ],
  "test_discretenb_predict_proba": [],
  "test_discretenb_uniform_prior": [
    "DiscreteNaiveBayes"
  ],
  "test_discretenb_provide_prior": [
    "DiscreteNaiveBayes"
  ],
  "test_discretenb_provide_prior_with_partial_fit": [
    "DiscreteNaiveBayes"
  ],
  "test_discretenb_sample_weight_multiclass": [
    "DiscreteNaiveBayes"
  ],
  "test_discretenb_degenerate_one_class_case": [
    "DiscreteNaiveBayes",
    "use_partial_fit",
    "train_on_single_class_y"
  ],
  "test_mnnb": [
    "kind",
    "global_random_seed",
    "csr_container"
  ],
  "test_mnb_prior_unobserved_targets": [],
  "test_bnb": [],
  "test_bnb_feature_log_prob": [],
  "test_cnb": [],
  "test_categoricalnb": [
    "global_random_seed"
  ],
  "test_categoricalnb_with_min_categories": [
    "min_categories",
    "exp_X1_count",
    "exp_X2_count",
    "new_X",
    "exp_n_categories_"
  ],
  "test_categoricalnb_min_categories_errors": [
    "min_categories",
    "error_msg"
  ],
  "test_alpha_vector": [],
  "test_check_accuracy_on_digits": [],
  "test_check_alpha": [],
  "test_predict_joint_proba": [
    "Estimator",
    "global_random_seed"
  ],
  "test_categorical_input_tag": [
    "Estimator"
  ],
  "test_gnb_array_api_compliance": [
    "use_str_y",
    "use_sample_weight",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "__author__": [],
  "__license__": [],
  "test_import_skl": [],
  "numpydoc_validation": [],
  "get_all_methods": [],
  "get_all_functions_names": [],
  "filter_errors": [
    "errors",
    "method",
    "Klass"
  ],
  "repr_errors": [
    "res",
    "Klass",
    "method"
  ],
  "test_function_docstring": [
    "function_name",
    "request"
  ],
  "test_docstring": [
    "Klass",
    "method",
    "request"
  ],
  "y3": [],
  "X1": [],
  "X6": [],
  "y6": [],
  "y7": [],
  "X7": [],
  "y4": [],
  "solver_shrinkage": [],
  "test_lda_predict": [],
  "test_lda_predict_proba": [
    "solver",
    "n_classes"
  ],
  "test_lda_priors": [],
  "test_lda_coefs": [],
  "test_lda_transform": [],
  "test_lda_explained_variance_ratio": [],
  "test_lda_orthogonality": [],
  "test_lda_scaling": [],
  "test_lda_store_covariance": [],
  "test_lda_shrinkage": [
    "seed"
  ],
  "test_lda_ledoitwolf": [],
  "test_lda_dimension_warning": [
    "n_classes",
    "n_features"
  ],
  "test_lda_dtype_match": [
    "data_type",
    "expected_type"
  ],
  "test_lda_numeric_consistency_float32_float64": [],
  "test_qda": [
    "solver"
  ],
  "test_qda_covariance_estimator": [],
  "test_qda_ledoitwolf": [
    "global_random_seed"
  ],
  "test_qda_coefs": [
    "global_random_seed"
  ],
  "test_qda_priors": [],
  "test_qda_prior_type": [
    "priors_type"
  ],
  "test_qda_prior_copy": [],
  "test_qda_store_covariance": [],
  "test_qda_regularization": [
    "global_random_seed",
    "solver"
  ],
  "test_covariance": [],
  "test_raises_value_error_on_same_number_of_classes_and_samples": [
    "solver"
  ],
  "test_raises_value_error_on_one_sample_per_class": [
    "solver"
  ],
  "test_get_feature_names_out": [],
  "test_qda_shrinkage_performance": [
    "global_random_seed",
    "n_features",
    "train_size",
    "solver_no_shrinkage"
  ],
  "min_depencies_tag_to_packages_without_version": [],
  "pyproject_section_to_min_dependencies_tag": [],
  "test_min_dependencies_readme": [],
  "check_pyproject_section": [
    "pyproject_section",
    "min_dependencies_tag",
    "skip_version_check_for"
  ],
  "test_min_dependencies_pyproject_toml": [
    "pyproject_section",
    "min_dependencies_tag"
  ],
  "record_metadata": [
    "obj",
    "record_default"
  ],
  "check_recorded_metadata": [
    "obj",
    "method",
    "parent",
    "split_params"
  ],
  "record_metadata_not_default": [],
  "assert_request_is_empty": [
    "metadata_request",
    "exclude"
  ],
  "assert_request_equal": [
    "request",
    "dictionary"
  ],
  "_Registry": {
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "__copy__": [
      "self"
    ]
  },
  "ConsumingRegressor": {
    "__init__": [
      "self",
      "registry"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "predict": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ]
  },
  "NonConsumingClassifier": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ]
  },
  "NonConsumingRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "ConsumingClassifier": {
    "__init__": [
      "self",
      "registry",
      "alpha"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight",
      "metadata"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "predict": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ],
    "predict_proba": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ],
    "predict_log_proba": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ],
    "decision_function": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ]
  },
  "ConsumingClassifierWithoutPredictProba": {
    "predict_proba": [
      "self"
    ]
  },
  "ConsumingClassifierWithoutPredictLogProba": {
    "predict_log_proba": [
      "self"
    ]
  },
  "ConsumingClassifierWithOnlyPredict": {
    "predict_proba": [
      "self"
    ],
    "predict_log_proba": [
      "self"
    ]
  },
  "ConsumingTransformer": {
    "__init__": [
      "self",
      "registry"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "transform": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "inverse_transform": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ]
  },
  "ConsumingNoFitTransformTransformer": {
    "__init__": [
      "self",
      "registry"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "metadata"
    ],
    "transform": [
      "self",
      "X",
      "sample_weight",
      "metadata"
    ]
  },
  "ConsumingScorer": {
    "__init__": [
      "self",
      "registry"
    ],
    "_score": [
      "self",
      "method_caller",
      "clf",
      "X",
      "y"
    ]
  },
  "ConsumingSplitter": {
    "__init__": [
      "self",
      "registry"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups",
      "metadata"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups",
      "metadata"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "MetaRegressor": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "WeightedMetaRegressor": {
    "__init__": [
      "self",
      "estimator",
      "registry"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "WeightedMetaClassifier": {
    "__init__": [
      "self",
      "estimator",
      "registry"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "MetaTransformer": {
    "__init__": [
      "self",
      "transformer"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "test_all_estimator_no_base_class": [],
  "_sample_func": [
    "x",
    "y"
  ],
  "CallableEstimator": {
    "__call__": [
      "self"
    ]
  },
  "test_get_check_estimator_ids": [
    "val",
    "expected"
  ],
  "test_estimators": [
    "estimator",
    "check",
    "request"
  ],
  "test_import_all_consistency": [],
  "test_root_import_all_completeness": [],
  "test_all_tests_are_importable": [],
  "test_class_support_removed": [],
  "_estimators_that_predict_in_fit": [],
  "column_name_estimators": [],
  "test_pandas_column_name_consistency": [
    "estimator_orig"
  ],
  "GET_FEATURES_OUT_MODULES_TO_IGNORE": [],
  "_include_in_get_feature_names_out_check": [
    "transformer"
  ],
  "GET_FEATURES_OUT_ESTIMATORS": [],
  "test_transformers_get_feature_names_out": [
    "transformer"
  ],
  "ESTIMATORS_WITH_GET_FEATURE_NAMES_OUT": [],
  "test_estimators_get_feature_names_out_error": [
    "estimator"
  ],
  "test_check_param_validation": [
    "estimator"
  ],
  "SET_OUTPUT_ESTIMATORS": [],
  "test_set_output_transform": [
    "estimator_orig"
  ],
  "test_set_output_transform_configured": [
    "estimator_orig",
    "check_func"
  ],
  "test_check_inplace_ensure_writeable": [
    "estimator"
  ],
  "test_polynomial_count_sketch": [
    "gamma",
    "degree",
    "coef0",
    "n_components"
  ],
  "test_polynomial_count_sketch_dense_sparse": [
    "gamma",
    "degree",
    "coef0",
    "csr_container"
  ],
  "_linear_kernel": [
    "X",
    "Y"
  ],
  "test_additive_chi2_sampler": [
    "csr_container"
  ],
  "test_additive_chi2_sampler_sample_steps": [
    "method",
    "sample_steps"
  ],
  "test_additive_chi2_sampler_wrong_sample_steps": [
    "method"
  ],
  "test_skewed_chi2_sampler": [],
  "test_additive_chi2_sampler_exceptions": [],
  "test_rbf_sampler": [],
  "test_rbf_sampler_fitted_attributes_dtype": [
    "global_dtype"
  ],
  "test_rbf_sampler_dtype_equivalence": [],
  "test_rbf_sampler_gamma_scale": [],
  "test_skewed_chi2_sampler_fitted_attributes_dtype": [
    "global_dtype"
  ],
  "test_skewed_chi2_sampler_dtype_equivalence": [],
  "test_input_validation": [
    "csr_container"
  ],
  "test_nystroem_approximation": [],
  "test_nystroem_default_parameters": [],
  "test_nystroem_singular_kernel": [],
  "test_nystroem_poly_kernel_params": [],
  "test_nystroem_callable": [],
  "test_nystroem_precomputed_kernel": [],
  "test_nystroem_component_indices": [],
  "test_additivechi2sampler_get_feature_names_out": [],
  "test_kernel_ridge": [],
  "test_kernel_ridge_sparse": [
    "sparse_container"
  ],
  "test_kernel_ridge_singular_kernel": [],
  "test_kernel_ridge_precomputed": [],
  "test_kernel_ridge_precomputed_kernel_unchanged": [],
  "test_kernel_ridge_sample_weights": [],
  "test_kernel_ridge_multi_output": [],
  "_check_predict_proba": [
    "clf",
    "X",
    "y"
  ],
  "_check_behavior_2d": [
    "clf"
  ],
  "_check_behavior_2d_for_constant": [
    "clf"
  ],
  "_check_equality_regressor": [
    "statistic",
    "y_learn",
    "y_pred_learn",
    "y_test",
    "y_pred_test"
  ],
  "test_feature_names_in_and_n_features_in_": [
    "global_random_seed",
    "n_samples"
  ],
  "test_most_frequent_and_prior_strategy": [],
  "test_most_frequent_and_prior_strategy_with_2d_column_y": [],
  "test_most_frequent_and_prior_strategy_multioutput": [],
  "test_stratified_strategy": [
    "global_random_seed"
  ],
  "test_stratified_strategy_multioutput": [
    "global_random_seed"
  ],
  "test_uniform_strategy": [
    "global_random_seed"
  ],
  "test_uniform_strategy_multioutput": [
    "global_random_seed"
  ],
  "test_string_labels": [],
  "test_classifier_score_with_None": [
    "y",
    "y_test"
  ],
  "test_classifier_prediction_independent_of_X": [
    "strategy",
    "global_random_seed"
  ],
  "test_mean_strategy_regressor": [
    "global_random_seed"
  ],
  "test_mean_strategy_multioutput_regressor": [
    "global_random_seed"
  ],
  "test_regressor_exceptions": [],
  "test_median_strategy_regressor": [
    "global_random_seed"
  ],
  "test_median_strategy_multioutput_regressor": [
    "global_random_seed"
  ],
  "test_quantile_strategy_regressor": [
    "global_random_seed"
  ],
  "test_quantile_strategy_multioutput_regressor": [
    "global_random_seed"
  ],
  "test_quantile_invalid": [],
  "test_quantile_strategy_empty_train": [],
  "test_constant_strategy_regressor": [
    "global_random_seed"
  ],
  "test_constant_strategy_multioutput_regressor": [
    "global_random_seed"
  ],
  "test_y_mean_attribute_regressor": [],
  "test_constants_not_specified_regressor": [],
  "test_constant_size_multioutput_regressor": [
    "global_random_seed"
  ],
  "test_constant_strategy": [],
  "test_constant_strategy_multioutput": [],
  "test_constant_strategy_exceptions": [
    "y",
    "params",
    "err_msg"
  ],
  "test_classification_sample_weight": [],
  "test_constant_strategy_sparse_target": [
    "csc_container"
  ],
  "test_uniform_strategy_sparse_target_warning": [
    "global_random_seed",
    "csc_container"
  ],
  "test_stratified_strategy_sparse_target": [
    "global_random_seed",
    "csc_container"
  ],
  "test_most_frequent_and_prior_strategy_sparse_target": [
    "csc_container"
  ],
  "test_dummy_regressor_sample_weight": [
    "global_random_seed",
    "n_samples"
  ],
  "test_dummy_regressor_on_3D_array": [],
  "test_dummy_classifier_on_3D_array": [],
  "test_dummy_regressor_return_std": [],
  "test_regressor_score_with_None": [
    "y",
    "y_test"
  ],
  "test_regressor_prediction_independent_of_X": [
    "strategy"
  ],
  "test_dtype_of_classifier_probas": [
    "strategy"
  ],
  "test_multi_target_regression": [],
  "test_multi_target_regression_partial_fit": [],
  "test_multi_target_regression_one_target": [],
  "test_multi_target_sparse_regression": [
    "sparse_container"
  ],
  "test_multi_target_sample_weights_api": [],
  "test_multi_target_sample_weight_partial_fit": [],
  "test_multi_target_sample_weights": [],
  "y1": [],
  "y2": [],
  "n_outputs": [],
  "n_classes": [],
  "test_multi_output_classification_partial_fit_parallelism": [],
  "test_hasattr_multi_output_predict_proba": [],
  "test_multi_output_predict_proba": [],
  "test_multi_output_classification_partial_fit": [],
  "test_multi_output_classification_partial_fit_no_first_classes_exception": [],
  "test_multi_output_classification": [],
  "test_multiclass_multioutput_estimator": [],
  "test_multiclass_multioutput_estimator_predict_proba": [],
  "test_multi_output_classification_sample_weights": [],
  "test_multi_output_classification_partial_fit_sample_weights": [],
  "test_multi_output_exceptions": [],
  "test_multi_output_not_fitted_error": [
    "response_method"
  ],
  "test_multi_output_delegate_predict_proba": [],
  "generate_multilabel_dataset_with_correlations": [],
  "test_classifier_chain_fit_and_predict_with_linear_svc": [
    "chain_method"
  ],
  "test_classifier_chain_fit_and_predict_with_sparse_data": [
    "csr_container"
  ],
  "test_classifier_chain_vs_independent_models": [],
  "test_classifier_chain_fit_and_predict": [
    "chain_method",
    "response_method"
  ],
  "test_regressor_chain_fit_and_predict": [],
  "test_base_chain_fit_and_predict_with_sparse_data_and_cv": [
    "csr_container"
  ],
  "test_base_chain_random_order": [],
  "test_base_chain_crossval_fit_and_predict": [
    "chain_type",
    "chain_method"
  ],
  "test_multi_output_classes_": [
    "estimator"
  ],
  "DummyRegressorWithFitParams": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "DummyClassifierWithFitParams": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "test_multioutput_estimator_with_fit_params": [
    "estimator",
    "dataset"
  ],
  "test_regressor_chain_w_fit_params": [],
  "test_support_missing_values": [
    "MultiOutputEstimator",
    "Estimator"
  ],
  "test_classifier_chain_tuple_order": [
    "order_type"
  ],
  "test_classifier_chain_tuple_invalid_order": [],
  "test_classifier_chain_verbose": [
    "capsys"
  ],
  "test_regressor_chain_verbose": [
    "capsys"
  ],
  "test_multioutputregressor_ducktypes_fitted_estimator": [],
  "test_fit_params_no_routing": [
    "Cls",
    "method"
  ],
  "test_multioutput_regressor_has_partial_fit": [],
  "test_base_estimator_deprecation": [
    "Estimator"
  ],
  "my_groups": [],
  "my_weights": [],
  "my_other_weights": [],
  "SimplePipeline": {
    "__init__": [
      "self",
      "steps"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "test_assert_request_is_empty": [],
  "test_estimator_puts_self_in_registry": [
    "estimator"
  ],
  "test_request_type_is_alias": [
    "val",
    "res"
  ],
  "test_request_type_is_valid": [
    "val",
    "res"
  ],
  "test_default_requests": [],
  "test_default_request_override": [],
  "test_process_routing_invalid_method": [],
  "test_process_routing_invalid_object": [],
  "test_process_routing_empty_params_get_with_default": [
    "method",
    "default"
  ],
  "test_simple_metadata_routing": [],
  "test_nested_routing": [],
  "test_nested_routing_conflict": [],
  "test_invalid_metadata": [],
  "test_get_metadata_routing": [],
  "test_setting_default_requests": [],
  "test_removing_non_existing_param_raises": [],
  "test_method_metadata_request": [],
  "test_get_routing_for_object": [],
  "test_metadata_request_consumes_method": [],
  "test_metadata_router_consumes_method": [],
  "test_metaestimator_warnings": [],
  "test_estimator_warnings": [],
  "test_string_representations": [
    "obj",
    "string"
  ],
  "test_validations": [
    "obj",
    "method",
    "inputs",
    "err_cls",
    "err_msg"
  ],
  "test_methodmapping": [],
  "test_metadatarouter_add_self_request": [],
  "test_metadata_routing_add": [],
  "test_metadata_routing_get_param_names": [],
  "test_method_generation": [],
  "test_composite_methods": [],
  "test_no_feature_flag_raises_error": [],
  "test_none_metadata_passed": [],
  "test_no_metadata_always_works": [],
  "test_unsetmetadatapassederror_correct": [],
  "test_unsetmetadatapassederror_correct_for_composite_methods": [],
  "test_unbound_set_methods_work": [],
  "test_config_context": [],
  "test_config_context_exception": [],
  "test_set_config": [],
  "set_assume_finite": [
    "assume_finite",
    "sleep_duration"
  ],
  "test_config_threadsafe_joblib": [
    "backend"
  ],
  "test_config_threadsafe": [],
  "test_config_array_api_dispatch_error_scipy": [
    "monkeypatch"
  ],
  "CLASS_DOCSTRING_CONSISTENCY_CASES": [],
  "FUNCTION_DOCSTRING_CONSISTENCY_CASES": [],
  "test_class_docstring_consistency": [
    "case"
  ],
  "test_function_docstring_consistency": [
    "case"
  ],
  "test_ovr_exceptions": [],
  "test_check_classification_targets": [],
  "test_ovr_ties": [],
  "test_ovr_fit_predict": [],
  "test_ovr_partial_fit": [],
  "test_ovr_partial_fit_exceptions": [],
  "test_ovr_ovo_regressor": [],
  "test_ovr_fit_predict_sparse": [
    "sparse_container"
  ],
  "test_ovr_always_present": [],
  "test_ovr_multiclass": [],
  "test_ovr_binary": [],
  "test_ovr_multilabel": [],
  "test_ovr_fit_predict_svc": [],
  "test_ovr_multilabel_dataset": [],
  "test_ovr_multilabel_predict_proba": [],
  "test_ovr_single_label_predict_proba": [],
  "test_ovr_single_label_predict_proba_zero": [],
  "test_ovr_multilabel_decision_function": [],
  "test_ovr_single_label_decision_function": [],
  "test_ovr_gridsearch": [],
  "test_ovr_pipeline": [],
  "test_ovo_exceptions": [],
  "test_ovo_fit_on_list": [],
  "test_ovo_fit_predict": [],
  "test_ovo_partial_fit_predict": [],
  "test_ovo_decision_function": [],
  "test_ovo_gridsearch": [],
  "test_ovo_ties": [],
  "test_ovo_ties2": [],
  "test_ovo_string_y": [],
  "test_ovo_one_class": [],
  "test_ovo_float_y": [],
  "test_ecoc_exceptions": [],
  "test_ecoc_fit_predict": [],
  "test_ecoc_gridsearch": [],
  "test_ecoc_float_y": [],
  "test_ecoc_delegate_sparse_base_estimator": [
    "csc_container"
  ],
  "test_pairwise_indices": [],
  "test_pairwise_n_features_in": [],
  "test_pairwise_tag": [
    "MultiClassClassifier"
  ],
  "test_pairwise_cross_val_score": [
    "MultiClassClassifier"
  ],
  "test_constant_int_target": [
    "make_y"
  ],
  "test_ovo_consistent_binary_classification": [],
  "test_multiclass_estimator_attribute_error": [],
  "test_permutation_invariance": [],
  "test_check_increasing_small_number_of_samples": [],
  "test_check_increasing_up": [],
  "test_check_increasing_up_extreme": [],
  "test_check_increasing_down": [],
  "test_check_increasing_down_extreme": [],
  "test_check_ci_warn": [],
  "test_isotonic_regression": [],
  "test_isotonic_regression_ties_min": [],
  "test_isotonic_regression_ties_max": [],
  "test_isotonic_regression_ties_secondary_": [],
  "test_isotonic_regression_with_ties_in_differently_sized_groups": [],
  "test_isotonic_regression_reversed": [],
  "test_isotonic_regression_auto_decreasing": [],
  "test_isotonic_regression_auto_increasing": [],
  "test_assert_raises_exceptions": [],
  "test_isotonic_sample_weight_parameter_default_value": [],
  "test_isotonic_min_max_boundaries": [],
  "test_isotonic_sample_weight": [],
  "test_isotonic_regression_oob_raise": [],
  "test_isotonic_regression_oob_clip": [],
  "test_isotonic_regression_oob_nan": [],
  "test_isotonic_regression_pickle": [],
  "test_isotonic_duplicate_min_entry": [],
  "test_isotonic_ymin_ymax": [],
  "test_isotonic_zero_weight_loop": [],
  "test_fast_predict": [],
  "test_isotonic_copy_before_fit": [],
  "test_isotonic_dtype": [
    "dtype"
  ],
  "test_isotonic_mismatched_dtype": [
    "y_dtype"
  ],
  "test_make_unique_dtype": [],
  "test_make_unique_tolerance": [
    "dtype"
  ],
  "test_isotonic_make_unique_tolerance": [],
  "test_isotonic_non_regression_inf_slope": [],
  "test_isotonic_thresholds": [
    "increasing"
  ],
  "test_input_shape_validation": [],
  "test_isotonic_2darray_more_than_1_feature": [],
  "test_isotonic_regression_sample_weight_not_overwritten": [],
  "test_isotonic_regression_output_predict": [],
  "MyEstimator": {
    "__init__": [
      "self",
      "l1",
      "empty"
    ]
  },
  "K": {
    "__init__": [
      "self",
      "c",
      "d"
    ]
  },
  "NaNTag": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "NoNaNTag": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "OverrideTag": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "DiamondOverwriteTag": {},
  "InheritDiamondOverwriteTag": {},
  "ModifyInitParams": {
    "__init__": [
      "self",
      "a"
    ]
  },
  "Buggy": {
    "__init__": [
      "self",
      "a"
    ]
  },
  "NoEstimator": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "VargEstimator": {
    "__init__": [
      "self"
    ]
  },
  "test_clone_2": [],
  "test_clone_buggy": [],
  "test_clone_empty_array": [],
  "test_clone_nan": [],
  "test_clone_dict": [],
  "test_clone_sparse_matrices": [],
  "test_clone_estimator_types": [],
  "test_clone_class_rather_than_instance": [],
  "test_conditional_attrs_not_in_dir": [],
  "test_repr": [],
  "test_str": [],
  "test_get_params": [],
  "test_is_classifier": [
    "estimator",
    "expected_result"
  ],
  "test_is_regressor": [
    "estimator",
    "expected_result"
  ],
  "test_is_clusterer": [
    "estimator",
    "expected_result"
  ],
  "test_set_params": [],
  "test_set_params_passes_all_parameters": [],
  "test_set_params_updates_valid_params": [],
  "test_score_sample_weight": [
    "tree",
    "dataset"
  ],
  "test_clone_pandas_dataframe": [],
  "test_clone_protocol": [],
  "test_pickle_version_warning_is_not_raised_with_matching_version": [],
  "TreeBadVersion": {
    "__getstate__": [
      "self"
    ]
  },
  "pickle_error_message": [],
  "test_pickle_version_warning_is_issued_upon_different_version": [],
  "TreeNoVersion": {
    "__getstate__": [
      "self"
    ]
  },
  "test_pickle_version_warning_is_issued_when_no_version_info_in_pickle": [],
  "test_pickle_version_no_warning_is_issued_with_non_sklearn_estimator": [],
  "DontPickleAttributeMixin": {
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "MultiInheritanceEstimator": {
    "__init__": [
      "self",
      "attribute_pickled"
    ]
  },
  "test_pickling_when_getstate_is_overwritten_by_mixin": [],
  "test_pickling_when_getstate_is_overwritten_by_mixin_outside_of_sklearn": [],
  "SingleInheritanceEstimator": {
    "__init__": [
      "self",
      "attribute_pickled"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "test_pickling_works_when_getstate_is_overwritten_in_the_child_class": [],
  "test_tag_inheritance": [],
  "test_raises_on_get_params_non_attribute": [],
  "test_repr_mimebundle_": [],
  "test_repr_html_wraps": [],
  "test_n_features_in_validation": [],
  "test_n_features_in_no_validation": [],
  "test_feature_names_in": [],
  "test_validate_data_skip_check_array": [],
  "test_clone_keeps_output_config": [],
  "_Empty": {},
  "EmptyEstimator": {},
  "test_estimator_empty_instance_dict": [
    "estimator"
  ],
  "test_estimator_getstate_using_slots_error_message": [],
  "test_dataframe_protocol": [
    "constructor_name",
    "minversion"
  ],
  "test_transformer_fit_transform_with_metadata_in_transform": [],
  "test_outlier_mixin_fit_predict_with_metadata_in_predict": [],
  "test_get_params_html": [],
  "make_estimator_with_param": [
    "default_value"
  ],
  "test_param_is_non_default": [
    "default_value",
    "test_value"
  ],
  "test_param_is_non_default_when_pandas_NA": [],
  "test_param_is_default": [
    "default_value",
    "test_value"
  ],
  "test_raise_build_error": [],
  "auc": [
    "x",
    "y"
  ],
  "average_precision_score": [
    "y_true",
    "y_score"
  ],
  "det_curve": [
    "y_true",
    "y_score",
    "pos_label",
    "sample_weight",
    "drop_intermediate"
  ],
  "_binary_roc_auc_score": [
    "y_true",
    "y_score",
    "sample_weight",
    "max_fpr"
  ],
  "roc_auc_score": [
    "y_true",
    "y_score"
  ],
  "_multiclass_roc_auc_score": [
    "y_true",
    "y_score",
    "labels",
    "multi_class",
    "average",
    "sample_weight"
  ],
  "confusion_matrix_at_thresholds": [
    "y_true",
    "y_score",
    "pos_label",
    "sample_weight"
  ],
  "precision_recall_curve": [
    "y_true",
    "y_score"
  ],
  "roc_curve": [
    "y_true",
    "y_score"
  ],
  "label_ranking_average_precision_score": [
    "y_true",
    "y_score"
  ],
  "coverage_error": [
    "y_true",
    "y_score"
  ],
  "label_ranking_loss": [
    "y_true",
    "y_score"
  ],
  "_dcg_sample_scores": [
    "y_true",
    "y_score",
    "k",
    "log_base",
    "ignore_ties"
  ],
  "_tie_averaged_dcg": [
    "y_true",
    "y_score",
    "discount_cumsum"
  ],
  "_check_dcg_target_type": [
    "y_true"
  ],
  "dcg_score": [
    "y_true",
    "y_score"
  ],
  "_ndcg_sample_scores": [
    "y_true",
    "y_score",
    "k",
    "ignore_ties"
  ],
  "ndcg_score": [
    "y_true",
    "y_score"
  ],
  "top_k_accuracy_score": [
    "y_true",
    "y_score"
  ],
  "_average_binary_score": [
    "binary_metric",
    "y_true",
    "y_score",
    "average",
    "sample_weight"
  ],
  "_average_multiclass_ovo_score": [
    "binary_metric",
    "y_true",
    "y_score",
    "average"
  ],
  "_cached_call": [
    "cache",
    "estimator",
    "response_method"
  ],
  "_get_func_repr_or_name": [
    "func"
  ],
  "_MultimetricScorer": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "estimator"
    ],
    "__repr__": [
      "self"
    ],
    "_accept_sample_weight": [
      "self"
    ],
    "_use_cache": [
      "self",
      "estimator"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_BaseScorer": {
    "__init__": [
      "self",
      "score_func",
      "sign",
      "kwargs",
      "response_method"
    ],
    "_get_pos_label": [
      "self"
    ],
    "_accept_sample_weight": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_routing_repr": [
      "self"
    ],
    "__call__": [
      "self",
      "estimator",
      "X",
      "y_true",
      "sample_weight"
    ],
    "_warn_overlap": [
      "self",
      "message",
      "kwargs"
    ],
    "set_score_request": [
      "self"
    ]
  },
  "_Scorer": {
    "_score": [
      "self",
      "method_caller",
      "estimator",
      "X",
      "y_true"
    ]
  },
  "get_scorer": [
    "scoring"
  ],
  "_PassthroughScorer": {
    "__init__": [
      "self",
      "estimator"
    ],
    "__call__": [
      "self",
      "estimator"
    ],
    "__repr__": [
      "self"
    ],
    "_routing_repr": [
      "self"
    ],
    "_accept_sample_weight": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_check_multimetric_scoring": [
    "estimator",
    "scoring"
  ],
  "_get_response_method_name": [
    "response_method"
  ],
  "make_scorer": [
    "score_func"
  ],
  "explained_variance_scorer": [],
  "r2_scorer": [],
  "neg_max_error_scorer": [],
  "neg_mean_squared_error_scorer": [],
  "neg_mean_squared_log_error_scorer": [],
  "neg_mean_absolute_error_scorer": [],
  "neg_mean_absolute_percentage_error_scorer": [],
  "neg_median_absolute_error_scorer": [],
  "neg_root_mean_squared_error_scorer": [],
  "neg_root_mean_squared_log_error_scorer": [],
  "neg_mean_poisson_deviance_scorer": [],
  "neg_mean_gamma_deviance_scorer": [],
  "d2_absolute_error_scorer": [],
  "d2_brier_score_scorer": [],
  "d2_log_loss_scorer": [],
  "accuracy_scorer": [],
  "balanced_accuracy_scorer": [],
  "matthews_corrcoef_scorer": [],
  "positive_likelihood_ratio": [
    "y_true",
    "y_pred"
  ],
  "negative_likelihood_ratio": [
    "y_true",
    "y_pred"
  ],
  "positive_likelihood_ratio_scorer": [],
  "neg_negative_likelihood_ratio_scorer": [],
  "top_k_accuracy_scorer": [],
  "roc_auc_scorer": [],
  "average_precision_scorer": [],
  "roc_auc_ovo_scorer": [],
  "roc_auc_ovo_weighted_scorer": [],
  "roc_auc_ovr_scorer": [],
  "roc_auc_ovr_weighted_scorer": [],
  "neg_log_loss_scorer": [],
  "neg_brier_score_scorer": [],
  "brier_score_loss_scorer": [],
  "adjusted_rand_scorer": [],
  "rand_scorer": [],
  "homogeneity_scorer": [],
  "completeness_scorer": [],
  "v_measure_scorer": [],
  "mutual_info_scorer": [],
  "adjusted_mutual_info_scorer": [],
  "normalized_mutual_info_scorer": [],
  "fowlkes_mallows_scorer": [],
  "_SCORERS": [],
  "get_scorer_names": [],
  "check_scoring": [
    "estimator",
    "scoring"
  ],
  "_threshold_scores_to_class_labels": [
    "y_score",
    "threshold",
    "classes",
    "pos_label"
  ],
  "_CurveScorer": {
    "__init__": [
      "self",
      "score_func",
      "sign",
      "kwargs",
      "thresholds",
      "response_method"
    ],
    "from_scorer": [
      "cls",
      "scorer",
      "response_method",
      "thresholds"
    ],
    "_score": [
      "self",
      "method_caller",
      "estimator",
      "X",
      "y_true"
    ]
  },
  "__ALL__": [],
  "_check_reg_targets": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "dtype",
    "xp"
  ],
  "_check_reg_targets_with_floating_dtype": [
    "y_true",
    "y_pred",
    "sample_weight",
    "multioutput",
    "xp"
  ],
  "mean_absolute_error": [
    "y_true",
    "y_pred"
  ],
  "mean_pinball_loss": [
    "y_true",
    "y_pred"
  ],
  "mean_absolute_percentage_error": [
    "y_true",
    "y_pred"
  ],
  "mean_squared_error": [
    "y_true",
    "y_pred"
  ],
  "root_mean_squared_error": [
    "y_true",
    "y_pred"
  ],
  "mean_squared_log_error": [
    "y_true",
    "y_pred"
  ],
  "root_mean_squared_log_error": [
    "y_true",
    "y_pred"
  ],
  "median_absolute_error": [
    "y_true",
    "y_pred"
  ],
  "_assemble_r2_explained_variance": [
    "numerator",
    "denominator",
    "n_outputs",
    "multioutput",
    "force_finite",
    "xp",
    "device"
  ],
  "explained_variance_score": [
    "y_true",
    "y_pred"
  ],
  "r2_score": [
    "y_true",
    "y_pred"
  ],
  "max_error": [
    "y_true",
    "y_pred"
  ],
  "_mean_tweedie_deviance": [
    "y_true",
    "y_pred",
    "sample_weight",
    "power"
  ],
  "mean_tweedie_deviance": [
    "y_true",
    "y_pred"
  ],
  "mean_poisson_deviance": [
    "y_true",
    "y_pred"
  ],
  "mean_gamma_deviance": [
    "y_true",
    "y_pred"
  ],
  "d2_tweedie_score": [
    "y_true",
    "y_pred"
  ],
  "d2_pinball_score": [
    "y_true",
    "y_pred"
  ],
  "d2_absolute_error_score": [
    "y_true",
    "y_pred"
  ],
  "_check_zero_division": [
    "zero_division"
  ],
  "_check_targets": [
    "y_true",
    "y_pred",
    "sample_weight"
  ],
  "_one_hot_encoding_multiclass_target": [
    "y_true",
    "labels",
    "target_xp",
    "target_device"
  ],
  "_validate_multiclass_probabilistic_prediction": [
    "y_true",
    "y_prob",
    "sample_weight",
    "labels"
  ],
  "accuracy_score": [
    "y_true",
    "y_pred"
  ],
  "confusion_matrix": [
    "y_true",
    "y_pred"
  ],
  "multilabel_confusion_matrix": [
    "y_true",
    "y_pred"
  ],
  "cohen_kappa_score": [
    "y1",
    "y2"
  ],
  "jaccard_score": [
    "y_true",
    "y_pred"
  ],
  "matthews_corrcoef": [
    "y_true",
    "y_pred"
  ],
  "zero_one_loss": [
    "y_true",
    "y_pred"
  ],
  "f1_score": [
    "y_true",
    "y_pred"
  ],
  "fbeta_score": [
    "y_true",
    "y_pred"
  ],
  "_prf_divide": [
    "numerator",
    "denominator",
    "metric",
    "modifier",
    "average",
    "warn_for",
    "zero_division"
  ],
  "_warn_prf": [
    "average",
    "modifier",
    "msg_start",
    "result_size"
  ],
  "_check_set_wise_labels": [
    "y_true",
    "y_pred",
    "average",
    "labels",
    "pos_label"
  ],
  "precision_recall_fscore_support": [
    "y_true",
    "y_pred"
  ],
  "class_likelihood_ratios": [
    "y_true",
    "y_pred"
  ],
  "precision_score": [
    "y_true",
    "y_pred"
  ],
  "recall_score": [
    "y_true",
    "y_pred"
  ],
  "balanced_accuracy_score": [
    "y_true",
    "y_pred"
  ],
  "classification_report": [
    "y_true",
    "y_pred"
  ],
  "hamming_loss": [
    "y_true",
    "y_pred"
  ],
  "_log_loss": [
    "transformed_labels",
    "y_pred"
  ],
  "hinge_loss": [
    "y_true",
    "pred_decision"
  ],
  "_one_hot_encoding_binary_target": [
    "y_true",
    "pos_label",
    "target_xp",
    "target_device"
  ],
  "_validate_binary_probabilistic_prediction": [
    "y_true",
    "y_prob",
    "sample_weight",
    "pos_label"
  ],
  "brier_score_loss": [
    "y_true",
    "y_proba"
  ],
  "d2_log_loss_score": [
    "y_true",
    "y_pred"
  ],
  "d2_brier_score": [
    "y_true",
    "y_proba"
  ],
  "_return_float_dtype": [
    "X",
    "Y"
  ],
  "_find_floating_dtype_allow_sparse": [
    "X",
    "Y",
    "xp"
  ],
  "check_pairwise_arrays": [
    "X",
    "Y"
  ],
  "check_paired_arrays": [
    "X",
    "Y"
  ],
  "euclidean_distances": [
    "X",
    "Y"
  ],
  "_euclidean_distances": [
    "X",
    "Y",
    "X_norm_squared",
    "Y_norm_squared",
    "squared"
  ],
  "nan_euclidean_distances": [
    "X",
    "Y"
  ],
  "_euclidean_distances_upcast": [
    "X",
    "XX",
    "Y",
    "YY",
    "batch_size"
  ],
  "_argmin_min_reduce": [
    "dist",
    "start"
  ],
  "_argmin_reduce": [
    "dist",
    "start"
  ],
  "_VALID_METRICS": [],
  "_NAN_METRICS": [],
  "pairwise_distances_argmin_min": [
    "X",
    "Y"
  ],
  "pairwise_distances_argmin": [
    "X",
    "Y"
  ],
  "haversine_distances": [
    "X",
    "Y"
  ],
  "manhattan_distances": [
    "X",
    "Y"
  ],
  "cosine_distances": [
    "X",
    "Y"
  ],
  "paired_euclidean_distances": [
    "X",
    "Y"
  ],
  "paired_manhattan_distances": [
    "X",
    "Y"
  ],
  "paired_cosine_distances": [
    "X",
    "Y"
  ],
  "PAIRED_DISTANCES": [],
  "paired_distances": [
    "X",
    "Y"
  ],
  "linear_kernel": [
    "X",
    "Y",
    "dense_output"
  ],
  "polynomial_kernel": [
    "X",
    "Y",
    "degree",
    "gamma",
    "coef0"
  ],
  "sigmoid_kernel": [
    "X",
    "Y",
    "gamma",
    "coef0"
  ],
  "rbf_kernel": [
    "X",
    "Y",
    "gamma"
  ],
  "laplacian_kernel": [
    "X",
    "Y",
    "gamma"
  ],
  "cosine_similarity": [
    "X",
    "Y",
    "dense_output"
  ],
  "additive_chi2_kernel": [
    "X",
    "Y"
  ],
  "chi2_kernel": [
    "X",
    "Y",
    "gamma"
  ],
  "PAIRWISE_DISTANCE_FUNCTIONS": [],
  "distance_metrics": [],
  "_transposed_dist_wrapper": [
    "dist_func",
    "dist_matrix",
    "slice_"
  ],
  "_parallel_pairwise": [
    "X",
    "Y",
    "func",
    "n_jobs"
  ],
  "_pairwise_callable": [
    "X",
    "Y",
    "metric",
    "ensure_all_finite"
  ],
  "_check_chunk_size": [
    "reduced",
    "chunk_size"
  ],
  "_precompute_metric_params": [
    "X",
    "Y",
    "metric"
  ],
  "pairwise_distances_chunked": [
    "X",
    "Y"
  ],
  "pairwise_distances": [
    "X",
    "Y",
    "metric"
  ],
  "PAIRWISE_BOOLEAN_FUNCTIONS": [],
  "PAIRWISE_KERNEL_FUNCTIONS": [],
  "kernel_metrics": [],
  "KERNEL_PARAMS": [],
  "pairwise_kernels": [
    "X",
    "Y",
    "metric"
  ],
  "dist_func": [
    "x1",
    "x2",
    "p"
  ],
  "d": [],
  "n1": [],
  "n2": [],
  "X64": [],
  "Y64": [],
  "X32": [],
  "Y32": [],
  "X_bool": [],
  "Y_bool": [],
  "V": [],
  "VI": [],
  "METRICS_DEFAULT_PARAMS": [],
  "test_cdist": [
    "metric_param_grid",
    "X",
    "Y",
    "csr_container"
  ],
  "test_cdist_bool_metric": [
    "metric",
    "X_bool",
    "Y_bool",
    "csr_container"
  ],
  "test_pdist": [
    "metric_param_grid",
    "X",
    "csr_container"
  ],
  "test_distance_metrics_dtype_consistency": [
    "metric_param_grid"
  ],
  "test_pdist_bool_metrics": [
    "metric",
    "X_bool",
    "csr_container"
  ],
  "test_pickle": [
    "writable_kwargs",
    "metric_param_grid",
    "X"
  ],
  "test_pickle_bool_metrics": [
    "metric",
    "X_bool"
  ],
  "test_haversine_metric": [
    "X",
    "Y",
    "csr_container"
  ],
  "test_pyfunc_metric": [],
  "test_input_data_size": [],
  "test_readonly_kwargs": [],
  "test_minkowski_metric_validate_weights_values": [
    "w",
    "err_type",
    "err_msg"
  ],
  "test_minkowski_metric_validate_weights_size": [],
  "test_get_metric_dtype": [
    "metric",
    "metric_kwargs",
    "dtype"
  ],
  "test_get_metric_bad_dtype": [],
  "test_minkowski_metric_validate_bad_p_parameter": [],
  "REGRESSION_METRICS": [],
  "CLASSIFICATION_METRICS": [],
  "precision_recall_curve_padded_thresholds": [],
  "CURVE_METRICS": [],
  "CONTINUOUS_CLASSIFICATION_METRICS": [],
  "ALL_METRICS": [],
  "METRIC_UNDEFINED_BINARY": [],
  "METRIC_UNDEFINED_MULTICLASS": [],
  "METRIC_UNDEFINED_BINARY_MULTICLASS": [],
  "METRICS_WITH_AVERAGING": [],
  "CONTINOUS_CLASSIFICATION_METRICS_WITH_AVERAGING": [],
  "METRICS_WITH_POS_LABEL": [],
  "METRICS_WITH_LABELS": [],
  "METRICS_WITH_NORMALIZE_OPTION": [],
  "CONTINUOUS_MULTILABEL_METRICS": [],
  "MULTILABELS_METRICS": [],
  "MULTIOUTPUT_METRICS": [],
  "SYMMETRIC_METRICS": [],
  "NOT_SYMMETRIC_METRICS": [],
  "METRICS_WITHOUT_SAMPLE_WEIGHT": [],
  "METRICS_REQUIRE_POSITIVE_Y": [],
  "METRICS_WITH_LOG1P_Y": [],
  "_require_positive_targets": [
    "y1",
    "y2"
  ],
  "_require_log1p_targets": [
    "y1",
    "y2"
  ],
  "test_symmetry_consistency": [],
  "test_symmetric_metric": [
    "name"
  ],
  "test_not_symmetric_metric": [
    "name"
  ],
  "test_symmetry_tests": [],
  "test_sample_order_invariance": [
    "name"
  ],
  "test_sample_order_invariance_multilabel_and_multioutput": [],
  "test_format_invariance_with_1d_vectors": [
    "name"
  ],
  "CLASSIFICATION_METRICS_REPORT": [],
  "test_classification_metrics_raise_on_empty_input": [
    "metric"
  ],
  "test_classification_with_invalid_sample_weight": [
    "metric"
  ],
  "test_classification_invariance_string_vs_numbers_labels": [
    "name"
  ],
  "test_continuous_classification_invariance_string_vs_numbers_labels": [
    "name"
  ],
  "invalids_nan_inf": [],
  "test_continuous_inf_nan_input": [
    "metric",
    "y_true",
    "y_score"
  ],
  "test_classification_inf_nan_input": [
    "metric",
    "y_true",
    "y_score"
  ],
  "test_classification_binary_continuous_input": [
    "metric"
  ],
  "check_single_sample": [
    "name"
  ],
  "check_single_sample_multioutput": [
    "name"
  ],
  "test_single_sample": [
    "name"
  ],
  "test_single_sample_multioutput": [
    "name"
  ],
  "test_multioutput_number_of_output_differ": [
    "name"
  ],
  "test_multioutput_regression_invariance_to_dimension_shuffling": [
    "name"
  ],
  "test_multilabel_representation_invariance": [
    "coo_container"
  ],
  "test_raise_value_error_multilabel_sequences": [
    "name"
  ],
  "test_normalize_option_binary_classification": [
    "name"
  ],
  "test_normalize_option_multiclass_classification": [
    "name"
  ],
  "test_normalize_option_multilabel_classification": [
    "name"
  ],
  "_check_averaging": [
    "metric",
    "y_true",
    "y_pred",
    "y_true_binarize",
    "y_pred_binarize",
    "is_multilabel"
  ],
  "check_averaging": [
    "name",
    "y_true",
    "y_true_binarize",
    "y_pred",
    "y_pred_binarize",
    "y_score"
  ],
  "test_averaging_multiclass": [
    "name"
  ],
  "test_averaging_multilabel": [
    "name"
  ],
  "test_averaging_multilabel_all_zeroes": [
    "name"
  ],
  "test_averaging_binary_multilabel_all_zeroes": [],
  "test_averaging_multilabel_all_ones": [
    "name"
  ],
  "check_sample_weight_invariance": [
    "name",
    "metric",
    "y1",
    "y2",
    "sample_weight"
  ],
  "test_regression_sample_weight_invariance": [
    "name"
  ],
  "test_regression_with_invalid_sample_weight": [
    "name"
  ],
  "test_binary_sample_weight_invariance": [
    "name"
  ],
  "test_multiclass_sample_weight_invariance": [
    "name"
  ],
  "test_multilabel_sample_weight_invariance": [
    "name"
  ],
  "test_multioutput_sample_weight_invariance": [
    "name"
  ],
  "test_no_averaging_labels": [],
  "test_multilabel_label_permutations_invariance": [
    "name"
  ],
  "test_continuous_multilabel_multioutput_permutations_invariance": [
    "name"
  ],
  "test_continuous_metric_permutation_invariance": [
    "name"
  ],
  "test_metrics_consistent_type_error": [
    "metric_name"
  ],
  "test_metrics_pos_label_error_str": [
    "metric",
    "y_pred_threshold",
    "dtype_y_str"
  ],
  "check_array_api_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name",
    "a_np",
    "b_np"
  ],
  "check_array_api_binary_classification_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "check_array_api_multiclass_classification_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "check_array_api_multilabel_classification_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "check_array_api_regression_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "check_array_api_regression_metric_multioutput": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "check_array_api_metric_pairwise": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "array_api_metric_checkers": [],
  "yield_metric_checker_combinations": [
    "metric_checkers"
  ],
  "test_array_api_compliance": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name",
    "check_func"
  ],
  "test_metrics_dataframe_series": [
    "metric_name",
    "df_lib_name"
  ],
  "_get_metric_kwargs_for_array_api_testing": [
    "metric",
    "params"
  ],
  "test_returned_value_consistency": [
    "name"
  ],
  "make_prediction": [
    "dataset",
    "binary"
  ],
  "test_classification_report_dictionary_output": [],
  "test_classification_report_zero_division_warning": [
    "zero_division"
  ],
  "test_classification_report_labels_subset_superset": [
    "labels",
    "show_micro_avg"
  ],
  "test_multilabel_accuracy_score_subset_accuracy": [],
  "test_precision_recall_f1_score_binary": [],
  "test_precision_recall_f_binary_single_class": [],
  "test_precision_recall_f_extra_labels": [],
  "test_precision_recall_f_ignored_labels": [],
  "test_average_precision_score_non_binary_class": [],
  "test_average_precision_score_duplicate_values": [
    "y_true",
    "y_score"
  ],
  "test_average_precision_score_tied_values": [
    "y_true",
    "y_score"
  ],
  "test_precision_recall_f_unused_pos_label": [],
  "test_confusion_matrix_binary": [],
  "test_multilabel_confusion_matrix_binary": [],
  "test_multilabel_confusion_matrix_multiclass": [],
  "test_multilabel_confusion_matrix_multilabel": [
    "csc_container",
    "csr_container"
  ],
  "test_multilabel_confusion_matrix_errors": [],
  "test_confusion_matrix_normalize": [
    "normalize",
    "cm_dtype",
    "expected_results"
  ],
  "test_confusion_matrix_normalize_single_class": [],
  "test_confusion_matrix_single_label": [],
  "test_likelihood_ratios_warnings": [
    "params",
    "warn_msg"
  ],
  "test_likelihood_ratios_errors": [
    "params",
    "err_msg"
  ],
  "test_likelihood_ratios": [],
  "test_likelihood_ratios_raise_warning_deprecation": [
    "raise_warning"
  ],
  "test_likelihood_ratios_replace_undefined_by_worst": [],
  "test_likelihood_ratios_wrong_dict_replace_undefined_by": [
    "replace_undefined_by"
  ],
  "test_likelihood_ratios_replace_undefined_by_0_fp": [
    "replace_undefined_by",
    "expected"
  ],
  "test_likelihood_ratios_replace_undefined_by_0_tn": [
    "replace_undefined_by",
    "expected"
  ],
  "test_cohen_kappa": [],
  "test_cohen_kappa_score_error_wrong_label": [],
  "test_zero_division_nan_no_warning": [
    "metric",
    "y_true",
    "y_pred",
    "zero_division"
  ],
  "test_zero_division_nan_warning": [
    "metric",
    "y_true",
    "y_pred"
  ],
  "test_matthews_corrcoef_against_numpy_corrcoef": [
    "global_random_seed"
  ],
  "test_matthews_corrcoef_against_jurman": [
    "global_random_seed"
  ],
  "test_matthews_corrcoef": [
    "global_random_seed"
  ],
  "test_matthews_corrcoef_multiclass": [
    "global_random_seed"
  ],
  "test_matthews_corrcoef_overflow": [
    "n_points",
    "global_random_seed"
  ],
  "test_precision_recall_f1_score_multiclass": [],
  "test_precision_refcall_f1_score_multilabel_unordered_labels": [
    "average"
  ],
  "test_precision_recall_f1_score_binary_averaged": [],
  "test_zero_precision_recall": [],
  "test_confusion_matrix_multiclass_subset_labels": [],
  "test_confusion_matrix_error": [
    "labels",
    "err_msg"
  ],
  "test_confusion_matrix_dtype": [],
  "test_confusion_matrix_pandas_nullable": [
    "dtype"
  ],
  "test_classification_report_multiclass": [],
  "test_classification_report_multiclass_balanced": [],
  "test_classification_report_multiclass_with_label_detection": [],
  "test_classification_report_multiclass_with_digits": [],
  "test_classification_report_multiclass_with_string_label": [],
  "test_classification_report_multiclass_with_unicode_label": [],
  "test_classification_report_multiclass_with_long_string_label": [],
  "test_classification_report_labels_target_names_unequal_length": [],
  "test_classification_report_no_labels_target_names_unequal_length": [],
  "test_multilabel_classification_report": [],
  "test_multilabel_zero_one_loss_subset": [],
  "test_multilabel_hamming_loss": [],
  "test_jaccard_score_validation": [],
  "test_multilabel_jaccard_score": [
    "recwarn"
  ],
  "test_multiclass_jaccard_score": [
    "recwarn"
  ],
  "test_average_binary_jaccard_score": [
    "recwarn"
  ],
  "test_jaccard_score_zero_division_warning": [],
  "test_jaccard_score_zero_division_set_value": [
    "zero_division",
    "expected_score"
  ],
  "test_precision_recall_f1_score_multilabel_1": [],
  "test_precision_recall_f1_score_multilabel_2": [],
  "test_precision_recall_f1_score_with_an_empty_prediction": [
    "zero_division",
    "zero_division_expected"
  ],
  "test_precision_recall_f1_no_labels": [
    "beta",
    "average",
    "zero_division"
  ],
  "test_precision_recall_f1_no_labels_check_warnings": [
    "average"
  ],
  "test_precision_recall_f1_no_labels_average_none": [
    "zero_division"
  ],
  "test_precision_recall_f1_no_labels_average_none_warn": [],
  "test_prf_warnings": [],
  "test_prf_no_warnings_if_zero_division_set": [
    "zero_division"
  ],
  "test_recall_warnings": [
    "zero_division"
  ],
  "test_precision_warnings": [
    "zero_division"
  ],
  "test_fscore_warnings": [
    "zero_division"
  ],
  "test_prf_average_binary_data_non_binary": [],
  "test__check_targets": [],
  "test__check_targets_raises_on_empty_inputs": [],
  "test__check_targets_multiclass_with_both_y_true_and_y_pred_binary": [],
  "test__check_targets_sparse_inputs": [
    "y",
    "target_type"
  ],
  "test_hinge_loss_binary": [],
  "test_hinge_loss_multiclass": [],
  "test_hinge_loss_multiclass_missing_labels_with_labels_none": [],
  "test_hinge_loss_multiclass_no_consistent_pred_decision_shape": [],
  "test_hinge_loss_multiclass_with_missing_labels": [],
  "test_hinge_loss_multiclass_missing_labels_only_two_unq_in_y_true": [],
  "test_hinge_loss_multiclass_invariance_lists": [],
  "test_log_loss": [],
  "test_log_loss_eps": [
    "dtype"
  ],
  "test_log_loss_not_probabilities_warning": [
    "dtype"
  ],
  "test_log_loss_perfect_predictions": [
    "y_true",
    "y_pred"
  ],
  "test_log_loss_pandas_input": [],
  "test_log_loss_warnings": [],
  "test_brier_score_loss_binary": [],
  "test_brier_score_loss_multiclass": [],
  "test_brier_score_loss_invalid_inputs": [],
  "test_brier_score_loss_warnings": [],
  "test_balanced_accuracy_score_unseen": [],
  "test_balanced_accuracy_score": [
    "y_true",
    "y_pred"
  ],
  "test_classification_metric_pos_label_types": [
    "metric",
    "classes"
  ],
  "test_f1_for_small_binary_inputs_with_zero_division": [
    "y_true",
    "y_pred",
    "expected_score"
  ],
  "test_classification_metric_division_by_zero_nan_validaton": [
    "scoring"
  ],
  "test_d2_log_loss_score": [],
  "test_d2_log_loss_score_missing_labels": [],
  "test_d2_log_loss_score_label_order": [],
  "test_d2_log_loss_score_raises": [],
  "test_d2_brier_score": [],
  "test_d2_brier_score_with_labels": [],
  "test_d2_brier_score_raises": [
    "y_true",
    "y_pred",
    "labels",
    "error_msg"
  ],
  "test_d2_brier_score_warning_on_less_than_two_samples": [],
  "test_confusion_matrix_array_api": [
    "array_namespace",
    "device",
    "_"
  ],
  "test_probabilistic_metrics_array_api": [
    "prob_metric",
    "str_y_true",
    "use_sample_weight",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_probabilistic_metrics_multilabel_array_api": [
    "prob_metric",
    "use_sample_weight",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_regression_metrics": [
    "n_samples"
  ],
  "test_root_mean_squared_error_multioutput_raw_value": [],
  "test_regression_metrics_at_limits": [],
  "test__check_reg_targets": [],
  "test__check_reg_targets_exception": [],
  "test_regression_multioutput_array": [],
  "test_regression_custom_weights": [],
  "test_regression_single_sample": [
    "metric"
  ],
  "test_tweedie_deviance_continuity": [
    "global_random_seed"
  ],
  "test_mean_absolute_percentage_error": [
    "global_random_seed"
  ],
  "test_mean_pinball_loss_on_constant_predictions": [
    "distribution",
    "target_quantile",
    "global_random_seed"
  ],
  "test_dummy_quantile_parameter_tuning": [
    "global_random_seed"
  ],
  "test_pinball_loss_relation_with_mae": [
    "global_random_seed"
  ],
  "REGRESSION_SCORERS": [],
  "CLF_SCORERS": [],
  "CLUSTER_SCORERS": [],
  "MULTILABEL_ONLY_SCORERS": [],
  "REQUIRE_POSITIVE_Y_SCORERS": [],
  "_require_positive_y": [
    "y"
  ],
  "_make_estimators": [
    "X_train",
    "y_train",
    "y_ml_train"
  ],
  "memmap_data_and_estimators": [
    "tmp_path_factory"
  ],
  "EstimatorWithFit": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "EstimatorWithFitAndScore": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "EstimatorWithFitAndPredict": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "DummyScorer": {
    "__call__": [
      "self",
      "est",
      "X",
      "y"
    ]
  },
  "test_all_scorers_repr": [],
  "test_repr_partial": [],
  "check_scoring_validator_for_single_metric_usecases": [
    "scoring_validator"
  ],
  "test_check_scoring_and_check_multimetric_scoring": [
    "scoring"
  ],
  "test_check_scoring_and_check_multimetric_scoring_errors": [
    "scoring",
    "msg"
  ],
  "test_check_scoring_gridsearchcv": [],
  "test_classification_binary_scores": [
    "scorer_name",
    "metric"
  ],
  "test_classification_multiclass_scores": [
    "scorer_name",
    "metric"
  ],
  "test_custom_scorer_pickling": [],
  "test_regression_scorers": [],
  "test_thresholded_scorers": [],
  "test_thresholded_scorers_multilabel_indicator_data": [],
  "test_supervised_cluster_scorers": [],
  "test_raises_on_score_list": [],
  "test_classification_scorer_sample_weight": [],
  "test_regression_scorer_sample_weight": [],
  "test_scorer_memmap_input": [
    "name",
    "memmap_data_and_estimators"
  ],
  "test_scoring_is_not_metric": [],
  "test_multimetric_scorer_calls_method_once": [
    "scorers",
    "expected_predict_count",
    "expected_predict_proba_count",
    "expected_decision_func_count"
  ],
  "test_multimetric_scorer_calls_method_once_classifier_no_decision": [
    "scorers"
  ],
  "test_multimetric_scorer_calls_method_once_regressor_threshold": [],
  "test_multimetric_scorer_sanity_check": [],
  "test_multimetric_scorer_exception_handling": [
    "raise_exc"
  ],
  "test_multiclass_roc_proba_scorer": [
    "scorer_name",
    "metric"
  ],
  "test_multiclass_roc_proba_scorer_label": [],
  "test_multiclass_roc_no_proba_scorer_errors": [
    "scorer_name"
  ],
  "string_labeled_classification_problem": [],
  "test_average_precision_pos_label": [
    "string_labeled_classification_problem"
  ],
  "test_brier_score_loss_pos_label": [
    "string_labeled_classification_problem"
  ],
  "test_non_symmetric_metric_pos_label": [
    "score_func",
    "string_labeled_classification_problem"
  ],
  "test_scorer_select_proba_error": [
    "scorer"
  ],
  "test_get_scorer_return_copy": [],
  "test_scorer_no_op_multiclass_select_proba": [],
  "test_scorer_set_score_request_raises": [
    "name"
  ],
  "test_scorer_metadata_request": [
    "name"
  ],
  "test_metadata_kwarg_conflict": [],
  "test_PassthroughScorer_set_score_request": [],
  "test_PassthroughScorer_set_score_request_raises_without_routing_enabled": [],
  "test_multimetric_scoring_metadata_routing": [],
  "test_multimetric_scoring_kwargs": [],
  "test_kwargs_without_metadata_routing_error": [],
  "test_get_scorer_multilabel_indicator": [],
  "test_make_scorer_repr": [
    "scorer",
    "expected_repr"
  ],
  "test_get_scorer_multimetric": [
    "pass_estimator"
  ],
  "test_multimetric_scorer_repr": [],
  "test_check_scoring_multimetric_raise_exc": [],
  "test_metadata_routing_multimetric_metadata_routing": [
    "enable_metadata_routing"
  ],
  "test_curve_scorer": [],
  "test_curve_scorer_pos_label": [
    "global_random_seed"
  ],
  "test_Pipeline_in_PassthroughScorer": [],
  "CURVE_FUNCS": [],
  "_auc": [
    "y_true",
    "y_score"
  ],
  "_average_precision": [
    "y_true",
    "y_score"
  ],
  "_average_precision_slow": [
    "y_true",
    "y_score"
  ],
  "_partial_roc_auc_score": [
    "y_true",
    "y_predict",
    "max_fpr"
  ],
  "test_confusion_matrix_at_thresholds": [
    "global_random_seed"
  ],
  "test_roc_curve": [
    "drop"
  ],
  "test_roc_curve_end_points": [],
  "test_roc_returns_consistency": [],
  "test_roc_curve_multi": [],
  "test_roc_curve_confidence": [],
  "test_roc_curve_hard": [],
  "test_roc_curve_one_label": [],
  "test_roc_curve_toydata": [],
  "test_roc_curve_drop_intermediate": [],
  "test_roc_curve_fpr_tpr_increasing": [],
  "test_auc": [],
  "test_auc_errors": [],
  "test_multiclass_ovo_roc_auc_toydata": [
    "y_true",
    "labels"
  ],
  "test_multiclass_ovo_roc_auc_toydata_binary": [
    "y_true",
    "labels"
  ],
  "test_multiclass_ovr_roc_auc_toydata": [
    "y_true",
    "labels"
  ],
  "test_perfect_imperfect_chance_multiclass_roc_auc": [
    "multi_class",
    "average"
  ],
  "test_micro_averaged_ovr_roc_auc": [
    "global_random_seed"
  ],
  "test_roc_auc_score_multiclass_labels_error": [
    "msg",
    "y_true",
    "labels",
    "multi_class"
  ],
  "test_roc_auc_score_multiclass_error": [
    "msg",
    "kwargs"
  ],
  "test_auc_score_non_binary_class": [],
  "test_confusion_matrix_at_thresholds_multiclass_error": [
    "curve_func"
  ],
  "test_confusion_matrix_at_thresholds_implicit_pos_label": [
    "curve_func"
  ],
  "test_confusion_matrix_at_thresholds_implicit_bytes_pos_label": [
    "curve_func",
    "labels_type"
  ],
  "test_confusion_matrix_at_thresholds_zero_sample_weight": [
    "curve_func"
  ],
  "test_precision_recall_curve": [
    "drop"
  ],
  "_test_precision_recall_curve": [
    "y_true",
    "y_score",
    "drop"
  ],
  "test_precision_recall_curve_toydata": [
    "drop"
  ],
  "test_precision_recall_curve_drop_intermediate": [],
  "test_average_precision_constant_values": [],
  "test_average_precision_score_binary_pos_label_errors": [],
  "test_average_precision_score_multilabel_pos_label_errors": [],
  "test_average_precision_score_multiclass_pos_label_errors": [],
  "test_score_scale_invariance": [],
  "test_det_curve_toydata": [
    "y_true",
    "y_score",
    "expected_fpr",
    "expected_fnr"
  ],
  "test_det_curve_drop_intermediate": [
    "y_true",
    "y_score",
    "expected_fpr",
    "expected_fnr",
    "drop_intermediate"
  ],
  "test_det_curve_tie_handling": [
    "y_true",
    "y_score",
    "expected_fpr",
    "expected_fnr"
  ],
  "test_det_curve_sanity_check": [],
  "test_det_curve_constant_scores": [
    "y_score"
  ],
  "test_det_curve_perfect_scores": [
    "y_true"
  ],
  "test_det_curve_bad_input": [
    "y_true",
    "y_pred",
    "err_msg"
  ],
  "test_det_curve_pos_label": [],
  "check_lrap_toy": [
    "lrap_score"
  ],
  "check_zero_or_all_relevant_labels": [
    "lrap_score"
  ],
  "check_lrap_error_raised": [
    "lrap_score"
  ],
  "check_lrap_only_ties": [
    "lrap_score"
  ],
  "check_lrap_without_tie_and_increasing_score": [
    "lrap_score"
  ],
  "_my_lrap": [
    "y_true",
    "y_score"
  ],
  "check_alternative_lrap_implementation": [
    "lrap_score",
    "n_classes",
    "n_samples",
    "random_state"
  ],
  "test_label_ranking_avp": [
    "check",
    "func"
  ],
  "test_lrap_error_raised": [],
  "test_alternative_lrap_implementation": [
    "n_samples",
    "n_classes",
    "random_state"
  ],
  "test_lrap_sample_weighting_zero_labels": [],
  "test_coverage_error": [],
  "test_coverage_tie_handling": [],
  "test_coverage_1d_error_message": [
    "y_true",
    "y_score"
  ],
  "test_label_ranking_loss": [],
  "test_label_ranking_loss_sparse": [
    "csr_container"
  ],
  "test_ranking_appropriate_input_shape": [],
  "test_ranking_loss_ties_handling": [],
  "test_dcg_score": [],
  "_test_dcg_score_for": [
    "y_true",
    "y_score"
  ],
  "test_dcg_ties": [],
  "test_ndcg_ignore_ties_with_k": [],
  "test_ndcg_negative_ndarray_error": [],
  "test_ndcg_invariant": [],
  "test_ndcg_toy_examples": [
    "ignore_ties"
  ],
  "test_ndcg_error_single_document": [],
  "test_ndcg_score": [],
  "_test_ndcg_score_for": [
    "y_true",
    "y_score"
  ],
  "test_partial_roc_auc_score": [],
  "test_top_k_accuracy_score": [
    "y_true",
    "k",
    "true_score"
  ],
  "test_top_k_accuracy_score_binary": [
    "y_score",
    "k",
    "true_score"
  ],
  "test_top_k_accuracy_score_multiclass_with_labels": [
    "y_true",
    "true_score",
    "labels",
    "labels_as_ndarray"
  ],
  "test_top_k_accuracy_score_increasing": [],
  "test_top_k_accuracy_score_ties": [
    "y_true",
    "k",
    "true_score"
  ],
  "test_top_k_accuracy_score_warning": [
    "y_true",
    "k"
  ],
  "test_top_k_accuracy_score_error": [
    "y_true",
    "y_score",
    "labels",
    "msg"
  ],
  "test_label_ranking_avg_precision_score_should_allow_csr_matrix_for_y_true_input": [
    "csr_container"
  ],
  "test_ranking_metric_pos_label_types": [
    "metric",
    "classes"
  ],
  "test_roc_curve_with_probablity_estimates": [
    "global_random_seed"
  ],
  "CDIST_PAIRWISE_DISTANCES_REDUCTION_COMMON_METRICS": [],
  "_get_metric_params_list": [
    "metric",
    "n_features",
    "seed"
  ],
  "assert_same_distances_for_common_neighbors": [
    "query_idx",
    "dist_row_a",
    "dist_row_b",
    "indices_row_a",
    "indices_row_b",
    "rtol",
    "atol"
  ],
  "assert_no_missing_neighbors": [
    "query_idx",
    "dist_row_a",
    "dist_row_b",
    "indices_row_a",
    "indices_row_b",
    "threshold"
  ],
  "assert_compatible_argkmin_results": [
    "neighbors_dists_a",
    "neighbors_dists_b",
    "neighbors_indices_a",
    "neighbors_indices_b",
    "rtol",
    "atol"
  ],
  "_non_trivial_radius": [],
  "assert_compatible_radius_results": [
    "neighbors_dists_a",
    "neighbors_dists_b",
    "neighbors_indices_a",
    "neighbors_indices_b",
    "radius",
    "check_sorted",
    "rtol",
    "atol"
  ],
  "FLOAT32_TOLS": [],
  "FLOAT64_TOLS": [],
  "ASSERT_RESULT": [],
  "test_assert_compatible_argkmin_results": [],
  "test_assert_compatible_radius_results": [
    "check_sorted"
  ],
  "test_pairwise_distances_reduction_is_usable_for": [
    "csr_container"
  ],
  "test_argkmin_factory_method_wrong_usages": [],
  "test_argkmin_classmode_factory_method_wrong_usages": [],
  "test_radius_neighbors_factory_method_wrong_usages": [],
  "test_radius_neighbors_classmode_factory_method_wrong_usages": [],
  "test_chunk_size_agnosticism": [
    "global_random_seed",
    "Dispatcher",
    "dtype",
    "n_features"
  ],
  "test_n_threads_agnosticism": [
    "global_random_seed",
    "Dispatcher",
    "dtype",
    "n_features"
  ],
  "test_format_agnosticism": [
    "global_random_seed",
    "Dispatcher",
    "dtype",
    "csr_container"
  ],
  "test_strategies_consistency": [
    "global_random_seed",
    "global_dtype",
    "Dispatcher",
    "n_features"
  ],
  "test_pairwise_distances_argkmin": [
    "global_random_seed",
    "metric",
    "strategy",
    "dtype",
    "csr_container",
    "n_queries",
    "n_samples",
    "k"
  ],
  "test_pairwise_distances_radius_neighbors": [
    "global_random_seed",
    "metric",
    "strategy",
    "dtype",
    "n_queries",
    "n_samples"
  ],
  "test_memmap_backed_data": [
    "metric",
    "Dispatcher",
    "dtype"
  ],
  "test_sqeuclidean_row_norms": [
    "global_random_seed",
    "dtype",
    "csr_container"
  ],
  "test_argkmin_classmode_strategy_consistent": [],
  "test_radius_neighbors_classmode_strategy_consistent": [
    "outlier_label"
  ],
  "test_pairwise_distances_for_dense_data": [
    "global_dtype"
  ],
  "test_pairwise_distances_array_api": [
    "array_namespace",
    "device",
    "dtype_name",
    "metric"
  ],
  "test_pairwise_distances_for_sparse_data": [
    "coo_container",
    "csc_container",
    "bsr_container",
    "csr_container",
    "global_dtype"
  ],
  "test_pairwise_boolean_distance": [
    "metric"
  ],
  "test_no_data_conversion_warning": [],
  "test_pairwise_precomputed": [
    "func"
  ],
  "test_pairwise_precomputed_non_negative": [],
  "_minkowski_kwds": [],
  "callable_rbf_kernel": [
    "x",
    "y"
  ],
  "test_pairwise_parallel": [
    "func",
    "metric",
    "kwds",
    "dtype"
  ],
  "test_pairwise_parallel_array_api": [
    "func",
    "metric",
    "kwds",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_pairwise_callable_nonstrict_metric": [],
  "test_pairwise_kernels": [
    "metric",
    "csr_container"
  ],
  "test_pairwise_kernels_array_api": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_pairwise_kernels_callable": [],
  "test_pairwise_kernels_filter_param": [],
  "test_paired_distances": [
    "metric",
    "func",
    "csr_container"
  ],
  "test_paired_distances_callable": [
    "global_dtype"
  ],
  "test_pairwise_distances_argmin_min": [
    "dok_container",
    "csr_container",
    "global_dtype"
  ],
  "_reduce_func": [
    "dist",
    "start"
  ],
  "test_pairwise_distances_chunked_reduce": [
    "global_dtype"
  ],
  "test_pairwise_distances_chunked_reduce_none": [
    "global_dtype"
  ],
  "test_pairwise_distances_chunked_reduce_valid": [
    "good_reduce"
  ],
  "test_pairwise_distances_chunked_reduce_invalid": [
    "global_dtype",
    "bad_reduce",
    "err_type",
    "message"
  ],
  "check_pairwise_distances_chunked": [
    "X",
    "Y",
    "working_memory",
    "metric"
  ],
  "test_pairwise_distances_chunked_diagonal": [
    "metric",
    "global_dtype"
  ],
  "test_parallel_pairwise_distances_diagonal": [
    "metric",
    "global_dtype"
  ],
  "test_pairwise_distances_chunked": [
    "global_dtype"
  ],
  "test_euclidean_distances_known_result": [
    "x_array_constr",
    "y_array_constr"
  ],
  "test_euclidean_distances_with_norms": [
    "global_dtype",
    "y_array_constr"
  ],
  "test_euclidean_distances_float32_norms": [
    "global_random_seed",
    "symmetric"
  ],
  "test_euclidean_distances_norm_shapes": [],
  "test_euclidean_distances": [
    "global_dtype",
    "x_array_constr",
    "y_array_constr"
  ],
  "test_euclidean_distances_sym": [
    "global_dtype",
    "x_array_constr"
  ],
  "test_euclidean_distances_upcast": [
    "batch_size",
    "x_array_constr",
    "y_array_constr"
  ],
  "test_euclidean_distances_upcast_sym": [
    "batch_size",
    "x_array_constr"
  ],
  "test_euclidean_distances_extreme_values": [
    "dtype",
    "eps",
    "rtol",
    "dim"
  ],
  "test_nan_euclidean_distances_equal_to_euclidean_distance": [
    "squared"
  ],
  "test_nan_euclidean_distances_infinite_values": [
    "X",
    "Y"
  ],
  "test_nan_euclidean_distances_2x2": [
    "X",
    "X_diag",
    "missing_value"
  ],
  "test_nan_euclidean_distances_complete_nan": [
    "missing_value"
  ],
  "test_nan_euclidean_distances_not_trival": [
    "missing_value"
  ],
  "test_nan_euclidean_distances_one_feature_match_positive": [
    "missing_value"
  ],
  "test_cosine_distances": [],
  "test_haversine_distances": [],
  "test_paired_euclidean_distances": [],
  "test_paired_manhattan_distances": [],
  "test_paired_cosine_distances": [],
  "test_chi_square_kernel": [],
  "test_kernel_symmetry": [
    "kernel"
  ],
  "test_kernel_sparse": [
    "kernel",
    "csr_container"
  ],
  "test_linear_kernel": [],
  "test_rbf_kernel": [],
  "test_laplacian_kernel": [],
  "test_pairwise_similarity_sparse_output": [
    "metric",
    "pairwise_func",
    "csr_container"
  ],
  "test_cosine_similarity": [
    "csr_container"
  ],
  "test_check_dense_matrices": [],
  "test_check_XB_returned": [],
  "test_check_different_dimensions": [],
  "test_check_invalid_dimensions": [],
  "test_check_sparse_arrays": [
    "csr_container"
  ],
  "tuplify": [
    "X"
  ],
  "test_check_tuple_input": [],
  "test_check_preserve_type": [],
  "test_pairwise_distances_data_derived_params": [
    "n_jobs",
    "metric",
    "dist_function"
  ],
  "test_pairwise_distances_data_derived_params_error": [
    "metric"
  ],
  "test_numeric_pairwise_distances_datatypes": [
    "metric",
    "global_dtype",
    "y_is_x"
  ],
  "test_nan_euclidean_support": [
    "pairwise_distances_func"
  ],
  "test_nan_euclidean_constant_input_argmin": [],
  "test_pairwise_dist_custom_metric_for_string": [
    "X",
    "Y",
    "expected_distance"
  ],
  "test_pairwise_dist_custom_metric_for_bool": [],
  "test_sparse_manhattan_readonly_dataset": [
    "csr_container"
  ],
  "PrecisionRecallDisplay": {
    "__init__": [
      "self",
      "precision",
      "recall"
    ],
    "plot": [
      "self",
      "ax"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_score"
    ]
  },
  "RocCurveDisplay": {
    "__init__": [
      "self"
    ],
    "_validate_plot_params": [
      "self"
    ],
    "plot": [
      "self",
      "ax"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_score"
    ],
    "from_cv_results": [
      "cls",
      "cv_results",
      "X",
      "y"
    ]
  },
  "DetCurveDisplay": {
    "__init__": [
      "self"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_score"
    ],
    "plot": [
      "self",
      "ax"
    ]
  },
  "PredictionErrorDisplay": {
    "__init__": [
      "self"
    ],
    "plot": [
      "self",
      "ax"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_pred"
    ]
  },
  "ConfusionMatrixDisplay": {
    "__init__": [
      "self",
      "confusion_matrix"
    ],
    "plot": [
      "self"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "from_predictions": [
      "cls",
      "y_true",
      "y_pred"
    ]
  },
  "test_confusion_matrix_display_validation": [
    "pyplot"
  ],
  "test_confusion_matrix_display_custom_labels": [
    "pyplot",
    "constructor_name",
    "with_labels",
    "with_display_labels"
  ],
  "test_confusion_matrix_display_plotting": [
    "pyplot",
    "constructor_name",
    "normalize",
    "include_values"
  ],
  "test_confusion_matrix_display": [
    "pyplot",
    "constructor_name"
  ],
  "test_confusion_matrix_contrast": [
    "pyplot"
  ],
  "test_confusion_matrix_pipeline": [
    "pyplot",
    "clf"
  ],
  "test_confusion_matrix_with_unknown_labels": [
    "pyplot",
    "constructor_name"
  ],
  "test_colormap_max": [
    "pyplot"
  ],
  "test_im_kw_adjust_vmin_vmax": [
    "pyplot"
  ],
  "test_confusion_matrix_text_kw": [
    "pyplot"
  ],
  "regressor_fitted": [],
  "test_prediction_error_display_raise_error": [
    "pyplot",
    "class_method",
    "regressor",
    "params",
    "err_type",
    "err_msg"
  ],
  "test_from_estimator_not_fitted": [
    "pyplot"
  ],
  "test_prediction_error_display": [
    "pyplot",
    "regressor_fitted",
    "class_method",
    "kind"
  ],
  "test_plot_prediction_error_subsample": [
    "pyplot",
    "regressor_fitted",
    "class_method",
    "subsample",
    "expected_size"
  ],
  "test_plot_prediction_error_ax": [
    "pyplot",
    "regressor_fitted",
    "class_method"
  ],
  "test_prediction_error_custom_artist": [
    "pyplot",
    "regressor_fitted",
    "class_method",
    "scatter_kwargs",
    "line_kwargs"
  ],
  "data_binary": [
    "data"
  ],
  "test_display_curve_error_classifier": [
    "pyplot",
    "data",
    "data_binary",
    "Display"
  ],
  "test_display_curve_error_regression": [
    "pyplot",
    "data_binary",
    "Display"
  ],
  "test_display_curve_error_no_response": [
    "pyplot",
    "data_binary",
    "response_method",
    "msg",
    "Display"
  ],
  "test_display_curve_estimator_name_multiple_calls": [
    "pyplot",
    "data_binary",
    "Display",
    "constructor_name"
  ],
  "test_display_curve_not_fitted_errors_old_name": [
    "pyplot",
    "data_binary",
    "clf",
    "Display"
  ],
  "test_display_curve_not_fitted_errors": [
    "pyplot",
    "data_binary",
    "clf",
    "Display"
  ],
  "test_display_curve_n_samples_consistency": [
    "pyplot",
    "data_binary",
    "Display"
  ],
  "test_display_curve_error_pos_label": [
    "pyplot",
    "data_binary",
    "Display"
  ],
  "test_classifier_display_curve_named_constructor_return_type": [
    "pyplot",
    "data_binary",
    "Display",
    "constructor"
  ],
  "test_display_estimator_name_deprecation": [
    "pyplot",
    "Display",
    "display_kwargs"
  ],
  "test_det_curve_display": [
    "pyplot",
    "constructor_name",
    "response_method",
    "with_sample_weight",
    "drop_intermediate",
    "with_strings"
  ],
  "test_det_curve_display_default_name": [
    "pyplot",
    "constructor_name",
    "expected_clf_name"
  ],
  "test_y_score_and_y_pred_specified_error": [
    "pyplot"
  ],
  "test_precision_recall_display_plotting": [
    "pyplot",
    "constructor_name",
    "response_method",
    "drop_intermediate"
  ],
  "test_precision_recall_chance_level_line": [
    "pyplot",
    "chance_level_kw",
    "constructor_name"
  ],
  "test_precision_recall_display_name": [
    "pyplot",
    "constructor_name",
    "default_label"
  ],
  "test_precision_recall_display_pipeline": [
    "pyplot",
    "clf"
  ],
  "test_precision_recall_display_string_labels": [
    "pyplot"
  ],
  "test_default_labels": [
    "pyplot",
    "average_precision",
    "name",
    "expected_label"
  ],
  "test_plot_precision_recall_pos_label": [
    "pyplot",
    "constructor_name",
    "response_method"
  ],
  "test_precision_recall_prevalence_pos_label_reusable": [
    "pyplot",
    "constructor_name"
  ],
  "test_precision_recall_raise_no_prevalence": [
    "pyplot"
  ],
  "test_plot_precision_recall_despine": [
    "pyplot",
    "despine",
    "constructor_name"
  ],
  "_check_figure_axes_and_labels": [
    "display",
    "pos_label"
  ],
  "test_roc_curve_display_plotting": [
    "pyplot",
    "response_method",
    "data_binary",
    "with_sample_weight",
    "drop_intermediate",
    "with_strings",
    "constructor_name",
    "default_name"
  ],
  "test_roc_curve_plot_parameter_length_validation": [
    "pyplot",
    "params",
    "err_msg"
  ],
  "test_validate_plot_params": [
    "pyplot"
  ],
  "test_roc_curve_from_cv_results_param_validation": [
    "pyplot",
    "data_binary"
  ],
  "test_roc_curve_display_from_cv_results_curve_kwargs": [
    "pyplot",
    "data_binary",
    "curve_kwargs"
  ],
  "test_roc_curve_display_kwargs_deprecation": [
    "pyplot",
    "data_binary",
    "constructor_name"
  ],
  "test_roc_curve_display_plotting_from_cv_results": [
    "pyplot",
    "data_binary",
    "with_strings",
    "with_sample_weight",
    "response_method",
    "drop_intermediate",
    "curve_kwargs"
  ],
  "test_roc_curve_plot_legend_label": [
    "pyplot",
    "data_binary",
    "name",
    "curve_kwargs",
    "roc_auc"
  ],
  "test_roc_curve_from_cv_results_legend_label": [
    "pyplot",
    "data_binary",
    "name",
    "curve_kwargs"
  ],
  "test_roc_curve_from_cv_results_curve_kwargs": [
    "pyplot",
    "data_binary",
    "curve_kwargs"
  ],
  "test_roc_curve_from_cv_results_pos_label_inferred": [
    "pyplot",
    "data_binary"
  ],
  "_check_chance_level": [
    "plot_chance_level",
    "chance_level_kw",
    "display"
  ],
  "test_roc_curve_chance_level_line": [
    "pyplot",
    "data_binary",
    "plot_chance_level",
    "chance_level_kw",
    "label",
    "constructor_name"
  ],
  "test_roc_curve_chance_level_line_from_cv_results": [
    "pyplot",
    "data_binary",
    "plot_chance_level",
    "chance_level_kw",
    "curve_kwargs"
  ],
  "test_roc_curve_display_complex_pipeline": [
    "pyplot",
    "data_binary",
    "clf",
    "constructor_name"
  ],
  "test_roc_curve_display_default_labels": [
    "pyplot",
    "roc_auc",
    "name",
    "curve_kwargs",
    "expected_labels"
  ],
  "_check_auc": [
    "display",
    "constructor_name"
  ],
  "test_plot_roc_curve_pos_label": [
    "pyplot",
    "response_method",
    "constructor_name"
  ],
  "test_plot_roc_curve_despine": [
    "pyplot",
    "data_binary",
    "despine",
    "constructor_name"
  ],
  "sqeuclidean_row_norms": [
    "X",
    "num_threads"
  ],
  "BaseDistancesReductionDispatcher": {
    "valid_metrics": [
      "cls"
    ],
    "is_usable_for": [
      "cls",
      "X",
      "Y",
      "metric"
    ],
    "compute": [
      "cls",
      "X",
      "Y"
    ]
  },
  "ArgKmin": {
    "compute": [
      "cls",
      "X",
      "Y",
      "k",
      "metric",
      "chunk_size",
      "metric_kwargs",
      "strategy",
      "return_distance"
    ]
  },
  "RadiusNeighbors": {
    "compute": [
      "cls",
      "X",
      "Y",
      "radius",
      "metric",
      "chunk_size",
      "metric_kwargs",
      "strategy",
      "return_distance",
      "sort_results"
    ]
  },
  "ArgKminClassMode": {
    "valid_metrics": [
      "cls"
    ],
    "compute": [
      "cls",
      "X",
      "Y",
      "k",
      "weights",
      "Y_labels",
      "unique_Y_labels",
      "metric",
      "chunk_size",
      "metric_kwargs",
      "strategy"
    ]
  },
  "RadiusNeighborsClassMode": {
    "valid_metrics": [
      "cls"
    ],
    "compute": [
      "cls",
      "X",
      "Y",
      "radius",
      "weights",
      "Y_labels",
      "unique_Y_labels",
      "outlier_label",
      "metric",
      "chunk_size",
      "metric_kwargs",
      "strategy"
    ]
  },
  "check_clusterings": [
    "labels_true",
    "labels_pred"
  ],
  "_generalized_average": [
    "U",
    "V",
    "average_method"
  ],
  "contingency_matrix": [
    "labels_true",
    "labels_pred"
  ],
  "pair_confusion_matrix": [
    "labels_true",
    "labels_pred"
  ],
  "rand_score": [
    "labels_true",
    "labels_pred"
  ],
  "adjusted_rand_score": [
    "labels_true",
    "labels_pred"
  ],
  "homogeneity_completeness_v_measure": [
    "labels_true",
    "labels_pred"
  ],
  "homogeneity_score": [
    "labels_true",
    "labels_pred"
  ],
  "completeness_score": [
    "labels_true",
    "labels_pred"
  ],
  "v_measure_score": [
    "labels_true",
    "labels_pred"
  ],
  "mutual_info_score": [
    "labels_true",
    "labels_pred"
  ],
  "adjusted_mutual_info_score": [
    "labels_true",
    "labels_pred"
  ],
  "normalized_mutual_info_score": [
    "labels_true",
    "labels_pred"
  ],
  "fowlkes_mallows_score": [
    "labels_true",
    "labels_pred"
  ],
  "_entropy": [
    "labels"
  ],
  "entropy": [
    "labels"
  ],
  "check_number_of_labels": [
    "n_labels",
    "n_samples"
  ],
  "silhouette_score": [
    "X",
    "labels"
  ],
  "_silhouette_reduce": [
    "D_chunk",
    "start",
    "labels",
    "label_freqs"
  ],
  "silhouette_samples": [
    "X",
    "labels"
  ],
  "calinski_harabasz_score": [
    "X",
    "labels"
  ],
  "davies_bouldin_score": [
    "X",
    "labels"
  ],
  "_check_rows_and_columns": [
    "a",
    "b"
  ],
  "_jaccard": [
    "a_rows",
    "a_cols",
    "b_rows",
    "b_cols"
  ],
  "_pairwise_similarity": [
    "a",
    "b",
    "similarity"
  ],
  "consensus_score": [
    "a",
    "b"
  ],
  "SUPERVISED_METRICS": [],
  "UNSUPERVISED_METRICS": [],
  "NON_SYMMETRIC_METRICS": [],
  "NORMALIZED_METRICS": [],
  "test_symmetric_non_symmetric_union": [],
  "test_symmetry": [
    "metric_name",
    "y1",
    "y2"
  ],
  "test_non_symmetry": [
    "metric_name",
    "y1",
    "y2"
  ],
  "test_normalized_output": [
    "metric_name"
  ],
  "test_permute_labels": [
    "metric_name"
  ],
  "test_format_invariance": [
    "metric_name"
  ],
  "test_inf_nan_input": [
    "metric_name",
    "metric_func"
  ],
  "check_array_api_unsupervised_metric": [
    "metric",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "score_funcs": [],
  "test_error_messages_on_wrong_input": [
    "score_func"
  ],
  "test_generalized_average": [],
  "test_perfect_matches": [
    "score_func"
  ],
  "test_perfect_matches_with_changing_means": [
    "score_func",
    "average_method"
  ],
  "test_homogeneous_but_not_complete_labeling": [],
  "test_complete_but_not_homogeneous_labeling": [],
  "test_not_complete_and_not_homogeneous_labeling": [],
  "test_beta_parameter": [],
  "test_non_consecutive_labels": [],
  "uniform_labelings_scores": [
    "score_func",
    "n_samples",
    "k_range",
    "n_runs",
    "seed"
  ],
  "test_adjustment_for_chance": [],
  "test_adjusted_mutual_info_score": [],
  "test_expected_mutual_info_overflow": [],
  "test_int_overflow_mutual_info_fowlkes_mallows_score": [],
  "test_public_entropy_deprecation": [],
  "test_entropy": [],
  "test_entropy_array_api": [
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_contingency_matrix": [],
  "test_contingency_matrix_sparse": [],
  "test_exactly_zero_info_score": [],
  "test_v_measure_and_mutual_information": [
    "seed"
  ],
  "test_fowlkes_mallows_score": [],
  "test_fowlkes_mallows_score_properties": [],
  "test_mutual_info_score_positive_constant_label": [
    "labels_true",
    "labels_pred"
  ],
  "test_check_clustering_error": [],
  "test_pair_confusion_matrix_fully_dispersed": [],
  "test_pair_confusion_matrix_single_cluster": [],
  "test_pair_confusion_matrix": [],
  "test_rand_score_edge_cases": [
    "clustering1",
    "clustering2"
  ],
  "test_rand_score": [],
  "test_adjusted_rand_score_overflow": [],
  "test_normalized_mutual_info_score_bounded": [
    "average_method"
  ],
  "test_fowlkes_mallows_sparse_deprecated": [
    "sparse"
  ],
  "test_jaccard": [],
  "test_consensus_score": [],
  "test_consensus_score_issue2445": [],
  "test_silhouette": [
    "sparse_container",
    "sample_size"
  ],
  "test_cluster_size_1": [],
  "test_silhouette_paper_example": [],
  "test_correct_labelsize": [],
  "test_non_encoded_labels": [],
  "test_non_numpy_labels": [],
  "test_silhouette_nonzero_diag": [
    "dtype"
  ],
  "test_silhouette_samples_precomputed_sparse": [
    "sparse_container"
  ],
  "test_silhouette_samples_euclidean_sparse": [
    "sparse_container"
  ],
  "test_silhouette_reduce": [
    "sparse_container"
  ],
  "assert_raises_on_only_one_label": [
    "func"
  ],
  "assert_raises_on_all_points_same_cluster": [
    "func"
  ],
  "test_calinski_harabasz_score": [],
  "test_davies_bouldin_score": [],
  "test_silhouette_score_integer_precomputed": [],
  "test_imports_strategies": [],
  "test_import_raises_warning": [],
  "ARCHIVE": [],
  "FUNNELED_ARCHIVE": [],
  "TARGETS": [],
  "_check_fetch_lfw": [
    "data_home",
    "funneled",
    "download_if_missing",
    "n_retries",
    "delay"
  ],
  "_load_imgs": [
    "file_paths",
    "slice_",
    "color",
    "resize"
  ],
  "_fetch_lfw_people": [
    "data_folder_path",
    "slice_",
    "color",
    "resize",
    "min_faces_per_person"
  ],
  "fetch_lfw_people": [],
  "_fetch_lfw_pairs": [
    "index_file_path",
    "data_folder_path",
    "slice_",
    "color",
    "resize"
  ],
  "fetch_lfw_pairs": [],
  "DATA_MODULE": [],
  "DESCR_MODULE": [],
  "IMAGES_MODULE": [],
  "RemoteFileMetadata": [],
  "get_data_home": [
    "data_home"
  ],
  "clear_data_home": [
    "data_home"
  ],
  "_convert_data_dataframe": [
    "caller_name",
    "data",
    "target",
    "feature_names",
    "target_names",
    "sparse_data"
  ],
  "load_files": [
    "container_path"
  ],
  "load_csv_data": [
    "data_file_name"
  ],
  "load_gzip_compressed_csv_data": [
    "data_file_name"
  ],
  "load_descr": [
    "descr_file_name"
  ],
  "load_wine": [],
  "load_iris": [],
  "load_breast_cancer": [],
  "load_digits": [],
  "load_diabetes": [],
  "load_linnerud": [],
  "load_sample_images": [],
  "load_sample_image": [
    "image_name"
  ],
  "_pkl_filepath": [],
  "_sha256": [
    "path"
  ],
  "_fetch_remote": [
    "remote",
    "dirname",
    "n_retries",
    "delay"
  ],
  "_filter_filename": [
    "value",
    "filter_dots"
  ],
  "_derive_folder_and_filename_from_url": [
    "url"
  ],
  "fetch_file": [
    "url",
    "folder",
    "local_filename",
    "sha256",
    "n_retries",
    "delay"
  ],
  "CACHE_NAME": [],
  "TRAIN_FOLDER": [],
  "TEST_FOLDER": [],
  "_download_20newsgroups": [
    "target_dir",
    "cache_path",
    "n_retries",
    "delay"
  ],
  "strip_newsgroup_header": [
    "text"
  ],
  "_QUOTE_RE": [],
  "strip_newsgroup_quoting": [
    "text"
  ],
  "strip_newsgroup_footer": [
    "text"
  ],
  "fetch_20newsgroups": [],
  "fetch_20newsgroups_vectorized": [],
  "load_svmlight_file": [
    "f"
  ],
  "_gen_open": [
    "f"
  ],
  "_open_and_load": [
    "f",
    "dtype",
    "multilabel",
    "zero_based",
    "query_id",
    "offset",
    "length"
  ],
  "load_svmlight_files": [
    "files"
  ],
  "_dump_svmlight": [
    "X",
    "y",
    "f",
    "multilabel",
    "one_based",
    "comment",
    "query_id"
  ],
  "dump_svmlight_file": [
    "X",
    "y",
    "f"
  ],
  "fetch_california_housing": [],
  "FEATURE_NAMES": [],
  "TARGET_NAMES": [],
  "fetch_covtype": [],
  "XY_METADATA": [],
  "TOPICS_METADATA": [],
  "fetch_rcv1": [],
  "_inverse_permutation": [
    "p"
  ],
  "_find_permutation": [
    "a",
    "b"
  ],
  "ARCHIVE_10_PERCENT": [],
  "fetch_kddcup99": [],
  "_fetch_brute_kddcup99": [
    "data_home",
    "download_if_missing",
    "percent10",
    "n_retries",
    "delay"
  ],
  "_mkdirp": [
    "d"
  ],
  "_split_sparse_columns": [
    "arff_data",
    "include_columns"
  ],
  "_sparse_data_to_array": [
    "arff_data",
    "include_columns"
  ],
  "_post_process_frame": [
    "frame",
    "feature_names",
    "target_names"
  ],
  "_liac_arff_parser": [
    "gzip_file",
    "output_arrays_type",
    "openml_columns_info",
    "feature_names_to_select",
    "target_names_to_select",
    "shape"
  ],
  "_pandas_arff_parser": [
    "gzip_file",
    "output_arrays_type",
    "openml_columns_info",
    "feature_names_to_select",
    "target_names_to_select",
    "read_csv_kwargs"
  ],
  "load_arff_from_gzip_file": [
    "gzip_file",
    "parser",
    "output_type",
    "openml_columns_info",
    "feature_names_to_select",
    "target_names_to_select",
    "shape",
    "read_csv_kwargs"
  ],
  "_generate_hypercube": [
    "samples",
    "dimensions",
    "rng"
  ],
  "make_classification": [
    "n_samples",
    "n_features"
  ],
  "make_multilabel_classification": [
    "n_samples",
    "n_features"
  ],
  "make_hastie_10_2": [
    "n_samples"
  ],
  "make_regression": [
    "n_samples",
    "n_features"
  ],
  "make_circles": [
    "n_samples"
  ],
  "make_moons": [
    "n_samples"
  ],
  "make_blobs": [
    "n_samples",
    "n_features"
  ],
  "make_friedman1": [
    "n_samples",
    "n_features"
  ],
  "make_friedman2": [
    "n_samples"
  ],
  "make_friedman3": [
    "n_samples"
  ],
  "make_low_rank_matrix": [
    "n_samples",
    "n_features"
  ],
  "make_sparse_coded_signal": [
    "n_samples"
  ],
  "make_sparse_uncorrelated": [
    "n_samples",
    "n_features"
  ],
  "make_spd_matrix": [
    "n_dim"
  ],
  "make_sparse_spd_matrix": [
    "n_dim"
  ],
  "make_swiss_roll": [
    "n_samples"
  ],
  "make_s_curve": [
    "n_samples"
  ],
  "make_gaussian_quantiles": [],
  "_shuffle": [
    "data",
    "random_state"
  ],
  "make_biclusters": [
    "shape",
    "n_clusters"
  ],
  "make_checkerboard": [
    "shape",
    "n_clusters"
  ],
  "_SEARCH_NAME": [],
  "_DATA_INFO": [],
  "_DATA_FEATURES": [],
  "_DATA_QUALITIES": [],
  "OpenmlQualitiesType": [],
  "OpenmlFeaturesType": [],
  "_get_local_path": [
    "openml_path",
    "data_home"
  ],
  "_retry_with_clean_cache": [
    "openml_path",
    "data_home",
    "no_retry_exception"
  ],
  "_retry_on_network_error": [
    "n_retries",
    "delay",
    "url"
  ],
  "_open_openml_url": [
    "url",
    "data_home",
    "n_retries",
    "delay"
  ],
  "OpenMLError": {},
  "_get_json_content_from_openml_api": [
    "url",
    "error_message",
    "data_home",
    "n_retries",
    "delay"
  ],
  "_get_data_info_by_name": [
    "name",
    "version",
    "data_home",
    "n_retries",
    "delay"
  ],
  "_get_data_description_by_id": [
    "data_id",
    "data_home",
    "n_retries",
    "delay"
  ],
  "_get_data_features": [
    "data_id",
    "data_home",
    "n_retries",
    "delay"
  ],
  "_get_data_qualities": [
    "data_id",
    "data_home",
    "n_retries",
    "delay"
  ],
  "_get_num_samples": [
    "data_qualities"
  ],
  "_load_arff_response": [
    "url",
    "data_home",
    "parser",
    "output_type",
    "openml_columns_info",
    "feature_names_to_select",
    "target_names_to_select",
    "shape",
    "md5_checksum",
    "n_retries",
    "delay",
    "read_csv_kwargs"
  ],
  "_download_data_to_bunch": [
    "url",
    "sparse",
    "data_home"
  ],
  "_verify_target_data_type": [
    "features_dict",
    "target_columns"
  ],
  "_valid_data_column_names": [
    "features_list",
    "target_columns"
  ],
  "fetch_openml": [
    "name"
  ],
  "SAMPLES": [],
  "COVERAGES": [],
  "DATA_ARCHIVE_NAME": [],
  "_load_coverage": [
    "F",
    "header_length",
    "dtype"
  ],
  "_load_csv": [
    "F"
  ],
  "construct_grids": [
    "batch"
  ],
  "fetch_species_distributions": [],
  "FACES": [],
  "fetch_olivetti_faces": [],
  "test_fetch_kddcup99_percent10": [
    "fetch_kddcup99_fxt",
    "as_frame",
    "subset",
    "n_samples",
    "n_features"
  ],
  "test_fetch_kddcup99_return_X_y": [
    "fetch_kddcup99_fxt"
  ],
  "test_fetch_kddcup99_as_frame": [
    "fetch_kddcup99_fxt"
  ],
  "test_fetch_kddcup99_shuffle": [
    "fetch_kddcup99_fxt"
  ],
  "test_pandas_dependency_message": [
    "fetch_kddcup99_fxt",
    "hide_available_pandas"
  ],
  "test_corrupted_file_error_message": [
    "fetch_kddcup99_fxt",
    "tmp_path"
  ],
  "TEST_DATA_MODULE": [],
  "datafile": [],
  "multifile": [],
  "invalidfile": [],
  "invalidfile2": [],
  "_svmlight_local_test_file_path": [
    "filename"
  ],
  "_load_svmlight_local_test_file": [
    "filename"
  ],
  "test_load_svmlight_file": [],
  "test_load_svmlight_file_fd": [],
  "test_load_svmlight_pathlib": [],
  "test_load_svmlight_file_multilabel": [],
  "test_load_svmlight_files": [],
  "test_load_svmlight_file_n_features": [],
  "test_load_compressed": [],
  "test_load_invalid_file": [],
  "test_load_invalid_order_file": [],
  "test_load_zero_based": [],
  "test_load_zero_based_auto": [],
  "test_load_with_qid": [],
  "test_load_large_qid": [],
  "test_load_invalid_file2": [],
  "test_not_a_filename": [],
  "test_invalid_filename": [],
  "test_dump": [
    "csr_container"
  ],
  "test_dump_multilabel": [
    "csr_container"
  ],
  "test_dump_concise": [],
  "test_dump_comment": [],
  "test_dump_invalid": [],
  "test_dump_query_id": [],
  "test_load_with_long_qid": [],
  "test_load_zeros": [
    "csr_container"
  ],
  "test_load_with_offsets": [
    "sparsity",
    "n_samples",
    "n_features",
    "csr_container"
  ],
  "test_load_offset_exhaustive_splits": [
    "csr_container"
  ],
  "test_load_with_offsets_error": [],
  "test_multilabel_y_explicit_zeros": [
    "tmp_path",
    "csr_container"
  ],
  "test_dump_read_only": [
    "tmp_path"
  ],
  "test_20news": [
    "fetch_20newsgroups_fxt"
  ],
  "test_20news_length_consistency": [
    "fetch_20newsgroups_fxt"
  ],
  "test_20news_vectorized": [
    "fetch_20newsgroups_vectorized_fxt"
  ],
  "test_20news_normalization": [
    "fetch_20newsgroups_vectorized_fxt"
  ],
  "test_20news_as_frame": [
    "fetch_20newsgroups_vectorized_fxt"
  ],
  "test_as_frame_no_pandas": [
    "fetch_20newsgroups_vectorized_fxt",
    "hide_available_pandas"
  ],
  "test_outdated_pickle": [
    "fetch_20newsgroups_vectorized_fxt"
  ],
  "test_fetch": [
    "fetch_covtype_fxt",
    "global_random_seed"
  ],
  "test_fetch_asframe": [
    "fetch_covtype_fxt"
  ],
  "is_pillow_installed": [],
  "FETCH_PYTEST_MARKERS": [],
  "check_pandas_dependency_message": [
    "fetch_func"
  ],
  "check_return_X_y": [
    "bunch",
    "dataset_func"
  ],
  "check_as_frame": [
    "bunch",
    "dataset_func",
    "expected_data_dtype",
    "expected_target_dtype"
  ],
  "_skip_network_tests": [],
  "_generate_func_supporting_param": [
    "param",
    "dataset_type"
  ],
  "test_common_check_return_X_y": [
    "name",
    "dataset_func"
  ],
  "test_common_check_as_frame": [
    "name",
    "dataset_func"
  ],
  "test_common_check_pandas_dependency": [
    "name",
    "dataset_func"
  ],
  "OPENML_TEST_DATA_MODULE": [],
  "test_offline": [],
  "_MONKEY_PATCH_LOCAL_OPENML_PATH": [],
  "_MockHTTPResponse": {
    "__init__": [
      "self",
      "data",
      "is_gzip"
    ],
    "read": [
      "self",
      "amt"
    ],
    "close": [
      "self"
    ],
    "info": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "_monkey_patch_webbased_functions": [
    "context",
    "data_id",
    "gzip_response"
  ],
  "test_fetch_openml_as_frame_true": [
    "monkeypatch",
    "data_id",
    "dataset_params",
    "n_samples",
    "n_features",
    "n_targets",
    "parser",
    "gzip_response"
  ],
  "test_fetch_openml_as_frame_false": [
    "monkeypatch",
    "data_id",
    "dataset_params",
    "n_samples",
    "n_features",
    "n_targets",
    "parser"
  ],
  "test_fetch_openml_consistency_parser": [
    "monkeypatch",
    "data_id"
  ],
  "test_fetch_openml_equivalence_array_dataframe": [
    "monkeypatch",
    "parser"
  ],
  "test_fetch_openml_iris_pandas": [
    "monkeypatch",
    "parser"
  ],
  "test_fetch_openml_forcing_targets": [
    "monkeypatch",
    "parser",
    "target_column"
  ],
  "test_fetch_openml_equivalence_frame_return_X_y": [
    "monkeypatch",
    "data_id",
    "parser"
  ],
  "test_fetch_openml_equivalence_array_return_X_y": [
    "monkeypatch",
    "data_id",
    "parser"
  ],
  "test_fetch_openml_difference_parsers": [
    "monkeypatch"
  ],
  "datasets_column_names": [],
  "datasets_missing_values": [],
  "test_fetch_openml_types_inference": [
    "monkeypatch",
    "data_id",
    "parser",
    "expected_n_categories",
    "expected_n_floats",
    "expected_n_ints",
    "gzip_response",
    "datasets_column_names",
    "datasets_missing_values"
  ],
  "test_fetch_openml_validation_parameter": [
    "monkeypatch",
    "params",
    "err_msg"
  ],
  "test_fetch_openml_requires_pandas_error": [
    "monkeypatch",
    "params"
  ],
  "test_fetch_openml_sparse_arff_error": [
    "monkeypatch",
    "params",
    "err_msg"
  ],
  "test_fetch_openml_auto_mode": [
    "monkeypatch",
    "data_id",
    "data_type"
  ],
  "test_convert_arff_data_dataframe_warning_low_memory_pandas": [
    "monkeypatch"
  ],
  "test_fetch_openml_iris_warn_multiple_version": [
    "monkeypatch",
    "gzip_response"
  ],
  "test_fetch_openml_no_target": [
    "monkeypatch",
    "gzip_response"
  ],
  "test_missing_values_pandas": [
    "monkeypatch",
    "gzip_response",
    "parser"
  ],
  "test_fetch_openml_inactive": [
    "monkeypatch",
    "gzip_response",
    "dataset_params"
  ],
  "test_fetch_openml_error": [
    "monkeypatch",
    "gzip_response",
    "data_id",
    "params",
    "err_type",
    "err_msg",
    "parser"
  ],
  "test_fetch_openml_raises_illegal_argument": [
    "params",
    "err_type",
    "err_msg"
  ],
  "test_warn_ignore_attribute": [
    "monkeypatch",
    "gzip_response"
  ],
  "test_dataset_with_openml_error": [
    "monkeypatch",
    "gzip_response"
  ],
  "test_dataset_with_openml_warning": [
    "monkeypatch",
    "gzip_response"
  ],
  "test_fetch_openml_overwrite_default_params_read_csv": [
    "monkeypatch"
  ],
  "test_open_openml_url_cache": [
    "monkeypatch",
    "gzip_response",
    "tmpdir"
  ],
  "test_open_openml_url_unlinks_local_path": [
    "monkeypatch",
    "tmpdir",
    "write_to_disk"
  ],
  "test_retry_with_clean_cache": [
    "tmpdir"
  ],
  "test_retry_with_clean_cache_http_error": [
    "tmpdir"
  ],
  "test_fetch_openml_cache": [
    "monkeypatch",
    "gzip_response",
    "tmpdir"
  ],
  "test_fetch_openml_verify_checksum": [
    "monkeypatch",
    "as_frame",
    "tmpdir",
    "parser"
  ],
  "test_open_openml_url_retry_on_network_error": [
    "monkeypatch"
  ],
  "test_fetch_openml_with_ignored_feature": [
    "monkeypatch",
    "gzip_response",
    "parser"
  ],
  "test_fetch_openml_strip_quotes": [
    "monkeypatch"
  ],
  "test_fetch_openml_leading_whitespace": [
    "monkeypatch"
  ],
  "test_fetch_openml_quotechar_escapechar": [
    "monkeypatch"
  ],
  "test_post_process_frame": [
    "feature_names",
    "target_names"
  ],
  "test_load_arff_from_gzip_file_error_parser": [],
  "test_pandas_arff_parser_strip_single_quotes": [
    "parser_func"
  ],
  "test_pandas_arff_parser_strip_double_quotes": [
    "parser_func"
  ],
  "test_pandas_arff_parser_strip_no_quotes": [
    "parser_func"
  ],
  "test_make_classification": [],
  "test_make_classification_informative_features": [],
  "test_make_classification_return_x_y": [],
  "test_make_classification_weights_type": [
    "weights",
    "err_type",
    "err_msg"
  ],
  "test_make_classification_weights_array_or_list_ok": [
    "kwargs"
  ],
  "test_make_multilabel_classification_return_sequences": [],
  "test_make_multilabel_classification_return_indicator": [],
  "test_make_multilabel_classification_return_indicator_sparse": [],
  "test_make_hastie_10_2": [],
  "test_make_regression": [
    "global_random_seed"
  ],
  "test_make_regression_multitarget": [
    "global_random_seed"
  ],
  "test_make_blobs": [
    "global_random_seed"
  ],
  "test_make_blobs_n_samples_list": [],
  "test_make_blobs_n_samples_list_with_centers": [
    "global_random_seed"
  ],
  "test_make_blobs_n_samples_centers_none": [
    "n_samples"
  ],
  "test_make_blobs_return_centers": [],
  "test_make_blobs_error": [],
  "test_make_friedman1": [
    "global_random_seed"
  ],
  "test_make_friedman2": [
    "global_random_seed"
  ],
  "test_make_friedman3": [
    "global_random_seed"
  ],
  "test_make_low_rank_matrix": [],
  "test_make_sparse_coded_signal": [
    "global_random_seed"
  ],
  "test_make_sparse_uncorrelated": [],
  "test_make_spd_matrix": [
    "global_random_seed"
  ],
  "test_make_sparse_spd_matrix": [
    "norm_diag",
    "sparse_format",
    "global_random_seed"
  ],
  "test_make_swiss_roll": [
    "global_random_seed",
    "hole"
  ],
  "test_make_s_curve": [
    "global_random_seed"
  ],
  "test_make_biclusters": [],
  "test_make_checkerboard": [],
  "test_make_moons": [
    "global_random_seed"
  ],
  "test_make_moons_unbalanced": [],
  "test_make_circles": [],
  "test_make_circles_unbalanced": [],
  "test_fetch_rcv1": [
    "fetch_rcv1_fxt",
    "global_random_seed"
  ],
  "FAKE_NAMES": [],
  "mock_empty_data_home": [
    "tmp_path_factory"
  ],
  "mock_data_home": [
    "tmp_path_factory"
  ],
  "test_load_empty_lfw_people": [
    "mock_empty_data_home"
  ],
  "test_load_fake_lfw_people": [
    "mock_data_home"
  ],
  "test_load_fake_lfw_people_too_restrictive": [
    "mock_data_home"
  ],
  "test_load_empty_lfw_pairs": [
    "mock_empty_data_home"
  ],
  "test_load_fake_lfw_pairs": [
    "mock_data_home"
  ],
  "test_fetch_lfw_people_internal_cropping": [
    "mock_data_home"
  ],
  "test_olivetti_faces": [
    "fetch_olivetti_faces_fxt"
  ],
  "_DummyPath": {
    "__init__": [
      "self",
      "path"
    ],
    "__fspath__": [
      "self"
    ]
  },
  "_remove_dir": [
    "path"
  ],
  "data_home": [
    "tmpdir_factory"
  ],
  "load_files_root": [
    "tmpdir_factory"
  ],
  "test_category_dir_1": [
    "load_files_root"
  ],
  "test_category_dir_2": [
    "load_files_root"
  ],
  "test_data_home": [
    "path_container",
    "data_home"
  ],
  "test_default_empty_load_files": [
    "load_files_root"
  ],
  "test_default_load_files": [
    "test_category_dir_1",
    "test_category_dir_2",
    "load_files_root"
  ],
  "test_load_files_w_categories_desc_and_encoding": [
    "test_category_dir_1",
    "test_category_dir_2",
    "load_files_root"
  ],
  "test_load_files_wo_load_content": [
    "test_category_dir_1",
    "test_category_dir_2",
    "load_files_root"
  ],
  "test_load_files_allowed_extensions": [
    "tmp_path",
    "allowed_extensions"
  ],
  "test_load_csv_data": [
    "filename",
    "expected_n_samples",
    "expected_n_features",
    "expected_target_names"
  ],
  "test_load_csv_data_with_descr": [],
  "test_load_gzip_compressed_csv_data": [
    "filename",
    "kwargs",
    "expected_shape"
  ],
  "test_load_gzip_compressed_csv_data_with_descr": [],
  "test_load_sample_images": [],
  "test_load_sample_image": [],
  "test_load_diabetes_raw": [],
  "test_loader": [
    "loader_func",
    "data_shape",
    "target_shape",
    "n_target",
    "has_descr",
    "filenames"
  ],
  "test_toy_dataset_frame_dtype": [
    "loader_func",
    "data_dtype",
    "target_dtype"
  ],
  "test_loads_dumps_bunch": [],
  "test_bunch_pickle_generated_with_0_16_and_read_with_0_17": [],
  "test_bunch_dir": [],
  "test_load_boston_error": [],
  "test_fetch_remote_raise_warnings_with_invalid_url": [
    "monkeypatch"
  ],
  "test_derive_folder_and_filename_from_url": [],
  "_mock_urlretrieve": [
    "server_side"
  ],
  "test_fetch_file_using_data_home": [
    "monkeypatch",
    "tmpdir"
  ],
  "test_fetch_file_without_sha256": [
    "monkeypatch",
    "tmpdir"
  ],
  "test_fetch_file_with_sha256": [
    "monkeypatch",
    "tmpdir"
  ],
  "_log_dirichlet_norm": [
    "dirichlet_concentration"
  ],
  "_log_wishart_norm": [
    "degrees_of_freedom",
    "log_det_precisions_chol",
    "n_features"
  ],
  "BayesianGaussianMixture": {
    "__init__": [
      "self"
    ],
    "_check_parameters": [
      "self",
      "X",
      "xp"
    ],
    "_check_weights_parameters": [
      "self"
    ],
    "_check_means_parameters": [
      "self",
      "X"
    ],
    "_check_precision_parameters": [
      "self",
      "X"
    ],
    "_checkcovariance_prior_parameter": [
      "self",
      "X"
    ],
    "_initialize": [
      "self",
      "X",
      "resp"
    ],
    "_estimate_weights": [
      "self",
      "nk"
    ],
    "_estimate_means": [
      "self",
      "nk",
      "xk"
    ],
    "_estimate_precisions": [
      "self",
      "nk",
      "xk",
      "sk"
    ],
    "_estimate_wishart_full": [
      "self",
      "nk",
      "xk",
      "sk"
    ],
    "_estimate_wishart_tied": [
      "self",
      "nk",
      "xk",
      "sk"
    ],
    "_estimate_wishart_diag": [
      "self",
      "nk",
      "xk",
      "sk"
    ],
    "_estimate_wishart_spherical": [
      "self",
      "nk",
      "xk",
      "sk"
    ],
    "_m_step": [
      "self",
      "X",
      "log_resp",
      "xp"
    ],
    "_estimate_log_weights": [
      "self",
      "xp"
    ],
    "_estimate_log_prob": [
      "self",
      "X",
      "xp"
    ],
    "_compute_lower_bound": [
      "self",
      "log_resp",
      "log_prob_norm"
    ],
    "_get_parameters": [
      "self"
    ],
    "_set_parameters": [
      "self",
      "params",
      "xp"
    ]
  },
  "_check_weights": [
    "weights",
    "n_components",
    "xp"
  ],
  "_check_means": [
    "means",
    "n_components",
    "n_features",
    "xp"
  ],
  "_check_precision_positivity": [
    "precision",
    "covariance_type",
    "xp"
  ],
  "_check_precision_matrix": [
    "precision",
    "covariance_type",
    "xp"
  ],
  "_check_precisions_full": [
    "precisions",
    "covariance_type",
    "xp"
  ],
  "_check_precisions": [
    "precisions",
    "covariance_type",
    "n_components",
    "n_features",
    "xp"
  ],
  "_estimate_gaussian_covariances_full": [
    "resp",
    "X",
    "nk",
    "means",
    "reg_covar",
    "xp"
  ],
  "_estimate_gaussian_covariances_tied": [
    "resp",
    "X",
    "nk",
    "means",
    "reg_covar",
    "xp"
  ],
  "_estimate_gaussian_covariances_diag": [
    "resp",
    "X",
    "nk",
    "means",
    "reg_covar",
    "xp"
  ],
  "_estimate_gaussian_covariances_spherical": [
    "resp",
    "X",
    "nk",
    "means",
    "reg_covar",
    "xp"
  ],
  "_estimate_gaussian_parameters": [
    "X",
    "resp",
    "reg_covar",
    "covariance_type",
    "xp"
  ],
  "_compute_precision_cholesky": [
    "covariances",
    "covariance_type",
    "xp"
  ],
  "_flipudlr": [
    "array",
    "xp"
  ],
  "_compute_precision_cholesky_from_precisions": [
    "precisions",
    "covariance_type",
    "xp"
  ],
  "_compute_log_det_cholesky": [
    "matrix_chol",
    "covariance_type",
    "n_features",
    "xp"
  ],
  "_estimate_log_gaussian_prob": [
    "X",
    "means",
    "precisions_chol",
    "covariance_type",
    "xp"
  ],
  "GaussianMixture": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_check_parameters": [
      "self",
      "X",
      "xp"
    ],
    "_initialize_parameters": [
      "self",
      "X",
      "random_state",
      "xp"
    ],
    "_initialize": [
      "self",
      "X",
      "resp",
      "xp"
    ],
    "_m_step": [
      "self",
      "X",
      "log_resp",
      "xp"
    ],
    "_estimate_log_prob": [
      "self",
      "X",
      "xp"
    ],
    "_estimate_log_weights": [
      "self",
      "xp"
    ],
    "_compute_lower_bound": [
      "self",
      "_",
      "log_prob_norm"
    ],
    "_get_parameters": [
      "self"
    ],
    "_set_parameters": [
      "self",
      "params",
      "xp"
    ],
    "_n_parameters": [
      "self"
    ],
    "bic": [
      "self",
      "X"
    ],
    "aic": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_shape": [
    "param",
    "param_shape",
    "name"
  ],
  "BaseMixture": {
    "__init__": [
      "self",
      "n_components",
      "tol",
      "reg_covar",
      "max_iter",
      "n_init",
      "init_params",
      "random_state",
      "warm_start",
      "verbose",
      "verbose_interval"
    ],
    "_check_parameters": [
      "self",
      "X",
      "xp"
    ],
    "_initialize_parameters": [
      "self",
      "X",
      "random_state",
      "xp"
    ],
    "_initialize": [
      "self",
      "X",
      "resp"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "_e_step": [
      "self",
      "X",
      "xp"
    ],
    "_m_step": [
      "self",
      "X",
      "log_resp"
    ],
    "_get_parameters": [
      "self"
    ],
    "_set_parameters": [
      "self",
      "params"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "sample": [
      "self",
      "n_samples"
    ],
    "_estimate_weighted_log_prob": [
      "self",
      "X",
      "xp"
    ],
    "_estimate_log_weights": [
      "self",
      "xp"
    ],
    "_estimate_log_prob": [
      "self",
      "X",
      "xp"
    ],
    "_estimate_log_prob_resp": [
      "self",
      "X",
      "xp"
    ],
    "_print_verbose_msg_init_beg": [
      "self",
      "n_init"
    ],
    "_print_verbose_msg_iter_end": [
      "self",
      "n_iter",
      "diff_ll"
    ],
    "_print_verbose_msg_init_end": [
      "self",
      "lb",
      "init_has_converged"
    ]
  },
  "test_gaussian_mixture_n_iter": [
    "estimator"
  ],
  "test_mixture_n_components_greater_than_n_samples_error": [
    "estimator"
  ],
  "COVARIANCE_TYPE": [],
  "generate_data": [
    "n_samples",
    "n_features",
    "weights",
    "means",
    "precisions",
    "covariance_type",
    "dtype"
  ],
  "RandomData": {
    "__init__": [
      "self",
      "rng",
      "n_samples",
      "n_components",
      "n_features",
      "scale",
      "dtype"
    ]
  },
  "test_gaussian_mixture_attributes": [],
  "test_check_weights": [],
  "test_check_means": [],
  "test_check_precisions": [],
  "test_suffstat_sk_full": [],
  "test_suffstat_sk_tied": [],
  "test_suffstat_sk_diag": [],
  "test_gaussian_suffstat_sk_spherical": [
    "global_dtype"
  ],
  "test_compute_log_det_cholesky": [
    "global_dtype"
  ],
  "_naive_lmvnpdf_diag": [
    "X",
    "means",
    "covars"
  ],
  "test_gaussian_mixture_log_probabilities": [],
  "test_gaussian_mixture_estimate_log_prob_resp": [],
  "test_gaussian_mixture_predict_predict_proba": [],
  "test_gaussian_mixture_fit_predict": [
    "seed",
    "max_iter",
    "tol",
    "global_dtype"
  ],
  "test_gaussian_mixture_fit_predict_n_init": [],
  "test_gaussian_mixture_fit": [
    "global_dtype"
  ],
  "test_gaussian_mixture_fit_best_params": [],
  "test_gaussian_mixture_fit_convergence_warning": [],
  "test_multiple_init": [],
  "test_gaussian_mixture_n_parameters": [],
  "test_bic_1d_1component": [],
  "test_gaussian_mixture_aic_bic": [],
  "test_gaussian_mixture_verbose": [],
  "test_convergence_detected_with_warm_start": [],
  "test_score": [
    "global_dtype"
  ],
  "test_monotonic_likelihood": [],
  "test_regularisation": [],
  "test_fitted_precision_covariance_concistency": [
    "covar_type",
    "global_dtype"
  ],
  "test_sample": [],
  "test_init": [],
  "test_gaussian_mixture_setting_best_params": [],
  "test_init_means_not_duplicated": [
    "init_params",
    "global_random_seed"
  ],
  "test_means_for_all_inits": [
    "init_params",
    "global_random_seed",
    "global_dtype"
  ],
  "test_max_iter_zero": [],
  "test_gaussian_mixture_precisions_init_diag": [
    "global_dtype"
  ],
  "_generate_data": [
    "seed",
    "n_samples",
    "n_features",
    "n_components",
    "dtype"
  ],
  "_calculate_precisions": [
    "X",
    "resp",
    "covariance_type"
  ],
  "test_gaussian_mixture_precisions_init": [
    "covariance_type",
    "global_random_seed",
    "global_dtype"
  ],
  "test_gaussian_mixture_single_component_stable": [],
  "test_gaussian_mixture_all_init_does_not_estimate_gaussian_parameters": [
    "monkeypatch",
    "global_random_seed"
  ],
  "test_gaussian_mixture_array_api_compliance": [
    "init_params",
    "covariance_type",
    "array_namespace",
    "device_",
    "dtype",
    "use_gmm_array_constructor_arguments"
  ],
  "test_gaussian_mixture_raises_where_array_api_not_implemented": [
    "init_params",
    "array_namespace",
    "device_",
    "dtype"
  ],
  "PRIOR_TYPE": [],
  "test_log_dirichlet_norm": [],
  "test_log_wishart_norm": [],
  "test_bayesian_mixture_weights_prior_initialisation": [],
  "test_bayesian_mixture_mean_prior_initialisation": [],
  "test_bayesian_mixture_precisions_prior_initialisation": [],
  "test_bayesian_mixture_check_is_fitted": [],
  "test_bayesian_mixture_weights": [],
  "test_compare_covar_type": [],
  "test_check_covariance_precision": [],
  "test_invariant_translation": [],
  "test_bayesian_mixture_fit_predict": [
    "seed",
    "max_iter",
    "tol"
  ],
  "test_bayesian_mixture_fit_predict_n_init": [],
  "test_bayesian_mixture_predict_predict_proba": [],
  "_color_brew": [
    "n"
  ],
  "Sentinel": {
    "__repr__": [
      "self"
    ]
  },
  "SENTINEL": [],
  "plot_tree": [
    "decision_tree"
  ],
  "_BaseTreeExporter": {
    "__init__": [
      "self",
      "max_depth",
      "feature_names",
      "class_names",
      "label",
      "filled",
      "impurity",
      "node_ids",
      "proportion",
      "rounded",
      "precision",
      "fontsize"
    ],
    "get_color": [
      "self",
      "value"
    ],
    "get_fill_color": [
      "self",
      "tree",
      "node_id"
    ],
    "node_to_str": [
      "self",
      "tree",
      "node_id",
      "criterion"
    ],
    "str_escape": [
      "self",
      "string"
    ]
  },
  "_DOTTreeExporter": {
    "__init__": [
      "self",
      "out_file",
      "max_depth",
      "feature_names",
      "class_names",
      "label",
      "filled",
      "leaves_parallel",
      "impurity",
      "node_ids",
      "proportion",
      "rotate",
      "rounded",
      "special_characters",
      "precision",
      "fontname"
    ],
    "export": [
      "self",
      "decision_tree"
    ],
    "tail": [
      "self"
    ],
    "head": [
      "self"
    ],
    "recurse": [
      "self",
      "tree",
      "node_id",
      "criterion",
      "parent",
      "depth"
    ],
    "str_escape": [
      "self",
      "string"
    ]
  },
  "_MPLTreeExporter": {
    "__init__": [
      "self",
      "max_depth",
      "feature_names",
      "class_names",
      "label",
      "filled",
      "impurity",
      "node_ids",
      "proportion",
      "rounded",
      "precision",
      "fontsize"
    ],
    "_make_tree": [
      "self",
      "node_id",
      "et",
      "criterion",
      "depth"
    ],
    "export": [
      "self",
      "decision_tree",
      "ax"
    ],
    "recurse": [
      "self",
      "node",
      "tree",
      "ax",
      "max_x",
      "max_y",
      "depth"
    ]
  },
  "export_graphviz": [
    "decision_tree",
    "out_file"
  ],
  "_compute_depth": [
    "tree",
    "node"
  ],
  "export_text": [
    "decision_tree"
  ],
  "DTYPE": [],
  "DOUBLE": [],
  "CRITERIA_CLF": [],
  "CRITERIA_REG": [],
  "DENSE_SPLITTERS": [],
  "SPARSE_SPLITTERS": [],
  "BaseDecisionTree": {
    "__metadata_request__predict": [],
    "__init__": [
      "self"
    ],
    "get_depth": [
      "self"
    ],
    "get_n_leaves": [
      "self"
    ],
    "_support_missing_values": [
      "self",
      "X"
    ],
    "_compute_missing_values_in_feature_mask": [
      "self",
      "X",
      "estimator_name"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input",
      "missing_values_in_feature_mask"
    ],
    "_validate_X_predict": [
      "self",
      "X",
      "check_input"
    ],
    "predict": [
      "self",
      "X",
      "check_input"
    ],
    "apply": [
      "self",
      "X",
      "check_input"
    ],
    "decision_path": [
      "self",
      "X",
      "check_input"
    ],
    "_prune_tree": [
      "self"
    ],
    "cost_complexity_pruning_path": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "feature_importances_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "DecisionTreeClassifier": {
    "__metadata_request__predict_proba": [],
    "__metadata_request__fit": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ],
    "predict_proba": [
      "self",
      "X",
      "check_input"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "DecisionTreeRegressor": {
    "__metadata_request__fit": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ],
    "_compute_partial_dependence_recursion": [
      "self",
      "grid",
      "target_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "ExtraTreeClassifier": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "ExtraTreeRegressor": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "DrawTree": {
    "__init__": [
      "self",
      "tree",
      "parent",
      "depth",
      "number"
    ],
    "left": [
      "self"
    ],
    "right": [
      "self"
    ],
    "lbrother": [
      "self"
    ],
    "get_lmost_sibling": [
      "self"
    ],
    "lmost_sibling": [],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "max_extents": [
      "self"
    ]
  },
  "buchheim": [
    "tree"
  ],
  "third_walk": [
    "tree",
    "n"
  ],
  "first_walk": [
    "v",
    "distance"
  ],
  "apportion": [
    "v",
    "default_ancestor",
    "distance"
  ],
  "move_subtree": [
    "wl",
    "wr",
    "shift"
  ],
  "execute_shifts": [
    "v"
  ],
  "ancestor": [
    "vil",
    "v",
    "default_ancestor"
  ],
  "second_walk": [
    "v",
    "m",
    "depth",
    "min"
  ],
  "Tree": {
    "__init__": [
      "self",
      "label",
      "node_id"
    ]
  },
  "TREE_CLASSIFIER_CLASSES": [],
  "TREE_REGRESSOR_CLASSES": [],
  "TREE_BASED_CLASSIFIER_CLASSES": [],
  "TREE_BASED_REGRESSOR_CLASSES": [],
  "test_monotonic_constraints_classifications": [
    "TreeClassifier",
    "depth_first_builder",
    "sparse_splitter",
    "global_random_seed",
    "csc_container"
  ],
  "test_monotonic_constraints_regressions": [
    "TreeRegressor",
    "depth_first_builder",
    "sparse_splitter",
    "criterion",
    "global_random_seed",
    "csc_container"
  ],
  "test_multiclass_raises": [
    "TreeClassifier"
  ],
  "test_multiple_output_raises": [
    "TreeClassifier"
  ],
  "test_missing_values_raises": [
    "Tree"
  ],
  "test_bad_monotonic_cst_raises": [
    "TreeClassifier"
  ],
  "assert_1d_reg_tree_children_monotonic_bounded": [
    "tree_",
    "monotonic_sign"
  ],
  "test_assert_1d_reg_tree_children_monotonic_bounded": [],
  "assert_1d_reg_monotonic": [
    "clf",
    "monotonic_sign",
    "min_x",
    "max_x",
    "n_steps"
  ],
  "test_1d_opposite_monotonicity_cst_data": [
    "TreeRegressor"
  ],
  "test_1d_tree_nodes_values": [
    "TreeRegressor",
    "monotonic_sign",
    "depth_first_builder",
    "criterion",
    "global_random_seed"
  ],
  "assert_nd_reg_tree_children_monotonic_bounded": [
    "tree_",
    "monotonic_cst"
  ],
  "test_assert_nd_reg_tree_children_monotonic_bounded": [],
  "test_nd_tree_nodes_values": [
    "TreeRegressor",
    "monotonic_sign",
    "depth_first_builder",
    "criterion",
    "global_random_seed"
  ],
  "CLF_CRITERIONS": [],
  "REG_CRITERIONS": [],
  "CLF_TREES": [],
  "REG_TREES": [],
  "SPARSE_TREES": [],
  "X_small": [],
  "y_small": [],
  "y_small_reg": [],
  "digits": [],
  "X_sparse_pos": [],
  "y_random": [],
  "X_sparse_mix": [],
  "DATASETS": [],
  "assert_tree_equal": [
    "d",
    "s",
    "message"
  ],
  "test_classification_toy": [],
  "test_weighted_classification_toy": [],
  "test_regression_toy": [
    "Tree",
    "criterion"
  ],
  "test_xor": [],
  "test_iris": [],
  "test_diabetes_overfit": [
    "name",
    "Tree",
    "criterion"
  ],
  "test_diabetes_underfit": [
    "Tree",
    "criterion",
    "metric",
    "global_random_seed"
  ],
  "test_arrayrepr": [],
  "test_pure_set": [],
  "test_numerical_stability": [],
  "test_importances": [],
  "test_importances_raises": [],
  "test_importances_gini_equal_squared_error": [],
  "test_max_features": [],
  "test_min_samples_split": [],
  "test_min_samples_leaf": [],
  "check_min_weight_fraction_leaf": [
    "name",
    "datasets",
    "sparse_container"
  ],
  "test_min_weight_fraction_leaf_on_dense_input": [
    "name"
  ],
  "test_min_weight_fraction_leaf_on_sparse_input": [
    "name",
    "csc_container"
  ],
  "check_min_weight_fraction_leaf_with_min_samples_leaf": [
    "name",
    "datasets",
    "sparse_container"
  ],
  "test_min_weight_fraction_leaf_with_min_samples_leaf_on_dense_input": [
    "name"
  ],
  "test_min_weight_fraction_leaf_with_min_samples_leaf_on_sparse_input": [
    "name",
    "csc_container"
  ],
  "test_min_impurity_decrease": [
    "global_random_seed"
  ],
  "test_multioutput": [
    "Tree",
    "criterion"
  ],
  "test_classes_shape": [],
  "test_unbalanced_iris": [],
  "test_memory_layout": [],
  "test_sample_weight_invalid": [],
  "test_class_weight_errors": [
    "name"
  ],
  "test_max_leaf_nodes": [],
  "test_max_leaf_nodes_max_depth": [],
  "test_arrays_persist": [],
  "test_only_constant_features": [],
  "test_almost_constant_feature": [
    "tree_cls"
  ],
  "test_behaviour_constant_feature_after_splits": [],
  "test_with_only_one_non_constant_features": [],
  "test_big_input": [],
  "test_realloc": [],
  "test_huge_allocations": [],
  "check_sparse_input": [
    "tree",
    "dataset",
    "max_depth"
  ],
  "test_sparse_input_reg_trees": [
    "tree_type",
    "dataset"
  ],
  "test_sparse_parameters": [
    "tree_type",
    "dataset",
    "csc_container"
  ],
  "test_sparse_criteria": [
    "tree_type",
    "dataset",
    "csc_container",
    "criterion"
  ],
  "test_explicit_sparse_zeros": [
    "tree_type",
    "csc_container",
    "csr_container"
  ],
  "check_raise_error_on_1d_input": [
    "name"
  ],
  "test_1d_input": [
    "name"
  ],
  "test_min_weight_leaf_split_level": [
    "name",
    "sparse_container"
  ],
  "test_public_apply_all_trees": [
    "name"
  ],
  "test_public_apply_sparse_trees": [
    "name",
    "csr_container"
  ],
  "test_decision_path_hardcoded": [],
  "test_decision_path": [
    "name"
  ],
  "test_no_sparse_y_support": [
    "name",
    "csr_container"
  ],
  "test_mae": [],
  "test_criterion_copy": [],
  "test_empty_leaf_infinite_threshold": [
    "sparse_container"
  ],
  "test_prune_tree_classifier_are_subtrees": [
    "dataset",
    "tree_cls"
  ],
  "test_prune_tree_regression_are_subtrees": [
    "dataset",
    "tree_cls"
  ],
  "test_prune_single_node_tree": [],
  "assert_pruning_creates_subtree": [
    "estimator_cls",
    "X",
    "y",
    "pruning_path"
  ],
  "assert_is_subtree": [
    "tree",
    "subtree"
  ],
  "test_apply_path_readonly_all_trees": [
    "name",
    "splitter",
    "sparse_container"
  ],
  "test_poisson_zero_nodes": [
    "seed"
  ],
  "test_poisson_vs_mse": [],
  "test_criterion_entropy_same_as_log_loss": [
    "Tree",
    "n_classes"
  ],
  "test_different_endianness_pickle": [],
  "test_different_endianness_joblib_pickle": [],
  "get_different_bitness_node_ndarray": [
    "node_ndarray"
  ],
  "get_different_alignment_node_ndarray": [
    "node_ndarray"
  ],
  "reduce_tree_with_different_bitness": [
    "tree"
  ],
  "test_different_bitness_pickle": [],
  "test_different_bitness_joblib_pickle": [],
  "test_check_n_classes": [],
  "test_check_value_ndarray": [],
  "test_check_node_ndarray": [],
  "test_splitter_serializable": [
    "Splitter"
  ],
  "test_tree_deserialization_from_read_only_buffer": [
    "tmpdir"
  ],
  "test_min_sample_split_1_error": [
    "Tree"
  ],
  "test_missing_values_best_splitter_on_equal_nodes_no_missing": [
    "criterion"
  ],
  "test_missing_values_random_splitter_on_equal_nodes_no_missing": [
    "criterion",
    "seed"
  ],
  "test_missing_values_best_splitter_three_classes": [
    "criterion"
  ],
  "test_missing_values_best_splitter_to_left": [
    "criterion"
  ],
  "test_missing_values_best_splitter_to_right": [
    "criterion"
  ],
  "test_missing_values_best_splitter_missing_both_classes_has_nan": [
    "criterion"
  ],
  "test_missing_value_errors": [
    "sparse_container",
    "tree"
  ],
  "test_missing_values_poisson": [
    "Tree"
  ],
  "make_friedman1_classification": [],
  "test_missing_values_is_resilience": [
    "make_data",
    "Tree",
    "sample_weight_train",
    "global_random_seed",
    "tolerance"
  ],
  "test_missing_value_is_predictive": [
    "Tree",
    "expected_score",
    "global_random_seed"
  ],
  "test_sample_weight_non_uniform": [
    "make_data",
    "Tree"
  ],
  "test_deterministic_pickle": [],
  "test_regression_tree_missing_values_toy": [
    "Tree",
    "X",
    "criterion",
    "global_random_seed"
  ],
  "test_regression_extra_tree_missing_values_toy": [
    "global_random_seed"
  ],
  "test_classification_tree_missing_values_toy": [],
  "test_build_pruned_tree_py": [],
  "test_build_pruned_tree_infinite_loop": [],
  "test_sort_log2_build": [],
  "test_absolute_errors_precomputation_function": [
    "global_random_seed"
  ],
  "test_absolute_error_accurately_predicts_weighted_median": [
    "global_random_seed"
  ],
  "test_splitting_with_missing_values": [],
  "test_missing_values_and_constant_toy": [],
  "w": [],
  "y_degraded": [],
  "test_graphviz_toy": [],
  "test_graphviz_feature_class_names_array_support": [
    "constructor"
  ],
  "test_graphviz_errors": [],
  "test_friedman_mse_in_graphviz": [],
  "test_precision": [],
  "test_export_text_errors": [],
  "test_export_text": [],
  "test_export_text_feature_class_names_array_support": [
    "constructor"
  ],
  "test_plot_tree_entropy": [
    "pyplot"
  ],
  "test_plot_tree_gini": [
    "pyplot",
    "fontsize"
  ],
  "test_not_fitted_tree": [
    "pyplot"
  ],
  "simple_tree": [],
  "bigger_tree": [],
  "test_buchheim": [
    "tree",
    "n_nodes"
  ],
  "test_cython_weighted_fenwick_tree": [
    "global_random_seed"
  ],
  "TransformedTargetRegressor": {
    "__init__": [
      "self",
      "regressor"
    ],
    "_fit_transformer": [
      "self",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "n_features_in_": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_regressor": [
      "self",
      "get_clone"
    ]
  },
  "_ERR_MSG_1DCOLUMN": [],
  "ColumnTransformer": {
    "__init__": [
      "self",
      "transformers"
    ],
    "_transformers": [
      "self",
      "value"
    ],
    "set_output": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "_iter": [
      "self",
      "fitted",
      "column_as_labels",
      "skip_drop",
      "skip_empty_columns"
    ],
    "_validate_transformers": [
      "self"
    ],
    "_validate_column_callables": [
      "self",
      "X"
    ],
    "_validate_remainder": [
      "self",
      "X"
    ],
    "_get_remainder_cols_dtype": [
      "self"
    ],
    "_get_remainder_cols": [
      "self",
      "indices"
    ],
    "named_transformers_": [
      "self"
    ],
    "_get_feature_name_out_for_transformer": [
      "self",
      "name",
      "trans",
      "feature_names_in"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "_add_prefix_for_feature_names_out": [
      "self",
      "transformer_with_feature_names_out"
    ],
    "_update_fitted_transformers": [
      "self",
      "transformers"
    ],
    "_validate_output": [
      "self",
      "result"
    ],
    "_record_output_indices": [
      "self",
      "Xs"
    ],
    "_log_message": [
      "self",
      "name",
      "idx",
      "total"
    ],
    "_call_func_on_transformers": [
      "self",
      "X",
      "y",
      "func",
      "column_as_labels",
      "routed_params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_hstack": [
      "self",
      "Xs"
    ],
    "_sk_visual_block_": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "_get_empty_routing": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_X": [
    "X"
  ],
  "_is_empty_column_selection": [
    "column"
  ],
  "_get_transformer_list": [
    "estimators"
  ],
  "make_column_transformer": [],
  "make_column_selector": {
    "__init__": [
      "self",
      "pattern"
    ],
    "__call__": [
      "self",
      "df"
    ]
  },
  "_feature_names_out_with_str_format": [
    "transformer_name",
    "feature_name",
    "str_format"
  ],
  "Trans": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "DoubleTrans": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "SparseMatrixTrans": {
    "__init__": [
      "self",
      "csr_container"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TransNo2D": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "TransRaise": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "test_column_transformer": [],
  "test_column_transformer_tuple_transformers_parameter": [],
  "test_column_transformer_dataframe": [
    "constructor_name"
  ],
  "test_column_transformer_empty_columns": [
    "pandas",
    "column_selection",
    "callable_column"
  ],
  "test_column_transformer_output_indices": [],
  "test_column_transformer_output_indices_df": [],
  "test_column_transformer_sparse_array": [
    "csr_container"
  ],
  "test_column_transformer_list": [],
  "test_column_transformer_sparse_stacking": [
    "csr_container",
    "constructor_name"
  ],
  "test_column_transformer_mixed_cols_sparse": [],
  "test_column_transformer_sparse_threshold": [],
  "test_column_transformer_error_msg_1D": [],
  "test_2D_transformer_output": [],
  "test_2D_transformer_output_pandas": [],
  "test_column_transformer_invalid_columns": [
    "remainder"
  ],
  "test_column_transformer_invalid_transformer": [],
  "test_make_column_transformer": [],
  "test_make_column_transformer_pandas": [],
  "test_make_column_transformer_kwargs": [],
  "test_make_column_transformer_remainder_transformer": [],
  "test_column_transformer_get_set_params": [],
  "test_column_transformer_named_estimators": [],
  "test_column_transformer_cloning": [],
  "test_column_transformer_get_feature_names": [],
  "test_column_transformer_special_strings": [],
  "test_column_transformer_remainder": [],
  "test_column_transformer_remainder_dtypes": [
    "cols1",
    "cols2",
    "expected_remainder_cols"
  ],
  "test_force_int_remainder_cols_deprecation": [
    "force_int_remainder_cols"
  ],
  "test_column_transformer_remainder_numpy": [
    "key",
    "expected_cols"
  ],
  "test_column_transformer_remainder_pandas": [
    "key",
    "expected_cols"
  ],
  "test_column_transformer_remainder_transformer": [
    "key",
    "expected_cols"
  ],
  "test_column_transformer_no_remaining_remainder_transformer": [],
  "test_column_transformer_drops_all_remainder_transformer": [],
  "test_column_transformer_sparse_remainder_transformer": [
    "csr_container"
  ],
  "test_column_transformer_drop_all_sparse_remainder_transformer": [
    "csr_container"
  ],
  "test_column_transformer_get_set_params_with_remainder": [],
  "test_column_transformer_no_estimators": [],
  "test_column_transformer_verbose": [
    "est",
    "pattern",
    "method",
    "capsys"
  ],
  "test_column_transformer_no_estimators_set_params": [],
  "test_column_transformer_callable_specifier": [],
  "test_column_transformer_callable_specifier_dataframe": [],
  "test_column_transformer_negative_column_indexes": [],
  "test_column_transformer_mask_indexing": [
    "array_type"
  ],
  "test_n_features_in": [],
  "test_make_column_selector_with_select_dtypes": [
    "cols",
    "pattern",
    "include",
    "exclude"
  ],
  "test_column_transformer_with_make_column_selector": [],
  "test_make_column_selector_error": [],
  "test_make_column_selector_pickle": [],
  "test_feature_names_empty_columns": [
    "empty_col"
  ],
  "test_feature_names_out_pandas": [
    "selector"
  ],
  "test_feature_names_out_non_pandas": [
    "selector"
  ],
  "test_sk_visual_block_remainder": [
    "remainder"
  ],
  "test_sk_visual_block_remainder_drop": [],
  "test_sk_visual_block_remainder_fitted_pandas": [
    "remainder"
  ],
  "test_sk_visual_block_remainder_fitted_numpy": [
    "remainder"
  ],
  "test_column_transformer_reordered_column_names_remainder": [
    "explicit_colname",
    "remainder"
  ],
  "test_feature_name_validation_missing_columns_drop_passthough": [],
  "test_feature_names_in_": [],
  "TransWithNames": {
    "__init__": [
      "self",
      "feature_names_out"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test_verbose_feature_names_out_true": [
    "transformers",
    "remainder",
    "expected_names"
  ],
  "_feature_names_out_callable_name_clash": [
    "trans_name",
    "feat_name"
  ],
  "_feature_names_out_callable_upper": [
    "trans_name",
    "feat_name"
  ],
  "test_verbose_feature_names_out_callable_or_str": [
    "transformers",
    "remainder",
    "verbose_feature_names_out",
    "expected_names"
  ],
  "test_verbose_feature_names_out_false": [
    "transformers",
    "remainder",
    "expected_names"
  ],
  "test_verbose_feature_names_out_false_errors": [
    "transformers",
    "remainder",
    "colliding_columns"
  ],
  "test_column_transformer_set_output": [
    "verbose_feature_names_out",
    "remainder"
  ],
  "test_column_transform_set_output_mixed": [
    "remainder",
    "fit_transform"
  ],
  "test_column_transform_set_output_after_fitting": [
    "remainder"
  ],
  "PandasOutTransformer": {
    "__init__": [
      "self",
      "offset"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "set_output": [
      "self",
      "transform"
    ]
  },
  "test_transformers_with_pandas_out_but_not_feature_names_out": [
    "trans_1",
    "expected_verbose_names",
    "expected_non_verbose_names"
  ],
  "test_empty_selection_pandas_output": [
    "empty_selection"
  ],
  "test_raise_error_if_index_not_aligned": [],
  "test_remainder_set_output": [],
  "test_transform_pd_na": [],
  "test_dataframe_different_dataframe_libraries": [],
  "test_column_transformer__getitem__": [],
  "test_column_transformer_remainder_passthrough_naming_consistency": [
    "transform_output"
  ],
  "test_column_transformer_column_renaming": [
    "dataframe_lib"
  ],
  "test_column_transformer_error_with_duplicated_columns": [
    "dataframe_lib"
  ],
  "test_column_transformer_auto_memmap": [
    "global_random_seed"
  ],
  "test_column_transformer_non_default_index": [],
  "test_metadata_routing_for_column_transformer": [
    "method"
  ],
  "test_metadata_routing_no_fit_transform": [],
  "test_metadata_routing_error_for_column_transformer": [
    "method"
  ],
  "test_get_metadata_routing_works_without_fit": [],
  "test_remainder_request_always_present": [],
  "test_unused_transformer_request_present": [],
  "friedman": [],
  "test_transform_target_regressor_error": [],
  "test_transform_target_regressor_invertible": [],
  "_check_standard_scaled": [
    "y",
    "y_pred"
  ],
  "_check_shifted_by_one": [
    "y",
    "y_pred"
  ],
  "test_transform_target_regressor_functions": [],
  "test_transform_target_regressor_functions_multioutput": [],
  "test_transform_target_regressor_1d_transformer": [
    "X",
    "y"
  ],
  "test_transform_target_regressor_2d_transformer": [
    "X",
    "y"
  ],
  "test_transform_target_regressor_2d_transformer_multioutput": [],
  "test_transform_target_regressor_3d_target": [],
  "test_transform_target_regressor_multi_to_single": [],
  "DummyCheckerArrayTransformer": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "DummyCheckerListRegressor": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_transform_target_regressor_ensure_y_array": [],
  "DummyTransformer": {
    "__init__": [
      "self",
      "fit_counter"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "test_transform_target_regressor_count_fit": [
    "check_inverse"
  ],
  "DummyRegressorWithExtraFitParams": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "check_input"
    ]
  },
  "test_transform_target_regressor_pass_fit_parameters": [],
  "test_transform_target_regressor_route_pipeline": [],
  "DummyRegressorWithExtraPredictParams": {
    "predict": [
      "self",
      "X",
      "check_input"
    ]
  },
  "test_transform_target_regressor_pass_extra_predict_parameters": [],
  "test_transform_target_regressor_not_warns_with_global_output_set": [
    "output_format"
  ],
  "ValidateDimensionRegressor": {
    "__init__": [
      "self",
      "ndim"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_transform_target_regressor_preserves_input_shape": [
    "ndim"
  ],
  "InvalidParameterError": {},
  "validate_parameter_constraints": [
    "parameter_constraints",
    "params",
    "caller_name"
  ],
  "make_constraint": [
    "constraint"
  ],
  "validate_params": [
    "parameter_constraints"
  ],
  "RealNotInt": {},
  "_type_name": [
    "t"
  ],
  "_Constraint": {
    "__init__": [
      "self"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_InstancesOf": {
    "__init__": [
      "self",
      "type"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_NoneConstraint": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_NanConstraint": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_PandasNAConstraint": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "Options": {
    "__init__": [
      "self",
      "type",
      "options"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "_mark_if_deprecated": [
      "self",
      "option"
    ],
    "__str__": [
      "self"
    ]
  },
  "StrOptions": {
    "__init__": [
      "self",
      "options"
    ]
  },
  "Interval": {
    "__init__": [
      "self",
      "type",
      "left",
      "right"
    ],
    "_check_params": [
      "self"
    ],
    "__contains__": [
      "self",
      "val"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_ArrayLikes": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_SparseMatrices": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_Callables": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_RandomStates": {
    "__init__": [
      "self"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_Booleans": {
    "__init__": [
      "self"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_VerboseHelper": {
    "__init__": [
      "self"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "MissingValues": {
    "__init__": [
      "self",
      "numeric_only"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "HasMethods": {
    "__init__": [
      "self",
      "methods"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_IterablesNotString": {
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "_CVObjects": {
    "__init__": [
      "self"
    ],
    "is_satisfied_by": [
      "self",
      "val"
    ],
    "__str__": [
      "self"
    ]
  },
  "Hidden": {
    "__init__": [
      "self",
      "constraint"
    ]
  },
  "generate_invalid_param_val": [
    "constraint"
  ],
  "generate_valid_param": [
    "constraint"
  ],
  "_process_predict_proba": [],
  "_process_decision_function": [],
  "_get_response_values": [
    "estimator",
    "X",
    "response_method",
    "pos_label",
    "return_response_method_used"
  ],
  "_get_response_values_binary": [
    "estimator",
    "X",
    "response_method",
    "pos_label",
    "return_response_method_used"
  ],
  "_init_arpack_v0": [
    "size",
    "random_state"
  ],
  "REGRESSION_DATASET": [],
  "_raise_for_missing_tags": [
    "estimator",
    "tag_name",
    "Mixin"
  ],
  "_yield_api_checks": [
    "estimator"
  ],
  "_yield_checks": [
    "estimator"
  ],
  "_yield_classifier_checks": [
    "classifier"
  ],
  "_yield_regressor_checks": [
    "regressor"
  ],
  "_yield_transformer_checks": [
    "transformer"
  ],
  "_yield_clustering_checks": [
    "clusterer"
  ],
  "_yield_outliers_checks": [
    "estimator"
  ],
  "_yield_array_api_checks": [
    "estimator"
  ],
  "_yield_all_checks": [
    "estimator",
    "legacy"
  ],
  "_check_name": [
    "check"
  ],
  "_maybe_mark": [
    "estimator",
    "check",
    "expected_failed_checks",
    "mark",
    "pytest",
    "xfail_strict"
  ],
  "_should_be_skipped_or_marked": [
    "estimator",
    "check",
    "expected_failed_checks"
  ],
  "estimator_checks_generator": [
    "estimator"
  ],
  "parametrize_with_checks": [
    "estimators"
  ],
  "check_estimator": [
    "estimator"
  ],
  "_regression_dataset": [],
  "_NotAnArray": {
    "__init__": [
      "self",
      "data"
    ],
    "__array__": [
      "self",
      "dtype",
      "copy"
    ],
    "__array_function__": [
      "self",
      "func",
      "types",
      "args",
      "kwargs"
    ]
  },
  "_is_pairwise_metric": [
    "estimator"
  ],
  "_generate_sparse_data": [
    "X_csr"
  ],
  "check_supervised_y_no_nan": [
    "name",
    "estimator_orig"
  ],
  "check_array_api_input": [
    "name",
    "estimator_orig",
    "array_namespace",
    "device",
    "dtype_name",
    "check_values",
    "check_sample_weight"
  ],
  "check_array_api_input_and_values": [
    "name",
    "estimator_orig",
    "array_namespace",
    "device",
    "dtype_name",
    "check_sample_weight"
  ],
  "check_estimator_sparse_tag": [
    "name",
    "estimator_orig"
  ],
  "_check_estimator_sparse_container": [
    "name",
    "estimator_orig",
    "sparse_type"
  ],
  "check_estimator_sparse_matrix": [
    "name",
    "estimator_orig"
  ],
  "check_estimator_sparse_array": [
    "name",
    "estimator_orig"
  ],
  "check_f_contiguous_array_estimator": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weights_pandas_series": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weights_not_an_array": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weights_list": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weights_shape": [
    "name",
    "estimator_orig"
  ],
  "_check_sample_weight_equivalence": [
    "name",
    "estimator_orig",
    "sparse_container"
  ],
  "check_sample_weight_equivalence_on_dense_data": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weight_equivalence_on_sparse_data": [
    "name",
    "estimator_orig"
  ],
  "check_sample_weights_not_overwritten": [
    "name",
    "estimator_orig"
  ],
  "check_dtype_object": [
    "name",
    "estimator_orig"
  ],
  "check_complex_data": [
    "name",
    "estimator_orig"
  ],
  "check_dict_unchanged": [
    "name",
    "estimator_orig"
  ],
  "_is_public_parameter": [
    "attr"
  ],
  "check_dont_overwrite_parameters": [
    "name",
    "estimator_orig"
  ],
  "check_fit2d_predict1d": [
    "name",
    "estimator_orig"
  ],
  "_apply_on_subsets": [
    "func",
    "X"
  ],
  "check_methods_subset_invariance": [
    "name",
    "estimator_orig"
  ],
  "check_methods_sample_order_invariance": [
    "name",
    "estimator_orig"
  ],
  "check_fit2d_1sample": [
    "name",
    "estimator_orig"
  ],
  "check_fit2d_1feature": [
    "name",
    "estimator_orig"
  ],
  "check_fit1d": [
    "name",
    "estimator_orig"
  ],
  "check_transformer_general": [
    "name",
    "transformer",
    "readonly_memmap"
  ],
  "check_transformer_data_not_an_array": [
    "name",
    "transformer"
  ],
  "check_transformers_unfitted": [
    "name",
    "transformer"
  ],
  "check_transformers_unfitted_stateless": [
    "name",
    "transformer"
  ],
  "_check_transformer": [
    "name",
    "transformer_orig",
    "X",
    "y"
  ],
  "check_pipeline_consistency": [
    "name",
    "estimator_orig"
  ],
  "check_mixin_order": [
    "name",
    "estimator_orig"
  ],
  "check_fit_score_takes_y": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_dtypes": [
    "name",
    "estimator_orig"
  ],
  "check_transformer_preserve_dtypes": [
    "name",
    "transformer_orig"
  ],
  "check_estimators_empty_data_messages": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_nan_inf": [
    "name",
    "estimator_orig"
  ],
  "check_nonsquare_error": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_pickle": [
    "name",
    "estimator_orig",
    "readonly_memmap"
  ],
  "check_estimators_partial_fit_n_features": [
    "name",
    "estimator_orig"
  ],
  "check_classifier_multioutput": [
    "name",
    "estimator_orig"
  ],
  "check_regressor_multioutput": [
    "name",
    "estimator"
  ],
  "check_clustering": [
    "name",
    "clusterer_orig",
    "readonly_memmap"
  ],
  "check_clusterer_compute_labels_predict": [
    "name",
    "clusterer_orig"
  ],
  "check_classifiers_one_label": [
    "name",
    "classifier_orig"
  ],
  "check_classifiers_one_label_sample_weights": [
    "name",
    "classifier_orig"
  ],
  "check_classifiers_train": [
    "name",
    "classifier_orig",
    "readonly_memmap",
    "X_dtype"
  ],
  "check_outlier_corruption": [
    "num_outliers",
    "expected_outliers",
    "decision"
  ],
  "check_outliers_train": [
    "name",
    "estimator_orig",
    "readonly_memmap"
  ],
  "check_outlier_contamination": [
    "name",
    "estimator_orig"
  ],
  "check_classifiers_multilabel_representation_invariance": [
    "name",
    "classifier_orig"
  ],
  "check_classifiers_multilabel_output_format_predict": [
    "name",
    "classifier_orig"
  ],
  "check_classifiers_multilabel_output_format_predict_proba": [
    "name",
    "classifier_orig"
  ],
  "check_classifiers_multilabel_output_format_decision_function": [
    "name",
    "classifier_orig"
  ],
  "check_get_feature_names_out_error": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_fit_returns_self": [
    "name",
    "estimator_orig"
  ],
  "check_readonly_memmap_input": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_unfitted": [
    "name",
    "estimator_orig"
  ],
  "check_supervised_y_2d": [
    "name",
    "estimator_orig"
  ],
  "check_classifiers_predictions": [
    "X",
    "y",
    "name",
    "classifier_orig"
  ],
  "_choose_check_classifiers_labels": [
    "name",
    "y",
    "y_names"
  ],
  "check_classifiers_classes": [
    "name",
    "classifier_orig"
  ],
  "check_regressors_int": [
    "name",
    "regressor_orig"
  ],
  "check_regressors_train": [
    "name",
    "regressor_orig",
    "readonly_memmap",
    "X_dtype"
  ],
  "check_regressors_no_decision_function": [
    "name",
    "regressor_orig"
  ],
  "check_class_weight_classifiers": [
    "name",
    "classifier_orig"
  ],
  "check_class_weight_balanced_classifiers": [
    "name",
    "classifier_orig",
    "X_train",
    "y_train",
    "X_test",
    "y_test",
    "weights"
  ],
  "check_class_weight_balanced_linear_classifier": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_overwrite_params": [
    "name",
    "estimator_orig"
  ],
  "check_no_attributes_set_in_init": [
    "name",
    "estimator_orig"
  ],
  "check_sparsify_coefficients": [
    "name",
    "estimator_orig"
  ],
  "check_classifier_data_not_an_array": [
    "name",
    "estimator_orig"
  ],
  "check_regressor_data_not_an_array": [
    "name",
    "estimator_orig"
  ],
  "check_estimators_data_not_an_array": [
    "name",
    "estimator_orig",
    "X",
    "y",
    "obj_type"
  ],
  "check_estimator_cloneable": [
    "name",
    "estimator_orig"
  ],
  "check_estimator_repr": [
    "name",
    "estimator_orig"
  ],
  "check_parameters_default_constructible": [
    "name",
    "estimator_orig"
  ],
  "_enforce_estimator_tags_y": [
    "estimator",
    "y"
  ],
  "_enforce_estimator_tags_X": [
    "estimator",
    "X",
    "X_test",
    "kernel"
  ],
  "check_positive_only_tag_during_fit": [
    "name",
    "estimator_orig"
  ],
  "check_non_transformer_estimators_n_iter": [
    "name",
    "estimator_orig"
  ],
  "check_transformer_n_iter": [
    "name",
    "estimator_orig"
  ],
  "check_get_params_invariance": [
    "name",
    "estimator_orig"
  ],
  "check_set_params": [
    "name",
    "estimator_orig"
  ],
  "check_classifiers_regression_target": [
    "name",
    "estimator_orig"
  ],
  "check_decision_proba_consistency": [
    "name",
    "estimator_orig"
  ],
  "check_outliers_fit_predict": [
    "name",
    "estimator_orig"
  ],
  "check_fit_non_negative": [
    "name",
    "estimator_orig"
  ],
  "check_fit_idempotent": [
    "name",
    "estimator_orig"
  ],
  "check_fit_check_is_fitted": [
    "name",
    "estimator_orig"
  ],
  "check_n_features_in": [
    "name",
    "estimator_orig"
  ],
  "check_requires_y_none": [
    "name",
    "estimator_orig"
  ],
  "check_n_features_in_after_fitting": [
    "name",
    "estimator_orig"
  ],
  "check_valid_tag_types": [
    "name",
    "estimator"
  ],
  "check_estimator_tags_renamed": [
    "name",
    "estimator_orig"
  ],
  "check_dataframe_column_names_consistency": [
    "name",
    "estimator_orig"
  ],
  "check_transformer_get_feature_names_out": [
    "name",
    "transformer_orig"
  ],
  "check_transformer_get_feature_names_out_pandas": [
    "name",
    "transformer_orig"
  ],
  "check_param_validation": [
    "name",
    "estimator_orig"
  ],
  "check_set_output_transform": [
    "name",
    "transformer_orig"
  ],
  "_output_from_fit_transform": [
    "transformer",
    "name",
    "X",
    "df",
    "y"
  ],
  "_check_generated_dataframe": [
    "name",
    "case",
    "index",
    "outputs_default",
    "outputs_dataframe_lib",
    "is_supported_dataframe",
    "create_dataframe",
    "assert_frame_equal"
  ],
  "_check_set_output_transform_dataframe": [
    "name",
    "transformer_orig"
  ],
  "_check_set_output_transform_pandas_context": [
    "name",
    "transformer_orig",
    "context"
  ],
  "check_set_output_transform_pandas": [
    "name",
    "transformer_orig"
  ],
  "check_global_output_transform_pandas": [
    "name",
    "transformer_orig"
  ],
  "_check_set_output_transform_polars_context": [
    "name",
    "transformer_orig",
    "context"
  ],
  "check_set_output_transform_polars": [
    "name",
    "transformer_orig"
  ],
  "check_global_set_output_transform_polars": [
    "name",
    "transformer_orig"
  ],
  "check_inplace_ensure_writeable": [
    "name",
    "estimator_orig"
  ],
  "check_do_not_raise_errors_in_init_or_set_params": [
    "name",
    "estimator_orig"
  ],
  "check_classifier_not_supporting_multiclass": [
    "name",
    "estimator_orig"
  ],
  "check_library_installed": [
    "library"
  ],
  "get_columns": [
    "columns"
  ],
  "ContainerAdapterProtocol": {
    "create_container": [
      "self",
      "X_output",
      "X_original",
      "columns",
      "inplace"
    ],
    "is_supported_container": [
      "self",
      "X"
    ],
    "rename_columns": [
      "self",
      "X",
      "columns"
    ],
    "hstack": [
      "self",
      "Xs"
    ]
  },
  "PandasAdapter": {
    "container_lib": [],
    "create_container": [
      "self",
      "X_output",
      "X_original",
      "columns",
      "inplace"
    ],
    "is_supported_container": [
      "self",
      "X"
    ],
    "rename_columns": [
      "self",
      "X",
      "columns"
    ],
    "hstack": [
      "self",
      "Xs"
    ]
  },
  "PolarsAdapter": {
    "container_lib": [],
    "create_container": [
      "self",
      "X_output",
      "X_original",
      "columns",
      "inplace"
    ],
    "is_supported_container": [
      "self",
      "X"
    ],
    "rename_columns": [
      "self",
      "X",
      "columns"
    ],
    "hstack": [
      "self",
      "Xs"
    ]
  },
  "ContainerAdaptersManager": {
    "__init__": [
      "self"
    ],
    "supported_outputs": [
      "self"
    ],
    "register": [
      "self",
      "adapter"
    ]
  },
  "ADAPTERS_MANAGER": [],
  "_get_adapter_from_container": [
    "container"
  ],
  "_get_container_adapter": [
    "method",
    "estimator"
  ],
  "_get_output_config": [
    "method",
    "estimator"
  ],
  "_wrap_data_with_container": [
    "method",
    "data_to_wrap",
    "original_input",
    "estimator"
  ],
  "_wrap_method_output": [
    "f",
    "method"
  ],
  "_auto_wrap_is_configured": [
    "estimator"
  ],
  "_SetOutputMixin": {
    "__init_subclass__": [
      "cls",
      "auto_wrap_output_keys"
    ],
    "set_output": [
      "self"
    ]
  },
  "_safe_set_output": [
    "estimator"
  ],
  "Bunch": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "_set_deprecated": [
      "self",
      "value"
    ],
    "__setattr__": [
      "self",
      "key",
      "value"
    ],
    "__dir__": [
      "self"
    ],
    "__getattr__": [
      "self",
      "key"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "single_source_shortest_path_length": [
    "graph",
    "source"
  ],
  "_fix_connected_components": [
    "X",
    "graph",
    "n_connected_components",
    "component_labels",
    "mode",
    "metric"
  ],
  "check_matplotlib_support": [
    "caller_name"
  ],
  "check_pandas_support": [
    "caller_name"
  ],
  "chunk_generator": [
    "gen",
    "chunksize"
  ],
  "gen_batches": [
    "n",
    "batch_size"
  ],
  "gen_even_slices": [
    "n",
    "n_packs"
  ],
  "get_chunk_n_rows": [
    "row_bytes"
  ],
  "deprecated": {
    "__init__": [
      "self",
      "extra"
    ],
    "__call__": [
      "self",
      "obj"
    ],
    "_decorate_class": [
      "self",
      "cls"
    ],
    "_decorate_fun": [
      "self",
      "fun"
    ],
    "_decorate_property": [
      "self",
      "prop"
    ]
  },
  "_is_deprecated": [
    "func"
  ],
  "_get_sys_info": [],
  "_get_deps_info": [],
  "show_versions": [],
  "_weighted_percentile": [
    "array",
    "sample_weight",
    "percentile_rank",
    "average",
    "xp"
  ],
  "_IS_32BIT": [],
  "_IS_WASM": [],
  "np_version": [],
  "np_base_version": [],
  "sp_version": [],
  "sp_base_version": [],
  "CSR_CONTAINERS": [],
  "CSC_CONTAINERS": [],
  "COO_CONTAINERS": [],
  "LIL_CONTAINERS": [],
  "DOK_CONTAINERS": [],
  "BSR_CONTAINERS": [],
  "DIA_CONTAINERS": [],
  "_object_dtype_isnan": [
    "X"
  ],
  "_mode": [
    "a",
    "axis"
  ],
  "pd_fillna": [
    "pd",
    "frame"
  ],
  "_preserve_dia_indices_dtype": [
    "sparse_container",
    "original_container_format",
    "requested_sparse_format"
  ],
  "_smallest_admissible_index_dtype": [
    "arrays",
    "maxval",
    "check_contents"
  ],
  "tarfile_extractall": [
    "tarfile",
    "path"
  ],
  "_in_unstable_openblas_configuration": [],
  "_get_additional_lbfgs_options_dict": [
    "key",
    "value"
  ],
  "PYARROW_VERSION_BELOW_17": [],
  "_BinaryClassifierCurveDisplayMixin": {
    "_validate_plot_params": [
      "self"
    ],
    "_validate_and_get_response_values": [
      "cls",
      "estimator",
      "X",
      "y"
    ],
    "_validate_from_predictions_params": [
      "cls",
      "y_true",
      "y_pred"
    ],
    "_validate_from_cv_results_params": [
      "cls",
      "cv_results",
      "X",
      "y"
    ],
    "_get_legend_label": [
      "curve_legend_metric",
      "curve_name",
      "legend_metric_name"
    ],
    "_validate_curve_kwargs": [
      "n_curves",
      "name",
      "legend_metric",
      "legend_metric_name",
      "curve_kwargs",
      "default_curve_kwargs",
      "default_multi_curve_kwargs"
    ]
  },
  "_validate_score_name": [
    "score_name",
    "scoring",
    "negate_score"
  ],
  "_interval_max_min_ratio": [
    "data"
  ],
  "_validate_style_kwargs": [
    "default_style_kwargs",
    "user_style_kwargs"
  ],
  "_despine": [
    "ax"
  ],
  "_deprecate_estimator_name": [
    "estimator_name",
    "name",
    "version"
  ],
  "_convert_to_list_leaving_none": [
    "param"
  ],
  "_check_param_lengths": [
    "required",
    "optional",
    "class_name"
  ],
  "_deprecate_y_pred_parameter": [
    "y_score",
    "y_pred",
    "version"
  ],
  "ArraySlicingWrapper": {
    "__init__": [
      "self",
      "array"
    ],
    "__getitem__": [
      "self",
      "aslice"
    ]
  },
  "MockDataFrame": {
    "__init__": [
      "self",
      "array"
    ],
    "__len__": [
      "self"
    ],
    "__array__": [
      "self",
      "dtype"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "take": [
      "self",
      "indices",
      "axis"
    ]
  },
  "CheckingClassifier": {
    "__init__": [
      "self"
    ],
    "_check_X_y": [
      "self",
      "X",
      "y",
      "should_be_fitted"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "NoSampleWeightWrapper": {
    "__init__": [
      "self",
      "est"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_response": [
    "method"
  ],
  "_MockEstimatorOnOffPrediction": {
    "__init__": [
      "self",
      "response_methods"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "_get_dense_mask": [
    "X",
    "value_to_mask"
  ],
  "_get_mask": [
    "X",
    "value_to_mask"
  ],
  "safe_mask": [
    "X",
    "mask"
  ],
  "axis0_safe_slice": [
    "X",
    "mask",
    "len_mask"
  ],
  "indices_to_mask": [
    "indices",
    "mask_length"
  ],
  "SkipTest": [],
  "ignore_warnings": [
    "obj",
    "category"
  ],
  "_IgnoreWarnings": {
    "__init__": [
      "self",
      "category"
    ],
    "__call__": [
      "self",
      "fn"
    ],
    "__repr__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "assert_allclose": [
    "actual",
    "desired",
    "rtol",
    "atol",
    "equal_nan",
    "err_msg",
    "verbose"
  ],
  "assert_allclose_dense_sparse": [
    "x",
    "y",
    "rtol",
    "atol",
    "err_msg"
  ],
  "set_random_state": [
    "estimator",
    "random_state"
  ],
  "_is_numpydoc": [],
  "check_skip_network": [],
  "_delete_folder": [
    "folder_path",
    "warn"
  ],
  "TempMemmap": {
    "__init__": [
      "self",
      "data",
      "mmap_mode"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "create_memmap_backed_data": [
    "data",
    "mmap_mode",
    "return_folder"
  ],
  "_get_args": [
    "function",
    "varargs"
  ],
  "_get_func_name": [
    "func"
  ],
  "check_docstring_parameters": [
    "func",
    "doc",
    "ignore"
  ],
  "_check_item_included": [
    "item_name",
    "args"
  ],
  "_diff_key": [
    "line"
  ],
  "_get_diff_msg": [
    "docstrings_grouped"
  ],
  "_check_consistency_items": [
    "items_docs",
    "type_or_desc",
    "section",
    "n_objects",
    "descr_regex_pattern",
    "ignore_types"
  ],
  "assert_docstring_consistency": [
    "objects",
    "include_params",
    "exclude_params",
    "include_attrs",
    "exclude_attrs",
    "include_returns",
    "exclude_returns",
    "descr_regex_pattern",
    "ignore_types"
  ],
  "assert_run_python_script_without_output": [
    "source_code",
    "pattern",
    "timeout"
  ],
  "_convert_container": [
    "container",
    "constructor_name",
    "columns_name",
    "dtype",
    "minversion",
    "categorical_feature_names"
  ],
  "raises": [
    "expected_exc_type",
    "match",
    "may_pass",
    "err_msg"
  ],
  "_Raises": {
    "__init__": [
      "self",
      "expected_exc_type",
      "match",
      "may_pass",
      "err_msg"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "_"
    ]
  },
  "MinimalClassifier": {
    "__init__": [
      "self",
      "param"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MinimalRegressor": {
    "__init__": [
      "self",
      "param"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MinimalTransformer": {
    "__init__": [
      "self",
      "param"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_array_api_for_tests": [
    "array_namespace",
    "device"
  ],
  "_get_warnings_filters_info_list": [],
  "get_pytest_filterwarning_lines": [],
  "turn_warnings_into_errors": [],
  "KeyValTuple": {
    "__repr__": [
      "self"
    ]
  },
  "KeyValTupleParam": {},
  "_changed_params": [
    "estimator"
  ],
  "_EstimatorPrettyPrinter": {
    "__init__": [
      "self",
      "indent",
      "width",
      "depth",
      "stream"
    ],
    "format": [
      "self",
      "object",
      "context",
      "maxlevels",
      "level"
    ],
    "_pprint_estimator": [
      "self",
      "object",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "_format_dict_items": [
      "self",
      "items",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "_format_params": [
      "self",
      "items",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "_format_params_or_dict_items": [
      "self",
      "object",
      "stream",
      "indent",
      "allowance",
      "context",
      "level",
      "is_dict"
    ],
    "_format_items": [
      "self",
      "items",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "_pprint_key_val_tuple": [
      "self",
      "object",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "_dispatch": []
  },
  "_safe_repr": [
    "object",
    "context",
    "maxlevels",
    "level",
    "changed_only"
  ],
  "_attach_unique": [
    "y"
  ],
  "attach_unique": [],
  "_cached_unique": [
    "y",
    "xp"
  ],
  "cached_unique": [],
  "_raise_typeerror": [
    "X"
  ],
  "_raise_error_wrong_axis": [
    "axis"
  ],
  "inplace_csr_column_scale": [
    "X",
    "scale"
  ],
  "inplace_csr_row_scale": [
    "X",
    "scale"
  ],
  "mean_variance_axis": [
    "X",
    "axis",
    "weights",
    "return_sum_weights"
  ],
  "incr_mean_variance_axis": [
    "X"
  ],
  "inplace_column_scale": [
    "X",
    "scale"
  ],
  "inplace_row_scale": [
    "X",
    "scale"
  ],
  "inplace_swap_row_csc": [
    "X",
    "m",
    "n"
  ],
  "inplace_swap_row_csr": [
    "X",
    "m",
    "n"
  ],
  "inplace_swap_row": [
    "X",
    "m",
    "n"
  ],
  "inplace_swap_column": [
    "X",
    "m",
    "n"
  ],
  "min_max_axis": [
    "X",
    "axis",
    "ignore_nan"
  ],
  "count_nonzero": [
    "X",
    "axis",
    "sample_weight"
  ],
  "_get_median": [
    "data",
    "n_zeros"
  ],
  "_get_elem_at_rank": [
    "rank",
    "data",
    "n_negative",
    "n_zeros"
  ],
  "csc_median_axis_0": [
    "X"
  ],
  "_implicit_column_offset": [
    "X",
    "offset"
  ],
  "sparse_matmul_to_dense": [
    "A",
    "B",
    "out"
  ],
  "is_scalar_nan": [
    "x"
  ],
  "is_pandas_na": [
    "x"
  ],
  "_MODULE_TO_IGNORE": [],
  "all_estimators": [
    "type_filter"
  ],
  "all_displays": [],
  "_is_checked_function": [
    "item"
  ],
  "all_functions": [],
  "compute_class_weight": [
    "class_weight"
  ],
  "compute_sample_weight": [
    "class_weight",
    "y"
  ],
  "squared_norm": [
    "x"
  ],
  "row_norms": [
    "X",
    "squared"
  ],
  "fast_logdet": [
    "A"
  ],
  "density": [
    "w"
  ],
  "safe_sparse_dot": [
    "a",
    "b"
  ],
  "randomized_range_finder": [
    "A"
  ],
  "_randomized_range_finder": [
    "A"
  ],
  "randomized_svd": [
    "M",
    "n_components"
  ],
  "_randomized_svd": [
    "M",
    "n_components"
  ],
  "_randomized_eigsh": [
    "M",
    "n_components"
  ],
  "weighted_mode": [
    "a",
    "w"
  ],
  "cartesian": [
    "arrays",
    "out"
  ],
  "svd_flip": [
    "u",
    "v",
    "u_based_decision"
  ],
  "softmax": [
    "X",
    "copy"
  ],
  "make_nonnegative": [
    "X",
    "min_value"
  ],
  "_safe_accumulator_op": [
    "op",
    "x"
  ],
  "_incremental_mean_and_var": [
    "X",
    "last_mean",
    "last_variance",
    "last_sample_count",
    "sample_weight"
  ],
  "_deterministic_vector_sign_flip": [
    "u"
  ],
  "stable_cumsum": [
    "arr",
    "axis",
    "rtol",
    "atol"
  ],
  "_nanaverage": [
    "a",
    "weights"
  ],
  "safe_sqr": [
    "X"
  ],
  "_approximate_mode": [
    "class_counts",
    "n_draws",
    "rng"
  ],
  "_threadpool_controller": [],
  "_with_config_and_warning_filters": [
    "delayed_func",
    "config",
    "warning_filters"
  ],
  "Parallel": {
    "__call__": [
      "self",
      "iterable"
    ]
  },
  "delayed": [
    "function"
  ],
  "_FuncWrapper": {
    "__init__": [
      "self",
      "function"
    ],
    "with_config_and_warning_filters": [
      "self",
      "config",
      "warning_filters"
    ],
    "__call__": [
      "self"
    ]
  },
  "_get_threadpool_controller": [],
  "_threadpool_controller_decorator": [
    "limits",
    "user_api"
  ],
  "SIMPLE_METHODS": [],
  "COMPOSITE_METHODS": [],
  "METHODS": [],
  "_routing_repr": [
    "obj"
  ],
  "_routing_enabled": [],
  "_raise_for_params": [
    "params",
    "owner",
    "method",
    "allow"
  ],
  "_raise_for_unsupported_routing": [
    "obj",
    "method"
  ],
  "_RoutingNotSupportedMixin": {
    "get_metadata_routing": [
      "self"
    ]
  },
  "UNUSED": [],
  "WARN": [],
  "UNCHANGED": [],
  "VALID_REQUEST_VALUES": [],
  "request_is_alias": [
    "item"
  ],
  "request_is_valid": [
    "item"
  ],
  "MethodMetadataRequest": {
    "__init__": [
      "self",
      "owner",
      "method",
      "requests"
    ],
    "requests": [
      "self"
    ],
    "add_request": [
      "self"
    ],
    "_get_param_names": [
      "self",
      "return_alias"
    ],
    "_check_warnings": [
      "self"
    ],
    "_route_params": [
      "self",
      "params",
      "parent",
      "caller"
    ],
    "_consumes": [
      "self",
      "params"
    ],
    "_serialize": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "MetadataRequest": {
    "_type": [],
    "__init__": [
      "self",
      "owner"
    ],
    "consumes": [
      "self",
      "method",
      "params"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "_get_param_names": [
      "self",
      "method",
      "return_alias",
      "ignore_self_request"
    ],
    "_route_params": [
      "self"
    ],
    "_check_warnings": [
      "self"
    ],
    "_serialize": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "RouterMappingPair": [],
  "MethodPair": [],
  "MethodMapping": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "add": [
      "self"
    ],
    "_serialize": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "MetadataRouter": {
    "_type": [],
    "__init__": [
      "self",
      "owner"
    ],
    "add_self_request": [
      "self",
      "obj"
    ],
    "add": [
      "self"
    ],
    "consumes": [
      "self",
      "method",
      "params"
    ],
    "_get_param_names": [
      "self"
    ],
    "_route_params": [
      "self"
    ],
    "route_params": [
      "self"
    ],
    "validate_metadata": [
      "self"
    ],
    "_serialize": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "get_routing_for_object": [
    "obj"
  ],
  "REQUESTER_DOC": [],
  "REQUESTER_DOC_PARAM": [],
  "REQUESTER_DOC_RETURN": [],
  "RequestMethod": {
    "__init__": [
      "self",
      "name",
      "keys",
      "validate_keys"
    ],
    "__get__": [
      "self",
      "instance",
      "owner"
    ]
  },
  "_MetadataRequester": {
    "__init_subclass__": [
      "cls"
    ],
    "_get_class_level_metadata_request_values": [
      "cls",
      "method"
    ],
    "_get_metadata_request": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "process_routing": [],
  "_BaseComposition": {
    "__init__": [
      "self"
    ],
    "_get_params": [
      "self",
      "attr",
      "deep"
    ],
    "_set_params": [
      "self",
      "attr"
    ],
    "_replace_estimator": [
      "self",
      "attr",
      "name",
      "new_val"
    ],
    "_validate_names": [
      "self",
      "names"
    ]
  },
  "_safe_split": [
    "estimator",
    "X",
    "y",
    "indices",
    "train_indices"
  ],
  "_message_with_time": [
    "source",
    "message",
    "time"
  ],
  "_print_elapsed_time": [
    "source",
    "message"
  ],
  "FLOAT_DTYPES": [],
  "_deprecate_positional_args": [
    "func"
  ],
  "_assert_all_finite": [
    "X",
    "allow_nan",
    "msg_dtype",
    "estimator_name",
    "input_name"
  ],
  "_assert_all_finite_element_wise": [
    "X"
  ],
  "assert_all_finite": [
    "X"
  ],
  "as_float_array": [
    "X"
  ],
  "_is_arraylike": [
    "x"
  ],
  "_is_arraylike_not_scalar": [
    "array"
  ],
  "_use_interchange_protocol": [
    "X"
  ],
  "_num_features": [
    "X"
  ],
  "_num_samples": [
    "x"
  ],
  "check_memory": [
    "memory"
  ],
  "check_consistent_length": [],
  "_make_indexable": [
    "iterable"
  ],
  "indexable": [],
  "_ensure_sparse_format": [
    "sparse_container",
    "accept_sparse",
    "dtype",
    "copy",
    "ensure_all_finite",
    "accept_large_sparse",
    "estimator_name",
    "input_name"
  ],
  "_ensure_no_complex_data": [
    "array"
  ],
  "_check_estimator_name": [
    "estimator"
  ],
  "_pandas_dtype_needs_early_conversion": [
    "pd_dtype"
  ],
  "_is_extension_array_dtype": [
    "array"
  ],
  "check_array": [
    "array",
    "accept_sparse"
  ],
  "_check_large_sparse": [
    "X",
    "accept_large_sparse"
  ],
  "check_X_y": [
    "X",
    "y",
    "accept_sparse"
  ],
  "_check_y": [
    "y",
    "multi_output",
    "y_numeric",
    "estimator"
  ],
  "column_or_1d": [
    "y"
  ],
  "check_random_state": [
    "seed"
  ],
  "has_fit_parameter": [
    "estimator",
    "parameter"
  ],
  "check_symmetric": [
    "array"
  ],
  "_is_fitted": [
    "estimator",
    "attributes",
    "all_or_any"
  ],
  "check_is_fitted": [
    "estimator",
    "attributes"
  ],
  "_estimator_has": [
    "attr"
  ],
  "check_non_negative": [
    "X",
    "whom"
  ],
  "check_scalar": [
    "x",
    "name",
    "target_type"
  ],
  "_check_psd_eigenvalues": [
    "lambdas",
    "enable_warnings"
  ],
  "_check_sample_weight": [
    "sample_weight",
    "X"
  ],
  "_allclose_dense_sparse": [
    "x",
    "y",
    "rtol",
    "atol"
  ],
  "_check_response_method": [
    "estimator",
    "response_method"
  ],
  "_check_method_params": [
    "X",
    "params",
    "indices"
  ],
  "_get_feature_names": [
    "X"
  ],
  "_check_feature_names_in": [
    "estimator",
    "input_features"
  ],
  "_generate_get_feature_names_out": [
    "estimator",
    "n_features_out",
    "input_features"
  ],
  "_check_monotonic_cst": [
    "estimator",
    "monotonic_cst"
  ],
  "_check_pos_label_consistency": [
    "pos_label",
    "y_true"
  ],
  "_to_object_array": [
    "sequence"
  ],
  "_check_n_features": [
    "estimator",
    "X",
    "reset"
  ],
  "validate_data": [
    "X",
    "y",
    "reset",
    "validate_separately",
    "skip_check_array"
  ],
  "_NUMPY_NAMESPACE_NAMES": [],
  "yield_namespaces": [
    "include_numpy_namespaces"
  ],
  "yield_namespace_device_dtype_combinations": [
    "include_numpy_namespaces"
  ],
  "_get_namespace_device_dtype_ids": [
    "param"
  ],
  "_check_array_api_dispatch": [
    "array_api_dispatch"
  ],
  "_single_array_device": [
    "array"
  ],
  "device": [],
  "size": [
    "x"
  ],
  "_is_numpy_namespace": [
    "xp"
  ],
  "_union1d": [
    "a",
    "b",
    "xp"
  ],
  "supported_float_dtypes": [
    "xp",
    "device"
  ],
  "_remove_non_arrays": [],
  "get_namespace": [],
  "get_namespace_and_device": [],
  "move_to": [],
  "_expit": [
    "X",
    "xp"
  ],
  "_validate_diagonal_args": [
    "array",
    "value",
    "xp"
  ],
  "_fill_diagonal": [
    "array",
    "value",
    "xp"
  ],
  "_add_to_diagonal": [
    "array",
    "value",
    "xp"
  ],
  "_is_xp_namespace": [
    "xp",
    "name"
  ],
  "_max_precision_float_dtype": [
    "xp",
    "device"
  ],
  "_find_matching_floating_dtype": [],
  "_average": [
    "a",
    "axis",
    "weights",
    "normalize",
    "xp"
  ],
  "_median": [
    "x",
    "axis",
    "keepdims",
    "xp"
  ],
  "_xlogy": [
    "x",
    "y",
    "xp"
  ],
  "_nanmin": [
    "X",
    "axis",
    "xp"
  ],
  "_nanmax": [
    "X",
    "axis",
    "xp"
  ],
  "_nanmean": [
    "X",
    "axis",
    "xp"
  ],
  "_nansum": [
    "X",
    "axis",
    "xp",
    "keepdims",
    "dtype"
  ],
  "_asarray_with_order": [
    "array",
    "dtype",
    "order",
    "copy"
  ],
  "_ravel": [
    "array",
    "xp"
  ],
  "_convert_to_numpy": [
    "array",
    "xp"
  ],
  "_estimator_with_converted_arrays": [
    "estimator",
    "converter"
  ],
  "_atol_for_type": [
    "dtype_or_dtype_name"
  ],
  "indexing_dtype": [
    "xp"
  ],
  "_isin": [
    "element",
    "test_elements",
    "xp",
    "assume_unique",
    "invert"
  ],
  "_in1d": [
    "ar1",
    "ar2",
    "xp",
    "assume_unique",
    "invert"
  ],
  "_count_nonzero": [
    "X",
    "axis",
    "sample_weight",
    "xp",
    "device"
  ],
  "_modify_in_place_if_numpy": [
    "xp",
    "func"
  ],
  "_bincount": [
    "array",
    "weights",
    "minlength",
    "xp"
  ],
  "_tolist": [
    "array",
    "xp"
  ],
  "_logsumexp": [
    "array",
    "axis",
    "xp"
  ],
  "_cholesky": [
    "covariance",
    "xp"
  ],
  "_linalg_solve": [
    "cov_chol",
    "eye_matrix",
    "xp"
  ],
  "_half_multinomial_loss": [
    "y",
    "pred",
    "sample_weight",
    "xp"
  ],
  "_LineSearchError": {},
  "_line_search_wolfe12": [
    "f",
    "fprime",
    "xk",
    "pk",
    "gfk",
    "old_fval",
    "old_old_fval",
    "verbose"
  ],
  "_cg": [
    "fhess_p",
    "fgrad",
    "maxiter",
    "tol",
    "verbose"
  ],
  "_newton_cg": [
    "grad_hess",
    "func",
    "grad",
    "x0",
    "args",
    "tol",
    "maxiter",
    "maxinner",
    "line_search",
    "warn",
    "verbose"
  ],
  "_check_optimize_result": [
    "solver",
    "result",
    "max_iter",
    "extra_warning_msg"
  ],
  "_unique": [
    "values"
  ],
  "_unique_np": [
    "values",
    "return_inverse",
    "return_counts"
  ],
  "_extract_missing": [
    "values"
  ],
  "_nandict": {
    "__init__": [
      "self",
      "mapping"
    ],
    "__missing__": [
      "self",
      "key"
    ]
  },
  "_map_to_integer": [
    "values",
    "uniques"
  ],
  "_unique_python": [
    "values"
  ],
  "_encode": [
    "values"
  ],
  "_check_unknown": [
    "values",
    "known_values",
    "return_mask"
  ],
  "_NaNCounter": {
    "__init__": [
      "self",
      "items"
    ],
    "_generate_items": [
      "self",
      "items"
    ],
    "__missing__": [
      "self",
      "key"
    ]
  },
  "_get_counts": [
    "values",
    "uniques"
  ],
  "is_df_or_series": [
    "X"
  ],
  "is_pandas_df_or_series": [
    "X"
  ],
  "is_pandas_df": [
    "X"
  ],
  "is_pyarrow_data": [
    "X"
  ],
  "is_polars_df_or_series": [
    "X"
  ],
  "is_polars_df": [
    "X"
  ],
  "_unique_multiclass": [
    "y",
    "xp"
  ],
  "_unique_indicator": [
    "y",
    "xp"
  ],
  "_FN_UNIQUE_LABELS": [],
  "unique_labels": [],
  "_is_integral_float": [
    "y"
  ],
  "is_multilabel": [
    "y"
  ],
  "check_classification_targets": [
    "y"
  ],
  "type_of_target": [
    "y",
    "input_name",
    "raise_unknown"
  ],
  "_check_partial_fit_first_call": [
    "clf",
    "classes"
  ],
  "class_distribution": [
    "y",
    "sample_weight"
  ],
  "_ovr_decision_function": [
    "predictions",
    "confidences",
    "n_classes"
  ],
  "_random_choice_csc": [
    "n_samples",
    "classes",
    "class_probability",
    "random_state"
  ],
  "_AvailableIfDescriptor": {
    "__init__": [
      "self",
      "fn",
      "check",
      "attribute_name"
    ],
    "_check": [
      "self",
      "obj",
      "owner"
    ],
    "__get__": [
      "self",
      "obj",
      "owner"
    ]
  },
  "available_if": [
    "check"
  ],
  "_array_indexing": [
    "array",
    "key",
    "key_dtype",
    "axis"
  ],
  "_pandas_indexing": [
    "X",
    "key",
    "key_dtype",
    "axis"
  ],
  "_list_indexing": [
    "X",
    "key",
    "key_dtype"
  ],
  "_polars_indexing": [
    "X",
    "key",
    "key_dtype",
    "axis"
  ],
  "_pyarrow_indexing": [
    "X",
    "key",
    "key_dtype",
    "axis"
  ],
  "_determine_key_type": [
    "key",
    "accept_slice"
  ],
  "_safe_indexing": [
    "X",
    "indices"
  ],
  "_safe_assign": [
    "X",
    "values"
  ],
  "_get_column_indices_for_bool_or_int": [
    "key",
    "n_columns"
  ],
  "_get_column_indices": [
    "X",
    "key"
  ],
  "_get_column_indices_interchange": [
    "X_interchange",
    "key",
    "key_dtype"
  ],
  "resample": [],
  "shuffle": [],
  "InputTags": {},
  "TargetTags": {},
  "TransformerTags": {},
  "ClassifierTags": {},
  "RegressorTags": {},
  "Tags": {},
  "get_tags": [
    "estimator"
  ],
  "test_newton_cg": [
    "global_random_seed"
  ],
  "test_newton_cg_verbosity": [
    "capsys",
    "verbose"
  ],
  "test_check_optimize": [],
  "test_object_dtype_isnan": [
    "dtype",
    "val"
  ],
  "test_smallest_admissible_index_dtype_max_val": [
    "params",
    "expected_dtype"
  ],
  "test_smallest_admissible_index_dtype_without_checking_contents": [
    "params",
    "expected_dtype"
  ],
  "test_smallest_admissible_index_dtype_by_checking_contents": [
    "params",
    "expected_dtype"
  ],
  "test_smallest_admissible_index_dtype_error": [
    "params",
    "err_type",
    "err_msg"
  ],
  "y64": [],
  "sample_weight64": [],
  "y32": [],
  "sample_weight32": [],
  "floating": [],
  "assert_csr_equal_values": [
    "current",
    "expected"
  ],
  "_make_dense_dataset": [
    "float_dtype"
  ],
  "_make_sparse_dataset": [
    "csr_container",
    "float_dtype"
  ],
  "_dense_dataset_factories": [],
  "_sparse_dataset_factories": [],
  "_fused_types_dataset_factories": [],
  "test_seq_dataset_basic_iteration": [
    "dataset_factory",
    "csr_container"
  ],
  "test_seq_dataset_shuffle": [
    "float_dtype",
    "csr_container"
  ],
  "test_fused_types_consistency": [
    "dataset_32_factory",
    "dataset_64_factory"
  ],
  "test_buffer_dtype_mismatch_error": [],
  "test_gen_even_slices": [],
  "test_get_chunk_n_rows": [
    "row_bytes",
    "max_n_rows",
    "working_memory",
    "expected"
  ],
  "test_get_chunk_n_rows_warns": [],
  "test_message_with_time": [
    "source",
    "message",
    "is_long",
    "time",
    "time_str"
  ],
  "test_print_elapsed_time": [
    "message",
    "expected",
    "capsys",
    "monkeypatch"
  ],
  "test_density": [
    "sparse_container"
  ],
  "test_uniform_weights": [],
  "test_random_weights": [],
  "test_randomized_svd_low_rank_all_dtypes": [
    "dtype"
  ],
  "test_randomized_eigsh": [
    "dtype"
  ],
  "test_randomized_eigsh_compared_to_others": [
    "k"
  ],
  "test_randomized_eigsh_reconst_low_rank": [
    "n",
    "rank"
  ],
  "test_row_norms": [
    "dtype",
    "csr_container"
  ],
  "test_randomized_svd_low_rank_with_noise": [],
  "test_randomized_svd_infinite_rank": [],
  "test_randomized_svd_transpose_consistency": [],
  "test_randomized_svd_power_iteration_normalizer": [],
  "test_randomized_svd_sparse_warnings": [
    "sparse_container"
  ],
  "test_svd_flip": [],
  "test_svd_flip_max_abs_cols": [
    "n_samples",
    "n_features",
    "global_random_seed"
  ],
  "test_randomized_svd_sign_flip": [],
  "test_randomized_svd_sign_flip_with_transpose": [],
  "test_randomized_svd_lapack_driver": [
    "n",
    "m",
    "k",
    "seed"
  ],
  "test_cartesian": [],
  "test_cartesian_mix_types": [
    "arrays",
    "output_dtype"
  ],
  "test_incremental_weighted_mean_and_variance_simple": [
    "dtype",
    "as_list"
  ],
  "test_incremental_weighted_mean_and_variance_array_api": [
    "array_namespace",
    "device",
    "dtype"
  ],
  "test_incremental_weighted_mean_and_variance": [
    "mean",
    "var",
    "weight_loc",
    "weight_scale"
  ],
  "test_incremental_weighted_mean_and_variance_ignore_nan": [
    "dtype"
  ],
  "test_incremental_variance_update_formulas": [],
  "test_incremental_mean_and_variance_ignore_nan": [],
  "test_incremental_variance_numerical_stability": [],
  "test_incremental_variance_ddof": [],
  "test_vector_sign_flip": [],
  "test_softmax": [],
  "test_stable_cumsum_deprecation": [],
  "test_safe_sparse_dot_2d": [
    "A_container",
    "B_container"
  ],
  "test_safe_sparse_dot_nd": [
    "csr_container"
  ],
  "test_safe_sparse_dot_2d_1d": [
    "container"
  ],
  "test_safe_sparse_dot_dense_output": [
    "dense_output"
  ],
  "test_approximate_mode": [],
  "test_randomized_svd_array_api_compliance": [
    "array_namespace",
    "device",
    "dtype"
  ],
  "test_randomized_range_finder_array_api_compliance": [
    "array_namespace",
    "device",
    "dtype"
  ],
  "test_validate_and_get_response_values": [
    "pyplot",
    "pos_label",
    "name",
    "response_method"
  ],
  "test_validate_from_predictions_params_errors": [
    "pyplot",
    "y_true",
    "error_message"
  ],
  "test_validate_from_predictions_params_returns": [
    "pyplot",
    "name",
    "pos_label",
    "y_true"
  ],
  "test_validate_from_cv_results_params": [
    "pyplot",
    "params",
    "err_msg"
  ],
  "test_get_legend_label": [
    "curve_legend_metric",
    "curve_name",
    "expected_label"
  ],
  "test_validate_curve_kwargs_deprecate_kwargs": [
    "curve_kwargs",
    "kwargs"
  ],
  "test_validate_curve_kwargs_error": [],
  "test_validate_curve_kwargs_single_legend": [
    "name",
    "legend_metric",
    "legend_metric_name",
    "curve_kwargs"
  ],
  "test_validate_curve_kwargs_multi_legend": [
    "name",
    "legend_metric",
    "legend_metric_name"
  ],
  "test_validate_curve_kwargs_default_kwargs": [
    "n_curves",
    "curve_kwargs"
  ],
  "metric": [],
  "neg_metric": [],
  "test_validate_score_name": [
    "score_name",
    "scoring",
    "negate_score",
    "expected_score_name"
  ],
  "test_inverval_max_min_ratio": [
    "data",
    "lower_bound",
    "upper_bound"
  ],
  "test_validate_style_kwargs": [
    "default_kwargs",
    "user_kwargs",
    "expected"
  ],
  "test_validate_style_kwargs_error": [
    "default_kwargs",
    "user_kwargs"
  ],
  "test_despine": [
    "pyplot"
  ],
  "test_deprecate_estimator_name": [
    "estimator_name",
    "name"
  ],
  "test_int_float_dict": [],
  "test_int_float_dict_argmin": [],
  "test_to_arrays": [],
  "test_compute_class_weight": [],
  "test_compute_class_weight_not_present": [
    "y_type",
    "class_weight",
    "classes",
    "err_msg"
  ],
  "test_compute_class_weight_dict": [],
  "test_compute_class_weight_invariance": [],
  "test_compute_class_weight_balanced_negative": [],
  "test_compute_class_weight_balanced_sample_weight_equivalence": [],
  "test_compute_class_weight_balanced_unordered": [],
  "test_compute_class_weight_default": [],
  "test_compute_sample_weight": [],
  "test_compute_sample_weight_with_subsample": [],
  "test_compute_sample_weight_errors": [
    "y_type",
    "class_weight",
    "indices",
    "err_msg"
  ],
  "test_compute_sample_weight_more_than_32": [],
  "test_class_weight_does_not_contains_more_classes": [],
  "test_compute_sample_weight_sparse": [
    "csc_container"
  ],
  "test_is_df_or_series": [
    "constructor_name"
  ],
  "test_is_pandas_df_other_libraries": [
    "constructor_name"
  ],
  "test_is_pandas_df": [],
  "test_is_pandas_df_pandas_not_installed": [
    "hide_available_pandas"
  ],
  "test_is_polars_df_other_libraries": [
    "constructor_name",
    "minversion"
  ],
  "test_is_polars_df_for_duck_typed_polars_dataframe": [],
  "test_is_polars_df": [],
  "test_types": [
    "type_t",
    "value",
    "expected_dtype"
  ],
  "test_encode_util": [
    "values",
    "expected"
  ],
  "test_encode_with_check_unknown": [],
  "_assert_check_unknown": [
    "values",
    "uniques",
    "expected_diff",
    "expected_mask"
  ],
  "test_check_unknown": [
    "values",
    "uniques",
    "expected_diff",
    "expected_mask"
  ],
  "test_check_unknown_missing_values": [
    "missing_value",
    "pickle_uniques"
  ],
  "test_unique_util_missing_values_objects": [
    "missing_value",
    "pickle_uniques"
  ],
  "test_unique_util_missing_values_numeric": [],
  "test_unique_util_with_all_missing_values": [],
  "test_check_unknown_with_both_missing_values": [],
  "test_get_counts": [
    "values",
    "uniques",
    "expected_counts"
  ],
  "test_bunch_attribute_deprecation": [],
  "AvailableParameterEstimator": {
    "__init__": [
      "self",
      "available",
      "return_value"
    ],
    "available_func": [
      "self"
    ]
  },
  "test_available_if_docstring": [],
  "test_available_if": [],
  "test_available_if_unbound_method": [],
  "test_available_if_methods_can_be_pickled": [],
  "test_get_sys_info": [],
  "test_get_deps_info": [],
  "test_show_versions": [
    "capsys"
  ],
  "test_mean_variance_axis0": [
    "csc_container",
    "csr_container",
    "lil_container"
  ],
  "test_mean_variance_axis0_precision": [
    "dtype",
    "sparse_constructor"
  ],
  "test_mean_variance_axis1": [
    "csc_container",
    "csr_container",
    "lil_container"
  ],
  "test_incr_mean_variance_axis_weighted_axis1": [
    "Xw",
    "X",
    "weights",
    "sparse_constructor",
    "dtype"
  ],
  "test_incr_mean_variance_axis_weighted_axis0": [
    "Xw",
    "X",
    "weights",
    "sparse_constructor",
    "dtype"
  ],
  "test_incr_mean_variance_axis": [
    "csc_container",
    "csr_container",
    "lil_container"
  ],
  "test_incr_mean_variance_axis_dim_mismatch": [
    "sparse_constructor"
  ],
  "test_incr_mean_variance_axis_equivalence_mean_variance": [
    "X1",
    "X2",
    "csr_container"
  ],
  "test_incr_mean_variance_no_new_n": [],
  "test_incr_mean_variance_n_float": [],
  "test_incr_mean_variance_axis_ignore_nan": [
    "axis",
    "sparse_constructor"
  ],
  "test_mean_variance_illegal_axis": [
    "csr_container"
  ],
  "test_densify_rows": [
    "csr_container"
  ],
  "test_inplace_column_scale": [],
  "test_inplace_row_scale": [],
  "test_inplace_swap_row": [
    "csc_container",
    "csr_container"
  ],
  "test_inplace_swap_column": [
    "csc_container",
    "csr_container"
  ],
  "test_min_max": [
    "dtype",
    "axis",
    "sparse_format",
    "missing_values",
    "min_func",
    "max_func",
    "ignore_nan",
    "large_indices"
  ],
  "test_min_max_axis_errors": [
    "csc_container",
    "csr_container"
  ],
  "test_count_nonzero": [
    "csc_container",
    "csr_container"
  ],
  "test_csc_row_median": [
    "csc_container",
    "csr_container"
  ],
  "test_inplace_normalize": [
    "csr_container",
    "inplace_csr_row_normalize"
  ],
  "test_csr_row_norms": [
    "dtype"
  ],
  "centered_matrices": [
    "request"
  ],
  "test_implicit_center_matmat": [
    "global_random_seed",
    "centered_matrices"
  ],
  "test_implicit_center_matvec": [
    "global_random_seed",
    "centered_matrices"
  ],
  "test_implicit_center_rmatmat": [
    "global_random_seed",
    "centered_matrices"
  ],
  "test_implit_center_rmatvec": [
    "global_random_seed",
    "centered_matrices"
  ],
  "test_sparse_matmul_to_dense_raises": [
    "A",
    "B",
    "out",
    "msg"
  ],
  "test_sparse_matmul_to_dense": [
    "global_random_seed",
    "out_is_None",
    "a_container",
    "b_container",
    "dtype"
  ],
  "test_safe_mask": [
    "csr_container"
  ],
  "test_get_namespace_ndarray_default": [
    "X"
  ],
  "test_get_namespace_ndarray_creation_device": [],
  "test_get_namespace_ndarray_with_dispatch": [],
  "test_get_namespace_df_with_dispatch": [
    "constructor_name"
  ],
  "test_get_namespace_sparse_with_dispatch": [],
  "test_get_namespace_array_api": [
    "monkeypatch"
  ],
  "test_move_to_array_api_conversions": [
    "array_input",
    "reference"
  ],
  "test_move_to_sparse": [],
  "test_asarray_with_order": [
    "array_api"
  ],
  "test_average": [
    "array_namespace",
    "device_",
    "dtype_name",
    "weights",
    "axis",
    "normalize",
    "expected"
  ],
  "test_average_raises_with_wrong_dtype": [
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_average_raises_with_invalid_parameters": [
    "array_namespace",
    "device",
    "dtype_name",
    "axis",
    "weights",
    "error",
    "error_msg"
  ],
  "test_device_none_if_no_input": [],
  "test_device_inspection": [],
  "test_nan_reductions": [
    "library",
    "X",
    "reduction",
    "expected"
  ],
  "test_ravel": [
    "namespace",
    "_device",
    "_dtype"
  ],
  "test_convert_to_numpy_gpu": [
    "library"
  ],
  "test_convert_to_numpy_cpu": [],
  "test_convert_estimator_to_ndarray": [
    "array_namespace",
    "converter"
  ],
  "test_convert_estimator_to_array_api": [],
  "test_indexing_dtype": [
    "namespace",
    "_device",
    "_dtype"
  ],
  "test_max_precision_float_dtype": [
    "namespace",
    "_device",
    "_dtype"
  ],
  "test_isin": [
    "array_namespace",
    "device",
    "_",
    "invert",
    "assume_unique",
    "element_size",
    "int_dtype"
  ],
  "test_get_namespace_and_device": [],
  "test_validate_diagonal_args": [
    "array",
    "value",
    "match"
  ],
  "test_fill_and_add_to_diagonal": [
    "c_contiguity",
    "function"
  ],
  "test_fill_diagonal": [
    "array",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_add_to_diagonal": [
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_sparse_device": [
    "csr_container",
    "dispatch"
  ],
  "test_median": [
    "namespace",
    "device",
    "dtype_name",
    "axis"
  ],
  "test_logsumexp_like_scipy_logsumexp": [
    "array_namespace",
    "device_",
    "dtype_name",
    "axis"
  ],
  "test_supported_float_types": [
    "namespace",
    "device_",
    "expected_types"
  ],
  "test_half_multinomial_loss": [
    "use_sample_weight",
    "namespace",
    "device_",
    "dtype_name"
  ],
  "test_set_random_state": [],
  "test_assert_allclose_dense_sparse": [
    "csr_container"
  ],
  "test_ignore_warning": [],
  "f_ok": [
    "a",
    "b"
  ],
  "f_bad_sections": [
    "a",
    "b"
  ],
  "f_bad_order": [
    "b",
    "a"
  ],
  "f_too_many_param_docstring": [
    "a",
    "b"
  ],
  "f_missing": [
    "a",
    "b"
  ],
  "f_check_param_definition": [
    "a",
    "b",
    "c",
    "d",
    "e"
  ],
  "Klass": {
    "f_missing": [
      "self",
      "X",
      "y"
    ],
    "f_bad_sections": [
      "self",
      "X",
      "y"
    ]
  },
  "MockEst": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "MockMetaEstimator": {
    "__init__": [
      "self",
      "delegate"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_check_docstring_parameters": [],
  "f_one": [
    "a",
    "b"
  ],
  "f_two": [
    "a",
    "b"
  ],
  "f_three": [
    "a",
    "b"
  ],
  "test_assert_docstring_consistency_object_type": [],
  "test_assert_docstring_consistency_arg_checks": [
    "objects",
    "kwargs",
    "error"
  ],
  "test_assert_docstring_consistency": [
    "objects",
    "kwargs",
    "error",
    "warn"
  ],
  "f_four": [
    "labels"
  ],
  "f_five": [
    "labels"
  ],
  "f_six": [
    "labels"
  ],
  "test_assert_docstring_consistency_error_msg": [],
  "test_assert_docstring_consistency_descr_regex_pattern": [],
  "RegistrationCounter": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "to_register_func"
    ]
  },
  "check_memmap": [
    "input_array",
    "mmap_data",
    "mmap_mode"
  ],
  "test_tempmemmap": [
    "monkeypatch"
  ],
  "test_create_memmap_backed_data": [
    "monkeypatch"
  ],
  "test_convert_container": [
    "constructor_name",
    "container_type",
    "dtype",
    "superdtype"
  ],
  "test_convert_container_categories_pandas": [],
  "test_convert_container_categories_polars": [],
  "test_convert_container_categories_pyarrow": [],
  "test_raises": [],
  "test_float32_aware_assert_allclose": [],
  "test_assert_run_python_script_without_output": [],
  "test_convert_container_sparse_to_sparse": [
    "constructor_name"
  ],
  "check_warnings_as_errors": [
    "warning_info",
    "warnings_as_errors"
  ],
  "test_sklearn_warnings_as_errors": [
    "warning_info"
  ],
  "test_turn_warnings_into_errors": [
    "warning_info"
  ],
  "test_weighted_percentile_matches_median": [
    "size",
    "average"
  ],
  "test_weighted_percentile_matches_numpy": [
    "global_random_seed",
    "size",
    "percentile_rank",
    "average"
  ],
  "test_weighted_percentile_plus_one_clip_max": [
    "percentile_rank"
  ],
  "test_weighted_percentile_equal": [],
  "test_weighted_percentile_all_zero_weights": [],
  "test_weighted_percentile_ignores_zero_weight": [
    "average",
    "percentile_rank",
    "expected_value"
  ],
  "test_weighted_percentile_frequency_weight_semantics": [
    "global_random_seed",
    "percentile_rank",
    "average"
  ],
  "test_weighted_percentile_constant_multiplier": [
    "global_random_seed",
    "percentile_rank",
    "average",
    "constant"
  ],
  "test_weighted_percentile_2d": [
    "global_random_seed",
    "percentile_rank",
    "average"
  ],
  "test_weighted_percentile_array_api_consistency": [
    "global_random_seed",
    "array_namespace",
    "device",
    "dtype_name",
    "data",
    "weights",
    "percentile"
  ],
  "test_weighted_percentile_nan_filtered": [
    "global_random_seed",
    "sample_weight_ndim",
    "average"
  ],
  "test_weighted_percentile_all_nan_column": [
    "percentile_rank",
    "expected"
  ],
  "test_weighted_percentile_like_numpy_quantile": [
    "percentile",
    "average",
    "uniform_weight",
    "global_random_seed"
  ],
  "test_weighted_percentile_like_numpy_nanquantile": [
    "percentile",
    "average",
    "uniform_weight",
    "global_random_seed"
  ],
  "test_pandas_adapter": [],
  "test_polars_adapter": [],
  "test__container_error_validation": [
    "csr_container"
  ],
  "EstimatorWithoutSetOutputAndWithoutTransform": {},
  "EstimatorNoSetOutputWithTransform": {
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "EstimatorWithSetOutput": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test__safe_set_output": [],
  "EstimatorNoSetOutputWithTransformNoFeatureNamesOut": {
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "test_set_output_mixin": [],
  "test__safe_set_output_error": [],
  "test_set_output_method": [
    "dataframe_lib"
  ],
  "test_set_output_method_error": [],
  "test__get_output_config": [
    "transform_output"
  ],
  "EstimatorWithSetOutputNoAutoWrap": {
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "test_get_output_auto_wrap_false": [],
  "test_auto_wrap_output_keys_errors_with_incorrect_input": [],
  "AnotherMixin": {
    "__init_subclass__": [
      "cls",
      "custom_parameter"
    ]
  },
  "test_set_output_mixin_custom_mixin": [],
  "test_set_output_mro": [],
  "EstimatorWithSetOutputIndex": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test_set_output_pandas_keep_index": [],
  "EstimatorReturnTuple": {
    "__init__": [
      "self",
      "OutputTuple"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "test_set_output_named_tuple_out": [],
  "EstimatorWithListInput": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test_set_output_list_input": [
    "dataframe_lib"
  ],
  "test_adapter_class_has_interface": [
    "name"
  ],
  "test_check_library_installed": [
    "monkeypatch"
  ],
  "test_get_adapter_from_container": [],
  "_success": [
    "x"
  ],
  "_fail": [
    "x"
  ],
  "test_check_on_fit_success": [
    "iris",
    "kwargs"
  ],
  "test_check_on_fit_fail": [
    "iris",
    "kwargs"
  ],
  "test_check_X_on_predict_success": [
    "iris",
    "pred_func"
  ],
  "test_check_X_on_predict_fail": [
    "iris",
    "pred_func"
  ],
  "test_checking_classifier": [
    "iris",
    "input_type"
  ],
  "test_checking_classifier_with_params": [
    "iris",
    "csr_container"
  ],
  "test_checking_classifier_fit_params": [
    "iris"
  ],
  "test_checking_classifier_missing_fit_params": [
    "iris"
  ],
  "test_checking_classifier_methods_to_check": [
    "iris",
    "methods_to_check",
    "predict_method"
  ],
  "test_mock_estimator_on_off_prediction": [
    "iris",
    "response_methods"
  ],
  "test_init_arpack_v0": [
    "seed"
  ],
  "floyd_warshall_slow": [
    "graph",
    "directed"
  ],
  "generate_graph": [
    "N"
  ],
  "test_shortest_path": [],
  "test_type_invariance": [
    "dtype",
    "WeightVector"
  ],
  "_func": [
    "a",
    "b"
  ],
  "_Class": {
    "_method": [
      "self",
      "a"
    ],
    "_deprecated_method": [
      "self",
      "a"
    ]
  },
  "_Estimator": {
    "__init__": [
      "self",
      "a"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_interval_range": [
    "interval_type"
  ],
  "test_interval_large_integers": [
    "interval_type"
  ],
  "test_interval_inf_in_bounds": [],
  "test_nan_not_in_interval": [
    "interval"
  ],
  "test_interval_errors": [
    "params",
    "error",
    "match"
  ],
  "test_stroptions": [],
  "test_options": [],
  "test_instances_of_type_human_readable": [
    "type",
    "expected_type_name"
  ],
  "test_hasmethods": [],
  "test_generate_invalid_param_val": [
    "constraint"
  ],
  "test_generate_invalid_param_val_2_intervals": [
    "integer_interval",
    "real_interval"
  ],
  "test_generate_invalid_param_val_all_valid": [
    "constraint"
  ],
  "test_generate_valid_param": [
    "constraint"
  ],
  "test_is_satisfied_by": [
    "constraint_declaration",
    "value"
  ],
  "test_make_constraint": [
    "constraint_declaration",
    "expected_constraint_class"
  ],
  "test_make_constraint_unknown": [],
  "test_validate_params": [],
  "test_validate_params_missing_params": [],
  "test_decorate_validated_function": [],
  "test_validate_params_method": [],
  "test_validate_params_estimator": [],
  "test_stroptions_deprecated_subset": [],
  "test_hidden_constraint": [],
  "test_hidden_stroptions": [],
  "test_validate_params_set_param_constraints_attribute": [],
  "test_boolean_constraint_deprecated_int": [],
  "test_no_validation": [],
  "test_pandas_na_constraint_with_pd_na": [],
  "test_iterable_not_string": [],
  "test_cv_objects": [],
  "test_third_party_estimator": [],
  "test_interval_real_not_int": [],
  "test_real_not_int": [],
  "test_skip_param_validation": [],
  "test_skip_nested_validation": [
    "prefer_skip_nested_validation"
  ],
  "test_skip_nested_validation_and_config_context": [
    "skip_parameter_validation",
    "prefer_skip_nested_validation",
    "expected_skipped"
  ],
  "test_make_rng": [],
  "test_as_float_array": [],
  "test_as_float_array_nan": [
    "X"
  ],
  "test_np_matrix": [],
  "test_memmap": [],
  "test_ordering": [],
  "test_check_array_ensure_all_finite_valid": [
    "value",
    "ensure_all_finite",
    "retype"
  ],
  "test_check_array_ensure_all_finite_invalid": [
    "value",
    "input_name",
    "ensure_all_finite",
    "match_msg",
    "retype"
  ],
  "test_check_array_links_to_imputer_doc_only_for_X": [
    "input_name",
    "retype"
  ],
  "test_check_array_ensure_all_finite_object": [],
  "test_check_array_ensure_all_finite_object_unsafe_casting": [
    "X",
    "err_msg",
    "ensure_all_finite"
  ],
  "test_check_array_series_err_msg": [],
  "test_check_array": [],
  "test_check_array_numeric_error": [
    "X"
  ],
  "test_check_array_pandas_na_support": [
    "pd_dtype",
    "dtype",
    "expected_dtype"
  ],
  "test_check_array_panadas_na_support_series": [],
  "test_check_array_pandas_dtype_casting": [],
  "test_check_array_on_mock_dataframe": [],
  "test_check_array_dtype_stability": [],
  "test_check_array_dtype_warning": [],
  "test_check_array_accept_sparse_type_exception": [],
  "test_check_array_accept_sparse_no_exception": [],
  "X_64bit": [
    "request"
  ],
  "test_check_array_accept_large_sparse_no_exception": [
    "X_64bit"
  ],
  "test_check_array_accept_large_sparse_raise_exception": [
    "X_64bit"
  ],
  "test_check_array_min_samples_and_features_messages": [],
  "test_check_array_complex_data_error": [],
  "test_has_fit_parameter": [],
  "test_check_symmetric": [],
  "test_check_is_fitted_with_is_fitted": [],
  "test_check_is_fitted_stateless": [],
  "test_check_is_fitted": [],
  "test_check_is_fitted_attributes": [],
  "test_check_is_fitted_with_attributes": [
    "wrap"
  ],
  "test_check_consistent_length": [],
  "test_check_consistent_length_array_api": [
    "array_namespace",
    "device",
    "_"
  ],
  "test_check_dataframe_fit_attribute": [],
  "test_suppress_validation": [],
  "test_check_array_series": [],
  "test_check_dataframe_mixed_float_dtypes": [
    "dtype",
    "bool_dtype"
  ],
  "test_check_dataframe_with_only_bool": [],
  "test_check_dataframe_with_only_boolean": [],
  "DummyMemory": {
    "cache": [
      "self",
      "func"
    ]
  },
  "WrongDummyMemory": {},
  "test_check_memory": [
    "tmp_path"
  ],
  "test_check_array_memmap": [
    "copy"
  ],
  "test_estimator_has": [
    "estimator_name",
    "estimator_value",
    "delegates",
    "expected_result",
    "expected_exception"
  ],
  "test_check_non_negative": [
    "retype"
  ],
  "test_check_X_y_informative_error": [],
  "test_retrieve_samples_from_non_standard_shape": [],
  "test_check_scalar_valid": [
    "x"
  ],
  "test_check_scalar_invalid": [
    "x",
    "target_name",
    "target_type",
    "min_val",
    "max_val",
    "include_boundaries",
    "err_msg"
  ],
  "_psd_cases_valid": [],
  "test_check_psd_eigenvalues_valid": [
    "lambdas",
    "expected_lambdas",
    "w_type",
    "w_msg",
    "enable_warnings"
  ],
  "_psd_cases_invalid": [],
  "test_check_psd_eigenvalues_invalid": [
    "lambdas",
    "err_type",
    "err_msg"
  ],
  "_check_sample_weight_common": [
    "xp"
  ],
  "test_check_sample_weight": [],
  "test_check_sample_weight_array_api": [
    "array_namespace",
    "device",
    "dtype"
  ],
  "test_check_pos_label_consistency": [
    "y_true"
  ],
  "test_check_pos_label_consistency_array_api": [
    "array_namespace",
    "device",
    "dtype",
    "y_true"
  ],
  "test_check_pos_label_consistency_invalid": [
    "y_true"
  ],
  "test_check_pos_label_consistency_invalid_array_api": [
    "array_namespace",
    "device",
    "dtype",
    "y_true"
  ],
  "test_allclose_dense_sparse_equals": [
    "toarray"
  ],
  "test_allclose_dense_sparse_not_equals": [
    "toarray"
  ],
  "test_allclose_dense_sparse_raise": [
    "toarray"
  ],
  "test_deprecate_positional_args_warns_for_function": [],
  "test_deprecate_positional_args_warns_for_function_version": [],
  "test_deprecate_positional_args_warns_for_class": [],
  "test_check_method_params": [
    "indices"
  ],
  "test_check_sparse_pandas_sp_format": [
    "sp_format"
  ],
  "test_check_pandas_sparse_mixed_dtypes": [
    "ntype1",
    "ntype2"
  ],
  "test_check_pandas_sparse_valid": [
    "ntype1",
    "ntype2",
    "expected_subtype"
  ],
  "test_num_features": [
    "constructor_name"
  ],
  "test_num_features_errors_1d_containers": [
    "X",
    "constructor_name"
  ],
  "test_num_features_errors_scalars": [
    "X"
  ],
  "test_get_feature_names_pandas_with_ints_no_warning": [
    "names"
  ],
  "test_get_feature_names_pandas": [],
  "test_get_feature_names_dataframe_protocol": [
    "constructor_name",
    "minversion"
  ],
  "test_get_feature_names_numpy": [],
  "test_get_feature_names_invalid_dtypes": [
    "names",
    "dtypes"
  ],
  "PassthroughTransformer": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "test_check_feature_names_in": [],
  "test_check_feature_names_in_pandas": [],
  "test_check_response_method_unknown_method": [],
  "test_check_response_method_not_supported_response_method": [
    "response_method"
  ],
  "test_check_response_method_list_str": [],
  "test_boolean_series_remains_boolean": [],
  "test_pandas_array_returns_ndarray": [
    "input_values"
  ],
  "test_check_array_array_api_has_non_finite": [],
  "test_check_array_multiple_extensions": [
    "extension_dtype",
    "regular_dtype",
    "include_object"
  ],
  "test_num_samples_dataframe_protocol": [],
  "test_check_array_dia_to_int32_indexed_csr_csc_coo": [
    "sparse_container",
    "output_format"
  ],
  "test_to_object_array": [
    "sequence"
  ],
  "test_column_or_1d": [],
  "test_check_array_writeable_np": [],
  "test_check_array_writeable_mmap": [],
  "test_check_array_writeable_df": [],
  "test_check_array_on_sparse_inputs_with_array_api_enabled": [],
  "test_check_array_allow_nd_errors": [
    "X",
    "estimator",
    "expected_error_message"
  ],
  "test_is_scalar_nan": [
    "value",
    "result"
  ],
  "get_working_memory": [],
  "test_configuration_passes_through_to_joblib": [
    "n_jobs",
    "backend"
  ],
  "test_parallel_delayed_warnings": [],
  "test_dispatch_config_parallel": [
    "n_jobs"
  ],
  "raise_warning": [],
  "_yield_n_jobs_backend_combinations": [],
  "test_filter_warning_propagates": [
    "n_jobs",
    "backend"
  ],
  "get_warning_filters": [],
  "test_check_warnings_threading": [],
  "test_filter_warning_propagates_no_side_effect_with_loky_backend": [],
  "EmptyClassifier": {},
  "EmptyTransformer": {},
  "EmptyRegressor": {},
  "test_requires_y": [
    "estimator",
    "value"
  ],
  "test_no___sklearn_tags__with_more_tags": [],
  "test_tag_test_passes_with_inheritance": [],
  "test_tags_no_sklearn_tags_concrete_implementation": [],
  "_mark_thread_unsafe_if_pytest_imported": [
    "f"
  ],
  "CorrectNotFittedError": {},
  "BaseBadClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "ChangesDict": {
    "__init__": [
      "self",
      "key"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "SetsWrongAttribute": {
    "__init__": [
      "self",
      "acceptable_key"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "ChangesWrongAttribute": {
    "__init__": [
      "self",
      "wrong_attribute"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "ChangesUnderscoreAttribute": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "RaisesErrorInSetParams": {
    "__init__": [
      "self",
      "p"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "HasMutableParameters": {
    "__init__": [
      "self",
      "p"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "HasImmutableParameters": {
    "__init__": [
      "self",
      "p",
      "q",
      "r"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "ModifiesValueInsteadOfRaisingError": {
    "__init__": [
      "self",
      "p"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "ModifiesAnotherValue": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "set_params": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "NoCheckinPredict": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "NoSparseClassifier": {
    "__init__": [
      "self",
      "raise_for_type"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "CorrectNotFittedErrorClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "NoSampleWeightPandasSeriesType": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "BadBalancedWeightsClassifier": {
    "__init__": [
      "self",
      "class_weight"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "BadTransformerWithoutMixin": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "NotInvariantPredict": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "NotInvariantSampleOrder": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "OneClassSampleErrorClassifier": {
    "__init__": [
      "self",
      "raise_when_single_class"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "LargeSparseNotSupportedClassifier": {
    "__init__": [
      "self",
      "raise_for_type"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "SparseTransformer": {
    "__init__": [
      "self",
      "sparse_container"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "EstimatorInconsistentForPandas": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "UntaggedBinaryClassifier": {
    "fit": [
      "self",
      "X",
      "y",
      "coef_init",
      "intercept_init",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "classes",
      "sample_weight"
    ]
  },
  "TaggedBinaryClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RequiresPositiveXRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RequiresPositiveYRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "PoorScoreLogisticRegression": {
    "decision_function": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "PartialFitChecksName": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "BrokenArrayAPI": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_check_array_api_input": [],
  "test_not_an_array_array_function": [],
  "test_check_fit_score_takes_y_works_on_deprecated_fit": [],
  "test_check_estimator_with_class_removed": [],
  "test_mutable_default_params": [],
  "test_check_set_params": [],
  "test_check_estimators_nan_inf": [],
  "test_check_dict_unchanged": [],
  "test_check_sample_weights_pandas_series": [],
  "test_check_estimators_overwrite_params": [],
  "test_check_dont_overwrite_parameters": [],
  "test_check_methods_sample_order_invariance": [],
  "test_check_methods_subset_invariance": [],
  "test_check_estimator_sparse_data": [],
  "test_check_classifiers_one_label_sample_weights": [],
  "test_check_estimator_not_fail_fast": [],
  "test_check_estimator": [],
  "test_check_outlier_corruption": [],
  "test_check_estimator_sparse_tag": [],
  "test_check_estimator_transformer_no_mixin": [],
  "test_check_estimator_clones": [],
  "test_check_estimators_unfitted": [],
  "test_check_no_attributes_set_in_init": [],
  "test_check_estimator_pairwise": [],
  "test_check_classifier_data_not_an_array": [],
  "test_check_regressor_data_not_an_array": [],
  "test_check_dataframe_column_names_consistency": [],
  "_BaseMultiLabelClassifierMock": {
    "__init__": [
      "self",
      "response_output"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "test_check_classifiers_multilabel_output_format_predict": [],
  "test_check_classifiers_multilabel_output_format_predict_proba": [],
  "test_check_classifiers_multilabel_output_format_decision_function": [],
  "run_tests_without_pytest": [],
  "test_check_class_weight_balanced_linear_classifier": [],
  "test_all_estimators_all_public": [],
  "test_estimator_checks_generator_strict_none": [],
  "test_estimator_checks_generator_strict_xfail_tests": [],
  "test_estimator_checks_generator_skipping_tests": [],
  "test_xfail_count_with_no_fast_fail": [],
  "test_check_estimator_callback": [],
  "test_minimal_class_implementation_checks": [],
  "test_check_fit_check_is_fitted": [],
  "test_check_requires_y_none": [],
  "test_non_deterministic_estimator_skip_tests": [],
  "test_check_outlier_contamination": [],
  "test_decision_proba_tie_ranking": [],
  "test_yield_all_checks_legacy": [],
  "test_check_estimator_cloneable_error": [],
  "test_estimator_repr_error": [],
  "test_check_estimator_tags_renamed": [],
  "test_check_classifier_not_supporting_multiclass": [],
  "test_estimator_with_set_output": [],
  "test_estimator_checks_generator": [],
  "test_check_estimator_callback_with_fast_fail_error": [],
  "test_check_mixin_order": [],
  "test_check_positive_only_tag_during_fit": [],
  "test_mmhash3_int": [],
  "test_mmhash3_int_array": [],
  "test_mmhash3_bytes": [],
  "test_mmhash3_unicode": [],
  "test_no_collision_on_byte_range": [],
  "test_uniform_distribution": [],
  "multilabel_explicit_zero": [],
  "_generate_sparse": [
    "data",
    "sparse_containers",
    "dtypes"
  ],
  "EXAMPLES": [],
  "ARRAY_API_EXAMPLES": [],
  "NON_ARRAY_LIKE_EXAMPLES": [],
  "MULTILABEL_SEQUENCES": [],
  "test_unique_labels": [],
  "test_check_classification_targets_too_many_unique_classes": [],
  "test_unique_labels_non_specific": [],
  "test_unique_labels_mixed_types": [],
  "test_is_multilabel": [],
  "test_is_multilabel_array_api_compliance": [
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_type_of_target": [],
  "test_type_of_target_pandas_sparse": [],
  "test_type_of_target_pandas_nullable": [],
  "test_unique_labels_pandas_nullable": [
    "dtype"
  ],
  "test_class_distribution": [
    "csc_container"
  ],
  "test_safe_split_with_precomputed_kernel": [],
  "test_labels_in_bytes_format_error": [
    "input_type"
  ],
  "test_invalid_sample_without_replacement_algorithm": [],
  "test_sample_without_replacement_algorithms": [],
  "check_edge_case_of_sample_int": [
    "sample_without_replacement"
  ],
  "check_sample_int": [
    "sample_without_replacement"
  ],
  "check_sample_int_distribution": [
    "sample_without_replacement"
  ],
  "test_random_choice_csc": [
    "n_samples",
    "random_state"
  ],
  "test_random_choice_csc_errors": [],
  "test_our_rand_r": [],
  "X_toy": [],
  "test_polars_indexing": [],
  "test_determine_key_type": [
    "key",
    "dtype"
  ],
  "test_determine_key_type_error": [],
  "test_determine_key_type_slice_error": [],
  "test_determine_key_type_array_api": [
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_safe_indexing_array_api_support": [
    "array_namespace",
    "device_",
    "dtype_name",
    "indexing_key",
    "axis"
  ],
  "test_safe_indexing_2d_container_axis_0": [
    "array_type",
    "indices_type"
  ],
  "test_safe_indexing_1d_container": [
    "array_type",
    "indices_type"
  ],
  "test_safe_indexing_2d_container_axis_1": [
    "array_type",
    "indices_type",
    "indices"
  ],
  "test_safe_indexing_2d_read_only_axis_1": [
    "array_read_only",
    "indices_read_only",
    "array_type",
    "indices_type",
    "axis",
    "expected_array"
  ],
  "test_safe_indexing_1d_container_mask": [
    "array_type",
    "indices_type"
  ],
  "test_safe_indexing_2d_mask": [
    "array_type",
    "indices_type",
    "axis",
    "expected_subset"
  ],
  "test_safe_indexing_2d_scalar_axis_0": [
    "array_type",
    "expected_output_type"
  ],
  "test_safe_indexing_1d_scalar": [
    "array_type"
  ],
  "test_safe_indexing_2d_scalar_axis_1": [
    "array_type",
    "expected_output_type",
    "indices"
  ],
  "test_safe_indexing_None_axis_0": [
    "array_type"
  ],
  "test_safe_indexing_pandas_no_matching_cols_error": [],
  "test_safe_indexing_error_axis": [
    "axis"
  ],
  "test_safe_indexing_1d_array_error": [
    "X_constructor"
  ],
  "test_safe_indexing_container_axis_0_unsupported_type": [],
  "test_safe_indexing_pandas_no_settingwithcopy_warning": [],
  "test_safe_indexing_list_axis_1_unsupported": [
    "indices"
  ],
  "test_safe_assign": [
    "array_type"
  ],
  "test_get_column_indices_error": [
    "key",
    "err_msg"
  ],
  "test_get_column_indices_pandas_nonunique_columns_error": [
    "key"
  ],
  "test_get_column_indices_interchange": [],
  "test_resample": [],
  "test_resample_weighted": [],
  "test_resample_stratified": [],
  "test_resample_stratified_replace": [],
  "test_resample_stratify_2dy": [],
  "test_notimplementederror": [],
  "test_resample_stratify_sparse_error": [
    "csr_container"
  ],
  "test_shuffle_on_ndim_equals_three": [],
  "test_shuffle_dont_convert_to_array": [
    "csc_container"
  ],
  "test_get_response_values_regressor_error": [
    "response_method"
  ],
  "test_get_response_values_regressor": [
    "return_response_method_used"
  ],
  "test_get_response_values_outlier_detection": [
    "response_method",
    "return_response_method_used"
  ],
  "test_get_response_values_classifier_unknown_pos_label": [
    "response_method"
  ],
  "test_get_response_values_classifier_inconsistent_y_pred_for_binary_proba": [
    "response_method"
  ],
  "test_get_response_values_binary_classifier_decision_function": [
    "return_response_method_used"
  ],
  "test_get_response_values_binary_classifier_predict_proba": [
    "return_response_method_used",
    "response_method"
  ],
  "test_get_response_error": [
    "estimator",
    "X",
    "y",
    "err_msg",
    "params"
  ],
  "test_get_response_predict_proba": [
    "return_response_method_used"
  ],
  "test_get_response_decision_function": [
    "return_response_method_used"
  ],
  "test_get_response_values_multiclass": [
    "estimator",
    "response_method"
  ],
  "test_get_response_values_with_response_list": [],
  "test_get_response_values_multilabel_indicator": [
    "response_method"
  ],
  "test_response_values_type_of_target_on_classes_no_warning": [],
  "_numpy_to_cython": [
    "dtype"
  ],
  "RTOL": [],
  "ORDER": [],
  "_no_op": [
    "x"
  ],
  "test_dot": [
    "dtype"
  ],
  "test_asum": [
    "dtype"
  ],
  "test_axpy": [
    "dtype"
  ],
  "test_nrm2": [
    "dtype"
  ],
  "test_scal": [
    "dtype"
  ],
  "test_rotg": [
    "dtype"
  ],
  "test_rot": [
    "dtype"
  ],
  "test_gemv": [
    "dtype",
    "opA",
    "transA",
    "order"
  ],
  "test_ger": [
    "dtype",
    "order"
  ],
  "test_gemm": [
    "dtype",
    "opA",
    "transA",
    "opB",
    "transB",
    "order"
  ],
  "test_fix_connected_components": [],
  "test_fix_connected_components_precomputed": [],
  "test_fix_connected_components_wrong_mode": [],
  "test_fix_connected_components_connectivity_mode": [],
  "test_fix_connected_components_distance_mode": [],
  "test_attach_unique_attaches_unique_to_array": [],
  "test_cached_unique_returns_cached_unique": [],
  "test_attach_unique_not_ndarray": [],
  "test_attach_unique_returns_view": [],
  "test_attach_unique_return_tuple": [],
  "test_check_array_keeps_unique": [],
  "StandardScaler": {
    "__init__": [
      "self",
      "copy",
      "with_mean",
      "with_std"
    ],
    "transform": [
      "self",
      "X",
      "copy"
    ]
  },
  "RFE": {
    "__init__": [
      "self",
      "estimator",
      "n_features_to_select",
      "step",
      "verbose"
    ]
  },
  "GridSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "param_grid",
      "scoring",
      "n_jobs",
      "iid",
      "refit",
      "cv",
      "verbose",
      "pre_dispatch",
      "error_score",
      "return_train_score"
    ]
  },
  "CountVectorizer": {
    "__init__": [
      "self",
      "input",
      "encoding",
      "decode_error",
      "strip_accents",
      "lowercase",
      "preprocessor",
      "tokenizer",
      "stop_words",
      "token_pattern",
      "ngram_range",
      "analyzer",
      "max_df",
      "min_df",
      "max_features",
      "vocabulary",
      "binary",
      "dtype"
    ]
  },
  "PCA": {
    "__init__": [
      "self",
      "n_components",
      "copy",
      "whiten",
      "svd_solver",
      "tol",
      "iterated_power",
      "random_state"
    ]
  },
  "NMF": {
    "__init__": [
      "self",
      "n_components",
      "init",
      "solver",
      "beta_loss",
      "tol",
      "max_iter",
      "random_state",
      "alpha",
      "l1_ratio",
      "verbose",
      "shuffle"
    ]
  },
  "SimpleImputer": {
    "__init__": [
      "self",
      "missing_values",
      "strategy",
      "fill_value",
      "verbose",
      "copy"
    ]
  },
  "test_basic": [],
  "test_changed_only": [],
  "test_pipeline": [],
  "test_deeply_nested": [],
  "test_print_estimator_max_depth": [
    "print_changed_only",
    "expected"
  ],
  "test_gridsearch": [],
  "test_gridsearch_pipeline": [],
  "test_n_max_elements_to_show": [],
  "test_bruteforce_ellipsis": [],
  "test_builtin_prettyprinter": [],
  "test_kwargs_in_init": [],
  "test_complexity_print_changed_only": [],
  "MockClass1": {},
  "MockClass2": {
    "method": [
      "self"
    ],
    "n_features_": [
      "self"
    ]
  },
  "MockClass3": {
    "__init__": [
      "self"
    ]
  },
  "MockClass4": {},
  "MockClass5": {
    "__init__": [
      "self",
      "a"
    ]
  },
  "MockClass6": {
    "__new__": [
      "cls"
    ]
  },
  "mock_function": [],
  "test_deprecated": [],
  "test_is_deprecated": [],
  "test_deprecated_class_signature": [],
  "test_min_pos": [],
  "test_min_pos_no_positive": [
    "dtype"
  ],
  "test_all_with_any_reduction_axis_1": [
    "dtype",
    "value"
  ],
  "_HTMLDocumentationLinkMixin": {
    "_doc_link_module": [],
    "_doc_link_url_param_generator": [],
    "_doc_link_template": [
      "self",
      "value"
    ],
    "_get_doc_link": [
      "self"
    ]
  },
  "ReprHTMLMixin": {
    "_repr_html_": [
      "self"
    ],
    "_repr_html_inner": [
      "self"
    ],
    "_repr_mimebundle_": [
      "self"
    ]
  },
  "_generate_link_to_param_doc": [
    "estimator_class",
    "param_name",
    "doc_link"
  ],
  "_read_params": [
    "name",
    "value",
    "non_default_params"
  ],
  "_scrape_estimator_docstring": [
    "docstring"
  ],
  "_params_html_repr": [
    "params"
  ],
  "ParamsDict": {
    "_html_repr": [],
    "__init__": [
      "self"
    ]
  },
  "_IDCounter": {
    "__init__": [
      "self",
      "prefix"
    ],
    "get_id": [
      "self"
    ]
  },
  "_get_css_style": [],
  "_CONTAINER_ID_COUNTER": [],
  "_ESTIMATOR_ID_COUNTER": [],
  "_CSS_STYLE": [],
  "_VisualBlock": {
    "__init__": [
      "self",
      "kind",
      "estimators"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "_write_label_html": [
    "out",
    "params",
    "name",
    "name_details",
    "name_caption",
    "doc_link_label",
    "outer_class",
    "inner_class",
    "checked",
    "doc_link",
    "is_fitted_css_class",
    "is_fitted_icon",
    "param_prefix"
  ],
  "_get_visual_block": [
    "estimator"
  ],
  "_write_estimator_html": [
    "out",
    "estimator",
    "estimator_label",
    "estimator_label_details",
    "is_fitted_css_class",
    "is_fitted_icon",
    "first_call",
    "param_prefix"
  ],
  "estimator_html_repr": [
    "estimator"
  ],
  "check_playwright": [],
  "local_server": [
    "request"
  ],
  "_make_page": [
    "body"
  ],
  "test_copy_paste": [
    "page",
    "local_server"
  ],
  "test_force_theme": [
    "page",
    "local_server",
    "color",
    "expected_theme"
  ],
  "dummy_function": [
    "x",
    "y"
  ],
  "test_write_label_html": [
    "checked"
  ],
  "test_get_visual_block_single_str_none": [
    "est"
  ],
  "test_get_visual_block_single_estimator": [],
  "test_get_visual_block_pipeline": [],
  "test_get_visual_block_feature_union": [],
  "test_get_visual_block_voting": [],
  "test_get_visual_block_column_transformer": [],
  "test_estimator_html_repr_an_empty_pipeline": [],
  "test_estimator_html_repr_pipeline": [],
  "test_stacking_classifier": [
    "final_estimator"
  ],
  "test_stacking_regressor": [
    "final_estimator"
  ],
  "test_birch_duck_typing_meta": [],
  "test_ovo_classifier_duck_typing_meta": [],
  "test_duck_typing_nested_estimator": [],
  "test_one_estimator_print_change_only": [
    "print_changed_only"
  ],
  "test_fallback_exists": [],
  "test_show_arrow_pipeline": [],
  "test_invalid_parameters_in_stacking": [],
  "test_estimator_get_params_return_cls": [],
  "test_estimator_html_repr_unfitted_vs_fitted": [],
  "test_estimator_html_repr_fitted_icon": [
    "estimator"
  ],
  "test_html_documentation_link_mixin_sklearn": [
    "mock_version"
  ],
  "test_html_documentation_link_mixin_get_doc_link_instance": [
    "module_path",
    "expected_module"
  ],
  "test_html_documentation_link_mixin_get_doc_link_class": [
    "module_path",
    "expected_module"
  ],
  "test_html_documentation_link_mixin_get_doc_link_out_of_library": [],
  "test_html_documentation_link_mixin_doc_link_url_param_generator_instance": [],
  "test_html_documentation_link_mixin_doc_link_url_param_generator_class": [],
  "set_non_utf8_locale": [],
  "test_non_utf8_locale": [
    "set_non_utf8_locale"
  ],
  "test_function_transformer_show_caption": [
    "func",
    "expected_name"
  ],
  "test_estimator_html_repr_table": [],
  "test_params_dict_content": [],
  "test_params_dict_repr_html_": [],
  "test_params_dict_repr_mimebundle": [],
  "test_read_params": [],
  "test_params_html_repr": [],
  "test_params_html_repr_with_doc_links": [],
  "test_params_html_repr_without_doc_links": [],
  "test_generate_link_to_param_doc_basic": [],
  "test_generate_link_to_param_doc_param_not_found": [],
  "test_generate_link_to_param_doc_empty_docstring": [],
  "CROSS_DECOMPOSITION": [],
  "INIT_PARAMS": [],
  "_tested_estimators": [
    "type_filter"
  ],
  "SKIPPED_ESTIMATORS": [],
  "_construct_instances": [
    "Estimator"
  ],
  "_get_check_estimator_ids": [
    "obj"
  ],
  "_yield_instances_for_check": [
    "check",
    "estimator_orig"
  ],
  "PER_ESTIMATOR_XFAIL_CHECKS": [],
  "linear_svr_not_thread_safe": [],
  "_get_expected_failed_checks": [
    "estimator"
  ],
  "GPR_CHOLESKY_LOWER": [],
  "GaussianProcessRegressor": {
    "__init__": [
      "self",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X",
      "return_std",
      "return_cov"
    ],
    "sample_y": [
      "self",
      "X",
      "n_samples",
      "random_state"
    ],
    "log_marginal_likelihood": [
      "self",
      "theta",
      "eval_gradient",
      "clone_kernel"
    ],
    "_constrained_optimization": [
      "self",
      "obj_func",
      "initial_theta",
      "bounds"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_check_length_scale": [
    "X",
    "length_scale"
  ],
  "Hyperparameter": {
    "__slots__": [],
    "__new__": [
      "cls",
      "name",
      "value_type",
      "bounds",
      "n_elements",
      "fixed"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "Kernel": {
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ],
    "clone_with_theta": [
      "self",
      "theta"
    ],
    "n_dims": [
      "self"
    ],
    "hyperparameters": [
      "self"
    ],
    "theta": [
      "self",
      "theta"
    ],
    "bounds": [
      "self"
    ],
    "__add__": [
      "self",
      "b"
    ],
    "__radd__": [
      "self",
      "b"
    ],
    "__mul__": [
      "self",
      "b"
    ],
    "__rmul__": [
      "self",
      "b"
    ],
    "__pow__": [
      "self",
      "b"
    ],
    "__eq__": [
      "self",
      "b"
    ],
    "__repr__": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "is_stationary": [
      "self"
    ],
    "requires_vector_input": [
      "self"
    ],
    "_check_bounds_params": [
      "self"
    ]
  },
  "NormalizedKernelMixin": {
    "diag": [
      "self",
      "X"
    ]
  },
  "StationaryKernelMixin": {
    "is_stationary": [
      "self"
    ]
  },
  "GenericKernelMixin": {
    "requires_vector_input": [
      "self"
    ]
  },
  "CompoundKernel": {
    "__init__": [
      "self",
      "kernels"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "theta": [
      "self",
      "theta"
    ],
    "bounds": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "__eq__": [
      "self",
      "b"
    ],
    "is_stationary": [
      "self"
    ],
    "requires_vector_input": [
      "self"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "KernelOperator": {
    "__init__": [
      "self",
      "k1",
      "k2"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "hyperparameters": [
      "self"
    ],
    "theta": [
      "self",
      "theta"
    ],
    "bounds": [
      "self"
    ],
    "__eq__": [
      "self",
      "b"
    ],
    "is_stationary": [
      "self"
    ],
    "requires_vector_input": [
      "self"
    ]
  },
  "Sum": {
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Product": {
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Exponentiation": {
    "__init__": [
      "self",
      "kernel",
      "exponent"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "hyperparameters": [
      "self"
    ],
    "theta": [
      "self",
      "theta"
    ],
    "bounds": [
      "self"
    ],
    "__eq__": [
      "self",
      "b"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "__repr__": [
      "self"
    ],
    "is_stationary": [
      "self"
    ],
    "requires_vector_input": [
      "self"
    ]
  },
  "ConstantKernel": {
    "__init__": [
      "self",
      "constant_value",
      "constant_value_bounds"
    ],
    "hyperparameter_constant_value": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "__repr__": [
      "self"
    ]
  },
  "WhiteKernel": {
    "__init__": [
      "self",
      "noise_level",
      "noise_level_bounds"
    ],
    "hyperparameter_noise_level": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "__repr__": [
      "self"
    ]
  },
  "RBF": {
    "__init__": [
      "self",
      "length_scale",
      "length_scale_bounds"
    ],
    "anisotropic": [
      "self"
    ],
    "hyperparameter_length_scale": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Matern": {
    "__init__": [
      "self",
      "length_scale",
      "length_scale_bounds",
      "nu"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "__repr__": [
      "self"
    ]
  },
  "RationalQuadratic": {
    "__init__": [
      "self",
      "length_scale",
      "alpha",
      "length_scale_bounds",
      "alpha_bounds"
    ],
    "hyperparameter_length_scale": [
      "self"
    ],
    "hyperparameter_alpha": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ExpSineSquared": {
    "__init__": [
      "self",
      "length_scale",
      "periodicity",
      "length_scale_bounds",
      "periodicity_bounds"
    ],
    "hyperparameter_length_scale": [
      "self"
    ],
    "hyperparameter_periodicity": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "__repr__": [
      "self"
    ]
  },
  "DotProduct": {
    "__init__": [
      "self",
      "sigma_0",
      "sigma_0_bounds"
    ],
    "hyperparameter_sigma_0": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "is_stationary": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "_approx_fprime": [
    "xk",
    "f",
    "epsilon",
    "args"
  ],
  "PairwiseKernel": {
    "__init__": [
      "self",
      "gamma",
      "gamma_bounds",
      "metric",
      "pairwise_kernels_kwargs"
    ],
    "hyperparameter_gamma": [
      "self"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "is_stationary": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "LAMBDAS": [],
  "COEFS": [],
  "_BinaryGaussianProcessClassifierLaplace": {
    "__init__": [
      "self",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "log_marginal_likelihood": [
      "self",
      "theta",
      "eval_gradient",
      "clone_kernel"
    ],
    "latent_mean_and_variance": [
      "self",
      "X"
    ],
    "_posterior_mode": [
      "self",
      "K",
      "return_temporaries"
    ],
    "_constrained_optimization": [
      "self",
      "obj_func",
      "initial_theta",
      "bounds"
    ]
  },
  "GaussianProcessClassifier": {
    "__init__": [
      "self",
      "kernel"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "kernel_": [
      "self"
    ],
    "log_marginal_likelihood": [
      "self",
      "theta",
      "eval_gradient",
      "clone_kernel"
    ],
    "latent_mean_and_variance": [
      "self",
      "X"
    ]
  },
  "kernel_rbf_plus_white": [],
  "kernels": [],
  "test_kernel_gradient": [
    "kernel"
  ],
  "test_kernel_theta": [
    "kernel"
  ],
  "test_auto_vs_cross": [
    "kernel"
  ],
  "test_kernel_diag": [
    "kernel"
  ],
  "test_kernel_operator_commutative": [],
  "test_kernel_anisotropic": [],
  "test_kernel_stationary": [
    "kernel"
  ],
  "test_kernel_input_type": [
    "kernel"
  ],
  "test_compound_kernel_input_type": [],
  "check_hyperparameters_equal": [
    "kernel1",
    "kernel2"
  ],
  "test_kernel_clone": [
    "kernel"
  ],
  "test_kernel_clone_after_set_params": [
    "kernel"
  ],
  "test_matern_kernel": [],
  "test_kernel_versus_pairwise": [
    "kernel"
  ],
  "test_set_get_params": [
    "kernel"
  ],
  "test_repr_kernels": [
    "kernel"
  ],
  "test_rational_quadratic_kernel": [],
  "f": [
    "x"
  ],
  "fixed_kernel": [],
  "non_fixed_kernels": [],
  "test_gpr_interpolation": [
    "kernel"
  ],
  "test_gpr_interpolation_structured": [],
  "test_lml_improving": [
    "kernel"
  ],
  "test_lml_precomputed": [
    "kernel"
  ],
  "test_lml_without_cloning_kernel": [
    "kernel"
  ],
  "test_converged_to_local_maximum": [
    "kernel"
  ],
  "test_solution_inside_bounds": [
    "kernel"
  ],
  "test_lml_gradient": [
    "kernel"
  ],
  "test_prior": [
    "kernel"
  ],
  "test_sample_statistics": [
    "kernel"
  ],
  "test_no_optimizer": [],
  "test_predict_cov_vs_std": [
    "kernel",
    "target"
  ],
  "test_anisotropic_kernel": [],
  "test_random_starts": [],
  "test_y_normalization": [
    "kernel"
  ],
  "test_large_variance_y": [],
  "test_y_multioutput": [],
  "test_custom_optimizer": [
    "kernel"
  ],
  "test_gpr_correct_error_message": [],
  "test_duplicate_input": [
    "kernel"
  ],
  "test_no_fit_default_predict": [],
  "test_warning_bounds": [],
  "test_bound_check_fixed_hyperparameter": [],
  "test_constant_target": [
    "kernel"
  ],
  "test_gpr_consistency_std_cov_non_invertible_kernel": [],
  "test_gpr_fit_error": [
    "params",
    "TypeError",
    "err_msg"
  ],
  "test_gpr_lml_error": [],
  "test_gpr_predict_error": [],
  "test_predict_shapes": [
    "normalize_y",
    "n_targets"
  ],
  "test_sample_y_shapes": [
    "normalize_y",
    "n_targets"
  ],
  "test_sample_y_shape_with_prior": [
    "n_targets",
    "n_samples"
  ],
  "test_predict_shape_with_prior": [
    "n_targets"
  ],
  "test_n_targets_error": [],
  "CustomKernel": {
    "diag": [
      "self",
      "X"
    ]
  },
  "test_gpr_predict_input_not_modified": [],
  "test_gpr_predict_no_cov_no_std_return": [
    "kernel"
  ],
  "fX": [],
  "y_mc": [],
  "test_predict_consistent": [
    "kernel"
  ],
  "test_predict_consistent_structured": [],
  "test_multi_class": [
    "kernel"
  ],
  "test_multi_class_n_jobs": [
    "kernel"
  ],
  "test_gpc_fit_error": [
    "params",
    "error_type",
    "err_msg"
  ],
  "test_gpc_latent_mean_and_variance_shape": [
    "kernel"
  ],
  "test_gpc_latent_mean_and_variance_complain_on_more_than_2_classes": [],
  "test_latent_mean_and_variance_works_on_structured_kernels": [],
  "MiniSeqKernel": {
    "__init__": [
      "self",
      "baseline_similarity",
      "baseline_similarity_bounds"
    ],
    "hyperparameter_baseline_similarity": [
      "self"
    ],
    "_f": [
      "self",
      "s1",
      "s2"
    ],
    "_g": [
      "self",
      "s1",
      "s2"
    ],
    "__call__": [
      "self",
      "X",
      "Y",
      "eval_gradient"
    ],
    "diag": [
      "self",
      "X"
    ],
    "clone_with_theta": [
      "self",
      "theta"
    ]
  },
  "_check_inputs_dtype": [
    "X",
    "missing_values"
  ],
  "_safe_min": [
    "items"
  ],
  "_most_frequent": [
    "array",
    "extra_value",
    "n_repeat"
  ],
  "_BaseImputer": {
    "__init__": [
      "self"
    ],
    "_fit_indicator": [
      "self",
      "X"
    ],
    "_transform_indicator": [
      "self",
      "X"
    ],
    "_concatenate_indicator": [
      "self",
      "X_imputed",
      "X_indicator"
    ],
    "_concatenate_indicator_feature_names_out": [
      "self",
      "names",
      "input_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MissingIndicator": {
    "__init__": [
      "self"
    ],
    "_get_missing_features_info": [
      "self",
      "X"
    ],
    "_validate_input": [
      "self",
      "X",
      "in_fit"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "precomputed"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KNNImputer": {
    "__init__": [
      "self"
    ],
    "_calc_impute": [
      "self",
      "dist_pot_donors",
      "n_neighbors",
      "fit_X_col",
      "mask_fit_X_col"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "_ImputerTriplet": [],
  "_assign_where": [
    "X1",
    "X2",
    "cond"
  ],
  "IterativeImputer": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_impute_one_feature": [
      "self",
      "X_filled",
      "mask_missing_values",
      "feat_idx",
      "neighbor_feat_idx",
      "estimator",
      "fit_mode",
      "params"
    ],
    "_get_neighbor_feat_idx": [
      "self",
      "n_features",
      "feat_idx",
      "abs_corr_mat"
    ],
    "_get_ordered_idx": [
      "self",
      "mask_missing_values"
    ],
    "_get_abs_corr_mat": [
      "self",
      "X_filled",
      "tolerance"
    ],
    "_initial_imputation": [
      "self",
      "X",
      "in_fit"
    ],
    "_validate_limit": [
      "limit",
      "limit_type",
      "n_features",
      "is_empty_feature",
      "keep_empty_feature"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_assert_array_equal_and_same_dtype": [
    "x",
    "y"
  ],
  "_assert_allclose_and_same_dtype": [
    "x",
    "y"
  ],
  "_check_statistics": [
    "X",
    "X_true",
    "strategy",
    "statistics",
    "missing_values",
    "sparse_container"
  ],
  "test_imputation_shape": [
    "strategy",
    "csr_container"
  ],
  "test_imputation_deletion_warning": [
    "strategy"
  ],
  "test_imputation_deletion_warning_feature_names": [
    "strategy"
  ],
  "test_imputation_error_sparse_0": [
    "strategy",
    "csc_container"
  ],
  "safe_median": [
    "arr"
  ],
  "safe_mean": [
    "arr"
  ],
  "test_imputation_mean_median": [
    "csc_container"
  ],
  "test_imputation_median_special_cases": [
    "csc_container"
  ],
  "test_imputation_mean_median_error_invalid_type": [
    "strategy",
    "dtype"
  ],
  "test_imputation_mean_median_error_invalid_type_list_pandas": [
    "strategy",
    "type"
  ],
  "test_imputation_const_mostf_error_invalid_types": [
    "strategy",
    "dtype"
  ],
  "test_imputation_most_frequent": [
    "csc_container"
  ],
  "test_imputation_most_frequent_objects": [
    "marker"
  ],
  "test_imputation_most_frequent_pandas": [
    "dtype"
  ],
  "test_imputation_constant_error_invalid_type": [
    "X_data",
    "missing_value"
  ],
  "test_imputation_constant_integer": [
    "keep_empty_features"
  ],
  "test_imputation_constant_float": [
    "array_constructor",
    "keep_empty_features"
  ],
  "test_imputation_constant_object": [
    "marker",
    "keep_empty_features"
  ],
  "test_imputation_constant_pandas": [
    "dtype",
    "keep_empty_features"
  ],
  "test_iterative_imputer_one_feature": [
    "X"
  ],
  "test_imputation_pipeline_grid_search": [],
  "test_imputation_copy": [],
  "test_iterative_imputer_zero_iters": [],
  "test_iterative_imputer_verbose": [],
  "test_iterative_imputer_all_missing": [],
  "test_iterative_imputer_imputation_order": [
    "imputation_order"
  ],
  "test_iterative_imputer_estimators": [
    "estimator"
  ],
  "test_iterative_imputer_clip": [],
  "test_iterative_imputer_clip_truncnorm": [],
  "test_iterative_imputer_truncated_normal_posterior": [],
  "test_iterative_imputer_missing_at_transform": [
    "strategy"
  ],
  "test_iterative_imputer_transform_stochasticity": [],
  "test_iterative_imputer_no_missing": [],
  "test_iterative_imputer_rank_one": [],
  "test_iterative_imputer_transform_recovery": [
    "rank"
  ],
  "test_iterative_imputer_additive_matrix": [],
  "test_iterative_imputer_early_stopping": [],
  "test_iterative_imputer_catch_warning": [],
  "test_iterative_imputer_min_max_array_like": [
    "min_value",
    "max_value",
    "correct_output"
  ],
  "test_iterative_imputer_catch_min_max_error": [
    "min_value",
    "max_value",
    "err_msg"
  ],
  "test_iterative_imputer_min_max_array_like_imputation": [
    "min_max_1",
    "min_max_2"
  ],
  "test_iterative_imputer_skip_non_missing": [
    "skip_complete"
  ],
  "test_iterative_imputer_dont_set_random_state": [
    "rs_imputer",
    "rs_estimator"
  ],
  "test_missing_indicator_error": [
    "X_fit",
    "X_trans",
    "params",
    "msg_err"
  ],
  "_generate_missing_indicator_cases": [],
  "test_missing_indicator_new": [
    "missing_values",
    "arr_type",
    "dtype",
    "param_features",
    "n_features",
    "features_indices"
  ],
  "test_missing_indicator_raise_on_sparse_with_missing_0": [
    "arr_type"
  ],
  "test_missing_indicator_sparse_param": [
    "arr_type",
    "missing_values",
    "param_sparse"
  ],
  "test_missing_indicator_string": [],
  "test_missing_indicator_with_imputer": [
    "X",
    "missing_values",
    "X_trans_exp"
  ],
  "test_inconsistent_dtype_X_missing_values": [
    "imputer_constructor",
    "imputer_missing_values",
    "missing_value",
    "err_msg"
  ],
  "test_missing_indicator_no_missing": [],
  "test_missing_indicator_sparse_no_explicit_zeros": [
    "csr_container"
  ],
  "test_imputer_without_indicator": [
    "imputer_constructor"
  ],
  "test_simple_imputation_add_indicator_sparse_matrix": [
    "arr_type"
  ],
  "test_simple_imputation_string_list": [
    "strategy",
    "expected"
  ],
  "test_imputation_order": [
    "order",
    "idx_order"
  ],
  "test_simple_imputation_inverse_transform": [
    "missing_value"
  ],
  "test_simple_imputation_inverse_transform_exceptions": [
    "missing_value"
  ],
  "test_most_frequent": [
    "expected",
    "array",
    "dtype",
    "extra_value",
    "n_repeat"
  ],
  "test_most_frequent_tie_object": [
    "expected",
    "array"
  ],
  "test_iterative_imputer_keep_empty_features": [
    "initial_strategy"
  ],
  "test_iterative_imputer_constant_fill_value": [
    "keep_empty_features"
  ],
  "test_iterative_imputer_min_max_value_remove_empty": [],
  "test_knn_imputer_keep_empty_features": [
    "keep_empty_features"
  ],
  "test_simple_impute_pd_na": [],
  "test_missing_indicator_feature_names_out": [],
  "test_imputer_lists_fit_transform": [],
  "test_imputer_transform_preserves_numeric_dtype": [
    "dtype_test"
  ],
  "test_simple_imputer_keep_empty_features": [
    "strategy",
    "array_type",
    "keep_empty_features"
  ],
  "test_imputation_custom": [
    "csc_container"
  ],
  "test_simple_imputer_constant_fill_value_casting": [],
  "test_iterative_imputer_no_empty_features": [
    "strategy"
  ],
  "test_iterative_imputer_with_empty_features": [
    "strategy",
    "X_test"
  ],
  "imputers": [],
  "sparse_imputers": [],
  "test_imputation_missing_value_in_test_array": [
    "imputer"
  ],
  "test_imputers_add_indicator": [
    "marker",
    "imputer"
  ],
  "test_imputers_add_indicator_sparse": [
    "imputer",
    "marker",
    "csr_container"
  ],
  "test_imputers_pandas_na_integer_array_support": [
    "imputer",
    "add_indicator"
  ],
  "test_imputers_feature_names_out_pandas": [
    "imputer",
    "add_indicator"
  ],
  "test_keep_empty_features": [
    "imputer",
    "keep_empty_features"
  ],
  "test_imputation_adds_missing_indicator_if_add_indicator_is_true": [
    "imputer",
    "missing_value_test"
  ],
  "test_knn_imputer_shape": [
    "weights",
    "n_neighbors"
  ],
  "test_knn_imputer_default_with_invalid_input": [
    "na"
  ],
  "test_knn_imputer_removes_all_na_features": [
    "na"
  ],
  "test_knn_imputer_zero_nan_imputes_the_same": [
    "na"
  ],
  "test_knn_imputer_verify": [
    "na"
  ],
  "test_knn_imputer_one_n_neighbors": [
    "na"
  ],
  "test_knn_imputer_all_samples_are_neighbors": [
    "na"
  ],
  "test_knn_imputer_weight_uniform": [
    "na"
  ],
  "test_knn_imputer_weight_distance": [
    "na"
  ],
  "test_knn_imputer_callable_metric": [],
  "test_knn_imputer_with_simple_example": [
    "na",
    "working_memory"
  ],
  "test_knn_imputer_not_enough_valid_distances": [
    "na",
    "weights"
  ],
  "test_knn_imputer_nan_distance": [
    "na",
    "weights"
  ],
  "test_knn_imputer_drops_all_nan_features": [
    "na"
  ],
  "test_knn_imputer_distance_weighted_not_enough_neighbors": [
    "na",
    "working_memory"
  ],
  "test_knn_tags": [
    "na",
    "allow_nan"
  ],
  "NoFitIndicatorImputer": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "NoTransformIndicatorImputer": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ]
  },
  "NoPrecomputedMaskFit": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "NoPrecomputedMaskTransform": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "test_base_imputer_not_fit": [
    "data"
  ],
  "test_base_imputer_not_transform": [
    "data"
  ],
  "test_base_no_precomputed_mask_fit": [
    "data"
  ],
  "test_base_no_precomputed_mask_transform": [
    "data"
  ],
  "test_assign_where": [
    "X1_type"
  ],
  "IncrementalPCA": {
    "__metadata_request__partial_fit": [],
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "check_input"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_assess_dimension": [
    "spectrum",
    "rank",
    "n_samples"
  ],
  "_infer_dimension": [
    "spectrum",
    "n_samples"
  ],
  "_check_positive_coding": [
    "method",
    "positive"
  ],
  "_sparse_encode_precomputed": [
    "X",
    "dictionary"
  ],
  "sparse_encode": [
    "X",
    "dictionary"
  ],
  "_sparse_encode": [
    "X",
    "dictionary"
  ],
  "_update_dict": [
    "dictionary",
    "Y",
    "code",
    "A",
    "B",
    "verbose",
    "random_state",
    "positive"
  ],
  "_dict_learning": [
    "X",
    "n_components"
  ],
  "dict_learning_online": [
    "X",
    "n_components"
  ],
  "dict_learning": [
    "X",
    "n_components"
  ],
  "_BaseSparseCoding": {
    "__init__": [
      "self",
      "transform_algorithm",
      "transform_n_nonzero_coefs",
      "transform_alpha",
      "split_sign",
      "n_jobs",
      "positive_code",
      "transform_max_iter"
    ],
    "_transform": [
      "self",
      "X",
      "dictionary"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_inverse_transform": [
      "self",
      "code",
      "dictionary"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "SparseCoder": {
    "__init__": [
      "self",
      "dictionary"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "DictionaryLearning": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MiniBatchDictionaryLearning": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_check_params": [
      "self",
      "X"
    ],
    "_initialize_dict": [
      "self",
      "X",
      "random_state"
    ],
    "_update_inner_stats": [
      "self",
      "X",
      "code",
      "batch_size",
      "step"
    ],
    "_minibatch_step": [
      "self",
      "X",
      "dictionary",
      "random_state",
      "step"
    ],
    "_check_convergence": [
      "self",
      "X",
      "batch_cost",
      "new_dict",
      "old_dict",
      "n_samples",
      "step",
      "n_steps"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_BasePCA": {
    "get_covariance": [
      "self"
    ],
    "get_precision": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X",
      "xp",
      "x_is_centered"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "FactorAnalysis": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_covariance": [
      "self"
    ],
    "get_precision": [
      "self"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "_rotate": [
      "self",
      "components",
      "n_components",
      "tol"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "_ortho_rotation": [
    "components",
    "method",
    "tol",
    "max_iter"
  ],
  "EPS": [],
  "_update_doc_distribution": [
    "X",
    "exp_topic_word_distr",
    "doc_topic_prior",
    "max_doc_update_iter",
    "mean_change_tol",
    "cal_sstats",
    "random_state"
  ],
  "LatentDirichletAllocation": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_init_latent_vars": [
      "self",
      "n_features",
      "dtype"
    ],
    "_e_step": [
      "self",
      "X",
      "cal_sstats",
      "random_init",
      "parallel"
    ],
    "_em_step": [
      "self",
      "X",
      "total_samples",
      "batch_update",
      "parallel"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_check_non_neg_array": [
      "self",
      "X",
      "reset_n_features",
      "whom"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_unnormalized_transform": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_approx_bound": [
      "self",
      "X",
      "doc_topic_distr",
      "sub_sampling"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "_perplexity_precomp_distr": [
      "self",
      "X",
      "doc_topic_distr",
      "sub_sampling"
    ],
    "perplexity": [
      "self",
      "X",
      "sub_sampling"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "TruncatedSVD": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "EPSILON": [],
  "norm": [
    "x"
  ],
  "trace_dot": [
    "X",
    "Y"
  ],
  "_check_init": [
    "A",
    "shape",
    "whom"
  ],
  "_beta_divergence": [
    "X",
    "W",
    "H",
    "beta",
    "square_root"
  ],
  "_special_sparse_dot": [
    "W",
    "H",
    "X"
  ],
  "_beta_loss_to_float": [
    "beta_loss"
  ],
  "_initialize_nmf": [
    "X",
    "n_components",
    "init",
    "eps",
    "random_state"
  ],
  "_update_coordinate_descent": [
    "X",
    "W",
    "Ht",
    "l1_reg",
    "l2_reg",
    "shuffle",
    "random_state"
  ],
  "_fit_coordinate_descent": [
    "X",
    "W",
    "H",
    "tol",
    "max_iter",
    "l1_reg_W",
    "l1_reg_H",
    "l2_reg_W",
    "l2_reg_H",
    "update_H",
    "verbose",
    "shuffle",
    "random_state"
  ],
  "_multiplicative_update_w": [
    "X",
    "W",
    "H",
    "beta_loss",
    "l1_reg_W",
    "l2_reg_W",
    "gamma",
    "H_sum",
    "HHt",
    "XHt",
    "update_H"
  ],
  "_multiplicative_update_h": [
    "X",
    "W",
    "H",
    "beta_loss",
    "l1_reg_H",
    "l2_reg_H",
    "gamma",
    "A",
    "B",
    "rho"
  ],
  "_fit_multiplicative_update": [
    "X",
    "W",
    "H",
    "beta_loss",
    "max_iter",
    "tol",
    "l1_reg_W",
    "l1_reg_H",
    "l2_reg_W",
    "l2_reg_H",
    "update_H",
    "verbose"
  ],
  "non_negative_factorization": [
    "X",
    "W",
    "H",
    "n_components"
  ],
  "_BaseNMF": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_check_params": [
      "self",
      "X"
    ],
    "_check_w_h": [
      "self",
      "X",
      "W",
      "H",
      "update_H"
    ],
    "_compute_regularization": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "MiniBatchNMF": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_check_params": [
      "self",
      "X"
    ],
    "_solve_W": [
      "self",
      "X",
      "H",
      "max_iter"
    ],
    "_minibatch_step": [
      "self",
      "X",
      "W",
      "H",
      "update_H"
    ],
    "_minibatch_convergence": [
      "self",
      "X",
      "batch_cost",
      "H",
      "H_buffer",
      "n_samples",
      "step",
      "n_steps"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "W",
      "H"
    ],
    "_fit_transform": [
      "self",
      "X",
      "W",
      "H",
      "update_H"
    ],
    "transform": [
      "self",
      "X"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "W",
      "H"
    ]
  },
  "_BaseSparsePCA": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SparsePCA": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_fit": [
      "self",
      "X",
      "n_components",
      "random_state"
    ]
  },
  "MiniBatchSparsePCA": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_fit": [
      "self",
      "X",
      "n_components",
      "random_state"
    ]
  },
  "_gs_decorrelation": [
    "w",
    "W",
    "j"
  ],
  "_sym_decorrelation": [
    "W"
  ],
  "_ica_def": [
    "X",
    "tol",
    "g",
    "fun_args",
    "max_iter",
    "w_init"
  ],
  "_ica_par": [
    "X",
    "tol",
    "g",
    "fun_args",
    "max_iter",
    "w_init"
  ],
  "_logcosh": [
    "x",
    "fun_args"
  ],
  "_exp": [
    "x",
    "fun_args"
  ],
  "_cube": [
    "x",
    "fun_args"
  ],
  "fastica": [
    "X",
    "n_components"
  ],
  "FastICA": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_fit_transform": [
      "self",
      "X",
      "compute_sources"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "copy"
    ],
    "inverse_transform": [
      "self",
      "X",
      "copy"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KernelPCA": {
    "__init__": [
      "self",
      "n_components"
    ],
    "_get_kernel": [
      "self",
      "X",
      "Y"
    ],
    "_fit_transform_in_place": [
      "self",
      "K"
    ],
    "_fit_inverse_transform": [
      "self",
      "X_transformed",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "rng_global": [],
  "test_sparse_encode_shapes_omp": [],
  "test_dict_learning_shapes": [],
  "test_dict_learning_overcomplete": [],
  "test_dict_learning_lars_positive_parameter": [],
  "test_dict_learning_positivity": [
    "transform_algorithm",
    "positive_code",
    "positive_dict"
  ],
  "test_dict_learning_lars_dict_positivity": [
    "positive_dict"
  ],
  "test_dict_learning_lars_code_positivity": [],
  "test_dict_learning_reconstruction": [],
  "test_dict_learning_reconstruction_parallel": [],
  "test_dict_learning_lassocd_readonly_data": [],
  "test_dict_learning_nonzero_coefs": [],
  "test_dict_learning_split": [],
  "test_dict_learning_online_shapes": [],
  "test_dict_learning_online_lars_positive_parameter": [],
  "test_minibatch_dictionary_learning_positivity": [
    "transform_algorithm",
    "positive_code",
    "positive_dict"
  ],
  "test_minibatch_dictionary_learning_lars": [
    "positive_dict"
  ],
  "test_dict_learning_online_positivity": [
    "positive_code",
    "positive_dict"
  ],
  "test_dict_learning_online_verbosity": [],
  "test_dict_learning_online_estimator_shapes": [],
  "test_dict_learning_online_overcomplete": [],
  "test_dict_learning_online_initialization": [],
  "test_dict_learning_online_readonly_initialization": [],
  "test_dict_learning_online_partial_fit": [],
  "test_sparse_encode_shapes": [],
  "test_sparse_encode_positivity": [
    "algo",
    "positive"
  ],
  "test_sparse_encode_unavailable_positivity": [
    "algo"
  ],
  "test_sparse_encode_input": [],
  "test_sparse_encode_error": [],
  "test_sparse_encode_error_default_sparsity": [],
  "test_sparse_coder_estimator": [],
  "test_sparse_coder_estimator_clone": [],
  "test_sparse_coder_parallel_mmap": [],
  "test_sparse_coder_common_transformer": [],
  "test_sparse_coder_n_features_in": [],
  "test_sparse_encoder_feature_number_error": [],
  "test_update_dict": [],
  "test_sparse_encode_dtype_match": [
    "data_type",
    "algorithm"
  ],
  "test_sparse_encode_numerical_consistency": [
    "algorithm"
  ],
  "test_sparse_coder_dtype_match": [
    "data_type",
    "transform_algorithm"
  ],
  "test_dictionary_learning_dtype_match": [
    "data_type",
    "expected_type",
    "fit_algorithm",
    "transform_algorithm"
  ],
  "test_minibatch_dictionary_learning_dtype_match": [
    "data_type",
    "expected_type",
    "fit_algorithm",
    "transform_algorithm"
  ],
  "test_dict_learning_dtype_match": [
    "data_type",
    "expected_type",
    "method"
  ],
  "test_dict_learning_numerical_consistency": [
    "method"
  ],
  "test_dict_learning_online_dtype_match": [
    "data_type",
    "expected_type",
    "method"
  ],
  "test_dict_learning_online_numerical_consistency": [
    "method"
  ],
  "test_cd_work_on_joblib_memmapped_data": [
    "monkeypatch"
  ],
  "test_kernel_pca": [
    "global_random_seed"
  ],
  "test_kernel_pca_invalid_parameters": [],
  "test_kernel_pca_consistent_transform": [
    "global_random_seed"
  ],
  "test_kernel_pca_deterministic_output": [
    "global_random_seed"
  ],
  "test_kernel_pca_sparse": [
    "csr_container",
    "global_random_seed"
  ],
  "test_kernel_pca_linear_kernel": [
    "solver",
    "n_features",
    "global_random_seed"
  ],
  "test_kernel_pca_n_components": [],
  "test_remove_zero_eig": [],
  "test_leave_zero_eig": [],
  "test_kernel_pca_precomputed": [
    "global_random_seed"
  ],
  "test_kernel_pca_precomputed_non_symmetric": [
    "solver"
  ],
  "test_gridsearch_pipeline_precomputed": [],
  "test_nested_circles": [],
  "test_kernel_conditioning": [],
  "test_precomputed_kernel_not_psd": [
    "solver"
  ],
  "test_kernel_pca_solvers_equivalence": [
    "n_components"
  ],
  "test_kernel_pca_inverse_transform_reconstruction": [],
  "test_kernel_pca_raise_not_fitted_error": [],
  "test_32_64_decomposition_shape": [],
  "test_kernel_pca_feature_names_out": [],
  "test_kernel_pca_inverse_correct_gamma": [
    "global_random_seed"
  ],
  "test_kernel_pca_pandas_output": [],
  "generate_toy_data": [
    "n_components",
    "n_samples",
    "image_size",
    "random_state"
  ],
  "test_fit_transform": [
    "global_random_seed"
  ],
  "test_fit_transform_parallel": [
    "global_random_seed"
  ],
  "test_transform_nan": [
    "global_random_seed"
  ],
  "test_fit_transform_tall": [
    "global_random_seed"
  ],
  "test_initialization": [
    "global_random_seed"
  ],
  "test_mini_batch_correct_shapes": [],
  "test_scaling_fit_transform": [
    "global_random_seed"
  ],
  "test_pca_vs_spca": [
    "global_random_seed"
  ],
  "test_spca_n_components_": [
    "SPCA",
    "n_components"
  ],
  "test_sparse_pca_dtype_match": [
    "SPCA",
    "method",
    "data_type",
    "expected_type"
  ],
  "test_sparse_pca_numerical_consistency": [
    "SPCA",
    "method",
    "global_random_seed"
  ],
  "test_spca_feature_names_out": [
    "SPCA"
  ],
  "test_spca_early_stopping": [
    "global_random_seed"
  ],
  "test_equivalence_components_pca_spca": [
    "global_random_seed"
  ],
  "test_sparse_pca_inverse_transform": [
    "global_random_seed"
  ],
  "test_transform_inverse_transform_round_trip": [
    "SPCA",
    "global_random_seed"
  ],
  "test_initialize_nn_output": [],
  "test_parameter_checking": [],
  "test_initialize_close": [],
  "test_initialize_variants": [],
  "test_nmf_fit_nn_output": [
    "Estimator",
    "solver",
    "init",
    "alpha_W",
    "alpha_H"
  ],
  "test_nmf_fit_close": [
    "Estimator",
    "solver"
  ],
  "test_nmf_true_reconstruction": [],
  "test_nmf_transform": [
    "solver"
  ],
  "test_minibatch_nmf_transform": [],
  "test_nmf_transform_custom_init": [
    "Estimator",
    "solver"
  ],
  "test_nmf_inverse_transform": [
    "solver"
  ],
  "test_mbnmf_inverse_transform": [],
  "test_n_components_greater_n_features": [
    "Estimator"
  ],
  "test_nmf_sparse_input": [
    "Estimator",
    "solver",
    "sparse_container",
    "alpha_W",
    "alpha_H"
  ],
  "test_nmf_sparse_transform": [
    "Estimator",
    "solver",
    "csc_container"
  ],
  "test_non_negative_factorization_consistency": [
    "init",
    "solver",
    "alpha_W",
    "alpha_H"
  ],
  "test_non_negative_factorization_checking": [],
  "_beta_divergence_dense": [
    "X",
    "W",
    "H",
    "beta"
  ],
  "test_beta_divergence": [
    "csr_container"
  ],
  "test_special_sparse_dot": [
    "csr_container"
  ],
  "test_nmf_multiplicative_update_sparse": [
    "csr_container"
  ],
  "test_nmf_negative_beta_loss": [
    "csr_container"
  ],
  "test_minibatch_nmf_negative_beta_loss": [
    "beta_loss"
  ],
  "test_nmf_regularization": [
    "Estimator",
    "solver"
  ],
  "test_nmf_decreasing": [
    "solver"
  ],
  "test_nmf_underflow": [],
  "test_nmf_dtype_match": [
    "Estimator",
    "solver",
    "dtype_in",
    "dtype_out"
  ],
  "test_nmf_float32_float64_consistency": [
    "Estimator",
    "solver"
  ],
  "test_nmf_custom_init_dtype_error": [
    "Estimator"
  ],
  "test_nmf_minibatchnmf_equivalence": [
    "beta_loss"
  ],
  "test_minibatch_nmf_partial_fit": [],
  "test_minibatch_nmf_verbose": [],
  "test_nmf_n_components_auto": [
    "Estimator"
  ],
  "test_nmf_non_negative_factorization_n_components_auto": [],
  "test_nmf_n_components_auto_no_h_update": [],
  "test_nmf_w_h_not_used_warning": [],
  "test_nmf_custom_init_shape_error": [],
  "_build_sparse_array": [
    "csr_container"
  ],
  "test_lda_default_prior_params": [
    "csr_container"
  ],
  "test_lda_fit_batch": [
    "csr_container"
  ],
  "test_lda_fit_online": [
    "csr_container"
  ],
  "test_lda_partial_fit": [
    "csr_container"
  ],
  "test_lda_dense_input": [
    "csr_container"
  ],
  "test_lda_fit_transform": [
    "method"
  ],
  "test_lda_negative_input": [],
  "test_lda_no_component_error": [],
  "test_lda_multi_jobs": [
    "method",
    "csr_container"
  ],
  "test_lda_partial_fit_multi_jobs": [
    "csr_container"
  ],
  "test_lda_preplexity_mismatch": [],
  "test_lda_perplexity": [
    "method",
    "csr_container"
  ],
  "test_lda_score": [
    "method",
    "csr_container"
  ],
  "test_perplexity_input_format": [
    "csr_container"
  ],
  "test_lda_score_perplexity": [
    "csr_container"
  ],
  "test_lda_fit_perplexity": [
    "csr_container"
  ],
  "test_lda_empty_docs": [
    "csr_container"
  ],
  "test_dirichlet_expectation": [],
  "check_verbosity": [
    "verbose",
    "evaluate_every",
    "expected_lines",
    "expected_perplexities",
    "csr_container"
  ],
  "test_lda_feature_names_out": [
    "csr_container"
  ],
  "test_lda_numerical_consistency": [
    "learning_method",
    "global_random_seed"
  ],
  "center_and_norm": [
    "x",
    "axis"
  ],
  "test_gs": [
    "global_random_seed"
  ],
  "test_fastica_attributes_dtypes": [
    "global_dtype"
  ],
  "test_fastica_return_dtypes": [
    "global_dtype"
  ],
  "test_fastica_simple": [
    "add_noise",
    "global_random_seed",
    "global_dtype"
  ],
  "test_fastica_nowhiten": [],
  "test_fastica_convergence_fail": [
    "global_random_seed"
  ],
  "test_non_square_fastica": [
    "global_random_seed",
    "add_noise"
  ],
  "test_fastica_errors": [],
  "test_fastica_whiten_unit_variance": [
    "global_random_seed"
  ],
  "test_fastica_output_shape": [
    "whiten",
    "return_X_mean",
    "return_n_iter"
  ],
  "test_fastica_simple_different_solvers": [
    "add_noise",
    "global_random_seed"
  ],
  "test_fastica_eigh_low_rank_warning": [
    "global_random_seed"
  ],
  "SVD_SOLVERS": [],
  "X_sparse": [],
  "test_solvers": [
    "X_sparse",
    "solver",
    "kind"
  ],
  "test_attributes": [
    "n_components",
    "X_sparse"
  ],
  "test_too_many_components": [
    "X_sparse",
    "algorithm",
    "n_components"
  ],
  "test_sparse_formats": [
    "fmt",
    "X_sparse"
  ],
  "test_integers": [
    "X_sparse"
  ],
  "test_explained_variance": [
    "X_sparse",
    "kind",
    "n_components",
    "solver"
  ],
  "test_explained_variance_components_10_20": [
    "X_sparse",
    "kind",
    "solver"
  ],
  "test_singular_values_consistency": [
    "solver",
    "global_random_seed"
  ],
  "test_singular_values_expected": [
    "solver",
    "global_random_seed"
  ],
  "test_truncated_svd_eq_pca": [
    "X_sparse"
  ],
  "test_factor_analysis": [
    "global_random_seed"
  ],
  "PCA_SOLVERS": [],
  "SPARSE_MAX_COMPONENTS": [],
  "_check_fitted_pca_close": [
    "pca1",
    "pca2",
    "rtol",
    "atol"
  ],
  "test_pca": [
    "svd_solver",
    "n_components"
  ],
  "test_pca_sparse": [
    "global_random_seed",
    "svd_solver",
    "sparse_container",
    "n_components",
    "density",
    "scale"
  ],
  "test_pca_sparse_fit_transform": [
    "global_random_seed",
    "sparse_container"
  ],
  "test_sparse_pca_solver_error": [
    "global_random_seed",
    "svd_solver",
    "sparse_container"
  ],
  "test_sparse_pca_auto_arpack_singluar_values_consistency": [
    "global_random_seed",
    "sparse_container"
  ],
  "test_no_empty_slice_warning": [],
  "test_whitening": [
    "solver",
    "copy"
  ],
  "test_pca_solver_equivalence": [
    "other_svd_solver",
    "data_shape",
    "rank_deficient",
    "whiten",
    "global_random_seed",
    "global_dtype"
  ],
  "test_pca_explained_variance_empirical": [
    "X",
    "svd_solver"
  ],
  "test_pca_singular_values_consistency": [
    "svd_solver"
  ],
  "test_pca_singular_values": [
    "svd_solver"
  ],
  "test_pca_check_projection": [
    "svd_solver"
  ],
  "test_pca_check_projection_list": [
    "svd_solver"
  ],
  "test_pca_inverse": [
    "svd_solver",
    "whiten"
  ],
  "test_pca_validation": [
    "svd_solver",
    "data",
    "n_components",
    "err_msg"
  ],
  "test_n_components_none": [
    "data",
    "solver",
    "n_components_"
  ],
  "test_n_components_mle": [
    "svd_solver"
  ],
  "test_n_components_mle_error": [
    "svd_solver"
  ],
  "test_pca_dim": [],
  "test_infer_dim_1": [],
  "test_infer_dim_2": [],
  "test_infer_dim_3": [],
  "test_infer_dim_by_explained_variance": [
    "X",
    "n_components",
    "n_components_validated"
  ],
  "test_pca_score": [
    "svd_solver"
  ],
  "test_pca_score3": [],
  "test_pca_sanity_noise_variance": [
    "svd_solver"
  ],
  "test_pca_score_consistency_solvers": [
    "svd_solver"
  ],
  "test_pca_zero_noise_variance_edge_cases": [
    "svd_solver"
  ],
  "test_pca_svd_solver_auto": [
    "n_samples",
    "n_features",
    "n_components",
    "expected_solver"
  ],
  "test_pca_deterministic_output": [
    "svd_solver"
  ],
  "test_pca_dtype_preservation": [
    "svd_solver",
    "global_random_seed"
  ],
  "check_pca_float_dtype_preservation": [
    "svd_solver",
    "seed"
  ],
  "check_pca_int_dtype_upcast_to_double": [
    "svd_solver"
  ],
  "test_pca_n_components_mostly_explained_variance_ratio": [],
  "test_assess_dimension_bad_rank": [],
  "test_small_eigenvalues_mle": [],
  "test_mle_redundant_data": [],
  "test_fit_mle_too_few_samples": [],
  "test_mle_simple_case": [],
  "test_assess_dimesion_rank_one": [],
  "test_pca_randomized_svd_n_oversamples": [],
  "test_variance_correctness": [
    "copy"
  ],
  "check_array_api_get_precision": [
    "name",
    "estimator",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_pca_array_api_compliance": [
    "estimator",
    "check",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_pca_mle_array_api_compliance": [
    "estimator",
    "check",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_array_api_error_and_warnings_on_unsupported_params": [],
  "test_incremental_pca": [],
  "test_incremental_pca_sparse": [
    "sparse_container"
  ],
  "test_incremental_pca_check_projection": [
    "global_random_seed"
  ],
  "test_incremental_pca_inverse": [
    "global_random_seed"
  ],
  "test_incremental_pca_validation": [],
  "test_n_samples_equal_n_components": [],
  "test_incremental_pca_set_params": [],
  "test_incremental_pca_num_features_change": [],
  "test_incremental_pca_batch_signs": [
    "global_random_seed"
  ],
  "test_incremental_pca_partial_fit_small_batch": [],
  "test_incremental_pca_batch_values": [
    "global_random_seed"
  ],
  "test_incremental_pca_batch_rank": [],
  "test_incremental_pca_partial_fit": [
    "global_random_seed"
  ],
  "test_incremental_pca_against_pca_iris": [],
  "test_incremental_pca_against_pca_random_data": [
    "global_random_seed"
  ],
  "test_explained_variances": [],
  "test_singular_values": [
    "global_random_seed"
  ],
  "test_incremental_pca_partial_fit_float_division": [],
  "test_incremental_pca_fit_overflow_error": [],
  "test_incremental_pca_feature_names_out": [],
  "INPLACE_MSG": [],
  "STANDARD_MSG": [],
  "raise_build_error": [
    "e"
  ],
  "_smacof_single": [
    "dissimilarities",
    "metric",
    "n_components",
    "init",
    "max_iter",
    "verbose",
    "eps",
    "random_state",
    "normalized_stress"
  ],
  "smacof": [
    "dissimilarities"
  ],
  "MDS": {
    "__init__": [
      "self",
      "n_components"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "init"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "init"
    ]
  },
  "barycenter_weights": [
    "X",
    "Y",
    "indices",
    "reg"
  ],
  "barycenter_kneighbors_graph": [
    "X",
    "n_neighbors",
    "reg",
    "n_jobs"
  ],
  "null_space": [
    "M",
    "k",
    "k_skip",
    "eigen_solver",
    "tol",
    "max_iter",
    "random_state"
  ],
  "_locally_linear_embedding": [
    "X"
  ],
  "locally_linear_embedding": [
    "X"
  ],
  "LocallyLinearEmbedding": {
    "__init__": [
      "self"
    ],
    "_fit_transform": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "ClassicalMDS": {
    "__init__": [
      "self",
      "n_components"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "_graph_connected_component": [
    "graph",
    "node_id"
  ],
  "_graph_is_connected": [
    "graph"
  ],
  "_set_diag": [
    "laplacian",
    "value",
    "norm_laplacian"
  ],
  "spectral_embedding": [
    "adjacency"
  ],
  "_spectral_embedding": [
    "adjacency"
  ],
  "SpectralEmbedding": {
    "__init__": [
      "self",
      "n_components"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_get_affinity_matrix": [
      "self",
      "X",
      "Y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "MACHINE_EPSILON": [],
  "_joint_probabilities": [
    "distances",
    "desired_perplexity",
    "verbose"
  ],
  "_joint_probabilities_nn": [
    "distances",
    "desired_perplexity",
    "verbose"
  ],
  "_kl_divergence": [
    "params",
    "P",
    "degrees_of_freedom",
    "n_samples",
    "n_components",
    "skip_num_points",
    "compute_error"
  ],
  "_kl_divergence_bh": [
    "params",
    "P",
    "degrees_of_freedom",
    "n_samples",
    "n_components",
    "angle",
    "skip_num_points",
    "verbose",
    "compute_error",
    "num_threads"
  ],
  "_gradient_descent": [
    "objective",
    "p0",
    "it",
    "max_iter",
    "n_iter_check",
    "n_iter_without_progress",
    "momentum",
    "learning_rate",
    "min_gain",
    "min_grad_norm",
    "verbose",
    "args",
    "kwargs"
  ],
  "trustworthiness": [
    "X",
    "X_embedded"
  ],
  "TSNE": {
    "_EXPLORATION_MAX_ITER": [],
    "_N_ITER_CHECK": [],
    "__init__": [
      "self",
      "n_components"
    ],
    "_check_params_vs_input": [
      "self",
      "X"
    ],
    "_fit": [
      "self",
      "X",
      "skip_num_points"
    ],
    "_tsne": [
      "self",
      "P",
      "degrees_of_freedom",
      "n_samples",
      "X_embedded",
      "neighbors",
      "skip_num_points"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "Isomap": {
    "__init__": [
      "self"
    ],
    "_fit_transform": [
      "self",
      "X"
    ],
    "reconstruction_error": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "skip_if_no_pyamg": [],
  "centers": [],
  "_assert_equal_with_sign_flipping": [
    "A",
    "B",
    "tol"
  ],
  "test_sparse_graph_connected_component": [
    "coo_container"
  ],
  "test_spectral_embedding_two_components": [
    "eigen_solver",
    "dtype",
    "seed"
  ],
  "test_spectral_embedding_precomputed_affinity": [
    "sparse_container",
    "eigen_solver",
    "dtype",
    "seed"
  ],
  "test_precomputed_nearest_neighbors_filtering": [],
  "test_spectral_embedding_callable_affinity": [
    "sparse_container",
    "seed"
  ],
  "test_spectral_embedding_amg_solver": [
    "dtype",
    "coo_container",
    "seed"
  ],
  "test_spectral_embedding_amg_solver_failure": [
    "dtype",
    "seed"
  ],
  "test_pipeline_spectral_clustering": [
    "seed"
  ],
  "test_connectivity": [
    "seed"
  ],
  "test_spectral_embedding_deterministic": [],
  "test_spectral_embedding_unnormalized": [],
  "test_spectral_embedding_first_eigen_vector": [],
  "test_spectral_embedding_preserves_dtype": [
    "eigen_solver",
    "dtype"
  ],
  "test_error_pyamg_not_available": [],
  "test_spectral_eigen_tol_auto": [
    "monkeypatch",
    "solver",
    "csr_container"
  ],
  "eigen_solvers": [],
  "path_methods": [],
  "create_sample_data": [
    "dtype",
    "n_pts",
    "add_noise"
  ],
  "test_isomap_simple_grid": [
    "global_dtype",
    "n_neighbors",
    "radius",
    "eigen_solver",
    "path_method"
  ],
  "test_isomap_reconstruction_error": [
    "global_dtype",
    "n_neighbors",
    "radius",
    "eigen_solver",
    "path_method"
  ],
  "test_pipeline_with_nearest_neighbors_transformer": [
    "global_dtype"
  ],
  "test_different_metric": [
    "global_dtype",
    "metric",
    "p",
    "is_euclidean"
  ],
  "test_isomap_clone_bug": [],
  "test_isomap_fit_precomputed_radius_graph": [
    "global_dtype"
  ],
  "test_isomap_fitted_attributes_dtype": [
    "global_dtype"
  ],
  "test_isomap_dtype_equivalence": [],
  "test_isomap_raise_error_when_neighbor_and_radius_both_set": [],
  "test_multiple_connected_components": [],
  "test_multiple_connected_components_metric_precomputed": [
    "global_dtype"
  ],
  "x": [],
  "X_2d_grid": [],
  "test_gradient_descent_stops": [
    "capsys"
  ],
  "test_binary_search": [],
  "test_binary_search_underflow": [],
  "test_binary_search_neighbors": [],
  "test_binary_perplexity_stability": [],
  "test_trustworthiness": [],
  "test_trustworthiness_n_neighbors_error": [],
  "test_preserve_trustworthiness_approximately": [
    "method",
    "init"
  ],
  "test_optimization_minimizes_kl_divergence": [],
  "test_fit_transform_csr_matrix": [
    "method",
    "init",
    "csr_container"
  ],
  "test_preserve_trustworthiness_approximately_with_precomputed_distances": [],
  "test_trustworthiness_not_euclidean_metric": [],
  "test_bad_precomputed_distances": [
    "method",
    "D",
    "retype",
    "message_regex"
  ],
  "test_exact_no_precomputed_sparse": [
    "csr_container"
  ],
  "test_high_perplexity_precomputed_sparse_distances": [
    "csr_container"
  ],
  "test_sparse_precomputed_distance": [
    "sparse_container"
  ],
  "test_non_positive_computed_distances": [],
  "test_init_ndarray": [],
  "test_init_ndarray_precomputed": [],
  "test_pca_initialization_not_compatible_with_precomputed_kernel": [],
  "test_n_components_range": [],
  "test_early_exaggeration_used": [],
  "test_max_iter_used": [],
  "test_answer_gradient_two_points": [
    "csr_container"
  ],
  "test_answer_gradient_four_points": [
    "csr_container"
  ],
  "test_skip_num_points_gradient": [
    "csr_container"
  ],
  "_run_answer_test": [
    "pos_input",
    "pos_output",
    "neighbors",
    "grad_output",
    "csr_container",
    "verbose",
    "perplexity",
    "skip_num_points"
  ],
  "test_chebyshev_metric": [],
  "test_reduction_to_one_component": [],
  "test_64bit": [
    "method",
    "dt"
  ],
  "test_kl_divergence_not_nan": [
    "method"
  ],
  "test_barnes_hut_angle": [],
  "test_n_iter_without_progress": [
    "capsys"
  ],
  "test_min_grad_norm": [
    "capsys"
  ],
  "test_accessible_kl_divergence": [
    "capsys"
  ],
  "test_uniform_grid": [
    "method"
  ],
  "assert_uniform_grid": [
    "Y",
    "try_name"
  ],
  "test_bh_match_exact": [],
  "test_gradient_bh_multithread_match_sequential": [],
  "test_tsne_with_different_distance_metrics": [
    "metric",
    "dist_func",
    "method"
  ],
  "test_tsne_n_jobs": [
    "method"
  ],
  "test_tsne_with_mahalanobis_distance": [],
  "test_tsne_perplexity_validation": [
    "perplexity"
  ],
  "test_tsne_works_with_pandas_output": [],
  "test_classical_mds_equivalent_to_pca": [],
  "test_classical_mds_equivalent_on_data_and_distances": [],
  "test_classical_mds_wrong_inputs": [],
  "test_classical_mds_metric_params": [],
  "test_barycenter_kneighbors_graph": [
    "global_dtype"
  ],
  "test_lle_simple_grid": [
    "global_dtype"
  ],
  "test_lle_manifold": [
    "global_dtype",
    "method",
    "solver"
  ],
  "test_integer_input": [],
  "test_smacof": [],
  "test_nonmetric_lower_normalized_stress": [],
  "test_nonmetric_mds_optimization": [],
  "test_mds_recovers_true_data": [
    "metric_mds"
  ],
  "test_smacof_error": [],
  "test_MDS": [],
  "test_normed_stress": [
    "k"
  ],
  "test_normalized_stress_auto": [
    "metric",
    "monkeypatch"
  ],
  "test_isotonic_outofbounds": [],
  "test_returned_stress": [
    "normalized_stress"
  ],
  "test_convergence_does_not_depend_on_scale": [
    "metric_mds"
  ],
  "test_future_warning_n_init": [],
  "test_future_warning_init_and_metric": [],
  "test_classical_mds_init_to_mds": [],
  "SelfTrainingClassifier": {
    "__init__": [
      "self",
      "estimator",
      "threshold",
      "criterion",
      "k_best",
      "max_iter",
      "verbose"
    ],
    "_get_estimator": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "BaseLabelPropagation": {
    "__init__": [
      "self",
      "kernel"
    ],
    "_get_kernel": [
      "self",
      "X",
      "y"
    ],
    "_build_graph": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LabelPropagation": {
    "_variant": [],
    "__init__": [
      "self",
      "kernel"
    ],
    "_build_graph": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "LabelSpreading": {
    "_variant": [],
    "__init__": [
      "self",
      "kernel"
    ],
    "_build_graph": [
      "self"
    ]
  },
  "SPARSE_TYPES": [],
  "CONSTRUCTOR_TYPES": [],
  "ESTIMATORS": [],
  "LP_ESTIMATORS": [],
  "test_fit_transduction": [
    "global_dtype",
    "Estimator",
    "parameters"
  ],
  "test_distribution": [
    "global_dtype",
    "Estimator",
    "parameters"
  ],
  "test_predict": [
    "global_dtype",
    "Estimator",
    "parameters"
  ],
  "test_predict_proba": [
    "global_dtype",
    "Estimator",
    "parameters"
  ],
  "test_label_spreading_closed_form": [
    "global_dtype",
    "Estimator",
    "parameters",
    "alpha"
  ],
  "test_label_propagation_closed_form": [
    "global_dtype"
  ],
  "test_sparse_input_types": [
    "accepted_sparse_type",
    "index_dtype",
    "dtype",
    "Estimator",
    "parameters"
  ],
  "test_label_propagation_build_graph_normalized": [
    "constructor",
    "Estimator",
    "parameters"
  ],
  "test_convergence_speed": [
    "constructor_type"
  ],
  "test_label_propagation_non_zero_normalizer": [
    "LabelPropagationCls"
  ],
  "test_predict_sparse_callable_kernel": [
    "global_dtype"
  ],
  "n_labeled_samples": [],
  "y_train_missing_labels": [],
  "mapping": [],
  "y_train_missing_strings": [],
  "test_warns_k_best": [],
  "test_classification": [
    "estimator",
    "selection_crit"
  ],
  "test_k_best": [],
  "test_sanity_classification": [],
  "test_none_iter": [],
  "test_zero_iterations": [
    "estimator",
    "y"
  ],
  "test_prefitted_throws_error": [],
  "test_labeled_iter": [
    "max_iter"
  ],
  "test_no_unlabeled": [],
  "test_strings_dtype": [],
  "test_verbose_k_best": [
    "capsys"
  ],
  "test_k_best_selects_best": [],
  "test_estimator_meta_estimator": [],
  "test_self_training_estimator_attribute_error": [],
  "_BaseVoting": {
    "_log_message": [
      "self",
      "name",
      "idx",
      "total"
    ],
    "_weights_not_none": [
      "self"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "n_features_in_": [
      "self"
    ],
    "_sk_visual_block_": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "VotingClassifier": {
    "__init__": [
      "self",
      "estimators"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_collect_probas": [
      "self",
      "X"
    ],
    "_check_voting": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "VotingRegressor": {
    "__init__": [
      "self",
      "estimators"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "_LOSSES": [],
  "_safe_divide": [
    "numerator",
    "denominator"
  ],
  "_init_raw_predictions": [
    "X",
    "estimator",
    "loss",
    "use_predict_proba"
  ],
  "_update_terminal_regions": [
    "loss",
    "tree",
    "X",
    "y",
    "neg_gradient",
    "raw_prediction",
    "sample_weight",
    "sample_mask",
    "learning_rate",
    "k"
  ],
  "set_huber_delta": [
    "loss",
    "y_true",
    "raw_prediction",
    "sample_weight"
  ],
  "VerboseReporter": {
    "__init__": [
      "self",
      "verbose"
    ],
    "init": [
      "self",
      "est",
      "begin_at_stage"
    ],
    "update": [
      "self",
      "j",
      "est"
    ]
  },
  "BaseGradientBoosting": {
    "__init__": [
      "self"
    ],
    "_encode_y": [
      "self",
      "y",
      "sample_weight"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ],
    "_fit_stage": [
      "self",
      "i",
      "X",
      "y",
      "raw_predictions",
      "sample_weight",
      "sample_mask",
      "random_state",
      "X_csc",
      "X_csr"
    ],
    "_set_max_features": [
      "self"
    ],
    "_init_state": [
      "self"
    ],
    "_clear_state": [
      "self"
    ],
    "_resize_state": [
      "self"
    ],
    "_is_fitted": [
      "self"
    ],
    "_check_initialized": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight",
      "monitor"
    ],
    "_fit_stages": [
      "self",
      "X",
      "y",
      "raw_predictions",
      "sample_weight",
      "random_state",
      "X_val",
      "y_val",
      "sample_weight_val",
      "begin_at_stage",
      "monitor"
    ],
    "_make_estimator": [
      "self",
      "append"
    ],
    "_raw_predict_init": [
      "self",
      "X"
    ],
    "_raw_predict": [
      "self",
      "X"
    ],
    "_staged_raw_predict": [
      "self",
      "X",
      "check_input"
    ],
    "feature_importances_": [
      "self"
    ],
    "_compute_partial_dependence_recursion": [
      "self",
      "grid",
      "target_features"
    ],
    "apply": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "GradientBoostingClassifier": {
    "__init__": [
      "self"
    ],
    "_encode_y": [
      "self",
      "y",
      "sample_weight"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "staged_decision_function": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "staged_predict_proba": [
      "self",
      "X"
    ]
  },
  "GradientBoostingRegressor": {
    "__init__": [
      "self"
    ],
    "_encode_y": [
      "self",
      "y",
      "sample_weight"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ],
    "apply": [
      "self",
      "X"
    ]
  },
  "BaseWeightBoosting": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_check_X": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_boost": [
      "self",
      "iboost",
      "X",
      "y",
      "sample_weight",
      "random_state"
    ],
    "staged_score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "feature_importances_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "AdaBoostClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_validate_estimator": [
      "self"
    ],
    "_boost": [
      "self",
      "iboost",
      "X",
      "y",
      "sample_weight",
      "random_state"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "staged_decision_function": [
      "self",
      "X"
    ],
    "_compute_proba_from_decision": [
      "decision",
      "n_classes"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "staged_predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ]
  },
  "AdaBoostRegressor": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_validate_estimator": [
      "self"
    ],
    "_boost": [
      "self",
      "iboost",
      "X",
      "y",
      "sample_weight",
      "random_state"
    ],
    "_get_median_predict": [
      "self",
      "X",
      "limit"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ]
  },
  "_parallel_compute_tree_depths": [
    "tree",
    "X",
    "features",
    "tree_decision_path_lengths",
    "tree_avg_path_lengths",
    "depths",
    "lock"
  ],
  "IsolationForest": {
    "__init__": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_parallel_args": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "_score_samples": [
      "self",
      "X"
    ],
    "_compute_chunked_score_samples": [
      "self",
      "X"
    ],
    "_compute_score_samples": [
      "self",
      "X",
      "subsample_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_average_path_length": [
    "n_samples_leaf"
  ],
  "_fit_single_estimator": [
    "estimator",
    "X",
    "y",
    "fit_params",
    "message_clsname",
    "message"
  ],
  "_set_random_states": [
    "estimator",
    "random_state"
  ],
  "BaseEnsemble": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_validate_estimator": [
      "self",
      "default"
    ],
    "_make_estimator": [
      "self",
      "append",
      "random_state"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__iter__": [
      "self"
    ]
  },
  "_partition_estimators": [
    "n_estimators",
    "n_jobs"
  ],
  "_BaseHeterogeneousEnsemble": {
    "named_estimators": [
      "self"
    ],
    "__init__": [
      "self",
      "estimators"
    ],
    "_validate_estimators": [
      "self"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_get_n_samples_bootstrap": [
    "n_samples",
    "max_samples",
    "sample_weight"
  ],
  "_generate_indices": [
    "random_state",
    "bootstrap",
    "n_population",
    "n_samples"
  ],
  "_generate_bagging_indices": [
    "random_state",
    "bootstrap_features",
    "bootstrap_samples",
    "n_features",
    "n_samples",
    "max_features",
    "max_samples",
    "sample_weight"
  ],
  "_consumes_sample_weight": [
    "estimator"
  ],
  "_parallel_build_estimators": [
    "n_estimators",
    "ensemble",
    "X",
    "y",
    "sample_weight",
    "seeds",
    "total_n_estimators",
    "verbose",
    "check_input",
    "fit_params"
  ],
  "_parallel_predict_proba": [
    "estimators",
    "estimators_features",
    "X",
    "n_classes",
    "predict_params",
    "predict_proba_params"
  ],
  "_parallel_predict_log_proba": [
    "estimators",
    "estimators_features",
    "X",
    "n_classes",
    "params"
  ],
  "_parallel_decision_function": [
    "estimators",
    "estimators_features",
    "X",
    "params"
  ],
  "_parallel_predict_regression": [
    "estimators",
    "estimators_features",
    "X",
    "params"
  ],
  "BaseBagging": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_parallel_args": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "max_samples",
      "max_depth",
      "check_input",
      "sample_weight"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_validate_y": [
      "self",
      "y"
    ],
    "_get_estimators_indices": [
      "self"
    ],
    "estimators_samples_": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_estimator": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "BaggingClassifier": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "_get_estimator": [
      "self"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_validate_y": [
      "self",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ]
  },
  "BaggingRegressor": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_set_oob_score": [
      "self",
      "X",
      "y"
    ],
    "_get_estimator": [
      "self"
    ]
  },
  "_generate_sample_indices": [
    "random_state",
    "n_samples",
    "n_samples_bootstrap"
  ],
  "_generate_unsampled_indices": [
    "random_state",
    "n_samples",
    "n_samples_bootstrap"
  ],
  "_parallel_build_trees": [
    "tree",
    "bootstrap",
    "X",
    "y",
    "sample_weight",
    "tree_idx",
    "n_trees",
    "verbose",
    "class_weight",
    "n_samples_bootstrap",
    "missing_values_in_feature_mask"
  ],
  "BaseForest": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "apply": [
      "self",
      "X"
    ],
    "decision_path": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y",
      "scoring_function"
    ],
    "_compute_oob_predictions": [
      "self",
      "X",
      "y"
    ],
    "_validate_y_class_weight": [
      "self",
      "y"
    ],
    "_validate_X_predict": [
      "self",
      "X"
    ],
    "feature_importances_": [
      "self"
    ],
    "_get_estimators_indices": [
      "self"
    ],
    "estimators_samples_": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_accumulate_prediction": [
    "predict",
    "X",
    "out",
    "lock"
  ],
  "ForestClassifier": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "_get_oob_predictions": [
      "tree",
      "X"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y",
      "scoring_function"
    ],
    "_validate_y_class_weight": [
      "self",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "ForestRegressor": {
    "__init__": [
      "self",
      "estimator",
      "n_estimators"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_get_oob_predictions": [
      "tree",
      "X"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y",
      "scoring_function"
    ],
    "_compute_partial_dependence_recursion": [
      "self",
      "grid",
      "target_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RandomForestClassifier": {
    "__init__": [
      "self",
      "n_estimators"
    ]
  },
  "RandomForestRegressor": {
    "__init__": [
      "self",
      "n_estimators"
    ]
  },
  "ExtraTreesClassifier": {
    "__init__": [
      "self",
      "n_estimators"
    ]
  },
  "ExtraTreesRegressor": {
    "__init__": [
      "self",
      "n_estimators"
    ]
  },
  "RandomTreesEmbedding": {
    "criterion": [],
    "max_features": [],
    "__init__": [
      "self",
      "n_estimators"
    ],
    "_set_oob_score_and_attributes": [
      "self",
      "X",
      "y",
      "scoring_function"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_BaseStacking": {
    "__init__": [
      "self",
      "estimators",
      "final_estimator"
    ],
    "_clone_final_estimator": [
      "self",
      "default"
    ],
    "_concatenate_predictions": [
      "self",
      "X",
      "predictions"
    ],
    "_method_name": [
      "name",
      "estimator",
      "method"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "n_features_in_": [
      "self"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_sk_visual_block_with_final_estimator": [
      "self",
      "final_estimator"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "StackingClassifier": {
    "__init__": [
      "self",
      "estimators",
      "final_estimator"
    ],
    "_validate_final_estimator": [
      "self"
    ],
    "_validate_estimators": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "StackingRegressor": {
    "__init__": [
      "self",
      "estimators",
      "final_estimator"
    ],
    "_validate_final_estimator": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "get_equivalent_estimator": [
    "estimator",
    "lib",
    "n_classes"
  ],
  "_find_binning_thresholds": [
    "col_data",
    "max_bins"
  ],
  "_BinMapper": {
    "__init__": [
      "self",
      "n_bins",
      "subsample",
      "is_categorical",
      "known_categories",
      "random_state",
      "n_threads"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "make_known_categories_bitsets": [
      "self"
    ]
  },
  "TreePredictor": {
    "__init__": [
      "self",
      "nodes",
      "binned_left_cat_bitsets",
      "raw_left_cat_bitsets"
    ],
    "get_n_leaf_nodes": [
      "self"
    ],
    "get_max_depth": [
      "self"
    ],
    "predict": [
      "self",
      "X",
      "known_cat_bitsets",
      "f_idx_map",
      "n_threads"
    ],
    "predict_binned": [
      "self",
      "X",
      "missing_values_bin_idx",
      "n_threads"
    ],
    "compute_partial_dependence": [
      "self",
      "grid",
      "target_features",
      "out"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "_update_leaves_values": [
    "loss",
    "grower",
    "y_true",
    "raw_prediction",
    "sample_weight"
  ],
  "_patch_raw_predict": [
    "estimator",
    "raw_predictions"
  ],
  "BaseHistGradientBoosting": {
    "__init__": [
      "self",
      "loss"
    ],
    "_validate_parameters": [
      "self"
    ],
    "_finalize_sample_weight": [
      "self",
      "sample_weight",
      "y"
    ],
    "_preprocess_X": [
      "self",
      "X"
    ],
    "_check_categories": [
      "self"
    ],
    "_check_categorical_features": [
      "self",
      "X"
    ],
    "_check_interaction_cst": [
      "self",
      "n_features"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_is_fitted": [
      "self"
    ],
    "_clear_state": [
      "self"
    ],
    "_get_small_trainset": [
      "self",
      "X_binned_train",
      "y_train",
      "sample_weight_train",
      "seed"
    ],
    "_check_early_stopping_scorer": [
      "self",
      "X_binned_small_train",
      "y_small_train",
      "sample_weight_small_train",
      "X_binned_val",
      "y_val",
      "sample_weight_val",
      "raw_predictions_small_train",
      "raw_predictions_val"
    ],
    "_score_with_raw_predictions": [
      "self",
      "X",
      "y",
      "sample_weight",
      "raw_predictions"
    ],
    "_check_early_stopping_loss": [
      "self",
      "raw_predictions",
      "y_train",
      "sample_weight_train",
      "raw_predictions_val",
      "y_val",
      "sample_weight_val",
      "n_threads"
    ],
    "_should_stop": [
      "self",
      "scores"
    ],
    "_bin_data": [
      "self",
      "X",
      "is_training_data"
    ],
    "_print_iteration_stats": [
      "self",
      "iteration_start_time"
    ],
    "_raw_predict": [
      "self",
      "X",
      "n_threads"
    ],
    "_predict_iterations": [
      "self",
      "X",
      "predictors",
      "raw_predictions",
      "is_binned",
      "n_threads"
    ],
    "_staged_raw_predict": [
      "self",
      "X"
    ],
    "_compute_partial_dependence_recursion": [
      "self",
      "grid",
      "target_features"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ],
    "_encode_y": [
      "self",
      "y"
    ],
    "_encode_y_val": [
      "self",
      "y"
    ],
    "n_iter_": [
      "self"
    ]
  },
  "HistGradientBoostingRegressor": {
    "__init__": [
      "self",
      "loss"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ],
    "_encode_y": [
      "self",
      "y"
    ],
    "_encode_y_val": [
      "self",
      "y"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ]
  },
  "HistGradientBoostingClassifier": {
    "__init__": [
      "self",
      "loss"
    ],
    "_finalize_sample_weight": [
      "self",
      "sample_weight",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "staged_predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "staged_predict_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "staged_decision_function": [
      "self",
      "X"
    ],
    "_encode_y": [
      "self",
      "y"
    ],
    "_encode_y_val": [
      "self",
      "y"
    ],
    "_get_loss": [
      "self",
      "sample_weight"
    ]
  },
  "TreeNode": {
    "__init__": [
      "self"
    ],
    "set_children_bounds": [
      "self",
      "lower",
      "upper"
    ],
    "__lt__": [
      "self",
      "other_node"
    ]
  },
  "TreeGrower": {
    "__init__": [
      "self",
      "X_binned",
      "gradients",
      "hessians",
      "max_leaf_nodes",
      "max_depth",
      "min_samples_leaf",
      "min_gain_to_split",
      "min_hessian_to_split",
      "n_bins",
      "n_bins_non_missing",
      "has_missing_values",
      "is_categorical",
      "monotonic_cst",
      "interaction_cst",
      "l2_regularization",
      "feature_fraction_per_split",
      "rng",
      "shrinkage",
      "n_threads"
    ],
    "_validate_parameters": [
      "self",
      "X_binned",
      "min_gain_to_split",
      "min_hessian_to_split"
    ],
    "grow": [
      "self"
    ],
    "_apply_shrinkage": [
      "self"
    ],
    "_initialize_root": [
      "self"
    ],
    "_compute_best_split_and_push": [
      "self",
      "node"
    ],
    "split_next": [
      "self"
    ],
    "_compute_interactions": [
      "self",
      "node"
    ],
    "_finalize_leaf": [
      "self",
      "node"
    ],
    "_finalize_splittable_nodes": [
      "self"
    ],
    "make_predictor": [
      "self",
      "binning_thresholds"
    ]
  },
  "_fill_predictor_arrays": [
    "predictor_nodes",
    "binned_left_cat_bitsets",
    "raw_left_cat_bitsets",
    "grower_node",
    "binning_thresholds",
    "n_bins_non_missing",
    "next_free_node_idx",
    "next_free_bitset_idx"
  ],
  "n_threads": [],
  "is_increasing": [
    "a"
  ],
  "is_decreasing": [
    "a"
  ],
  "assert_leaves_values_monotonic": [
    "predictor",
    "monotonic_cst"
  ],
  "assert_children_values_monotonic": [
    "predictor",
    "monotonic_cst"
  ],
  "assert_children_values_bounded": [
    "grower",
    "monotonic_cst"
  ],
  "test_nodes_values": [
    "monotonic_cst",
    "seed"
  ],
  "test_predictions": [
    "global_random_seed",
    "use_feature_names"
  ],
  "test_input_error": [],
  "test_input_error_related_to_feature_names": [],
  "test_bounded_value_min_gain_to_split": [],
  "_make_training_data": [
    "n_bins",
    "constant_hessian"
  ],
  "_check_children_consistency": [
    "parent",
    "left",
    "right"
  ],
  "test_grow_tree": [
    "n_bins",
    "constant_hessian",
    "stopping_param",
    "shrinkage"
  ],
  "test_predictor_from_grower": [],
  "test_min_samples_leaf_root": [
    "n_samples",
    "min_samples_leaf"
  ],
  "assert_is_stump": [
    "grower"
  ],
  "test_max_depth": [
    "max_depth"
  ],
  "test_init_parameters_validation": [],
  "test_missing_value_predict_only": [],
  "test_split_on_nan_with_infinite_values": [],
  "test_grow_tree_categories": [],
  "test_ohe_equivalence": [
    "min_samples_leaf",
    "n_unique_categories",
    "target"
  ],
  "test_grower_interaction_constraints": [],
  "test_regression_dataset": [
    "n_bins"
  ],
  "test_infinite_values_and_thresholds": [
    "num_threshold",
    "expected_predictions"
  ],
  "test_categorical_predictor": [
    "bins_go_left",
    "expected_predictions"
  ],
  "_assert_predictor_equal": [
    "gb_1",
    "gb_2",
    "X"
  ],
  "test_max_iter_with_warm_start_validation": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_warm_start_yields_identical_results": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_warm_start_max_depth": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_warm_start_early_stopping": [
    "GradientBoosting",
    "X",
    "y",
    "scoring"
  ],
  "test_warm_start_equal_n_estimators": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_warm_start_clear": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_random_seeds_warm_start": [
    "GradientBoosting",
    "X",
    "y",
    "rng_type"
  ],
  "test_build_histogram": [
    "build_func"
  ],
  "test_histogram_sample_order_independence": [],
  "test_unrolled_equivalent_to_naive": [
    "constant_hessian"
  ],
  "test_hist_subtraction": [
    "constant_hessian"
  ],
  "test_same_predictions_regression": [
    "seed",
    "loss",
    "min_samples_leaf",
    "n_samples",
    "max_leaf_nodes"
  ],
  "test_same_predictions_classification": [
    "seed",
    "min_samples_leaf",
    "n_samples",
    "max_leaf_nodes"
  ],
  "test_same_predictions_multiclass_classification": [
    "seed",
    "min_samples_leaf",
    "n_samples",
    "max_leaf_nodes"
  ],
  "test_set_get_bitset": [
    "values_to_insert",
    "expected_bitset"
  ],
  "test_raw_bitset_from_binned_bitset": [
    "raw_categories",
    "binned_cat_to_insert",
    "expected_raw_bitset"
  ],
  "_make_dumb_dataset": [
    "n_samples"
  ],
  "test_early_stopping_regression": [
    "scoring",
    "validation_fraction",
    "early_stopping",
    "n_iter_no_change",
    "tol"
  ],
  "test_early_stopping_classification": [
    "data",
    "scoring",
    "validation_fraction",
    "early_stopping",
    "n_iter_no_change",
    "tol"
  ],
  "test_early_stopping_default": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_should_stop": [
    "scores",
    "n_iter_no_change",
    "tol",
    "stopping"
  ],
  "test_absolute_error": [],
  "test_absolute_error_sample_weight": [],
  "test_gamma_y_positive": [
    "y"
  ],
  "test_gamma": [],
  "test_quantile_asymmetric_error": [
    "quantile"
  ],
  "test_poisson_y_positive": [
    "y"
  ],
  "test_poisson": [],
  "test_binning_train_validation_are_separated": [],
  "test_missing_values_trivial": [],
  "test_missing_values_resilience": [
    "problem",
    "missing_proportion",
    "expected_min_score_classification",
    "expected_min_score_regression"
  ],
  "test_zero_division_hessians": [
    "data"
  ],
  "test_small_trainset": [],
  "test_missing_values_minmax_imputation": [],
  "test_infinite_values": [],
  "test_consistent_lengths": [],
  "test_infinite_values_missing_values": [],
  "test_string_target_early_stopping": [
    "scoring"
  ],
  "test_zero_sample_weights_regression": [],
  "test_zero_sample_weights_classification": [],
  "test_sample_weight_effect": [
    "problem",
    "duplication"
  ],
  "test_sum_hessians_are_sample_weight": [
    "Loss"
  ],
  "test_max_depth_max_leaf_nodes": [],
  "test_early_stopping_on_test_set_with_warm_start": [],
  "test_early_stopping_with_sample_weights": [
    "monkeypatch"
  ],
  "test_raw_predict_is_called_with_custom_scorer": [],
  "test_single_node_trees": [
    "Est"
  ],
  "test_custom_loss": [
    "Est",
    "loss",
    "X",
    "y"
  ],
  "test_staged_predict": [
    "HistGradientBoosting",
    "X",
    "y"
  ],
  "test_unknown_categories_nan": [
    "insert_missing",
    "Est",
    "bool_categorical_parameter",
    "missing_value"
  ],
  "test_categorical_encoding_strategies": [],
  "test_categorical_spec_errors": [
    "Est",
    "categorical_features",
    "monotonic_cst",
    "expected_msg"
  ],
  "test_categorical_spec_errors_with_feature_names": [
    "Est"
  ],
  "test_categorical_spec_no_categories": [
    "Est",
    "categorical_features",
    "as_array"
  ],
  "test_categorical_bad_encoding_errors": [
    "Est",
    "use_pandas",
    "feature_name"
  ],
  "test_uint8_predict": [
    "Est"
  ],
  "test_check_interaction_cst": [
    "interaction_cst",
    "n_features",
    "result"
  ],
  "test_interaction_cst_numerically": [],
  "test_no_user_warning_with_scoring": [],
  "test_unknown_category_that_are_negative": [],
  "test_X_val_in_fit": [
    "GradientBoosting",
    "make_X_y",
    "sample_weight",
    "global_random_seed"
  ],
  "test_X_val_raises_missing_y_val": [],
  "test_X_val_raises_with_early_stopping_false": [],
  "test_dataframe_categorical_results_same_as_ndarray": [
    "dataframe_lib",
    "HistGradientBoosting"
  ],
  "test_dataframe_categorical_errors": [
    "dataframe_lib",
    "HistGradientBoosting"
  ],
  "test_categorical_different_order_same_model": [
    "dataframe_lib"
  ],
  "reduce_predictor_with_different_bitness": [
    "predictor"
  ],
  "test_pandas_nullable_dtype": [],
  "test_histogram_split": [
    "n_bins"
  ],
  "test_gradient_and_hessian_sanity": [
    "constant_hessian"
  ],
  "test_split_indices": [],
  "test_min_gain_to_split": [],
  "test_splitting_missing_values": [
    "X_binned",
    "all_gradients",
    "has_missing_values",
    "n_bins_non_missing",
    "expected_split_on_nan",
    "expected_bin_idx",
    "expected_go_to_left"
  ],
  "test_splitting_categorical_cat_smooth": [
    "X_binned",
    "has_missing_values",
    "n_bins_non_missing"
  ],
  "_assert_categories_equals_bitset": [
    "categories",
    "bitset"
  ],
  "test_splitting_categorical_sanity": [
    "X_binned",
    "all_gradients",
    "expected_categories_left",
    "n_bins_non_missing",
    "missing_values_bin_idx",
    "has_missing_values",
    "expected_missing_go_to_left"
  ],
  "test_split_interaction_constraints": [],
  "test_split_feature_fraction_per_split": [
    "forbidden_features"
  ],
  "DATA": [],
  "test_find_binning_thresholds_regular_data": [],
  "test_find_binning_thresholds_small_regular_data": [],
  "test_find_binning_thresholds_random_data": [],
  "test_find_binning_thresholds_low_n_bins": [],
  "test_invalid_n_bins": [
    "n_bins"
  ],
  "test_bin_mapper_n_features_transform": [],
  "test_map_to_bins": [
    "max_bins"
  ],
  "test_bin_mapper_random_data": [
    "max_bins"
  ],
  "test_bin_mapper_small_random_data": [
    "n_samples",
    "max_bins"
  ],
  "test_bin_mapper_identity_repeated_values": [
    "max_bins",
    "n_distinct",
    "multiplier"
  ],
  "test_bin_mapper_repeated_values_invariance": [
    "n_distinct"
  ],
  "test_bin_mapper_identity_small": [
    "max_bins",
    "scale",
    "offset"
  ],
  "test_bin_mapper_idempotence": [
    "max_bins_small",
    "max_bins_large"
  ],
  "test_n_bins_non_missing": [
    "n_bins",
    "diff"
  ],
  "test_subsample": [],
  "test_missing_values_support": [
    "n_bins",
    "n_bins_non_missing",
    "X_trans_expected"
  ],
  "test_categorical_feature": [
    "n_bins"
  ],
  "test_categorical_feature_negative_missing": [],
  "test_categorical_with_numerical_features": [
    "n_bins"
  ],
  "test_make_known_categories_bitsets": [],
  "test_categorical_parameters": [
    "is_categorical",
    "known_categories",
    "match"
  ],
  "hastie_X": [],
  "DEFAULT_JOBLIB_BACKEND": [],
  "FOREST_CLASSIFIERS": [],
  "FOREST_REGRESSORS": [],
  "FOREST_TRANSFORMERS": [],
  "test_iris_criterion": [
    "name",
    "criterion"
  ],
  "test_regression_criterion": [
    "name",
    "criterion"
  ],
  "test_balance_property_random_forest": [
    "criterion"
  ],
  "test_regressor_attributes": [
    "name"
  ],
  "test_importances_asymptotic": [],
  "test_unfitted_feature_importances": [
    "name"
  ],
  "test_forest_classifier_oob": [
    "ForestClassifier",
    "X",
    "y",
    "X_type",
    "lower_bound_accuracy",
    "oob_score"
  ],
  "test_forest_regressor_oob": [
    "ForestRegressor",
    "X",
    "y",
    "X_type",
    "lower_bound_r2",
    "oob_score"
  ],
  "test_forest_oob_warning": [
    "ForestEstimator"
  ],
  "test_forest_oob_score_requires_bootstrap": [
    "ForestEstimator"
  ],
  "test_classifier_error_oob_score_multiclass_multioutput": [
    "ForestClassifier"
  ],
  "test_forest_multioutput_integral_regression_target": [
    "ForestRegressor"
  ],
  "test_random_trees_embedding_raise_error_oob": [
    "oob_score"
  ],
  "test_parallel": [
    "name"
  ],
  "test_multioutput_string": [
    "name"
  ],
  "test_random_trees_dense_type": [],
  "test_random_trees_dense_equal": [],
  "test_random_hasher": [],
  "test_random_hasher_sparse_data": [
    "csc_container"
  ],
  "test_parallel_train": [],
  "test_min_weight_fraction_leaf": [
    "name"
  ],
  "test_class_weight_balanced_and_bootstrap_multi_output": [
    "name"
  ],
  "test_warm_start_smaller_n_estimators": [
    "name"
  ],
  "test_warm_start_oob": [
    "name"
  ],
  "test_oob_not_computed_twice": [
    "name"
  ],
  "test_dtype_convert": [
    "n_classes"
  ],
  "test_poisson_y_positive_check": [],
  "MyBackend": {
    "__init__": [
      "self"
    ],
    "start_call": [
      "self"
    ]
  },
  "test_backend_respected": [],
  "test_forest_feature_importances_sum": [],
  "test_forest_degenerate_feature_importances": [],
  "test_max_samples_bootstrap": [
    "name"
  ],
  "test_large_max_samples_exception": [
    "name"
  ],
  "test_max_samples_boundary_regressors": [
    "name"
  ],
  "test_max_samples_boundary_classifiers": [
    "name"
  ],
  "test_forest_y_sparse": [
    "csr_container"
  ],
  "test_little_tree_with_small_max_samples": [
    "ForestClass"
  ],
  "test_mse_criterion_object_segfault_smoke_test": [
    "Forest"
  ],
  "test_random_trees_embedding_feature_names_out": [],
  "test_read_only_buffer": [
    "csr_container",
    "monkeypatch"
  ],
  "test_round_samples_to_one_when_samples_too_low": [
    "class_weight"
  ],
  "test_estimators_samples": [
    "ForestClass",
    "bootstrap",
    "seed"
  ],
  "test_missing_values_is_resilient": [
    "make_data",
    "Forest"
  ],
  "test_non_supported_criterion_raises_error_with_missing_values": [
    "Forest"
  ],
  "test_ensemble_heterogeneous_estimators_behavior": [
    "X",
    "y",
    "estimator"
  ],
  "test_ensemble_heterogeneous_estimators_type": [
    "Ensemble"
  ],
  "test_ensemble_heterogeneous_estimators_name_validation": [
    "X",
    "y",
    "Ensemble"
  ],
  "test_ensemble_heterogeneous_estimators_all_dropped": [
    "X",
    "y",
    "estimator"
  ],
  "test_heterogeneous_ensemble_support_missing_values": [
    "Ensemble",
    "Estimator",
    "X",
    "y"
  ],
  "X_scaled": [],
  "test_voting_classifier_estimator_init": [
    "params",
    "err_msg"
  ],
  "test_predictproba_hardvoting": [],
  "test_notfitted": [],
  "test_majority_label_iris": [
    "global_random_seed"
  ],
  "test_tie_situation": [],
  "test_weights_iris": [
    "global_random_seed"
  ],
  "test_weights_regressor": [],
  "test_predict_on_toy_problem": [
    "global_random_seed"
  ],
  "test_predict_proba_on_toy_problem": [],
  "test_multilabel": [],
  "test_parallel_fit": [
    "global_random_seed"
  ],
  "test_sample_weight_kwargs": [],
  "test_voting_classifier_set_params": [
    "global_random_seed"
  ],
  "test_set_estimator_drop": [],
  "test_estimator_weights_format": [
    "global_random_seed"
  ],
  "test_none_estimator_with_weights": [
    "X",
    "y",
    "voter"
  ],
  "test_voting_verbose": [
    "estimator",
    "capsys"
  ],
  "test_get_features_names_out_regressor": [],
  "test_get_features_names_out_classifier": [
    "kwargs",
    "expected_names"
  ],
  "test_get_features_names_out_classifier_error": [],
  "test_get_metadata_routing_without_fit": [
    "Estimator",
    "Child"
  ],
  "test_metadata_routing_for_voting_estimators": [
    "Estimator",
    "Child",
    "prop"
  ],
  "test_metadata_routing_error_for_voting_estimators": [
    "Estimator",
    "Child"
  ],
  "test_sparse_classification": [
    "sparse_container",
    "params",
    "method"
  ],
  "test_regression": [],
  "test_sparse_regression": [
    "sparse_container"
  ],
  "DummySizeEstimator": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_bootstrap_samples": [],
  "test_bootstrap_features": [],
  "test_oob_score_classification": [],
  "test_oob_score_regression": [],
  "test_single_estimator": [],
  "test_parallel_classification": [],
  "test_parallel_regression": [],
  "test_bagging_with_pipeline": [],
  "test_warm_start_equivalence": [],
  "test_warm_start_with_oob_score_fails": [],
  "test_warning_bootstrap_sample_weight": [],
  "test_invalid_sample_weight_max_samples_bootstrap_combinations": [],
  "EstimatorAcceptingSampleWeight": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "EstimatorRejectingSampleWeight": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_draw_indices_using_sample_weight": [
    "bagging_class",
    "accept_sample_weight",
    "metadata_routing",
    "max_samples"
  ],
  "test_get_n_samples_bootstrap": [],
  "test_oob_score_removed_on_warm_start": [],
  "test_oob_score_consistency": [],
  "test_estimators_samples_deterministic": [],
  "test_max_samples_consistency": [],
  "test_set_oob_score_label_encoding": [],
  "replace": [
    "X"
  ],
  "test_bagging_regressor_with_missing_inputs": [],
  "test_bagging_classifier_with_missing_inputs": [],
  "test_bagging_small_max_features": [],
  "test_bagging_get_estimators_indices": [
    "global_random_seed"
  ],
  "test_bagging_allow_nan_tag": [
    "bagging",
    "expected_allow_nan"
  ],
  "test_bagging_with_metadata_routing": [
    "model"
  ],
  "test_metadata_routing_with_dynamic_method_selection": [
    "sub_estimator",
    "caller",
    "callee"
  ],
  "test_bagging_without_support_metadata_routing": [
    "model"
  ],
  "test_iforest": [
    "global_random_seed"
  ],
  "test_iforest_sparse": [
    "global_random_seed",
    "sparse_container"
  ],
  "test_iforest_error": [],
  "test_recalculate_max_depth": [],
  "test_max_samples_attribute": [],
  "test_iforest_parallel_regression": [
    "global_random_seed"
  ],
  "test_iforest_performance": [
    "global_random_seed"
  ],
  "test_iforest_works": [
    "contamination",
    "global_random_seed"
  ],
  "test_iforest_subsampled_features": [],
  "test_iforest_average_path_length": [],
  "test_iforest_warm_start": [],
  "test_iforest_chunks_works1": [
    "mocked_get_chunk",
    "contamination",
    "n_predict_calls",
    "global_random_seed"
  ],
  "test_iforest_chunks_works2": [
    "mocked_get_chunk",
    "contamination",
    "n_predict_calls",
    "global_random_seed"
  ],
  "test_iforest_with_uniform_data": [],
  "test_iforest_with_n_jobs_does_not_segfault": [
    "csc_container"
  ],
  "test_iforest_preserve_feature_names": [],
  "test_iforest_sparse_input_float_contamination": [
    "sparse_container"
  ],
  "test_iforest_predict_parallel": [
    "global_random_seed",
    "contamination",
    "n_jobs"
  ],
  "test_stacking_classifier_iris": [
    "cv",
    "final_estimator",
    "passthrough"
  ],
  "test_stacking_classifier_drop_column_binary_classification": [],
  "test_stacking_classifier_drop_estimator": [],
  "test_stacking_regressor_drop_estimator": [],
  "test_stacking_regressor_diabetes": [
    "cv",
    "final_estimator",
    "predict_params",
    "passthrough"
  ],
  "test_stacking_regressor_sparse_passthrough": [
    "sparse_container"
  ],
  "test_stacking_classifier_sparse_passthrough": [
    "sparse_container"
  ],
  "test_stacking_classifier_drop_binary_prob": [],
  "NoWeightRegressor": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "NoWeightClassifier": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_stacking_classifier_error": [
    "y",
    "params",
    "type_err",
    "msg_err"
  ],
  "test_stacking_regressor_error": [
    "y",
    "params",
    "type_err",
    "msg_err"
  ],
  "test_stacking_randomness": [
    "estimator",
    "X",
    "y"
  ],
  "test_stacking_classifier_stratify_default": [],
  "test_stacking_with_sample_weight": [
    "stacker",
    "X",
    "y"
  ],
  "test_stacking_classifier_sample_weight_fit_param": [],
  "test_stacking_cv_influence": [
    "stacker",
    "X",
    "y"
  ],
  "test_stacking_prefit": [
    "Stacker",
    "Estimator",
    "stack_method",
    "final_estimator",
    "X",
    "y"
  ],
  "test_stacking_prefit_error": [
    "stacker",
    "X",
    "y"
  ],
  "test_stacking_without_n_features_in": [
    "make_dataset",
    "Stacking",
    "Estimator"
  ],
  "test_stacking_classifier_multilabel_predict_proba": [
    "estimator"
  ],
  "test_stacking_classifier_multilabel_decision_function": [],
  "test_stacking_classifier_multilabel_auto_predict": [
    "stack_method",
    "passthrough"
  ],
  "test_stacking_classifier_base_regressor": [],
  "test_stacking_final_estimator_attribute_error": [],
  "test_metadata_routing_for_stacking_estimators": [
    "Estimator",
    "Child",
    "prop",
    "prop_value"
  ],
  "test_metadata_routing_error_for_stacking_estimators": [
    "Estimator",
    "Child"
  ],
  "GRADIENT_BOOSTING_ESTIMATORS": [],
  "test_exponential_n_classes_gt_2": [],
  "test_raise_if_init_has_no_predict_proba": [],
  "test_classification_synthetic": [
    "loss",
    "global_random_seed"
  ],
  "test_regression_synthetic": [
    "global_random_seed"
  ],
  "test_feature_importances": [
    "GradientBoosting",
    "X",
    "y"
  ],
  "test_probability_log": [
    "global_random_seed"
  ],
  "test_single_class_with_sample_weight": [],
  "test_check_inputs_predict_stages": [
    "csc_container"
  ],
  "test_max_feature_regression": [
    "global_random_seed"
  ],
  "test_feature_importance_regression": [
    "fetch_california_housing_fxt",
    "global_random_seed"
  ],
  "test_staged_predict_proba": [],
  "test_staged_functions_defensive": [
    "Estimator",
    "global_random_seed"
  ],
  "test_serialization": [],
  "test_degenerate_targets": [],
  "test_quantile_loss": [
    "global_random_seed"
  ],
  "test_symbol_labels": [],
  "test_float_class_labels": [],
  "test_shape_y": [],
  "test_mem_layout": [],
  "test_oob_improvement": [
    "GradientBoostingEstimator"
  ],
  "test_oob_scores": [
    "GradientBoostingEstimator"
  ],
  "test_oob_attributes_error": [
    "GradientBoostingEstimator",
    "oob_attribute"
  ],
  "test_oob_multilcass_iris": [],
  "test_verbose_output": [],
  "test_more_verbose_output": [],
  "test_warm_start_n_estimators": [
    "Cls",
    "global_random_seed"
  ],
  "test_warm_start_state_oob_scores": [
    "GradientBoosting"
  ],
  "test_warm_start_oob_switch": [
    "Cls"
  ],
  "test_warm_start_sparse": [
    "Cls",
    "sparse_container"
  ],
  "test_warm_start_fortran": [
    "Cls",
    "global_random_seed"
  ],
  "early_stopping_monitor": [
    "i",
    "est",
    "locals"
  ],
  "test_monitor_early_stopping": [
    "Cls"
  ],
  "test_complete_classification": [],
  "test_complete_regression": [],
  "test_zero_estimator_reg": [
    "global_random_seed"
  ],
  "test_zero_estimator_clf": [
    "global_random_seed"
  ],
  "test_warm_start_wo_nestimators_change": [],
  "test_non_uniform_weights_toy_edge_case_reg": [
    "loss",
    "value"
  ],
  "test_non_uniform_weights_toy_edge_case_clf": [],
  "test_gradient_boosting_early_stopping": [
    "GradientBoostingEstimator"
  ],
  "test_gradient_boosting_without_early_stopping": [],
  "test_gradient_boosting_validation_fraction": [],
  "_make_multiclass": [],
  "test_gradient_boosting_with_init": [
    "gb",
    "dataset_maker",
    "init_estimator",
    "global_random_seed"
  ],
  "test_gradient_boosting_with_init_pipeline": [],
  "test_early_stopping_n_classes": [],
  "test_gbr_degenerate_feature_importances": [],
  "test_huber_vs_mean_and_median": [],
  "test_safe_divide": [],
  "test_squared_error_exact_backward_compat": [],
  "test_huber_exact_backward_compat": [],
  "test_binomial_error_exact_backward_compat": [],
  "test_multinomial_error_exact_backward_compat": [],
  "test_gb_denominator_zero": [
    "global_random_seed"
  ],
  "y_class": [],
  "y_regr": [],
  "y_t_class": [],
  "y_t_regr": [],
  "test_oneclass_adaboost_proba": [],
  "test_diabetes": [
    "loss"
  ],
  "test_adaboost_classifier_sample_weight_error": [],
  "test_sample_weights_infinite": [],
  "test_sample_weight_adaboost_regressor": [],
  "test_multidimensional_X": [],
  "test_adaboostclassifier_without_sample_weight": [],
  "test_adaboostregressor_sample_weight": [],
  "test_adaboost_consistent_predict": [],
  "test_adaboost_negative_weight_error": [
    "model",
    "X",
    "y"
  ],
  "test_adaboost_numerically_stable_feature_importance_with_small_weights": [],
  "test_adaboost_decision_function": [
    "global_random_seed"
  ],
  "test_base": [],
  "test_set_random_states": [],
  "LocalOutlierFactor": {
    "__init__": [
      "self",
      "n_neighbors"
    ],
    "_check_novelty_fit_predict": [
      "self"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_check_novelty_predict": [
      "self"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "_check_novelty_decision_function": [
      "self"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "_check_novelty_score_samples": [
      "self"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "_local_reachability_density": [
      "self",
      "distances_X",
      "neighbors_indices"
    ]
  },
  "VALID_KERNELS": [],
  "TREE_DICT": [],
  "KernelDensity": {
    "__init__": [
      "self"
    ],
    "_choose_algorithm": [
      "self",
      "algorithm",
      "metric"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "sample": [
      "self",
      "n_samples",
      "random_state"
    ]
  },
  "NearestCentroid": {
    "__init__": [
      "self",
      "metric"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_decision_function": [
      "self",
      "X"
    ],
    "_check_euclidean_metric": [
      "self"
    ],
    "decision_function": [],
    "predict_proba": [],
    "predict_log_proba": [],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SCIPY_METRICS": [],
  "VALID_METRICS": [],
  "VALID_METRICS_SPARSE": [],
  "_get_weights": [
    "dist",
    "weights"
  ],
  "_is_sorted_by_data": [
    "graph"
  ],
  "_check_precomputed": [
    "X"
  ],
  "sort_graph_by_row_values": [
    "graph",
    "copy",
    "warn_when_not_sorted"
  ],
  "_kneighbors_from_graph": [
    "graph",
    "n_neighbors",
    "return_distance"
  ],
  "_radius_neighbors_from_graph": [
    "graph",
    "radius",
    "return_distance"
  ],
  "NeighborsBase": {
    "__init__": [
      "self",
      "n_neighbors",
      "radius",
      "algorithm",
      "leaf_size",
      "metric",
      "p",
      "metric_params",
      "n_jobs"
    ],
    "_check_algorithm_metric": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KNeighborsMixin": {
    "_kneighbors_reduce_func": [
      "self",
      "dist",
      "start",
      "n_neighbors",
      "return_distance"
    ],
    "kneighbors": [
      "self",
      "X",
      "n_neighbors",
      "return_distance"
    ],
    "kneighbors_graph": [
      "self",
      "X",
      "n_neighbors",
      "mode"
    ]
  },
  "RadiusNeighborsMixin": {
    "_radius_neighbors_reduce_func": [
      "self",
      "dist",
      "start",
      "radius",
      "return_distance"
    ],
    "radius_neighbors": [
      "self",
      "X",
      "radius",
      "return_distance",
      "sort_results"
    ],
    "radius_neighbors_graph": [
      "self",
      "X",
      "radius",
      "mode",
      "sort_results"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KNeighborsRegressor": {
    "__init__": [
      "self",
      "n_neighbors"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "RadiusNeighborsRegressor": {
    "__init__": [
      "self",
      "radius"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "_adjusted_metric": [
    "metric",
    "metric_kwargs",
    "p"
  ],
  "KNeighborsClassifier": {
    "__init__": [
      "self",
      "n_neighbors"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "RadiusNeighborsClassifier": {
    "__init__": [
      "self",
      "radius"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "NeighborhoodComponentsAnalysis": {
    "__init__": [
      "self",
      "n_components"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_initialize": [
      "self",
      "X",
      "y",
      "init"
    ],
    "_callback": [
      "self",
      "transformation"
    ],
    "_loss_grad_lbfgs": [
      "self",
      "transformation",
      "X",
      "same_class_mask",
      "sign"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_n_features_out": [
      "self"
    ]
  },
  "NearestNeighbors": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_check_params": [
    "X",
    "metric",
    "p",
    "metric_params"
  ],
  "_query_include_self": [
    "X",
    "include_self",
    "mode"
  ],
  "kneighbors_graph": [
    "X",
    "n_neighbors"
  ],
  "radius_neighbors_graph": [
    "X",
    "radius"
  ],
  "KNeighborsTransformer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "RadiusNeighborsTransformer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ]
  },
  "true_result_prior1": [],
  "true_discriminant_scores": [],
  "true_proba": [],
  "test_iris_shrinkage": [],
  "test_shrinkage_correct": [],
  "test_shrinkage_threshold_decoded_y": [],
  "test_predict_translated_data": [],
  "test_manhattan_metric": [
    "csr_container"
  ],
  "test_features_zero_var": [],
  "test_negative_priors_error": [],
  "test_warn_non_normalized_priors": [],
  "test_method_not_available_with_manhattan": [
    "response_method"
  ],
  "test_error_zero_variances": [
    "array_constructor"
  ],
  "test_quadtree_boundary_computation": [],
  "test_quadtree_similar_point": [],
  "test_quad_tree_pickle": [
    "n_dimensions",
    "protocol"
  ],
  "test_qt_insert_duplicate": [
    "n_dimensions"
  ],
  "test_summarize": [],
  "SPARSE_OR_DENSE": [],
  "ALGORITHMS": [],
  "COMMON_VALID_METRICS": [],
  "P": [],
  "DISTANCE_METRIC_OBJS": [],
  "_parse_metric": [
    "metric",
    "dtype"
  ],
  "_generate_test_params_for": [
    "metric",
    "n_features"
  ],
  "_weight_func": [
    "dist"
  ],
  "WEIGHTS": [],
  "test_unsupervised_kneighbors": [
    "global_dtype",
    "n_samples",
    "n_features",
    "n_query_pts",
    "n_neighbors",
    "query_is_train",
    "metric"
  ],
  "test_neigh_predictions_algorithm_agnosticity": [
    "global_dtype",
    "n_samples",
    "n_features",
    "n_query_pts",
    "metric",
    "n_neighbors",
    "radius",
    "NeighborsMixinSubclass"
  ],
  "test_unsupervised_inputs": [
    "global_dtype",
    "KNeighborsMixinSubclass"
  ],
  "test_not_fitted_error_gets_raised": [],
  "check_precomputed": [
    "make_train_test",
    "estimators"
  ],
  "test_precomputed_dense": [],
  "test_precomputed_sparse_knn": [
    "fmt"
  ],
  "test_precomputed_sparse_radius": [
    "fmt"
  ],
  "test_is_sorted_by_data": [
    "csr_container"
  ],
  "test_sort_graph_by_row_values": [
    "function",
    "csr_container"
  ],
  "test_sort_graph_by_row_values_copy": [
    "csr_container"
  ],
  "test_sort_graph_by_row_values_warning": [
    "csr_container"
  ],
  "test_sort_graph_by_row_values_bad_sparse_format": [
    "sparse_container"
  ],
  "test_precomputed_sparse_invalid": [
    "csr_container"
  ],
  "test_precomputed_cross_validation": [],
  "test_unsupervised_radius_neighbors": [
    "global_dtype",
    "n_samples",
    "n_features",
    "n_query_pts",
    "radius",
    "random_state"
  ],
  "test_kneighbors_classifier": [
    "global_dtype",
    "algorithm",
    "weights",
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_kneighbors_classifier_float_labels": [
    "global_dtype",
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_kneighbors_classifier_predict_proba": [
    "global_dtype"
  ],
  "test_radius_neighbors_classifier": [
    "global_dtype",
    "algorithm",
    "weights",
    "n_samples",
    "n_features",
    "n_test_pts",
    "radius",
    "random_state"
  ],
  "test_radius_neighbors_classifier_when_no_neighbors": [
    "global_dtype",
    "algorithm",
    "weights",
    "outlier_label"
  ],
  "test_radius_neighbors_classifier_outlier_labeling": [
    "global_dtype",
    "algorithm",
    "weights"
  ],
  "test_radius_neighbors_classifier_zero_distance": [],
  "test_neighbors_regressors_zero_distance": [],
  "test_radius_neighbors_boundary_handling": [],
  "test_radius_neighbors_returns_array_of_objects": [
    "csr_container"
  ],
  "test_query_equidistant_kth_nn": [
    "algorithm"
  ],
  "test_radius_neighbors_sort_results": [
    "algorithm",
    "metric"
  ],
  "test_RadiusNeighborsClassifier_multioutput": [],
  "test_kneighbors_classifier_sparse": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_KNeighborsClassifier_multioutput": [],
  "test_kneighbors_regressor": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_KNeighborsRegressor_multioutput_uniform_weight": [],
  "test_kneighbors_regressor_multioutput": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_radius_neighbors_regressor": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "radius",
    "random_state"
  ],
  "test_RadiusNeighborsRegressor_multioutput_with_uniform_weight": [],
  "test_RadiusNeighborsRegressor_multioutput": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "random_state"
  ],
  "test_kneighbors_regressor_sparse": [
    "n_samples",
    "n_features",
    "n_test_pts",
    "n_neighbors",
    "random_state"
  ],
  "test_neighbors_iris": [],
  "test_neighbors_digits": [],
  "test_kneighbors_graph": [],
  "test_kneighbors_graph_sparse": [
    "n_neighbors",
    "mode",
    "csr_container",
    "seed"
  ],
  "test_radius_neighbors_graph": [],
  "test_radius_neighbors_graph_sparse": [
    "n_neighbors",
    "mode",
    "csr_container",
    "seed"
  ],
  "test_neighbors_validate_parameters": [
    "Estimator",
    "csr_container"
  ],
  "test_neighbors_minkowski_semimetric_algo_warn": [
    "Estimator",
    "n_features",
    "algorithm"
  ],
  "test_neighbors_minkowski_semimetric_algo_error": [
    "Estimator",
    "n_features",
    "algorithm"
  ],
  "test_nearest_neighbors_validate_params": [],
  "test_neighbors_metrics": [
    "global_dtype",
    "global_random_seed",
    "metric",
    "n_samples",
    "n_features",
    "n_query_pts",
    "n_neighbors"
  ],
  "test_kneighbors_brute_backend": [
    "metric",
    "global_dtype",
    "global_random_seed",
    "n_samples",
    "n_features",
    "n_query_pts",
    "n_neighbors"
  ],
  "test_callable_metric": [],
  "test_valid_brute_metric_for_auto_algorithm": [
    "global_dtype",
    "metric",
    "csr_container",
    "n_samples",
    "n_features"
  ],
  "test_metric_params_interface": [],
  "test_predict_sparse_ball_kd_tree": [
    "csr_container"
  ],
  "test_non_euclidean_kneighbors": [],
  "check_object_arrays": [
    "nparray",
    "list_check"
  ],
  "test_k_and_radius_neighbors_train_is_not_query": [],
  "test_k_and_radius_neighbors_X_None": [
    "algorithm"
  ],
  "test_k_and_radius_neighbors_duplicates": [
    "algorithm"
  ],
  "test_include_self_neighbors_graph": [],
  "test_same_knn_parallel": [
    "algorithm"
  ],
  "test_same_radius_neighbors_parallel": [
    "algorithm"
  ],
  "test_knn_forcing_backend": [
    "backend",
    "algorithm"
  ],
  "test_sparse_metric_callable": [
    "csr_container"
  ],
  "test_radius_neighbors_predict_proba": [],
  "test_auto_algorithm": [
    "X",
    "metric",
    "metric_params",
    "expected_algo"
  ],
  "test_radius_neighbors_brute_backend": [
    "metric",
    "global_random_seed",
    "global_dtype",
    "n_samples",
    "n_features",
    "n_query_pts",
    "radius"
  ],
  "test_valid_metrics_has_no_duplicate": [],
  "test_regressor_predict_on_arraylikes": [],
  "test_predict_dataframe": [],
  "test_nearest_neighbours_works_with_p_less_than_1": [],
  "test_KNeighborsClassifier_raise_on_all_zero_weights": [],
  "test_neighbor_classifiers_loocv": [
    "nn_model",
    "algorithm"
  ],
  "test_neighbor_regressors_loocv": [
    "nn_model",
    "algorithm"
  ],
  "test_lof": [
    "global_dtype"
  ],
  "test_lof_performance": [
    "global_dtype"
  ],
  "test_lof_values": [
    "global_dtype"
  ],
  "test_lof_precomputed": [
    "global_dtype",
    "random_state"
  ],
  "test_n_neighbors_attribute": [],
  "test_novelty_errors": [],
  "test_novelty_training_scores": [
    "global_dtype"
  ],
  "test_hasattr_prediction": [],
  "test_novelty_true_common_tests": [
    "estimator",
    "check"
  ],
  "test_predicted_outlier_number": [
    "expected_outliers"
  ],
  "test_sparse": [
    "csr_container"
  ],
  "test_lof_error_n_neighbors_too_large": [],
  "test_lof_input_dtype_preservation": [
    "global_dtype",
    "algorithm",
    "contamination",
    "novelty"
  ],
  "test_lof_dtype_equivalence": [
    "algorithm",
    "novelty",
    "contamination"
  ],
  "test_lof_duplicate_samples": [],
  "V_mahalanobis": [],
  "DIMENSION": [],
  "METRICS": [],
  "DISCRETE_METRICS": [],
  "BOOLEAN_METRICS": [],
  "BALL_TREE_CLASSES": [],
  "brute_force_neighbors": [
    "X",
    "Y",
    "k",
    "metric"
  ],
  "test_BallTree_is_BallTree64_subclass": [],
  "test_ball_tree_query_metrics": [
    "metric",
    "array_type",
    "BallTreeImplementation"
  ],
  "test_query_haversine": [
    "BallTreeImplementation",
    "decimal_tol"
  ],
  "test_array_object_type": [
    "BallTreeImplementation"
  ],
  "test_bad_pyfunc_metric": [
    "BallTreeImplementation"
  ],
  "test_ball_tree_numerical_consistency": [
    "global_random_seed",
    "metric"
  ],
  "test_kernel_density_numerical_consistency": [
    "global_random_seed",
    "metric"
  ],
  "test_two_point_correlation_numerical_consistency": [
    "global_random_seed"
  ],
  "get_dataset_for_binary_tree": [
    "random_seed",
    "features"
  ],
  "test_spectral_clustering": [],
  "test_spectral_embedding": [],
  "test_dbscan": [],
  "test_isomap": [],
  "test_tsne": [],
  "test_lof_novelty_false": [],
  "test_lof_novelty_true": [],
  "KD_TREE_METRICS": [],
  "BALL_TREE_METRICS": [],
  "compute_kernel_slow": [
    "Y",
    "X",
    "kernel",
    "h"
  ],
  "test_kernel_density": [
    "Cls",
    "kernel",
    "h",
    "rtol",
    "atol",
    "breadth_first",
    "n_samples",
    "n_features"
  ],
  "test_neighbor_tree_query_radius": [
    "Cls",
    "n_samples",
    "n_features"
  ],
  "test_neighbor_tree_query_radius_distance": [
    "Cls",
    "n_samples",
    "n_features"
  ],
  "test_neighbor_tree_two_point": [
    "Cls",
    "dualtree",
    "n_samples",
    "n_features"
  ],
  "test_neighbors_heap": [
    "NeighborsHeap",
    "n_pts",
    "n_nbrs"
  ],
  "test_node_heap": [
    "nodeheap_sort",
    "n_nodes"
  ],
  "test_simultaneous_sort": [
    "simultaneous_sort",
    "n_rows",
    "n_pts"
  ],
  "test_gaussian_kde": [
    "Cls",
    "n_samples"
  ],
  "test_nn_tree_query": [
    "Cls",
    "metric",
    "k",
    "dualtree",
    "breadth_first"
  ],
  "KD_TREE_CLASSES": [],
  "test_KDTree_is_KDTree64_subclass": [],
  "test_kdtree_picklable_with_joblib": [
    "BinarySearchTree"
  ],
  "test_kd_tree_numerical_consistency": [
    "global_random_seed",
    "metric"
  ],
  "iris_target": [],
  "test_simple_example": [],
  "test_toy_example_collapse_points": [],
  "test_finite_differences": [
    "global_random_seed"
  ],
  "test_params_validation": [],
  "test_transformation_dimensions": [],
  "test_n_components": [],
  "test_init_transformation": [],
  "test_auto_init": [
    "n_samples",
    "n_features",
    "n_classes",
    "n_components"
  ],
  "test_warm_start_validation": [],
  "test_warm_start_effectiveness": [],
  "test_no_verbose": [
    "capsys"
  ],
  "test_singleton_class": [],
  "test_one_class": [],
  "test_callback": [
    "capsys"
  ],
  "test_expected_transformation_shape": [],
  "test_parameters_valid_types": [
    "param",
    "value"
  ],
  "test_nca_feature_names_out": [
    "n_components"
  ],
  "check_results": [
    "kernel",
    "bandwidth",
    "atol",
    "rtol",
    "X",
    "Y",
    "dens_true"
  ],
  "test_kernel_density_sampling": [
    "n_samples",
    "n_features"
  ],
  "test_kde_algorithm_metric_choice": [
    "algorithm",
    "metric"
  ],
  "test_kde_score": [
    "n_samples",
    "n_features"
  ],
  "test_kde_sample_weights_error": [],
  "test_kde_pipeline_gridsearch": [],
  "test_kde_sample_weights": [],
  "test_pickling": [
    "tmpdir",
    "sample_weight"
  ],
  "test_bandwidth": [
    "bandwidth"
  ],
  "test_transformer_result": [],
  "_has_explicit_diagonal": [
    "X"
  ],
  "test_explicit_diagonal": [],
  "test_graph_feature_names_out": [
    "Klass"
  ],
  "_check_is_fitted": [
    "estimator"
  ],
  "BaseThresholdClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_get_response_method": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "classes_": [
      "self"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "FixedThresholdClassifier": {
    "__init__": [
      "self",
      "estimator"
    ],
    "classes_": [
      "self"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_fit_and_score_over_thresholds": [
    "classifier",
    "X",
    "y"
  ],
  "_mean_interpolated_score": [
    "target_thresholds",
    "cv_thresholds",
    "cv_scores"
  ],
  "TunedThresholdClassifierCV": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_curve_scorer": [
      "self"
    ]
  },
  "_SubsampleMetaSplitter": {
    "__init__": [
      "self"
    ],
    "split": [
      "self",
      "X",
      "y"
    ]
  },
  "_top_k": [
    "results",
    "k",
    "itr"
  ],
  "BaseSuccessiveHalving": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_check_input_parameters": [
      "self",
      "X",
      "y",
      "split_params"
    ],
    "_select_best_index": [
      "refit",
      "refit_metric",
      "results"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "_generate_candidate_params": [
      "self"
    ]
  },
  "HalvingGridSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "param_grid"
    ],
    "_generate_candidate_params": [
      "self"
    ]
  },
  "HalvingRandomSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "param_distributions"
    ],
    "_generate_candidate_params": [
      "self"
    ]
  },
  "_UnsupportedGroupCVMixin": {
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "GroupsConsumerMixin": {
    "__metadata_request__split": []
  },
  "BaseCrossValidator": {
    "__metadata_request__split": [],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_iter_test_masks": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "__repr__": [
      "self"
    ]
  },
  "LeaveOneOut": {
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "LeavePOut": {
    "__init__": [
      "self",
      "p"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_BaseKFold": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "KFold": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "GroupKFold": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "StratifiedKFold": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "_make_test_folds": [
      "self",
      "X",
      "y"
    ],
    "_iter_test_masks": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "StratifiedGroupKFold": {
    "__init__": [
      "self",
      "n_splits",
      "shuffle",
      "random_state"
    ],
    "_iter_test_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_find_best_fold": [
      "self",
      "y_counts_per_fold",
      "y_cnt",
      "group_y_counts"
    ]
  },
  "TimeSeriesSplit": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_split": [
      "self",
      "X"
    ]
  },
  "LeaveOneGroupOut": {
    "_iter_test_masks": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "LeavePGroupsOut": {
    "__init__": [
      "self",
      "n_groups"
    ],
    "_iter_test_masks": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_RepeatedSplits": {
    "__metadata_request__split": [],
    "__init__": [
      "self",
      "cv"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "__repr__": [
      "self"
    ]
  },
  "RepeatedKFold": {
    "__init__": [
      "self"
    ]
  },
  "RepeatedStratifiedKFold": {
    "__init__": [
      "self"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "BaseShuffleSplit": {
    "__metadata_request__split": [],
    "__init__": [
      "self",
      "n_splits"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_iter_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ShuffleSplit": {
    "__init__": [
      "self",
      "n_splits"
    ]
  },
  "GroupShuffleSplit": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "_iter_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "StratifiedShuffleSplit": {
    "__init__": [
      "self",
      "n_splits"
    ],
    "_iter_indices": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_validate_shuffle_split": [
    "n_samples",
    "test_size",
    "train_size",
    "default_test_size"
  ],
  "PredefinedSplit": {
    "__init__": [
      "self",
      "test_fold"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "_split": [
      "self"
    ],
    "_iter_test_masks": [
      "self"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "_CVIterableWrapper": {
    "__init__": [
      "self",
      "cv"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "check_cv": [
    "cv",
    "y"
  ],
  "train_test_split": [],
  "_pprint": [
    "params",
    "offset",
    "printer"
  ],
  "_build_repr": [
    "self"
  ],
  "_yields_constant_splits": [
    "cv"
  ],
  "_check_groups_routing_disabled": [
    "groups"
  ],
  "cross_validate": [
    "estimator",
    "X",
    "y"
  ],
  "_insert_error_scores": [
    "results",
    "error_score"
  ],
  "_normalize_score_results": [
    "scores",
    "scaler_score_key"
  ],
  "_warn_or_raise_about_fit_failures": [
    "results",
    "error_score"
  ],
  "cross_val_score": [
    "estimator",
    "X",
    "y"
  ],
  "_fit_and_score": [
    "estimator",
    "X",
    "y"
  ],
  "_score": [
    "estimator",
    "X_test",
    "y_test",
    "scorer",
    "score_params",
    "error_score"
  ],
  "cross_val_predict": [
    "estimator",
    "X",
    "y"
  ],
  "_fit_and_predict": [
    "estimator",
    "X",
    "y",
    "train",
    "test",
    "fit_params",
    "method"
  ],
  "_enforce_prediction_order": [
    "classes",
    "predictions",
    "n_classes",
    "method"
  ],
  "_check_is_permutation": [
    "indices",
    "n_samples"
  ],
  "permutation_test_score": [
    "estimator",
    "X",
    "y"
  ],
  "_permutation_test_score": [
    "estimator",
    "X",
    "y",
    "cv",
    "scorer",
    "split_params",
    "fit_params",
    "score_params"
  ],
  "learning_curve": [
    "estimator",
    "X",
    "y"
  ],
  "_translate_train_sizes": [
    "train_sizes",
    "n_max_training_samples"
  ],
  "_incremental_fit_estimator": [
    "estimator",
    "X",
    "y",
    "classes",
    "train",
    "test",
    "train_sizes",
    "scorer",
    "return_times",
    "error_score",
    "fit_params",
    "score_params"
  ],
  "validation_curve": [
    "estimator",
    "X",
    "y"
  ],
  "_aggregate_score_dicts": [
    "scores"
  ],
  "ParameterGrid": {
    "__init__": [
      "self",
      "param_grid"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "ind"
    ]
  },
  "ParameterSampler": {
    "__init__": [
      "self",
      "param_distributions",
      "n_iter"
    ],
    "_is_all_lists": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "_check_refit": [
    "search_cv",
    "attr"
  ],
  "_search_estimator_has": [
    "attr"
  ],
  "_yield_masked_array_for_each_param": [
    "candidate_params"
  ],
  "BaseSearchCV": {
    "__init__": [
      "self",
      "estimator"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "n_features_in_": [
      "self"
    ],
    "classes_": [
      "self"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ],
    "_check_refit_for_multimetric": [
      "self",
      "scores"
    ],
    "_select_best_index": [
      "refit",
      "refit_metric",
      "results"
    ],
    "_get_scorers": [
      "self"
    ],
    "_check_scorers_accept_sample_weight": [
      "self"
    ],
    "_get_routed_params_for_fit": [
      "self",
      "params"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_format_results": [
      "self",
      "candidate_params",
      "n_splits",
      "out",
      "more_results"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "RandomizedSearchCV": {
    "__init__": [
      "self",
      "estimator",
      "param_distributions"
    ],
    "_run_search": [
      "self",
      "evaluate_candidates"
    ]
  },
  "_BaseCurveDisplay": {
    "_plot_curve": [
      "self",
      "x_data"
    ]
  },
  "LearningCurveDisplay": {
    "__init__": [
      "self"
    ],
    "plot": [
      "self",
      "ax"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ]
  },
  "ValidationCurveDisplay": {
    "__init__": [
      "self"
    ],
    "plot": [
      "self",
      "ax"
    ],
    "from_estimator": [
      "cls",
      "estimator",
      "X",
      "y"
    ]
  },
  "OneTimeSplitter": {
    "__init__": [
      "self",
      "n_splits",
      "n_samples"
    ],
    "split": [
      "self",
      "X",
      "y",
      "groups"
    ],
    "get_n_splits": [
      "self",
      "X",
      "y",
      "groups"
    ]
  },
  "FastClassifier": {
    "__init__": [
      "self",
      "strategy",
      "random_state",
      "constant"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "SometimesFailClassifier": {
    "__init__": [
      "self",
      "strategy",
      "random_state",
      "constant",
      "n_estimators",
      "fail_fit",
      "fail_predict",
      "a"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_nan_handling": [
    "HalvingSearch",
    "fail_at"
  ],
  "test_aggressive_elimination": [
    "Est",
    "aggressive_elimination",
    "max_resources",
    "expected_n_iterations",
    "expected_n_required_iterations",
    "expected_n_possible_iterations",
    "expected_n_remaining_candidates",
    "expected_n_candidates",
    "expected_n_resources"
  ],
  "test_min_max_resources": [
    "Est",
    "min_resources",
    "max_resources",
    "expected_n_iterations",
    "expected_n_possible_iterations",
    "expected_n_resources"
  ],
  "test_n_iterations": [
    "Est",
    "max_resources",
    "n_iterations",
    "n_possible_iterations"
  ],
  "test_resource_parameter": [
    "Est"
  ],
  "test_random_search": [
    "max_resources",
    "n_candidates",
    "expected_n_candidates"
  ],
  "test_random_search_discrete_distributions": [
    "param_distributions",
    "expected_n_candidates"
  ],
  "test_input_errors": [
    "Est",
    "params",
    "expected_error_message"
  ],
  "test_input_errors_randomized": [
    "params",
    "expected_error_message"
  ],
  "test_subsample_splitter_shapes": [
    "fraction",
    "subsample_test",
    "expected_train_size",
    "expected_test_size"
  ],
  "test_subsample_splitter_determinism": [
    "subsample_test"
  ],
  "test_top_k": [
    "k",
    "itr",
    "expected"
  ],
  "test_cv_results": [
    "Est"
  ],
  "test_base_estimator_inputs": [
    "Est"
  ],
  "test_groups_support": [
    "Est"
  ],
  "test_min_resources_null": [
    "SearchCV"
  ],
  "test_select_best_index": [
    "SearchCV"
  ],
  "test_halving_random_search_list_of_dicts": [],
  "NO_GROUP_SPLITTERS": [],
  "GROUP_SPLITTERS": [],
  "GROUP_SPLITTER_NAMES": [],
  "ALL_SPLITTERS": [],
  "SPLITTERS_REQUIRING_TARGET": [],
  "test_groups": [],
  "_split": [
    "splitter",
    "X",
    "y",
    "groups"
  ],
  "test_cross_validator_with_default_params": [],
  "test_2d_y": [],
  "check_valid_split": [
    "train",
    "test",
    "n_samples"
  ],
  "check_cv_coverage": [
    "cv",
    "X",
    "y",
    "groups",
    "expected_n_splits"
  ],
  "test_kfold_valueerrors": [],
  "test_kfold_indices": [],
  "test_kfold_no_shuffle": [],
  "test_stratified_kfold_no_shuffle": [],
  "test_stratified_kfold_ratios": [
    "k",
    "shuffle",
    "kfold"
  ],
  "test_stratified_kfold_label_invariance": [
    "k",
    "shuffle",
    "kfold"
  ],
  "test_kfold_balance": [],
  "test_stratifiedkfold_balance": [
    "kfold"
  ],
  "test_shuffle_kfold": [],
  "test_shuffle_kfold_stratifiedkfold_reproducibility": [
    "kfold"
  ],
  "test_shuffle_stratifiedkfold": [],
  "test_shuffle_groupkfold": [],
  "test_kfold_can_detect_dependent_samples_on_digits": [],
  "test_stratified_group_kfold_trivial": [],
  "test_stratified_group_kfold_approximate": [],
  "test_stratified_group_kfold_homogeneous_groups": [
    "y",
    "groups",
    "expected"
  ],
  "test_stratified_group_kfold_shuffle_preserves_stratification": [],
  "test_stratified_group_kfold_against_group_kfold": [
    "cls_distr",
    "n_groups"
  ],
  "test_shuffle_split": [],
  "test_shuffle_split_default_test_size": [
    "split_class",
    "train_size",
    "exp_train",
    "exp_test"
  ],
  "test_group_shuffle_split_default_test_size": [
    "train_size",
    "exp_train",
    "exp_test"
  ],
  "test_stratified_shuffle_split_init": [],
  "test_stratified_shuffle_split_respects_test_size": [],
  "test_stratified_shuffle_split_iter": [],
  "test_stratified_shuffle_split_even": [],
  "test_stratified_shuffle_split_overlap_train_test_bug": [],
  "test_stratified_shuffle_split_multilabel": [],
  "test_stratified_shuffle_split_multilabel_many_labels": [],
  "test_predefinedsplit_with_kfold_split": [],
  "test_group_shuffle_split": [],
  "test_leave_one_p_group_out": [],
  "test_leave_group_out_changing_groups": [],
  "test_leave_group_out_order_dependence": [],
  "test_leave_one_p_group_out_error_on_fewer_number_of_groups": [],
  "test_repeated_cv_value_errors": [],
  "test_repeated_cv_repr": [
    "RepeatedCV"
  ],
  "test_repeated_kfold_determinstic_split": [],
  "test_get_n_splits_for_repeated_kfold": [],
  "test_get_n_splits_for_repeated_stratified_kfold": [],
  "test_repeated_stratified_kfold_determinstic_split": [],
  "test_train_test_split_errors": [],
  "test_train_test_split_default_test_size": [
    "train_size",
    "exp_train",
    "exp_test"
  ],
  "test_array_api_train_test_split": [
    "shuffle",
    "stratify",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_train_test_split": [
    "coo_container"
  ],
  "test_train_test_split_32bit_overflow": [],
  "test_train_test_split_pandas": [],
  "test_train_test_split_sparse": [
    "sparse_container"
  ],
  "test_train_test_split_mock_pandas": [],
  "test_train_test_split_list_input": [],
  "test_shufflesplit_errors": [
    "test_size",
    "train_size"
  ],
  "test_shufflesplit_reproducible": [],
  "test_stratifiedshufflesplit_list_input": [],
  "test_train_test_split_allow_nans": [],
  "test_check_cv": [],
  "test_cv_iterable_wrapper": [],
  "test_group_kfold": [
    "kfold",
    "shuffle",
    "global_random_seed"
  ],
  "test_time_series_cv": [],
  "_check_time_series_max_train_size": [
    "splits",
    "check_splits",
    "max_train_size"
  ],
  "test_time_series_max_train_size": [],
  "test_time_series_test_size": [],
  "test_time_series_gap": [],
  "test_nested_cv": [],
  "test_build_repr": [],
  "test_shuffle_split_empty_trainset": [
    "CVSplitter"
  ],
  "test_train_test_split_empty_trainset": [],
  "test_leave_one_out_empty_trainset": [],
  "test_leave_p_out_empty_trainset": [],
  "test_random_state_shuffle_false": [
    "Klass"
  ],
  "test_yields_constant_splits": [
    "cv",
    "expected"
  ],
  "test_splitter_get_metadata_routing": [
    "cv"
  ],
  "test_splitter_set_split_request": [
    "cv"
  ],
  "test_no_group_splitters_warns_with_groups": [
    "cv"
  ],
  "test_stratified_splitter_without_y": [
    "cv"
  ],
  "MockClassifier": {
    "__init__": [
      "self",
      "foo_param"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "T"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "predict_proba": [],
    "predict_log_proba": [],
    "decision_function": [],
    "score": [
      "self",
      "X",
      "Y"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "LinearSVCNoScore": {
    "score": [
      "self"
    ]
  },
  "assert_grid_iter_equals_getitem": [
    "grid"
  ],
  "test_validate_parameter_input": [
    "klass",
    "input",
    "error_type",
    "error_message"
  ],
  "test_parameter_grid": [],
  "test_grid_search": [],
  "test_grid_search_pipeline_steps": [],
  "test_SearchCV_with_fit_params": [
    "SearchCV"
  ],
  "test_grid_search_no_score": [],
  "test_grid_search_score_method": [],
  "test_grid_search_groups": [],
  "test_classes__property": [],
  "test_trivial_cv_results_attr": [],
  "test_no_refit": [],
  "test_grid_search_error": [],
  "test_grid_search_one_grid_point": [],
  "test_grid_search_when_param_grid_includes_range": [],
  "test_grid_search_bad_param_grid": [],
  "test_grid_search_sparse": [
    "csr_container"
  ],
  "test_grid_search_sparse_scoring": [
    "csr_container"
  ],
  "test_grid_search_precomputed_kernel": [],
  "test_grid_search_precomputed_kernel_error_nonsquare": [],
  "BrokenClassifier": {
    "__init__": [
      "self",
      "parameter"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_refit": [],
  "test_refit_callable": [],
  "test_refit_callable_invalid_type": [],
  "test_refit_callable_out_bound": [
    "out_bound_value",
    "search_cv"
  ],
  "test_refit_callable_multi_metric": [],
  "test_gridsearch_nd": [],
  "test_X_as_list": [],
  "test_y_as_list": [],
  "test_pandas_input": [],
  "test_unsupervised_grid_search": [],
  "test_gridsearch_no_predict": [],
  "test_param_sampler": [],
  "check_cv_results_array_types": [
    "search",
    "param_keys",
    "score_keys",
    "expected_cv_results_kinds"
  ],
  "check_cv_results_keys": [
    "cv_results",
    "param_keys",
    "score_keys",
    "n_cand",
    "extra_keys"
  ],
  "test_grid_search_cv_results": [],
  "test_random_search_cv_results": [],
  "test_search_default_iid": [
    "SearchCV",
    "specialized_params"
  ],
  "test_grid_search_cv_results_multimetric": [],
  "test_random_search_cv_results_multimetric": [],
  "compare_cv_results_multimetric_with_single": [
    "search_multi",
    "search_acc",
    "search_rec"
  ],
  "compare_refit_methods_when_refit_with_acc": [
    "search_multi",
    "search_acc",
    "refit"
  ],
  "test_search_cv_score_samples_error": [
    "search_cv"
  ],
  "test_unsupported_sample_weight_scorer": [],
  "test_search_cv_sample_weight_equivalence": [
    "estimator"
  ],
  "test_search_cv_score_samples_method": [
    "search_cv"
  ],
  "test_search_cv_results_rank_tie_breaking": [],
  "test_search_cv_results_none_param": [],
  "test_search_cv_timing": [],
  "test_grid_search_correct_score_results": [],
  "test_grid_search_with_multioutput_data": [],
  "test_predict_proba_disabled": [],
  "test_grid_search_allows_nans": [],
  "FailingClassifier": {
    "FAILING_PARAMETER": [],
    "__init__": [
      "self",
      "parameter"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ]
  },
  "test_grid_search_failing_classifier": [],
  "test_grid_search_classifier_all_fits_fail": [],
  "test_grid_search_failing_classifier_raise": [],
  "test_parameters_sampler_replacement": [],
  "test_stochastic_gradient_loss_param": [],
  "test_search_train_scores_set_to_false": [],
  "test_grid_search_cv_splits_consistency": [],
  "test_custom_run_search": [],
  "test__custom_fit_no_run_search": [],
  "test_empty_cv_iterator_error": [],
  "test_random_search_bad_cv": [],
  "test_searchcv_raise_warning_with_non_finite_score": [
    "SearchCV",
    "specialized_params",
    "return_train_score"
  ],
  "test_callable_multimetric_confusion_matrix": [],
  "test_callable_multimetric_same_as_list_of_strings": [],
  "test_callable_single_metric_same_as_single_string": [],
  "test_callable_multimetric_error_on_invalid_key": [],
  "test_callable_multimetric_error_failing_clf": [],
  "test_callable_multimetric_clf_all_fits_fail": [],
  "test_search_cv_pairwise_property_delegated_to_base_estimator": [
    "pairwise"
  ],
  "test_search_cv__pairwise_property_delegated_to_base_estimator": [],
  "test_search_cv_pairwise_property_equivalence_of_precomputed": [],
  "test_scalar_fit_param": [
    "SearchCV",
    "param_search"
  ],
  "test_scalar_fit_param_compat": [
    "SearchCV",
    "param_search"
  ],
  "test_search_cv_verbose_3": [
    "capsys",
    "return_train_score"
  ],
  "test_search_estimator_param": [
    "SearchCV",
    "param_search"
  ],
  "test_search_with_2d_array": [],
  "test_search_html_repr": [],
  "test_multi_metric_search_forwards_metadata": [
    "SearchCV",
    "param_search"
  ],
  "test_score_rejects_params_with_no_routing_enabled": [
    "SearchCV",
    "param_search"
  ],
  "test_cv_results_dtype_issue_29074": [],
  "test_search_with_estimators_issue_29157": [],
  "test_cv_results_multi_size_array": [],
  "test_array_api_search_cv_classifier": [
    "SearchCV",
    "array_namespace",
    "device",
    "dtype"
  ],
  "one_hot_encoder": [],
  "ordinal_encoder": [],
  "ma_with_tuples": [],
  "test_yield_masked_array_for_each_param": [
    "candidate_params",
    "expected"
  ],
  "test_yield_masked_array_no_runtime_warning": [],
  "MockImprovingEstimator": {
    "__init__": [
      "self",
      "n_max_train_sizes"
    ],
    "fit": [
      "self",
      "X_subset",
      "y_subset"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ],
    "_is_training_data": [
      "self",
      "X"
    ]
  },
  "MockIncrementalImprovingEstimator": {
    "__init__": [
      "self",
      "n_max_train_sizes",
      "expected_fit_params"
    ],
    "_is_training_data": [
      "self",
      "X"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ]
  },
  "MockEstimatorWithParameter": {
    "__init__": [
      "self",
      "param"
    ],
    "fit": [
      "self",
      "X_subset",
      "y_subset"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "_is_training_data": [
      "self",
      "X"
    ]
  },
  "MockEstimatorWithSingleFitCallAllowed": {
    "fit": [
      "self",
      "X_subset",
      "y_subset"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "test_cross_val_score": [
    "coo_container"
  ],
  "test_cross_validate_many_jobs": [],
  "test_cross_validate_invalid_scoring_param": [],
  "test_cross_validate_nested_estimator": [],
  "test_cross_validate": [
    "use_sparse",
    "csr_container"
  ],
  "check_cross_validate_single_metric": [
    "clf",
    "X",
    "y",
    "scores",
    "cv"
  ],
  "check_cross_validate_multi_metric": [
    "clf",
    "X",
    "y",
    "scores",
    "cv"
  ],
  "test_cross_val_score_predict_groups": [],
  "test_cross_val_score_pandas": [],
  "test_cross_val_score_mask": [],
  "test_cross_val_score_precomputed": [],
  "test_cross_val_score_fit_params": [
    "coo_container"
  ],
  "test_cross_val_score_score_func": [],
  "test_cross_val_score_with_score_func_classification": [],
  "test_cross_val_score_with_score_func_regression": [],
  "test_permutation_score": [
    "coo_container"
  ],
  "test_permutation_test_score_allow_nans": [],
  "test_permutation_test_score_params": [],
  "test_cross_val_score_allow_nans": [],
  "test_cross_val_score_multilabel": [],
  "test_cross_val_predict": [
    "coo_container"
  ],
  "test_cross_val_predict_decision_function_shape": [],
  "test_cross_val_predict_predict_proba_shape": [],
  "test_cross_val_predict_predict_log_proba_shape": [],
  "test_cross_val_predict_input_types": [
    "coo_container"
  ],
  "test_cross_val_predict_pandas": [],
  "test_cross_val_predict_unbalanced": [],
  "test_cross_val_predict_y_none": [],
  "test_cross_val_score_sparse_fit_params": [
    "coo_container"
  ],
  "test_learning_curve": [],
  "test_learning_curve_unsupervised": [],
  "test_learning_curve_verbose": [
    "capsys"
  ],
  "test_learning_curve_incremental_learning_not_possible": [],
  "test_learning_curve_incremental_learning": [],
  "test_learning_curve_incremental_learning_unsupervised": [],
  "test_learning_curve_batch_and_incremental_learning_are_equal": [],
  "test_learning_curve_n_sample_range_out_of_bounds": [],
  "test_learning_curve_remove_duplicate_sample_sizes": [],
  "test_learning_curve_with_boolean_indices": [],
  "test_learning_curve_with_shuffle": [],
  "test_learning_curve_params": [],
  "test_learning_curve_incremental_learning_params": [],
  "test_validation_curve": [],
  "test_validation_curve_clone_estimator": [],
  "test_validation_curve_cv_splits_consistency": [],
  "test_validation_curve_params": [],
  "test_check_is_permutation": [],
  "test_cross_val_predict_sparse_prediction": [
    "csr_container"
  ],
  "check_cross_val_predict_binary": [
    "est",
    "X",
    "y",
    "method"
  ],
  "check_cross_val_predict_multiclass": [
    "est",
    "X",
    "y",
    "method"
  ],
  "check_cross_val_predict_multilabel": [
    "est",
    "X",
    "y",
    "method"
  ],
  "check_cross_val_predict_with_method_binary": [
    "est"
  ],
  "check_cross_val_predict_with_method_multiclass": [
    "est"
  ],
  "test_cross_val_predict_with_method": [],
  "test_cross_val_predict_method_checking": [],
  "test_gridsearchcv_cross_val_predict_with_method": [],
  "test_cross_val_predict_with_method_multilabel_ovr": [],
  "RFWithDecisionFunction": {
    "decision_function": [
      "self",
      "X"
    ]
  },
  "test_cross_val_predict_with_method_multilabel_rf": [],
  "test_cross_val_predict_with_method_rare_class": [],
  "test_cross_val_predict_with_method_multilabel_rf_rare_class": [],
  "get_expected_predictions": [
    "X",
    "y",
    "cv",
    "classes",
    "est",
    "method"
  ],
  "test_cross_val_predict_class_subset": [],
  "test_score_memmap": [],
  "test_permutation_test_score_pandas": [],
  "test_fit_and_score_failing": [],
  "test_fit_and_score_working": [],
  "DataDependentFailingClassifier": {
    "__init__": [
      "self",
      "max_x_value"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X",
      "Y"
    ]
  },
  "test_cross_validate_some_failing_fits_warning": [
    "error_score"
  ],
  "test_cross_validate_all_failing_fits_error": [
    "error_score"
  ],
  "_failing_scorer": [
    "estimator",
    "X",
    "y",
    "error_msg"
  ],
  "test_cross_val_score_failing_scorer": [
    "error_score"
  ],
  "test_cross_validate_failing_scorer": [
    "error_score",
    "return_train_score",
    "with_multimetric"
  ],
  "three_params_scorer": [
    "i",
    "j",
    "k"
  ],
  "test_fit_and_score_verbosity": [
    "capsys",
    "train_score",
    "scorer",
    "verbose",
    "split_prg",
    "cdt_prg",
    "expected"
  ],
  "test_callable_multimetric_confusion_matrix_cross_validate": [],
  "test_learning_curve_partial_fit_regressors": [],
  "test_learning_curve_some_failing_fits_warning": [
    "global_random_seed"
  ],
  "test_cross_validate_return_indices": [
    "global_random_seed"
  ],
  "test_groups_with_routing_validation": [
    "func",
    "extra_args"
  ],
  "test_cross_validate_params_none": [
    "func",
    "extra_args"
  ],
  "test_passed_unrequested_metadata": [
    "func",
    "extra_args"
  ],
  "test_validation_functions_routing": [
    "func",
    "extra_args"
  ],
  "test_learning_curve_exploit_incremental_learning_routing": [],
  "test_cross_val_predict_array_api_compliance": [
    "estimator",
    "cv",
    "namespace",
    "device_",
    "dtype_name"
  ],
  "test_fit_and_score_over_thresholds_curve_scorers": [],
  "test_fit_and_score_over_thresholds_prefit": [],
  "test_fit_and_score_over_thresholds_sample_weight": [],
  "test_fit_and_score_over_thresholds_fit_params": [
    "fit_params_type"
  ],
  "test_tuned_threshold_classifier_no_binary": [
    "data"
  ],
  "test_tuned_threshold_classifier_conflict_cv_refit": [
    "params",
    "err_type",
    "err_msg"
  ],
  "test_threshold_classifier_estimator_response_methods": [
    "ThresholdClassifier",
    "estimator",
    "response_method"
  ],
  "test_tuned_threshold_classifier_without_constraint_value": [
    "response_method"
  ],
  "test_tuned_threshold_classifier_metric_with_parameter": [],
  "test_tuned_threshold_classifier_with_string_targets": [
    "response_method",
    "metric"
  ],
  "test_tuned_threshold_classifier_refit": [
    "with_sample_weight",
    "global_random_seed"
  ],
  "test_tuned_threshold_classifier_fit_params": [
    "fit_params_type"
  ],
  "test_tuned_threshold_classifier_cv_zeros_sample_weights_equivalence": [],
  "test_tuned_threshold_classifier_thresholds_array": [],
  "test_tuned_threshold_classifier_store_cv_results": [
    "store_cv_results"
  ],
  "test_tuned_threshold_classifier_cv_float": [],
  "test_tuned_threshold_classifier_error_constant_predictor": [],
  "test_fixed_threshold_classifier_equivalence_default": [
    "response_method"
  ],
  "test_fixed_threshold_classifier": [
    "response_method",
    "threshold",
    "pos_label"
  ],
  "test_fixed_threshold_classifier_metadata_routing": [],
  "test_fixed_threshold_classifier_fitted_estimator": [
    "method"
  ],
  "test_fixed_threshold_classifier_classes_": [],
  "test_curve_display_parameters_validation": [
    "pyplot",
    "data",
    "params",
    "err_type",
    "err_msg",
    "CurveDisplay",
    "specific_params"
  ],
  "test_learning_curve_display_default_usage": [
    "pyplot",
    "data"
  ],
  "test_validation_curve_display_default_usage": [
    "pyplot",
    "data"
  ],
  "test_curve_display_negate_score": [
    "pyplot",
    "data",
    "CurveDisplay",
    "specific_params"
  ],
  "test_curve_display_score_name": [
    "pyplot",
    "data",
    "score_name",
    "ylabel",
    "CurveDisplay",
    "specific_params"
  ],
  "test_learning_curve_display_score_type": [
    "pyplot",
    "data",
    "std_display_style"
  ],
  "test_validation_curve_display_score_type": [
    "pyplot",
    "data",
    "std_display_style"
  ],
  "test_curve_display_xscale_auto": [
    "pyplot",
    "data",
    "CurveDisplay",
    "specific_params",
    "expected_xscale"
  ],
  "test_curve_display_std_display_style": [
    "pyplot",
    "data",
    "CurveDisplay",
    "specific_params"
  ],
  "test_curve_display_plot_kwargs": [
    "pyplot",
    "data",
    "CurveDisplay",
    "specific_params"
  ],
  "test_validation_curve_xscale_from_param_range_provided_as_a_list": [
    "pyplot",
    "data",
    "param_range",
    "xscale"
  ],
  "test_subclassing_displays": [
    "pyplot",
    "data",
    "Display",
    "params"
  ],
  "pytest_ignore_collect": [
    "collection_path",
    "config"
  ],
  "__author_email__": [],
  "_SIMPLE_TYPES": [],
  "_TK_DESCRIPTION": [],
  "_TK_COMMENT": [],
  "_TK_RELATION": [],
  "_TK_ATTRIBUTE": [],
  "_TK_DATA": [],
  "_RE_RELATION": [],
  "_RE_ATTRIBUTE": [],
  "_RE_QUOTE_CHARS": [],
  "_RE_ESCAPE_CHARS": [],
  "_RE_SPARSE_LINE": [],
  "_RE_NONTRIVIAL_DATA": [],
  "ArffDenseDataType": [],
  "ArffSparseDataType": [],
  "_build_re_values": [],
  "_ESCAPE_SUB_MAP": [],
  "_UNESCAPE_SUB_MAP": [],
  "_escape_sub_callback": [
    "match"
  ],
  "_unquote": [
    "v"
  ],
  "_parse_values": [
    "s"
  ],
  "DENSE": [],
  "COO": [],
  "LOD": [],
  "DENSE_GEN": [],
  "LOD_GEN": [],
  "_SUPPORTED_DATA_STRUCTURES": [],
  "ArffException": {
    "__init__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "BadRelationFormat": {
    "message": []
  },
  "BadAttributeFormat": {
    "message": []
  },
  "BadDataFormat": {
    "__init__": [
      "self",
      "value"
    ]
  },
  "BadAttributeType": {
    "message": []
  },
  "BadAttributeName": {
    "__init__": [
      "self",
      "value",
      "value2"
    ]
  },
  "BadNominalValue": {
    "__init__": [
      "self",
      "value"
    ]
  },
  "BadNominalFormatting": {
    "__init__": [
      "self",
      "value"
    ]
  },
  "BadNumericalValue": {
    "message": []
  },
  "BadStringValue": {
    "message": []
  },
  "BadLayout": {
    "message": [],
    "__init__": [
      "self",
      "msg"
    ]
  },
  "BadObject": {
    "__init__": [
      "self",
      "msg"
    ],
    "__str__": [
      "self"
    ]
  },
  "_unescape_sub_callback": [
    "match"
  ],
  "encode_string": [
    "s"
  ],
  "EncodedNominalConversor": {
    "__init__": [
      "self",
      "values"
    ],
    "__call__": [
      "self",
      "value"
    ]
  },
  "NominalConversor": {
    "__init__": [
      "self",
      "values"
    ],
    "__call__": [
      "self",
      "value"
    ]
  },
  "DenseGeneratorData": {
    "decode_rows": [
      "self",
      "stream",
      "conversors"
    ],
    "_decode_values": [
      "values",
      "conversors"
    ],
    "encode_data": [
      "self",
      "data",
      "attributes"
    ]
  },
  "_DataListMixin": {
    "decode_rows": [
      "self",
      "stream",
      "conversors"
    ]
  },
  "Data": {},
  "COOData": {
    "decode_rows": [
      "self",
      "stream",
      "conversors"
    ],
    "encode_data": [
      "self",
      "data",
      "attributes"
    ]
  },
  "LODGeneratorData": {
    "decode_rows": [
      "self",
      "stream",
      "conversors"
    ],
    "encode_data": [
      "self",
      "data",
      "attributes"
    ]
  },
  "LODData": {},
  "_get_data_object_for_decoding": [
    "matrix_type"
  ],
  "_get_data_object_for_encoding": [
    "matrix"
  ],
  "ArffDecoder": {
    "__init__": [
      "self"
    ],
    "_decode_comment": [
      "self",
      "s"
    ],
    "_decode_relation": [
      "self",
      "s"
    ],
    "_decode_attribute": [
      "self",
      "s"
    ],
    "_decode": [
      "self",
      "s",
      "encode_nominal",
      "matrix_type"
    ],
    "decode": [
      "self",
      "s",
      "encode_nominal",
      "return_type"
    ]
  },
  "ArffEncoder": {
    "_encode_comment": [
      "self",
      "s"
    ],
    "_encode_relation": [
      "self",
      "name"
    ],
    "_encode_attribute": [
      "self",
      "name",
      "type_"
    ],
    "encode": [
      "self",
      "obj"
    ],
    "iter_encode": [
      "self",
      "obj"
    ]
  },
  "load": [
    "fp",
    "encode_nominal",
    "return_type"
  ],
  "loads": [
    "s",
    "encode_nominal",
    "return_type"
  ],
  "dump": [
    "obj",
    "fp"
  ],
  "dumps": [
    "obj"
  ],
  "strip_blank_lines": [
    "l"
  ],
  "Reader": {
    "__init__": [
      "self",
      "data"
    ],
    "__getitem__": [
      "self",
      "n"
    ],
    "reset": [
      "self"
    ],
    "read": [
      "self"
    ],
    "seek_next_non_empty_line": [
      "self"
    ],
    "eof": [
      "self"
    ],
    "read_to_condition": [
      "self",
      "condition_func"
    ],
    "read_to_next_empty_line": [
      "self"
    ],
    "read_to_next_unindented_line": [
      "self"
    ],
    "peek": [
      "self",
      "n"
    ],
    "is_empty": [
      "self"
    ]
  },
  "ParseError": {
    "__str__": [
      "self"
    ]
  },
  "Parameter": [],
  "NumpyDocString": {
    "sections": [],
    "__init__": [
      "self",
      "docstring",
      "config"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__setitem__": [
      "self",
      "key",
      "val"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "_is_at_section": [
      "self"
    ],
    "_strip": [
      "self",
      "doc"
    ],
    "_read_to_next_section": [
      "self"
    ],
    "_read_sections": [
      "self"
    ],
    "_parse_param_list": [
      "self",
      "content",
      "single_element_is_type"
    ],
    "_role": [],
    "_funcbacktick": [],
    "_funcplain": [],
    "_funcname": [],
    "_funcnamenext": [],
    "_description": [],
    "_func_rgx": [],
    "_line_rgx": [],
    "empty_description": [],
    "_parse_see_also": [
      "self",
      "content"
    ],
    "_parse_index": [
      "self",
      "section",
      "content"
    ],
    "_parse_summary": [
      "self"
    ],
    "_parse": [
      "self"
    ],
    "_obj": [
      "self"
    ],
    "_error_location": [
      "self",
      "msg",
      "error"
    ],
    "_str_header": [
      "self",
      "name",
      "symbol"
    ],
    "_str_indent": [
      "self",
      "doc",
      "indent"
    ],
    "_str_signature": [
      "self"
    ],
    "_str_summary": [
      "self"
    ],
    "_str_extended_summary": [
      "self"
    ],
    "_str_param_list": [
      "self",
      "name"
    ],
    "_str_section": [
      "self",
      "name"
    ],
    "_str_see_also": [
      "self",
      "func_role"
    ],
    "_str_index": [
      "self"
    ],
    "__str__": [
      "self",
      "func_role"
    ]
  },
  "dedent_lines": [
    "lines"
  ],
  "FunctionDoc": {
    "__init__": [
      "self",
      "func",
      "role",
      "doc",
      "config"
    ],
    "get_func": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ObjDoc": {
    "__init__": [
      "self",
      "obj",
      "doc",
      "config"
    ]
  },
  "ClassDoc": {
    "extra_public_methods": [],
    "__init__": [
      "self",
      "cls",
      "doc",
      "modulename",
      "func_doc",
      "config"
    ],
    "methods": [
      "self"
    ],
    "properties": [
      "self"
    ],
    "_should_skip_member": [
      "name",
      "klass"
    ],
    "_is_show_member": [
      "self",
      "name"
    ]
  },
  "get_doc_object": [
    "obj",
    "what",
    "doc",
    "config",
    "class_doc",
    "func_doc",
    "obj_doc"
  ],
  "InfiniteTypes": [],
  "PrePostDevType": [],
  "SubLocalType": [],
  "LocalType": [],
  "CmpKey": [],
  "LegacyCmpKey": [],
  "VersionComparisonMethod": [],
  "_Version": [],
  "parse": [
    "version"
  ],
  "InvalidVersion": {},
  "_BaseVersion": {
    "__hash__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "LegacyVersion": {
    "__init__": [
      "self",
      "version"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "public": [
      "self"
    ],
    "base_version": [
      "self"
    ],
    "epoch": [
      "self"
    ],
    "release": [
      "self"
    ],
    "pre": [
      "self"
    ],
    "post": [
      "self"
    ],
    "dev": [
      "self"
    ],
    "local": [
      "self"
    ],
    "is_prerelease": [
      "self"
    ],
    "is_postrelease": [
      "self"
    ],
    "is_devrelease": [
      "self"
    ]
  },
  "_legacy_version_component_re": [],
  "_legacy_version_replacement_map": [],
  "_parse_version_parts": [
    "s"
  ],
  "_legacy_cmpkey": [
    "version"
  ],
  "VERSION_PATTERN": [],
  "Version": {
    "_regex": [],
    "__init__": [
      "self",
      "version"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "epoch": [
      "self"
    ],
    "release": [
      "self"
    ],
    "pre": [
      "self"
    ],
    "post": [
      "self"
    ],
    "dev": [
      "self"
    ],
    "local": [
      "self"
    ],
    "public": [
      "self"
    ],
    "base_version": [
      "self"
    ],
    "is_prerelease": [
      "self"
    ],
    "is_postrelease": [
      "self"
    ],
    "is_devrelease": [
      "self"
    ],
    "major": [
      "self"
    ],
    "minor": [
      "self"
    ],
    "micro": [
      "self"
    ]
  },
  "_parse_letter_version": [
    "letter",
    "number"
  ],
  "_local_version_separators": [],
  "_parse_local_version": [
    "local"
  ],
  "_cmpkey": [
    "epoch",
    "release",
    "pre",
    "post",
    "dev",
    "local"
  ],
  "InfinityType": {
    "__repr__": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__neg__": [
      "self"
    ]
  },
  "Infinity": [],
  "NegativeInfinityType": {
    "__repr__": [
      "self"
    ],
    "__hash__": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__neg__": [
      "self"
    ]
  },
  "NegativeInfinity": [],
  "Deprecated": {
    "DEPRECATED": []
  },
  "DEPRECATED": [],
  "lazy_xp_function": [
    "func"
  ],
  "patch_lazy_xp_functions": [
    "request",
    "monkeypatch"
  ],
  "CountingDaskScheduler": {
    "__init__": [
      "self",
      "max_count",
      "msg"
    ],
    "__call__": [
      "self",
      "dsk",
      "keys"
    ]
  },
  "_dask_wrap": [
    "func",
    "n"
  ],
  "isclose": [
    "a",
    "b"
  ],
  "nan_to_num": [],
  "one_hot": [
    "num_classes"
  ],
  "pad": [
    "x",
    "pad_width",
    "mode"
  ],
  "apply_where": [],
  "_apply_where": [
    "cond",
    "f1",
    "f2",
    "fill_value"
  ],
  "atleast_nd": [],
  "broadcast_shapes": [],
  "cov": [],
  "create_diagonal": [],
  "default_dtype": [
    "xp",
    "kind"
  ],
  "expand_dims": [],
  "kron": [],
  "nunique": [],
  "setdiff1d": [],
  "sinc": [],
  "NUMPY_VERSION": [],
  "Backend": {
    "ARRAY_API_STRICT": [],
    "ARRAY_API_STRICTEST": [],
    "NUMPY": [],
    "NUMPY_READONLY": [],
    "CUPY": [],
    "TORCH": [],
    "TORCH_GPU": [],
    "DASK": [],
    "SPARSE": [],
    "JAX": [],
    "JAX_GPU": [],
    "modname": [
      "self"
    ],
    "like": [
      "self"
    ],
    "pytest_param": [
      "self"
    ]
  },
  "_AtOp": {
    "SET": [],
    "ADD": [],
    "SUBTRACT": [],
    "MULTIPLY": [],
    "DIVIDE": [],
    "POWER": [],
    "MIN": [],
    "MAX": [],
    "__str__": [
      "self"
    ]
  },
  "Undef": {
    "UNDEF": []
  },
  "_undef": [],
  "at": {
    "__init__": [],
    "__getitem__": [],
    "_op": [
      "copy",
      "xp"
    ],
    "set": [
      "copy",
      "xp"
    ],
    "add": [
      "copy",
      "xp"
    ],
    "subtract": [
      "copy",
      "xp"
    ],
    "multiply": [
      "copy",
      "xp"
    ],
    "divide": [
      "copy",
      "xp"
    ],
    "power": [
      "copy",
      "xp"
    ],
    "min": [
      "copy",
      "xp"
    ],
    "max": [
      "copy",
      "xp"
    ]
  },
  "_check_ns_shape_dtype": [
    "actual",
    "desired",
    "check_dtype",
    "check_shape",
    "check_scalar"
  ],
  "_is_materializable": [
    "x"
  ],
  "as_numpy_array": [
    "array"
  ],
  "xp_assert_equal": [
    "actual",
    "desired"
  ],
  "xp_assert_less": [
    "x",
    "y"
  ],
  "xp_assert_close": [
    "actual",
    "desired"
  ],
  "xfail": [
    "request"
  ],
  "lazy_apply": [
    "func"
  ],
  "_is_jax_jit_enabled": [
    "xp"
  ],
  "_lazy_apply_wrapper": [
    "func",
    "as_numpy",
    "multi_output",
    "xp"
  ],
  "Array": [],
  "DType": [],
  "Device": [],
  "GetIndex": [],
  "SetIndex": [],
  "in1d": [],
  "mean": [],
  "is_python_scalar": [
    "x"
  ],
  "asarrays": [
    "a",
    "b",
    "xp"
  ],
  "ndindex": [],
  "eager_shape": [],
  "meta_namespace": [],
  "capabilities": [
    "xp"
  ],
  "_BASIC_PICKLED_TYPES": [],
  "_BASIC_REST_TYPES": [],
  "pickle_flatten": [
    "obj",
    "cls"
  ],
  "pickle_unflatten": [
    "instances",
    "rest"
  ],
  "_AutoJITWrapper": {
    "__init__": [
      "self",
      "obj"
    ],
    "_register": [
      "cls"
    ]
  },
  "jax_autojit": [
    "func"
  ],
  "_T": [],
  "get_xp": [
    "xp"
  ],
  "arange": [
    "stop",
    "step"
  ],
  "empty": [
    "shape",
    "xp"
  ],
  "empty_like": [
    "xp"
  ],
  "eye": [],
  "full": [
    "shape",
    "fill_value",
    "xp"
  ],
  "full_like": [
    "fill_value"
  ],
  "linspace": [
    "num"
  ],
  "ones": [
    "shape",
    "xp"
  ],
  "ones_like": [
    "xp"
  ],
  "zeros": [
    "shape",
    "xp"
  ],
  "zeros_like": [
    "xp"
  ],
  "UniqueAllResult": {},
  "UniqueCountsResult": {},
  "UniqueInverseResult": {},
  "_unique_kwargs": [
    "xp"
  ],
  "unique_all": [
    "xp"
  ],
  "unique_counts": [
    "xp"
  ],
  "unique_inverse": [
    "xp"
  ],
  "unique_values": [
    "xp"
  ],
  "std": [
    "xp"
  ],
  "var": [
    "xp"
  ],
  "cumulative_sum": [
    "xp"
  ],
  "cumulative_prod": [
    "xp"
  ],
  "clip": [
    "min",
    "max"
  ],
  "permute_dims": [
    "axes",
    "xp"
  ],
  "reshape": [
    "shape",
    "xp"
  ],
  "argsort": [
    "xp"
  ],
  "sort": [
    "xp"
  ],
  "nonzero": [
    "xp"
  ],
  "ceil": [
    "xp"
  ],
  "floor": [
    "xp"
  ],
  "trunc": [
    "xp"
  ],
  "matmul": [
    "xp"
  ],
  "matrix_transpose": [
    "xp"
  ],
  "tensordot": [
    "xp"
  ],
  "vecdot": [
    "xp"
  ],
  "isdtype": [
    "dtype",
    "kind",
    "xp"
  ],
  "unstack": [
    "xp"
  ],
  "sign": [
    "xp"
  ],
  "finfo": [
    "xp"
  ],
  "iinfo": [
    "xp"
  ],
  "_all_ignore": [],
  "fft": [
    "xp"
  ],
  "ifft": [
    "xp"
  ],
  "fftn": [
    "xp"
  ],
  "ifftn": [
    "xp"
  ],
  "rfft": [
    "xp"
  ],
  "irfft": [
    "xp"
  ],
  "rfftn": [
    "xp"
  ],
  "irfftn": [
    "xp"
  ],
  "hfft": [
    "xp"
  ],
  "ihfft": [
    "xp"
  ],
  "fftfreq": [
    "xp"
  ],
  "rfftfreq": [
    "xp"
  ],
  "fftshift": [
    "xp"
  ],
  "ifftshift": [
    "xp"
  ],
  "_T_co": [],
  "JustInt": {
    "__class__": []
  },
  "JustFloat": {
    "__class__": []
  },
  "JustComplex": {
    "__class__": []
  },
  "NestedSequence": {
    "__getitem__": [],
    "__len__": []
  },
  "SupportsArrayNamespace": {
    "__array_namespace__": []
  },
  "HasShape": {
    "shape": []
  },
  "Capabilities": [],
  "DefaultDTypes": [],
  "DTypesBool": {},
  "DTypesSigned": {},
  "DTypesUnsigned": {},
  "DTypesIntegral": {},
  "DTypesReal": {},
  "DTypesComplex": {},
  "DTypesNumeric": {},
  "DTypesAll": {},
  "cross": [
    "xp"
  ],
  "outer": [
    "xp"
  ],
  "EighResult": {},
  "QRResult": {},
  "SlogdetResult": {},
  "SVDResult": {},
  "eigh": [
    "xp"
  ],
  "qr": [
    "xp"
  ],
  "slogdet": [
    "xp"
  ],
  "svd": [
    "xp"
  ],
  "cholesky": [
    "xp"
  ],
  "matrix_rank": [
    "xp"
  ],
  "pinv": [
    "xp"
  ],
  "matrix_norm": [
    "xp"
  ],
  "svdvals": [
    "xp"
  ],
  "vector_norm": [
    "xp"
  ],
  "diagonal": [
    "xp"
  ],
  "trace": [
    "xp"
  ],
  "_issubclass_fast": [
    "cls",
    "modname",
    "clsname"
  ],
  "_is_jax_zero_gradient_array": [
    "x"
  ],
  "is_numpy_array": [
    "x"
  ],
  "is_cupy_array": [
    "x"
  ],
  "is_torch_array": [
    "x"
  ],
  "is_ndonnx_array": [
    "x"
  ],
  "is_dask_array": [
    "x"
  ],
  "is_jax_array": [
    "x"
  ],
  "is_pydata_sparse_array": [
    "x"
  ],
  "is_array_api_obj": [
    "x"
  ],
  "_is_array_api_cls": [
    "cls"
  ],
  "_compat_module_name": [],
  "is_numpy_namespace": [
    "xp"
  ],
  "is_cupy_namespace": [
    "xp"
  ],
  "is_torch_namespace": [
    "xp"
  ],
  "is_ndonnx_namespace": [
    "xp"
  ],
  "is_dask_namespace": [
    "xp"
  ],
  "is_jax_namespace": [
    "xp"
  ],
  "is_pydata_sparse_namespace": [
    "xp"
  ],
  "is_array_api_strict_namespace": [
    "xp"
  ],
  "_check_api_version": [
    "api_version"
  ],
  "array_namespace": [],
  "_check_device": [
    "bare_xp",
    "device"
  ],
  "_dask_device": {
    "__repr__": [
      "self"
    ]
  },
  "_DASK_DEVICE": [],
  "_device": [],
  "_cupy_to_device": [
    "stream"
  ],
  "_torch_to_device": [
    "stream"
  ],
  "to_device": [],
  "_is_writeable_cls": [
    "cls"
  ],
  "is_writeable_array": [
    "x"
  ],
  "_is_lazy_cls": [
    "cls"
  ],
  "is_lazy_array": [
    "x"
  ],
  "bool": [],
  "acos": [],
  "acosh": [],
  "asin": [],
  "asinh": [],
  "atan": [],
  "atan2": [],
  "atanh": [],
  "bitwise_left_shift": [],
  "bitwise_invert": [],
  "bitwise_right_shift": [],
  "concat": [],
  "pow": [],
  "_supports_buffer_protocol": [
    "obj"
  ],
  "asarray": [],
  "astype": [],
  "take_along_axis": [],
  "__array_namespace_info__": {
    "__module__": [],
    "capabilities": [
      "self"
    ],
    "default_device": [
      "self"
    ],
    "default_dtypes": [
      "self"
    ],
    "dtypes": [
      "self"
    ],
    "devices": [
      "self"
    ]
  },
  "solve": [],
  "_ensure_single_chunk": [
    "x",
    "axis"
  ],
  "_n": [],
  "fft_all": [],
  "linalg_all": [],
  "_int_dtypes": [],
  "_array_api_dtypes": [],
  "_promotion_table": [],
  "_two_arg": [
    "f"
  ],
  "_fix_promotion": [
    "x1",
    "x2",
    "only_scalar"
  ],
  "_py_scalars": [],
  "result_type": [],
  "_result_type": [
    "x",
    "y"
  ],
  "can_cast": [],
  "newaxis": [],
  "conj": [],
  "add": [],
  "bitwise_and": [],
  "bitwise_or": [],
  "bitwise_xor": [],
  "copysign": [],
  "divide": [],
  "equal": [],
  "floor_divide": [],
  "greater": [],
  "greater_equal": [],
  "hypot": [],
  "less": [],
  "less_equal": [],
  "logaddexp": [],
  "maximum": [],
  "minimum": [],
  "multiply": [],
  "not_equal": [],
  "remainder": [],
  "subtract": [],
  "max": [],
  "min": [],
  "_normalize_axes": [
    "axis",
    "ndim"
  ],
  "_axis_none_keepdims": [
    "x",
    "ndim",
    "keepdims"
  ],
  "_reduce_multiple_axes": [
    "f",
    "x",
    "axis",
    "keepdims"
  ],
  "_sum_prod_no_axis": [
    "x",
    "dtype"
  ],
  "prod": [],
  "sum": [],
  "any": [],
  "all": [],
  "squeeze": [
    "axis"
  ],
  "broadcast_to": [
    "shape"
  ],
  "flip": [],
  "roll": [
    "shift"
  ],
  "diff": [],
  "repeat": [],
  "where": [],
  "tril": [],
  "triu": [],
  "broadcast_arrays": [],
  "_vecdot": [],
  "take": [],
  "meshgrid": [],
  "__array_api_version__": [],
  "laplacian": [
    "csgraph",
    "normed",
    "return_diag",
    "use_out_degree"
  ],
  "_setdiag_dense": [
    "m",
    "d"
  ],
  "_laplace": [
    "m",
    "d"
  ],
  "_laplace_normed": [
    "m",
    "d",
    "nd"
  ],
  "_laplace_sym": [
    "m",
    "d"
  ],
  "_laplace_normed_sym": [
    "m",
    "d",
    "nd"
  ],
  "_linearoperator": [
    "mv",
    "shape",
    "dtype"
  ],
  "_laplacian_sparse_flo": [
    "graph",
    "normed",
    "axis",
    "copy",
    "form",
    "dtype",
    "symmetrized"
  ],
  "_laplacian_sparse": [
    "graph",
    "normed",
    "axis",
    "copy",
    "form",
    "dtype",
    "symmetrized"
  ],
  "_laplacian_dense_flo": [
    "graph",
    "normed",
    "axis",
    "copy",
    "form",
    "dtype",
    "symmetrized"
  ],
  "_laplacian_dense": [
    "graph",
    "normed",
    "axis",
    "copy",
    "form",
    "dtype",
    "symmetrized"
  ],
  "BaseLoss": {
    "differentiable": [],
    "need_update_leaves_values": [],
    "is_multiclass": [],
    "__init__": [
      "self",
      "closs",
      "link",
      "n_classes"
    ],
    "in_y_true_range": [
      "self",
      "y"
    ],
    "in_y_pred_range": [
      "self",
      "y"
    ],
    "loss": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "loss_out",
      "n_threads"
    ],
    "loss_gradient": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "loss_out",
      "gradient_out",
      "n_threads"
    ],
    "gradient": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "gradient_out",
      "n_threads"
    ],
    "gradient_hessian": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "gradient_out",
      "hessian_out",
      "n_threads"
    ],
    "__call__": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "n_threads"
    ],
    "fit_intercept_only": [
      "self",
      "y_true",
      "sample_weight"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ],
    "init_gradient_and_hessian": [
      "self",
      "n_samples",
      "dtype",
      "order"
    ]
  },
  "HalfSquaredError": {
    "__init__": [
      "self",
      "sample_weight"
    ]
  },
  "AbsoluteError": {
    "differentiable": [],
    "need_update_leaves_values": [],
    "__init__": [
      "self",
      "sample_weight"
    ],
    "fit_intercept_only": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "PinballLoss": {
    "differentiable": [],
    "need_update_leaves_values": [],
    "__init__": [
      "self",
      "sample_weight",
      "quantile"
    ],
    "fit_intercept_only": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "HuberLoss": {
    "differentiable": [],
    "need_update_leaves_values": [],
    "__init__": [
      "self",
      "sample_weight",
      "quantile",
      "delta"
    ],
    "fit_intercept_only": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "HalfPoissonLoss": {
    "__init__": [
      "self",
      "sample_weight"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "HalfGammaLoss": {
    "__init__": [
      "self",
      "sample_weight"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "HalfTweedieLoss": {
    "__init__": [
      "self",
      "sample_weight",
      "power"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ]
  },
  "HalfTweedieLossIdentity": {
    "__init__": [
      "self",
      "sample_weight",
      "power"
    ]
  },
  "HalfBinomialLoss": {
    "__init__": [
      "self",
      "sample_weight"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "raw_prediction"
    ]
  },
  "HalfMultinomialLoss": {
    "is_multiclass": [],
    "__init__": [
      "self",
      "sample_weight",
      "n_classes"
    ],
    "in_y_true_range": [
      "self",
      "y"
    ],
    "fit_intercept_only": [
      "self",
      "y_true",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "raw_prediction"
    ],
    "gradient_proba": [
      "self",
      "y_true",
      "raw_prediction",
      "sample_weight",
      "gradient_out",
      "proba_out",
      "n_threads"
    ]
  },
  "ExponentialLoss": {
    "__init__": [
      "self",
      "sample_weight"
    ],
    "constant_to_optimal_zero": [
      "self",
      "y_true",
      "sample_weight"
    ],
    "predict_proba": [
      "self",
      "raw_prediction"
    ]
  },
  "_inclusive_low_high": [
    "interval",
    "dtype"
  ],
  "BaseLink": {
    "is_multiclass": [],
    "interval_y_pred": [],
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": [
      "self",
      "raw_prediction",
      "out"
    ]
  },
  "IdentityLink": {
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": []
  },
  "LogLink": {
    "interval_y_pred": [],
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": [
      "self",
      "raw_prediction",
      "out"
    ]
  },
  "LogitLink": {
    "interval_y_pred": [],
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": [
      "self",
      "raw_prediction",
      "out"
    ]
  },
  "HalfLogitLink": {
    "interval_y_pred": [],
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": [
      "self",
      "raw_prediction",
      "out"
    ]
  },
  "MultinomialLogit": {
    "is_multiclass": [],
    "interval_y_pred": [],
    "symmetrize_raw_prediction": [
      "self",
      "raw_prediction"
    ],
    "link": [
      "self",
      "y_pred",
      "out"
    ],
    "inverse": [
      "self",
      "raw_prediction",
      "out"
    ]
  },
  "_LINKS": [],
  "LINK_FUNCTIONS": [],
  "test_interval_raises": [],
  "test_is_in_range": [
    "interval"
  ],
  "test_link_inverse_identity": [
    "link",
    "global_random_seed"
  ],
  "test_link_out_argument": [
    "link"
  ],
  "ALL_LOSSES": [],
  "LOSS_INSTANCES": [],
  "loss_instance_name": [
    "param"
  ],
  "random_y_true_raw_prediction": [
    "loss",
    "n_samples",
    "y_bound",
    "raw_bound",
    "seed"
  ],
  "numerical_derivative": [
    "func",
    "x",
    "eps"
  ],
  "test_loss_boundary": [
    "loss"
  ],
  "Y_COMMON_PARAMS": [],
  "Y_TRUE_PARAMS": [],
  "Y_PRED_PARAMS": [],
  "test_loss_boundary_y_true": [
    "loss",
    "y_true_success",
    "y_true_fail"
  ],
  "test_loss_boundary_y_pred": [
    "loss",
    "y_pred_success",
    "y_pred_fail"
  ],
  "test_loss_on_specific_values": [
    "loss",
    "y_true",
    "raw_prediction",
    "loss_true",
    "gradient_true",
    "hessian_true"
  ],
  "test_loss_dtype": [
    "loss",
    "readonly_memmap",
    "dtype_in",
    "dtype_out",
    "sample_weight",
    "out1",
    "out2",
    "n_threads"
  ],
  "test_loss_same_as_C_functions": [
    "loss",
    "sample_weight"
  ],
  "test_loss_gradients_are_the_same": [
    "loss",
    "sample_weight",
    "global_random_seed"
  ],
  "test_sample_weight_multiplies": [
    "loss",
    "sample_weight",
    "global_random_seed"
  ],
  "test_graceful_squeezing": [
    "loss"
  ],
  "test_loss_of_perfect_prediction": [
    "loss",
    "sample_weight"
  ],
  "test_derivatives": [
    "loss",
    "x0",
    "y_true"
  ],
  "test_loss_intercept_only": [
    "loss",
    "sample_weight"
  ],
  "test_specific_fit_intercept_only": [
    "loss",
    "func",
    "random_dist",
    "global_random_seed"
  ],
  "test_multinomial_loss_fit_intercept_only": [],
  "test_multinomial_cy_gradient": [
    "global_random_seed"
  ],
  "test_binomial_and_multinomial_loss": [
    "global_random_seed"
  ],
  "test_binomial_vs_alternative_formulation": [
    "y_true",
    "y_pred",
    "global_dtype"
  ],
  "test_init_gradient_and_hessians": [
    "loss",
    "sample_weight",
    "dtype",
    "order"
  ],
  "test_init_gradient_and_hessian_raises": [
    "loss",
    "params",
    "err_msg"
  ],
  "test_loss_init_parameter_validation": [
    "loss",
    "params",
    "err_type",
    "err_msg"
  ],
  "test_loss_pickle": [
    "loss"
  ],
  "test_tweedie_log_identity_consistency": [
    "p"
  ],
  "VarianceThreshold": {
    "__init__": [
      "self",
      "threshold"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_get_support_mask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SelectorMixin": {
    "get_support": [
      "self",
      "indices"
    ],
    "_get_support_mask": [
      "self"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "_get_feature_importances": [
    "estimator",
    "getter",
    "transform_func",
    "norm_order"
  ],
  "_rfe_single_fit": [
    "rfe",
    "estimator",
    "X",
    "y",
    "train",
    "test",
    "scorer",
    "routed_params"
  ],
  "RFECV": {
    "__metadata_request__fit": [],
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "_get_scorer": [
      "self"
    ]
  },
  "_clean_nans": [
    "scores"
  ],
  "f_oneway": [],
  "f_classif": [
    "X",
    "y"
  ],
  "_chisquare": [
    "f_obs",
    "f_exp"
  ],
  "chi2": [
    "X",
    "y"
  ],
  "r_regression": [
    "X",
    "y"
  ],
  "f_regression": [
    "X",
    "y"
  ],
  "_BaseFilter": {
    "__init__": [
      "self",
      "score_func"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_check_params": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SelectPercentile": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_get_support_mask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SelectKBest": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_check_params": [
      "self",
      "X",
      "y"
    ],
    "_get_support_mask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SelectFpr": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_get_support_mask": [
      "self"
    ]
  },
  "SelectFdr": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_get_support_mask": [
      "self"
    ]
  },
  "SelectFwe": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_get_support_mask": [
      "self"
    ]
  },
  "GenericUnivariateSelect": {
    "__init__": [
      "self",
      "score_func"
    ],
    "_make_selector": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "_check_params": [
      "self",
      "X",
      "y"
    ],
    "_get_support_mask": [
      "self"
    ]
  },
  "SequentialFeatureSelector": {
    "__init__": [
      "self",
      "estimator"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_get_best_new_feature_score": [
      "self",
      "estimator",
      "X",
      "y",
      "cv",
      "current_mask"
    ],
    "_get_support_mask": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "_compute_mi_cc": [
    "x",
    "y",
    "n_neighbors"
  ],
  "_compute_mi_cd": [
    "c",
    "d",
    "n_neighbors"
  ],
  "_compute_mi": [
    "x",
    "y",
    "x_discrete",
    "y_discrete",
    "n_neighbors"
  ],
  "_iterate_columns": [
    "X",
    "columns"
  ],
  "_estimate_mi": [
    "X",
    "y"
  ],
  "mutual_info_regression": [
    "X",
    "y"
  ],
  "mutual_info_classif": [
    "X",
    "y"
  ],
  "_calculate_threshold": [
    "estimator",
    "importances",
    "threshold"
  ],
  "SelectFromModel": {
    "__init__": [
      "self",
      "estimator"
    ],
    "_get_support_mask": [
      "self"
    ],
    "_check_max_features": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "threshold_": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "n_features_in_": [
      "self"
    ],
    "get_metadata_routing": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "test_compute_mi_dd": [],
  "test_compute_mi_cc": [
    "global_dtype"
  ],
  "test_compute_mi_cd": [
    "global_dtype"
  ],
  "test_compute_mi_cd_unique_label": [
    "global_dtype"
  ],
  "test_mutual_info_classif_discrete": [
    "global_dtype"
  ],
  "test_mutual_info_regression": [
    "global_dtype"
  ],
  "test_mutual_info_classif_mixed": [
    "global_dtype"
  ],
  "test_mutual_info_options": [
    "global_dtype",
    "csr_container"
  ],
  "test_mutual_information_symmetry_classif_regression": [
    "correlated",
    "global_random_seed"
  ],
  "test_mutual_info_regression_X_int_dtype": [
    "global_random_seed"
  ],
  "test_mutual_info_n_jobs": [
    "global_random_seed",
    "mutual_info_func",
    "data_generator"
  ],
  "NaNTagRandomForest": {
    "__sklearn_tags__": [
      "self"
    ]
  },
  "test_invalid_input": [],
  "test_input_estimator_unchanged": [],
  "test_max_features_error": [
    "max_features",
    "err_type",
    "err_msg"
  ],
  "test_inferred_max_features_integer": [
    "max_features"
  ],
  "test_inferred_max_features_callable": [
    "max_features"
  ],
  "test_max_features_array_like": [
    "max_features"
  ],
  "test_max_features_callable_data": [
    "max_features"
  ],
  "FixedImportanceEstimator": {
    "__init__": [
      "self",
      "importances"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "test_max_features_tiebreak": [],
  "test_threshold_and_max_features": [],
  "test_coef_default_threshold": [
    "estimator"
  ],
  "test_2d_coef": [],
  "test_calling_fit_reinitializes": [],
  "test_prefit": [],
  "test_prefit_max_features": [],
  "test_get_feature_names_out_elasticnetcv": [],
  "test_prefit_get_feature_names_out": [],
  "test_threshold_string": [],
  "test_threshold_without_refitting": [],
  "test_fit_accepts_nan_inf": [],
  "test_transform_accepts_nan_inf": [],
  "test_allow_nan_tag_comes_from_estimator": [],
  "_pca_importances": [
    "pca_estimator"
  ],
  "test_importance_getter": [
    "estimator",
    "importance_getter"
  ],
  "test_select_from_model_pls": [
    "PLSEstimator"
  ],
  "test_estimator_does_not_support_feature_names": [],
  "test_partial_fit_validate_feature_names": [
    "as_frame"
  ],
  "test_from_model_estimator_attribute_error": [],
  "test_bad_n_features_to_select": [],
  "test_n_features_to_select": [
    "direction",
    "n_features_to_select"
  ],
  "test_n_features_to_select_auto": [
    "direction"
  ],
  "test_n_features_to_select_stopping_criterion": [
    "direction"
  ],
  "test_n_features_to_select_float": [
    "direction",
    "n_features_to_select",
    "expected"
  ],
  "test_sanity": [
    "seed",
    "direction",
    "n_features_to_select",
    "expected_selected_features"
  ],
  "test_sparse_support": [
    "csr_container"
  ],
  "test_nan_support": [],
  "test_pipeline_support": [],
  "test_unsupervised_model_fit": [
    "n_features_to_select"
  ],
  "test_no_y_validation_model_fit": [
    "y"
  ],
  "test_forward_neg_tol_error": [],
  "test_backward_neg_tol": [],
  "test_cv_generator_support": [],
  "test_fit_rejects_params_with_no_routing_enabled": [],
  "test_f_oneway_vs_scipy_stats": [],
  "test_f_oneway_ints": [],
  "test_f_classif": [
    "csr_container"
  ],
  "test_r_regression": [
    "center"
  ],
  "test_f_regression": [
    "csr_container"
  ],
  "test_f_regression_input_dtype": [],
  "test_f_regression_center": [],
  "test_r_regression_force_finite": [
    "X",
    "y",
    "expected_corr_coef",
    "force_finite"
  ],
  "test_f_regression_corner_case": [
    "X",
    "y",
    "expected_f_statistic",
    "expected_p_values",
    "force_finite"
  ],
  "test_f_classif_multi_class": [],
  "test_select_percentile_classif": [],
  "test_select_percentile_classif_sparse": [
    "csr_container"
  ],
  "test_select_kbest_classif": [],
  "test_select_kbest_all": [],
  "test_select_kbest_zero": [
    "dtype_in"
  ],
  "test_select_heuristics_classif": [],
  "assert_best_scores_kept": [
    "score_filter"
  ],
  "test_select_percentile_regression": [],
  "test_select_percentile_regression_full": [],
  "test_select_kbest_regression": [],
  "test_select_heuristics_regression": [],
  "test_boundary_case_ch2": [],
  "test_select_fdr_regression": [
    "alpha",
    "n_informative"
  ],
  "test_select_fwe_regression": [],
  "test_selectkbest_tiebreaking": [],
  "test_selectpercentile_tiebreaking": [],
  "test_tied_pvalues": [],
  "test_scorefunc_multilabel": [],
  "test_tied_scores": [],
  "test_nans": [],
  "test_invalid_k": [],
  "test_f_classif_constant_feature": [],
  "test_no_feature_selected": [],
  "test_mutual_info_classif": [],
  "test_dataframe_output_dtypes": [],
  "test_unsupervised_filter": [
    "selector"
  ],
  "data2": [],
  "test_zero_variance": [
    "sparse_container"
  ],
  "test_zero_variance_value_error": [],
  "test_variance_threshold": [
    "sparse_container"
  ],
  "test_zero_variance_floating_point_error": [
    "sparse_container"
  ],
  "test_variance_nan": [
    "sparse_container"
  ],
  "StepSelector": {
    "__init__": [
      "self",
      "step"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_get_support_mask": [
      "self"
    ]
  },
  "support": [],
  "support_inds": [],
  "Xt": [],
  "Xinv": [],
  "feature_names": [],
  "feature_names_t": [],
  "feature_names_inv": [],
  "test_transform_dense": [],
  "test_transform_sparse": [
    "csc_container"
  ],
  "test_inverse_transform_dense": [],
  "test_inverse_transform_sparse": [
    "csc_container"
  ],
  "test_get_support": [],
  "test_output_dataframe": [],
  "test_rfe_features_importance": [],
  "test_rfe": [
    "csr_container"
  ],
  "test_RFE_fit_score_params": [],
  "test_rfe_percent_n_features": [],
  "test_rfe_mockclassifier": [],
  "test_rfecv": [
    "csr_container"
  ],
  "test_rfecv_mockclassifier": [],
  "test_rfecv_verbose_output": [],
  "test_rfecv_cv_results_size": [
    "global_random_seed"
  ],
  "test_rfe_estimator_tags": [],
  "test_rfe_min_step": [
    "global_random_seed"
  ],
  "test_number_of_subsets_of_features": [
    "global_random_seed"
  ],
  "test_rfe_cv_n_jobs": [
    "global_random_seed"
  ],
  "test_rfe_cv_groups": [],
  "test_rfe_wrapped_estimator": [
    "importance_getter",
    "selector",
    "expected_n_features"
  ],
  "test_rfe_importance_getter_validation": [
    "importance_getter",
    "err_type",
    "Selector"
  ],
  "test_rfe_allow_nan_inf_in_x": [
    "cv"
  ],
  "test_w_pipeline_2d_coef_": [],
  "test_rfecv_std_and_mean": [
    "global_random_seed"
  ],
  "test_rfecv_cv_results_n_features": [
    "min_features_to_select",
    "n_features",
    "step",
    "cv_results_n_features"
  ],
  "test_pipeline_with_nans": [
    "ClsRFE"
  ],
  "test_rfe_pls": [
    "ClsRFE",
    "PLSEstimator"
  ],
  "test_rfe_estimator_attribute_error": [],
  "test_rfe_n_features_to_select_warning": [
    "ClsRFE",
    "param"
  ],
  "test_rfe_with_sample_weight": [],
  "test_rfe_with_joblib_threading_backend": [
    "global_random_seed"
  ],
  "test_results_per_cv_in_rfecv": [
    "global_random_seed"
  ],
  "mkchi2": [
    "k"
  ],
  "test_chi2": [
    "csr_container"
  ],
  "test_chi2_coo": [
    "coo_container"
  ],
  "test_chi2_negative": [
    "csr_container"
  ],
  "test_chi2_unused_feature": [],
  "test_chisquare": [],
  "_iterate_sparse_X": [
    "X"
  ],
  "_split_node": [
    "node",
    "threshold",
    "branching_factor"
  ],
  "_CFNode": {
    "__init__": [
      "self"
    ],
    "append_subcluster": [
      "self",
      "subcluster"
    ],
    "update_split_subclusters": [
      "self",
      "subcluster",
      "new_subcluster1",
      "new_subcluster2"
    ],
    "insert_cf_subcluster": [
      "self",
      "subcluster"
    ]
  },
  "_CFSubcluster": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "subcluster"
    ],
    "merge_subcluster": [
      "self",
      "nominee_cluster",
      "threshold"
    ],
    "radius": [
      "self"
    ]
  },
  "Birch": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "partial"
    ],
    "_get_leaves": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_global_clustering": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "estimate_bandwidth": [
    "X"
  ],
  "_mean_shift_single_seed": [
    "my_mean",
    "X",
    "nbrs",
    "max_iter"
  ],
  "mean_shift": [
    "X"
  ],
  "get_bin_seeds": [
    "X",
    "bin_size",
    "min_bin_freq"
  ],
  "MeanShift": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "kmeans_plusplus": [
    "X",
    "n_clusters"
  ],
  "_kmeans_plusplus": [
    "X",
    "n_clusters",
    "x_squared_norms",
    "sample_weight",
    "random_state",
    "n_local_trials"
  ],
  "_tolerance": [
    "X",
    "tol"
  ],
  "k_means": [
    "X",
    "n_clusters"
  ],
  "_kmeans_single_elkan": [
    "X",
    "sample_weight",
    "centers_init",
    "max_iter",
    "verbose",
    "tol",
    "n_threads"
  ],
  "_kmeans_single_lloyd": [
    "X",
    "sample_weight",
    "centers_init",
    "max_iter",
    "verbose",
    "tol",
    "n_threads"
  ],
  "_labels_inertia": [
    "X",
    "sample_weight",
    "centers",
    "n_threads",
    "return_inertia"
  ],
  "_labels_inertia_threadpool_limit": [],
  "_BaseKMeans": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_check_params_vs_input": [
      "self",
      "X",
      "default_n_init"
    ],
    "_warn_mkl_vcomp": [
      "self",
      "n_active_threads"
    ],
    "_check_mkl_vcomp": [
      "self",
      "X",
      "n_samples"
    ],
    "_validate_center_shape": [
      "self",
      "X",
      "centers"
    ],
    "_check_test_data": [
      "self",
      "X"
    ],
    "_init_centroids": [
      "self",
      "X",
      "x_squared_norms",
      "init",
      "random_state",
      "sample_weight",
      "init_size",
      "n_centroids"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_transform": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KMeans": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_check_params_vs_input": [
      "self",
      "X"
    ],
    "_warn_mkl_vcomp": [
      "self",
      "n_active_threads"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "_mini_batch_step": [
    "X",
    "sample_weight",
    "centers",
    "centers_new",
    "weight_sums",
    "random_state",
    "random_reassign",
    "reassignment_ratio",
    "verbose",
    "n_threads"
  ],
  "MiniBatchKMeans": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_check_params_vs_input": [
      "self",
      "X"
    ],
    "_warn_mkl_vcomp": [
      "self",
      "n_active_threads"
    ],
    "_mini_batch_convergence": [
      "self",
      "step",
      "n_steps",
      "n_samples",
      "centers_squared_diff",
      "batch_inertia"
    ],
    "_random_reassign": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "partial_fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "_fix_connectivity": [
    "X",
    "connectivity",
    "affinity"
  ],
  "_single_linkage_tree": [
    "connectivity",
    "n_samples",
    "n_nodes",
    "n_clusters",
    "n_connected_components",
    "return_distance"
  ],
  "ward_tree": [
    "X"
  ],
  "linkage_tree": [
    "X",
    "connectivity",
    "n_clusters",
    "linkage",
    "affinity",
    "return_distance"
  ],
  "_complete_linkage": [],
  "_average_linkage": [],
  "_single_linkage": [],
  "_TREE_BUILDERS": [],
  "_hc_cut": [
    "n_clusters",
    "children",
    "n_leaves"
  ],
  "AgglomerativeClustering": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "FeatureAgglomeration": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self"
    ]
  },
  "_equal_similarities_and_preferences": [
    "S",
    "preference"
  ],
  "_affinity_propagation": [
    "S"
  ],
  "affinity_propagation": [
    "S"
  ],
  "AffinityPropagation": {
    "__init__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ]
  },
  "dbscan": [
    "X",
    "eps"
  ],
  "DBSCAN": {
    "__init__": [
      "self",
      "eps"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "fit_predict": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "AgglomerationTransform": {
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "OPTICS": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_validate_size": [
    "size",
    "n_samples",
    "param_name"
  ],
  "_compute_core_distances_": [
    "X",
    "neighbors",
    "min_samples",
    "working_memory"
  ],
  "compute_optics_graph": [
    "X"
  ],
  "_set_reach_dist": [
    "core_distances_",
    "reachability_",
    "predecessor_",
    "point_index",
    "processed",
    "X",
    "nbrs",
    "metric",
    "metric_params",
    "p",
    "max_eps"
  ],
  "cluster_optics_dbscan": [],
  "cluster_optics_xi": [],
  "_extend_region": [
    "steep_point",
    "xward_point",
    "start",
    "min_samples"
  ],
  "_update_filter_sdas": [
    "sdas",
    "mib",
    "xi_complement",
    "reachability_plot"
  ],
  "_correct_predecessor": [
    "reachability_plot",
    "predecessor_plot",
    "ordering",
    "s",
    "e"
  ],
  "_xi_cluster": [
    "reachability_plot",
    "predecessor_plot",
    "ordering",
    "xi",
    "min_samples",
    "min_cluster_size",
    "predecessor_correction"
  ],
  "_extract_xi_labels": [
    "ordering",
    "clusters"
  ],
  "_scale_normalize": [
    "X"
  ],
  "_bistochastic_normalize": [
    "X",
    "max_iter",
    "tol"
  ],
  "_log_normalize": [
    "X"
  ],
  "BaseSpectral": {
    "__init__": [
      "self",
      "n_clusters",
      "svd_method",
      "n_svd_vecs",
      "mini_batch",
      "init",
      "n_init",
      "random_state"
    ],
    "_check_parameters": [
      "self",
      "n_samples"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_svd": [
      "self",
      "array",
      "n_components",
      "n_discard"
    ],
    "_k_means": [
      "self",
      "data",
      "n_clusters"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SpectralCoclustering": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_check_parameters": [
      "self",
      "n_samples"
    ],
    "_fit": [
      "self",
      "X"
    ]
  },
  "SpectralBiclustering": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_check_parameters": [
      "self",
      "n_samples"
    ],
    "_fit": [
      "self",
      "X"
    ],
    "_fit_best_piecewise": [
      "self",
      "vectors",
      "n_best",
      "n_clusters"
    ],
    "_project_and_cluster": [
      "self",
      "data",
      "vectors",
      "n_clusters"
    ]
  },
  "_BisectingTree": {
    "__init__": [
      "self",
      "center",
      "indices",
      "score"
    ],
    "split": [
      "self",
      "labels",
      "centers",
      "scores"
    ],
    "get_cluster_to_bisect": [
      "self"
    ],
    "iter_leaves": [
      "self"
    ]
  },
  "BisectingKMeans": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "_warn_mkl_vcomp": [
      "self",
      "n_active_threads"
    ],
    "_inertia_per_cluster": [
      "self",
      "X",
      "centers",
      "labels",
      "sample_weight"
    ],
    "_bisect": [
      "self",
      "X",
      "x_squared_norms",
      "sample_weight",
      "cluster_to_bisect"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "predict": [
      "self",
      "X"
    ],
    "_predict_recursive": [
      "self",
      "X",
      "sample_weight",
      "cluster_node"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "cluster_qr": [
    "vectors"
  ],
  "discretize": [
    "vectors"
  ],
  "spectral_clustering": [
    "affinity"
  ],
  "SpectralClustering": {
    "__init__": [
      "self",
      "n_clusters"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "FAST_METRICS": [],
  "_brute_mst": [
    "mutual_reachability",
    "min_samples"
  ],
  "_process_mst": [
    "min_spanning_tree"
  ],
  "_hdbscan_brute": [
    "X",
    "min_samples",
    "alpha",
    "metric",
    "n_jobs",
    "copy"
  ],
  "_hdbscan_prims": [
    "X",
    "algo",
    "min_samples",
    "alpha",
    "metric",
    "leaf_size",
    "n_jobs"
  ],
  "remap_single_linkage_tree": [
    "tree",
    "internal_to_raw",
    "non_finite"
  ],
  "_get_finite_row_indices": [
    "matrix"
  ],
  "HDBSCAN": {
    "_parameter_constraints": [],
    "__init__": [
      "self",
      "min_cluster_size",
      "min_samples",
      "cluster_selection_epsilon",
      "max_cluster_size",
      "metric",
      "metric_params",
      "alpha",
      "algorithm",
      "leaf_size",
      "n_jobs",
      "cluster_selection_method",
      "allow_single_cluster",
      "store_centers",
      "copy"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_predict": [
      "self",
      "X",
      "y"
    ],
    "_weighted_cluster_center": [
      "self",
      "X"
    ],
    "dbscan_clustering": [
      "self",
      "cut_distance",
      "min_cluster_size"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "test_mutual_reachability_graph_error_sparse_format": [],
  "test_mutual_reachability_graph_inplace": [
    "array_type"
  ],
  "test_mutual_reachability_graph_equivalence_dense_sparse": [],
  "test_mutual_reachability_graph_preserves_dtype": [
    "array_type",
    "dtype"
  ],
  "generate_clustered_data": [
    "seed",
    "n_clusters",
    "n_features",
    "n_samples_per_cluster",
    "std"
  ],
  "test_linkage_misc": [],
  "test_structured_linkage_tree": [],
  "test_unstructured_linkage_tree": [],
  "test_height_linkage_tree": [],
  "test_zero_cosine_linkage_tree": [],
  "test_agglomerative_clustering_distances": [
    "n_clusters",
    "compute_distances",
    "distance_threshold",
    "linkage"
  ],
  "test_agglomerative_clustering": [
    "global_random_seed",
    "lil_container"
  ],
  "test_agglomerative_clustering_memory_mapped": [],
  "test_ward_agglomeration": [
    "global_random_seed"
  ],
  "test_single_linkage_clustering": [],
  "assess_same_labelling": [
    "cut1",
    "cut2"
  ],
  "test_sparse_scikit_vs_scipy": [
    "global_random_seed"
  ],
  "test_vector_scikit_single_vs_scipy_single": [
    "global_random_seed"
  ],
  "test_mst_linkage_core_memory_mapped": [
    "metric_param_grid"
  ],
  "test_identical_points": [],
  "test_connectivity_propagation": [],
  "test_ward_tree_children_order": [
    "global_random_seed"
  ],
  "test_ward_linkage_tree_return_distance": [
    "global_random_seed"
  ],
  "test_connectivity_fixing_non_lil": [],
  "test_connectivity_callable": [],
  "test_connectivity_ignores_diagonal": [],
  "test_compute_full_tree": [],
  "test_affinity_passed_to_fix_connectivity": [],
  "test_agglomerative_clustering_with_distance_threshold": [
    "linkage",
    "global_random_seed"
  ],
  "test_small_distance_threshold": [
    "global_random_seed"
  ],
  "test_cluster_distances_with_distance_threshold": [
    "global_random_seed"
  ],
  "test_agglomerative_clustering_with_distance_threshold_edge_case": [
    "linkage",
    "threshold",
    "y_true"
  ],
  "test_dist_threshold_invalid_parameters": [],
  "test_invalid_shape_precomputed_dist_matrix": [],
  "test_precomputed_connectivity_metric_with_2_connected_components": [],
  "test_feature_agglomeration": [],
  "test_feature_agglomeration_feature_names_out": [],
  "n_clusters": [],
  "test_affinity_propagation": [
    "global_random_seed",
    "global_dtype"
  ],
  "test_affinity_propagation_precomputed": [],
  "test_affinity_propagation_no_copy": [],
  "test_affinity_propagation_affinity_shape": [],
  "test_affinity_propagation_precomputed_with_sparse_input": [
    "csr_container"
  ],
  "test_affinity_propagation_predict": [
    "global_random_seed",
    "global_dtype"
  ],
  "test_affinity_propagation_predict_error": [],
  "test_affinity_propagation_fit_non_convergence": [
    "global_dtype"
  ],
  "test_affinity_propagation_equal_mutual_similarities": [
    "global_dtype"
  ],
  "test_affinity_propagation_predict_non_convergence": [
    "global_dtype"
  ],
  "test_affinity_propagation_non_convergence_regressiontest": [
    "global_dtype"
  ],
  "test_equal_similarities_and_preferences": [
    "global_dtype"
  ],
  "test_affinity_propagation_random_state": [],
  "test_affinity_propagation_convergence_warning_dense_sparse": [
    "container",
    "global_dtype"
  ],
  "test_correct_clusters": [
    "global_dtype"
  ],
  "test_sparse_input_for_predict": [
    "csr_container"
  ],
  "test_sparse_input_for_fit_predict": [
    "csr_container"
  ],
  "test_affinity_propagation_equal_points": [],
  "test_three_clusters": [
    "bisecting_strategy",
    "init"
  ],
  "test_n_clusters": [
    "n_clusters"
  ],
  "test_one_cluster": [],
  "test_fit_predict": [
    "csr_container"
  ],
  "test_dtype_preserved": [
    "csr_container",
    "global_dtype"
  ],
  "test_float32_float64_equivalence": [
    "csr_container"
  ],
  "test_no_crash_on_empty_bisections": [
    "algorithm"
  ],
  "test_one_feature": [],
  "OUTLIER_SET": [],
  "check_label_quality": [
    "labels",
    "threshold"
  ],
  "test_outlier_data": [
    "outlier_type"
  ],
  "test_hdbscan_distance_matrix": [],
  "test_hdbscan_sparse_distance_matrix": [
    "sparse_constructor"
  ],
  "test_hdbscan_feature_array": [],
  "test_hdbscan_algorithms": [
    "algo",
    "metric"
  ],
  "test_dbscan_clustering": [],
  "test_dbscan_clustering_outlier_data": [
    "cut_distance"
  ],
  "test_hdbscan_best_balltree_metric": [],
  "test_hdbscan_no_clusters": [],
  "test_hdbscan_min_cluster_size": [],
  "test_hdbscan_callable_metric": [],
  "test_hdbscan_precomputed_non_brute": [
    "tree"
  ],
  "test_hdbscan_sparse": [
    "csr_container"
  ],
  "test_hdbscan_centers": [
    "algorithm"
  ],
  "test_hdbscan_allow_single_cluster_with_epsilon": [],
  "test_hdbscan_better_than_dbscan": [],
  "test_hdbscan_usable_inputs": [
    "X",
    "kwargs"
  ],
  "test_hdbscan_sparse_distances_too_few_nonzero": [
    "csr_container"
  ],
  "test_hdbscan_sparse_distances_disconnected_graph": [
    "csr_container"
  ],
  "test_hdbscan_tree_invalid_metric": [],
  "test_hdbscan_too_many_min_samples": [],
  "test_hdbscan_precomputed_dense_nan": [],
  "test_labelling_distinct": [
    "global_random_seed",
    "allow_single_cluster",
    "epsilon"
  ],
  "test_labelling_thresholding": [],
  "test_hdbscan_error_precomputed_and_store_centers": [
    "store_centers"
  ],
  "test_hdbscan_cosine_metric_valid_algorithm": [
    "valid_algo"
  ],
  "test_hdbscan_cosine_metric_invalid_algorithm": [
    "invalid_algo"
  ],
  "test_hdbscan_default_copy_warning": [],
  "test_convergence_of_1d_constant_data": [],
  "test_estimate_bandwidth": [],
  "test_estimate_bandwidth_1sample": [
    "global_dtype"
  ],
  "test_mean_shift": [
    "global_dtype",
    "bandwidth",
    "cluster_all",
    "expected",
    "first_cluster_label"
  ],
  "test_meanshift_predict": [
    "global_dtype"
  ],
  "test_meanshift_all_orphans": [],
  "test_cluster_intensity_tie": [
    "global_dtype"
  ],
  "test_bin_seeds": [
    "global_dtype"
  ],
  "test_mean_shift_zero_bandwidth": [
    "global_dtype"
  ],
  "test_dbscan_similarity": [],
  "test_dbscan_feature": [],
  "test_dbscan_sparse": [
    "lil_container"
  ],
  "test_dbscan_sparse_precomputed": [
    "include_self"
  ],
  "test_dbscan_sparse_precomputed_different_eps": [],
  "test_dbscan_input_not_modified": [
    "metric",
    "csr_container"
  ],
  "test_dbscan_input_not_modified_precomputed_sparse_nodiag": [
    "csr_container"
  ],
  "test_dbscan_no_core_samples": [
    "csr_container"
  ],
  "test_dbscan_callable": [],
  "test_dbscan_metric_params": [],
  "test_dbscan_balltree": [],
  "test_boundaries": [],
  "test_weighted_dbscan": [
    "global_random_seed"
  ],
  "test_dbscan_core_samples_toy": [
    "algorithm"
  ],
  "test_dbscan_precomputed_metric_with_degenerate_input_arrays": [],
  "test_dbscan_precomputed_metric_with_initial_rows_zero": [
    "csr_container"
  ],
  "test_spectral_clustering_sparse": [
    "assign_labels",
    "coo_container",
    "global_random_seed"
  ],
  "test_affinities": [
    "global_random_seed"
  ],
  "test_cluster_qr": [
    "global_random_seed"
  ],
  "test_cluster_qr_permutation_invariance": [
    "global_random_seed"
  ],
  "test_discretize": [
    "n_samples",
    "coo_container",
    "global_random_seed"
  ],
  "test_spectral_clustering_with_arpack_amg_solvers": [
    "global_random_seed"
  ],
  "test_spectral_clustering_np_matrix_raises": [],
  "test_spectral_clustering_not_infinite_loop": [
    "capsys",
    "monkeypatch"
  ],
  "MockBiclustering": {
    "__init__": [
      "self"
    ],
    "get_indices": [
      "self",
      "i"
    ]
  },
  "test_get_submatrix": [
    "csr_container"
  ],
  "_test_shape_indices": [
    "model"
  ],
  "test_spectral_coclustering": [
    "global_random_seed",
    "csr_container"
  ],
  "test_spectral_biclustering": [
    "global_random_seed",
    "csr_container"
  ],
  "_do_scale_test": [
    "scaled"
  ],
  "_do_bistochastic_test": [
    "scaled"
  ],
  "test_scale_normalize": [
    "global_random_seed",
    "csr_container"
  ],
  "test_bistochastic_normalize": [
    "global_random_seed",
    "csr_container"
  ],
  "test_log_normalize": [
    "global_random_seed"
  ],
  "test_fit_best_piecewise": [
    "global_random_seed"
  ],
  "test_project_and_cluster": [
    "global_random_seed",
    "csr_container"
  ],
  "test_perfect_checkerboard": [
    "global_random_seed"
  ],
  "test_spectralbiclustering_parameter_validation": [
    "params",
    "type_err",
    "err_msg"
  ],
  "test_n_features_in_": [
    "est"
  ],
  "n_points_per_cluster": [],
  "C1": [],
  "C2": [],
  "C3": [],
  "C4": [],
  "C5": [],
  "C6": [],
  "test_extend_downward": [
    "r_plot",
    "end"
  ],
  "test_extend_upward": [
    "r_plot",
    "end"
  ],
  "test_the_extract_xi_labels": [
    "ordering",
    "clusters",
    "expected"
  ],
  "test_extract_xi": [
    "global_dtype"
  ],
  "test_cluster_hierarchy": [
    "global_dtype",
    "global_random_seed"
  ],
  "test_correct_number_of_clusters": [
    "metric",
    "csr_container"
  ],
  "test_minimum_number_of_sample_check": [],
  "test_bad_extract": [],
  "test_bad_reachability": [],
  "test_nowarn_if_metric_bool_data_bool": [],
  "test_warn_if_metric_bool_data_no_bool": [],
  "test_nowarn_if_metric_no_bool": [],
  "test_close_extract": [],
  "test_dbscan_optics_parity": [
    "eps",
    "min_samples",
    "metric",
    "global_dtype",
    "csr_container"
  ],
  "test_min_samples_edge_case": [
    "global_dtype"
  ],
  "test_min_cluster_size": [
    "min_cluster_size",
    "global_dtype"
  ],
  "test_min_cluster_size_invalid2": [
    "csr_container"
  ],
  "test_processing_order": [],
  "test_compare_to_ELKI": [],
  "test_extract_dbscan": [
    "global_dtype",
    "global_random_seed"
  ],
  "test_precomputed_dists": [
    "global_dtype",
    "csr_container"
  ],
  "test_optics_input_not_modified_precomputed_sparse_nodiag": [
    "csr_container",
    "global_random_seed"
  ],
  "test_optics_predecessor_correction_ordering": [],
  "test_n_samples_leaves_roots": [
    "global_random_seed",
    "global_dtype"
  ],
  "test_birch_predict": [
    "global_random_seed",
    "global_dtype"
  ],
  "test_sparse_X": [
    "global_random_seed",
    "global_dtype",
    "csr_container"
  ],
  "test_partial_fit_second_call_error_checks": [],
  "check_branching_factor": [
    "node",
    "branching_factor"
  ],
  "test_branching_factor": [
    "global_random_seed",
    "global_dtype"
  ],
  "check_threshold": [
    "birch_instance",
    "threshold"
  ],
  "test_threshold": [
    "global_random_seed",
    "global_dtype"
  ],
  "test_birch_n_clusters_long_int": [],
  "test_transform_match_across_dtypes": [
    "global_random_seed"
  ],
  "test_subcluster_dtype": [
    "global_dtype"
  ],
  "test_both_subclusters_updated": [],
  "X_as_any_csr": [],
  "data_containers": [],
  "data_containers_ids": [],
  "test_kmeans_results": [
    "array_constr",
    "algo",
    "dtype"
  ],
  "test_kmeans_relocated_clusters": [
    "array_constr",
    "algo"
  ],
  "test_relocate_empty_clusters": [
    "array_constr"
  ],
  "test_kmeans_elkan_results": [
    "distribution",
    "array_constr",
    "tol",
    "global_random_seed"
  ],
  "test_kmeans_convergence": [
    "algorithm",
    "global_random_seed"
  ],
  "test_minibatch_update_consistency": [
    "X_csr",
    "global_random_seed"
  ],
  "_check_fitted_model": [
    "km"
  ],
  "test_all_init": [
    "Estimator",
    "input_data",
    "init"
  ],
  "test_minibatch_kmeans_partial_fit_init": [
    "init"
  ],
  "test_kmeans_init_auto_with_initial_centroids": [
    "Estimator",
    "init",
    "expected_n_init"
  ],
  "test_fortran_aligned_data": [
    "Estimator",
    "global_random_seed"
  ],
  "test_minibatch_kmeans_verbose": [],
  "test_kmeans_verbose": [
    "algorithm",
    "tol",
    "capsys"
  ],
  "test_minibatch_kmeans_warning_init_size": [],
  "test_warning_n_init_precomputed_centers": [
    "Estimator"
  ],
  "test_minibatch_sensible_reassign": [
    "global_random_seed"
  ],
  "test_minibatch_reassign": [
    "input_data",
    "global_random_seed"
  ],
  "test_minibatch_with_many_reassignments": [],
  "test_minibatch_kmeans_init_size": [],
  "test_minibatch_declared_convergence": [
    "capsys",
    "tol",
    "max_no_improvement"
  ],
  "test_minibatch_iter_steps": [],
  "test_kmeans_copyx": [],
  "test_score_max_iter": [
    "Estimator",
    "global_random_seed"
  ],
  "test_kmeans_predict": [
    "Estimator",
    "algorithm",
    "array_constr",
    "max_iter",
    "global_dtype",
    "global_random_seed"
  ],
  "test_predict_dense_sparse": [
    "Estimator",
    "init",
    "X_csr"
  ],
  "test_n_init": [
    "global_random_seed"
  ],
  "test_k_means_function": [
    "global_random_seed"
  ],
  "test_float_precision": [
    "Estimator",
    "input_data",
    "global_random_seed"
  ],
  "test_centers_not_mutated": [
    "Estimator",
    "dtype"
  ],
  "test_kmeans_init_fitted_centers": [
    "input_data"
  ],
  "test_kmeans_warns_less_centers_than_unique_points": [
    "global_random_seed"
  ],
  "_sort_centers": [
    "centers"
  ],
  "test_weighted_vs_repeated": [
    "global_random_seed"
  ],
  "test_unit_weights_vs_no_weights": [
    "Estimator",
    "input_data",
    "global_random_seed"
  ],
  "test_scaled_weights": [
    "Estimator",
    "input_data",
    "global_random_seed"
  ],
  "test_kmeans_elkan_iter_attribute": [],
  "test_kmeans_empty_cluster_relocated": [
    "array_constr"
  ],
  "test_result_equal_in_diff_n_threads": [
    "Estimator",
    "global_random_seed"
  ],
  "test_warning_elkan_1_cluster": [],
  "test_k_means_1_iteration": [
    "array_constr",
    "algo",
    "global_random_seed"
  ],
  "test_euclidean_distance": [
    "dtype",
    "squared",
    "global_random_seed"
  ],
  "test_inertia": [
    "dtype",
    "global_random_seed"
  ],
  "test_n_init_auto": [
    "Klass",
    "default_n_init"
  ],
  "test_sample_weight_unchanged": [
    "Estimator"
  ],
  "test_wrong_params": [
    "Estimator",
    "param",
    "match"
  ],
  "test_kmeans_plusplus_wrong_params": [
    "param",
    "match"
  ],
  "test_kmeans_plusplus_output": [
    "input_data",
    "dtype",
    "global_random_seed"
  ],
  "test_kmeans_plusplus_norms": [
    "x_squared_norms"
  ],
  "test_kmeans_plusplus_dataorder": [
    "global_random_seed"
  ],
  "test_is_same_clustering": [],
  "test_kmeans_with_array_like_or_np_scalar_init": [
    "kwargs"
  ],
  "test_predict_does_not_change_cluster_centers": [
    "csr_container"
  ],
  "test_sample_weight_init": [
    "init",
    "global_random_seed"
  ],
  "test_sample_weight_zero": [
    "init",
    "global_random_seed"
  ],
  "test_relocating_with_duplicates": [
    "algorithm",
    "array_constr"
  ],
  "TargetEncoder": {
    "__init__": [
      "self",
      "categories",
      "target_type",
      "smooth",
      "cv",
      "shuffle",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "_fit_encodings_all": [
      "self",
      "X",
      "y"
    ],
    "_fit_encoding_binary_or_continuous": [
      "self",
      "X_ordinal",
      "y",
      "n_categories",
      "target_mean"
    ],
    "_fit_encoding_multiclass": [
      "self",
      "X_ordinal",
      "y",
      "n_categories",
      "target_mean"
    ],
    "_transform_X_ordinal": [
      "self",
      "X_out",
      "X_ordinal",
      "X_unknown_mask",
      "row_indices",
      "encodings",
      "target_mean"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LabelEncoder": {
    "fit": [
      "self",
      "y"
    ],
    "fit_transform": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "y"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "LabelBinarizer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "y"
    ],
    "fit_transform": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "inverse_transform": [
      "self",
      "Y",
      "threshold"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "label_binarize": [
    "y"
  ],
  "_inverse_binarize_multiclass": [
    "y",
    "classes",
    "xp"
  ],
  "_inverse_binarize_thresholding": [
    "y",
    "output_type",
    "classes",
    "threshold",
    "xp"
  ],
  "MultiLabelBinarizer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "y"
    ],
    "fit_transform": [
      "self",
      "y"
    ],
    "transform": [
      "self",
      "y"
    ],
    "_build_cache": [
      "self"
    ],
    "_transform": [
      "self",
      "y",
      "class_mapping"
    ],
    "inverse_transform": [
      "self",
      "yt"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_create_expansion": [
    "X",
    "interaction_only",
    "deg",
    "n_features",
    "cumulative_size"
  ],
  "PolynomialFeatures": {
    "__init__": [
      "self",
      "degree"
    ],
    "_combinations": [
      "n_features",
      "min_degree",
      "max_degree",
      "interaction_only",
      "include_bias"
    ],
    "_num_combinations": [
      "n_features",
      "min_degree",
      "max_degree",
      "interaction_only",
      "include_bias"
    ],
    "powers_": [
      "self"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "SplineTransformer": {
    "__init__": [
      "self",
      "n_knots",
      "degree"
    ],
    "_get_base_knot_positions": [
      "X",
      "n_knots",
      "knots",
      "sample_weight"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KBinsDiscretizer": {
    "__init__": [
      "self",
      "n_bins"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_validate_n_bins": [
      "self",
      "n_features"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ]
  },
  "BOUNDS_THRESHOLD": [],
  "_is_constant_feature": [
    "var",
    "mean",
    "n_samples"
  ],
  "_handle_zeros_in_scale": [
    "scale",
    "copy",
    "constant_mask"
  ],
  "scale": [
    "X"
  ],
  "MinMaxScaler": {
    "__init__": [
      "self",
      "feature_range"
    ],
    "_reset": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "minmax_scale": [
    "X",
    "feature_range"
  ],
  "MaxAbsScaler": {
    "__init__": [
      "self"
    ],
    "_reset": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "maxabs_scale": [
    "X"
  ],
  "RobustScaler": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "robust_scale": [
    "X"
  ],
  "normalize": [
    "X",
    "norm"
  ],
  "Normalizer": {
    "__init__": [
      "self",
      "norm"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "copy"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "binarize": [
    "X"
  ],
  "Binarizer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "copy"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "KernelCenterer": {
    "__metadata_request__transform": [],
    "__metadata_request__fit": [],
    "fit": [
      "self",
      "K",
      "y"
    ],
    "transform": [
      "self",
      "K",
      "copy"
    ],
    "_n_features_out": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "add_dummy_feature": [
    "X",
    "value"
  ],
  "QuantileTransformer": {
    "__init__": [
      "self"
    ],
    "_dense_fit": [
      "self",
      "X",
      "random_state"
    ],
    "_sparse_fit": [
      "self",
      "X",
      "random_state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_transform_col": [
      "self",
      "X_col",
      "quantiles",
      "inverse"
    ],
    "_check_inputs": [
      "self",
      "X",
      "in_fit",
      "accept_sparse_negative",
      "copy"
    ],
    "_transform": [
      "self",
      "X",
      "inverse"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "quantile_transform": [
    "X"
  ],
  "PowerTransformer": {
    "__init__": [
      "self",
      "method"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_fit": [
      "self",
      "X",
      "y",
      "force_transform"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "_yeo_johnson_inverse_transform": [
      "self",
      "x",
      "lmbda"
    ],
    "_yeo_johnson_transform": [
      "self",
      "x",
      "lmbda"
    ],
    "_box_cox_optimize": [
      "self",
      "x"
    ],
    "_yeo_johnson_optimize": [
      "self",
      "x"
    ],
    "_check_input": [
      "self",
      "X",
      "in_fit",
      "check_positive",
      "check_shape"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "power_transform": [
    "X",
    "method"
  ],
  "_identity": [
    "X"
  ],
  "FunctionTransformer": {
    "__init__": [
      "self",
      "func",
      "inverse_func"
    ],
    "_check_inverse_transform": [
      "self",
      "X"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "_transform": [
      "self",
      "X",
      "func",
      "kw_args"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ],
    "set_output": [
      "self"
    ],
    "_get_function_name": [
      "self"
    ],
    "_sk_visual_block_": [
      "self"
    ]
  },
  "_BaseEncoder": {
    "_check_X": [
      "self",
      "X",
      "ensure_all_finite"
    ],
    "_fit": [
      "self",
      "X",
      "handle_unknown",
      "ensure_all_finite",
      "return_counts",
      "return_and_ignore_missing_for_infrequent"
    ],
    "_transform": [
      "self",
      "X",
      "handle_unknown",
      "ensure_all_finite",
      "warn_on_unknown",
      "ignore_category_indices"
    ],
    "infrequent_categories_": [
      "self"
    ],
    "_check_infrequent_enabled": [
      "self"
    ],
    "_identify_infrequent": [
      "self",
      "category_count",
      "n_samples",
      "col_idx"
    ],
    "_fit_infrequent_category_mapping": [
      "self",
      "n_samples",
      "category_counts",
      "missing_indices"
    ],
    "_map_infrequent_categories": [
      "self",
      "X_int",
      "X_mask",
      "ignore_category_indices"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "OneHotEncoder": {
    "__init__": [
      "self"
    ],
    "_map_drop_idx_to_infrequent": [
      "self",
      "feature_idx",
      "drop_idx"
    ],
    "_set_drop_idx": [
      "self"
    ],
    "_compute_transformed_categories": [
      "self",
      "i",
      "remove_dropped"
    ],
    "_remove_dropped_categories": [
      "self",
      "categories",
      "i"
    ],
    "_compute_n_features_outs": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "_check_get_feature_name_combiner": [
      "self"
    ]
  },
  "OrdinalEncoder": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "inverse_transform": [
      "self",
      "X"
    ]
  },
  "test_one_hot_encoder_sparse_dense": [],
  "test_one_hot_encoder_handle_unknown": [
    "handle_unknown"
  ],
  "test_one_hot_encoder_handle_unknown_strings": [
    "handle_unknown"
  ],
  "test_one_hot_encoder_dtype": [
    "input_dtype",
    "output_dtype"
  ],
  "test_one_hot_encoder_dtype_pandas": [
    "output_dtype"
  ],
  "test_one_hot_encoder_feature_names": [],
  "test_one_hot_encoder_feature_names_unicode": [],
  "test_one_hot_encoder_custom_feature_name_combiner": [],
  "test_one_hot_encoder_set_params": [],
  "check_categorical_onehot": [
    "X"
  ],
  "test_one_hot_encoder": [
    "X"
  ],
  "test_one_hot_encoder_inverse": [
    "handle_unknown",
    "sparse_",
    "drop"
  ],
  "test_one_hot_encoder_inverse_transform_raise_error_with_unknown": [
    "X",
    "X_trans",
    "sparse_"
  ],
  "test_one_hot_encoder_inverse_if_binary": [],
  "test_one_hot_encoder_drop_reset": [
    "drop",
    "reset_drop"
  ],
  "test_X_is_not_1D": [
    "X",
    "method"
  ],
  "test_X_is_not_1D_pandas": [
    "method"
  ],
  "test_one_hot_encoder_categories": [
    "X",
    "cat_exp",
    "cat_dtype"
  ],
  "test_one_hot_encoder_specified_categories": [
    "X",
    "X2",
    "cats",
    "cat_dtype",
    "handle_unknown"
  ],
  "test_one_hot_encoder_unsorted_categories": [],
  "test_encoder_nan_ending_specified_categories": [
    "Encoder"
  ],
  "test_one_hot_encoder_specified_categories_mixed_columns": [],
  "test_one_hot_encoder_pandas": [],
  "test_one_hot_encoder_feature_names_drop": [
    "drop",
    "expected_names"
  ],
  "test_one_hot_encoder_drop_equals_if_binary": [],
  "test_ordinal_encoder": [
    "X"
  ],
  "test_ordinal_encoder_specified_categories": [
    "X",
    "X2",
    "cats",
    "cat_dtype"
  ],
  "test_ordinal_encoder_inverse": [],
  "test_ordinal_encoder_handle_unknowns_string": [],
  "test_ordinal_encoder_handle_unknowns_numeric": [
    "dtype"
  ],
  "test_ordinal_encoder_handle_unknowns_nan": [],
  "test_ordinal_encoder_handle_unknowns_nan_non_float_dtype": [],
  "test_ordinal_encoder_raise_categories_shape": [],
  "test_encoder_dtypes": [],
  "test_encoder_dtypes_pandas": [],
  "test_one_hot_encoder_warning": [],
  "test_ohe_handle_unknown_warn": [
    "drop"
  ],
  "test_one_hot_encoder_drop_manual": [
    "missing_value"
  ],
  "test_invalid_drop_length": [
    "drop"
  ],
  "test_categories": [
    "density",
    "drop"
  ],
  "test_encoders_has_categorical_tags": [
    "Encoder"
  ],
  "test_ohe_infrequent_two_levels": [
    "kwargs",
    "categories"
  ],
  "test_ohe_infrequent_two_levels_drop_frequent": [
    "drop"
  ],
  "test_ohe_infrequent_two_levels_drop_infrequent_errors": [
    "drop"
  ],
  "test_ohe_infrequent_three_levels": [
    "kwargs"
  ],
  "test_ohe_infrequent_three_levels_drop_frequent": [
    "drop"
  ],
  "test_ohe_infrequent_three_levels_drop_infrequent_errors": [
    "drop"
  ],
  "test_ohe_infrequent_handle_unknown_error": [],
  "test_ohe_infrequent_two_levels_user_cats_one_frequent": [
    "kwargs"
  ],
  "test_ohe_infrequent_two_levels_user_cats": [],
  "test_ohe_infrequent_three_levels_user_cats": [],
  "test_ohe_infrequent_mixed": [],
  "test_ohe_infrequent_multiple_categories": [],
  "test_ohe_infrequent_multiple_categories_dtypes": [],
  "test_ohe_infrequent_one_level_errors": [
    "kwargs"
  ],
  "test_ohe_infrequent_user_cats_unknown_training_errors": [
    "kwargs"
  ],
  "test_encoders_string_categories": [
    "input_dtype",
    "category_dtype",
    "array_type"
  ],
  "test_mixed_string_bytes_categoricals": [],
  "test_ohe_missing_values_get_feature_names": [
    "missing_value"
  ],
  "test_ohe_missing_value_support_pandas": [],
  "test_ohe_missing_value_support_pandas_categorical": [
    "pd_nan_type",
    "handle_unknown"
  ],
  "test_ohe_drop_first_handle_unknown_ignore_warns": [
    "handle_unknown"
  ],
  "test_ohe_drop_if_binary_handle_unknown_ignore_warns": [
    "handle_unknown"
  ],
  "test_ohe_drop_first_explicit_categories": [
    "handle_unknown"
  ],
  "test_ohe_more_informative_error_message": [],
  "test_ordinal_encoder_passthrough_missing_values_float_errors_dtype": [],
  "test_ordinal_encoder_passthrough_missing_values_float": [
    "encoded_missing_value"
  ],
  "test_ordinal_encoder_missing_value_support_pandas_categorical": [
    "pd_nan_type",
    "encoded_missing_value"
  ],
  "test_ordinal_encoder_specified_categories_missing_passthrough": [
    "X",
    "X2",
    "cats",
    "cat_dtype"
  ],
  "test_encoder_duplicate_specified_categories": [
    "Encoder"
  ],
  "test_ordinal_encoder_handle_missing_and_unknown": [
    "X",
    "expected_X_trans",
    "X_test"
  ],
  "test_ordinal_encoder_sparse": [
    "csr_container"
  ],
  "test_ordinal_encoder_fit_with_unseen_category": [],
  "test_ordinal_encoder_handle_unknown_string_dtypes": [
    "X_train",
    "X_test"
  ],
  "test_ordinal_encoder_python_integer": [],
  "test_ordinal_encoder_features_names_out_pandas": [],
  "test_ordinal_encoder_unknown_missing_interaction": [],
  "test_ordinal_encoder_encoded_missing_value_error": [
    "with_pandas"
  ],
  "test_ordinal_encoder_unknown_missing_interaction_both_nan": [
    "X_train",
    "X_test_trans_expected",
    "X_roundtrip_expected"
  ],
  "test_one_hot_encoder_set_output": [],
  "test_ordinal_set_output": [],
  "test_predefined_categories_dtype": [],
  "test_ordinal_encoder_missing_unknown_encoding_max": [],
  "test_drop_idx_infrequent_categories": [],
  "test_ordinal_encoder_infrequent_three_levels": [
    "kwargs"
  ],
  "test_ordinal_encoder_infrequent_three_levels_user_cats": [],
  "test_ordinal_encoder_infrequent_mixed": [],
  "test_ordinal_encoder_infrequent_multiple_categories_dtypes": [],
  "test_ordinal_encoder_infrequent_custom_mapping": [],
  "test_ordinal_encoder_all_frequent": [
    "kwargs"
  ],
  "test_ordinal_encoder_all_infrequent": [
    "kwargs"
  ],
  "test_ordinal_encoder_missing_appears_frequent": [],
  "test_ordinal_encoder_missing_appears_infrequent": [],
  "test_encoder_not_fitted": [
    "Encoder"
  ],
  "test_onehotencoder_handle_unknown_warn_maps_to_infrequent": [],
  "_make_func": [
    "args_store",
    "kwargs_store",
    "func"
  ],
  "test_delegate_to_func": [],
  "test_np_log": [],
  "test_kw_arg": [],
  "test_kw_arg_update": [],
  "test_kw_arg_reset": [],
  "test_check_inverse": [
    "sparse_container"
  ],
  "test_check_inverse_func_or_inverse_not_provided": [],
  "test_function_transformer_frame": [],
  "test_function_transformer_raise_error_with_mixed_dtype": [
    "X_type"
  ],
  "test_function_transformer_support_all_nummerical_dataframes_check_inverse_True": [],
  "test_function_transformer_with_dataframe_and_check_inverse_True": [],
  "test_function_transformer_get_feature_names_out": [
    "X",
    "feature_names_out",
    "input_features",
    "expected",
    "validate"
  ],
  "test_function_transformer_get_feature_names_out_without_validation": [],
  "test_function_transformer_feature_names_out_is_None": [],
  "test_function_transformer_feature_names_out_uses_estimator": [],
  "test_function_transformer_validate_inverse": [],
  "test_get_feature_names_out_dataframe_with_string_data": [
    "feature_names_out",
    "expected",
    "in_pipeline"
  ],
  "test_set_output_func": [],
  "test_consistence_column_name_between_steps": [],
  "test_function_transformer_overwrite_column_names": [
    "dataframe_lib",
    "transform_output"
  ],
  "test_function_transformer_overwrite_column_names_numerical": [
    "feature_names_out"
  ],
  "test_function_transformer_error_column_inconsistent": [
    "dataframe_lib",
    "feature_names_out"
  ],
  "_get_valid_samples_by_column": [
    "X",
    "col"
  ],
  "test_missing_value_handling": [
    "est",
    "func",
    "support_sparse",
    "strictly_positive",
    "omit_kwargs"
  ],
  "test_missing_value_pandas_na_support": [
    "est",
    "func"
  ],
  "test_valid_n_bins": [],
  "test_invalid_n_bins_array": [],
  "test_fit_transform_n_bins_array": [
    "strategy",
    "quantile_method",
    "expected",
    "sample_weight"
  ],
  "test_kbinsdiscretizer_effect_sample_weight": [],
  "test_kbinsdiscretizer_no_mutating_sample_weight": [
    "strategy"
  ],
  "test_same_min_max": [
    "strategy"
  ],
  "test_transform_1d_behavior": [],
  "test_numeric_stability": [
    "i"
  ],
  "test_encode_options": [],
  "test_nonuniform_strategies": [
    "strategy",
    "quantile_method",
    "expected_2bins",
    "expected_3bins",
    "expected_5bins"
  ],
  "test_transform_outside_fit_range": [
    "strategy"
  ],
  "test_overwrite": [],
  "test_redundant_bins": [
    "strategy",
    "expected_bin_edges",
    "quantile_method"
  ],
  "test_percentile_numeric_stability": [],
  "test_consistent_dtype": [
    "in_dtype",
    "out_dtype",
    "encode"
  ],
  "test_32_equal_64": [
    "input_dtype",
    "encode"
  ],
  "test_kbinsdiscretizer_subsample_default": [],
  "test_kbinsdiscrtizer_get_feature_names_out": [
    "encode",
    "expected_names"
  ],
  "test_kbinsdiscretizer_subsample": [
    "strategy",
    "global_random_seed"
  ],
  "test_quantile_method_future_warnings": [],
  "test_invalid_quantile_method_with_sample_weight": [],
  "n_features": [],
  "offsets": [],
  "scales": [],
  "X_2d": [],
  "X_1row": [],
  "X_1col": [],
  "X_list_1row": [],
  "X_list_1col": [],
  "toarray": [
    "a"
  ],
  "_check_dim_1axis": [
    "a"
  ],
  "assert_correct_incr": [
    "i",
    "batch_start",
    "batch_stop",
    "n",
    "chunk_size",
    "n_samples_seen"
  ],
  "_yield_xw_x_sampleweight": [],
  "test_standard_scaler_sample_weight": [
    "Xw",
    "X",
    "sample_weight",
    "array_constructor"
  ],
  "test_standard_scaler_sample_weight_array_api": [
    "Xw",
    "X",
    "sample_weight",
    "namespace",
    "dev",
    "dtype"
  ],
  "test_standard_scaler_1d": [],
  "test_standard_scaler_dtype": [
    "add_sample_weight",
    "sparse_container"
  ],
  "test_standard_scaler_constant_features": [
    "scaler",
    "add_sample_weight",
    "sparse_container",
    "dtype",
    "constant"
  ],
  "test_standard_scaler_near_constant_features": [
    "n_samples",
    "sparse_container",
    "average",
    "dtype"
  ],
  "test_scale_1d": [],
  "test_standard_scaler_numerical_stability": [],
  "test_scaler_2d_arrays": [],
  "test_scaler_float16_overflow": [],
  "test_handle_zeros_in_scale": [],
  "test_minmax_scaler_partial_fit": [],
  "test_standard_scaler_partial_fit": [],
  "test_standard_scaler_partial_fit_numerical_stability": [
    "sparse_container"
  ],
  "test_partial_fit_sparse_input": [
    "sample_weight",
    "sparse_container"
  ],
  "test_standard_scaler_trasform_with_partial_fit": [
    "sample_weight"
  ],
  "test_standard_check_array_of_inverse_transform": [],
  "test_preprocessing_array_api_compliance": [
    "estimator",
    "check",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_standard_scaler_array_api_compliance": [
    "check",
    "sample_weight",
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_min_max_scaler_iris": [],
  "test_min_max_scaler_zero_variance_features": [],
  "test_minmax_scale_axis1": [],
  "test_min_max_scaler_1d": [],
  "test_scaler_without_centering": [
    "sample_weight",
    "sparse_container"
  ],
  "test_scaler_n_samples_seen_with_nan": [
    "with_mean",
    "with_std",
    "sparse_container"
  ],
  "_check_identity_scalers_attributes": [
    "scaler_1",
    "scaler_2"
  ],
  "test_scaler_return_identity": [
    "sparse_container"
  ],
  "test_scaler_int": [
    "sparse_container"
  ],
  "test_scaler_without_copy": [
    "sparse_container"
  ],
  "test_scale_sparse_with_mean_raise_exception": [
    "sparse_container"
  ],
  "test_scale_input_finiteness_validation": [],
  "test_robust_scaler_error_sparse": [],
  "test_robust_scaler_attributes": [
    "X",
    "with_centering",
    "with_scaling"
  ],
  "test_robust_scaler_col_zero_sparse": [
    "csr_container"
  ],
  "test_robust_scaler_2d_arrays": [],
  "test_robust_scaler_equivalence_dense_sparse": [
    "density",
    "strictly_signed"
  ],
  "test_robust_scaler_transform_one_row_csr": [
    "csr_container"
  ],
  "test_robust_scaler_iris": [],
  "test_robust_scaler_iris_quantiles": [],
  "test_quantile_transform_iris": [
    "csc_container"
  ],
  "test_quantile_transform_check_error": [
    "csc_container"
  ],
  "test_quantile_transform_sparse_ignore_zeros": [
    "csc_container"
  ],
  "test_quantile_transform_dense_toy": [],
  "test_quantile_transform_subsampling": [],
  "test_quantile_transform_subsampling_disabled": [],
  "test_quantile_transform_sparse_toy": [
    "csc_container"
  ],
  "test_quantile_transform_axis1": [],
  "test_quantile_transform_bounds": [
    "csc_container"
  ],
  "test_quantile_transform_and_inverse": [],
  "test_quantile_transform_nan": [],
  "test_quantile_transformer_sorted_quantiles": [
    "array_type"
  ],
  "test_robust_scaler_invalid_range": [],
  "test_scale_function_without_centering": [
    "csr_container"
  ],
  "test_robust_scale_axis1": [],
  "test_robust_scale_1d_array": [],
  "test_robust_scaler_zero_variance_features": [],
  "test_robust_scaler_unit_variance": [],
  "test_maxabs_scaler_zero_variance_features": [
    "sparse_container"
  ],
  "test_maxabs_scaler_large_negative_value": [],
  "test_maxabs_scaler_transform_one_row_csr": [
    "csr_container"
  ],
  "test_maxabs_scaler_1d": [],
  "test_maxabs_scaler_partial_fit": [
    "csr_container"
  ],
  "check_normalizer": [
    "norm",
    "X_norm"
  ],
  "test_normalizer_l1_l2_max": [
    "norm",
    "csr_container"
  ],
  "test_normalizer_l1_l2_max_non_csr": [
    "norm",
    "sparse_container"
  ],
  "test_normalizer_max_sign": [
    "csr_container"
  ],
  "test_normalize": [
    "csr_container"
  ],
  "test_binarizer": [
    "constructor"
  ],
  "test_binarizer_array_api_int": [
    "array_namespace",
    "device",
    "dtype_name"
  ],
  "test_center_kernel": [],
  "test_kernelcenterer_non_linear_kernel": [],
  "test_cv_pipeline_precomputed": [],
  "test_add_dummy_feature": [],
  "test_add_dummy_feature_sparse": [
    "sparse_container"
  ],
  "test_fit_cold_start": [],
  "test_power_transformer_notfitted": [
    "method"
  ],
  "test_power_transformer_inverse": [
    "method",
    "standardize",
    "X"
  ],
  "test_power_transformer_1d": [],
  "test_power_transformer_2d": [],
  "test_power_transformer_boxcox_strictly_positive_exception": [],
  "test_power_transformer_yeojohnson_any_input": [
    "X"
  ],
  "test_power_transformer_shape_exception": [
    "method"
  ],
  "test_power_transformer_lambda_zero": [],
  "test_power_transformer_lambda_one": [],
  "test_optimization_power_transformer": [
    "method",
    "lmbda"
  ],
  "test_invserse_box_cox": [],
  "test_yeo_johnson_darwin_example": [],
  "test_power_transformer_nans": [
    "method"
  ],
  "test_power_transformer_fit_transform": [
    "method",
    "standardize"
  ],
  "test_power_transformer_copy_True": [
    "method",
    "standardize"
  ],
  "test_power_transformer_copy_False": [
    "method",
    "standardize"
  ],
  "test_power_transformer_box_cox_raise_all_nans_col": [],
  "test_standard_scaler_sparse_partial_fit_finite_variance": [
    "X_2"
  ],
  "test_minmax_scaler_clip": [
    "feature_range"
  ],
  "test_maxabs_scaler_clip": [
    "data_constructor"
  ],
  "test_standard_scaler_raise_error_for_1d_input": [],
  "test_power_transformer_significantly_non_gaussian": [],
  "test_one_to_one_features": [
    "Transformer"
  ],
  "test_one_to_one_features_pandas": [
    "Transformer"
  ],
  "test_kernel_centerer_feature_names_out": [],
  "test_power_transformer_constant_feature": [
    "standardize"
  ],
  "test_yeo_johnson_inverse_transform_warning": [],
  "test_power_transformer_no_warnings": [],
  "test_yeojohnson_for_different_scipy_version": [],
  "test_label_binarizer": [],
  "test_label_binarizer_unseen_labels": [],
  "test_label_binarizer_set_label_encoding": [],
  "test_label_binarizer_pandas_nullable": [
    "dtype",
    "unique_first"
  ],
  "test_label_binarizer_errors": [],
  "test_label_binarizer_sparse_errors": [
    "csr_container"
  ],
  "test_label_binarizer_array_api_compliance": [
    "y",
    "classes",
    "expected",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_label_encoder": [
    "values",
    "classes",
    "unknown"
  ],
  "test_label_encoder_negative_ints": [],
  "test_label_encoder_str_bad_shape": [
    "dtype"
  ],
  "test_label_encoder_errors": [],
  "test_label_encoder_empty_array": [
    "values"
  ],
  "test_sparse_output_multilabel_binarizer": [],
  "test_sparse_output_multilabel_binarizer_errors": [
    "csr_container"
  ],
  "test_multilabel_binarizer": [],
  "test_multilabel_binarizer_empty_sample": [],
  "test_multilabel_binarizer_unknown_class": [],
  "test_multilabel_binarizer_given_classes": [],
  "test_multilabel_binarizer_multiple_calls": [],
  "test_multilabel_binarizer_same_length_sequence": [],
  "test_multilabel_binarizer_non_integer_labels": [],
  "test_multilabel_binarizer_non_unique": [],
  "test_multilabel_binarizer_inverse_validation": [],
  "test_label_binarize_with_class_order": [],
  "check_binarized_results": [
    "y",
    "classes",
    "pos_label",
    "neg_label",
    "expected"
  ],
  "test_label_binarize_binary": [],
  "test_label_binarize_multiclass": [],
  "test_label_binarize_multilabel": [
    "arr_type"
  ],
  "test_invalid_input_label_binarize": [],
  "test_label_binarize_array_api_compliance": [
    "y",
    "classes",
    "expected",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_inverse_binarize_multiclass": [
    "csr_container"
  ],
  "test_nan_label_encoder": [],
  "test_label_encoders_do_not_have_set_output": [
    "encoder"
  ],
  "test_label_encoder_array_api_compliance": [
    "y",
    "array_namespace",
    "device",
    "dtype"
  ],
  "test_polynomial_and_spline_array_order": [
    "est"
  ],
  "test_spline_transformer_input_validation": [
    "params",
    "err_msg"
  ],
  "test_spline_transformer_integer_knots": [
    "extrapolation"
  ],
  "test_spline_transformer_feature_names": [],
  "test_split_transform_feature_names_extrapolation_degree": [
    "extrapolation",
    "degree"
  ],
  "test_spline_transformer_unity_decomposition": [
    "degree",
    "n_knots",
    "knots",
    "extrapolation"
  ],
  "test_spline_transformer_linear_regression": [
    "bias",
    "intercept"
  ],
  "test_spline_transformer_get_base_knot_positions": [
    "knots",
    "n_knots",
    "sample_weight",
    "expected_knots"
  ],
  "test_spline_transformer_periodic_linear_regression": [
    "bias",
    "intercept"
  ],
  "test_spline_transformer_periodic_spline_backport": [],
  "test_spline_transformer_periodic_splines_periodicity": [],
  "test_spline_transformer_periodic_splines_smoothness": [
    "degree"
  ],
  "test_spline_transformer_extrapolation": [
    "bias",
    "intercept",
    "degree"
  ],
  "test_spline_transformer_kbindiscretizer": [
    "global_random_seed"
  ],
  "test_spline_transformer_sparse_output": [
    "degree",
    "knots",
    "extrapolation",
    "include_bias",
    "global_random_seed"
  ],
  "test_spline_transformer_n_features_out": [
    "n_knots",
    "include_bias",
    "degree",
    "extrapolation",
    "sparse_output"
  ],
  "test_spline_transformer_handles_missing_values": [
    "extrapolation",
    "sparse_output"
  ],
  "test_spline_transformer_handles_all_nans": [
    "extrapolation",
    "sparse_output"
  ],
  "test_polynomial_features_input_validation": [
    "params",
    "err_msg"
  ],
  "single_feature_degree3": [],
  "test_polynomial_features_one_feature": [
    "single_feature_degree3",
    "degree",
    "include_bias",
    "interaction_only",
    "indices",
    "X_container"
  ],
  "two_features_degree3": [],
  "test_polynomial_features_two_features": [
    "two_features_degree3",
    "degree",
    "include_bias",
    "interaction_only",
    "indices",
    "X_container"
  ],
  "test_polynomial_feature_names": [],
  "test_polynomial_features_csc_X": [
    "deg",
    "include_bias",
    "interaction_only",
    "dtype",
    "csc_container",
    "global_random_seed"
  ],
  "test_polynomial_features_csr_X": [
    "deg",
    "include_bias",
    "interaction_only",
    "dtype",
    "csr_container",
    "global_random_seed"
  ],
  "test_num_combinations": [
    "n_features",
    "min_degree",
    "max_degree",
    "interaction_only",
    "include_bias",
    "csr_container"
  ],
  "test_polynomial_features_csr_X_floats": [
    "deg",
    "include_bias",
    "interaction_only",
    "dtype",
    "csr_container",
    "global_random_seed"
  ],
  "test_polynomial_features_csr_X_zero_row": [
    "zero_row_index",
    "deg",
    "interaction_only",
    "csr_container",
    "global_random_seed"
  ],
  "test_polynomial_features_csr_X_degree_4": [
    "include_bias",
    "interaction_only",
    "csr_container",
    "global_random_seed"
  ],
  "test_polynomial_features_csr_X_dim_edges": [
    "deg",
    "dim",
    "interaction_only",
    "csr_container",
    "global_random_seed"
  ],
  "test_csr_polynomial_expansion_index_overflow_non_regression": [
    "interaction_only",
    "include_bias",
    "csr_container"
  ],
  "test_csr_polynomial_expansion_index_overflow": [
    "degree",
    "n_features",
    "interaction_only",
    "include_bias",
    "csr_container"
  ],
  "test_csr_polynomial_expansion_too_large_to_index": [
    "interaction_only",
    "include_bias",
    "csr_container"
  ],
  "test_polynomial_features_behaviour_on_zero_degree": [
    "sparse_container"
  ],
  "test_sizeof_LARGEST_INT_t": [],
  "test_csr_polynomial_expansion_windows_fail": [
    "csr_container"
  ],
  "test_polynomial_features_array_api_compliance": [
    "two_features_degree3",
    "degree",
    "include_bias",
    "interaction_only",
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "test_polynomial_features_array_api_raises_on_order_F": [
    "array_namespace",
    "device_",
    "dtype_name"
  ],
  "_encode_target": [
    "X_ordinal",
    "y_numeric",
    "n_categories",
    "smooth"
  ],
  "test_encoding": [
    "categories",
    "unknown_value",
    "global_random_seed",
    "smooth",
    "target_type"
  ],
  "test_encoding_multiclass": [
    "global_random_seed",
    "categories",
    "unknown_values",
    "target_labels",
    "smooth"
  ],
  "test_custom_categories": [
    "X",
    "categories",
    "smooth"
  ],
  "test_errors": [
    "y",
    "msg"
  ],
  "test_use_regression_target": [],
  "test_feature_names_out_set_output": [
    "y",
    "feature_names"
  ],
  "test_multiple_features_quick": [
    "to_pandas",
    "smooth",
    "target_type"
  ],
  "test_constant_target_and_feature": [
    "y",
    "y_mean",
    "smooth"
  ],
  "test_fit_transform_not_associated_with_y_if_ordinal_categorical_is_not": [
    "global_random_seed"
  ],
  "test_smooth_zero": [],
  "test_invariance_of_encoding_under_label_permutation": [
    "smooth",
    "global_random_seed"
  ],
  "test_target_encoding_for_linear_regression": [
    "smooth",
    "global_random_seed"
  ],
  "test_pandas_copy_on_write": [],
  "FrozenEstimator": {
    "__init__": [
      "self",
      "estimator"
    ],
    "__getitem__": [
      "self"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "__sklearn_clone__": [
      "self"
    ],
    "__sklearn_is_fitted__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "set_params": [
      "self"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "regression_dataset": [],
  "classification_dataset": [],
  "test_frozen_methods": [
    "estimator",
    "dataset",
    "request",
    "method"
  ],
  "test_frozen_metadata_routing": [
    "regression_dataset"
  ],
  "test_composite_fit": [
    "classification_dataset"
  ],
  "test_clone_frozen": [
    "regression_dataset"
  ],
  "test_frozen_tags": [],
  "test_frozen_params": [],
  "_iteritems": [
    "d"
  ],
  "FeatureHasher": {
    "__metadata_request__transform": [],
    "__init__": [
      "self",
      "n_features"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "raw_X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "DictVectorizer": {
    "__metadata_request__inverse_transform": [],
    "__init__": [
      "self"
    ],
    "_add_iterable_element": [
      "self",
      "f",
      "v",
      "feature_names",
      "vocab"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_transform": [
      "self",
      "X",
      "fitting"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "inverse_transform": [
      "self",
      "X",
      "dict_type"
    ],
    "transform": [
      "self",
      "X"
    ],
    "get_feature_names_out": [
      "self",
      "input_features"
    ],
    "restrict": [
      "self",
      "support",
      "indices"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "ENGLISH_STOP_WORDS": [],
  "_preprocess": [
    "doc",
    "accent_function",
    "lower"
  ],
  "_analyze": [
    "doc",
    "analyzer",
    "tokenizer",
    "ngrams",
    "preprocessor",
    "decoder",
    "stop_words"
  ],
  "strip_accents_unicode": [
    "s"
  ],
  "strip_accents_ascii": [
    "s"
  ],
  "strip_tags": [
    "s"
  ],
  "_check_stop_list": [
    "stop"
  ],
  "_VectorizerMixin": {
    "_white_spaces": [],
    "decode": [
      "self",
      "doc"
    ],
    "_word_ngrams": [
      "self",
      "tokens",
      "stop_words"
    ],
    "_char_ngrams": [
      "self",
      "text_document"
    ],
    "_char_wb_ngrams": [
      "self",
      "text_document"
    ],
    "build_preprocessor": [
      "self"
    ],
    "build_tokenizer": [
      "self"
    ],
    "get_stop_words": [
      "self"
    ],
    "_check_stop_words_consistency": [
      "self",
      "stop_words",
      "preprocess",
      "tokenize"
    ],
    "build_analyzer": [
      "self"
    ],
    "_validate_vocabulary": [
      "self"
    ],
    "_check_vocabulary": [
      "self"
    ],
    "_validate_ngram_range": [
      "self"
    ],
    "_warn_for_unused_params": [
      "self"
    ]
  },
  "HashingVectorizer": {
    "__init__": [
      "self"
    ],
    "partial_fit": [
      "self",
      "X",
      "y"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "_get_hasher": [
      "self"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_document_frequency": [
    "X"
  ],
  "_make_int_array": [],
  "TfidfTransformer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "copy"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "TfidfVectorizer": {
    "__init__": [
      "self"
    ],
    "idf_": [
      "self",
      "value"
    ],
    "_check_params": [
      "self"
    ],
    "fit": [
      "self",
      "raw_documents",
      "y"
    ],
    "fit_transform": [
      "self",
      "raw_documents",
      "y"
    ],
    "transform": [
      "self",
      "raw_documents"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "_make_edges_3d": [
    "n_x",
    "n_y",
    "n_z"
  ],
  "_compute_gradient_3d": [
    "edges",
    "img"
  ],
  "_mask_edges_weights": [
    "mask",
    "edges",
    "weights"
  ],
  "_to_graph": [
    "n_x",
    "n_y",
    "n_z",
    "mask",
    "img",
    "return_as",
    "dtype"
  ],
  "img_to_graph": [
    "img"
  ],
  "grid_to_graph": [
    "n_x",
    "n_y",
    "n_z"
  ],
  "_compute_n_patches": [
    "i_h",
    "i_w",
    "p_h",
    "p_w",
    "max_patches"
  ],
  "_extract_patches": [
    "arr",
    "patch_shape",
    "extraction_step"
  ],
  "extract_patches_2d": [
    "image",
    "patch_size"
  ],
  "reconstruct_from_patches_2d": [
    "patches",
    "image_size"
  ],
  "PatchExtractor": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X"
    ],
    "__sklearn_tags__": [
      "self"
    ]
  },
  "test_feature_hasher_dicts": [],
  "test_feature_hasher_strings": [],
  "test_feature_hasher_single_string": [
    "input_type"
  ],
  "test_hashing_transform_seed": [],
  "test_feature_hasher_pairs": [],
  "test_feature_hasher_pairs_with_string_values": [],
  "test_hash_empty_input": [],
  "test_hasher_zeros": [],
  "test_hasher_alternate_sign": [],
  "test_hash_collisions": [],
  "test_feature_hasher_requires_fit_tag": [],
  "test_feature_hasher_transform_without_fit": [],
  "NOTJUNK_FOOD_DOCS": [],
  "ALL_FOOD_DOCS": [],
  "uppercase": [
    "s"
  ],
  "strip_eacute": [
    "s"
  ],
  "split_tokenize": [
    "s"
  ],
  "lazy_analyze": [
    "s"
  ],
  "test_strip_accents": [],
  "test_to_ascii": [],
  "test_word_analyzer_unigrams": [
    "Vectorizer"
  ],
  "test_word_analyzer_unigrams_and_bigrams": [],
  "test_unicode_decode_error": [],
  "test_char_ngram_analyzer": [],
  "test_char_wb_ngram_analyzer": [],
  "test_word_ngram_analyzer": [],
  "test_countvectorizer_custom_vocabulary": [],
  "test_countvectorizer_custom_vocabulary_pipeline": [],
  "test_countvectorizer_custom_vocabulary_repeated_indices": [],
  "test_countvectorizer_custom_vocabulary_gap_index": [],
  "test_countvectorizer_stop_words": [],
  "test_countvectorizer_empty_vocabulary": [],
  "test_fit_countvectorizer_twice": [],
  "test_countvectorizer_custom_token_pattern": [],
  "test_countvectorizer_custom_token_pattern_with_several_group": [],
  "test_countvectorizer_uppercase_in_vocab": [],
  "test_tf_transformer_feature_names_out": [],
  "test_tf_idf_smoothing": [],
  "test_tfidf_no_smoothing": [],
  "test_sublinear_tf": [],
  "test_vectorizer": [],
  "test_tfidf_vectorizer_setters": [],
  "test_hashing_vectorizer": [],
  "test_feature_names": [],
  "test_vectorizer_max_features": [
    "Vectorizer"
  ],
  "test_count_vectorizer_max_features": [],
  "test_vectorizer_max_df": [],
  "test_vectorizer_min_df": [],
  "test_count_binary_occurrences": [],
  "test_hashed_binary_occurrences": [],
  "test_vectorizer_inverse_transform": [
    "Vectorizer"
  ],
  "test_count_vectorizer_pipeline_grid_selection": [],
  "test_vectorizer_pipeline_grid_selection": [],
  "test_vectorizer_pipeline_cross_validation": [],
  "test_vectorizer_unicode": [],
  "test_tfidf_vectorizer_with_fixed_vocabulary": [],
  "test_pickling_vectorizer": [],
  "test_pickling_built_processors": [
    "factory"
  ],
  "test_countvectorizer_vocab_sets_when_pickling": [],
  "test_countvectorizer_vocab_dicts_when_pickling": [],
  "test_pickling_transformer": [],
  "test_transformer_idf_setter": [],
  "test_tfidf_vectorizer_setter": [],
  "test_tfidfvectorizer_invalid_idf_attr": [],
  "test_non_unique_vocab": [],
  "test_hashingvectorizer_nan_in_docs": [],
  "test_tfidfvectorizer_binary": [],
  "test_tfidfvectorizer_export_idf": [],
  "test_vectorizer_vocab_clone": [],
  "test_vectorizer_string_object_as_input": [
    "Vectorizer"
  ],
  "test_tfidf_transformer_type": [
    "X_dtype"
  ],
  "test_tfidf_transformer_sparse": [
    "csc_container",
    "csr_container"
  ],
  "test_tfidf_vectorizer_type": [
    "vectorizer_dtype",
    "output_dtype",
    "warning_expected"
  ],
  "test_vectorizers_invalid_ngram_range": [
    "vec"
  ],
  "_check_stop_words_consistency": [
    "estimator"
  ],
  "test_vectorizer_stop_words_inconsistent": [],
  "test_countvectorizer_sort_features_64bit_sparse_indices": [
    "csr_container"
  ],
  "test_stop_word_validation_custom_preprocessor": [
    "Estimator"
  ],
  "test_callable_analyzer_error": [
    "Estimator",
    "input_type",
    "err_type",
    "err_msg"
  ],
  "test_callable_analyzer_change_behavior": [
    "Estimator",
    "analyzer",
    "input_type"
  ],
  "test_callable_analyzer_reraise_error": [
    "tmpdir",
    "Estimator"
  ],
  "test_unused_parameters_warn": [
    "Vectorizer",
    "stop_words",
    "tokenizer",
    "preprocessor",
    "ngram_range",
    "token_pattern",
    "analyzer",
    "unused_name",
    "ovrd_name",
    "ovrd_msg"
  ],
  "test_tie_breaking_sample_order_invariance": [],
  "test_nonnegative_hashing_vectorizer_result_indices": [],
  "test_vectorizers_do_not_have_set_output": [
    "Estimator"
  ],
  "test_tfidf_transformer_copy": [
    "csr_container"
  ],
  "test_tfidf_vectorizer_perserve_dtype_idf": [
    "dtype"
  ],
  "test_hashing_vectorizer_requires_fit_tag": [],
  "test_hashing_vectorizer_transform_without_fit": [],
  "test_img_to_graph": [],
  "test_img_to_graph_sparse": [],
  "test_grid_to_graph": [],
  "test_connect_regions": [
    "raccoon_face_fxt"
  ],
  "test_connect_regions_with_grid": [
    "raccoon_face_fxt"
  ],
  "downsampled_face": [
    "raccoon_face_fxt"
  ],
  "orange_face": [
    "downsampled_face"
  ],
  "_make_images": [
    "face"
  ],
  "downsampled_face_collection": [
    "downsampled_face"
  ],
  "test_extract_patches_all": [
    "downsampled_face"
  ],
  "test_extract_patches_all_color": [
    "orange_face"
  ],
  "test_extract_patches_all_rect": [
    "downsampled_face"
  ],
  "test_extract_patches_max_patches": [
    "downsampled_face"
  ],
  "test_extract_patch_same_size_image": [
    "downsampled_face"
  ],
  "test_extract_patches_less_than_max_patches": [
    "downsampled_face"
  ],
  "test_reconstruct_patches_perfect": [
    "downsampled_face"
  ],
  "test_reconstruct_patches_perfect_color": [
    "orange_face"
  ],
  "test_patch_extractor_fit": [
    "downsampled_face_collection",
    "global_random_seed"
  ],
  "test_patch_extractor_max_patches": [
    "downsampled_face_collection",
    "global_random_seed"
  ],
  "test_patch_extractor_max_patches_default": [
    "downsampled_face_collection",
    "global_random_seed"
  ],
  "test_patch_extractor_all_patches": [
    "downsampled_face_collection",
    "global_random_seed"
  ],
  "test_patch_extractor_color": [
    "orange_face",
    "global_random_seed"
  ],
  "test_extract_patches_strided": [],
  "test_extract_patches_square": [
    "downsampled_face"
  ],
  "test_width_patch": [],
  "test_patch_extractor_wrong_input": [
    "orange_face"
  ],
  "test_dictvectorizer": [
    "sparse",
    "dtype",
    "sort",
    "iterable"
  ],
  "test_feature_selection": [],
  "test_one_of_k": [],
  "test_iterable_value": [],
  "test_iterable_not_string_error": [],
  "test_mapping_error": [],
  "test_unseen_or_no_features": [],
  "test_deterministic_vocabulary": [
    "global_random_seed"
  ],
  "test_dictvectorizer_dense_sparse_equivalence": [],
  "test_dict_vectorizer_unsupported_value_type": [],
  "test_dict_vectorizer_get_feature_names_out": [],
  "test_dict_vectorizer_not_fitted_error": [
    "method",
    "input"
  ],
  "sklearn_init": [],
  "version_line": [],
  "version": [],
  "process_tempita": [
    "fromfile",
    "outfile"
  ],
  "main": [],
  "c_step": [
    "X",
    "n_support",
    "remaining_iterations",
    "initial_estimates",
    "verbose",
    "cov_computation_method",
    "random_state"
  ],
  "_c_step": [
    "X",
    "n_support",
    "random_state",
    "remaining_iterations",
    "initial_estimates",
    "verbose",
    "cov_computation_method"
  ],
  "_consistency_factor": [
    "n_features",
    "alpha"
  ],
  "select_candidates": [
    "X",
    "n_support",
    "n_trials",
    "select",
    "n_iter",
    "verbose",
    "cov_computation_method",
    "random_state"
  ],
  "fast_mcd": [
    "X",
    "support_fraction",
    "cov_computation_method",
    "random_state"
  ],
  "MinCovDet": {
    "_nonrobust_covariance": [],
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "correct_covariance": [
      "self",
      "data"
    ],
    "reweight_covariance": [
      "self",
      "data"
    ]
  },
  "EllipticEnvelope": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "decision_function": [
      "self",
      "X"
    ],
    "score_samples": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "log_likelihood": [
    "emp_cov",
    "precision"
  ],
  "empirical_covariance": [
    "X"
  ],
  "EmpiricalCovariance": {
    "__metadata_request__score": [],
    "__init__": [
      "self"
    ],
    "_set_covariance": [
      "self",
      "covariance"
    ],
    "get_precision": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "score": [
      "self",
      "X_test",
      "y"
    ],
    "error_norm": [
      "self",
      "comp_cov",
      "norm",
      "scaling",
      "squared"
    ],
    "mahalanobis": [
      "self",
      "X"
    ]
  },
  "_ledoit_wolf": [
    "X"
  ],
  "_oas": [
    "X"
  ],
  "shrunk_covariance": [
    "emp_cov",
    "shrinkage"
  ],
  "ShrunkCovariance": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "ledoit_wolf_shrinkage": [
    "X",
    "assume_centered",
    "block_size"
  ],
  "ledoit_wolf": [
    "X"
  ],
  "LedoitWolf": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "oas": [
    "X"
  ],
  "OAS": {
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "_objective": [
    "mle",
    "precision_",
    "alpha"
  ],
  "_dual_gap": [
    "emp_cov",
    "precision_",
    "alpha"
  ],
  "_graphical_lasso": [
    "emp_cov",
    "alpha"
  ],
  "alpha_max": [
    "emp_cov"
  ],
  "graphical_lasso": [
    "emp_cov",
    "alpha"
  ],
  "BaseGraphicalLasso": {
    "__init__": [
      "self",
      "tol",
      "enet_tol",
      "max_iter",
      "mode",
      "verbose",
      "eps",
      "assume_centered"
    ]
  },
  "GraphicalLasso": {
    "__init__": [
      "self",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ]
  },
  "graphical_lasso_path": [
    "X",
    "alphas",
    "cov_init",
    "X_test",
    "mode",
    "tol",
    "enet_tol",
    "max_iter",
    "verbose",
    "eps"
  ],
  "GraphicalLassoCV": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "get_metadata_routing": [
      "self"
    ]
  },
  "X_1d": [],
  "test_mcd": [
    "global_random_seed"
  ],
  "test_fast_mcd_on_invalid_input": [],
  "test_mcd_class_on_invalid_input": [],
  "launch_mcd_on_dataset": [
    "n_samples",
    "n_features",
    "n_outliers",
    "tol_loc",
    "tol_cov",
    "tol_support",
    "seed"
  ],
  "test_mcd_issue1127": [],
  "test_mcd_issue3367": [
    "global_random_seed"
  ],
  "test_mcd_support_covariance_is_zero": [],
  "test_mcd_increasing_det_warning": [
    "global_random_seed"
  ],
  "test_mincovdet_bias_on_normal": [
    "n_samples",
    "n_features",
    "global_random_seed"
  ],
  "test_shrunk_covariance_func": [
    "n_matrices"
  ],
  "test_shrunk_covariance": [],
  "test_ledoit_wolf": [],
  "_naive_ledoit_wolf_shrinkage": [
    "X"
  ],
  "test_ledoit_wolf_small": [],
  "test_ledoit_wolf_large": [
    "global_random_seed"
  ],
  "test_ledoit_wolf_empty_array": [
    "ledoit_wolf_fitting_function"
  ],
  "test_oas": [],
  "test_EmpiricalCovariance_validates_mahalanobis": [],
  "test_graphical_lassos": [
    "global_random_seed"
  ],
  "test_graphical_lasso_when_alpha_equals_0": [
    "global_random_seed"
  ],
  "test_graphical_lasso_n_iter": [
    "mode"
  ],
  "test_graphical_lasso_iris": [],
  "test_graph_lasso_2D": [],
  "test_graphical_lasso_iris_singular": [
    "method"
  ],
  "test_graphical_lasso_cv": [
    "global_random_seed"
  ],
  "test_graphical_lasso_cv_alphas_iterable": [
    "alphas_container_type"
  ],
  "test_graphical_lasso_cv_alphas_invalid_array": [
    "alphas",
    "err_type",
    "err_msg"
  ],
  "test_graphical_lasso_cv_scores": [
    "global_random_seed"
  ],
  "test_graphical_lasso_cv_scores_with_routing": [
    "global_random_seed"
  ],
  "_assert_graphical_lasso_cv_scores": [
    "cov",
    "n_splits",
    "n_refinements",
    "n_alphas"
  ],
  "test_elliptic_envelope": [
    "global_random_seed"
  ]
}