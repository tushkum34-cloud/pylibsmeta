{
  "__all__": [],
  "TYPE_CHECKING": [],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "_logged_once": [],
  "LoggerConfig": {},
  "configure_logger": [
    "config"
  ],
  "support_log_once": [
    "record"
  ],
  "Processor": [],
  "DatasetType": [],
  "NamedModules": [],
  "_registry": [],
  "Sentinel": {
    "__new__": [
      "cls",
      "name",
      "module_name"
    ],
    "__repr__": [
      "self"
    ],
    "__reduce__": [
      "self"
    ],
    "__get_pydantic_core_schema__": [
      "cls",
      "_source_type",
      "_handler"
    ],
    "validate": [
      "cls",
      "value"
    ]
  },
  "parse_args": [],
  "trace": [
    "model_id",
    "model_class",
    "sequential_targets",
    "ignore",
    "modality",
    "trust_remote_code",
    "skip_weights",
    "device_map"
  ],
  "get_dataset_kwargs": [
    "modality",
    "ignore"
  ],
  "collate_sample": [
    "sample",
    "device"
  ],
  "main": [],
  "SparsityConfigMetadata": {
    "infer_global_sparsity": [
      "model",
      "state_dict"
    ],
    "infer_sparsity_structure": [
      "model",
      "check_only_modifiers"
    ],
    "from_pretrained": [
      "model",
      "state_dict",
      "compress",
      "quantization_format",
      "disable_sparse_compression",
      "sparsity_structure"
    ],
    "fill_config_details": [
      "config",
      "model",
      "state_dict"
    ],
    "is_sparse24_bitmask_supported": [
      "model",
      "sparsity_structure"
    ]
  },
  "__ALL__": [],
  "tensor_follows_mask_structure": [
    "tensor",
    "mask"
  ],
  "infer_sparsity_structure_from_modifiers": [
    "modifiers"
  ],
  "infer_sparsity_structure_from_model": [
    "model"
  ],
  "infer_sparse_targets_and_ignores": [
    "model",
    "sparsity_structure",
    "sparsity_threshold"
  ],
  "is_sparse_compression_target": [
    "module",
    "sparsity_threshold",
    "sparsity_structure"
  ],
  "_get_sparse_targets_ignore_dicts": [
    "module",
    "sparsity_structure",
    "sparsity_threshold"
  ],
  "_reduce_targets_and_ignores_into_lists": [
    "exhaustive_targets",
    "exhaustive_ignore"
  ],
  "modify_save_pretrained": [
    "model"
  ],
  "get_model_compressor": [
    "model",
    "sparsity_config",
    "quantization_format",
    "save_compressed",
    "skip_sparsity_compression_stats",
    "disable_sparse_compression"
  ],
  "update_and_save_recipe": [
    "model_stub",
    "save_directory"
  ],
  "RECIPE_FILE_NAME": [],
  "is_model_ct_quantized_from_path": [
    "path"
  ],
  "infer_recipe_from_model_path": [
    "model_path"
  ],
  "recipe_from_huggingface_model_id": [
    "hf_stub",
    "recipe_file_name"
  ],
  "resolve_processor_from_model_args": [
    "model_args"
  ],
  "PreprocessingFunctionRegistry": {},
  "custom_evolved_codealpaca_dataset": [
    "self",
    "data"
  ],
  "Flickr30K": {
    "DEFAULT_CHAT_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "GSM8KDataset": {
    "GSM_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "TextGenerationDataset": {
    "PROMPT_KEY": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "__call__": [
      "self",
      "add_labels"
    ],
    "load_dataset": [
      "self"
    ],
    "preprocess": [
      "self"
    ],
    "dataset_template": [
      "self"
    ],
    "rename_columns": [
      "self",
      "dataset"
    ],
    "filter_tokenizer_args": [
      "self",
      "dataset"
    ],
    "tokenize": [
      "self",
      "data"
    ],
    "group_text": [
      "self",
      "data"
    ],
    "add_labels": [
      "self",
      "data"
    ],
    "map": [
      "self",
      "dataset",
      "function"
    ]
  },
  "get_columns": [
    "dataset"
  ],
  "CNNDailyMailDataset": {
    "SAMPLE_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "EvolCodeAlpacaDataset": {
    "EVOL_ALPACA_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "PeoplesSpeech": {
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "example"
    ],
    "filter_tokenizer_args": [
      "self",
      "dataset"
    ],
    "tokenize": [
      "self",
      "data"
    ]
  },
  "OpenPlatypusDataset": {
    "ALPACA_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "C4Dataset": {
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ]
  },
  "LOGGER": [],
  "LABELS_MASK_VALUE": [],
  "get_raw_dataset": [
    "dataset_args",
    "cache_dir",
    "streaming"
  ],
  "get_custom_datasets_from_path": [
    "path",
    "ext"
  ],
  "transform_dataset_keys": [
    "data_files"
  ],
  "UltraChatDataset": {
    "DEFAULT_CHAT_TEMPLATE": [],
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ],
    "dataset_template": [
      "self",
      "sample"
    ]
  },
  "CustomDataset": {},
  "WikiTextDataset": {
    "__init__": [
      "self",
      "dataset_args",
      "split",
      "processor"
    ]
  },
  "pre_process": [
    "model_args",
    "dataset_args",
    "output_dir"
  ],
  "post_process": [
    "model_args",
    "recipe_args",
    "output_dir"
  ],
  "initialize_model_from_path": [
    "model_args"
  ],
  "initialize_processor_from_path": [
    "model_args",
    "model"
  ],
  "Oneshot": {
    "__init__": [
      "self",
      "log_dir"
    ],
    "__call__": [
      "self"
    ],
    "apply_recipe_modifiers": [
      "self",
      "calibration_dataloader",
      "recipe_stage"
    ]
  },
  "oneshot": [
    "model",
    "config_name",
    "tokenizer",
    "processor",
    "use_auth_token",
    "precision",
    "tie_word_embeddings",
    "trust_remote_code_model",
    "save_compressed",
    "model_revision",
    "recipe",
    "recipe_args",
    "clear_sparse_session",
    "stage",
    "dataset",
    "dataset_config_name",
    "dataset_path",
    "splits",
    "batch_size",
    "data_collator",
    "num_calibration_samples",
    "shuffle_calibration_samples",
    "max_seq_length",
    "pad_to_max_length",
    "text_column",
    "concatenate_data",
    "streaming",
    "overwrite_cache",
    "preprocessing_num_workers",
    "min_tokens_per_module",
    "moe_calibrate_all_experts",
    "quantization_aware_calibration",
    "output_dir",
    "log_dir"
  ],
  "process_file": [
    "file_path",
    "save_path",
    "scheme",
    "ignore",
    "device"
  ],
  "process_file_microscale_scheme": [
    "file_path",
    "save_path",
    "scheme",
    "ignore",
    "device"
  ],
  "DEFAULT_FUSED_MAPPINGS": [],
  "is_microscale_scheme": [
    "scheme"
  ],
  "get_fused_names": [
    "tensor_names"
  ],
  "weights_files": [],
  "is_weights_file": [
    "file_name"
  ],
  "get_checkpoint_files": [
    "model_stub"
  ],
  "walk_file_paths": [
    "root_dir",
    "ignore"
  ],
  "KeyType": [],
  "ValueType": [],
  "MatchedNamesSet": [],
  "gpu_if_available": [
    "device"
  ],
  "find_safetensors_index_path": [
    "save_directory"
  ],
  "find_config_path": [
    "save_directory"
  ],
  "find_safetensors_index_file": [
    "model_files"
  ],
  "match_names_set_eager": [
    "names",
    "targets",
    "return_unmatched"
  ],
  "invert_mapping": [
    "mapping"
  ],
  "update_config": [
    "save_directory",
    "scheme_name",
    "scheme",
    "ignore"
  ],
  "update_safetensors_index": [
    "save_directory",
    "total_size",
    "weight_map"
  ],
  "model_free_ptq": [
    "model_stub",
    "save_directory",
    "scheme",
    "ignore",
    "max_workers",
    "device"
  ],
  "validate_scheme": [
    "scheme"
  ],
  "validate_safetensors_index": [
    "model_files",
    "scheme"
  ],
  "reindex_fused_weights": [
    "model_stub",
    "save_directory",
    "num_workers"
  ],
  "_with_progress": [
    "fn"
  ],
  "initialize_quantized_linear": [
    "weight",
    "scheme",
    "device"
  ],
  "calibrate_global_scale": [
    "module"
  ],
  "calibrate_scale_zp": [
    "module"
  ],
  "compress_module": [
    "module"
  ],
  "wandb_available": [],
  "ALL_TOKEN": [],
  "DEFAULT_TAG": [],
  "BaseLogger": {
    "__init__": [
      "self",
      "name",
      "enabled"
    ],
    "name": [
      "self"
    ],
    "enabled": [
      "self",
      "value"
    ],
    "__repr__": [
      "self"
    ],
    "log_hyperparams": [
      "self",
      "params"
    ],
    "log_scalar": [
      "self",
      "tag",
      "value",
      "step",
      "wall_time"
    ],
    "log_scalars": [
      "self",
      "tag",
      "values",
      "step",
      "wall_time"
    ],
    "log_string": [
      "self",
      "tag",
      "string",
      "step",
      "wall_time"
    ],
    "save": [
      "self",
      "file_path"
    ]
  },
  "LambdaLogger": {
    "__init__": [
      "self",
      "lambda_func",
      "name",
      "enabled"
    ],
    "lambda_func": [
      "self"
    ],
    "log_hyperparams": [
      "self",
      "params",
      "level"
    ],
    "log_scalar": [
      "self",
      "tag",
      "value",
      "step",
      "wall_time",
      "level"
    ],
    "log_scalars": [
      "self",
      "tag",
      "values",
      "step",
      "wall_time",
      "level"
    ]
  },
  "PythonLogger": {
    "_global_file_sink_id": [],
    "__init__": [
      "self",
      "name",
      "enabled"
    ],
    "_create_default_logger": [
      "self"
    ],
    "_log_lambda": [
      "self",
      "tag",
      "value",
      "values",
      "step",
      "wall_time",
      "level"
    ],
    "log_string": [
      "self",
      "tag",
      "string",
      "step",
      "wall_time",
      "level"
    ]
  },
  "TensorBoardLogger": {
    "__init__": [
      "self",
      "log_path",
      "writer",
      "name",
      "enabled"
    ],
    "available": [],
    "writer": [
      "self"
    ],
    "_log_lambda": [
      "self",
      "tag",
      "value",
      "values",
      "step",
      "wall_time",
      "level"
    ]
  },
  "WANDBLogger": {
    "available": [],
    "__init__": [
      "self",
      "init_kwargs",
      "name",
      "enabled",
      "wandb_err"
    ],
    "_log_lambda": [
      "self",
      "tag",
      "value",
      "values",
      "step",
      "wall_time",
      "level"
    ],
    "save": [
      "self",
      "file_path"
    ]
  },
  "SparsificationGroupLogger": {
    "__init__": [
      "self",
      "lambda_func",
      "python",
      "python_log_level",
      "tensorboard",
      "wandb_",
      "name",
      "enabled"
    ],
    "enabled": [
      "self",
      "value"
    ],
    "loggers": [
      "self"
    ],
    "log_hyperparams": [
      "self",
      "params",
      "level"
    ],
    "log_scalar": [
      "self",
      "tag",
      "value",
      "step",
      "wall_time",
      "level"
    ],
    "log_scalars": [
      "self",
      "tag",
      "values",
      "step",
      "wall_time",
      "level"
    ]
  },
  "LoggerManager": {
    "__init__": [
      "self",
      "loggers",
      "log_frequency",
      "log_python",
      "name",
      "mode",
      "frequency_type"
    ],
    "__len__": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "add_logger": [
      "self",
      "logger"
    ],
    "log_ready": [
      "self",
      "current_log_step",
      "last_log_step",
      "check_model_update"
    ],
    "log_written": [
      "self",
      "step"
    ],
    "model_updated": [
      "self",
      "step"
    ],
    "epoch_to_step": [
      "epoch",
      "steps_per_epoch"
    ],
    "loggers": [
      "self",
      "value"
    ],
    "log_frequency": [
      "self",
      "value"
    ],
    "name": [
      "self"
    ],
    "wandb": [
      "self"
    ],
    "log_scalar": [
      "self",
      "tag",
      "value",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "log_scalars": [
      "self",
      "tag",
      "values",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "log_hyperparams": [
      "self",
      "params",
      "log_types",
      "level"
    ],
    "log_string": [
      "self",
      "tag",
      "string",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "save": [
      "self",
      "file_path"
    ],
    "time": [
      "self",
      "tag"
    ]
  },
  "LoggingWrapperBase": {
    "__init__": [
      "self",
      "loggers",
      "frequency_manager"
    ],
    "__repr__": [
      "self"
    ]
  },
  "SystemLoggingWrapper": {
    "log_string": [
      "self",
      "tag",
      "string",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "debug": [
      "self",
      "tag",
      "string"
    ],
    "info": [
      "self",
      "tag",
      "string"
    ],
    "warning": [
      "self",
      "tag",
      "string"
    ],
    "warn": [
      "self",
      "tag",
      "string"
    ],
    "error": [
      "self",
      "tag",
      "string"
    ],
    "critical": [
      "self",
      "tag",
      "string"
    ]
  },
  "MetricLoggingWrapper": {
    "log_hyperparams": [
      "self",
      "params",
      "log_types",
      "level"
    ],
    "log_scalar": [
      "self",
      "tag",
      "value",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "log_scalars": [
      "self",
      "tag",
      "values",
      "step",
      "wall_time",
      "log_types",
      "level"
    ],
    "add_scalar": [
      "self",
      "value",
      "tag",
      "step",
      "wall_time"
    ],
    "add_scalars": [
      "self",
      "values",
      "tag",
      "step",
      "wall_time"
    ],
    "log": [
      "self",
      "data",
      "step",
      "tag"
    ]
  },
  "_create_dirs": [
    "path"
  ],
  "LogStepType": [],
  "LoggingModeType": [],
  "FrequencyType": [],
  "DEFAULT_FREQUENCY_TYPE": [],
  "DEFAULT_LOGGING_MODE": [],
  "FrequencyManager": {
    "__init__": [
      "self",
      "log_frequency",
      "mode",
      "frequency_type"
    ],
    "__repr__": [
      "self"
    ],
    "log_ready": [
      "self",
      "current_log_step",
      "check_model_update"
    ],
    "model_updated": [
      "self",
      "step"
    ],
    "log_written": [
      "self",
      "step"
    ],
    "log_frequency": [
      "self",
      "log_frequency"
    ],
    "is_optim_frequency_manager": [
      "self"
    ],
    "is_epoch_frequency_manager": [
      "self"
    ],
    "_validate_log_frequency": [
      "self",
      "log_frequency"
    ],
    "_validate_log_step": [
      "self",
      "log_step"
    ],
    "_set_logging_mode": [
      "self",
      "mode"
    ],
    "_set_frequency_type": [
      "self",
      "frequency_type"
    ]
  },
  "log_ready": [
    "current_log_step",
    "last_log_step",
    "log_frequency",
    "last_model_update_step",
    "check_model_update"
  ],
  "_basic_normalization": [
    "value"
  ],
  "DatasetMetaData": {},
  "ParamMetaData": {},
  "LayerMetaData": {},
  "ModelMetaData": {},
  "_load_json_or_yaml_string": [
    "content"
  ],
  "_parse_recipe_from_md": [
    "file_path",
    "yaml_str"
  ],
  "get_yaml_serializable_dict": [
    "modifiers",
    "stage"
  ],
  "filter_dict": [
    "obj",
    "target_stage"
  ],
  "append_recipe_dict": [
    "d1",
    "d2"
  ],
  "Recipe": {
    "model_config": [],
    "from_modifiers": [
      "cls",
      "modifiers",
      "modifier_group_name"
    ],
    "create_instance": [
      "cls",
      "path_or_modifiers",
      "modifier_group_name",
      "target_stage"
    ],
    "from_dict": [
      "cls",
      "recipe_dict"
    ],
    "dict": [
      "self"
    ],
    "yaml": [
      "self",
      "file_path",
      "existing_recipe_path"
    ]
  },
  "RecipeInput": [],
  "RecipeStageInput": [],
  "RecipeArgsInput": [],
  "MovingAverageObserverBase": {
    "__init__": [
      "self",
      "base_name",
      "args",
      "module"
    ],
    "get_current_min_max": [
      "self",
      "observed"
    ],
    "get_current_global_min_max": [
      "self",
      "observed"
    ],
    "get_min_max": [
      "self",
      "observed"
    ],
    "get_global_min_max": [
      "self",
      "observed"
    ],
    "_lerp": [
      "self",
      "input",
      "end",
      "weight"
    ]
  },
  "MinMaxTuple": [],
  "ScaleZpTuple": [],
  "Observer": {
    "__init__": [
      "self",
      "base_name",
      "args",
      "module"
    ],
    "get_min_max": [
      "self",
      "observed"
    ],
    "get_global_min_max": [
      "self",
      "observed"
    ],
    "forward": [
      "self",
      "observed"
    ],
    "get_global_scale": [
      "self",
      "observed"
    ],
    "_forward_with_minmax": [
      "self",
      "observed"
    ],
    "_get_global_scale_with_minmax": [
      "self",
      "observed"
    ],
    "_get_module_param": [
      "self",
      "name"
    ],
    "_check_has_global_scale": [
      "self",
      "global_scale"
    ]
  },
  "flatten_for_calibration": [
    "value",
    "base_name",
    "args",
    "g_idx"
  ],
  "_flatten_weight": [
    "value",
    "args",
    "g_idx"
  ],
  "_flatten_activation": [
    "value",
    "args"
  ],
  "_flatten_attention": [
    "value",
    "args"
  ],
  "MemorylessMinMaxObserver": {
    "get_min_max": [
      "self",
      "observed"
    ],
    "get_global_min_max": [
      "self",
      "observed"
    ]
  },
  "StaticMinMaxObserver": {
    "__init__": [
      "self"
    ],
    "get_min_max": [
      "self",
      "observed"
    ],
    "get_global_min_max": [
      "self",
      "observed"
    ]
  },
  "MinMaxObserver": {
    "get_current_min_max": [
      "self",
      "observed"
    ],
    "get_current_global_min_max": [
      "self",
      "observed"
    ]
  },
  "_get_min_max": [
    "observed"
  ],
  "MemorylessMSEObserver": {
    "__init__": [
      "self"
    ],
    "get_min_max": [
      "self",
      "observed"
    ],
    "get_global_min_max": [
      "self",
      "observed"
    ]
  },
  "MovingAverageMSEObserver": {
    "__init__": [
      "self"
    ],
    "get_current_min_max": [
      "self",
      "observed"
    ],
    "get_current_global_min_max": [
      "self",
      "observed"
    ]
  },
  "_grid_search_mse": [
    "observed",
    "args",
    "maxshrink",
    "patience",
    "grid",
    "norm",
    "global_scale",
    "optimize_global_scale"
  ],
  "BS_WARNING_THRESHOLD": [],
  "get_processed_dataset": [
    "dataset_args",
    "processor",
    "do_oneshot",
    "do_train"
  ],
  "get_calibration_dataloader": [
    "dataset_args",
    "processor"
  ],
  "format_calibration_data": [
    "args",
    "tokenized_dataset",
    "processor"
  ],
  "make_dataset_splits": [
    "tokenized_datasets",
    "do_oneshot",
    "do_train"
  ],
  "_make_collate_fn": [
    "args",
    "processor"
  ],
  "_make_sampler": [
    "args",
    "dataset"
  ],
  "data_collator_with_truncation": [
    "features",
    "return_tensors"
  ],
  "LengthAwareSampler": {
    "__init__": [
      "self",
      "data_source",
      "num_samples"
    ],
    "num_samples": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "CalibrationQwen3NextSparseMoeBlock": {
    "is_permanent": [],
    "__init__": [
      "self",
      "original",
      "config",
      "calibrate_all_experts"
    ],
    "forward": [
      "self",
      "hidden_states"
    ],
    "restore": [
      "self",
      "original"
    ]
  },
  "PRECISION": [],
  "center_embeddings": [
    "embedding"
  ],
  "fuse_norm_linears": [
    "norm",
    "linears"
  ],
  "SequentialLlama4TextMoe": {
    "is_permanent": [],
    "__init__": [
      "self",
      "original",
      "config",
      "calibrate_all_experts"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "SequentialLlama4TextExperts": {
    "__init__": [
      "self",
      "config",
      "original"
    ]
  },
  "GraniteMoeHybridParallelExpertsLinear": {
    "__init__": [
      "self",
      "num_experts",
      "input_size",
      "output_size"
    ],
    "from_3d_expert": [
      "cls",
      "original"
    ],
    "to_3d_expert": [
      "self"
    ],
    "forward": [
      "self",
      "inputs",
      "expert_size"
    ],
    "__repr__": [
      "self"
    ]
  },
  "CalibrationQwen3MoeSparseMoeBlock": {
    "is_permanent": [],
    "__init__": [
      "self",
      "original",
      "config",
      "calibrate_all_experts"
    ],
    "forward": [
      "self",
      "hidden_states"
    ],
    "restore": [
      "self",
      "original"
    ]
  },
  "CalibrateQwen3VLMoeTextSparseMoeBlock": {
    "is_permanent": [],
    "__init__": [
      "self",
      "original",
      "config",
      "calibrate_all_experts"
    ],
    "forward": [
      "self",
      "hidden_states"
    ],
    "restore": [
      "self",
      "original"
    ]
  },
  "SequentialQwen3VLMoeTextExperts": {
    "__init__": [
      "self",
      "config",
      "original"
    ]
  },
  "MoECalibrationModule": {
    "restore": [
      "self",
      "original"
    ]
  },
  "moe_calibration_context": [
    "model",
    "calibrate_all_experts"
  ],
  "_is_registered": [
    "name",
    "subclass"
  ],
  "CalibrationDeepseekV3MoE": {
    "is_permanent": [],
    "__init__": [
      "self",
      "original",
      "config",
      "calibrate_all_experts"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "COMPLETED_STAGES_FILENAME": [],
  "save_checkpoint": [
    "save_path",
    "model",
    "processor",
    "save_safetensors",
    "save_compressed",
    "skip_sparsity_compression_stats"
  ],
  "parse_dtype": [
    "dtype_arg"
  ],
  "get_session_model": [],
  "get_completed_stages": [
    "checkpoint_dir"
  ],
  "save_completed_stages": [
    "checkpoint_dir",
    "completed_stages"
  ],
  "load_safetensors_state_dict": [
    "file_path"
  ],
  "copy_python_files_from_model_cache": [
    "model",
    "save_path"
  ],
  "tensors_to_device": [
    "tensors",
    "device"
  ],
  "tensors_to_precision": [
    "tensors",
    "full_precision"
  ],
  "tensors_module_forward": [
    "tensors",
    "module",
    "check_feat_lab_inp"
  ],
  "tensor_sparsity": [
    "tens",
    "dim"
  ],
  "get_linear_layers": [
    "module"
  ],
  "get_quantized_layers": [
    "module"
  ],
  "set_deterministic_seeds": [
    "seed"
  ],
  "ModuleSparsificationInfo": {
    "__init__": [
      "self",
      "module",
      "state_dict"
    ],
    "__str__": [
      "self"
    ],
    "params_total": [
      "self"
    ],
    "params_sparse": [
      "self"
    ],
    "params_sparse_percent": [
      "self"
    ],
    "params_quantized": [
      "self"
    ],
    "params_quantized_percent": [
      "self"
    ]
  },
  "get_leaf_operations": [
    "model",
    "operations_to_skip",
    "operations_to_unwrap"
  ],
  "is_quantized": [
    "operation"
  ],
  "get_precision_information": [
    "operation"
  ],
  "_get_num_bits": [
    "dtype"
  ],
  "SparsificationInfo": {
    "from_module": [
      "cls",
      "module"
    ],
    "loggable_items": [
      "self"
    ],
    "filter_loggable_items_percentages_only": [
      "items_to_log",
      "percentage_only"
    ],
    "filter_loggable_items_non_zero_only": [
      "items_to_log",
      "non_zero_only"
    ],
    "_filter_items_to_log": [
      "items_to_log",
      "filter_function",
      "to_filter"
    ]
  },
  "CountAndPercent": {},
  "SparsificationSummaries": {
    "from_module": [
      "cls",
      "module",
      "pruning_thresholds"
    ],
    "loggable_items": [
      "self",
      "non_zero_only",
      "percentages_only"
    ]
  },
  "SparsificationPruning": {
    "from_module": [
      "cls",
      "module"
    ],
    "loggable_items": [
      "self",
      "percentages_only",
      "non_zero_only"
    ]
  },
  "SparsificationQuantization": {
    "model_config": [],
    "from_module": [
      "cls",
      "module"
    ],
    "loggable_items": [
      "self",
      "enabled_only"
    ]
  },
  "skip_weights_download": [
    "model_class"
  ],
  "skip_weights_initialize": [
    "use_zeros"
  ],
  "patch_transformers_logger_level": [
    "level"
  ],
  "dispatch_for_generation": [
    "model"
  ],
  "ALL_PRUNABLE_TOKEN": [],
  "FROM_PARAM_TOKEN": [],
  "RECIPE_METADATA_KEY": [],
  "FRAMEWORK_METADATA_KEY": [],
  "ROOT_PATH": [],
  "flatten_iterable": [
    "li"
  ],
  "convert_to_bool": [
    "val"
  ],
  "validate_str_iterable": [
    "val",
    "error_desc"
  ],
  "bucket_iterable": [
    "val",
    "num_buckets",
    "edge_percent",
    "sort_highest",
    "sort_key"
  ],
  "INTERPOLATION_FUNCS": [],
  "interpolate": [
    "x_cur",
    "x0",
    "x1",
    "y0",
    "y1",
    "inter_func"
  ],
  "interpolate_list_linear": [
    "measurements",
    "x_val"
  ],
  "interpolated_integral": [
    "measurements"
  ],
  "clean_path": [
    "path"
  ],
  "create_dirs": [
    "path"
  ],
  "create_parent_dirs": [
    "path"
  ],
  "create_unique_dir": [
    "path",
    "check_number"
  ],
  "path_file_count": [
    "path",
    "pattern"
  ],
  "path_file_size": [
    "path"
  ],
  "is_url": [
    "val"
  ],
  "NDARRAY_KEY": [],
  "load_numpy": [
    "file_path"
  ],
  "save_numpy": [
    "array",
    "export_dir",
    "name",
    "npz"
  ],
  "_fix_loaded_numpy": [
    "array"
  ],
  "load_numpy_from_tar": [
    "path"
  ],
  "load_numpy_list": [
    "data"
  ],
  "load_labeled_data": [
    "data",
    "labels",
    "raise_on_error"
  ],
  "NumpyArrayBatcher": {
    "__init__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "append": [
      "self",
      "item"
    ],
    "stack": [
      "self"
    ]
  },
  "tensor_export": [
    "tensor",
    "export_dir",
    "name",
    "npz"
  ],
  "tensors_export": [
    "tensors",
    "export_dir",
    "name_prefix",
    "counter",
    "break_batch"
  ],
  "_tensors_export_recursive": [
    "tensors",
    "export_dir",
    "name_prefix",
    "counter",
    "exported_paths"
  ],
  "_tensors_export_batch": [
    "tensors",
    "export_dir",
    "name_prefix",
    "counter",
    "exported_paths"
  ],
  "json_to_jsonl": [
    "json_file_path",
    "overwrite"
  ],
  "deprecation_warning": [
    "message"
  ],
  "is_package_available": [
    "package_name",
    "return_version"
  ],
  "import_from_path": [
    "path"
  ],
  "getattr_chain": [
    "obj",
    "chain_str"
  ],
  "disable_cache": [
    "module"
  ],
  "DisableQuantization": [
    "module"
  ],
  "eval_context": [
    "module"
  ],
  "disable_hf_kernels": [
    "module"
  ],
  "calibration_forward_context": [
    "model"
  ],
  "disable_lm_head": [
    "model"
  ],
  "patch_attr": [
    "base",
    "attr",
    "value"
  ],
  "DISABLE_QAC_MODIFIERS": [],
  "untie_word_embeddings": [
    "model"
  ],
  "targets_embeddings": [
    "model",
    "targets",
    "check_input",
    "check_output"
  ],
  "get_embeddings": [
    "model"
  ],
  "get_GPU_memory_usage": [],
  "get_GPU_usage_nv": [],
  "get_GPU_usage_amd": [],
  "get_layer_size_mb": [
    "module"
  ],
  "CompressionLogger": {
    "__init__": [
      "self",
      "module"
    ],
    "set_loss": [
      "self",
      "loss"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "_exc_type",
      "_exc_val",
      "_exc_tb"
    ]
  },
  "measure_cuda_memory": {
    "__init__": [
      "self",
      "device"
    ],
    "reset_peak_memory_stats": [
      "self"
    ],
    "current_memory_usage": [
      "self"
    ],
    "peak_memory_usage": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ]
  },
  "ALL_TARGET": [],
  "ALL_PRUNABLE_TARGET": [],
  "ALL_QUANTIZABLE_TARGET": [],
  "match_targets": [
    "name",
    "targets"
  ],
  "match_class": [
    "layer",
    "targets"
  ],
  "get_default_params": [
    "layers"
  ],
  "match_layers_params": [
    "targets",
    "module",
    "params"
  ],
  "get_layers": [
    "targets",
    "module",
    "exclude_internal_modules"
  ],
  "get_layer": [
    "target",
    "module"
  ],
  "set_layer": [
    "target",
    "layer",
    "module"
  ],
  "get_params": [
    "targets",
    "module"
  ],
  "get_param": [
    "target",
    "module"
  ],
  "get_terminal_layers": [
    "module"
  ],
  "get_prunable_layers": [
    "module"
  ],
  "get_quantizable_layers": [
    "module"
  ],
  "qat_active": [
    "module"
  ],
  "get_layers_params": [
    "targets",
    "module"
  ],
  "get_matching_layer": [
    "target",
    "name_to_match",
    "module"
  ],
  "get_no_split_params": [
    "model"
  ],
  "get_layer_by_name": [
    "layer_name",
    "module"
  ],
  "get_module_to_name_dict": [
    "model"
  ],
  "is_fsdp_model": [
    "model"
  ],
  "maybe_get_wrapped": [
    "model"
  ],
  "set_wrapped_model": [
    "state",
    "wrapped_model"
  ],
  "get_fsdp_parent": [
    "layer_name",
    "model"
  ],
  "summon_full_params_context": [
    "model",
    "offload_to_cpu"
  ],
  "main_process_first_context": [],
  "fix_fsdp_module_name": [
    "name"
  ],
  "RecipeArguments": {},
  "ModelArguments": {},
  "DVCDatasetArguments": {},
  "CustomDatasetArguments": {},
  "DatasetArguments": {
    "is_dataset_provided": [
      "self"
    ]
  },
  "IntermediateValue": {},
  "IntermediateValues": [],
  "IntermediatesCache": {
    "__init__": [
      "self",
      "batch_intermediates",
      "offload_device"
    ],
    "empty": [
      "cls",
      "num_batches",
      "offload_device"
    ],
    "from_dataloader": [
      "cls",
      "dataloader",
      "model_device",
      "offload_device"
    ],
    "fetch": [
      "self",
      "batch_index",
      "input_names"
    ],
    "update": [
      "self",
      "batch_index",
      "values"
    ],
    "delete": [
      "self",
      "batch_index",
      "consumed_names"
    ],
    "append": [
      "self",
      "values"
    ],
    "size": [
      "self"
    ],
    "iter": [
      "self",
      "input_names"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "_onload_value": [
      "cls",
      "intermediate"
    ],
    "_offload_value": [
      "cls",
      "value",
      "offload_device",
      "onload_device"
    ]
  },
  "CalibrationPipeline": {
    "__call__": [
      "model",
      "dataloader",
      "dataset_args"
    ],
    "from_modifiers": [
      "cls",
      "modifiers",
      "user"
    ],
    "_infer_pipeline": [
      "modifiers"
    ]
  },
  "IndependentPipeline": {
    "__call__": [
      "model",
      "dataloader",
      "dataset_args"
    ]
  },
  "BasicPipeline": {
    "__call__": [
      "model",
      "dataloader",
      "dataset_args"
    ]
  },
  "run_calibration": [
    "model",
    "dataloader"
  ],
  "DataFreePipeline": {
    "__call__": [
      "model",
      "dataloader",
      "dataset_args"
    ]
  },
  "Subgraph": {
    "forward": [
      "self"
    ],
    "submodules": [
      "self",
      "model",
      "recurse"
    ]
  },
  "trace_subgraphs": [
    "model",
    "sample_input",
    "sequential_targets",
    "ignore"
  ],
  "SequentialTracer": {
    "__init__": [
      "self",
      "ancestors",
      "offloaded"
    ],
    "create_arg": [
      "self",
      "a"
    ],
    "is_leaf_module": [
      "self",
      "module",
      "module_qualified_name"
    ]
  },
  "populate_concrete_args": [
    "model",
    "sample_input"
  ],
  "find_target_nodes": [
    "graph",
    "targets"
  ],
  "topological_partition": [
    "graph",
    "targets"
  ],
  "partition_graph": [
    "model",
    "partitions"
  ],
  "trace_consumed_names": [
    "subgraphs"
  ],
  "graph_is_well_formed": [
    "graph"
  ],
  "match_modules": [
    "model",
    "target_names"
  ],
  "get_sequential_targets": [
    "modifiers",
    "model",
    "args"
  ],
  "add_line_numbers": [
    "text"
  ],
  "get_sequential_ancestors": [
    "model",
    "targets"
  ],
  "dispatch_for_sequential": [
    "model"
  ],
  "_get_autowrap_functions": [],
  "logger": [],
  "_IS_IN_DEBUG_MODE": [],
  "_generate_supported_model_class_names": [
    "model_name",
    "supported_tasks"
  ],
  "_REGULAR_SUPPORTED_MODEL_NAMES_AND_TASKS": [],
  "_FX_SUPPORTED_MODELS_WITH_KV_CACHE": [],
  "_REGULAR_SUPPORTED_MODELS": [],
  "_SPECIAL_SUPPORTED_MODELS": [],
  "_SUPPORTED_MODELS": [],
  "_CURRENT_TRACER": [],
  "torch_nn_embedding": [
    "self",
    "input"
  ],
  "torch_nn_functional_embedding": [
    "input",
    "weight",
    "padding_idx",
    "max_norm",
    "norm_type",
    "scale_grad_by_freq",
    "sparse"
  ],
  "torch_nn_layernorm": [
    "self",
    "input"
  ],
  "torch_nn_groupnorm": [
    "self",
    "input"
  ],
  "torch_nn_linear": [
    "self",
    "input"
  ],
  "torch_relu": [
    "x"
  ],
  "torch_nn_relu": [
    "self",
    "x"
  ],
  "torch_nn_functional_relu": [
    "x",
    "inplace"
  ],
  "torch_where": [
    "condition",
    "x",
    "y"
  ],
  "torch_abs": [
    "input"
  ],
  "torch_arange": [],
  "torch_full": [],
  "torch_cat": [
    "tensors",
    "dim",
    "axis"
  ],
  "torch_stack": [
    "tensors",
    "dim",
    "axis"
  ],
  "torch_add": [
    "input",
    "other"
  ],
  "torch_mul": [
    "input",
    "other"
  ],
  "torch_tensor_mul": [
    "self",
    "other"
  ],
  "torch_matmul": [
    "input",
    "other"
  ],
  "torch_bmm": [
    "input",
    "mat2"
  ],
  "torch_baddbmm": [
    "input",
    "batch1",
    "batch2"
  ],
  "torch_tensor_baddbmm": [
    "self",
    "batch1",
    "batch2"
  ],
  "torch_einsum": [
    "equation"
  ],
  "torch_tensor_repeat": [
    "self"
  ],
  "torch_repeat_interleave": [],
  "torch_index_select": [
    "input",
    "dim",
    "index"
  ],
  "torch_tensor_index_select": [
    "self",
    "dim",
    "index"
  ],
  "torch_gather": [
    "input",
    "dim",
    "index"
  ],
  "torch_tensor_gather": [
    "self",
    "dim",
    "index"
  ],
  "torch_roll": [
    "input",
    "shifts",
    "dims"
  ],
  "torch_flip": [
    "input",
    "dims"
  ],
  "torch_tensor_flip": [
    "self",
    "dims"
  ],
  "torch_nn_conv1d": [
    "self",
    "input"
  ],
  "torch_nn_conv2d": [
    "self",
    "input"
  ],
  "torch_squeeze": [
    "input",
    "dim"
  ],
  "torch_tensor_squeeze": [
    "self",
    "dim"
  ],
  "torch_unsqueeze": [
    "input",
    "dim"
  ],
  "torch_tensor_unsqueeze": [
    "self",
    "dim"
  ],
  "torch_unique_consecutive": [
    "input"
  ],
  "torch_nn_functional_one_hot": [
    "tensor",
    "num_classes"
  ],
  "torch_nn_functional_scaled_dot_product_attention": [
    "query",
    "key",
    "value",
    "attn_mask",
    "dropout_p",
    "is_causal",
    "scale"
  ],
  "torch_nn_mseloss": [
    "self",
    "input",
    "target"
  ],
  "torch_nn_crossentropyloss": [
    "self",
    "input",
    "target"
  ],
  "torch_nn_bcewithlogitsloss": [
    "self",
    "input",
    "target"
  ],
  "operator_getitem": [
    "a",
    "b"
  ],
  "HFProxy": {
    "install_metadata": [
      "self",
      "metadata"
    ],
    "shape": [
      "self"
    ],
    "device": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__bool__": [
      "self"
    ],
    "__getattr__": [
      "self",
      "k"
    ],
    "__setitem__": [
      "self",
      "indices",
      "values"
    ],
    "__contains__": [
      "self",
      "key"
    ]
  },
  "HFAttribute": {
    "__init__": [
      "self",
      "root",
      "attr"
    ],
    "node": [
      "self"
    ],
    "__call__": [
      "self"
    ]
  },
  "MetaDeviceAttribute": {},
  "HFCacheProxy": {
    "install_orig_cache_cls": [
      "self",
      "orig_cache_cls"
    ],
    "__class__": [
      "self"
    ]
  },
  "create_wrapper": [
    "function",
    "op_type",
    "proxy_factory_fn"
  ],
  "HFProxyableClassMeta": {
    "__new__": [
      "cls",
      "name",
      "bases",
      "attrs",
      "proxy_factory_fn"
    ]
  },
  "gen_constructor_wrapper": [
    "target"
  ],
  "_proxies_to_metas": [
    "v"
  ],
  "create_cache_proxy_factory_fn": [
    "orig_cache_cls"
  ],
  "ProxyableCache": [],
  "ProxyableDynamicCache": [],
  "ProxyableStaticCache": [],
  "_generate_random_int": [
    "low",
    "high",
    "forbidden_values"
  ],
  "HFTracer": {
    "_TORCH_METHODS_TO_PATCH": [],
    "_CLASSES_TO_PATCH": [],
    "supported_archs": [],
    "__init__": [
      "self",
      "autowrap_modules",
      "autowrap_functions"
    ],
    "_generate_dummy_input": [
      "self",
      "model",
      "input_name",
      "shape",
      "input_names"
    ],
    "create_proxy": [
      "self",
      "kind",
      "target",
      "args",
      "kwargs",
      "name",
      "type_expr",
      "proxy_factory_fn"
    ],
    "_module_getattr": [
      "self",
      "attr",
      "attr_val",
      "parameter_proxy_cache"
    ],
    "getattr": [
      "self",
      "attr",
      "attr_val",
      "parameter_proxy_cache"
    ],
    "call_module": [
      "self",
      "m",
      "forward",
      "args",
      "kwargs"
    ],
    "proxy": [
      "self",
      "node"
    ],
    "patch_for_tracing": [
      "self",
      "root"
    ],
    "trace": [
      "self",
      "root",
      "concrete_args",
      "dummy_inputs",
      "complete_concrete_args_with_inputs_not_in_dummy_inputs"
    ],
    "_stateless_mod_instantiation_depends_on_proxies": [
      "self",
      "mod"
    ],
    "_insert_module_as_submodule": [
      "self",
      "mod"
    ],
    "path_of_module": [
      "self",
      "mod"
    ],
    "is_leaf_module": [
      "self",
      "m",
      "module_qualified_name"
    ],
    "keys": [
      "self",
      "obj"
    ]
  },
  "get_concrete_args": [
    "model",
    "input_names"
  ],
  "is_model_supported": [
    "model"
  ],
  "check_if_model_is_supported": [
    "model"
  ],
  "symbolic_trace": [
    "model",
    "input_names",
    "disable_check",
    "tracer_cls"
  ],
  "SequentialPipeline": {
    "__call__": [
      "model",
      "dataloader",
      "dataset_args"
    ]
  },
  "autowrap_forwards": [
    "modules",
    "ignore"
  ],
  "autowrap_forward": [
    "module",
    "ignore"
  ],
  "append_autowrap_source_on_fail": [],
  "ControlFlowAnalyzer": {
    "_context_types": [],
    "is_valid": [
      "self",
      "node"
    ],
    "generic_visit": [
      "self",
      "node"
    ],
    "visit_Return": [
      "self",
      "node"
    ],
    "visit_Continue": [
      "self",
      "node"
    ],
    "visit_Break": [
      "self",
      "node"
    ],
    "visit_Await": [
      "self",
      "node"
    ],
    "visit_Yield": [
      "self",
      "node"
    ]
  },
  "NameAnalyzer": {
    "__init__": [
      "self",
      "omit"
    ],
    "analyze": [
      "self",
      "node"
    ],
    "visit_Name": [
      "self",
      "node"
    ],
    "visit_Assign": [
      "self",
      "node"
    ],
    "visit_NamedExpr": [
      "self",
      "node"
    ],
    "visit_If": [
      "self",
      "node"
    ]
  },
  "AutoWrapper": {
    "__init__": [
      "self",
      "namespace",
      "ignore"
    ],
    "auto_wrap": [
      "self",
      "tree"
    ],
    "visit_FunctionDef": [
      "self",
      "node"
    ],
    "visit_Name": [
      "self",
      "node"
    ],
    "visit_Delete": [
      "self",
      "node"
    ],
    "visit_If": [
      "self",
      "node"
    ],
    "visit_Tuple": [
      "self",
      "node"
    ],
    "visit_Call": [
      "self",
      "node"
    ],
    "_eval_expr": [
      "self",
      "node"
    ],
    "_can_wrap": [
      "self",
      "node"
    ],
    "_wrap_if_possible": [
      "self",
      "node"
    ],
    "_wrap_stmt": [
      "self",
      "node"
    ],
    "_wrap_expr": [
      "self",
      "node"
    ]
  },
  "ModelParameterizedLayer": {},
  "should_log_model_info": [
    "model",
    "loggers",
    "current_log_step",
    "last_log_step"
  ],
  "log_model_info": [
    "state",
    "current_log_step"
  ],
  "_log_current_step": [
    "logger_manager",
    "current_log_step"
  ],
  "_log_model_loggable_items": [
    "logger_manager",
    "loggable_items",
    "epoch"
  ],
  "Data": {},
  "Hardware": {},
  "State": {
    "compression_ready": [
      "self"
    ],
    "update": [
      "self",
      "model",
      "teacher_model",
      "optimizer",
      "attach_optim_callbacks",
      "train_data",
      "val_data",
      "test_data",
      "calib_data",
      "copy_data",
      "start",
      "steps_per_epoch",
      "batches_per_step",
      "loggers",
      "model_log_cadence"
    ]
  },
  "ModifiedState": {
    "__init__": [
      "self",
      "model",
      "optimizer",
      "loss",
      "modifier_data"
    ]
  },
  "_global_session": [],
  "_local_storage": [],
  "create_session": [],
  "active_session": [],
  "reset_session": [],
  "LifecycleCallbacks": {
    "event": [
      "cls",
      "event_type"
    ],
    "batch_start": [
      "cls",
      "batch_data"
    ],
    "loss_calculated": [
      "cls",
      "loss"
    ],
    "optim_pre_step": [
      "cls"
    ],
    "optim_post_step": [
      "cls"
    ],
    "batch_end": [
      "cls"
    ],
    "calibration_epoch_start": [
      "cls"
    ],
    "sequential_epoch_end": [
      "cls",
      "subgraph"
    ],
    "calibration_epoch_end": [
      "cls"
    ]
  },
  "callbacks": [],
  "_CallbackContainer": {},
  "CompressionSession": {
    "__init__": [
      "self"
    ],
    "lifecycle": [
      "self"
    ],
    "state": [
      "self"
    ],
    "initialize": [
      "self",
      "recipe",
      "recipe_stage",
      "recipe_args",
      "model",
      "teacher_model",
      "optimizer",
      "attach_optim_callbacks",
      "train_data",
      "val_data",
      "test_data",
      "calib_data",
      "copy_data",
      "start",
      "steps_per_epoch",
      "batches_per_step",
      "loggers"
    ],
    "finalize": [
      "self"
    ],
    "event": [
      "self",
      "event_type",
      "batch_data",
      "loss"
    ],
    "log": [
      "self",
      "event_type",
      "loss"
    ],
    "reset": [
      "self"
    ],
    "reset_stage": [
      "self"
    ],
    "get_serialized_recipe": [
      "self"
    ],
    "_log_model_info": [
      "self"
    ],
    "_log_loss": [
      "self",
      "event_type",
      "loss"
    ]
  },
  "CompressionLifecycle": {
    "reset": [
      "self"
    ],
    "initialize": [
      "self",
      "recipe",
      "recipe_stage",
      "recipe_args"
    ],
    "finalize": [
      "self"
    ],
    "event": [
      "self",
      "event_type",
      "global_step"
    ],
    "_validate_event_order": [
      "self",
      "event_type"
    ]
  },
  "EventType": {
    "INITIALIZE": [],
    "FINALIZE": [],
    "BATCH_START": [],
    "LOSS_CALCULATED": [],
    "BATCH_END": [],
    "CALIBRATION_EPOCH_START": [],
    "SEQUENTIAL_EPOCH_END": [],
    "CALIBRATION_EPOCH_END": [],
    "OPTIM_PRE_STEP": [],
    "OPTIM_POST_STEP": []
  },
  "Event": {
    "epoch_based": [
      "self"
    ],
    "epoch": [
      "self"
    ],
    "epoch_full": [
      "self"
    ],
    "epoch_step": [
      "self"
    ],
    "epoch_batch": [
      "self"
    ],
    "current_index": [
      "self",
      "value"
    ],
    "should_update": [
      "self",
      "start",
      "end",
      "update"
    ],
    "new_instance": [
      "self"
    ]
  },
  "ModifierInterface": {
    "initialized": [
      "self"
    ],
    "finalized": [
      "self"
    ],
    "initialize": [
      "self",
      "state"
    ],
    "finalize": [
      "self",
      "state"
    ],
    "update_event": [
      "self",
      "state",
      "event"
    ]
  },
  "ModifierFactory": {
    "_MAIN_PACKAGE_PATH": [],
    "_EXPERIMENTAL_PACKAGE_PATH": [],
    "refresh": [],
    "load_from_package": [
      "package_path"
    ],
    "create": [
      "type_",
      "allow_registered",
      "allow_experimental"
    ],
    "register": [
      "type_",
      "modifier_class"
    ]
  },
  "Modifier": {
    "model_config": [],
    "initialized": [
      "self"
    ],
    "finalized": [
      "self"
    ],
    "initialize": [
      "self",
      "state"
    ],
    "finalize": [
      "self",
      "state"
    ],
    "update_event": [
      "self",
      "state",
      "event"
    ],
    "should_start": [
      "self",
      "event"
    ],
    "should_end": [
      "self",
      "event"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_update": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ]
  },
  "AWQModifier": {
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_set_resolved_mappings": [
      "self",
      "model"
    ],
    "_setup_activation_cache_hooks": [
      "self"
    ],
    "_apply_smoothing": [
      "self",
      "model"
    ],
    "_run_samples": [
      "self",
      "module"
    ],
    "_compute_best_scale": [
      "self",
      "mapping",
      "fp16_outputs"
    ],
    "_compute_loss": [
      "self",
      "fp16_outputs",
      "int_w_outputs"
    ],
    "_assert_all_activations_consumed": [
      "self"
    ],
    "_compute_layer_means": [
      "layers"
    ],
    "validate_duo_scaling": [
      "cls",
      "v"
    ]
  },
  "_orient_weight": [
    "weight",
    "q_args"
  ],
  "_reorient_weight": [
    "weight",
    "q_args",
    "orig_shape"
  ],
  "_check_layers_are_compatible": [
    "smooth_layer",
    "smooth_name",
    "balance_layers",
    "balance_names"
  ],
  "get_lowest_common_ancestor_with_avoid": [
    "balance_names",
    "model",
    "avoid"
  ],
  "_accumulate_mean": [
    "inp",
    "prev_mean_and_count"
  ],
  "AWQMapping": {},
  "_default_mappings": [],
  "_moe_default_mappings": [],
  "_phi_mappings": [],
  "_gemma_mappings": [],
  "_cohere_mappings": [],
  "_deepseek_mappings": [],
  "_bloom_mappings": [],
  "_exaone4_mappings": [],
  "ResolvedMapping": {},
  "get_layer_mappings_from_architecture": [
    "architecture"
  ],
  "LogarithmicEqualizationModifier": {
    "_calculate_smoothing_scales": [
      "self",
      "balance_layers",
      "activation_scales"
    ]
  },
  "PruningCreateSettings": {},
  "SchedulerCalculationType": [],
  "CreateSchedulerType": [],
  "PruningSchedulerFactory": {
    "registry": [],
    "register": [
      "name",
      "func"
    ],
    "register_decorator": [
      "name"
    ],
    "create_scheduler": [
      "scheduler_type",
      "settings"
    ]
  },
  "create_custom_scheduler": [
    "scheduler_type",
    "settings"
  ],
  "linear_scheduler": [
    "settings"
  ],
  "cubic_scheduler": [
    "settings"
  ],
  "polynomial_decay_scheduler": [
    "settings"
  ],
  "polynomial_scheduler": [
    "settings"
  ],
  "multi_step_scheduler": [
    "settings"
  ],
  "WANDA_PRECISION": [],
  "make_empty_row_scalars": [
    "module",
    "device"
  ],
  "accumulate_row_scalars": [
    "inp",
    "module",
    "row_scalars",
    "num_samples"
  ],
  "sparsify_weight": [
    "module",
    "row_scalars_dict",
    "sparsity",
    "prune_n",
    "prune_m"
  ],
  "WandaPruningModifier": {
    "calibrate_module": [
      "self",
      "module",
      "args",
      "_output"
    ],
    "compress_modules": [
      "self"
    ],
    "on_finalize": [
      "self",
      "state"
    ]
  },
  "MagnitudePruningModifier": {
    "validate_leave_enabled": [
      "value"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_update": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "_update_masks": [
      "self",
      "event"
    ]
  },
  "SparseGPTModifier": {
    "calibrate_module": [
      "self",
      "module",
      "args",
      "_output"
    ],
    "compress_modules": [
      "self"
    ],
    "_maybe_onload_hessian": [
      "self",
      "module"
    ],
    "on_finalize": [
      "self",
      "state"
    ]
  },
  "SGPT_PRECISION": [],
  "make_empty_hessian": [
    "module",
    "device"
  ],
  "accumulate_hessian": [
    "inp",
    "module",
    "H",
    "num_samples"
  ],
  "SparsityModifierBase": {
    "validate_sequential_update": [
      "cls",
      "value"
    ],
    "validate_sparsity_profile": [
      "cls",
      "value"
    ],
    "validate_model_after": [
      "model"
    ],
    "calibrate_module": [
      "self",
      "module",
      "args",
      "_output"
    ],
    "compress_modules": [
      "self"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "_infer_sequential_targets": [
      "self",
      "model"
    ],
    "_infer_owl_layer_sparsity": [
      "self",
      "model",
      "layers",
      "dataloader"
    ],
    "_get_activations": [
      "self",
      "model",
      "dataloader",
      "nsamples"
    ],
    "_split_mask_structure": [
      "self",
      "mask_structure"
    ]
  },
  "param_mask_name": [],
  "setup_mask_for_param": [
    "param",
    "mask"
  ],
  "ParameterizedLayerMaskSettings": {},
  "LayerParamMasking": {
    "add_mask": [
      "self",
      "layer_param_name",
      "parameterized_layer",
      "init_mask",
      "persistent",
      "add_hooks"
    ],
    "update_mask": [
      "self",
      "layer_param_name",
      "mask"
    ],
    "remove_mask": [
      "self",
      "layer_param_name"
    ],
    "apply_mask_weight": [
      "self",
      "layer_param_name"
    ],
    "apply_mask_gradient": [
      "self",
      "layer_param_name"
    ],
    "enable_masks": [
      "self"
    ],
    "disable_masks": [
      "self"
    ]
  },
  "PruningMaskCreatorArgs": {},
  "MaskCreatorType": [],
  "CreateMaskCreatorType": [],
  "PruningMaskFactory": {
    "registry": [],
    "register": [
      "name",
      "func"
    ],
    "register_decorator": [
      "name"
    ],
    "create_mask_creator": [
      "mask_structure"
    ]
  },
  "unstructured_pruning": [
    "mask_structure"
  ],
  "channel_pruning": [
    "mask_structure",
    "aggregate"
  ],
  "filter_pruning": [
    "mask_structure",
    "aggregate"
  ],
  "block_pruning": [
    "mask_structure",
    "aggregate"
  ],
  "ConstantPruningModifier": {
    "on_initialize": [
      "self",
      "state"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_update": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ]
  },
  "_LLModelWrapper": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self"
    ]
  },
  "_PretrainModelWrapper": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self"
    ]
  },
  "_wrap_decoding_layer": [
    "layer"
  ],
  "AutoRoundModifier": {
    "on_initialize": [
      "self",
      "state"
    ],
    "start_calibration": [
      "self",
      "model"
    ],
    "input_capture_hook": [
      "self",
      "module"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "apply_autoround": [
      "self",
      "state",
      "subgraph"
    ],
    "post_autoround_cleanup": [
      "self"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_add_temporary_names": [
      "self",
      "model"
    ],
    "_remove_temporary_names": [
      "self",
      "model"
    ],
    "_is_decoding_layer": [
      "self",
      "module"
    ],
    "_infer_sequential_targets": [
      "self",
      "model"
    ],
    "_mapping_config_to_autoround": [
      "self"
    ]
  },
  "HooksMixin": {
    "disable_hooks": [
      "cls",
      "keep"
    ],
    "register_hook": [
      "self",
      "target",
      "hook",
      "hook_type"
    ],
    "remove_hooks": [
      "self",
      "handles"
    ],
    "_get_register_function": [
      "self",
      "target",
      "hook_type"
    ]
  },
  "update_fused_layer_weight_global_scales": [
    "submodule"
  ],
  "apply_pad_mask_to_batch": [
    "batch"
  ],
  "is_moe_model": [
    "model"
  ],
  "QuIPModifier": {
    "validate_not_implemented": [
      "cls",
      "value",
      "info"
    ],
    "validate_lowercase_list": [
      "cls",
      "value"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_get_targets": [
      "self",
      "model"
    ],
    "_create_config": [
      "self"
    ],
    "_create_v_scheme": [
      "self"
    ],
    "_create_u_scheme": [
      "self"
    ]
  },
  "SpinquantRotation": {
    "R1": [],
    "R2": [],
    "R3": [],
    "R4": []
  },
  "SpinQuantModifier": {
    "validate_not_implemented": [
      "cls",
      "value",
      "info"
    ],
    "validate_rotations": [
      "cls",
      "value"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_get_targets": [
      "self",
      "model"
    ],
    "_center_embeddings": [
      "self",
      "model"
    ],
    "_fuse_norms": [
      "self",
      "model"
    ],
    "_create_r1_scheme": [
      "self"
    ],
    "_create_r2_scheme": [
      "self",
      "head_dim"
    ],
    "_create_r3_scheme": [
      "self",
      "head_dim"
    ],
    "_create_r4_scheme": [
      "self"
    ]
  },
  "SpinQuantMapping": {
    "cast_to_list": [
      "cls",
      "value"
    ]
  },
  "infer_mapping_from_model": [
    "model"
  ],
  "NormMapping": {
    "cast_to_list": [
      "cls",
      "value"
    ]
  },
  "infer_norm_mapping_from_model": [
    "model"
  ],
  "initialize_observer": [
    "module",
    "base_name"
  ],
  "call_observer": [
    "module",
    "base_name",
    "value",
    "should_calculate_gparam",
    "should_calculate_qparams"
  ],
  "update_weight_global_scale": [
    "module"
  ],
  "update_weight_zp_scale": [
    "module"
  ],
  "calibrate_activations": [
    "module",
    "value",
    "base_name"
  ],
  "calibrate_input_hook": [
    "module",
    "args"
  ],
  "calibrate_output_hook": [
    "module",
    "_args",
    "output"
  ],
  "calibrate_query_hook": [
    "module",
    "query_states"
  ],
  "calibrate_key_hook": [
    "module",
    "key_states"
  ],
  "calibrate_value_hook": [
    "module",
    "value_states"
  ],
  "apply_calibration_status": [
    "module"
  ],
  "freeze_module_quantization": [
    "module"
  ],
  "reset_quantization_status": [
    "model"
  ],
  "GPTQModifier": {
    "resolve_quantization_config": [
      "self"
    ],
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "calibrate_module": [
      "self",
      "module",
      "args",
      "_output"
    ],
    "compress_modules": [
      "self"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_maybe_onload_hessian": [
      "self",
      "module"
    ]
  },
  "GPTQ_PRECISION": [],
  "quantize_weight": [
    "module",
    "quant_args",
    "hessians_dict",
    "blocksize",
    "percdamp"
  ],
  "_apply_activation_ordering": [
    "W",
    "H"
  ],
  "QuantizationModifier": {
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ]
  },
  "QuantizationMixin": {
    "validate_targets": [
      "cls",
      "value"
    ],
    "validate_scheme": [
      "cls",
      "value"
    ],
    "validate_observer": [
      "cls",
      "value"
    ],
    "resolved_config": [
      "self"
    ],
    "resolved_targets": [
      "self"
    ],
    "initialize_quantization": [
      "self",
      "model"
    ],
    "start_calibration": [
      "self",
      "model"
    ],
    "end_calibration": [
      "self",
      "model"
    ],
    "has_config": [
      "self"
    ],
    "resolve_quantization_config": [
      "self"
    ],
    "_apply_observer_overrides": [
      "self",
      "scheme"
    ],
    "_initialize_observers": [
      "self",
      "module"
    ],
    "_initialize_hooks": [
      "self",
      "module"
    ]
  },
  "MINIMUM_SMOOTHING_SCALE": [],
  "SmoothQuantScale": {},
  "SmoothQuantMapping": {},
  "SmoothQuantModifier": {
    "on_initialize": [
      "self",
      "state"
    ],
    "on_start": [
      "self",
      "state",
      "event"
    ],
    "on_event": [
      "self",
      "state",
      "event"
    ],
    "on_end": [
      "self",
      "state",
      "event"
    ],
    "on_finalize": [
      "self",
      "state"
    ],
    "_infer_mappings_from_model": [
      "self",
      "model"
    ],
    "_resolve_mappings": [
      "self",
      "model"
    ],
    "_setup_scale_hooks": [
      "self"
    ],
    "_apply_smoothing": [
      "self",
      "model"
    ],
    "_calculate_smoothing_scales": [
      "self",
      "balance_layers",
      "activation_scales"
    ],
    "model_config": []
  },
  "LayerMapType": [],
  "handle_mapping_resolution_errors": [
    "func"
  ]
}