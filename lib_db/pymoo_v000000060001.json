{
  "__version__": [],
  "algorithms": [],
  "visualization": [],
  "docs": [],
  "parse_doc_string": [
    "source",
    "dest",
    "other"
  ],
  "Config": {
    "root": [],
    "warnings": [],
    "show_compile_hint": [],
    "parse_custom_docs": [],
    "data": [
      "cls"
    ]
  },
  "get_pymoo": [],
  "minimize": [
    "problem",
    "algorithm",
    "termination",
    "copy_algorithm",
    "copy_termination"
  ],
  "AttachConfigEvaluator": {
    "__init__": [
      "self",
      "wrapped",
      "config"
    ],
    "eval": [
      "self",
      "problem",
      "pop"
    ]
  },
  "copy_to_dict": [
    "src",
    "dest"
  ],
  "AdaptiveConstraintHandling": {
    "__init__": [
      "self",
      "algorithm"
    ],
    "_setup": [
      "self",
      "_"
    ],
    "_adapt_constraint_handling": [
      "self",
      "config",
      "infills"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ]
  },
  "ConstraintsAsObjective": {
    "__init__": [
      "self",
      "problem",
      "config",
      "append"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ],
    "pareto_front": [
      "self"
    ]
  },
  "ConstraintsAsPenalty": {
    "__init__": [
      "self",
      "problem",
      "penalty"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ]
  },
  "ConstraintsFromBounds": {
    "__init__": [
      "self",
      "problem",
      "remove_bonds"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ]
  },
  "AdaptiveEpsilonConstraintHandling": {
    "__init__": [
      "self",
      "algorithm",
      "perc_eps_until"
    ],
    "_adapt_constraint_handling": [
      "self",
      "config"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ]
  },
  "CompromiseProgramming": {
    "__init__": [
      "self",
      "metric"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "PseudoWeights": {
    "__init__": [
      "self",
      "weights"
    ],
    "_do": [
      "self",
      "F",
      "return_pseudo_weights"
    ]
  },
  "HighTradeoffPoints": {
    "__init__": [
      "self",
      "epsilon"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "GDE3": {
    "__init__": [
      "self",
      "variant"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "ElementwiseEvaluationFunctionWithGradient": {
    "__init__": [
      "self",
      "problem",
      "backend",
      "args",
      "kwargs"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "ElementwiseAutomaticDifferentiation": {
    "__init__": [
      "self",
      "problem",
      "backend",
      "copy"
    ],
    "_create_elementwise_func": [
      "self",
      "problem",
      "args",
      "kwargs"
    ]
  },
  "AutomaticDifferentiation": {
    "__init__": [
      "self",
      "object",
      "backend"
    ],
    "do": [
      "self",
      "x",
      "return_values_of"
    ]
  },
  "calc_complex_gradient": [
    "problem",
    "return_values_of",
    "x",
    "eps"
  ],
  "ComplexNumberGradient": {
    "__init__": [
      "self",
      "problem",
      "eps"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ]
  },
  "jax_elementwise_value_and_grad": [
    "f",
    "x"
  ],
  "jax_vectorized_value_and_grad": [
    "f",
    "x"
  ],
  "value_and_grad": [],
  "log": [],
  "sqrt": [],
  "row_stack": [],
  "triu_indices": [],
  "run_and_trace": [
    "f",
    "x"
  ],
  "autograd_elementwise_value_and_grad": [
    "f",
    "x"
  ],
  "autograd_vectorized_value_and_grad": [
    "f",
    "x"
  ],
  "BACKENDS": [],
  "active_backend": [],
  "activate": [
    "name"
  ],
  "deactivate": [],
  "LazyBackend": {
    "__getattr__": [
      "self",
      "name"
    ],
    "__dir__": [
      "self"
    ]
  },
  "RayParallelization": {
    "__init__": [
      "self",
      "job_resources"
    ],
    "__call__": [
      "self",
      "f",
      "X"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "StarmapParallelization": {
    "__init__": [
      "self",
      "starmap"
    ],
    "__call__": [
      "self",
      "f",
      "X"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "DaskParallelization": {
    "__init__": [
      "self",
      "client"
    ],
    "__call__": [
      "self",
      "f",
      "X"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "__all__": [],
  "JoblibParallelization": {
    "__init__": [
      "self",
      "n_jobs"
    ],
    "__call__": [
      "self",
      "f",
      "X"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "ParameterControl": {
    "__init__": [
      "self",
      "obj"
    ],
    "do": [
      "self",
      "N",
      "set_to_params",
      "random_state"
    ],
    "_do": [
      "self",
      "N",
      "random_state"
    ],
    "tell": [
      "self"
    ],
    "advance": [
      "self",
      "infills"
    ]
  },
  "NoParameterControl": {
    "__init__": [
      "self",
      "_"
    ],
    "_do": [
      "self",
      "N",
      "random_state"
    ]
  },
  "RandomParameterControl": {
    "_do": [
      "self",
      "N",
      "random_state"
    ]
  },
  "EvolutionaryParameterControl": {
    "__init__": [
      "self",
      "obj"
    ],
    "_do": [
      "self",
      "N",
      "random_state"
    ]
  },
  "AgeBasedTournamentSelection": {
    "__init__": [
      "self",
      "pressure"
    ]
  },
  "age_binary_tournament": [
    "pop",
    "P"
  ],
  "ParameterControlMating": {
    "__init__": [
      "self",
      "selection",
      "crossover",
      "mutation",
      "control"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "parents"
    ]
  },
  "inversion_mutation": [
    "y",
    "seq",
    "inplace"
  ],
  "InversionMutation": {
    "__init__": [
      "self",
      "prob"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "NoMutation": {
    "do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "mut_pm": [
    "X",
    "xl",
    "xu",
    "eta",
    "prob",
    "at_least_once",
    "random_state"
  ],
  "PolynomialMutation": {
    "__init__": [
      "self",
      "prob",
      "eta",
      "at_least_once"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "params"
    ]
  },
  "PM": {},
  "BitflipMutation": {
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "BFM": {},
  "mut_gauss": [
    "X",
    "xl",
    "xu",
    "sigma",
    "prob",
    "random_state"
  ],
  "GaussianMutation": {
    "__init__": [
      "self",
      "sigma"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "GM": {},
  "ChoiceRandomMutation": {
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "inverse_penality": [
    "x",
    "p",
    "xl",
    "xu",
    "alpha",
    "random_state"
  ],
  "inverse_penality_by_problem": [
    "problem",
    "x",
    "p"
  ],
  "InversePenaltyOutOfBoundsRepair": {
    "repair_out_of_bounds": [
      "self",
      "problem",
      "X",
      "P"
    ]
  },
  "RoundingRepair": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "set_to_bounds_if_outside": [
    "X",
    "xl",
    "xu"
  ],
  "set_to_bounds_if_outside_by_problem": [
    "problem",
    "X"
  ],
  "ToBoundOutOfBoundsRepair": {
    "repair_out_of_bounds": [
      "self",
      "problem",
      "X"
    ]
  },
  "TypeRepair": {
    "__init__": [
      "self",
      "vtype"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "is_in_bounds": [
    "X",
    "xl",
    "xu"
  ],
  "is_in_bounds_by_problem": [
    "problem",
    "X"
  ],
  "is_out_of_bounds": [
    "X",
    "xl",
    "xu"
  ],
  "is_out_of_bounds_by_problem": [
    "problem",
    "X"
  ],
  "repeat_bounds": [
    "xl",
    "xu",
    "n"
  ],
  "repair_clamp": [
    "Xp",
    "xl",
    "xu"
  ],
  "repair_periodic": [
    "Xp",
    "xl",
    "xu"
  ],
  "repair_random_init": [
    "Xp",
    "X",
    "xl",
    "xu",
    "random_state"
  ],
  "BoundsRepair": {
    "_do": [
      "self",
      "problem",
      "pop_or_X",
      "check_out_of_bounds"
    ],
    "repair_out_of_bounds": [
      "self",
      "problem",
      "X"
    ]
  },
  "bounce_back": [
    "X",
    "xl",
    "xu"
  ],
  "bounce_back_by_problem": [
    "problem",
    "X"
  ],
  "BounceBackOutOfBoundsRepair": {
    "repair_out_of_bounds": [
      "self",
      "problem",
      "X"
    ]
  },
  "TournamentSelection": {
    "__init__": [
      "self",
      "func_comp",
      "pressure"
    ],
    "_do": [
      "self",
      "_",
      "pop",
      "n_select",
      "n_parents",
      "random_state"
    ]
  },
  "compare": [
    "a",
    "a_val",
    "b",
    "b_val",
    "method",
    "return_random_if_equal",
    "random_state"
  ],
  "RandomSelection": {
    "_do": [
      "self",
      "_",
      "pop",
      "n_select",
      "n_parents"
    ]
  },
  "fast_fill_random": [
    "X",
    "N",
    "columns",
    "Xp",
    "n_max_attempts",
    "random_state"
  ],
  "RankAndCrowding": {
    "__init__": [
      "self",
      "nds",
      "crowding_func"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "ConstrRankAndCrowding": {
    "__init__": [
      "self",
      "nds",
      "crowding_func"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "get_crowding_function": [
    "label"
  ],
  "CrowdingDiversity": {
    "do": [
      "self",
      "F",
      "n_remove"
    ],
    "_do": [
      "self",
      "F",
      "n_remove"
    ]
  },
  "FunctionalDiversity": {
    "__init__": [
      "self",
      "function",
      "filter_out_duplicates"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "FuncionalDiversityMNN": {
    "_do": [
      "self",
      "F"
    ]
  },
  "calc_crowding_distance": [
    "F"
  ],
  "calc_crowding_entropy": [
    "F"
  ],
  "calc_mnn_fast": [
    "F"
  ],
  "calc_2nn_fast": [
    "F"
  ],
  "_calc_mnn_fast": [
    "F",
    "n_neighbors"
  ],
  "criterion_maxmin": [
    "X"
  ],
  "criterion_corr": [
    "X"
  ],
  "sampling_lhs": [
    "n_samples",
    "n_var",
    "xl",
    "xu",
    "smooth",
    "criterion",
    "n_iter",
    "random_state"
  ],
  "sampling_lhs_unit": [
    "n_samples",
    "n_var",
    "smooth",
    "random_state"
  ],
  "LatinHypercubeSampling": {
    "__init__": [
      "self",
      "smooth",
      "iterations",
      "criterion"
    ],
    "_do": [
      "self",
      "problem",
      "n_samples",
      "random_state"
    ]
  },
  "LHS": {},
  "random": [
    "problem",
    "n_samples",
    "random_state"
  ],
  "FloatRandomSampling": {
    "_do": [
      "self",
      "problem",
      "n_samples"
    ]
  },
  "BinaryRandomSampling": {
    "_do": [
      "self",
      "problem",
      "n_samples"
    ]
  },
  "IntegerRandomSampling": {
    "_do": [
      "self",
      "problem",
      "n_samples"
    ]
  },
  "PermutationRandomSampling": {
    "_do": [
      "self",
      "problem",
      "n_samples"
    ]
  },
  "de_differential": [
    "X",
    "F",
    "dither",
    "jitter",
    "gamma",
    "return_differentials",
    "random_state"
  ],
  "DEX": {
    "__init__": [
      "self",
      "F",
      "CR",
      "variant",
      "dither",
      "jitter",
      "n_diffs",
      "n_iter",
      "at_least_once"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "parents"
    ]
  },
  "rnd_F": [
    "m",
    "random_state"
  ],
  "mut_binomial": [
    "n",
    "m",
    "prob",
    "at_least_once",
    "random_state"
  ],
  "BinomialCrossover": {
    "__init__": [
      "self",
      "bias",
      "n_offsprings"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "BX": {},
  "HalfUniformCrossover": {
    "__init__": [
      "self",
      "prob_hux"
    ],
    "_do": [
      "self",
      "_",
      "X",
      "random_state"
    ]
  },
  "HUX": {},
  "pcx": [
    "X",
    "eta",
    "zeta",
    "index",
    "random_state"
  ],
  "ParentCentricCrossover": {
    "__init__": [
      "self",
      "eta",
      "zeta"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "params",
      "random_state"
    ]
  },
  "PCX": {},
  "remove_from_adj_list": [
    "H",
    "val"
  ],
  "has_duplicates": [
    "x"
  ],
  "erx": [
    "a",
    "b",
    "random_state"
  ],
  "EdgeRecombinationCrossover": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "ERX": {},
  "number_to_letter": [
    "n"
  ],
  "numbers_to_letters": [
    "numbers"
  ],
  "letter_to_number": [
    "char"
  ],
  "letters_to_numbers": [
    "letters"
  ],
  "calc_adjency_matrix": [
    "x",
    "H"
  ],
  "PointCrossover": {
    "__init__": [
      "self",
      "n_points"
    ],
    "_do": [
      "self",
      "_",
      "X",
      "random_state"
    ]
  },
  "SinglePointCrossover": {
    "__init__": [
      "self"
    ]
  },
  "TwoPointCrossover": {
    "__init__": [
      "self"
    ]
  },
  "SPX": {},
  "cross_sbx": [
    "X",
    "xl",
    "xu",
    "eta",
    "prob_var",
    "prob_bin",
    "eps",
    "random_state"
  ],
  "SimulatedBinaryCrossover": {
    "__init__": [
      "self",
      "prob_var",
      "eta",
      "prob_exch",
      "prob_bin",
      "n_offsprings"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "SBX": {},
  "random_sequence": [
    "n",
    "random_state"
  ],
  "ox": [
    "receiver",
    "donor",
    "seq",
    "shift",
    "random_state"
  ],
  "OrderCrossover": {
    "__init__": [
      "self",
      "shift"
    ],
    "_do": [
      "self",
      "problem",
      "X",
      "random_state"
    ]
  },
  "mut_exp": [
    "n_matings",
    "n_var",
    "prob",
    "at_least_once",
    "random_state"
  ],
  "ExponentialCrossover": {
    "__init__": [
      "self",
      "prob_exp"
    ],
    "_do": [
      "self",
      "_",
      "X",
      "random_state"
    ]
  },
  "UniformCrossover": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "_",
      "X",
      "random_state"
    ]
  },
  "UX": {},
  "NoCrossover": {
    "__init__": [
      "self"
    ],
    "do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "get_functions": [],
  "FunctionLoader": {
    "__instance": [],
    "get_instance": [],
    "__init__": [
      "self"
    ],
    "load": [
      "self",
      "func_name",
      "mode"
    ]
  },
  "load_function": [
    "func_name",
    "_type"
  ],
  "is_compiled": [],
  "calc_mnn": [
    "X",
    "n_remove"
  ],
  "calc_2nn": [
    "X",
    "n_remove"
  ],
  "calc_mnn_base": [
    "X",
    "n_remove",
    "twonn"
  ],
  "hv": [
    "ref_point",
    "F"
  ],
  "fast_non_dominated_sort": [
    "F",
    "dominator",
    "native_biobj_sorting"
  ],
  "_fast_biobjective_nondominated_sort": [
    "F"
  ],
  "find_non_dominated": [
    "F",
    "epsilon"
  ],
  "efficient_non_dominated_sort": [
    "F",
    "strategy"
  ],
  "sequential_search": [
    "F",
    "i",
    "fronts"
  ],
  "binary_search": [
    "F",
    "i",
    "fronts"
  ],
  "Tree": {
    "__init__": [
      "self",
      "key",
      "num_branch",
      "children",
      "parent"
    ],
    "parent": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "traversal": [
      "self",
      "visit"
    ]
  },
  "tree_based_non_dominated_sort": [
    "F"
  ],
  "update_tree": [
    "F",
    "p",
    "forest",
    "k",
    "left",
    "obj_seq"
  ],
  "check_tree": [
    "F",
    "p",
    "tree",
    "obj_seq",
    "add_pos"
  ],
  "construct_comp_matrix": [
    "vec",
    "sorted_idx"
  ],
  "construct_domination_matrix": [
    "f_scores"
  ],
  "dda_ns": [
    "f_scores"
  ],
  "dda_ens": [
    "f_scores"
  ],
  "dominance_degree_non_dominated_sort": [
    "f_scores",
    "strategy"
  ],
  "fast_best_order_sort": [],
  "calc_perpendicular_distance": [
    "N",
    "ref_dirs"
  ],
  "calc_pcd": [
    "X",
    "n_remove"
  ],
  "calc_distance_to_weights": [
    "F",
    "weights",
    "utopian_point"
  ],
  "swap": [
    "M",
    "a",
    "b"
  ],
  "stochastic_ranking": [
    "f",
    "phi",
    "pr",
    "I",
    "random_state"
  ],
  "ZeroToOne": {
    "__init__": [
      "self",
      "problem"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ],
    "denormalize": [
      "self",
      "x"
    ],
    "normalize": [
      "self",
      "x"
    ]
  },
  "MultiToSingleObjective": {
    "__init__": [
      "self",
      "problem",
      "decomposition",
      "kwargs"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ]
  },
  "get_problem": [
    "name"
  ],
  "StaticProblem": {
    "__init__": [
      "self",
      "problem"
    ],
    "_evaluate": [
      "self",
      "_",
      "out"
    ]
  },
  "decompose": [
    "problem",
    "decomposition",
    "weights",
    "return_copy"
  ],
  "load_pareto_front_from_file": [
    "fname"
  ],
  "binomial": [
    "n",
    "k"
  ],
  "func_return_none": [],
  "FunctionalProblem": {
    "__init__": [
      "self",
      "n_var",
      "objs",
      "constr_ieq",
      "constr_eq",
      "func_pf",
      "func_ps"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "DynamicProblem": {},
  "DynamicTestProblem": {
    "__init__": [
      "self",
      "nt",
      "taut",
      "tau",
      "time"
    ],
    "tic": [
      "self",
      "elapsed"
    ],
    "time": [
      "self",
      "value"
    ]
  },
  "TimeSimulation": {
    "update": [
      "self",
      "algorithm"
    ]
  },
  "C1DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "C1DTLZ3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "r"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "C2DTLZ2": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "r"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "C3DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "C3DTLZ4": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "constraint_c1_linear": [
    "f"
  ],
  "constraint_c1_spherical": [
    "f",
    "r"
  ],
  "constraint_c2": [
    "f",
    "r"
  ],
  "constraint_c3_linear": [
    "f"
  ],
  "constraint_c3_spherical": [
    "f"
  ],
  "constraint_c4_cylindrical": [
    "f",
    "r"
  ],
  "DTLZ": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "k"
    ],
    "g1": [
      "self",
      "X_M"
    ],
    "g2": [
      "self",
      "X_M"
    ],
    "obj_func": [
      "self",
      "X_",
      "g",
      "alpha"
    ]
  },
  "DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ],
    "obj_func": [
      "self",
      "X_",
      "g"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ2": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ4": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "alpha",
      "d"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ5": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ6": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DTLZ7": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "InvertedDTLZ1": {
    "_calc_pareto_front": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ScaledProblem": {
    "__init__": [
      "self",
      "problem",
      "scale_factor"
    ],
    "get_scale": [
      "n",
      "scale_factor"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "ConvexProblem": {
    "__init__": [
      "self",
      "problem"
    ],
    "get_power": [
      "self",
      "n"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "ScaledDTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "scale_factor"
    ]
  },
  "ConvexDTLZ2": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ]
  },
  "ConvexDTLZ4": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ]
  },
  "generic_sphere": [
    "ref_dirs"
  ],
  "get_ref_dirs": [
    "n_obj"
  ],
  "WFG": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "k",
      "l"
    ],
    "validate": [
      "self",
      "l",
      "k",
      "n_obj"
    ],
    "_post": [
      "self",
      "t",
      "a"
    ],
    "_calculate": [
      "self",
      "x",
      "s",
      "h"
    ],
    "_rand_optimal_position": [
      "self",
      "n",
      "random_state"
    ],
    "_positional_to_optimal": [
      "self",
      "K"
    ],
    "_calc_pareto_set_extremes": [
      "self"
    ],
    "_calc_pareto_set_interior": [
      "self",
      "n_points"
    ],
    "_calc_pareto_set": [
      "self",
      "n_points"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs",
      "n_iterations",
      "points_each_iteration"
    ]
  },
  "WFG1": {
    "t1": [
      "x",
      "n",
      "k"
    ],
    "t2": [
      "x",
      "n",
      "k"
    ],
    "t3": [
      "x",
      "n"
    ],
    "t4": [
      "x",
      "m",
      "n",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_rand_optimal_position": [
      "self",
      "n",
      "random_state"
    ]
  },
  "WFG2": {
    "validate": [
      "self",
      "l",
      "k",
      "n_obj"
    ],
    "t2": [
      "x",
      "n",
      "k"
    ],
    "t3": [
      "x",
      "m",
      "n",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "k"
    ],
    "validate": [
      "self",
      "l",
      "k",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG4": {
    "t1": [
      "x"
    ],
    "t2": [
      "x",
      "m",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG5": {
    "t1": [
      "x"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG6": {
    "t2": [
      "x",
      "m",
      "n",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG7": {
    "t1": [
      "x",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WFG8": {
    "t1": [
      "x",
      "n",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_positional_to_optimal": [
      "self",
      "K"
    ]
  },
  "WFG9": {
    "t1": [
      "x",
      "n"
    ],
    "t2": [
      "x",
      "n",
      "k"
    ],
    "t3": [
      "x",
      "m",
      "n",
      "k"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_positional_to_optimal": [
      "self",
      "K"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "_transformation_shift_linear": [
    "value",
    "shift"
  ],
  "_transformation_shift_deceptive": [
    "y",
    "A",
    "B",
    "C"
  ],
  "_transformation_shift_multi_modal": [
    "y",
    "A",
    "B",
    "C"
  ],
  "_transformation_bias_flat": [
    "y",
    "a",
    "b",
    "c"
  ],
  "_transformation_bias_poly": [
    "y",
    "alpha"
  ],
  "_transformation_param_dependent": [
    "y",
    "y_deg",
    "A",
    "B",
    "C"
  ],
  "_transformation_param_deceptive": [
    "y",
    "A",
    "B",
    "C"
  ],
  "_reduction_weighted_sum": [
    "y",
    "w"
  ],
  "_reduction_weighted_sum_uniform": [
    "y"
  ],
  "_reduction_non_sep": [
    "y",
    "A"
  ],
  "_shape_concave": [
    "x",
    "m"
  ],
  "_shape_convex": [
    "x",
    "m"
  ],
  "_shape_linear": [
    "x",
    "m"
  ],
  "_shape_mixed": [
    "x",
    "A",
    "alpha"
  ],
  "_shape_disconnected": [
    "x",
    "alpha",
    "beta",
    "A"
  ],
  "validate_wfg2_wfg3": [
    "l"
  ],
  "correct_to_01": [
    "X",
    "epsilon"
  ],
  "constraint_dc1": [
    "X",
    "a",
    "b"
  ],
  "constraints_dc2": [
    "gx",
    "a",
    "b"
  ],
  "constraints_dc3": [
    "X",
    "gx",
    "a",
    "b"
  ],
  "DC1DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DC1DTLZ3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DC2DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DC2DTLZ3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DC3DTLZ1": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DC3DTLZ3": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "DynamicCEC2015": {
    "__init__": [
      "self",
      "n_var",
      "nt",
      "taut",
      "n_obj",
      "xl",
      "xu",
      "vtype"
    ]
  },
  "FDA2DEB": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "FDA4": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "FDA5": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DIMP2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "dMOP2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "dMOP3": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "HE2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "HE7": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "HE9": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "FDA2_deb": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ]
  },
  "DMOP2": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ]
  },
  "DIMP2b": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "get_pf_t": [
      "self"
    ]
  },
  "HE2b": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "get_pf_t": [
      "self"
    ]
  },
  "HE7b": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "time": [
      "self",
      "t"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "get_pf_t": [
      "self"
    ]
  },
  "HE9b": {
    "__init__": [
      "self",
      "nt",
      "taut"
    ],
    "time": [
      "self",
      "t"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "get_pf_t": [
      "self"
    ]
  },
  "DF": {
    "__init__": [
      "self",
      "n_var",
      "nt",
      "taut"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF1": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF2": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF3": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF4": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF5": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF6": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF7": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF8": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF9": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF10": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF11": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF12": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF13": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DF14": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "get_PF": [
    "f",
    "nondominate"
  ],
  "MultiModalSimple1": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "MultiModalSimple2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "FlowshopScheduling": {
    "__init__": [
      "self",
      "processing_times"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "makespan": [
      "self",
      "x"
    ],
    "get_machine_times": [
      "self",
      "x"
    ]
  },
  "create_random_flowshop_problem": [
    "n_machines",
    "n_jobs",
    "random_state"
  ],
  "visualize": [
    "problem",
    "x",
    "path",
    "label"
  ],
  "Rosenbrock": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Griewank": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "PressureVessel": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G": {
    "_calc_pareto_front": [
      "self"
    ]
  },
  "G1": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G3": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G4": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G5": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G6": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G7": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G8": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G9": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G10": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G11": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G12": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G13": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G14": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G15": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G16": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G17": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G18": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G19": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G20": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G21": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G22": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G23": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "G24": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "SimpleMultiModal01": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "MOPTA08": {
    "__init__": [
      "self",
      "exec"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "Sphere": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Knapsack": {
    "__init__": [
      "self",
      "n_items",
      "W",
      "P",
      "C"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "MultiObjectiveKnapsack": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "create_random_knapsack_problem": [
    "n_items",
    "variant",
    "random_state"
  ],
  "Zakharov": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Ackley": {
    "__init__": [
      "self",
      "n_var",
      "a",
      "b",
      "c"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Himmelblau": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "TravelingSalesman": {
    "__init__": [
      "self",
      "cities"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "get_route_length": [
      "self",
      "x"
    ]
  },
  "create_random_tsp_problem": [
    "n_cities",
    "grid_width",
    "grid_height",
    "random_state"
  ],
  "Schwefel": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "CantileveredBeam": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Rastrigin": {
    "__init__": [
      "self",
      "n_var",
      "A"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "Kursawe": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "CSI": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "MODAct": {
    "__init__": [
      "self",
      "function",
      "pf"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "TNK": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "ZDT": {
    "__init__": [
      "self",
      "n_var"
    ]
  },
  "ZDT1": {
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ZDT2": {
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ZDT3": {
    "_calc_pareto_front": [
      "self",
      "n_points",
      "flatten"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ZDT4": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ZDT5": {
    "__init__": [
      "self",
      "m",
      "n",
      "normalize"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "ZDT6": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "WRM": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "SYMPARTRotated": {
    "__init__": [
      "self",
      "length",
      "v_dist",
      "h_dist",
      "angle"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_set": [
      "self",
      "n_pareto_points"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ]
  },
  "SYMPART": {
    "__init__": [
      "self",
      "length",
      "v_dist",
      "h_dist"
    ]
  },
  "WeldedBeam": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DIFFICULTIES": [],
  "DASCMOP": {
    "__init__": [
      "self",
      "n_obj",
      "n_ieq_constr",
      "difficulty"
    ],
    "g1": [
      "self",
      "X"
    ],
    "g2": [
      "self",
      "X"
    ],
    "g3": [
      "self",
      "X"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "DASCMOP1": {
    "__init__": [
      "self",
      "difficulty"
    ],
    "constraints": [
      "self",
      "X",
      "f0",
      "f1",
      "g"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP2": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP3": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP4": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP5": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP6": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP7": {
    "__init__": [
      "self",
      "difficulty_factors"
    ],
    "constraints": [
      "self",
      "X",
      "f0",
      "f1",
      "f2",
      "g"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP8": {
    "objectives": [
      "self",
      "X",
      "g"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "DASCMOP9": {
    "_evaluate": [
      "self",
      "X",
      "out"
    ]
  },
  "OmniTest": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_set": [
      "self",
      "n_pareto_points"
    ],
    "_calc_pareto_front": [
      "self",
      "n_pareto_points"
    ]
  },
  "Clutch": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "g_linear": [
    "x"
  ],
  "g_multimodal": [
    "x"
  ],
  "CTP": {
    "__init__": [
      "self",
      "n_var",
      "n_ieq_constr",
      "option"
    ],
    "calc_objectives": [
      "self",
      "x"
    ],
    "calc_constraint": [
      "self",
      "theta",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f1",
      "f2"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "CTP1": {
    "__init__": [
      "self",
      "n_var",
      "n_ieq_constr"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP2": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP3": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP4": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP5": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP6": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP7": {
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "CTP8": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "Carside": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "SRN": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ]
  },
  "BNH": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "n_points"
    ]
  },
  "Truss2D": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "n_ieq_constr"
    ],
    "LA1": [
      "A",
      "B",
      "C",
      "D",
      "theta"
    ],
    "LA2": [
      "A",
      "B",
      "C",
      "D",
      "theta"
    ],
    "LA3": [
      "A",
      "B",
      "C",
      "D",
      "theta"
    ],
    "g1": [
      "self",
      "X"
    ],
    "g2": [
      "self",
      "X"
    ],
    "g3": [
      "self",
      "X"
    ]
  },
  "MW1": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW2": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW3": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW4": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW5": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW6": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW7": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW8": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW9": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW10": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW11": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW12": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self",
      "ref_dirs"
    ]
  },
  "MW13": {
    "__init__": [
      "self",
      "n_var"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "MW14": {
    "__init__": [
      "self",
      "n_var",
      "n_obj"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "OSY": {
    "__init__": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "_calc_pareto_front": [
      "self"
    ]
  },
  "ASF": {
    "_do": [
      "self",
      "F",
      "weights",
      "weight_0"
    ]
  },
  "AASF": {
    "__init__": [
      "self",
      "eps",
      "_type",
      "rho",
      "beta"
    ],
    "_do": [
      "self",
      "F",
      "weights"
    ]
  },
  "calc_rho": [
    "beta"
  ],
  "PerpendicularDistance": {
    "__init__": [
      "self",
      "theta"
    ],
    "_do": [
      "self",
      "F",
      "weights"
    ]
  },
  "PBI": {
    "__init__": [
      "self",
      "theta"
    ],
    "_do": [
      "self",
      "F",
      "weights"
    ]
  },
  "WeightedSum": {
    "_do": [
      "self",
      "F",
      "weights"
    ]
  },
  "Tchebicheff": {
    "_do": [
      "self",
      "F",
      "weights"
    ]
  },
  "create": [
    "algorithm",
    "params"
  ],
  "HyperparameterProblem": {
    "__init__": [
      "self",
      "algorithm",
      "performance",
      "func_create",
      "vars"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "SingleObjectiveSingleRun": {
    "__init__": [
      "self",
      "problem"
    ],
    "__call__": [
      "self",
      "algorithm"
    ]
  },
  "stats_single_objective_mean": [
    "rets"
  ],
  "stats_avg_nevals": [
    "rets"
  ],
  "MultiRun": {
    "__init__": [
      "self",
      "problem",
      "n_runs",
      "seeds",
      "func_stats",
      "random_state"
    ],
    "__call__": [
      "self",
      "algorithm"
    ]
  },
  "FitnessSurvival": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive"
    ]
  },
  "Search_Rule": [
    "Xb",
    "Xw",
    "Xn",
    "rho",
    "random_state"
  ],
  "NRBO": {
    "__init__": [
      "self",
      "pop_size",
      "deciding_factor",
      "sampling",
      "max_iteration",
      "repair",
      "output",
      "display",
      "callback",
      "archive",
      "return_least_infeasible",
      "save_history",
      "verbose",
      "seed",
      "evaluator"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "ISRES": {
    "__init__": [
      "self",
      "gamma",
      "alpha"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_infill": [
      "self"
    ]
  },
  "PSOFuzzyOutput": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "S1_exploration": [
    "f"
  ],
  "S2_exploitation": [
    "f"
  ],
  "S3_convergence": [
    "f"
  ],
  "S4_jumping_out": [
    "f"
  ],
  "pso_equation": [
    "X",
    "P_X",
    "S_X",
    "V",
    "V_max",
    "w",
    "c1",
    "c2",
    "r1",
    "r2",
    "random_state"
  ],
  "PSO": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "w",
      "c1",
      "c2",
      "adaptive",
      "initial_velocity",
      "max_velocity_rate",
      "pertube_best",
      "repair",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_social_best": [
      "self"
    ],
    "_adapt": [
      "self"
    ]
  },
  "StochasticRankingSurvival": {
    "__init__": [
      "self",
      "PR"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "SRES": {
    "__init__": [
      "self",
      "PF"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "CMAESOutput": {
    "__init__": [
      "self"
    ],
    "initialize": [
      "self",
      "algorithm"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "CMAES": {
    "__init__": [
      "self",
      "x0",
      "sigma",
      "normalize",
      "parallelize",
      "maxfevals",
      "tolfun",
      "tolx",
      "restarts",
      "restart_from_best",
      "incpopsize",
      "eval_initial_x",
      "noise_handler",
      "noise_change_sigma_exponent",
      "noise_kappa_exponent",
      "bipop",
      "cmaes_verbose",
      "verb_log",
      "output",
      "pop_size"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_advance": [
      "self"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "SimpleCMAES": {
    "__init__": [
      "self",
      "sigma",
      "opts",
      "normalize"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "BIPOPCMAES": {
    "__init__": [
      "self",
      "restarts"
    ]
  },
  "bounds_if_normalize": [
    "xl",
    "xu"
  ],
  "G3PCX": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "n_offsprings",
      "n_parents",
      "family_size",
      "repair",
      "output"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_next": [
      "self"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "ES": {
    "__init__": [
      "self",
      "n_offsprings",
      "pop_size",
      "rule",
      "phi",
      "gamma",
      "sampling",
      "survival",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "es_sigma": [
    "sigma",
    "tau",
    "taup",
    "random_state"
  ],
  "es_intermediate_recomb": [
    "sigma",
    "random_state"
  ],
  "es_mut_repair": [
    "Xp",
    "X",
    "sigma",
    "xl",
    "xu",
    "n_trials",
    "random_state"
  ],
  "es_mut_loop": [
    "X",
    "sigmap",
    "xl",
    "xu",
    "n_trials",
    "random_state"
  ],
  "comp_by_cv_and_fitness": [
    "pop",
    "P",
    "random_state"
  ],
  "GA": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "survival",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ]
  },
  "BGA": {
    "__init__": [
      "self",
      "sampling",
      "crossover",
      "mutation"
    ]
  },
  "NelderAndMeadTermination": {
    "__init__": [
      "self",
      "x_tol",
      "f_tol",
      "n_max_iter",
      "n_max_evals"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "adaptive_params": [
    "problem"
  ],
  "default_params": [
    "_"
  ],
  "initialize_simplex": [
    "problem",
    "x0",
    "scale"
  ],
  "NelderMead": {
    "__init__": [
      "self",
      "init_simplex_scale",
      "func_params",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_simplex": [
      "self"
    ],
    "_next": [
      "self"
    ],
    "_step": [
      "self"
    ]
  },
  "NicheOutput": {
    "__init__": [
      "self"
    ]
  },
  "NicheSingleObjectiveSpaceToleranceTermination": {
    "_data": [
      "self",
      "algorithm"
    ]
  },
  "NicheTermination": {
    "__init__": [
      "self",
      "x_tol",
      "cv_tol",
      "f_tol",
      "period"
    ]
  },
  "comp_by_cv_and_clearing_fitness": [
    "pop",
    "P"
  ],
  "EpsilonClearingSurvival": {
    "__init__": [
      "self",
      "epsilon",
      "n_max_each_iter",
      "norm_by_dim"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "out"
    ]
  },
  "NicheGA": {
    "__init__": [
      "self",
      "pop_size",
      "norm_niche_size",
      "norm_by_dim",
      "return_all_opt",
      "output",
      "survival",
      "selection"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "PatternSearch": {
    "__init__": [
      "self",
      "init_delta",
      "init_rho",
      "step_size",
      "output"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_next": [
      "self"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "exploration_move": [
    "problem",
    "center",
    "sign",
    "delta",
    "rho",
    "randomize",
    "random_state"
  ],
  "pattern_move": [
    "problem",
    "current",
    "direction",
    "step_size"
  ],
  "calc_sign": [
    "direction"
  ],
  "step_along_axis": [
    "problem",
    "x",
    "delta",
    "axis"
  ],
  "Optuna": {
    "__init__": [
      "self",
      "sampler",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "pso_canonical": [
    "V",
    "X",
    "P_X",
    "L_X",
    "w",
    "c1",
    "c2",
    "random_state"
  ],
  "pso_rotation_invariant": [
    "V",
    "X",
    "P_X",
    "L_X",
    "inertia",
    "c1",
    "c2",
    "random_state"
  ],
  "alea_sphere": [
    "G",
    "radius",
    "random_state"
  ],
  "Swarm": {
    "__init__": [
      "self",
      "w",
      "c1",
      "c2",
      "V_max",
      "prob_mut",
      "control"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "algorithm",
      "random_state"
    ]
  },
  "get_neighbors": [
    "name",
    "N",
    "random_state"
  ],
  "EPPSO": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "swarm",
      "topology",
      "init_V",
      "output"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "RandomSearch": {
    "__init__": [
      "self",
      "n_points_per_iteration",
      "sampling",
      "output"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "EliteSurvival": {
    "__init__": [
      "self",
      "n_elites",
      "eliminate_duplicates"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "algorithm"
    ]
  },
  "EliteBiasedSelection": {
    "_do": [
      "self",
      "problem",
      "pop",
      "n_select",
      "n_parents"
    ]
  },
  "BRKGA": {
    "__init__": [
      "self",
      "n_elites",
      "n_offsprings",
      "n_mutants",
      "bias",
      "sampling",
      "survival",
      "output",
      "eliminate_duplicates"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "norm_bounds": [
    "pop",
    "problem"
  ],
  "update_bounds": [
    "ind",
    "xl",
    "xu",
    "k",
    "delta"
  ],
  "DIRECT": {
    "__init__": [
      "self",
      "eps",
      "penalty",
      "n_max_candidates",
      "n_max_archive",
      "archive_reduct",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_potential_optimal": [
      "self"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "Variant": {
    "__init__": [
      "self",
      "selection",
      "n_diffs",
      "F",
      "crossover",
      "CR",
      "jitter",
      "prob_mut",
      "control"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "algorithm"
    ]
  },
  "DE": {
    "__init__": [
      "self",
      "pop_size",
      "n_offsprings",
      "sampling",
      "variant",
      "output"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "ExponentialSearch": {
    "__init__": [
      "self",
      "delta"
    ],
    "_setup": [
      "self",
      "problem",
      "x0"
    ],
    "_initialize_infill": [
      "self"
    ],
    "step": [
      "self"
    ]
  },
  "GoldenSectionSearch": {
    "__init__": [
      "self"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_advance": [
      "self"
    ]
  },
  "WolfeSearch": {
    "__init__": [
      "self",
      "c1",
      "c2",
      "max_iter"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_set_optimum": [
      "self",
      "force"
    ],
    "step": [
      "self"
    ],
    "_infill": [
      "self"
    ]
  },
  "wolfe_line_search": [
    "problem",
    "sol",
    "direction",
    "c1",
    "c2",
    "max_iter",
    "evaluator"
  ],
  "quadr_interp_equ": [
    "xa",
    "fa",
    "xb",
    "fb",
    "xc",
    "fc"
  ],
  "quadr_interp": [
    "a",
    "b",
    "c"
  ],
  "QuadraticInterpolationSearch": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_advance": [
      "self"
    ]
  },
  "binary_tournament": [
    "pop",
    "P",
    "algorithm"
  ],
  "RankAndCrowdingSurvival": {
    "__init__": [
      "self",
      "nds",
      "crowding_func"
    ]
  },
  "NSGA2": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "survival",
      "output"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "LeastHypervolumeContributionSurvival": {
    "__init__": [
      "self",
      "eps"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "cv_and_dom_tournament": [
    "pop",
    "P"
  ],
  "SMSEMOA": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "survival",
      "eliminate_duplicates",
      "n_offsprings",
      "normalize",
      "output"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "RVEA": {
    "__init__": [
      "self",
      "ref_dirs",
      "alpha",
      "adapt_freq",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_advance": [
      "self"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "calc_gamma": [
    "V"
  ],
  "calc_V": [
    "ref_dirs"
  ],
  "APDSurvival": {
    "__init__": [
      "self",
      "ref_dirs",
      "alpha"
    ],
    "adapt": [
      "self"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "algorithm",
      "n_gen",
      "n_max_gen"
    ]
  },
  "euclidean_distance": [
    "a",
    "b"
  ],
  "KGB": {
    "__init__": [
      "self",
      "perc_detect_change",
      "perc_diversity",
      "c_size",
      "eps",
      "ps",
      "perturb_dev",
      "save_ps"
    ],
    "setup": [
      "self",
      "problem"
    ],
    "_infill": [
      "self"
    ],
    "knowledge_reconstruction_examination": [
      "self"
    ],
    "naive_bayesian_classifier": [
      "self",
      "pop_useful",
      "pop_useless"
    ],
    "add_to_ps": [
      "self"
    ],
    "predicted_population": [
      "self",
      "X_test",
      "Y_test"
    ],
    "calculate_cluster_centroid": [
      "self",
      "solution_cluster"
    ],
    "check_boundaries": [
      "self",
      "pop"
    ],
    "random_strategy": [
      "self",
      "N_r"
    ],
    "diversify_population": [
      "self",
      "pop"
    ],
    "_advance": [
      "self"
    ]
  },
  "MOPSO_CD": {
    "__init__": [
      "self",
      "pop_size",
      "w",
      "c1",
      "c2",
      "max_velocity_rate",
      "archive_size",
      "sampling",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_update_archive": [
      "self",
      "pop"
    ],
    "_select_diverse_leaders": [
      "self"
    ],
    "_update_pbest": [
      "self",
      "new_pop"
    ],
    "_dominates": [
      "self",
      "f1",
      "f2"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "RNSGA3": {
    "__init__": [
      "self",
      "ref_points",
      "pop_per_ref_point",
      "mu",
      "sampling",
      "selection",
      "eliminate_duplicates",
      "n_offsprings"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_finalize": [
      "self"
    ]
  },
  "AspirationPointSurvival": {
    "__init__": [
      "self",
      "ref_points",
      "aspiration_ref_dirs",
      "mu"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "D",
      "random_state"
    ]
  },
  "get_ref_dirs_from_points": [
    "ref_point",
    "ref_dirs",
    "mu"
  ],
  "line_plane_intersection": [
    "l0",
    "l1",
    "p0",
    "p_no",
    "epsilon"
  ],
  "comp_by_rank_and_ref_line_dist": [
    "pop",
    "P",
    "random_state"
  ],
  "UNSGA3": {
    "__init__": [
      "self",
      "ref_dirs",
      "selection"
    ]
  },
  "DNSGA2": {
    "__init__": [
      "self",
      "perc_detect_change",
      "perc_diversity",
      "eps",
      "version"
    ],
    "setup": [
      "self",
      "problem"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self"
    ]
  },
  "comp_by_cv_dom_then_random": [
    "pop",
    "P",
    "random_state"
  ],
  "RestrictedMating": {
    "_do": [
      "self",
      "problem",
      "Hm",
      "n_select",
      "n_parents",
      "random_state"
    ]
  },
  "CADASurvival": {
    "__init__": [
      "self",
      "ref_dirs"
    ],
    "do": [
      "self",
      "_",
      "pop",
      "da",
      "n_survive",
      "random_state"
    ],
    "_associate": [
      "self",
      "pop"
    ],
    "_updateCA": [
      "self",
      "pop",
      "n_survive",
      "random_state"
    ],
    "_updateDA": [
      "self",
      "pop",
      "Hd",
      "n_survive"
    ]
  },
  "CTAEA": {
    "__init__": [
      "self",
      "ref_dirs",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "eliminate_duplicates",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "AGEMOEA": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "AGEMOEASurvival": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ],
    "survival_score": [
      "self",
      "front",
      "ideal_point"
    ],
    "compute_geometry": [
      "front",
      "extreme",
      "n"
    ],
    "pairwise_distances": [
      "front",
      "p"
    ],
    "minkowski_distances": [
      "A",
      "B",
      "p"
    ]
  },
  "find_corner_solutions": [
    "front"
  ],
  "point_2_line_distance": [
    "P",
    "A",
    "B"
  ],
  "normalize": [
    "front",
    "extreme"
  ],
  "AGEMOEA2": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ]
  },
  "project_on_manifold": [
    "point",
    "p"
  ],
  "find_zero": [
    "point",
    "n",
    "precision"
  ],
  "AGEMOEA2Survival": {
    "compute_geometry": [
      "front",
      "extreme",
      "n"
    ],
    "pairwise_distances": [
      "front",
      "p"
    ]
  },
  "AutomatedDM": {
    "__init__": [
      "self",
      "get_pairwise_ranks_func"
    ],
    "makeDecision": [
      "self",
      "F"
    ],
    "makePairwiseDecision": [
      "self",
      "F"
    ]
  },
  "PINSGA2": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "output",
      "tau",
      "eta",
      "opt_method",
      "vf_type",
      "eps_max",
      "ranking_type",
      "presi_signs",
      "automated_dm",
      "verbose"
    ],
    "_warn": [
      "self",
      "msg"
    ],
    "_prompt_for_ranks": [
      "F",
      "presi_signs"
    ],
    "_present_ranks": [
      "F",
      "dm_ranks",
      "presi_signs"
    ],
    "_get_pairwise_ranks": [
      "F",
      "presi_signs",
      "dm"
    ],
    "_get_ranks": [
      "F",
      "presi_signs"
    ],
    "_reset_dm_preference": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "CrowdingDistanceTournamentSurvival": {
    "__init__": [
      "self",
      "tournament_size"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "random_state"
    ]
  },
  "angle_between": [
    "v1",
    "v2"
  ],
  "cmopso_equation": [
    "X",
    "L",
    "V",
    "V_max",
    "random_state"
  ],
  "CMOPSO": {
    "__init__": [
      "self",
      "pop_size",
      "max_velocity_rate",
      "elite_size",
      "initial_velocity",
      "mutation_rate",
      "sampling",
      "repair",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "NeighborhoodSelection": {
    "__init__": [
      "self",
      "prob"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_select",
      "n_parents",
      "neighbors",
      "random_state"
    ]
  },
  "MOEAD": {
    "__init__": [
      "self",
      "ref_dirs",
      "n_neighbors",
      "decomposition",
      "prob_neighbor_mating",
      "sampling",
      "crossover",
      "mutation",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_next": [
      "self"
    ],
    "_replace": [
      "self",
      "k",
      "off"
    ]
  },
  "ParallelMOEAD": {
    "__init__": [
      "self",
      "ref_dirs"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "default_decomp": [
    "problem"
  ],
  "comp_by_cv_then_random": [
    "pop",
    "P",
    "random_state"
  ],
  "NSGA3": {
    "__init__": [
      "self",
      "ref_dirs",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "ReferenceDirectionSurvival": {
    "__init__": [
      "self",
      "ref_dirs"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive",
      "D",
      "random_state"
    ]
  },
  "niching": [
    "pop",
    "n_remaining",
    "niche_count",
    "niche_of_individuals",
    "dist_to_niche",
    "random_state"
  ],
  "associate_to_niches": [
    "F",
    "niches",
    "ideal_point",
    "nadir_point",
    "utopian_epsilon"
  ],
  "calc_niche_count": [
    "n_niches",
    "niche_of_individuals"
  ],
  "HyperplaneNormalization": {
    "__init__": [
      "self",
      "n_dim"
    ],
    "update": [
      "self",
      "F",
      "nds"
    ]
  },
  "get_extreme_points_c": [
    "F",
    "ideal_point",
    "extreme_points"
  ],
  "get_nadir_point": [
    "extreme_points",
    "ideal_point",
    "worst_point",
    "worst_of_front",
    "worst_of_population"
  ],
  "RNSGA2": {
    "__init__": [
      "self",
      "ref_points",
      "epsilon",
      "normalization",
      "weights",
      "extreme_points_as_reference_points"
    ]
  },
  "RankAndModifiedCrowdingSurvival": {
    "__init__": [
      "self",
      "ref_points",
      "epsilon",
      "weights",
      "normalization",
      "extreme_points_as_reference_points"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_survive"
    ]
  },
  "calc_norm_pref_distance": [
    "A",
    "B",
    "weights",
    "ideal",
    "nadir"
  ],
  "SPEA2Survival": {
    "__init__": [
      "self",
      "normalize",
      "filter_infeasible"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "spea_binary_tournament": [
    "pop",
    "P",
    "algorithm",
    "random_state"
  ],
  "SPEA2": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "survival",
      "eliminate_duplicates",
      "n_offsprings",
      "output"
    ]
  },
  "BracketSearch": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "_setup": [
      "self",
      "problem",
      "a",
      "b"
    ],
    "_initialize_infill": [
      "self"
    ]
  },
  "GeneticAlgorithm": {
    "__init__": [
      "self",
      "pop_size",
      "sampling",
      "selection",
      "crossover",
      "mutation",
      "survival",
      "n_offsprings",
      "eliminate_duplicates",
      "repair",
      "mating",
      "advance_after_initial_infill"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "LocalSearch": {
    "__init__": [
      "self",
      "initial",
      "sampling",
      "output",
      "n_sample_points"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ]
  },
  "LineSearch": {
    "__init__": [
      "self"
    ],
    "setup": [
      "self",
      "problem",
      "point",
      "direction"
    ],
    "_initialize_infill": [
      "self"
    ]
  },
  "LineSearchProblem": {
    "__init__": [
      "self",
      "problem",
      "point",
      "direction",
      "strict_bounds",
      "xl",
      "xu"
    ],
    "_evaluate": [
      "self",
      "alpha",
      "out"
    ]
  },
  "MetaAlgorithm": {
    "__new__": [
      "cls",
      "algorithm"
    ],
    "__init__": [
      "self",
      "algorithm"
    ],
    "__getattr__": [
      "self",
      "attr"
    ]
  },
  "MetaAlgorithm2": {
    "__init__": [
      "self",
      "algorithm",
      "copy"
    ],
    "_copy_from_orig": [
      "self"
    ],
    "setup": [
      "self"
    ],
    "_infill": [
      "self"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "advance": [
      "self",
      "infills"
    ],
    "_set_optimum": [
      "self"
    ]
  },
  "LOWER_BOUND": [],
  "UPPER_BOUND": [],
  "ERR_MSG": [],
  "DELTA_STATE": [],
  "beta_uni": [
    "x",
    "t",
    "g",
    "obj_num"
  ],
  "beta_multi": [
    "x",
    "t",
    "g",
    "obj_num"
  ],
  "beta_mix": [
    "x",
    "t",
    "g",
    "obj_num"
  ],
  "alpha_conv": [
    "x"
  ],
  "alpha_disc": [
    "x"
  ],
  "alpha_mix": [
    "x",
    "t"
  ],
  "alpha_conf": [
    "x",
    "t"
  ],
  "alpha_conf_3obj_type1": [
    "x",
    "t"
  ],
  "alpha_conf_3obj_type2": [
    "x",
    "t"
  ],
  "g": [
    "x",
    "t"
  ],
  "check_boundary": [
    "x",
    "upper_bound",
    "lower_bound"
  ],
  "check_boundary_3obj": [
    "x",
    "upper_bound",
    "lower_bound"
  ],
  "fix_numerical_instability": [
    "x"
  ],
  "additive": [
    "alpha",
    "beta"
  ],
  "multiplicative": [
    "alpha",
    "beta"
  ],
  "DB1a": [
    "x",
    "t"
  ],
  "DB1m": [
    "x",
    "t"
  ],
  "DB2a": [
    "x",
    "t"
  ],
  "DB2m": [
    "x",
    "t"
  ],
  "DB3a": [
    "x",
    "t"
  ],
  "DB3m": [
    "x",
    "t"
  ],
  "DB4a": [
    "x",
    "t"
  ],
  "DB4m": [
    "x",
    "t"
  ],
  "DB5a": [
    "x",
    "t"
  ],
  "DB5m": [
    "x",
    "t"
  ],
  "DB6a": [
    "x",
    "t"
  ],
  "DB6m": [
    "x",
    "t"
  ],
  "DB7a": [
    "x",
    "t"
  ],
  "DB7m": [
    "x",
    "t"
  ],
  "DB8a": [
    "x",
    "t"
  ],
  "DB8m": [
    "x",
    "t"
  ],
  "DB9a": [
    "x",
    "t"
  ],
  "DB9m": [
    "x",
    "t"
  ],
  "DB10a": [
    "x",
    "t"
  ],
  "DB10m": [
    "x",
    "t"
  ],
  "DB11a": [
    "x",
    "t"
  ],
  "DB11m": [
    "x",
    "t"
  ],
  "DB12a": [
    "x",
    "t"
  ],
  "DB12m": [
    "x",
    "t"
  ],
  "fda2_deb": [
    "x",
    "t"
  ],
  "get_bounds": [
    "problem_id",
    "n_vars"
  ],
  "cec2018_DF": [
    "problemID",
    "x",
    "t"
  ],
  "false": [],
  "true": [],
  "cec2018_DF_PF": [
    "probID",
    "t",
    "n_points"
  ],
  "all_stoppings": [],
  "void": [
    "_"
  ],
  "my_fmin": [
    "x0",
    "sigma0",
    "objective_function",
    "options",
    "args",
    "gradf",
    "restarts",
    "restart_from_best",
    "incpopsize",
    "eval_initial_x",
    "parallel_objective",
    "noise_handler",
    "noise_change_sigma_exponent",
    "noise_kappa_exponent",
    "bipop",
    "callback",
    "random_state"
  ],
  "MyCMAEvolutionStrategy": {
    "ask_and_eval": [
      "self",
      "func",
      "args",
      "gradf",
      "number",
      "xmean",
      "sigma_fac",
      "evaluations",
      "aggregation",
      "kappa",
      "parallel_mode"
    ]
  },
  "Optimizer": {
    "__init__": [
      "self",
      "method",
      "with_bounds",
      "with_constr",
      "require_jac",
      "use_bounds",
      "use_constr",
      "estm_gradients",
      "disp",
      "show_warnings"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_advance": [
      "self"
    ]
  },
  "CG": {
    "__init__": [
      "self"
    ]
  },
  "NewtonCG": {
    "__init__": [
      "self"
    ]
  },
  "BFGS": {
    "__init__": [
      "self"
    ]
  },
  "Powell": {
    "__init__": [
      "self"
    ]
  },
  "Dogleg": {
    "__init__": [
      "self"
    ]
  },
  "TrustNCG": {
    "__init__": [
      "self"
    ]
  },
  "TrustExact": {
    "__init__": [
      "self"
    ]
  },
  "TrustKrylov": {
    "__init__": [
      "self"
    ]
  },
  "LBFGSB": {
    "__init__": [
      "self"
    ]
  },
  "TNC": {
    "__init__": [
      "self"
    ]
  },
  "COBYLA": {
    "__init__": [
      "self"
    ]
  },
  "SLSQP": {
    "__init__": [
      "self"
    ]
  },
  "TrustConstr": {
    "__init__": [
      "self"
    ]
  },
  "COCOProblem": {
    "__init__": [
      "self",
      "name",
      "n_var",
      "pf_from_file"
    ],
    "_calc_pareto_set": [
      "self"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_evaluate": [
      "self",
      "X",
      "out"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "d"
    ]
  },
  "get_bbob": [
    "name",
    "n_var"
  ],
  "IGDPlus": {
    "__init__": [
      "self",
      "pf"
    ]
  },
  "modified_distance": [
    "z",
    "a",
    "norm"
  ],
  "derive_ideal_and_nadir_from_pf": [
    "pf",
    "ideal",
    "nadir"
  ],
  "DistanceIndicator": {
    "__init__": [
      "self",
      "pf",
      "dist_func",
      "axis",
      "zero_to_one",
      "ideal",
      "nadir",
      "norm_by_dist"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "KKTPM": {
    "calc": [
      "self",
      "X",
      "problem",
      "ideal",
      "utopian_eps",
      "rho"
    ]
  },
  "solve": [
    "A",
    "b",
    "method"
  ],
  "SpacingIndicator": {
    "__init__": [
      "self",
      "pf",
      "zero_to_one",
      "ideal",
      "nadir"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "GDPlus": {
    "__init__": [
      "self",
      "pf"
    ]
  },
  "RMetric": {
    "__init__": [
      "self",
      "problem",
      "ref_points",
      "w",
      "delta",
      "pf"
    ],
    "_filter": [
      "self"
    ],
    "_preprocess": [
      "self",
      "data",
      "ref_point",
      "w_point"
    ],
    "_translate": [
      "self",
      "zp",
      "trimmed_data",
      "ref_point",
      "w_point"
    ],
    "_trim": [
      "self",
      "pop",
      "centeroid",
      "range"
    ],
    "_trim_fast": [
      "self",
      "pop",
      "centeroid",
      "range"
    ],
    "do": [
      "self",
      "F",
      "others",
      "calc_hv"
    ]
  },
  "IGD": {
    "__init__": [
      "self",
      "pf"
    ]
  },
  "GD": {
    "__init__": [
      "self",
      "pf"
    ]
  },
  "MIGD": {
    "__init__": [
      "self",
      "reevaluate"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "value": [
      "self"
    ]
  },
  "alpha": [
    "N",
    "k"
  ],
  "hv_monte_carlo": [
    "dom",
    "V",
    "n_dom"
  ],
  "hvc_monte_carlo": [
    "dom",
    "V",
    "n_dom",
    "k"
  ],
  "ApproximateHypervolume": {
    "__init__": [
      "self",
      "ref_point",
      "n_samples",
      "n_exclusive",
      "random_state"
    ],
    "_calc": [
      "self",
      "ref_point",
      "F"
    ],
    "delete": [
      "self",
      "k"
    ]
  },
  "Hypervolume": {
    "__init__": [
      "self",
      "ref_point",
      "pf",
      "nds",
      "norm_ref_point",
      "ideal",
      "nadir"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "HV": {},
  "hvc_looped": [
    "ref_point",
    "F",
    "func"
  ],
  "hvc_2d_slow": [
    "ref_point",
    "F"
  ],
  "hvc_2d_fast": [
    "ref_point",
    "F_sorted",
    "left",
    "right"
  ],
  "hv_2d_fast": [
    "ref_point",
    "F_sorted"
  ],
  "ExactHypervolume2D": {
    "__init__": [
      "self",
      "ref_point"
    ],
    "_calc": [
      "self",
      "ref_point",
      "F"
    ]
  },
  "hv_exact": [
    "ref_point",
    "F"
  ],
  "hvc_exact": [
    "ref_point",
    "F"
  ],
  "DynamicHypervolume": {
    "__init__": [
      "self",
      "ref_point",
      "F",
      "func_hv",
      "func_hvc"
    ],
    "add": [
      "self",
      "F"
    ],
    "delete": [
      "self",
      "k"
    ],
    "calc": [
      "self"
    ],
    "_calc": [
      "self",
      "ref_point",
      "F"
    ]
  },
  "ExactHypervolume": {
    "__init__": [
      "self",
      "ref_point",
      "func_hv",
      "func_hvc"
    ]
  },
  "DesignSpaceTermination": {
    "__init__": [
      "self",
      "tol"
    ],
    "_delta": [
      "self",
      "prev",
      "current"
    ],
    "_data": [
      "self",
      "algorithm"
    ]
  },
  "DefaultTermination": {
    "__init__": [
      "self",
      "x",
      "cv",
      "f",
      "n_max_gen",
      "n_max_evals"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "DefaultSingleObjectiveTermination": {
    "__init__": [
      "self",
      "xtol",
      "cvtol",
      "ftol",
      "period"
    ]
  },
  "DefaultMultiObjectiveTermination": {
    "__init__": [
      "self",
      "xtol",
      "cvtol",
      "ftol",
      "n_skip",
      "period"
    ]
  },
  "TerminationCollection": {
    "__init__": [
      "self"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "calc_delta": [
    "a",
    "b"
  ],
  "calc_delta_norm": [
    "a",
    "b",
    "norm"
  ],
  "SingleObjectiveSpaceTermination": {
    "__init__": [
      "self",
      "tol",
      "only_feas"
    ],
    "_delta": [
      "self",
      "prev",
      "current"
    ],
    "_data": [
      "self",
      "algorithm"
    ]
  },
  "MultiObjectiveSpaceTermination": {
    "__init__": [
      "self",
      "tol",
      "only_feas"
    ],
    "_data": [
      "self",
      "algorithm"
    ],
    "_delta": [
      "self",
      "prev",
      "current"
    ]
  },
  "MultiObjectiveSpaceTerminationWithRenormalization": {
    "__init__": [
      "self",
      "n",
      "all_to_current",
      "sliding_window",
      "indicator"
    ],
    "_metric": [
      "self",
      "data"
    ],
    "_decide": [
      "self",
      "metrics"
    ]
  },
  "IndicatorTermination": {
    "__init__": [
      "self",
      "indicator",
      "threshold",
      "goal"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "MaximumGenerationTermination": {
    "__init__": [
      "self",
      "n_max_gen"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "TimeBasedTermination": {
    "__init__": [
      "self",
      "max_time"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "DeltaToleranceTermination": {
    "__init__": [
      "self",
      "tol",
      "n_skip"
    ],
    "_update": [
      "self",
      "algorithm"
    ],
    "_delta": [
      "self",
      "prev",
      "current"
    ],
    "_data": [
      "self",
      "algorithm"
    ]
  },
  "get_termination": [
    "name"
  ],
  "MinimumFunctionValueTermination": {
    "__init__": [
      "self",
      "fmin"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "ConstraintViolationTermination": {
    "__init__": [
      "self",
      "tol",
      "terminate_when_feasible"
    ],
    "_update": [
      "self",
      "algorithm"
    ],
    "_delta": [
      "self",
      "prev",
      "current"
    ],
    "_data": [
      "self",
      "algorithm"
    ]
  },
  "UntilFeasibleTermination": {
    "__init__": [
      "self"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "RobustTermination": {
    "__init__": [
      "self",
      "termination",
      "period"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "MaximumFunctionCallTermination": {
    "__init__": [
      "self",
      "n_max_evals"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "Variable": {
    "__init__": [
      "self",
      "value",
      "active",
      "flag"
    ],
    "sample": [
      "self",
      "n",
      "random_state"
    ],
    "_sample": [
      "self",
      "n",
      "random_state"
    ],
    "set": [
      "self",
      "value"
    ],
    "get": [
      "self"
    ]
  },
  "BoundedVariable": {
    "__init__": [
      "self",
      "value",
      "bounds",
      "strict"
    ],
    "lb": [
      "self"
    ],
    "ub": [
      "self"
    ]
  },
  "Real": {
    "vtype": [],
    "_sample": [
      "self",
      "n",
      "random_state"
    ]
  },
  "Integer": {
    "vtype": [],
    "_sample": [
      "self",
      "n",
      "random_state"
    ]
  },
  "Binary": {
    "vtype": [],
    "_sample": [
      "self",
      "n",
      "random_state"
    ]
  },
  "Choice": {
    "vtype": [],
    "__init__": [
      "self",
      "value",
      "options",
      "all"
    ],
    "_sample": [
      "self",
      "n",
      "random_state"
    ]
  },
  "get": [],
  "Algorithm": {
    "__init__": [
      "self",
      "termination",
      "output",
      "display",
      "callback",
      "archive",
      "return_least_infeasible",
      "save_history",
      "verbose",
      "seed",
      "evaluator"
    ],
    "setup": [
      "self",
      "problem",
      "verbose",
      "progress"
    ],
    "run": [
      "self"
    ],
    "has_next": [
      "self"
    ],
    "finalize": [
      "self"
    ],
    "next": [
      "self"
    ],
    "_initialize": [
      "self"
    ],
    "infill": [
      "self"
    ],
    "advance": [
      "self",
      "infills"
    ],
    "result": [
      "self"
    ],
    "ask": [
      "self"
    ],
    "tell": [
      "self"
    ],
    "_set_optimum": [
      "self"
    ],
    "_post_advance": [
      "self"
    ],
    "_setup": [
      "self",
      "problem"
    ],
    "_initialize_infill": [
      "self"
    ],
    "_initialize_advance": [
      "self",
      "infills"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ],
    "_finalize": [
      "self"
    ],
    "n_gen": [
      "self",
      "value"
    ]
  },
  "LoopwiseAlgorithm": {
    "__init__": [
      "self"
    ],
    "_next": [
      "self"
    ],
    "_infill": [
      "self"
    ],
    "_advance": [
      "self",
      "infills"
    ]
  },
  "default_termination": [
    "problem"
  ],
  "Selection": {
    "__init__": [
      "self"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "n_select",
      "n_parents",
      "to_pop"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_select",
      "n_parents"
    ]
  },
  "Solution": {},
  "SolutionSet": {},
  "InfillCriterion": {
    "__init__": [
      "self",
      "repair",
      "eliminate_duplicates",
      "n_max_iterations"
    ],
    "__call__": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "random_state"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "random_state",
      "n_max_iterations"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "random_state"
    ]
  },
  "Evaluator": {
    "__init__": [
      "self",
      "skip_already_evaluated",
      "evaluate_values_of",
      "callback"
    ],
    "eval": [
      "self",
      "problem",
      "pop",
      "skip_already_evaluated",
      "evaluate_values_of",
      "count_evals"
    ],
    "_eval": [
      "self",
      "problem",
      "pop",
      "evaluate_values_of"
    ]
  },
  "VoidEvaluator": {
    "__init__": [
      "self",
      "value"
    ],
    "eval": [
      "self",
      "problem",
      "pop"
    ]
  },
  "Sampling": {
    "__init__": [
      "self"
    ],
    "do": [
      "self",
      "problem",
      "n_samples"
    ],
    "_do": [
      "self",
      "problem",
      "n_samples"
    ]
  },
  "Crossover": {
    "__init__": [
      "self",
      "n_parents",
      "n_offsprings",
      "prob"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "parents"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "Initialization": {
    "__init__": [
      "self",
      "sampling",
      "repair",
      "eliminate_duplicates"
    ],
    "do": [
      "self",
      "problem",
      "n_samples",
      "random_state"
    ]
  },
  "get_data": [
    "obj"
  ],
  "get_params": [
    "obj",
    "flag",
    "only_active"
  ],
  "get_params_bfs": [
    "obj",
    "flag",
    "only_active"
  ],
  "get_params_rec": [
    "obj",
    "visited",
    "flag",
    "only_active"
  ],
  "apply_to_params": [
    "obj",
    "func_apply"
  ],
  "deactivate_params": [
    "obj"
  ],
  "set_params": [
    "obj",
    "params",
    "as_value"
  ],
  "flatten": [
    "params"
  ],
  "flatten_rec": [
    "params",
    "prefix"
  ],
  "hierarchical": [
    "data"
  ],
  "Indicator": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "F"
    ],
    "do": [
      "self",
      "F"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "DecisionMaking": {
    "__init__": [
      "self"
    ],
    "_do": [
      "self",
      "F"
    ]
  },
  "NeighborFinder": {
    "__init__": [
      "self",
      "N",
      "epsilon",
      "n_neighbors",
      "n_min_neigbors",
      "consider_2d"
    ],
    "find": [
      "self",
      "i"
    ]
  },
  "find_outliers_upper_tail": [
    "mu"
  ],
  "Termination": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "has_terminated": [
      "self"
    ],
    "do_continue": [
      "self"
    ],
    "terminate": [
      "self"
    ],
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "NoTermination": {
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "MultipleCriteria": {
    "__init__": [
      "self"
    ]
  },
  "TerminateIfAny": {
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "TerminateIfAll": {
    "_update": [
      "self",
      "algorithm"
    ]
  },
  "default_config": [],
  "Individual": {
    "default_config": [],
    "__init__": [
      "self",
      "config"
    ],
    "reset": [
      "self",
      "data"
    ],
    "has": [
      "self",
      "key"
    ],
    "X": [
      "self",
      "value"
    ],
    "F": [
      "self",
      "value"
    ],
    "G": [
      "self",
      "value"
    ],
    "H": [
      "self",
      "value"
    ],
    "CV": [
      "self",
      "value"
    ],
    "FEAS": [
      "self"
    ],
    "dF": [
      "self",
      "value"
    ],
    "dG": [
      "self",
      "value"
    ],
    "dH": [
      "self",
      "value"
    ],
    "ddF": [
      "self",
      "value"
    ],
    "ddG": [
      "self",
      "value"
    ],
    "ddH": [
      "self",
      "value"
    ],
    "x": [
      "self"
    ],
    "f": [
      "self"
    ],
    "cv": [
      "self"
    ],
    "feas": [
      "self"
    ],
    "feasible": [
      "self"
    ],
    "set_by_dict": [
      "self"
    ],
    "set": [
      "self",
      "key",
      "value"
    ],
    "get": [
      "self"
    ],
    "duplicate": [
      "self",
      "key",
      "new_key"
    ],
    "new": [
      "self"
    ],
    "copy": [
      "self",
      "other",
      "deep"
    ]
  },
  "calc_cv": [
    "G",
    "H",
    "config"
  ],
  "constr_to_cv": [
    "c",
    "eps",
    "scale",
    "pow",
    "func"
  ],
  "Result": {
    "__init__": [
      "self"
    ],
    "cv": [
      "self"
    ],
    "f": [
      "self"
    ],
    "feas": [
      "self"
    ]
  },
  "Callback": {
    "__init__": [
      "self"
    ],
    "initialize": [
      "self",
      "algorithm"
    ],
    "notify": [
      "self",
      "algorithm"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "_update": [
      "self",
      "algorithm"
    ],
    "__call__": [
      "self",
      "algorithm"
    ]
  },
  "CallbackCollection": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "Survival": {
    "__init__": [
      "self",
      "filter_infeasible"
    ],
    "do": [
      "self",
      "problem",
      "pop"
    ],
    "_do": [
      "self",
      "problem",
      "pop"
    ]
  },
  "ToReplacement": {
    "__init__": [
      "self",
      "survival"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "off",
      "random_state"
    ]
  },
  "split_by_feasibility": [
    "pop",
    "sort_infeas_by_cv",
    "sort_feas_by_obj",
    "return_pop"
  ],
  "Plot": {
    "__init__": [
      "self",
      "fig",
      "ax",
      "figsize",
      "title",
      "legend",
      "tight_layout",
      "bounds",
      "reverse",
      "cmap",
      "axis_style",
      "axis_label_style",
      "func_number_to_text",
      "labels",
      "close_on_destroy"
    ],
    "init_figure": [
      "self",
      "n_rows",
      "n_cols",
      "plot_3D",
      "force_axes_as_matrix"
    ],
    "do": [
      "self"
    ],
    "apply": [
      "self",
      "func"
    ],
    "get_plot": [
      "self"
    ],
    "set_axis_style": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "add": [
      "self",
      "F"
    ],
    "plot_if_not_done_yet": [
      "self"
    ],
    "show": [
      "self"
    ],
    "save": [
      "self",
      "fname"
    ],
    "get_labels": [
      "self"
    ],
    "__del__": [
      "self"
    ]
  },
  "get_parameter_with_options": [
    "param"
  ],
  "LoopedElementwiseEvaluation": {
    "__call__": [
      "self",
      "f",
      "X"
    ]
  },
  "ElementwiseEvaluationFunction": {
    "__init__": [
      "self",
      "problem",
      "args",
      "kwargs"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "Problem": {
    "__init__": [
      "self",
      "n_var",
      "n_obj",
      "n_ieq_constr",
      "n_eq_constr",
      "xl",
      "xu",
      "vtype",
      "vars",
      "elementwise",
      "elementwise_func",
      "elementwise_runner",
      "requires_kwargs",
      "replace_nan_values_by",
      "exclude_from_serialization",
      "callback",
      "strict"
    ],
    "evaluate": [
      "self",
      "X"
    ],
    "do": [
      "self",
      "X",
      "return_values_of"
    ],
    "_evaluate_vectorized": [
      "self",
      "X",
      "out"
    ],
    "_evaluate_elementwise": [
      "self",
      "X",
      "out"
    ],
    "_format_dict": [
      "self",
      "out",
      "N",
      "return_values_of"
    ],
    "nadir_point": [
      "self"
    ],
    "ideal_point": [
      "self"
    ],
    "pareto_front": [
      "self"
    ],
    "pareto_set": [
      "self"
    ],
    "n_constr": [
      "self"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ],
    "has_bounds": [
      "self"
    ],
    "has_constraints": [
      "self"
    ],
    "bounds": [
      "self"
    ],
    "name": [
      "self"
    ],
    "_calc_pareto_front": [
      "self"
    ],
    "_calc_pareto_set": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__getstate__": [
      "self"
    ]
  },
  "ElementwiseProblem": {
    "__init__": [
      "self",
      "elementwise"
    ]
  },
  "default_shape": [
    "problem",
    "n"
  ],
  "is_better": [
    "_new",
    "_old",
    "eps"
  ],
  "ReplacementSurvival": {
    "do": [
      "self",
      "problem",
      "pop",
      "off",
      "return_indices",
      "inplace"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "off"
    ]
  },
  "ImprovementReplacement": {
    "_do": [
      "self",
      "problem",
      "pop",
      "off"
    ]
  },
  "parameter_less": [
    "f",
    "cv"
  ],
  "hierarchical_sort": [
    "f",
    "cv"
  ],
  "Mutation": {
    "__init__": [
      "self",
      "prob",
      "prob_var"
    ],
    "do": [
      "self",
      "problem",
      "pop",
      "inplace"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ],
    "get_prob_var": [
      "self",
      "problem"
    ]
  },
  "default_attr": [
    "pop"
  ],
  "DuplicateElimination": {
    "__init__": [
      "self",
      "func"
    ],
    "do": [
      "self",
      "pop"
    ],
    "_do": [
      "self",
      "pop",
      "other",
      "is_duplicate"
    ]
  },
  "DefaultDuplicateElimination": {
    "__init__": [
      "self",
      "epsilon"
    ],
    "calc_dist": [
      "self",
      "pop",
      "other"
    ],
    "_do": [
      "self",
      "pop",
      "other",
      "is_duplicate"
    ]
  },
  "to_float": [
    "val"
  ],
  "ElementwiseDuplicateElimination": {
    "__init__": [
      "self",
      "cmp_func"
    ],
    "is_equal": [
      "self",
      "a",
      "b"
    ],
    "_do": [
      "self",
      "pop",
      "other",
      "is_duplicate"
    ]
  },
  "to_hash": [
    "x"
  ],
  "HashDuplicateElimination": {
    "__init__": [
      "self",
      "func"
    ],
    "_do": [
      "self",
      "pop",
      "other",
      "is_duplicate"
    ]
  },
  "NoDuplicateElimination": {
    "do": [
      "self",
      "pop"
    ]
  },
  "Mating": {
    "__init__": [
      "self",
      "selection",
      "crossover",
      "mutation"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "parents",
      "random_state"
    ]
  },
  "Repair": {
    "do": [
      "self",
      "problem",
      "pop"
    ],
    "_do": [
      "self",
      "problem",
      "X"
    ]
  },
  "NoRepair": {},
  "Decomposition": {
    "__init__": [
      "self",
      "eps",
      "_type"
    ],
    "__call__": [
      "self"
    ],
    "do": [
      "self",
      "F",
      "weights",
      "_type",
      "ideal_point",
      "utopian_point",
      "nadir_point"
    ]
  },
  "Population": {
    "__new__": [
      "cls",
      "individuals"
    ],
    "has": [
      "self",
      "key"
    ],
    "collect": [
      "self",
      "func",
      "to_numpy"
    ],
    "apply": [
      "self",
      "func"
    ],
    "set": [
      "self"
    ],
    "get": [
      "self"
    ],
    "merge": [
      "cls",
      "a",
      "b"
    ],
    "create": [
      "cls"
    ],
    "empty": [
      "cls",
      "size"
    ],
    "new": [
      "cls"
    ]
  },
  "pop_from_array_or_individual": [
    "array",
    "pop"
  ],
  "merge": [
    "a",
    "b"
  ],
  "interleaving_args": [],
  "Recorder": {
    "__init__": [
      "self",
      "nth_evals"
    ],
    "notify": [
      "self",
      "algorithm"
    ],
    "save": [
      "self",
      "algorithm"
    ],
    "get": [
      "self"
    ]
  },
  "DefaultSingleObjectiveRecorder": {
    "save": [
      "self",
      "algorithm"
    ]
  },
  "DefaultMultiObjectiveRecorder": {
    "save": [
      "self",
      "algorithm"
    ]
  },
  "Operator": {
    "__init__": [
      "self",
      "name",
      "vtype",
      "repair"
    ],
    "do": [
      "self",
      "problem",
      "elem"
    ],
    "_do": [
      "self",
      "problem",
      "elem"
    ],
    "__call__": [
      "self",
      "problem",
      "elem"
    ]
  },
  "Meta": {
    "__init__": [
      "self",
      "object",
      "copy",
      "clazz"
    ]
  },
  "MixedVariableMating": {
    "__init__": [
      "self",
      "selection",
      "crossover",
      "mutation",
      "repair",
      "eliminate_duplicates",
      "n_max_iterations"
    ],
    "_do": [
      "self",
      "problem",
      "pop",
      "n_offsprings",
      "parents",
      "random_state"
    ]
  },
  "MixedVariableSampling": {
    "_do": [
      "self",
      "problem",
      "n_samples",
      "random_state"
    ]
  },
  "MixedVariableDuplicateElimination": {
    "is_equal": [
      "self",
      "a",
      "b"
    ]
  },
  "groups_of_vars": [
    "vars"
  ],
  "MixedVariableGA": {
    "__init__": [
      "self",
      "pop_size",
      "n_offsprings",
      "output",
      "sampling",
      "mating",
      "eliminate_duplicates",
      "survival"
    ]
  },
  "randomized_argsort": [
    "A",
    "method",
    "order",
    "random_state"
  ],
  "quicksort": [
    "A",
    "random_state"
  ],
  "_quicksort": [
    "A",
    "I",
    "left",
    "right",
    "random_state"
  ],
  "Truncation": {
    "__call__": [
      "self",
      "sols",
      "k"
    ]
  },
  "RandomTruncation": {
    "__call__": [
      "self",
      "sols",
      "k",
      "random_state"
    ]
  },
  "SurvivalTruncation": {
    "__init__": [
      "self",
      "survival",
      "problem"
    ],
    "__call__": [
      "self",
      "sols",
      "k"
    ]
  },
  "Archive": {
    "__new__": [
      "cls",
      "individuals",
      "max_size",
      "truncate_size",
      "truncation",
      "duplicate_elimination"
    ],
    "__array_finalize__": [
      "self",
      "obj"
    ],
    "add": [
      "self",
      "sols"
    ],
    "_find_opt": [
      "self",
      "sols"
    ]
  },
  "VoidArchive": {
    "add": [
      "self",
      "sols"
    ]
  },
  "SingleObjectiveArchive": {
    "__new__": [
      "cls",
      "max_size"
    ],
    "_find_opt": [
      "self",
      "sols"
    ]
  },
  "MultiObjectiveArchive": {
    "__new__": [
      "cls",
      "max_size",
      "truncate_size"
    ],
    "_find_opt": [
      "self",
      "sols"
    ]
  },
  "default_archive": [
    "problem"
  ],
  "default_ref_dirs": [
    "m"
  ],
  "ReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "scaling",
      "lexsort",
      "verbose"
    ],
    "__call__": [
      "self"
    ],
    "do": [
      "self",
      "random_state"
    ],
    "_do": [
      "self",
      "random_state"
    ]
  },
  "get_number_of_uniform_points": [
    "n_partitions",
    "n_dim"
  ],
  "get_partition_closest_to_points": [
    "n_points",
    "n_dim"
  ],
  "das_dennis": [
    "n_partitions",
    "n_dim"
  ],
  "das_dennis_recursion": [
    "ref_dirs",
    "ref_dir",
    "n_partitions",
    "beta",
    "depth"
  ],
  "UniformReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "scaling",
      "n_points",
      "n_partitions"
    ],
    "_do": [
      "self",
      "random_state"
    ]
  },
  "MultiLayerReferenceDirectionFactory": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self"
    ],
    "add_layer": [
      "self"
    ],
    "do": [
      "self"
    ]
  },
  "get_rng": [
    "random_state"
  ],
  "sample_on_unit_simplex": [
    "n_points",
    "n_dim",
    "unit_simplex_mapping",
    "random_state"
  ],
  "map_onto_unit_simplex": [
    "rnd",
    "method"
  ],
  "scale_reference_directions": [
    "ref_dirs",
    "scaling"
  ],
  "select_points_with_maximum_distance": [
    "X",
    "n_select",
    "selected",
    "random_state"
  ],
  "Cache": [
    "func"
  ],
  "SlidingWindow": {
    "__init__": [
      "self",
      "size"
    ],
    "append": [
      "self",
      "entry"
    ],
    "is_full": [
      "self"
    ],
    "to_numpy": [
      "self"
    ],
    "clear": [
      "self"
    ]
  },
  "filter_optimum": [
    "pop",
    "least_infeasible"
  ],
  "get_relation": [
    "ind_a",
    "ind_b"
  ],
  "Dominator": {
    "get_relation": [
      "a",
      "b",
      "cva",
      "cvb"
    ],
    "calc_domination_matrix_loop": [
      "F",
      "G"
    ],
    "calc_domination_matrix": [
      "F",
      "_F",
      "epsilon"
    ]
  },
  "max_alpha": [
    "point",
    "direction",
    "xl",
    "xu",
    "mode"
  ],
  "calc_hvc_looped": [
    "ref_point",
    "F",
    "func"
  ],
  "Normalization": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "X"
    ],
    "backward": [
      "self",
      "X"
    ]
  },
  "NoNormalization": {
    "forward": [
      "self",
      "X"
    ],
    "backward": [
      "self",
      "X"
    ]
  },
  "ZeroToOneNormalization": {
    "__init__": [
      "self",
      "xl",
      "xu"
    ],
    "forward": [
      "self",
      "X"
    ],
    "backward": [
      "self",
      "N"
    ]
  },
  "SimpleZeroToOneNormalization": {
    "__init__": [
      "self",
      "xl",
      "xu",
      "estimate_bounds"
    ],
    "forward": [
      "self",
      "X"
    ],
    "backward": [
      "self",
      "X"
    ]
  },
  "denormalize": [
    "x",
    "xl",
    "xu"
  ],
  "standardize": [
    "x",
    "return_bounds"
  ],
  "destandardize": [
    "x",
    "mean",
    "std"
  ],
  "PreNormalization": {
    "__init__": [
      "self",
      "zero_to_one",
      "ideal",
      "nadir"
    ],
    "do": [
      "self"
    ]
  },
  "find_ideal": [
    "F",
    "current"
  ],
  "ObjectiveSpaceNormalization": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "pop"
    ],
    "ideal": [
      "self",
      "only_feas"
    ]
  },
  "default_random_state": [
    "func_or_seed"
  ],
  "VFDominator": {
    "__init__": [
      "self",
      "algorithm"
    ],
    "get_relation": [
      "a",
      "b",
      "cva",
      "cvb"
    ],
    "calc_domination_matrix_loop": [
      "F",
      "G"
    ],
    "calc_domination_matrix": [
      "self",
      "F",
      "_F",
      "epsilon"
    ]
  },
  "RunningMetric": {
    "__init__": [
      "self",
      "period",
      "indicator"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "RunningMetricAnimation": {
    "__init__": [
      "self",
      "delta_gen",
      "n_plots",
      "key_press"
    ],
    "draw": [
      "self",
      "data",
      "ax"
    ],
    "do": [
      "self",
      "_",
      "algorithm",
      "force_plot"
    ]
  },
  "install_matlab": [],
  "MatlabEngine": {
    "__instance": [],
    "get_instance": [],
    "shutdown": []
  },
  "Remote": {
    "__instance": [],
    "get_instance": [],
    "__init__": [
      "self",
      "server",
      "folder"
    ],
    "load": [
      "self"
    ]
  },
  "func_select_by_objective": [
    "pop"
  ],
  "func_select_from_sorted": [
    "_"
  ],
  "select_by_clearing": [
    "pop",
    "D",
    "n_select",
    "func_select",
    "delta"
  ],
  "EpsilonClearing": {
    "__init__": [
      "self",
      "D",
      "epsilon"
    ],
    "remaining": [
      "self"
    ],
    "has_remaining": [
      "self"
    ],
    "cleared": [
      "self"
    ],
    "selected": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "select": [
      "self",
      "k"
    ]
  },
  "repair": [
    "X",
    "xl",
    "xu"
  ],
  "unique_rows": [
    "a"
  ],
  "parameter_less_constraints": [
    "F",
    "CV",
    "F_max"
  ],
  "random_permutations": [
    "n",
    "l",
    "concat",
    "random_state"
  ],
  "get_duplicates": [
    "M"
  ],
  "func_euclidean_distance": [
    "a",
    "b"
  ],
  "func_norm_euclidean_distance": [
    "xl",
    "xu"
  ],
  "norm_eucl_dist_by_bounds": [
    "A",
    "B",
    "xl",
    "xu"
  ],
  "norm_eucl_dist": [
    "problem",
    "A",
    "B"
  ],
  "func_manhatten_distance": [
    "a",
    "b"
  ],
  "func_norm_manhatten_distance": [
    "xl",
    "xu"
  ],
  "norm_manhatten_dist_by_bounds": [
    "A",
    "B",
    "xl",
    "xu"
  ],
  "norm_manhatten_dist": [
    "problem",
    "A",
    "B"
  ],
  "func_tchebychev_distance": [
    "a",
    "b"
  ],
  "func_norm_tchebychev_distance": [
    "xl",
    "xu"
  ],
  "norm_tchebychev_dist_by_bounds": [
    "A",
    "B",
    "xl",
    "xu"
  ],
  "norm_tchebychev_dist": [
    "problem",
    "A",
    "B"
  ],
  "cdist": [
    "A",
    "B"
  ],
  "vectorized_cdist": [
    "A",
    "B",
    "func_dist",
    "fill_diag_with_inf"
  ],
  "covert_to_type": [
    "problem",
    "X"
  ],
  "find_duplicates": [
    "X",
    "epsilon"
  ],
  "at_least_2d": [],
  "at_least_2d_array": [
    "x",
    "extend_as",
    "return_if_reshaped"
  ],
  "to_1d_array_if_possible": [
    "x"
  ],
  "stack": [],
  "all_except": [
    "x"
  ],
  "all_combinations": [
    "A",
    "B"
  ],
  "pop_from_sampling": [
    "problem",
    "sampling",
    "n_initial_samples",
    "pop"
  ],
  "evaluate_if_not_done_yet": [
    "evaluator",
    "problem",
    "pop",
    "algorithm"
  ],
  "set_if_none": [
    "kwargs",
    "str",
    "val"
  ],
  "set_if_none_from_tuples": [
    "kwargs"
  ],
  "distance_of_closest_points_to_others": [
    "X"
  ],
  "time_to_int": [
    "t"
  ],
  "powerset": [
    "iterable"
  ],
  "intersect": [
    "a",
    "b"
  ],
  "has_feasible": [
    "pop"
  ],
  "to_numpy": [
    "a"
  ],
  "termination_from_tuple": [
    "termination"
  ],
  "unique_and_all_indices": [
    "arr"
  ],
  "from_dict": [
    "D"
  ],
  "list_of_dicts_unique": [
    "l",
    "k"
  ],
  "list_of_dicts_filter": [
    "l"
  ],
  "logical_op": [
    "func",
    "a",
    "b"
  ],
  "replace_nan_by": [
    "x",
    "val",
    "inplace"
  ],
  "set_defaults": [
    "kwargs",
    "defaults",
    "overwrite",
    "func_get"
  ],
  "filter_params": [
    "params",
    "prefix",
    "delete_prefix"
  ],
  "where_is_what": [
    "x"
  ],
  "crossover_mask": [
    "X",
    "M"
  ],
  "row_at_least_once_true": [
    "M",
    "random_state"
  ],
  "create_vf": [
    "P",
    "ranks",
    "ineq_constr",
    "vf",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "create_poly_vf": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "create_linear_vf": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method"
  ],
  "create_vf_scipy_poly": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "create_vf_scipy_linear": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "create_vf_pymoo_linear": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "create_vf_pymoo_poly": [
    "P",
    "ranks",
    "delta",
    "eps_max",
    "method",
    "verbose"
  ],
  "linear_vf": [
    "P",
    "x"
  ],
  "poly_vf": [
    "P",
    "x"
  ],
  "plot_vf": [
    "P",
    "vf",
    "show"
  ],
  "_ineq_constr_poly": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_build_ineq_constr_poly": [
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_eq_constr_poly": [
    "x"
  ],
  "_build_constr_poly": [
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_ineq_constr_2D_poly": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_ineq_constr_1D_poly": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_build_ineq_constr_linear": [
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_build_constr_linear": [
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_ineq_constr_linear": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_ineq_constr_2D_linear": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_ineq_constr_1D_linear": [
    "x",
    "P",
    "vf",
    "ranks",
    "delta"
  ],
  "_obj_func": [
    "x"
  ],
  "_sort_P": [
    "P",
    "ranks"
  ],
  "_calc_S": [
    "P",
    "x"
  ],
  "_eq_constr_linear": [
    "x"
  ],
  "make_vf_comparator": [
    "vf",
    "P_rank_2"
  ],
  "vf_comparator": [
    "vf",
    "P_rank_2",
    "P"
  ],
  "OptimizeLinearVF": {
    "__init__": [
      "self",
      "P",
      "ranks",
      "delta",
      "eps_max",
      "vf"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "_validate_vf": [
    "res",
    "verbose"
  ],
  "OptimizePolyVF": {
    "__init__": [
      "self",
      "P",
      "ranks",
      "delta",
      "eps_max",
      "vf"
    ],
    "_evaluate": [
      "self",
      "x",
      "out"
    ]
  },
  "vfResults": {
    "__init__": [
      "self",
      "vf",
      "params",
      "epsilon",
      "fit"
    ]
  },
  "RouletteWheelSelection": {
    "__init__": [
      "self",
      "val",
      "larger_is_better"
    ],
    "next": [
      "self",
      "n",
      "random_state"
    ]
  },
  "NumberOfNondominatedSolutions": {
    "__init__": [
      "self",
      "width"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "MultiObjectiveOutput": {
    "__init__": [
      "self"
    ],
    "initialize": [
      "self",
      "algorithm"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "MinimumConstraintViolation": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "AverageConstraintViolation": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "SingleObjectiveOutput": {
    "__init__": [
      "self"
    ],
    "initialize": [
      "self",
      "algorithm"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "Display": {
    "__init__": [
      "self",
      "output",
      "progress",
      "verbose"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "finalize": [
      "self"
    ]
  },
  "Column": {
    "__init__": [
      "self",
      "name",
      "width",
      "func",
      "truncate"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "header": [
      "self"
    ],
    "text": [
      "self"
    ],
    "set": [
      "self",
      "value"
    ]
  },
  "number_to_text": [
    "number",
    "width"
  ],
  "format_text": [
    "value",
    "width",
    "truncate"
  ],
  "ProgressBar": {
    "__init__": [
      "self"
    ],
    "set": [
      "self",
      "value"
    ],
    "start": [
      "self"
    ],
    "close": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "type",
      "value",
      "traceback"
    ]
  },
  "pareto_front_if_possible": [
    "problem"
  ],
  "NumberOfGenerations": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "NumberOfEvaluations": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  },
  "Output": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "header": [
      "self",
      "border"
    ],
    "text": [
      "self"
    ]
  },
  "LayerwiseRieszEnergyReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "partitions",
      "return_as_tuple",
      "n_max_iter",
      "verbose",
      "X"
    ],
    "_step": [
      "self",
      "optimizer",
      "X",
      "scalings"
    ],
    "_solve": [
      "self",
      "X",
      "scalings"
    ],
    "do": [
      "self"
    ]
  },
  "get_points": [
    "X",
    "scalings"
  ],
  "calc_potential_energy": [
    "scalings",
    "X"
  ],
  "RandomSamplingAndMap": {
    "__init__": [
      "self",
      "n_dim",
      "n_points"
    ],
    "_do": [
      "self",
      "random_state"
    ]
  },
  "DasDennis": {
    "__init__": [
      "self",
      "n_partitions",
      "n_dim",
      "scaling"
    ],
    "number_of_points": [
      "self"
    ],
    "next": [
      "self",
      "n_points"
    ],
    "has_next": [
      "self"
    ],
    "traverse": [
      "self",
      "func",
      "n_points"
    ]
  },
  "RieszEnergyReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "n_points",
      "ref_points",
      "return_as_tuple",
      "n_max_iter",
      "n_until_optimizer_reset",
      "sampling",
      "norm_gradients",
      "verify_gradient",
      "freeze_edges",
      "precision",
      "restarts",
      "X",
      "d",
      "callback"
    ],
    "_step": [
      "self",
      "optimizer",
      "X",
      "freeze"
    ],
    "_solve": [
      "self",
      "X",
      "F",
      "freeze_edges"
    ],
    "_do": [
      "self",
      "random_state"
    ],
    "calc_ref_points": [
      "self",
      "X",
      "ref_points"
    ]
  },
  "squared_dist": [
    "A",
    "B"
  ],
  "calc_potential_energy_with_grad": [
    "x",
    "d",
    "return_mutual_dist"
  ],
  "get_reference_directions": [
    "name"
  ],
  "distance_of_closest_point": [
    "ref_dirs"
  ],
  "average_distance_to_other_points": [
    "ref_dirs"
  ],
  "closest_point_variance": [
    "z"
  ],
  "closest_point_variance_mod": [
    "z"
  ],
  "geometric_mean_var": [
    "z"
  ],
  "mean_mean": [
    "z"
  ],
  "potential_energy": [
    "x"
  ],
  "iterative_igd": [
    "X",
    "n_partitions",
    "batch_size"
  ],
  "gram_schmidt": [
    "X",
    "row_vecs",
    "norm"
  ],
  "triangulation": [
    "X"
  ],
  "project_onto_one_dim_less": [
    "X"
  ],
  "simplex_edge_difference": [
    "X"
  ],
  "kmeans": [
    "X",
    "centroids",
    "n_max_iter",
    "a_tol",
    "n_ignore"
  ],
  "ReductionBasedReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "n_points",
      "scaling",
      "n_sample_points",
      "sampling",
      "kmeans",
      "kmeans_max_iter",
      "kmeans_a_tol"
    ],
    "_do": [
      "self",
      "random_state"
    ]
  },
  "check_n_points": [
    "n_points",
    "n_dim"
  ],
  "incremental_lattice": [
    "n_partitions",
    "n_dim"
  ],
  "IncrementalReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "scaling",
      "n_points",
      "n_partitions"
    ],
    "_do": [
      "self"
    ]
  },
  "project_onto": [
    "y",
    "p",
    "n"
  ],
  "project_onto_sum_equals_one_plane": [
    "y"
  ],
  "project_onto_sum_equals_zero_plane": [
    "y"
  ],
  "project_onto_unit_simplex": [
    "X"
  ],
  "project_onto_unit_simplex_recursive": [
    "X"
  ],
  "matrix_project_onto_sum_equals_one_plane": [
    "next"
  ],
  "ReferenceDirectionGA": {
    "__init__": [
      "self",
      "n_dim",
      "n_points",
      "fun",
      "pop_size",
      "n_gen",
      "verbose"
    ],
    "_do": [
      "self",
      "random_state"
    ]
  },
  "calc_dist_to_others": [
    "x",
    "X"
  ],
  "calc_dist_to_others_with_gradient": [
    "x",
    "X"
  ],
  "ConstructionBasedReferenceDirectionFactory": {
    "__init__": [
      "self",
      "n_dim",
      "n_points",
      "n_samples",
      "gradient_descent",
      "verbose"
    ],
    "_do": [
      "self",
      "random_state"
    ],
    "next": [
      "self"
    ]
  },
  "GradientDescent": {
    "__init__": [
      "self",
      "learning_rate"
    ],
    "_next": [
      "self",
      "X",
      "dX"
    ]
  },
  "Adam": {
    "__init__": [
      "self",
      "alpha",
      "beta_1",
      "beta_2",
      "epsilon"
    ],
    "_next": [
      "self",
      "X",
      "dX"
    ]
  },
  "naive_non_dominated_sort": [
    "F"
  ],
  "NonDominatedSorting": {
    "__init__": [
      "self",
      "epsilon",
      "method",
      "dominator"
    ],
    "do": [
      "self",
      "F",
      "return_rank",
      "only_non_dominated_front",
      "n_stop_if_ranked",
      "n_fronts"
    ]
  },
  "rank_from_fronts": [
    "fronts",
    "n"
  ],
  "PCP": {
    "__init__": [
      "self",
      "bounds",
      "show_bounds",
      "n_ticks",
      "normalize_each_axis",
      "bbox"
    ],
    "_do": [
      "self"
    ]
  },
  "FitnessLandscape": {
    "__init__": [
      "self",
      "problem",
      "_type",
      "n_samples",
      "colorbar",
      "contour_levels",
      "kwargs_surface",
      "kwargs_contour",
      "kwargs_contour_labels"
    ],
    "_do": [
      "self"
    ]
  },
  "is_available": [],
  "Petal": {
    "__init__": [
      "self",
      "bounds"
    ],
    "_plot": [
      "self",
      "ax",
      "F"
    ],
    "_do": [
      "self"
    ]
  },
  "Heatmap": {
    "__init__": [
      "self",
      "cmap",
      "order_by_objectives",
      "reverse",
      "solution_labels"
    ],
    "_do": [
      "self"
    ]
  },
  "StarCoordinate": {
    "__init__": [
      "self",
      "axis_extension"
    ],
    "_do": [
      "self"
    ]
  },
  "get_circle_points": [
    "n_points"
  ],
  "default_number_to_text": [
    "val"
  ],
  "in_notebook": [],
  "get_uniform_points_around_circle": [
    "n"
  ],
  "plot_circle": [
    "ax",
    "center",
    "radius"
  ],
  "plot_radar_line": [
    "ax",
    "x"
  ],
  "plot_axes_arrow": [
    "ax",
    "X",
    "extend_factor"
  ],
  "plot_axes_lines": [
    "ax",
    "X",
    "extend_factor"
  ],
  "plot_polygon": [
    "ax",
    "x"
  ],
  "plot_axis_labels": [
    "ax",
    "endpoints",
    "labels",
    "margin",
    "size"
  ],
  "equal_axis": [
    "ax"
  ],
  "no_ticks": [
    "ax"
  ],
  "parse_bounds": [
    "bounds",
    "n_dim"
  ],
  "radviz_pandas": [
    "F"
  ],
  "plot": [],
  "plot_3d": [],
  "plot_2d": [],
  "animate": [
    "path_to_file",
    "H",
    "problem",
    "func_iter",
    "plot_min",
    "plot_max"
  ],
  "plot_problem_surface": [
    "problem",
    "n_samples",
    "plot_type",
    "cmap",
    "show",
    "return_figure"
  ],
  "Radviz": {
    "__init__": [
      "self",
      "endpoint_style"
    ],
    "_do": [
      "self"
    ]
  },
  "Radar": {
    "__init__": [
      "self",
      "normalize_each_objective",
      "n_partitions",
      "point_style"
    ],
    "_plot": [
      "self",
      "ax",
      "_F",
      "inner",
      "outer",
      "kwargs"
    ],
    "_do": [
      "self"
    ]
  },
  "plot_1d": [
    "sc"
  ],
  "plot_pairwise": [
    "sc"
  ],
  "Scatter": {
    "__init__": [
      "self",
      "plot_3d",
      "angle"
    ],
    "_do": [
      "self"
    ]
  },
  "PSOAnimation": {
    "__init__": [
      "self",
      "nth_gen",
      "n_samples_for_surface",
      "dpi"
    ],
    "do": [
      "self",
      "problem",
      "algorithm"
    ]
  },
  "OneVariableOneObjectiveVisualization": {
    "__init__": [
      "self",
      "n_samples_for_surface"
    ],
    "do": [
      "self",
      "problem",
      "algorithm"
    ]
  },
  "TwoVariablesOneObjectiveVisualization": {
    "__init__": [
      "self",
      "n_samples_for_surface"
    ],
    "do": [
      "self",
      "problem",
      "algorithm"
    ]
  },
  "AnimationCallback": {
    "__init__": [
      "self",
      "do_show",
      "do_close",
      "nth_gen",
      "dpi",
      "recorder",
      "fname",
      "exception_if_not_applicable"
    ],
    "update": [
      "self",
      "algorithm"
    ],
    "do": [
      "self",
      "problem",
      "algorithm"
    ]
  },
  "ObjectiveSpaceAnimation": {
    "__init__": [
      "self",
      "recorder"
    ],
    "update": [
      "self",
      "algorithm"
    ]
  }
}