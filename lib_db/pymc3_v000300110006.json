{
  "VarName": [],
  "ModelGraph": {
    "__init__": [
      "self",
      "model"
    ],
    "get_deterministics": [
      "self",
      "var"
    ],
    "_get_ancestors": [
      "self",
      "var",
      "func"
    ],
    "_filter_parents": [
      "self",
      "var",
      "parents"
    ],
    "get_parents": [
      "self",
      "var"
    ],
    "make_compute_graph": [
      "self"
    ],
    "_make_node": [
      "self",
      "var_name",
      "graph"
    ],
    "get_plates": [
      "self"
    ],
    "make_graph": [
      "self",
      "formatting"
    ]
  },
  "model_to_graphviz": [
    "model"
  ],
  "logger": [],
  "ParallelSamplingError": {
    "__init__": [
      "self",
      "message",
      "chain",
      "warnings"
    ]
  },
  "RemoteTraceback": {
    "__init__": [
      "self",
      "tb"
    ],
    "__str__": [
      "self"
    ]
  },
  "ExceptionWithTraceback": {
    "__init__": [
      "self",
      "exc",
      "tb"
    ],
    "__reduce__": [
      "self"
    ]
  },
  "rebuild_exc": [
    "exc",
    "tb"
  ],
  "_Process": {
    "__init__": [
      "self",
      "name",
      "msg_pipe",
      "step_method",
      "step_method_is_pickled",
      "shared_point",
      "draws",
      "tune",
      "seed",
      "pickle_backend"
    ],
    "_unpickle_step_method": [
      "self"
    ],
    "run": [
      "self"
    ],
    "_wait_for_abortion": [
      "self"
    ],
    "_make_numpy_refs": [
      "self"
    ],
    "_write_point": [
      "self",
      "point"
    ],
    "_recv_msg": [
      "self"
    ],
    "_start_loop": [
      "self"
    ],
    "_compute_point": [
      "self"
    ],
    "_collect_warnings": [
      "self"
    ]
  },
  "_run_process": [],
  "ProcessAdapter": {
    "__init__": [
      "self",
      "draws",
      "tune",
      "step_method",
      "step_method_pickled",
      "chain",
      "seed",
      "start",
      "mp_ctx",
      "pickle_backend"
    ],
    "shared_point_view": [
      "self"
    ],
    "_send": [
      "self",
      "msg"
    ],
    "start": [
      "self"
    ],
    "write_next": [
      "self"
    ],
    "abort": [
      "self"
    ],
    "join": [
      "self",
      "timeout"
    ],
    "terminate": [
      "self"
    ],
    "recv_draw": [
      "processes",
      "timeout"
    ],
    "terminate_all": [
      "processes",
      "patience"
    ]
  },
  "Draw": [],
  "ParallelSampler": {
    "__init__": [
      "self",
      "draws",
      "tune",
      "chains",
      "cores",
      "seeds",
      "start_points",
      "step_method",
      "start_chain_num",
      "progressbar",
      "mp_ctx",
      "pickle_backend"
    ],
    "_make_active": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "_cpu_count": [],
  "kronecker": [],
  "cartesian": [],
  "kron_matrix_op": [
    "krons",
    "m",
    "op"
  ],
  "kron_dot": [],
  "kron_solve_lower": [],
  "kron_solve_upper": [],
  "flat_outer": [
    "a",
    "b"
  ],
  "kron_diag": [],
  "tround": [],
  "logsumexp": [
    "x",
    "axis",
    "keepdims"
  ],
  "logaddexp": [
    "a",
    "b"
  ],
  "logdiffexp": [
    "a",
    "b"
  ],
  "logdiffexp_numpy": [
    "a",
    "b"
  ],
  "invlogit": [
    "x",
    "eps"
  ],
  "logbern": [
    "log_p"
  ],
  "logit": [
    "p"
  ],
  "log1pexp": [
    "x"
  ],
  "log1mexp": [
    "x"
  ],
  "log1mexp_numpy": [
    "x"
  ],
  "flatten_list": [
    "tensors"
  ],
  "LogDet": {
    "make_node": [
      "self",
      "x"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "outputs",
      "params"
    ],
    "grad": [
      "self",
      "inputs",
      "g_outputs"
    ],
    "__str__": [
      "self"
    ]
  },
  "logdet": [],
  "probit": [
    "p"
  ],
  "invprobit": [
    "x"
  ],
  "expand_packed_triangular": [
    "n",
    "packed",
    "lower",
    "diagonal_only"
  ],
  "BatchedDiag": {
    "__props__": [],
    "make_node": [
      "self",
      "diag"
    ],
    "perform": [
      "self",
      "node",
      "ins",
      "outs",
      "params"
    ],
    "grad": [
      "self",
      "inputs",
      "gout"
    ],
    "infer_shape": [
      "self",
      "fgraph",
      "nodes",
      "shapes"
    ]
  },
  "batched_diag": [
    "C"
  ],
  "BlockDiagonalMatrix": {
    "__props__": [],
    "__init__": [
      "self",
      "sparse",
      "format"
    ],
    "make_node": [
      "self"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "output_storage",
      "params"
    ],
    "grad": [
      "self",
      "inputs",
      "gout"
    ],
    "infer_shape": [
      "self",
      "fgraph",
      "nodes",
      "shapes"
    ]
  },
  "block_diagonal": [
    "matrices",
    "sparse",
    "format"
  ],
  "__all__": [],
  "STEP_METHODS": [],
  "Step": [],
  "ArrayLike": [],
  "PointType": [],
  "PointList": [],
  "Backend": [],
  "_log": [],
  "instantiate_steppers": [
    "_model",
    "steps",
    "selected_steps",
    "step_kwargs"
  ],
  "assign_step_methods": [
    "model",
    "step",
    "methods",
    "step_kwargs"
  ],
  "_print_step_hierarchy": [
    "s",
    "level"
  ],
  "sample": [
    "draws",
    "step",
    "init",
    "n_init",
    "initvals",
    "trace",
    "chain_idx",
    "chains",
    "cores",
    "tune",
    "progressbar",
    "model",
    "random_seed",
    "discard_tuned_samples",
    "compute_convergence_checks",
    "callback",
    "jitter_max_retries"
  ],
  "_check_start_shape": [
    "model",
    "start"
  ],
  "_sample_many": [
    "draws",
    "chain",
    "chains",
    "start",
    "random_seed",
    "step",
    "callback"
  ],
  "_sample_population": [
    "draws",
    "chain",
    "chains",
    "start",
    "random_seed",
    "step",
    "tune",
    "model",
    "progressbar",
    "parallelize"
  ],
  "_sample": [
    "chain",
    "progressbar",
    "random_seed",
    "start",
    "draws",
    "step",
    "trace",
    "tune",
    "model",
    "callback"
  ],
  "iter_sample": [
    "draws",
    "step",
    "start",
    "trace",
    "chain",
    "tune",
    "model",
    "random_seed",
    "callback"
  ],
  "_iter_sample": [
    "draws",
    "step",
    "start",
    "trace",
    "chain",
    "tune",
    "model",
    "random_seed",
    "callback"
  ],
  "PopulationStepper": {
    "__init__": [
      "self",
      "steppers",
      "parallelize",
      "progressbar"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "_run_secondary": [
      "c",
      "stepper_dumps",
      "secondary_end"
    ],
    "step": [
      "self",
      "tune_stop",
      "population"
    ]
  },
  "_prepare_iter_population": [
    "draws",
    "chains",
    "step",
    "start",
    "parallelize",
    "tune",
    "model",
    "random_seed",
    "progressbar"
  ],
  "_iter_population": [
    "draws",
    "tune",
    "popstep",
    "steppers",
    "traces",
    "points"
  ],
  "_choose_backend": [
    "trace",
    "chain"
  ],
  "_mp_sample": [
    "draws",
    "tune",
    "step",
    "chains",
    "cores",
    "chain",
    "random_seed",
    "start",
    "progressbar",
    "trace",
    "model",
    "callback",
    "discard_tuned_samples",
    "mp_ctx",
    "pickle_backend"
  ],
  "_choose_chains": [
    "traces",
    "tune"
  ],
  "stop_tuning": [
    "step"
  ],
  "_DefaultTrace": {
    "__init__": [
      "self",
      "samples"
    ],
    "insert": [
      "self",
      "k",
      "v",
      "idx"
    ]
  },
  "sample_posterior_predictive": [
    "trace",
    "samples",
    "model",
    "var_names",
    "size",
    "keep_size",
    "random_seed",
    "progressbar"
  ],
  "sample_posterior_predictive_w": [
    "traces",
    "samples",
    "models",
    "weights",
    "random_seed",
    "progressbar"
  ],
  "sample_prior_predictive": [
    "samples",
    "model",
    "var_names",
    "random_seed"
  ],
  "_init_jitter": [
    "model",
    "chains",
    "jitter_max_retries"
  ],
  "init_nuts": [
    "init",
    "chains",
    "n_init",
    "model",
    "random_seed",
    "progressbar",
    "jitter_max_retries"
  ],
  "logp": [
    "rv",
    "value"
  ],
  "inputvars": [
    "a"
  ],
  "cont_inputs": [
    "f"
  ],
  "floatX": [
    "X"
  ],
  "_conversion_map": [],
  "intX": [
    "X"
  ],
  "smartfloatX": [
    "x"
  ],
  "gradient1": [
    "f",
    "v"
  ],
  "empty_gradient": [],
  "gradient": [
    "f",
    "vars"
  ],
  "jacobian1": [
    "f",
    "v"
  ],
  "jacobian": [
    "f",
    "vars"
  ],
  "jacobian_diag": [
    "f",
    "x"
  ],
  "hessian": [
    "f",
    "vars"
  ],
  "hessian_diag1": [
    "f",
    "v"
  ],
  "hessian_diag": [
    "f",
    "vars"
  ],
  "makeiter": [
    "a"
  ],
  "IdentityOp": {
    "st_impl": [
      "x"
    ],
    "impl": [
      "self",
      "x"
    ],
    "grad": [
      "self",
      "inp",
      "grads"
    ],
    "c_code": [
      "self",
      "node",
      "name",
      "inp",
      "out",
      "sub"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "make_shared_replacements": [
    "vars",
    "model"
  ],
  "join_nonshared_inputs": [
    "xs",
    "vars",
    "shared",
    "make_shared"
  ],
  "reshape_t": [
    "x",
    "shape"
  ],
  "CallableTensor": {
    "__init__": [
      "self",
      "tensor"
    ],
    "__call__": [
      "self",
      "input"
    ]
  },
  "scalar_identity": [],
  "identity": [],
  "GeneratorOp": {
    "__props__": [],
    "__init__": [
      "self",
      "gen",
      "default"
    ],
    "make_node": [
      "self"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "output_storage",
      "params"
    ],
    "do_constant_folding": [
      "self",
      "fgraph",
      "node"
    ],
    "__call__": [],
    "set_gen": [
      "self",
      "gen"
    ],
    "set_default": [
      "self",
      "value"
    ]
  },
  "generator": [
    "gen",
    "default"
  ],
  "_tt_rng": [],
  "tt_rng": [
    "random_seed"
  ],
  "set_tt_rng": [
    "new_rng"
  ],
  "floatX_array": [
    "x"
  ],
  "ix_": [],
  "largest_common_dtype": [
    "tensors"
  ],
  "_make_along_axis_idx": [
    "arr_shape",
    "indices",
    "axis"
  ],
  "take_along_axis": [
    "arr",
    "indices",
    "axis"
  ],
  "VarMap": [],
  "DataMap": [],
  "ArrayOrdering": {
    "__init__": [
      "self",
      "vars"
    ],
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "DictToArrayBijection": {
    "__init__": [
      "self",
      "ordering",
      "dpoint"
    ],
    "map": [
      "self",
      "dpt"
    ],
    "rmap": [
      "self",
      "apt"
    ],
    "mapf": [
      "self",
      "f"
    ]
  },
  "ListArrayOrdering": {
    "__init__": [
      "self",
      "list_arrays",
      "intype"
    ]
  },
  "ListToArrayBijection": {
    "__init__": [
      "self",
      "ordering",
      "list_arrays"
    ],
    "fmap": [
      "self",
      "list_arrays"
    ],
    "dmap": [
      "self",
      "dpt"
    ],
    "rmap": [
      "self",
      "array"
    ]
  },
  "DictToVarBijection": {
    "__init__": [
      "self",
      "var",
      "idx",
      "dpoint"
    ],
    "map": [
      "self",
      "dpt"
    ],
    "rmap": [
      "self",
      "apt"
    ],
    "mapf": [
      "self",
      "f"
    ]
  },
  "Compose": {
    "__init__": [
      "self",
      "fa",
      "fb"
    ],
    "__call__": [
      "self",
      "x"
    ]
  },
  "__version__": [],
  "_check_backend_version": [],
  "__set_compiler_flags": [],
  "_hotfix_theano_printing": [],
  "LATEX_ESCAPE_RE": [],
  "escape_latex": [
    "strng"
  ],
  "get_transformed_name": [
    "name",
    "transform"
  ],
  "is_transformed_name": [
    "name"
  ],
  "get_untransformed_name": [
    "name"
  ],
  "get_default_varnames": [
    "var_iterator",
    "include_transformed"
  ],
  "get_repr_for_variable": [
    "variable",
    "formatting"
  ],
  "get_var_name": [
    "var"
  ],
  "update_start_vals": [
    "a",
    "b",
    "model"
  ],
  "check_start_vals": [
    "start",
    "model"
  ],
  "get_transformed": [
    "z"
  ],
  "biwrap": [
    "wrapper"
  ],
  "dataset_to_point_dict": [
    "ds"
  ],
  "dataset_to_point_list": [
    "ds"
  ],
  "chains_and_samples": [
    "data"
  ],
  "hashable": [
    "a"
  ],
  "hash_key": [],
  "HashableWrapper": {
    "__slots__": [],
    "__init__": [
      "self",
      "obj"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "WithMemoization": {
    "__hash__": [
      "self"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "locally_cachedmethod": [
    "f"
  ],
  "FlatView": [],
  "PyMC3Variable": {
    "__matmul__": [],
    "__rmatmul__": [
      "self",
      "other"
    ],
    "_str_repr": [
      "self",
      "name",
      "dist",
      "formatting"
    ],
    "_repr_latex_": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__latex__": []
  },
  "InstanceMethod": {
    "__init__": [
      "self",
      "obj",
      "method_name"
    ],
    "__call__": [
      "self"
    ]
  },
  "incorporate_methods": [
    "source",
    "destination",
    "methods",
    "wrapper",
    "override"
  ],
  "get_named_nodes_and_relations": [
    "graph"
  ],
  "_get_named_nodes_and_relations": [
    "graph",
    "descendent",
    "descendents",
    "ancestors"
  ],
  "build_named_node_tree": [
    "graphs"
  ],
  "T": [],
  "ContextMeta": {
    "__new__": [
      "cls",
      "name",
      "bases",
      "dct"
    ],
    "__init__": [
      "cls",
      "name",
      "bases",
      "nmspc",
      "context_class"
    ],
    "get_context": [
      "cls",
      "error_if_none"
    ],
    "get_contexts": [
      "cls"
    ],
    "context_class": [
      "cls"
    ],
    "__init_subclass__": [
      "cls"
    ],
    "__call__": [
      "cls"
    ]
  },
  "modelcontext": [
    "model"
  ],
  "Factor": {
    "__init__": [
      "self"
    ],
    "logp": [
      "self"
    ],
    "logp_elemwise": [
      "self"
    ],
    "dlogp": [
      "self",
      "vars"
    ],
    "d2logp": [
      "self",
      "vars"
    ],
    "logp_nojac": [
      "self"
    ],
    "dlogp_nojac": [
      "self",
      "vars"
    ],
    "d2logp_nojac": [
      "self",
      "vars"
    ],
    "fastlogp": [
      "self"
    ],
    "fastdlogp": [
      "self",
      "vars"
    ],
    "fastd2logp": [
      "self",
      "vars"
    ],
    "fastlogp_nojac": [
      "self"
    ],
    "fastdlogp_nojac": [
      "self",
      "vars"
    ],
    "fastd2logp_nojac": [
      "self",
      "vars"
    ],
    "logpt": [
      "self"
    ],
    "logp_nojact": [
      "self"
    ]
  },
  "withparent": [
    "meth"
  ],
  "treelist": {
    "__init__": [
      "self",
      "iterable",
      "parent"
    ],
    "append": [],
    "__iadd__": [],
    "extend": [],
    "tree_contains": [
      "self",
      "item"
    ],
    "__setitem__": [
      "self",
      "key",
      "value"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__imul__": [
      "self",
      "other"
    ]
  },
  "treedict": {
    "__init__": [
      "self",
      "iterable",
      "parent"
    ],
    "__setitem__": [],
    "update": [],
    "tree_contains": [
      "self",
      "item"
    ]
  },
  "ValueGradFunction": {
    "__init__": [
      "self",
      "costs",
      "grad_vars",
      "extra_vars"
    ],
    "set_weights": [
      "self",
      "values"
    ],
    "set_extra_values": [
      "self",
      "extra_vars"
    ],
    "get_extra_values": [
      "self"
    ],
    "__call__": [
      "self",
      "array",
      "grad_out",
      "extra_vars"
    ],
    "profile": [
      "self"
    ],
    "dict_to_array": [
      "self",
      "point"
    ],
    "array_to_dict": [
      "self",
      "array"
    ],
    "array_to_full_dict": [
      "self",
      "array"
    ],
    "_build_joined": [
      "self",
      "cost",
      "args",
      "vmap"
    ]
  },
  "Model": {
    "__new__": [
      "cls"
    ],
    "__init__": [
      "self",
      "name",
      "model",
      "theano_config",
      "coords",
      "check_bounds"
    ],
    "model": [
      "self"
    ],
    "parent": [
      "self"
    ],
    "root": [
      "self"
    ],
    "isroot": [
      "self"
    ],
    "bijection": [
      "self"
    ],
    "dict_to_array": [
      "self"
    ],
    "ndim": [
      "self"
    ],
    "logp_array": [
      "self"
    ],
    "dlogp_array": [
      "self"
    ],
    "logp_dlogp_function": [
      "self",
      "grad_vars",
      "tempered"
    ],
    "logpt": [
      "self"
    ],
    "logp_nojact": [
      "self"
    ],
    "varlogpt": [
      "self"
    ],
    "datalogpt": [
      "self"
    ],
    "vars": [
      "self"
    ],
    "basic_RVs": [
      "self"
    ],
    "unobserved_RVs": [
      "self"
    ],
    "test_point": [
      "self"
    ],
    "disc_vars": [
      "self"
    ],
    "cont_vars": [
      "self"
    ],
    "shape_from_dims": [
      "self",
      "dims"
    ],
    "add_coords": [
      "self",
      "coords"
    ],
    "Var": [
      "self",
      "name",
      "dist",
      "data",
      "total_size",
      "dims"
    ],
    "add_random_variable": [
      "self",
      "var",
      "dims"
    ],
    "prefix": [
      "self"
    ],
    "name_for": [
      "self",
      "name"
    ],
    "name_of": [
      "self",
      "name"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "makefn": [
      "self",
      "outs",
      "mode"
    ],
    "fn": [
      "self",
      "outs",
      "mode"
    ],
    "fastfn": [
      "self",
      "outs",
      "mode"
    ],
    "profile": [
      "self",
      "outs",
      "n",
      "point",
      "profile"
    ],
    "flatten": [
      "self",
      "vars",
      "order",
      "inputvar"
    ],
    "check_test_point": [
      "self",
      "test_point",
      "round_vals"
    ],
    "_str_repr": [
      "self",
      "formatting"
    ],
    "__str__": [
      "self"
    ],
    "_repr_latex_": [
      "self"
    ],
    "__latex__": []
  },
  "set_data": [
    "new_data",
    "model"
  ],
  "fn": [
    "outs",
    "mode",
    "model"
  ],
  "fastfn": [
    "outs",
    "mode",
    "model"
  ],
  "Point": [],
  "FastPointFunc": {
    "__init__": [
      "self",
      "f"
    ],
    "__call__": [
      "self",
      "state"
    ]
  },
  "LoosePointFunc": {
    "__init__": [
      "self",
      "f",
      "model"
    ],
    "__call__": [
      "self"
    ]
  },
  "compilef": [],
  "_get_scaling": [
    "total_size",
    "shape",
    "ndim"
  ],
  "FreeRV": {
    "dshape": [],
    "size": [],
    "distribution": [],
    "model": [],
    "__init__": [
      "self",
      "type",
      "owner",
      "index",
      "name",
      "distribution",
      "total_size",
      "model"
    ],
    "init_value": [
      "self"
    ]
  },
  "pandas_to_array": [
    "data"
  ],
  "as_tensor": [
    "data",
    "name",
    "model",
    "distribution"
  ],
  "ObservedRV": {
    "__init__": [
      "self",
      "type",
      "owner",
      "index",
      "name",
      "data",
      "distribution",
      "total_size",
      "model"
    ],
    "init_value": [
      "self"
    ]
  },
  "MultiObservedRV": {
    "__init__": [
      "self",
      "name",
      "data",
      "distribution",
      "total_size",
      "model"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "_walk_up_rv": [
    "rv",
    "formatting"
  ],
  "DeterministicWrapper": {
    "_str_repr": [
      "self",
      "formatting"
    ],
    "_repr_latex_": [
      "self"
    ],
    "__latex__": [],
    "__str__": [
      "self"
    ]
  },
  "Deterministic": [
    "name",
    "var",
    "model",
    "dims"
  ],
  "Potential": [
    "name",
    "var",
    "model"
  ],
  "TransformedRV": {
    "__init__": [
      "self",
      "type",
      "owner",
      "index",
      "name",
      "distribution",
      "model",
      "transform",
      "total_size"
    ],
    "init_value": [
      "self"
    ]
  },
  "as_iterargs": [
    "data"
  ],
  "all_continuous": [
    "vars"
  ],
  "SamplingError": {},
  "IncorrectArgumentsError": {},
  "TraceDirectoryError": {},
  "ImputationWarning": {},
  "ShapeError": {
    "__init__": [
      "self",
      "message",
      "actual",
      "expected"
    ]
  },
  "DtypeError": {
    "__init__": [
      "self",
      "message",
      "actual",
      "expected"
    ]
  },
  "bool_types": [],
  "int_types": [],
  "float_types": [],
  "complex_types": [],
  "continuous_types": [],
  "discrete_types": [],
  "string_types": [],
  "typefilter": [
    "vars",
    "types"
  ],
  "isgenerator": [
    "obj"
  ],
  "theano_constant": [],
  "BASE_URL": [],
  "get_data": [
    "filename"
  ],
  "GenTensorVariable": {
    "__init__": [
      "self",
      "op",
      "type",
      "name"
    ],
    "set_gen": [
      "self",
      "gen"
    ],
    "set_default": [
      "self",
      "value"
    ],
    "clone": [
      "self"
    ]
  },
  "GeneratorAdapter": {
    "make_variable": [
      "self",
      "gop",
      "name"
    ],
    "__init__": [
      "self",
      "generator"
    ],
    "__next__": [
      "self"
    ],
    "next": [],
    "__iter__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "Minibatch": {
    "RNG": [],
    "__init__": [
      "self",
      "data",
      "batch_size",
      "dtype",
      "broadcastable",
      "name",
      "random_seed",
      "update_shared_f",
      "in_memory_size"
    ],
    "rslice": [
      "self",
      "total",
      "size",
      "seed"
    ],
    "__del__": [
      "self"
    ],
    "make_static_slices": [
      "user_size"
    ],
    "make_random_slices": [
      "self",
      "in_memory_shape",
      "batch_size",
      "default_random_seed"
    ],
    "update_shared": [
      "self"
    ],
    "set_value": [
      "self",
      "value"
    ],
    "clone": [
      "self"
    ]
  },
  "align_minibatches": [
    "batches"
  ],
  "Data": {
    "__new__": [
      "self",
      "name",
      "value"
    ],
    "set_coords": [
      "model",
      "value",
      "dims"
    ]
  },
  "CompoundStep": {
    "__init__": [
      "self",
      "methods"
    ],
    "step": [
      "self",
      "point"
    ],
    "warnings": [
      "self"
    ],
    "stop_tuning": [
      "self"
    ],
    "reset_tuning": [
      "self"
    ],
    "vars_shape_dtype": [
      "self"
    ]
  },
  "EXPERIMENTAL_WARNING": [],
  "_value_error": [
    "cond",
    "str"
  ],
  "_check_minibatches": [
    "minibatch_tensors",
    "minibatches"
  ],
  "prior_dlogp": [
    "vars",
    "model",
    "flat_view"
  ],
  "elemwise_dlogL": [
    "vars",
    "model",
    "flat_view"
  ],
  "BaseStochasticGradient": {
    "__init__": [
      "self",
      "vars",
      "batch_size",
      "total_size",
      "step_size",
      "model",
      "random_seed",
      "minibatches",
      "minibatch_tensors"
    ],
    "_initialize_values": [
      "self"
    ],
    "mk_training_fn": [
      "self"
    ],
    "training_complete": [
      "self"
    ],
    "astep": [
      "self",
      "q0"
    ]
  },
  "MetropolisMLDA": {
    "name": [],
    "__init__": [
      "self"
    ],
    "reset_tuning": [
      "self"
    ],
    "astep": [
      "self",
      "q0"
    ]
  },
  "DEMetropolisZMLDA": {
    "name": [],
    "__init__": [
      "self"
    ],
    "reset_tuning": [
      "self"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "stop_tuning": [
      "self"
    ]
  },
  "MLDA": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "__init__": [
      "self",
      "coarse_models",
      "vars",
      "base_sampler",
      "base_S",
      "base_proposal_dist",
      "base_scaling",
      "tune",
      "base_tune_target",
      "base_tune_interval",
      "base_lamb",
      "base_tune_drop_fraction",
      "model",
      "mode",
      "subsampling_rates",
      "base_blocked",
      "variance_reduction",
      "store_Q_fine",
      "adaptive_error_model"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "update_vr_variables": [
      "self",
      "accepted",
      "skipped_logp"
    ],
    "update_error_estimate": [
      "self",
      "accepted",
      "skipped_logp"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "RecursiveSampleMoments": {
    "__init__": [
      "self",
      "mu_0",
      "sigma_0",
      "t"
    ],
    "__call__": [
      "self"
    ],
    "get_mu": [
      "self"
    ],
    "get_sigma": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "delta_logp_inverse": [
    "logp",
    "vars",
    "shared"
  ],
  "extract_Q_estimate": [
    "trace",
    "levels"
  ],
  "subsample": [
    "draws",
    "step",
    "start",
    "trace",
    "tune",
    "model",
    "random_seed",
    "callback"
  ],
  "RecursiveDAProposal": {
    "__init__": [
      "self",
      "step_method_below",
      "model_below",
      "tune",
      "subsampling_rate"
    ],
    "__call__": [
      "self",
      "q0_dict"
    ]
  },
  "ElemwiseCategorical": {
    "__init__": [
      "self",
      "vars",
      "values",
      "model"
    ],
    "astep": [
      "self",
      "q",
      "logp"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "elemwise_logp": [
    "model",
    "var"
  ],
  "categorical": [
    "prob",
    "shape"
  ],
  "PGBART": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "num_particles",
      "max_stages",
      "chunk",
      "model"
    ],
    "astep": [
      "self",
      "_"
    ],
    "competence": [
      "var",
      "has_grad"
    ],
    "normalize": [
      "self",
      "particles"
    ],
    "get_old_tree_particle": [
      "self",
      "tree_id",
      "t"
    ],
    "init_particles": [
      "self",
      "tree_id"
    ],
    "resample": [
      "self",
      "particles",
      "weights"
    ]
  },
  "ParticleTree": {
    "__init__": [
      "self",
      "tree",
      "prior_prob_leaf_node",
      "log_weight",
      "likelihood"
    ],
    "sample_tree_sequential": [
      "self",
      "bart"
    ],
    "set_particle_to_step": [
      "self",
      "t"
    ]
  },
  "Competence": {
    "INCOMPATIBLE": [],
    "COMPATIBLE": [],
    "PREFERRED": [],
    "IDEAL": []
  },
  "BlockedStep": {
    "generates_stats": [],
    "__new__": [
      "cls"
    ],
    "__getnewargs_ex__": [
      "self"
    ],
    "competence": [
      "var",
      "has_grad"
    ],
    "_competence": [
      "cls",
      "vars",
      "have_grad"
    ],
    "vars_shape_dtype": [
      "self"
    ],
    "stop_tuning": [
      "self"
    ]
  },
  "ArrayStep": {
    "__init__": [
      "self",
      "vars",
      "fs",
      "allvars",
      "blocked"
    ],
    "step": [
      "self",
      "point"
    ]
  },
  "ArrayStepShared": {
    "__init__": [
      "self",
      "vars",
      "shared",
      "blocked"
    ],
    "step": [
      "self",
      "point"
    ]
  },
  "PopulationArrayStepShared": {
    "__init__": [
      "self",
      "vars",
      "shared",
      "blocked"
    ],
    "link_population": [
      "self",
      "population",
      "chain_index"
    ]
  },
  "GradientSharedStep": {
    "__init__": [
      "self",
      "vars",
      "model",
      "blocked",
      "dtype",
      "logp_dlogp_func"
    ],
    "step": [
      "self",
      "point"
    ]
  },
  "metrop_select": [
    "mr",
    "q",
    "q0"
  ],
  "Proposal": {
    "__init__": [
      "self",
      "s"
    ]
  },
  "NormalProposal": {
    "__call__": [
      "self"
    ]
  },
  "UniformProposal": {
    "__call__": [
      "self"
    ]
  },
  "CauchyProposal": {
    "__call__": [
      "self"
    ]
  },
  "LaplaceProposal": {
    "__call__": [
      "self"
    ]
  },
  "PoissonProposal": {
    "__call__": [
      "self"
    ]
  },
  "MultivariateNormalProposal": {
    "__init__": [
      "self",
      "s"
    ],
    "__call__": [
      "self",
      "num_draws"
    ]
  },
  "Metropolis": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "S",
      "proposal_dist",
      "scaling",
      "tune",
      "tune_interval",
      "model",
      "mode"
    ],
    "reset_tuning": [
      "self"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "tune": [
    "scale",
    "acc_rate"
  ],
  "BinaryMetropolis": {
    "name": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "scaling",
      "tune",
      "tune_interval",
      "model"
    ],
    "astep": [
      "self",
      "q0",
      "logp"
    ],
    "competence": [
      "var"
    ]
  },
  "BinaryGibbsMetropolis": {
    "name": [],
    "__init__": [
      "self",
      "vars",
      "order",
      "transit_p",
      "model"
    ],
    "astep": [
      "self",
      "q0",
      "logp"
    ],
    "competence": [
      "var"
    ]
  },
  "CategoricalGibbsMetropolis": {
    "name": [],
    "__init__": [
      "self",
      "vars",
      "proposal",
      "order",
      "model"
    ],
    "astep_unif": [
      "self",
      "q0",
      "logp"
    ],
    "astep_prop": [
      "self",
      "q0",
      "logp"
    ],
    "metropolis_proportional": [
      "self",
      "q",
      "logp",
      "logp_curr",
      "dim",
      "k"
    ],
    "competence": [
      "var"
    ]
  },
  "DEMetropolis": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "S",
      "proposal_dist",
      "lamb",
      "scaling",
      "tune",
      "tune_interval",
      "model",
      "mode"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "DEMetropolisZ": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "S",
      "proposal_dist",
      "lamb",
      "scaling",
      "tune",
      "tune_interval",
      "tune_drop_fraction",
      "model",
      "mode"
    ],
    "reset_tuning": [
      "self"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "stop_tuning": [
      "self"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "sample_except": [
    "limit",
    "excluded"
  ],
  "softmax": [
    "x"
  ],
  "delta_logp": [
    "logp",
    "vars",
    "shared"
  ],
  "get_chol": [
    "cov",
    "chol"
  ],
  "EllipticalSlice": {
    "default_blocked": [],
    "__init__": [
      "self",
      "vars",
      "prior_cov",
      "prior_chol",
      "model"
    ],
    "astep": [
      "self",
      "q0",
      "logp"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "DualAverageAdaptation": {
    "__init__": [
      "self",
      "initial_step",
      "target",
      "gamma",
      "k",
      "t0"
    ],
    "reset": [
      "self"
    ],
    "current": [
      "self",
      "tune"
    ],
    "update": [
      "self",
      "accept_stat",
      "tune"
    ],
    "stats": [
      "self"
    ],
    "warnings": [
      "self"
    ]
  },
  "LOOP_ERR_MSG": [],
  "Slice": {
    "name": [],
    "default_blocked": [],
    "__init__": [
      "self",
      "vars",
      "w",
      "tune",
      "model",
      "iter_limit"
    ],
    "astep": [
      "self",
      "q0",
      "logp"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "quad_potential": [
    "C",
    "is_cov"
  ],
  "partial_check_positive_definite": [
    "C"
  ],
  "PositiveDefiniteError": {
    "__init__": [
      "self",
      "msg",
      "idx"
    ],
    "__str__": [
      "self"
    ]
  },
  "QuadPotential": {
    "velocity": [
      "self",
      "x",
      "out"
    ],
    "energy": [
      "self",
      "x",
      "velocity"
    ],
    "random": [
      "self",
      "x"
    ],
    "velocity_energy": [
      "self",
      "x",
      "v_out"
    ],
    "update": [
      "self",
      "sample",
      "grad",
      "tune"
    ],
    "raise_ok": [
      "self",
      "vmap"
    ],
    "reset": [
      "self"
    ]
  },
  "isquadpotential": [
    "value"
  ],
  "QuadPotentialDiagAdapt": {
    "__init__": [
      "self",
      "n",
      "initial_mean",
      "initial_diag",
      "initial_weight",
      "adaptation_window",
      "adaptation_window_multiplier",
      "dtype"
    ],
    "reset": [
      "self"
    ],
    "velocity": [
      "self",
      "x",
      "out"
    ],
    "energy": [
      "self",
      "x",
      "velocity"
    ],
    "velocity_energy": [
      "self",
      "x",
      "v_out"
    ],
    "random": [
      "self"
    ],
    "_update_from_weightvar": [
      "self",
      "weightvar"
    ],
    "update": [
      "self",
      "sample",
      "grad",
      "tune"
    ],
    "raise_ok": [
      "self",
      "vmap"
    ]
  },
  "QuadPotentialDiagAdaptGrad": {
    "reset": [
      "self"
    ],
    "_update": [
      "self",
      "var"
    ],
    "update": [
      "self",
      "sample",
      "grad",
      "tune"
    ]
  },
  "_WeightedVariance": {
    "__init__": [
      "self",
      "nelem",
      "initial_mean",
      "initial_variance",
      "initial_weight",
      "dtype"
    ],
    "add_sample": [
      "self",
      "x",
      "weight"
    ],
    "current_variance": [
      "self",
      "out"
    ],
    "current_mean": [
      "self"
    ]
  },
  "QuadPotentialDiag": {
    "__init__": [
      "self",
      "v",
      "dtype"
    ],
    "velocity": [
      "self",
      "x",
      "out"
    ],
    "random": [
      "self"
    ],
    "energy": [
      "self",
      "x",
      "velocity"
    ],
    "velocity_energy": [
      "self",
      "x",
      "v_out"
    ]
  },
  "QuadPotentialFullInv": {
    "__init__": [
      "self",
      "A",
      "dtype"
    ],
    "velocity": [
      "self",
      "x",
      "out"
    ],
    "random": [
      "self"
    ],
    "energy": [
      "self",
      "x",
      "velocity"
    ],
    "velocity_energy": [
      "self",
      "x",
      "v_out"
    ]
  },
  "QuadPotentialFull": {
    "__init__": [
      "self",
      "cov",
      "dtype"
    ],
    "velocity": [
      "self",
      "x",
      "out"
    ],
    "random": [
      "self"
    ],
    "energy": [
      "self",
      "x",
      "velocity"
    ],
    "velocity_energy": [
      "self",
      "x",
      "v_out"
    ],
    "__call__": []
  },
  "QuadPotentialFullAdapt": {
    "__init__": [
      "self",
      "n",
      "initial_mean",
      "initial_cov",
      "initial_weight",
      "adaptation_window",
      "adaptation_window_multiplier",
      "update_window",
      "dtype"
    ],
    "reset": [
      "self"
    ],
    "_update_from_weightvar": [
      "self",
      "weightvar"
    ],
    "update": [
      "self",
      "sample",
      "grad",
      "tune"
    ],
    "raise_ok": [
      "self",
      "vmap"
    ]
  },
  "_WeightedCovariance": {
    "__init__": [
      "self",
      "nelem",
      "initial_mean",
      "initial_covariance",
      "initial_weight",
      "dtype"
    ],
    "add_sample": [
      "self",
      "x",
      "weight"
    ],
    "current_covariance": [
      "self",
      "out"
    ],
    "current_mean": [
      "self"
    ]
  },
  "HMCStepData": [],
  "DivergenceInfo": [],
  "BaseHMC": {
    "default_blocked": [],
    "__init__": [
      "self",
      "vars",
      "scaling",
      "step_scale",
      "is_cov",
      "model",
      "blocked",
      "potential",
      "dtype",
      "Emax",
      "target_accept",
      "gamma",
      "k",
      "t0",
      "adapt_step_size",
      "step_rand"
    ],
    "_hamiltonian_step": [
      "self",
      "start",
      "p0",
      "step_size"
    ],
    "astep": [
      "self",
      "q0"
    ],
    "reset_tuning": [
      "self",
      "start"
    ],
    "reset": [
      "self",
      "start"
    ],
    "warnings": [
      "self"
    ]
  },
  "unif": [
    "step_size",
    "elow",
    "ehigh"
  ],
  "HamiltonianMC": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "path_length",
      "max_steps"
    ],
    "_hamiltonian_step": [
      "self",
      "start",
      "p0",
      "step_size"
    ],
    "competence": [
      "var",
      "has_grad"
    ]
  },
  "NUTS": {
    "name": [],
    "default_blocked": [],
    "generates_stats": [],
    "stats_dtypes": [],
    "__init__": [
      "self",
      "vars",
      "max_treedepth",
      "early_max_treedepth"
    ],
    "_hamiltonian_step": [
      "self",
      "start",
      "p0",
      "step_size"
    ],
    "competence": [
      "var",
      "has_grad"
    ],
    "warnings": [
      "self"
    ]
  },
  "Subtree": [],
  "_Tree": {
    "__init__": [
      "self",
      "ndim",
      "integrator",
      "start",
      "step_size",
      "Emax"
    ],
    "extend": [
      "self",
      "direction"
    ],
    "_single_step": [
      "self",
      "left",
      "epsilon"
    ],
    "_build_subtree": [
      "self",
      "left",
      "depth",
      "epsilon"
    ],
    "stats": [
      "self"
    ]
  },
  "State": [],
  "IntegrationError": {},
  "CpuLeapfrogIntegrator": {
    "__init__": [
      "self",
      "potential",
      "logp_dlogp_func"
    ],
    "compute_state": [
      "self",
      "q",
      "p"
    ],
    "step": [
      "self",
      "epsilon",
      "state"
    ],
    "_step": [
      "self",
      "epsilon",
      "state"
    ]
  },
  "test_posdef_symmetric1": [],
  "test_posdef_symmetric2": [],
  "test_posdef_symmetric3": [],
  "test_posdef_symmetric4": [],
  "test_coords": [],
  "TestNUTSUniform": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestMetropolisUniform": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestSliceUniform": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestNUTSUniform2": {
    "step_args": []
  },
  "TestNUTSUniform3": {
    "step_args": []
  },
  "TestNUTSNormal": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestNUTSBetaBinomial": {
    "n_samples": [],
    "ks_thin": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": []
  },
  "TestNUTSStudentT": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestNUTSNormalLong": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": [],
    "rtol": [],
    "atol": []
  },
  "TestNUTSLKJCholeskyCov": {
    "n_samples": [],
    "tune": [],
    "burn": [],
    "chains": [],
    "min_n_eff": []
  },
  "TestLogpSyntax": {
    "test_equivalence": [
      "self"
    ],
    "test_equivalence_dist": [
      "self"
    ]
  },
  "_DataSampler": {
    "__init__": [
      "self",
      "data",
      "batchsize",
      "random_seed",
      "dtype"
    ],
    "__iter__": [
      "self"
    ],
    "__next__": [
      "self"
    ],
    "next": []
  },
  "datagen": [],
  "integers": [],
  "integers_ndim": [
    "ndim"
  ],
  "TestGenerator": {
    "test_basic": [
      "self"
    ],
    "test_ndim": [
      "self"
    ],
    "test_cloning_available": [
      "self"
    ],
    "test_default_value": [
      "self"
    ],
    "test_set_gen_and_exc": [
      "self"
    ],
    "test_pickling": [
      "self",
      "datagen"
    ],
    "test_gen_cloning_with_shape_change": [
      "self",
      "datagen"
    ]
  },
  "gen1": [],
  "gen2": [],
  "TestScaling": {
    "test_density_scaling": [
      "self"
    ],
    "test_density_scaling_with_genarator": [
      "self"
    ],
    "test_gradient_with_scaling": [
      "self"
    ],
    "test_multidim_scaling": [
      "self"
    ],
    "test_common_errors": [
      "self"
    ],
    "test_mixed1": [
      "self"
    ],
    "test_mixed2": [
      "self"
    ],
    "test_free_rv": [
      "self"
    ]
  },
  "TestMinibatch": {
    "data": [],
    "test_1d": [
      "self"
    ],
    "test_2d": [
      "self"
    ],
    "test_special1": [
      "self"
    ],
    "test_special2": [
      "self"
    ],
    "test_special3": [
      "self"
    ],
    "test_special4": [
      "self"
    ],
    "test_cloning_available": [
      "self"
    ],
    "test_align": [
      "self"
    ]
  },
  "tol": [],
  "test_logp": [],
  "test_dlogp": [],
  "test_dlogp2": [],
  "test_deterministic": [],
  "test_mapping": [],
  "test_bound": [],
  "test_check_bounds_false": [],
  "test_alltrue_scalar": [],
  "test_alltrue_shape": [],
  "MultinomialA": {
    "__init__": [
      "self",
      "n",
      "p"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "MultinomialB": {
    "__init__": [
      "self",
      "n",
      "p"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "test_multinomial_bound": [],
  "TestMvNormalLogp": {
    "test_logp": [
      "self"
    ],
    "test_grad": [
      "self"
    ],
    "test_hessian": [
      "self"
    ]
  },
  "TestSplineWrapper": {
    "test_grad": [
      "self"
    ],
    "test_hessian": [
      "self"
    ]
  },
  "TestI0e": {
    "test_grad": [
      "self"
    ]
  },
  "test_clipped_beta_rvs": [
    "dtype"
  ],
  "TestSample": {
    "setup_method": [
      "self"
    ],
    "test_sample_does_not_set_seed": [
      "self"
    ],
    "test_parallel_sample_does_not_reuse_seed": [
      "self"
    ],
    "test_sample": [
      "self"
    ],
    "test_sample_init": [
      "self"
    ],
    "test_sample_args": [
      "self"
    ],
    "test_iter_sample": [
      "self"
    ],
    "test_parallel_start": [
      "self"
    ],
    "test_sample_tune_len": [
      "self"
    ],
    "test_reset_tuning": [
      "self"
    ],
    "test_trace_report": [
      "self",
      "step_cls",
      "discard"
    ],
    "test_trace_report_bart": [
      "self"
    ],
    "test_return_inferencedata": [
      "self",
      "monkeypatch"
    ],
    "test_sampler_stat_tune": [
      "self",
      "cores"
    ],
    "test_sample_start_bad_shape": [
      "self",
      "start",
      "error"
    ],
    "test_sample_start_good_shape": [
      "self",
      "start"
    ],
    "test_sample_callback": [
      "self"
    ],
    "test_callback_can_cancel": [
      "self"
    ]
  },
  "test_sample_find_MAP_does_not_modify_start": [],
  "test_empty_model": [],
  "test_partial_trace_sample": [],
  "test_choose_chains": [
    "n_points",
    "tune",
    "expected_length",
    "expected_n_traces"
  ],
  "TestNamedSampling": {
    "test_shared_named": [
      "self"
    ],
    "test_shared_unnamed": [
      "self"
    ],
    "test_constant_named": [
      "self"
    ]
  },
  "TestChooseBackend": {
    "test_choose_backend_none": [
      "self"
    ],
    "test_choose_backend_list_of_variables": [
      "self"
    ]
  },
  "TestSamplePPC": {
    "test_normal_scalar": [
      "self"
    ],
    "test_normal_vector": [
      "self",
      "caplog"
    ],
    "test_exceptions": [
      "self",
      "caplog"
    ],
    "test_vector_observed": [
      "self"
    ],
    "test_sum_normal": [
      "self"
    ],
    "test_model_not_drawable_prior": [
      "self"
    ],
    "test_model_shared_variable": [
      "self"
    ],
    "test_deterministic_of_observed": [
      "self"
    ],
    "test_deterministic_of_observed_modified_interface": [
      "self"
    ],
    "test_variable_type": [
      "self"
    ],
    "test_potentials_warning": [
      "self"
    ]
  },
  "TestSamplePPCW": {
    "test_sample_posterior_predictive_w": [
      "self"
    ],
    "test_potentials_warning": [
      "self"
    ]
  },
  "test_exec_nuts_init": [
    "method"
  ],
  "test_default_sample_nuts_jitter": [
    "init",
    "start",
    "expectation",
    "monkeypatch"
  ],
  "test_init_jitter": [
    "testval",
    "jitter_max_retries",
    "expectation"
  ],
  "point_list_arg_bug_fixture": [],
  "TestSamplePriorPredictive": {
    "test_ignores_observed": [
      "self"
    ],
    "test_respects_shape": [
      "self"
    ],
    "test_multivariate": [
      "self"
    ],
    "test_multivariate2": [
      "self"
    ],
    "test_layers": [
      "self"
    ],
    "test_transformed": [
      "self"
    ],
    "test_shared": [
      "self"
    ],
    "test_density_dist": [
      "self"
    ],
    "test_shape_edgecase": [
      "self"
    ],
    "test_zeroinflatedpoisson": [
      "self"
    ],
    "test_bounded_dist": [
      "self"
    ],
    "test_potentials_warning": [
      "self"
    ]
  },
  "TestSamplePosteriorPredictive": {
    "test_point_list_arg_bug_fspp": [
      "self",
      "point_list_arg_bug_fixture"
    ],
    "test_point_list_arg_bug_spp": [
      "self",
      "point_list_arg_bug_fixture"
    ],
    "test_sample_from_xarray_prior": [
      "self",
      "point_list_arg_bug_fixture"
    ],
    "test_sample_from_xarray_posterior": [
      "self",
      "point_list_arg_bug_fixture"
    ],
    "test_sample_from_xarray_posterior_fast": [
      "self",
      "point_list_arg_bug_fixture"
    ]
  },
  "TestProfile": {
    "setup_method": [
      "self"
    ],
    "test_profile_model": [
      "self"
    ],
    "test_profile_variable": [
      "self"
    ],
    "test_profile_count": [
      "self"
    ]
  },
  "NewModel": {
    "__init__": [
      "self",
      "name",
      "model"
    ]
  },
  "DocstringModel": {
    "__init__": [
      "self",
      "mean",
      "sigma",
      "name",
      "model"
    ]
  },
  "TestBaseModel": {
    "test_setattr_properly_works": [
      "self"
    ],
    "test_context_passes_vars_to_parent_model": [
      "self"
    ]
  },
  "TestNested": {
    "test_nest_context_works": [
      "self"
    ],
    "test_named_context": [
      "self"
    ],
    "test_docstring_example1": [
      "self"
    ],
    "test_docstring_example2": [
      "self"
    ],
    "test_duplicates_detection": [
      "self"
    ],
    "test_model_root": [
      "self"
    ]
  },
  "TestObserved": {
    "test_observed_rv_fail": [
      "self"
    ],
    "test_observed_type": [
      "self"
    ]
  },
  "TestTheanoConfig": {
    "test_set_testval_raise": [
      "self"
    ],
    "test_nested": [
      "self"
    ]
  },
  "test_matrix_multiplication": [],
  "test_duplicate_vars": [],
  "test_empty_observed": [],
  "TestValueGradFunction": {
    "test_no_extra": [
      "self"
    ],
    "test_invalid_type": [
      "self"
    ],
    "setUp": [
      "self"
    ],
    "test_extra_not_set": [
      "self"
    ],
    "test_grad": [
      "self"
    ],
    "test_bij": [
      "self"
    ],
    "test_edge_case": [
      "self"
    ],
    "test_tensor_type_conversion": [
      "self"
    ],
    "test_theano_switch_broadcast_edge_cases": [
      "self"
    ]
  },
  "test_multiple_observed_rv": [],
  "test_tempered_logp_dlogp": [],
  "test_model_pickle": [
    "tmpdir"
  ],
  "test_model_pickle_deterministic": [
    "tmpdir"
  ],
  "test_shapes": [],
  "test_sizes": [],
  "test_to_shapes": [],
  "fixture_sizes": [
    "request"
  ],
  "fixture_shapes": [
    "request"
  ],
  "fixture_exception_handling": [
    "request"
  ],
  "samples_to_broadcast": [
    "fixture_sizes",
    "fixture_shapes"
  ],
  "samples_to_broadcast_to": [
    "request",
    "samples_to_broadcast"
  ],
  "fixture_model": [],
  "TestShapesBroadcasting": {
    "test_type_check_raises": [
      "self",
      "bad_input"
    ],
    "test_type_check_success": [
      "self"
    ],
    "test_broadcasting": [
      "self",
      "fixture_shapes",
      "fixture_exception_handling"
    ],
    "test_broadcast_dist_samples_shape": [
      "self",
      "fixture_sizes",
      "fixture_shapes"
    ]
  },
  "TestSamplesBroadcasting": {
    "test_broadcast_distribution_samples": [
      "self",
      "samples_to_broadcast"
    ],
    "test_get_broadcastable_dist_samples": [
      "self",
      "samples_to_broadcast"
    ],
    "test_broadcast_dist_samples_to": [
      "self",
      "samples_to_broadcast_to"
    ]
  },
  "test_sample_generate_values": [
    "fixture_model",
    "fixture_sizes"
  ],
  "test_leapfrog_reversible": [],
  "test_nuts_tuning": [],
  "generate_normal_mixture_data": [
    "w",
    "mu",
    "sd",
    "size"
  ],
  "generate_poisson_mixture_data": [
    "w",
    "mu",
    "size"
  ],
  "TestMixture": {
    "setup_class": [
      "cls"
    ],
    "test_dimensions": [
      "self"
    ],
    "test_mixture_list_of_normals": [
      "self"
    ],
    "test_normal_mixture": [
      "self"
    ],
    "test_normal_mixture_nd": [
      "self",
      "nd",
      "ncomp"
    ],
    "test_poisson_mixture": [
      "self"
    ],
    "test_mixture_list_of_poissons": [
      "self"
    ],
    "test_mixture_of_mvn": [
      "self"
    ],
    "test_mixture_of_mixture": [
      "self"
    ],
    "test_sample_prior_and_posterior": [
      "self"
    ]
  },
  "TestMixtureVsLatent": {
    "setup_method": [
      "self"
    ],
    "test_1d_w": [
      "self"
    ],
    "test_2d_w": [
      "self"
    ],
    "samples_from_same_distribution": [
      "self"
    ],
    "logp_matches": [
      "self",
      "mixture",
      "latent_mix",
      "z",
      "npop",
      "model"
    ]
  },
  "TestMixtureSameFamily": {
    "setup_class": [
      "cls"
    ],
    "test_with_multinomial": [
      "self",
      "batch_shape"
    ],
    "test_with_mvnormal": [
      "self"
    ],
    "test_broadcasting_in_shape": [
      "self"
    ]
  },
  "check_transform": [
    "transform",
    "domain",
    "constructor",
    "test"
  ],
  "check_vector_transform": [
    "transform",
    "domain"
  ],
  "get_values": [
    "transform",
    "domain",
    "constructor",
    "test"
  ],
  "check_jacobian_det": [
    "transform",
    "domain",
    "constructor",
    "test",
    "make_comparable",
    "elemwise"
  ],
  "test_stickbreaking": [],
  "test_stickbreaking_bounds": [],
  "test_stickbreaking_accuracy": [],
  "test_sum_to_1": [],
  "test_log": [],
  "test_log_exp_m1": [],
  "test_logodds": [],
  "test_lowerbound": [],
  "test_upperbound": [],
  "test_interval": [],
  "test_interval_near_boundary": [],
  "test_circular": [],
  "test_ordered": [],
  "test_chain": [],
  "TestElementWiseLogp": {
    "build_model": [
      "self",
      "distfam",
      "params",
      "shape",
      "transform",
      "testval"
    ],
    "check_transform_elementwise_logp": [
      "self",
      "model"
    ],
    "check_vectortransform_elementwise_logp": [
      "self",
      "model",
      "vect_opt"
    ],
    "test_half_normal": [
      "self",
      "sd",
      "shape"
    ],
    "test_exponential": [
      "self",
      "lam",
      "shape"
    ],
    "test_beta": [
      "self",
      "a",
      "b",
      "shape"
    ],
    "test_uniform": [
      "self",
      "lower",
      "upper",
      "shape"
    ],
    "test_vonmises": [
      "self",
      "mu",
      "kappa",
      "shape"
    ],
    "test_dirichlet": [
      "self",
      "a",
      "shape"
    ],
    "test_normal_ordered": [
      "self"
    ],
    "test_half_normal_ordered": [
      "self",
      "sd",
      "shape"
    ],
    "test_exponential_ordered": [
      "self",
      "lam",
      "shape"
    ],
    "test_beta_ordered": [
      "self",
      "a",
      "b",
      "shape"
    ],
    "test_uniform_ordered": [
      "self",
      "lower",
      "upper",
      "shape"
    ],
    "test_vonmises_ordered": [
      "self",
      "mu",
      "kappa",
      "shape"
    ],
    "test_uniform_other": [
      "self",
      "lower",
      "upper",
      "shape",
      "transform"
    ],
    "test_mvnormal_ordered": [
      "self",
      "mu",
      "cov",
      "shape"
    ]
  },
  "simple_model": [],
  "simple_categorical": [],
  "multidimensional_model": [],
  "simple_arbitrary_det": [],
  "simple_init": [],
  "simple_2model": [],
  "simple_2model_continuous": [],
  "mv_simple": [],
  "mv_simple_coarse": [],
  "mv_simple_very_coarse": [],
  "mv_simple_discrete": [],
  "mv_prior_simple": [],
  "non_normal": [
    "n"
  ],
  "exponential_beta": [
    "n"
  ],
  "beta_bernoulli": [
    "n"
  ],
  "simple_normal": [
    "bounded_prior"
  ],
  "FLOATX": [],
  "INTX": [],
  "TestBroadcasting": {
    "test_make_shared_replacements": [
      "self"
    ],
    "test_metropolis_sampling": [
      "self"
    ]
  },
  "TestTakeAlongAxis": {
    "setup_class": [
      "self"
    ],
    "_input_tensors": [
      "self",
      "shape"
    ],
    "get_input_tensors": [
      "self",
      "shape"
    ],
    "_output_tensor": [
      "self",
      "arr",
      "indices",
      "axis"
    ],
    "get_output_tensors": [
      "self",
      "shape",
      "axis"
    ],
    "_function": [
      "self",
      "arr",
      "indices",
      "out"
    ],
    "get_function": [
      "self",
      "shape",
      "axis"
    ],
    "get_input_values": [
      "shape",
      "axis",
      "samples"
    ],
    "test_take_along_axis": [
      "self",
      "shape",
      "axis",
      "samples"
    ],
    "test_take_along_axis_grad": [
      "self",
      "shape",
      "axis",
      "samples"
    ],
    "test_axis_failure": [
      "self",
      "axis"
    ],
    "test_ndim_failure": [
      "self"
    ],
    "test_dtype_failure": [
      "self"
    ]
  },
  "test_kronecker": [],
  "test_cartesian": [],
  "test_cartesian_2d": [],
  "test_kron_dot": [],
  "test_kron_solve_lower": [],
  "test_probit": [],
  "test_log1pexp": [],
  "test_log1mexp": [],
  "test_log1mexp_numpy_no_warning": [],
  "TestLogDet": {
    "setup_method": [
      "self"
    ],
    "validate": [
      "self",
      "input_mat"
    ],
    "test_basic": [
      "self"
    ]
  },
  "test_expand_packed_triangular": [],
  "test_logsumexp": [
    "values",
    "axis",
    "keepdims"
  ],
  "pytestmark": [],
  "test_callbacks_convergence": [
    "diff",
    "ord"
  ],
  "test_tracker_callback": [],
  "three_var_model": [],
  "test_init_groups": [
    "three_var_model",
    "raises",
    "grouping"
  ],
  "three_var_groups": [
    "request",
    "three_var_model"
  ],
  "three_var_approx": [
    "three_var_model",
    "three_var_groups"
  ],
  "three_var_approx_single_group_mf": [
    "three_var_model"
  ],
  "test_sample_simple": [
    "three_var_approx",
    "request"
  ],
  "aevb_initial": [],
  "parametric_grouped_approxes": [
    "request"
  ],
  "three_var_aevb_groups": [
    "parametric_grouped_approxes",
    "three_var_model",
    "aevb_initial"
  ],
  "three_var_aevb_approx": [
    "three_var_model",
    "three_var_aevb_groups"
  ],
  "test_sample_aevb": [
    "three_var_aevb_approx",
    "aevb_initial"
  ],
  "test_replacements_in_sample_node_aevb": [
    "three_var_aevb_approx",
    "aevb_initial"
  ],
  "test_vae": [],
  "test_logq_mini_1_sample_1_var": [
    "parametric_grouped_approxes",
    "three_var_model"
  ],
  "test_logq_mini_2_sample_2_var": [
    "parametric_grouped_approxes",
    "three_var_model"
  ],
  "test_logq_mini_sample_aevb": [
    "three_var_aevb_groups"
  ],
  "test_logq_aevb": [
    "three_var_aevb_approx"
  ],
  "test_logq_globals": [
    "three_var_approx"
  ],
  "test_group_api_vfam": [
    "three_var_model",
    "raises",
    "vfam",
    "type_",
    "kw"
  ],
  "test_group_api_params": [
    "three_var_model",
    "raises",
    "params",
    "type_",
    "kw",
    "formula"
  ],
  "test_single_group_shortcuts": [
    "three_var_model",
    "approx",
    "kw",
    "gcls"
  ],
  "test_elbo": [],
  "test_scale_cost_to_minibatch_works": [
    "aux_total_size"
  ],
  "test_elbo_beta_kl": [
    "aux_total_size"
  ],
  "use_minibatch": [
    "request"
  ],
  "simple_model_data": [
    "use_minibatch"
  ],
  "inference_spec": [
    "request"
  ],
  "inference": [
    "inference_spec",
    "simple_model"
  ],
  "fit_kwargs": [
    "inference",
    "use_minibatch"
  ],
  "test_fit_oo": [
    "inference",
    "fit_kwargs",
    "simple_model_data"
  ],
  "test_profile": [
    "inference"
  ],
  "test_remove_scan_op": [],
  "test_clear_cache": [],
  "another_simple_model": [],
  "fit_method_with_object": [
    "request",
    "another_simple_model"
  ],
  "test_fit_fn_text": [
    "method",
    "kwargs",
    "error",
    "another_simple_model"
  ],
  "aevb_model": [],
  "test_aevb": [
    "inference_spec",
    "aevb_model"
  ],
  "test_rowwise_approx": [
    "three_var_model",
    "parametric_grouped_approxes"
  ],
  "test_pickle_approx": [
    "three_var_approx"
  ],
  "test_pickle_single_group": [
    "three_var_approx_single_group_mf"
  ],
  "test_pickle_approx_aevb": [
    "three_var_aevb_approx"
  ],
  "binomial_model": [],
  "binomial_model_inference": [
    "binomial_model",
    "inference_spec"
  ],
  "test_replacements": [
    "binomial_model_inference"
  ],
  "test_sample_replacements": [
    "binomial_model_inference"
  ],
  "test_discrete_not_allowed": [],
  "test_var_replacement": [],
  "test_empirical_from_trace": [
    "another_simple_model"
  ],
  "flow_spec": [
    "request"
  ],
  "test_flow_det": [
    "flow_spec"
  ],
  "test_flow_det_local": [
    "flow_spec"
  ],
  "test_flows_collect_chain": [],
  "test_flow_formula": [
    "formula",
    "length",
    "order"
  ],
  "TestSMC": {
    "setup_class": [
      "self"
    ],
    "test_sample": [
      "self"
    ],
    "test_discrete_continuous": [
      "self"
    ],
    "test_ml": [
      "self"
    ],
    "test_start": [
      "self"
    ]
  },
  "TestSMCABC": {
    "setup_class": [
      "self"
    ],
    "test_one_gaussian": [
      "self"
    ],
    "test_sim_data_ppc": [
      "self"
    ],
    "test_custom_dist_sum": [
      "self"
    ],
    "test_potential": [
      "self"
    ],
    "test_automatic_use_of_sort": [
      "self"
    ],
    "test_repr_latex": [
      "self"
    ],
    "test_name_is_string_type": [
      "self"
    ],
    "test_named_models_are_unsupported": [
      "self"
    ],
    "test_log_pseudolikelihood": [
      "self"
    ]
  },
  "test_accuracy_normal": [],
  "test_accuracy_non_normal": [],
  "test_find_MAP_discrete": [],
  "test_find_MAP_no_gradient": [],
  "test_find_MAP": [],
  "test_allinmodel": [],
  "test_gradients": [],
  "test_simulate": [],
  "TestSensitivityInitialCondition": {
    "t": [],
    "test_sens_ic_scalar_1_param": [
      "self"
    ],
    "test_sens_ic_scalar_2_param": [
      "self"
    ],
    "test_sens_ic_vector_1_param": [
      "self"
    ],
    "test_sens_ic_vector_2_param": [
      "self"
    ],
    "test_sens_ic_vector_3_params": [
      "self"
    ]
  },
  "test_logp_scalar_ode": [],
  "TestErrors": {
    "system": [
      "y",
      "t",
      "p"
    ],
    "times": [],
    "ode_model": [],
    "test_too_many_params": [
      "self"
    ],
    "test_too_many_y0": [
      "self"
    ],
    "test_too_few_params": [
      "self"
    ],
    "test_too_few_y0": [
      "self"
    ],
    "test_func_callable": [
      "self"
    ],
    "test_number_of_states": [
      "self"
    ],
    "test_number_of_params": [
      "self"
    ]
  },
  "TestDiffEqModel": {
    "test_op_equality": [
      "self"
    ],
    "test_scalar_ode_1_param": [
      "self"
    ],
    "test_scalar_ode_2_param": [
      "self"
    ],
    "test_vector_ode_1_param": [
      "self"
    ],
    "test_vector_ode_2_param": [
      "self"
    ]
  },
  "theano_config": [],
  "exception_verbosity": [],
  "strict_float32": [],
  "seeded_test": [],
  "KnownMean": {
    "test_mean": [
      "self"
    ]
  },
  "KnownVariance": {
    "test_var": [
      "self"
    ]
  },
  "KnownCDF": {
    "ks_thin": [],
    "alpha": [],
    "test_kstest": [
      "self"
    ]
  },
  "UniformFixture": {
    "means": [],
    "variances": [],
    "cdfs": [],
    "make_model": [
      "cls"
    ]
  },
  "NormalFixture": {
    "means": [],
    "variances": [],
    "cdfs": [],
    "make_model": [
      "cls"
    ]
  },
  "BetaBinomialFixture": {
    "cdfs": [],
    "make_model": [
      "cls"
    ]
  },
  "StudentTFixture": {
    "means": [],
    "cdfs": [],
    "ks_thin": [],
    "make_model": [
      "cls"
    ]
  },
  "LKJCholeskyCovFixture": {
    "cdfs": [],
    "make_model": [
      "cls"
    ]
  },
  "BaseSampler": {
    "setup_class": [
      "cls"
    ],
    "test_neff": [
      "self"
    ],
    "test_Rhat": [
      "self"
    ]
  },
  "NutsFixture": {
    "make_step": [
      "cls"
    ],
    "test_target_accept": [
      "self"
    ]
  },
  "MetropolisFixture": {
    "make_step": [
      "cls"
    ]
  },
  "SliceFixture": {
    "make_step": [
      "cls"
    ]
  },
  "TestPickling": {
    "setup_method": [
      "self"
    ],
    "test_model_roundtrip": [
      "self"
    ]
  },
  "SeededTest": {
    "random_seed": [],
    "setup_class": [
      "cls"
    ],
    "setup_method": [
      "self"
    ],
    "teardown_method": [
      "self"
    ]
  },
  "LoggingHandler": {
    "__init__": [
      "self",
      "matcher"
    ],
    "shouldFlush": [
      "self"
    ],
    "emit": [
      "self",
      "record"
    ],
    "matches": [
      "self"
    ]
  },
  "Matcher": {
    "_partial_matches": [],
    "matches": [
      "self",
      "d"
    ],
    "match_value": [
      "self",
      "k",
      "dv",
      "v"
    ]
  },
  "select_by_precision": [
    "float64",
    "float32"
  ],
  "not_raises": [],
  "verify_grad": [
    "op",
    "pt",
    "n_tests",
    "rng"
  ],
  "test_translate_point_list": [],
  "test_build_TraceDict": [],
  "test_build_TraceDict_point_list": [],
  "test_fast_sample_posterior_predictive_shape_assertions": [],
  "test_context": [],
  "NoUnpickle": {
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ]
  },
  "test_bad_unpickle": [],
  "tt_vector": [],
  "_crash_remote_process": [
    "a",
    "master_pid"
  ],
  "test_dill": [],
  "test_remote_pipe_closed": [],
  "test_abort": [],
  "test_explicit_sample": [],
  "test_iterator": [],
  "test_spawn_densitydist_function": [],
  "test_spawn_densitydist_bound_method": [],
  "test_spawn_densitydist_syswarning": [
    "monkeypatch"
  ],
  "test_spawn_densitydist_mpctxwarning": [
    "monkeypatch"
  ],
  "generate_data": [
    "intercept",
    "slope",
    "size"
  ],
  "TestGLM": {
    "setup_class": [
      "cls"
    ],
    "test_linear_component": [
      "self"
    ],
    "test_glm": [
      "self"
    ],
    "test_glm_offset": [
      "self"
    ],
    "test_glm_link_func": [
      "self"
    ],
    "test_glm_link_func2": [
      "self"
    ],
    "test_more_than_one_glm_is_ok": [
      "self"
    ],
    "test_from_xy": [
      "self"
    ],
    "test_boolean_y": [
      "self"
    ],
    "test_glm_formula_from_calling_scope": [
      "self"
    ],
    "test_linear_component_formula_from_calling_scope": [
      "self"
    ]
  },
  "SCIPY_VERSION": [],
  "get_lkj_cases": [],
  "LKJ_CASES": [],
  "Domain": {
    "__init__": [
      "self",
      "vals",
      "dtype",
      "edges",
      "shape"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__neg__": [
      "self"
    ]
  },
  "product": [
    "domains",
    "n_samples"
  ],
  "R": [],
  "Rplus": [],
  "Rplusbig": [],
  "Rminusbig": [],
  "Unit": [],
  "Circ": [],
  "Runif": [],
  "Rdunif": [],
  "Rplusunif": [],
  "Rplusdunif": [],
  "I": [],
  "NatSmall": [],
  "Nat": [],
  "NatBig": [],
  "PosNat": [],
  "Bool": [],
  "build_model": [
    "distfam",
    "valuedomain",
    "vardomains",
    "extra_args"
  ],
  "laplace_asymmetric_logpdf": [
    "value",
    "kappa",
    "b",
    "mu"
  ],
  "integrate_nd": [
    "f",
    "domain",
    "shape",
    "dtype"
  ],
  "multinomial_logpdf": [
    "value",
    "n",
    "p"
  ],
  "dirichlet_multinomial_logpmf": [
    "value",
    "n",
    "a"
  ],
  "beta_mu_sigma": [
    "value",
    "mu",
    "sigma"
  ],
  "ProductDomain": {
    "__init__": [
      "self",
      "domains"
    ]
  },
  "Vector": [
    "D",
    "n"
  ],
  "SortedVector": [
    "n"
  ],
  "UnitSortedVector": [
    "n"
  ],
  "RealMatrix": [
    "n",
    "m"
  ],
  "simplex_values": [
    "n"
  ],
  "normal_logpdf_tau": [
    "value",
    "mu",
    "tau"
  ],
  "normal_logpdf_cov": [
    "value",
    "mu",
    "cov"
  ],
  "normal_logpdf_chol": [
    "value",
    "mu",
    "chol"
  ],
  "normal_logpdf_chol_upper": [
    "value",
    "mu",
    "chol"
  ],
  "matrix_normal_logpdf_cov": [
    "value",
    "mu",
    "rowcov",
    "colcov"
  ],
  "matrix_normal_logpdf_chol": [
    "value",
    "mu",
    "rowchol",
    "colchol"
  ],
  "kron_normal_logpdf_cov": [
    "value",
    "mu",
    "covs",
    "sigma"
  ],
  "kron_normal_logpdf_chol": [
    "value",
    "mu",
    "chols",
    "sigma"
  ],
  "kron_normal_logpdf_evd": [
    "value",
    "mu",
    "evds",
    "sigma"
  ],
  "betafn": [
    "a"
  ],
  "logpow": [
    "v",
    "p"
  ],
  "discrete_weibull_logpmf": [
    "value",
    "q",
    "beta"
  ],
  "dirichlet_logpdf": [
    "value",
    "a"
  ],
  "categorical_logpdf": [
    "value",
    "p"
  ],
  "mvt_logpdf": [
    "value",
    "nu",
    "Sigma",
    "mu"
  ],
  "AR1_logpdf": [
    "value",
    "k",
    "tau_e"
  ],
  "orderedlogistic_logpdf": [
    "value",
    "eta",
    "cutpoints"
  ],
  "orderedprobit_logpdf": [
    "value",
    "eta",
    "cutpoints"
  ],
  "Simplex": {
    "__init__": [
      "self",
      "n"
    ]
  },
  "MultiSimplex": {
    "__init__": [
      "self",
      "n_dependent",
      "n_independent"
    ]
  },
  "PdMatrix": [
    "n"
  ],
  "PdMatrix1": [],
  "PdMatrix2": [],
  "PdMatrix3": [],
  "PdMatrixChol1": [],
  "PdMatrixChol2": [],
  "PdMatrixChol3": [],
  "PdMatrixChol": [
    "n"
  ],
  "PdMatrixCholUpper1": [],
  "PdMatrixCholUpper2": [],
  "PdMatrixCholUpper3": [],
  "PdMatrixCholUpper": [
    "n"
  ],
  "RandomPdMatrix": [
    "n"
  ],
  "TestMatchesScipy": {
    "check_logp": [
      "self",
      "pymc3_dist",
      "domain",
      "paramdomains",
      "scipy_logp",
      "decimal",
      "n_samples",
      "extra_args",
      "scipy_args"
    ],
    "check_logcdf": [
      "self",
      "pymc3_dist",
      "domain",
      "paramdomains",
      "scipy_logcdf",
      "decimal",
      "n_samples",
      "skip_paramdomain_inside_edge_test",
      "skip_paramdomain_outside_edge_test"
    ],
    "check_selfconsistency_discrete_logcdf": [
      "self",
      "distribution",
      "domain",
      "paramdomains",
      "decimal",
      "n_samples"
    ],
    "check_int_to_1": [
      "self",
      "model",
      "value",
      "domain",
      "paramdomains"
    ],
    "checkd": [
      "self",
      "distfam",
      "valuedomain",
      "vardomains",
      "checks",
      "extra_args"
    ],
    "test_uniform": [
      "self"
    ],
    "test_triangular": [
      "self"
    ],
    "test_bound_normal": [
      "self"
    ],
    "test_discrete_unif": [
      "self"
    ],
    "test_flat": [
      "self"
    ],
    "test_half_flat": [
      "self"
    ],
    "test_normal": [
      "self"
    ],
    "test_truncated_normal": [
      "self"
    ],
    "test_half_normal": [
      "self"
    ],
    "test_chi_squared": [
      "self"
    ],
    "test_wald_scipy": [
      "self"
    ],
    "test_wald": [
      "self",
      "value",
      "mu",
      "lam",
      "phi",
      "alpha",
      "logp"
    ],
    "test_beta": [
      "self"
    ],
    "test_kumaraswamy": [
      "self"
    ],
    "test_exponential": [
      "self"
    ],
    "test_geometric": [
      "self"
    ],
    "test_hypergeometric": [
      "self"
    ],
    "test_negative_binomial": [
      "self"
    ],
    "test_negative_binomial_init_fail": [
      "self",
      "mu",
      "p",
      "alpha",
      "n",
      "expected"
    ],
    "test_laplace": [
      "self"
    ],
    "test_laplace_asymmetric": [
      "self"
    ],
    "test_lognormal": [
      "self"
    ],
    "test_t": [
      "self"
    ],
    "test_cauchy": [
      "self"
    ],
    "test_half_cauchy": [
      "self"
    ],
    "test_gamma_logp": [
      "self"
    ],
    "test_gamma_logcdf": [
      "self"
    ],
    "test_inverse_gamma": [
      "self"
    ],
    "test_inverse_gamma_alt_params": [
      "self"
    ],
    "test_pareto": [
      "self"
    ],
    "test_weibull": [
      "self"
    ],
    "test_half_studentt": [
      "self"
    ],
    "test_skew_normal": [
      "self"
    ],
    "test_binomial": [
      "self"
    ],
    "test_beta_binomial": [
      "self"
    ],
    "test_bernoulli": [
      "self"
    ],
    "test_discrete_weibull": [
      "self"
    ],
    "test_poisson": [
      "self"
    ],
    "test_bound_poisson": [
      "self"
    ],
    "test_constantdist": [
      "self"
    ],
    "test_zeroinflatedpoisson": [
      "self"
    ],
    "test_zeroinflatednegativebinomial": [
      "self"
    ],
    "test_zeroinflatedbinomial": [
      "self"
    ],
    "test_mvnormal": [
      "self",
      "n"
    ],
    "test_mvnormal_indef": [
      "self"
    ],
    "test_mvnormal_init_fail": [
      "self"
    ],
    "test_matrixnormal": [
      "self",
      "n"
    ],
    "test_kroneckernormal": [
      "self",
      "n",
      "m",
      "sigma"
    ],
    "test_mvt": [
      "self",
      "n"
    ],
    "test_AR1": [
      "self",
      "n"
    ],
    "test_wishart": [
      "self",
      "n"
    ],
    "test_lkj": [
      "self",
      "x",
      "eta",
      "n",
      "lp"
    ],
    "test_dirichlet": [
      "self",
      "n"
    ],
    "test_dirichlet_with_batch_shapes": [
      "self",
      "dist_shape"
    ],
    "test_dirichlet_shape": [
      "self"
    ],
    "test_dirichlet_2D": [
      "self"
    ],
    "test_multinomial": [
      "self",
      "n"
    ],
    "test_multinomial_mode": [
      "self",
      "p",
      "n"
    ],
    "test_multinomial_random": [
      "self",
      "p",
      "shape",
      "n"
    ],
    "test_multinomial_mode_with_shape": [
      "self"
    ],
    "test_multinomial_vec": [
      "self"
    ],
    "test_multinomial_vec_1d_n": [
      "self"
    ],
    "test_multinomial_vec_1d_n_2d_p": [
      "self"
    ],
    "test_multinomial_vec_2d_p": [
      "self"
    ],
    "test_batch_multinomial": [
      "self"
    ],
    "test_dirichlet_multinomial": [
      "self",
      "n"
    ],
    "test_dirichlet_multinomial_matches_beta_binomial": [
      "self"
    ],
    "test_dirichlet_multinomial_defaultval": [
      "self",
      "a",
      "n",
      "shape"
    ],
    "test_dirichlet_multinomial_vec": [
      "self"
    ],
    "test_dirichlet_multinomial_vec_1d_n": [
      "self"
    ],
    "test_dirichlet_multinomial_vec_1d_n_2d_a": [
      "self"
    ],
    "test_dirichlet_multinomial_vec_2d_a": [
      "self"
    ],
    "test_batch_dirichlet_multinomial": [
      "self"
    ],
    "test_categorical_bounds": [
      "self"
    ],
    "test_categorical_valid_p": [
      "self"
    ],
    "test_categorical": [
      "self",
      "n"
    ],
    "test_orderedlogistic": [
      "self",
      "n"
    ],
    "test_orderedprobit": [
      "self",
      "n"
    ],
    "test_densitydist": [
      "self"
    ],
    "test_get_tau_sigma": [
      "self"
    ],
    "test_ex_gaussian": [
      "self",
      "value",
      "mu",
      "sigma",
      "nu",
      "logp"
    ],
    "test_ex_gaussian_cdf": [
      "self",
      "value",
      "mu",
      "sigma",
      "nu",
      "logcdf"
    ],
    "test_ex_gaussian_cdf_outside_edges": [
      "self"
    ],
    "test_vonmises": [
      "self"
    ],
    "test_gumbel": [
      "self"
    ],
    "test_logistic": [
      "self"
    ],
    "test_logitnormal": [
      "self"
    ],
    "test_multidimensional_beta_construction": [
      "self"
    ],
    "test_rice": [
      "self"
    ],
    "test_moyal": [
      "self"
    ],
    "test_interpolated": [
      "self"
    ]
  },
  "TestStrAndLatexRepr": {
    "setup_class": [
      "self"
    ],
    "test__repr_latex_": [
      "self"
    ],
    "test___latex__": [
      "self"
    ],
    "test___str__": [
      "self"
    ],
    "test_str": [
      "self"
    ]
  },
  "test_discrete_trafo": [],
  "test_orderedlogistic_dimensions": [
    "shape"
  ],
  "TestBugfixes": {
    "test_issue_3051": [
      "self",
      "dims",
      "dist_cls",
      "kwargs"
    ]
  },
  "test_serialize_density_dist": [],
  "test": [],
  "TestModelContext": {
    "test_thread_safety": [
      "self"
    ]
  },
  "test_mixed_contexts": [],
  "ModelBackendSetupTestCase": {
    "setup_method": [
      "self"
    ],
    "test_append_invalid": [
      "self"
    ],
    "test_append": [
      "self"
    ],
    "test_double_close": [
      "self"
    ],
    "teardown_method": [
      "self"
    ]
  },
  "StatsTestCase": {
    "setup_method": [
      "self"
    ],
    "test_bad_dtype": [
      "self"
    ],
    "teardown_method": [
      "self"
    ]
  },
  "ModelBackendSampledTestCase": {
    "setup_class": [
      "cls"
    ],
    "teardown_class": [
      "cls"
    ],
    "test_varnames_nonempty": [
      "self"
    ],
    "test_stat_names": [
      "self"
    ]
  },
  "SamplingTestCase": {
    "record_point": [
      "self",
      "val"
    ],
    "test_standard_close": [
      "self"
    ],
    "test_missing_stats": [
      "self"
    ],
    "test_clean_interrupt": [
      "self"
    ]
  },
  "SelectionTestCase": {
    "test_get_values_default": [
      "self"
    ],
    "test_get_values_nocombine_burn_keyword": [
      "self"
    ],
    "test_len": [
      "self"
    ],
    "test_dtypes": [
      "self"
    ],
    "test_get_values_nocombine_thin_keyword": [
      "self"
    ],
    "test_get_point": [
      "self"
    ],
    "test_get_slice": [
      "self"
    ],
    "test_get_slice_step": [
      "self"
    ],
    "test_get_slice_neg_step": [
      "self"
    ],
    "test_get_neg_slice": [
      "self"
    ],
    "test_get_values_one_chain": [
      "self"
    ],
    "test_get_values_nocombine_chains_reversed": [
      "self"
    ],
    "test_nchains": [
      "self"
    ],
    "test_get_values_one_chain_int_arg": [
      "self"
    ],
    "test_get_values_combine": [
      "self"
    ],
    "test_get_values_combine_burn_arg": [
      "self"
    ],
    "test_get_values_combine_thin_arg": [
      "self"
    ],
    "test_getitem_equivalence": [
      "self"
    ],
    "test_selection_method_equivalence": [
      "self"
    ]
  },
  "DumpLoadTestCase": {
    "setup_class": [
      "cls"
    ],
    "teardown_class": [
      "cls"
    ],
    "test_nchains": [
      "self"
    ],
    "test_varnames": [
      "self"
    ],
    "test_values": [
      "self"
    ]
  },
  "BackendEqualityTestCase": {
    "setup_class": [
      "cls"
    ],
    "teardown_class": [
      "cls"
    ],
    "test_chain_length": [
      "self"
    ],
    "test_dtype": [
      "self"
    ],
    "test_number_of_draws": [
      "self"
    ],
    "test_get_item": [
      "self"
    ],
    "test_get_values": [
      "self"
    ],
    "test_get_values_no_squeeze": [
      "self"
    ],
    "test_get_values_combine_and_no_squeeze": [
      "self"
    ],
    "test_get_values_with_burn": [
      "self"
    ],
    "test_get_values_with_thin": [
      "self"
    ],
    "test_get_values_with_burn_and_thin": [
      "self"
    ],
    "test_get_values_with_chains_arg": [
      "self"
    ],
    "test_get_point": [
      "self"
    ],
    "test_point_with_chain_arg": [
      "self"
    ]
  },
  "remove_file_or_directory": [
    "name"
  ],
  "TestZeroMean": {
    "test_value": [
      "self"
    ]
  },
  "TestConstantMean": {
    "test_value": [
      "self"
    ]
  },
  "TestLinearMean": {
    "test_value": [
      "self"
    ]
  },
  "TestAddProdMean": {
    "test_add": [
      "self"
    ],
    "test_prod": [
      "self"
    ],
    "test_add_multid": [
      "self"
    ],
    "test_prod_multid": [
      "self"
    ]
  },
  "TestCovAdd": {
    "test_symadd_cov": [
      "self"
    ],
    "test_rightadd_scalar": [
      "self"
    ],
    "test_leftadd_scalar": [
      "self"
    ],
    "test_rightadd_matrix": [
      "self"
    ],
    "test_leftadd_matrixt": [
      "self"
    ],
    "test_leftprod_matrix": [
      "self"
    ],
    "test_inv_rightadd": [
      "self"
    ]
  },
  "TestCovProd": {
    "test_symprod_cov": [
      "self"
    ],
    "test_rightprod_scalar": [
      "self"
    ],
    "test_leftprod_scalar": [
      "self"
    ],
    "test_rightprod_matrix": [
      "self"
    ],
    "test_leftprod_matrix": [
      "self"
    ],
    "test_multiops": [
      "self"
    ],
    "test_inv_rightprod": [
      "self"
    ]
  },
  "TestCovExponentiation": {
    "test_symexp_cov": [
      "self"
    ],
    "test_covexp_numpy": [
      "self"
    ],
    "test_covexp_theano": [
      "self"
    ],
    "test_covexp_shared": [
      "self"
    ],
    "test_invalid_covexp": [
      "self"
    ]
  },
  "TestCovKron": {
    "test_symprod_cov": [
      "self"
    ],
    "test_multiops": [
      "self"
    ]
  },
  "TestCovSliceDim": {
    "test_slice1": [
      "self"
    ],
    "test_slice2": [
      "self"
    ],
    "test_slice3": [
      "self"
    ],
    "test_diffslice": [
      "self"
    ],
    "test_raises": [
      "self"
    ]
  },
  "TestStability": {
    "test_stable": [
      "self"
    ]
  },
  "TestExpQuad": {
    "test_1d": [
      "self"
    ],
    "test_2d": [
      "self"
    ],
    "test_2dard": [
      "self"
    ],
    "test_inv_lengthscale": [
      "self"
    ]
  },
  "TestWhiteNoise": {
    "test_1d": [
      "self"
    ]
  },
  "TestConstant": {
    "test_1d": [
      "self"
    ]
  },
  "TestRatQuad": {
    "test_1d": [
      "self"
    ]
  },
  "TestExponential": {
    "test_1d": [
      "self"
    ]
  },
  "TestMatern52": {
    "test_1d": [
      "self"
    ]
  },
  "TestMatern32": {
    "test_1d": [
      "self"
    ]
  },
  "TestMatern12": {
    "test_1d": [
      "self"
    ]
  },
  "TestCosine": {
    "test_1d": [
      "self"
    ]
  },
  "TestPeriodic": {
    "test_1d": [
      "self"
    ]
  },
  "TestLinear": {
    "test_1d": [
      "self"
    ]
  },
  "TestPolynomial": {
    "test_1d": [
      "self"
    ]
  },
  "TestWarpedInput": {
    "test_1d": [
      "self"
    ],
    "test_raises": [
      "self"
    ]
  },
  "TestGibbs": {
    "test_1d": [
      "self"
    ],
    "test_raises": [
      "self"
    ]
  },
  "TestScaledCov": {
    "test_1d": [
      "self"
    ],
    "test_raises": [
      "self"
    ]
  },
  "TestHandleArgs": {
    "test_handleargs": [
      "self"
    ]
  },
  "TestCoregion": {
    "setup_method": [
      "self"
    ],
    "test_full": [
      "self"
    ],
    "test_fullB": [
      "self"
    ],
    "test_Xs": [
      "self"
    ],
    "test_diag": [
      "self"
    ],
    "test_raises": [
      "self"
    ],
    "test_raises2": [
      "self"
    ],
    "test_raises3": [
      "self"
    ]
  },
  "TestMarginalVsLatent": {
    "setup_method": [
      "self"
    ],
    "testLatent1": [
      "self"
    ],
    "testLatent2": [
      "self"
    ]
  },
  "TestMarginalVsMarginalSparse": {
    "setup_method": [
      "self"
    ],
    "testApproximations": [
      "self",
      "approx"
    ],
    "testPredictVar": [
      "self",
      "approx"
    ],
    "testPredictCov": [
      "self"
    ]
  },
  "TestGPAdditive": {
    "setup_method": [
      "self"
    ],
    "testAdditiveMarginal": [
      "self"
    ],
    "testAdditiveMarginalSparse": [
      "self",
      "approx"
    ],
    "testAdditiveLatent": [
      "self"
    ],
    "testAdditiveSparseRaises": [
      "self"
    ],
    "testAdditiveTypeRaises1": [
      "self"
    ],
    "testAdditiveTypeRaises2": [
      "self"
    ]
  },
  "TestTP": {
    "setup_method": [
      "self"
    ],
    "testTPvsLatent": [
      "self"
    ],
    "testTPvsLatentReparameterized": [
      "self"
    ],
    "testAdditiveTPRaises": [
      "self"
    ]
  },
  "TestLatentKron": {
    "setup_method": [
      "self"
    ],
    "testLatentKronvsLatent": [
      "self"
    ],
    "testLatentKronRaisesAdditive": [
      "self"
    ],
    "testLatentKronRaisesSizes": [
      "self"
    ]
  },
  "TestMarginalKron": {
    "setup_method": [
      "self"
    ],
    "testMarginalKronvsMarginalpredict": [
      "self"
    ],
    "testMarginalKronvsMarginal": [
      "self"
    ],
    "testMarginalKronRaises": [
      "self"
    ]
  },
  "TestUtil": {
    "test_plot_gp_dist": [
      "self"
    ],
    "test_plot_gp_dist_warn_nan": [
      "self"
    ]
  },
  "TestCircular": {
    "test_1d_tau1": [
      "self"
    ],
    "test_1d_tau2": [
      "self"
    ]
  },
  "test_elemwise_posdef": [],
  "test_elemwise_velocity": [],
  "test_elemwise_energy": [],
  "test_equal_diag": [],
  "test_equal_dense": [],
  "test_random_diag": [],
  "test_random_dense": [],
  "test_user_potential": [],
  "test_weighted_covariance": [
    "ndim",
    "seed"
  ],
  "test_full_adapt_sample_p": [
    "seed"
  ],
  "test_full_adapt_update_window": [
    "seed"
  ],
  "test_full_adapt_adaptation_window": [
    "seed"
  ],
  "test_full_adapt_not_invertible": [],
  "test_full_adapt_warn": [],
  "test_full_adapt_sampling": [
    "seed"
  ],
  "test_issue_3965": [],
  "test_AR": [],
  "test_AR_nd": [],
  "test_GARCH11": [],
  "_gen_sde_path": [
    "sde",
    "pars",
    "dt",
    "n",
    "x0"
  ],
  "test_linear": [],
  "TestType": {
    "samplers": [],
    "setup_method": [
      "self"
    ],
    "teardown_method": [
      "self"
    ],
    "test_float64": [
      "self"
    ],
    "test_float32": [
      "self"
    ],
    "test_float64_MLDA": [
      "self"
    ],
    "test_float32_MLDA": [
      "self"
    ]
  },
  "test_plot_posterior_predictive_glm_defaults": [
    "inferencedata"
  ],
  "test_plot_posterior_predictive_glm_non_defaults": [
    "inferencedata"
  ],
  "test_missing": [],
  "test_missing_pandas": [],
  "test_missing_with_predictors": [],
  "test_missing_dual_observations": [],
  "test_internal_missing_observations": [],
  "TestStepMethods": {
    "master_samples": [],
    "setup_class": [
      "self"
    ],
    "teardown_class": [
      "self"
    ],
    "test_sample_exact": [
      "self"
    ],
    "check_trace": [
      "self",
      "step_method"
    ],
    "check_stat": [
      "self",
      "check",
      "trace",
      "name"
    ],
    "test_step_continuous": [
      "self"
    ],
    "test_step_discrete": [
      "self"
    ],
    "test_step_categorical": [
      "self"
    ],
    "test_step_elliptical_slice": [
      "self"
    ]
  },
  "TestMetropolisProposal": {
    "test_proposal_choice": [
      "self"
    ],
    "test_mv_proposal": [
      "self"
    ]
  },
  "TestCompoundStep": {
    "samplers": [],
    "test_non_blocked": [
      "self"
    ],
    "test_blocked": [
      "self"
    ]
  },
  "TestAssignStepMethods": {
    "test_bernoulli": [
      "self"
    ],
    "test_normal": [
      "self"
    ],
    "test_categorical": [
      "self"
    ],
    "test_binomial": [
      "self"
    ],
    "test_normal_nograd_op": [
      "self"
    ]
  },
  "TestPopulationSamplers": {
    "steppers": [],
    "test_checks_population_size": [
      "self"
    ],
    "test_demcmc_warning_on_small_populations": [
      "self"
    ],
    "test_demcmc_tune_parameter": [
      "self"
    ],
    "test_nonparallelized_chains_are_random": [
      "self"
    ],
    "test_parallelized_chains_are_random": [
      "self"
    ]
  },
  "TestMetropolis": {
    "test_tuning_reset": [
      "self"
    ]
  },
  "TestDEMetropolisZ": {
    "test_tuning_lambda_sequential": [
      "self"
    ],
    "test_tuning_epsilon_parallel": [
      "self"
    ],
    "test_tuning_none": [
      "self"
    ],
    "test_tuning_reset": [
      "self"
    ],
    "test_tune_drop_fraction": [
      "self"
    ],
    "test_competence": [
      "self",
      "variable",
      "has_grad",
      "outcome"
    ],
    "test_invalid_tune": [
      "self",
      "tune_setting"
    ],
    "test_custom_proposal_dist": [
      "self"
    ]
  },
  "TestNutsCheckTrace": {
    "test_multiple_samplers": [
      "self",
      "caplog"
    ],
    "test_bad_init_nonparallel": [
      "self"
    ],
    "test_bad_init_parallel": [
      "self"
    ],
    "test_linalg": [
      "self",
      "caplog"
    ],
    "test_sampler_stats": [
      "self"
    ]
  },
  "TestMLDA": {
    "steppers": [],
    "test_proposal_and_base_proposal_choice": [
      "self"
    ],
    "test_step_methods_in_each_level": [
      "self"
    ],
    "test_exceptions_coarse_models": [
      "self"
    ],
    "test_nonparallelized_chains_are_random": [
      "self"
    ],
    "test_parallelized_chains_are_random": [
      "self"
    ],
    "test_acceptance_rate_against_coarseness": [
      "self"
    ],
    "test_mlda_non_blocked": [
      "self"
    ],
    "test_mlda_blocked": [
      "self"
    ],
    "test_tuning_and_scaling_on": [
      "self"
    ],
    "test_tuning_and_scaling_off": [
      "self"
    ],
    "test_trace_length": [
      "self"
    ],
    "test_competence": [
      "self",
      "variable",
      "has_grad",
      "outcome"
    ],
    "test_multiple_subsampling_rates": [
      "self"
    ],
    "test_aem_mu_sigma": [
      "self"
    ],
    "test_variance_reduction": [
      "self"
    ]
  },
  "get_city_data": [],
  "TestARM5_4": {
    "build_model": [
      "self"
    ],
    "test_run": [
      "self"
    ]
  },
  "TestARM12_6": {
    "build_model": [
      "self"
    ],
    "too_slow": [
      "self"
    ]
  },
  "TestARM12_6Uranium": {
    "build_model": [
      "self"
    ],
    "too_slow": [
      "self"
    ]
  },
  "build_disaster_model": [
    "masked"
  ],
  "TestDisasterModel": {
    "test_disaster_model": [
      "self"
    ],
    "test_disaster_model_missing": [
      "self"
    ]
  },
  "TestGLMLinear": {
    "build_model": [
      "self"
    ],
    "test_run": [
      "self"
    ]
  },
  "TestLatentOccupancy": {
    "setup_method": [
      "self"
    ],
    "build_model": [
      "self"
    ],
    "test_run": [
      "self"
    ]
  },
  "TestRSV": {
    "build_model": [
      "self"
    ],
    "test_run": [
      "self"
    ]
  },
  "TestMultilevelNormal": {
    "build_models": [
      "self"
    ],
    "test_run": [
      "self"
    ]
  },
  "pymc3_random": [
    "dist",
    "paramdomains",
    "ref_rand",
    "valuedomain",
    "size",
    "alpha",
    "fails",
    "extra_args",
    "model_args"
  ],
  "pymc3_random_discrete": [
    "dist",
    "paramdomains",
    "valuedomain",
    "ref_rand",
    "size",
    "alpha",
    "fails"
  ],
  "TestDrawValues": {
    "test_draw_scalar_parameters": [
      "self"
    ],
    "test_draw_dependencies": [
      "self"
    ],
    "test_draw_order": [
      "self"
    ],
    "test_draw_point_replacement": [
      "self"
    ],
    "test_random_sample_returns_nd_array": [
      "self"
    ]
  },
  "TestDrawValuesContext": {
    "test_normal_context": [
      "self"
    ],
    "test_blocking_context": [
      "self"
    ]
  },
  "BaseTestCases": {},
  "TestGaussianRandomWalk": {
    "distribution": [],
    "params": [],
    "default_shape": []
  },
  "TestNormal": {
    "distribution": [],
    "params": []
  },
  "TestTruncatedNormal": {
    "distribution": [],
    "params": []
  },
  "TestTruncatedNormalLower": {
    "distribution": [],
    "params": []
  },
  "TestTruncatedNormalUpper": {
    "distribution": [],
    "params": []
  },
  "TestSkewNormal": {
    "distribution": [],
    "params": []
  },
  "TestHalfNormal": {
    "distribution": [],
    "params": []
  },
  "TestUniform": {
    "distribution": [],
    "params": []
  },
  "TestTriangular": {
    "distribution": [],
    "params": []
  },
  "TestWald": {
    "distribution": [],
    "params": []
  },
  "TestBeta": {
    "distribution": [],
    "params": []
  },
  "TestKumaraswamy": {
    "distribution": [],
    "params": []
  },
  "TestLaplace": {
    "distribution": [],
    "params": []
  },
  "TestAsymmetricLaplace": {
    "distribution": [],
    "params": []
  },
  "TestLognormal": {
    "distribution": [],
    "params": []
  },
  "TestStudentT": {
    "distribution": [],
    "params": []
  },
  "TestPareto": {
    "distribution": [],
    "params": []
  },
  "TestCauchy": {
    "distribution": [],
    "params": []
  },
  "TestHalfCauchy": {
    "distribution": [],
    "params": []
  },
  "TestGamma": {
    "distribution": [],
    "params": []
  },
  "TestInverseGamma": {
    "distribution": [],
    "params": []
  },
  "TestChiSquared": {
    "distribution": [],
    "params": []
  },
  "TestWeibull": {
    "distribution": [],
    "params": []
  },
  "TestExGaussian": {
    "distribution": [],
    "params": []
  },
  "TestVonMises": {
    "distribution": [],
    "params": []
  },
  "TestGumbel": {
    "distribution": [],
    "params": []
  },
  "TestLogistic": {
    "distribution": [],
    "params": []
  },
  "TestLogitNormal": {
    "distribution": [],
    "params": []
  },
  "TestBinomial": {
    "distribution": [],
    "params": []
  },
  "TestBetaBinomial": {
    "distribution": [],
    "params": []
  },
  "TestBernoulli": {
    "distribution": [],
    "params": []
  },
  "TestDiscreteWeibull": {
    "distribution": [],
    "params": []
  },
  "TestPoisson": {
    "distribution": [],
    "params": []
  },
  "TestNegativeBinomial": {
    "distribution": [],
    "params": []
  },
  "TestZeroInflatedPoisson": {
    "distribution": [],
    "params": []
  },
  "TestZeroInflatedNegativeBinomial": {
    "distribution": [],
    "params": []
  },
  "TestZeroInflatedBinomial": {
    "distribution": [],
    "params": []
  },
  "TestDiscreteUniform": {
    "distribution": [],
    "params": []
  },
  "TestGeometric": {
    "distribution": [],
    "params": []
  },
  "TestHyperGeometric": {
    "distribution": [],
    "params": []
  },
  "TestMoyal": {
    "distribution": [],
    "params": []
  },
  "TestCategorical": {
    "distribution": [],
    "params": [],
    "get_random_variable": [
      "self",
      "shape",
      "with_vector_params"
    ],
    "test_probability_vector_shape": [
      "self"
    ]
  },
  "TestDirichlet": {
    "test_dirichlet_random_shape": [
      "self",
      "shape",
      "size"
    ]
  },
  "TestScalarParameterSamples": {
    "test_bounded": [
      "self"
    ],
    "test_uniform": [
      "self"
    ],
    "test_normal": [
      "self"
    ],
    "test_truncated_normal": [
      "self"
    ],
    "test_truncated_normal_lower": [
      "self"
    ],
    "test_truncated_normal_upper": [
      "self"
    ],
    "test_skew_normal": [
      "self"
    ],
    "test_half_normal": [
      "self"
    ],
    "test_wald": [
      "self"
    ],
    "test_beta": [
      "self"
    ],
    "test_exponential": [
      "self"
    ],
    "test_laplace": [
      "self"
    ],
    "test_laplace_asymmetric": [
      "self"
    ],
    "test_lognormal": [
      "self"
    ],
    "test_student_t": [
      "self"
    ],
    "test_cauchy": [
      "self"
    ],
    "test_half_cauchy": [
      "self"
    ],
    "test_gamma_alpha_beta": [
      "self"
    ],
    "test_gamma_mu_sigma": [
      "self"
    ],
    "test_inverse_gamma": [
      "self"
    ],
    "test_pareto": [
      "self"
    ],
    "test_ex_gaussian": [
      "self"
    ],
    "test_vonmises": [
      "self"
    ],
    "test_triangular": [
      "self"
    ],
    "test_flat": [
      "self"
    ],
    "test_half_flat": [
      "self"
    ],
    "test_binomial": [
      "self"
    ],
    "test_beta_binomial": [
      "self"
    ],
    "_beta_bin": [
      "self",
      "n",
      "alpha",
      "beta",
      "size"
    ],
    "test_bernoulli": [
      "self"
    ],
    "test_poisson": [
      "self"
    ],
    "test_negative_binomial": [
      "self"
    ],
    "test_geometric": [
      "self"
    ],
    "test_hypergeometric": [
      "self"
    ],
    "test_discrete_uniform": [
      "self"
    ],
    "test_discrete_weibull": [
      "self"
    ],
    "test_categorical_random": [
      "self",
      "s"
    ],
    "test_constant_dist": [
      "self"
    ],
    "test_mv_normal": [
      "self"
    ],
    "test_matrix_normal": [
      "self"
    ],
    "test_kronecker_normal": [
      "self"
    ],
    "test_mv_t": [
      "self"
    ],
    "test_dirichlet": [
      "self"
    ],
    "test_dirichlet_multinomial": [
      "self"
    ],
    "test_dirichlet_multinomial_shape": [
      "self",
      "a",
      "shape",
      "n"
    ],
    "test_dirichlet_multinomial_dist_ShapeError": [
      "self",
      "n",
      "a",
      "shape",
      "expectation"
    ],
    "test_multinomial": [
      "self"
    ],
    "test_gumbel": [
      "self"
    ],
    "test_logistic": [
      "self"
    ],
    "test_logitnormal": [
      "self"
    ],
    "test_moyal": [
      "self"
    ],
    "test_interpolated": [
      "self"
    ],
    "test_wishart": [
      "self"
    ],
    "test_lkj": [
      "self"
    ],
    "test_normalmixture": [
      "self"
    ]
  },
  "test_mixture_random_shape": [],
  "test_mixture_random_shape_fast": [],
  "TestDensityDist": {
    "test_density_dist_with_random_sampleable": [
      "self",
      "shape"
    ],
    "test_density_dist_with_random_sampleable_failure": [
      "self",
      "shape"
    ],
    "test_density_dist_with_random_sampleable_hidden_error": [
      "self",
      "shape"
    ],
    "test_density_dist_with_random_sampleable_handcrafted_success": [
      "self"
    ],
    "test_density_dist_with_random_sampleable_handcrafted_success_fast": [
      "self"
    ],
    "test_density_dist_without_random_not_sampleable": [
      "self"
    ]
  },
  "TestNestedRandom": {
    "build_model": [
      "self",
      "distribution",
      "shape",
      "nested_rvs_info"
    ],
    "sample_prior": [
      "self",
      "distribution",
      "shape",
      "nested_rvs_info",
      "prior_samples"
    ],
    "test_NegativeBinomial": [
      "self",
      "prior_samples",
      "shape",
      "mu",
      "alpha"
    ],
    "test_ZeroInflatedNegativeBinomial": [
      "self",
      "prior_samples",
      "shape",
      "psi",
      "mu",
      "alpha"
    ],
    "test_Rice": [
      "self",
      "prior_samples",
      "shape",
      "nu",
      "sigma"
    ],
    "test_TruncatedNormal": [
      "self",
      "prior_samples",
      "shape",
      "mu",
      "sigma",
      "lower",
      "upper"
    ],
    "test_Triangular": [
      "self",
      "prior_samples",
      "shape",
      "c",
      "lower",
      "upper"
    ]
  },
  "generate_shapes": [
    "include_params"
  ],
  "TestMvNormal": {
    "test_with_np_arrays": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape",
      "param"
    ],
    "test_with_chol_rv": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape"
    ],
    "test_with_cov_rv": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape"
    ],
    "test_issue_3758": [
      "self"
    ],
    "test_issue_3829": [
      "self"
    ],
    "test_issue_3706": [
      "self"
    ]
  },
  "test_matrix_normal_random_with_random_variables": [],
  "test_lkj_corr_with_prior_predictive": [
    "n"
  ],
  "TestMvGaussianRandomWalk": {
    "test_with_np_arrays": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape",
      "param"
    ],
    "test_with_chol_rv": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape"
    ],
    "test_with_cov_rv": [
      "self",
      "sample_shape",
      "dist_shape",
      "mu_shape"
    ]
  },
  "STATS1": [],
  "STATS2": [],
  "TestNDArray0dSampling": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArray0dSamplingStats1": {
    "backend": [],
    "name": [],
    "sampler_vars": [],
    "shape": []
  },
  "TestNDArray0dSamplingStats2": {
    "backend": [],
    "name": [],
    "sampler_vars": [],
    "shape": []
  },
  "TestNDArray1dSampling": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArray2dSampling": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArrayStats": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArray0dSelection": {
    "backend": [],
    "name": [],
    "shape": [],
    "sampler_vars": []
  },
  "TestNDArray0dSelection2": {
    "backend": [],
    "name": [],
    "shape": [],
    "sampler_vars": []
  },
  "TestNDArray0dSelectionStats1": {
    "backend": [],
    "name": [],
    "shape": [],
    "sampler_vars": []
  },
  "TestNDArray0dSelectionStats2": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArray1dSelection": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestNDArray2dSelection": {
    "backend": [],
    "name": [],
    "shape": []
  },
  "TestMultiTrace": {
    "name": [],
    "backend": [],
    "shape": [],
    "setup_method": [
      "self"
    ],
    "test_multitrace_nonunique": [
      "self"
    ],
    "test_merge_traces_no_traces": [
      "self"
    ],
    "test_merge_traces_diff_lengths": [
      "self"
    ],
    "test_merge_traces_nonunique": [
      "self"
    ]
  },
  "TestMultiTrace_add_remove_values": {
    "name": [],
    "backend": [],
    "shape": [],
    "test_add_values": [
      "self"
    ]
  },
  "TestSqueezeCat": {
    "setup_method": [
      "self"
    ],
    "test_combine_false_squeeze_false": [
      "self"
    ],
    "test_combine_true_squeeze_false": [
      "self"
    ],
    "test_combine_false_squeeze_true_more_than_one_item": [
      "self"
    ],
    "test_combine_false_squeeze_true_one_item": [
      "self"
    ],
    "test_combine_true_squeeze_true": [
      "self"
    ]
  },
  "TestSaveLoad": {
    "model": [],
    "setup_class": [
      "cls"
    ],
    "test_save_new_model": [
      "self",
      "tmpdir_factory"
    ],
    "test_save_and_load": [
      "self",
      "tmpdir_factory"
    ],
    "test_bad_load": [
      "self",
      "tmpdir_factory"
    ],
    "test_sample_posterior_predictive": [
      "self",
      "tmpdir_factory"
    ]
  },
  "TestHelperFunc": {
    "test_pandas_to_array": [
      "self",
      "input_dtype"
    ],
    "test_as_tensor": [
      "self"
    ]
  },
  "TestBackendVersionCheck": {
    "test_warn_on_incompatible_backend": [
      "self",
      "capsys"
    ]
  },
  "TestTransformName": {
    "cases": [],
    "transform_name": [],
    "test_get_transformed_name": [
      "self"
    ],
    "test_is_transformed_name": [
      "self"
    ],
    "test_get_untransformed_name": [
      "self"
    ]
  },
  "TestUpdateStartVals": {
    "setup_method": [
      "self"
    ],
    "test_soft_update_all_present": [
      "self"
    ],
    "test_soft_update_one_missing": [
      "self"
    ],
    "test_soft_update_empty": [
      "self"
    ],
    "test_soft_update_transformed": [
      "self"
    ],
    "test_soft_update_parent": [
      "self"
    ]
  },
  "TestCheckStartVals": {
    "setup_method": [
      "self"
    ],
    "test_valid_start_point": [
      "self"
    ],
    "test_invalid_start_point": [
      "self"
    ],
    "test_invalid_variable_name": [
      "self"
    ]
  },
  "TestExceptions": {
    "test_shape_error": [
      "self"
    ],
    "test_dtype_error": [
      "self"
    ]
  },
  "test_hashing_of_rv_tuples": [],
  "test_hash_key": [],
  "test_adjust_precision": [],
  "test_guess_scaling": [],
  "test_mle_jacobian": [],
  "test_tune_not_inplace": [],
  "TestUtils": {
    "setup_method": [
      "self"
    ],
    "assertMatrixLabels": [
      "self",
      "m",
      "l",
      "mt",
      "lt"
    ],
    "test_numpy_init": [
      "self"
    ],
    "test_pandas_init": [
      "self"
    ],
    "test_dict_input": [
      "self"
    ],
    "test_list_input": [
      "self"
    ],
    "test_tensor_input": [
      "self"
    ],
    "test_user_mistakes": [
      "self"
    ]
  },
  "test_functions": [],
  "t_multigamma": [],
  "check_vals": [
    "fn1",
    "fn2"
  ],
  "DistTest": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "logp": [
      "self",
      "v"
    ]
  },
  "test_default_nan_fail": [],
  "test_default_empty_fail": [],
  "test_default_testval": [],
  "test_default_testval_nan": [],
  "test_default_a": [],
  "test_default_b": [],
  "test_default_c": [],
  "test_default_discrete_uniform": [],
  "test_discrete_uniform_negative": [],
  "test_categorical_mode": [],
  "test_split_node": [],
  "test_leaf_node": [],
  "test_bart": [],
  "test_available_splitting_rules": [],
  "test_model": [],
  "test_draw_value": [],
  "TestJointDistributionDrawValues": {
    "test_joint_distribution": [
      "self"
    ]
  },
  "_a": [],
  "_b": [],
  "_m": [],
  "_n": [],
  "_m2": [],
  "_n2": [],
  "test_updates_fast": [
    "opt",
    "loss_and_params",
    "kwargs",
    "getter"
  ],
  "TestTraceToDf": {
    "backend": [],
    "name": [],
    "shape": [],
    "test_trace_to_dataframe": [
      "self"
    ],
    "test_trace_to_dataframe_chain_arg": [
      "self"
    ]
  },
  "test_create_flat_names_0d": [],
  "test_create_flat_names_1d": [],
  "test_create_flat_names_2d": [],
  "test_create_flat_names_3d": [],
  "TestShared": {
    "test_deterministic": [
      "self"
    ],
    "test_sample": [
      "self"
    ]
  },
  "TestData": {
    "test_deterministic": [
      "self"
    ],
    "test_sample": [
      "self"
    ],
    "test_sample_posterior_predictive_after_set_data": [
      "self"
    ],
    "test_sample_after_set_data": [
      "self"
    ],
    "test_shared_data_as_index": [
      "self"
    ],
    "test_shared_data_as_rv_input": [
      "self"
    ],
    "test_shared_scalar_as_rv_input": [
      "self"
    ],
    "test_creation_of_data_outside_model_context": [
      "self"
    ],
    "test_set_data_to_non_data_container_variables": [
      "self"
    ],
    "test_model_to_graphviz_for_model_with_data_container": [
      "self"
    ],
    "test_explicit_coords": [
      "self"
    ],
    "test_implicit_coords_series": [
      "self"
    ],
    "test_implicit_coords_dataframe": [
      "self"
    ]
  },
  "test_data_naming": [],
  "radon_model": [],
  "TestSimpleModel": {
    "setup_class": [
      "cls"
    ],
    "test_inputs": [
      "self"
    ],
    "test_compute_graph": [
      "self"
    ],
    "test_plates": [
      "self"
    ],
    "test_graphviz": [
      "self"
    ]
  },
  "close_to": [
    "x",
    "v",
    "bound",
    "name"
  ],
  "close_to_logical": [
    "x",
    "v",
    "bound",
    "name"
  ],
  "Mean": {
    "__call__": [
      "self",
      "X"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ]
  },
  "Zero": {
    "__call__": [
      "self",
      "X"
    ]
  },
  "Constant": {
    "__init__": [
      "self",
      "c"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "Linear": {
    "__init__": [
      "self",
      "coeffs",
      "intercept"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "Add": {
    "__init__": [
      "self",
      "first_mean",
      "second_mean"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "Prod": {
    "__init__": [
      "self",
      "first_mean",
      "second_mean"
    ],
    "__call__": [
      "self",
      "X"
    ]
  },
  "Base": {
    "__init__": [
      "self",
      "mean_func",
      "cov_func"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "prior": [
      "self",
      "name",
      "X"
    ],
    "marginal_likelihood": [
      "self",
      "name",
      "X"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew"
    ],
    "predict": [
      "self",
      "Xnew",
      "point",
      "given",
      "diag"
    ]
  },
  "Latent": {
    "__init__": [
      "self",
      "mean_func",
      "cov_func"
    ],
    "_build_prior": [
      "self",
      "name",
      "X",
      "reparameterize"
    ],
    "prior": [
      "self",
      "name",
      "X",
      "reparameterize"
    ],
    "_get_given_vals": [
      "self",
      "given"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "X",
      "f",
      "cov_total",
      "mean_total"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "given"
    ]
  },
  "TP": {
    "__init__": [
      "self",
      "mean_func",
      "cov_func",
      "nu"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "_build_prior": [
      "self",
      "name",
      "X",
      "reparameterize"
    ],
    "prior": [
      "self",
      "name",
      "X",
      "reparameterize"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "X",
      "f"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew"
    ]
  },
  "Marginal": {
    "_build_marginal_likelihood": [
      "self",
      "X",
      "noise"
    ],
    "marginal_likelihood": [
      "self",
      "name",
      "X",
      "y",
      "noise",
      "is_observed"
    ],
    "_get_given_vals": [
      "self",
      "given"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "pred_noise",
      "diag",
      "X",
      "y",
      "noise",
      "cov_total",
      "mean_total"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "pred_noise",
      "given"
    ],
    "predict": [
      "self",
      "Xnew",
      "point",
      "diag",
      "pred_noise",
      "given"
    ],
    "predictt": [
      "self",
      "Xnew",
      "diag",
      "pred_noise",
      "given"
    ]
  },
  "MarginalSparse": {
    "_available_approx": [],
    "__init__": [
      "self",
      "mean_func",
      "cov_func",
      "approx"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "_build_marginal_likelihood_logp": [
      "self",
      "y",
      "X",
      "Xu",
      "sigma"
    ],
    "marginal_likelihood": [
      "self",
      "name",
      "X",
      "Xu",
      "y",
      "noise",
      "is_observed"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "pred_noise",
      "diag",
      "X",
      "Xu",
      "y",
      "sigma",
      "cov_total",
      "mean_total"
    ],
    "_get_given_vals": [
      "self",
      "given"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "pred_noise",
      "given"
    ]
  },
  "LatentKron": {
    "__init__": [
      "self",
      "mean_func",
      "cov_funcs"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "_build_prior": [
      "self",
      "name",
      "Xs"
    ],
    "prior": [
      "self",
      "name",
      "Xs"
    ],
    "_build_conditional": [
      "self",
      "Xnew"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew"
    ]
  },
  "MarginalKron": {
    "__init__": [
      "self",
      "mean_func",
      "cov_funcs"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "_build_marginal_likelihood": [
      "self",
      "Xs"
    ],
    "_check_inputs": [
      "self",
      "Xs",
      "y"
    ],
    "marginal_likelihood": [
      "self",
      "name",
      "Xs",
      "y",
      "sigma",
      "is_observed"
    ],
    "_build_conditional": [
      "self",
      "Xnew",
      "pred_noise",
      "diag"
    ],
    "conditional": [
      "self",
      "name",
      "Xnew",
      "pred_noise"
    ],
    "predict": [
      "self",
      "Xnew",
      "point",
      "diag",
      "pred_noise"
    ],
    "predictt": [
      "self",
      "Xnew",
      "diag",
      "pred_noise"
    ]
  },
  "cholesky": [],
  "solve_lower": [],
  "solve_upper": [],
  "solve": [],
  "infer_shape": [
    "X",
    "n_points"
  ],
  "stabilize": [
    "K"
  ],
  "kmeans_inducing_points": [
    "n_inducing",
    "X"
  ],
  "conditioned_vars": [
    "varnames"
  ],
  "plot_gp_dist": [
    "ax",
    "samples",
    "x",
    "plot_samples",
    "palette",
    "fill_alpha",
    "samples_alpha",
    "fill_kwargs",
    "samples_kwargs"
  ],
  "Covariance": {
    "__init__": [
      "self",
      "input_dim",
      "active_dims"
    ],
    "__call__": [
      "self",
      "X",
      "Xs",
      "diag"
    ],
    "diag": [
      "self",
      "X"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "_slice": [
      "self",
      "X",
      "Xs"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__pow__": [
      "self",
      "other"
    ],
    "__array_wrap__": [
      "self",
      "result"
    ]
  },
  "Combination": {
    "__init__": [
      "self",
      "factor_list"
    ],
    "merge_factors": [
      "self",
      "X",
      "Xs",
      "diag"
    ]
  },
  "Exponentiated": {
    "__init__": [
      "self",
      "kernel",
      "power"
    ],
    "__call__": [
      "self",
      "X",
      "Xs",
      "diag"
    ]
  },
  "Kron": {
    "__init__": [
      "self",
      "factor_list"
    ],
    "_split": [
      "self",
      "X",
      "Xs"
    ],
    "__call__": [
      "self",
      "X",
      "Xs",
      "diag"
    ]
  },
  "WhiteNoise": {
    "__init__": [
      "self",
      "sigma"
    ],
    "diag": [
      "self",
      "X"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Circular": {
    "__init__": [
      "self",
      "input_dim",
      "period",
      "tau",
      "active_dims"
    ],
    "dist": [
      "self",
      "X",
      "Xs"
    ],
    "weinland": [
      "self",
      "t"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "Stationary": {
    "__init__": [
      "self",
      "input_dim",
      "ls",
      "ls_inv",
      "active_dims"
    ],
    "square_dist": [
      "self",
      "X",
      "Xs"
    ],
    "euclidean_dist": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Periodic": {
    "__init__": [
      "self",
      "input_dim",
      "period",
      "ls",
      "ls_inv",
      "active_dims"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "ExpQuad": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "RatQuad": {
    "__init__": [
      "self",
      "input_dim",
      "alpha",
      "ls",
      "ls_inv",
      "active_dims"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Matern52": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Matern32": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Matern12": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Exponential": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Cosine": {
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Polynomial": {
    "__init__": [
      "self",
      "input_dim",
      "c",
      "d",
      "offset",
      "active_dims"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "WarpedInput": {
    "__init__": [
      "self",
      "input_dim",
      "cov_func",
      "warp_func",
      "args",
      "active_dims"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "Gibbs": {
    "__init__": [
      "self",
      "input_dim",
      "lengthscale_func",
      "args",
      "active_dims"
    ],
    "square_dist": [
      "self",
      "X",
      "Xs"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "ScaledCov": {
    "__init__": [
      "self",
      "input_dim",
      "cov_func",
      "scaling_func",
      "args",
      "active_dims"
    ],
    "diag": [
      "self",
      "X"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ]
  },
  "Coregion": {
    "__init__": [
      "self",
      "input_dim",
      "W",
      "kappa",
      "B",
      "active_dims"
    ],
    "full": [
      "self",
      "X",
      "Xs"
    ],
    "diag": [
      "self",
      "X"
    ]
  },
  "handle_args": [
    "func",
    "args"
  ],
  "map_args": [
    "func",
    "alias"
  ],
  "autocorrplot": [],
  "forestplot": [],
  "kdeplot": [],
  "energyplot": [],
  "densityplot": [],
  "pairplot": [],
  "traceplot": [],
  "compareplot": [],
  "plot_posterior_predictive_glm": [
    "trace",
    "eval",
    "lm",
    "samples"
  ],
  "any_to_tensor_and_labels": [
    "x",
    "labels"
  ],
  "Identity": {
    "__call__": [
      "self",
      "x"
    ]
  },
  "inverse": [],
  "exp": [],
  "Family": {
    "priors": [],
    "link": [],
    "__init__": [
      "self"
    ],
    "_get_priors": [
      "self",
      "model",
      "name"
    ],
    "create_likelihood": [
      "self",
      "name",
      "y_est",
      "y_data",
      "model"
    ],
    "__repr__": [
      "self"
    ]
  },
  "StudentT": {
    "link": [],
    "likelihood": [],
    "parent": [],
    "priors": []
  },
  "Normal": {
    "link": [],
    "likelihood": [],
    "parent": [],
    "priors": []
  },
  "Binomial": {
    "link": [],
    "likelihood": [],
    "parent": [],
    "priors": []
  },
  "Poisson": {
    "link": [],
    "likelihood": [],
    "parent": [],
    "priors": []
  },
  "NegativeBinomial": {
    "link": [],
    "likelihood": [],
    "parent": [],
    "priors": []
  },
  "LinearComponent": {
    "default_regressor_prior": [],
    "default_intercept_prior": [],
    "__init__": [
      "self",
      "x",
      "y",
      "intercept",
      "labels",
      "priors",
      "vars",
      "name",
      "model",
      "offset"
    ],
    "from_formula": [
      "cls",
      "formula",
      "data",
      "priors",
      "vars",
      "name",
      "model",
      "offset",
      "eval_env"
    ]
  },
  "GLM": {
    "__init__": [
      "self",
      "x",
      "y",
      "intercept",
      "labels",
      "priors",
      "vars",
      "family",
      "name",
      "model",
      "offset"
    ],
    "from_formula": [
      "cls",
      "formula",
      "data",
      "priors",
      "vars",
      "family",
      "name",
      "model",
      "offset",
      "eval_env"
    ]
  },
  "glm": [],
  "VariationalInferenceError": {},
  "ExplicitInferenceError": {},
  "AEVBInferenceError": {},
  "ParametrizationError": {},
  "GroupError": {},
  "BatchedGroupError": {},
  "LocalGroupError": {},
  "append_name": [
    "name"
  ],
  "node_property": [
    "f"
  ],
  "try_to_set_test_value": [
    "node_in",
    "node_out",
    "s"
  ],
  "ObjectiveUpdates": {
    "loss": []
  },
  "_warn_not_used": [
    "smth",
    "where"
  ],
  "ObjectiveFunction": {
    "__init__": [
      "self",
      "op",
      "tf"
    ],
    "obj_params": [],
    "test_params": [],
    "approx": [],
    "updates": [
      "self",
      "obj_n_mc",
      "tf_n_mc",
      "obj_optimizer",
      "test_optimizer",
      "more_obj_params",
      "more_tf_params",
      "more_updates",
      "more_replacements",
      "total_grad_norm_constraint"
    ],
    "add_test_updates": [
      "self",
      "updates",
      "tf_n_mc",
      "test_optimizer",
      "more_tf_params",
      "more_replacements",
      "total_grad_norm_constraint"
    ],
    "add_obj_updates": [
      "self",
      "updates",
      "obj_n_mc",
      "obj_optimizer",
      "more_obj_params",
      "more_replacements",
      "total_grad_norm_constraint"
    ],
    "step_function": [
      "self",
      "obj_n_mc",
      "tf_n_mc",
      "obj_optimizer",
      "test_optimizer",
      "more_obj_params",
      "more_tf_params",
      "more_updates",
      "more_replacements",
      "total_grad_norm_constraint",
      "score",
      "fn_kwargs"
    ],
    "score_function": [
      "self",
      "sc_n_mc",
      "more_replacements",
      "fn_kwargs"
    ],
    "__call__": [
      "self",
      "nmc"
    ]
  },
  "Operator": {
    "has_test_function": [],
    "returns_loss": [],
    "require_logq": [],
    "objective_class": [],
    "supports_aevb": [],
    "T": [],
    "__init__": [
      "self",
      "approx"
    ],
    "inputs": [],
    "logp": [],
    "varlogp": [],
    "datalogp": [],
    "logq": [],
    "logp_norm": [],
    "varlogp_norm": [],
    "datalogp_norm": [],
    "logq_norm": [],
    "model": [],
    "apply": [
      "self",
      "f"
    ],
    "__call__": [
      "self",
      "f"
    ],
    "__str__": [
      "self"
    ]
  },
  "collect_shared_to_list": [
    "params"
  ],
  "TestFunction": {
    "__init__": [
      "self"
    ],
    "params": [
      "self"
    ],
    "__call__": [
      "self",
      "z"
    ],
    "setup": [
      "self",
      "approx"
    ],
    "from_function": [
      "cls",
      "f"
    ]
  },
  "Group": {
    "shared_params": [],
    "symbolic_initial": [],
    "replacements": [],
    "input": [],
    "supports_batched": [],
    "has_logq": [],
    "initial_dist_name": [],
    "initial_dist_map": [],
    "__param_spec__": [],
    "short_name": [],
    "alias_names": [],
    "__param_registry": [],
    "__name_registry": [],
    "register": [
      "cls",
      "sbcls"
    ],
    "group_for_params": [
      "cls",
      "params"
    ],
    "group_for_short_name": [
      "cls",
      "name"
    ],
    "__new__": [
      "cls",
      "group",
      "vfam",
      "params"
    ],
    "__init__": [
      "self",
      "group",
      "vfam",
      "params",
      "random_seed",
      "model",
      "local",
      "rowwise",
      "options"
    ],
    "get_param_spec_for": [
      "cls"
    ],
    "_check_user_params": [
      "self"
    ],
    "_initial_type": [
      "self",
      "name"
    ],
    "_input_type": [
      "self",
      "name"
    ],
    "__init_group__": [
      "self",
      "group"
    ],
    "_finalize_init": [
      "self"
    ],
    "local": [],
    "batched": [],
    "params_dict": [
      "self"
    ],
    "params": [
      "self"
    ],
    "_new_initial_shape": [
      "self",
      "size",
      "dim",
      "more_replacements"
    ],
    "bdim": [
      "self"
    ],
    "ndim": [
      "self"
    ],
    "ddim": [
      "self"
    ],
    "_new_initial": [
      "self",
      "size",
      "deterministic",
      "more_replacements"
    ],
    "symbolic_random": [
      "self"
    ],
    "symbolic_random2d": [
      "self"
    ],
    "set_size_and_deterministic": [
      "self",
      "node",
      "s",
      "d",
      "more_replacements"
    ],
    "to_flat_input": [
      "self",
      "node"
    ],
    "symbolic_sample_over_posterior": [
      "self",
      "node"
    ],
    "symbolic_single_sample": [
      "self",
      "node"
    ],
    "make_size_and_deterministic_replacements": [
      "self",
      "s",
      "d",
      "more_replacements"
    ],
    "symbolic_normalizing_constant": [
      "self"
    ],
    "symbolic_logq_not_scaled": [
      "self"
    ],
    "symbolic_logq": [
      "self"
    ],
    "logq": [
      "self"
    ],
    "logq_norm": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "std": [
      "self"
    ],
    "cov": [
      "self"
    ],
    "mean": [
      "self"
    ]
  },
  "group_for_params": [],
  "group_for_short_name": [],
  "Approximation": {
    "__init__": [
      "self",
      "groups",
      "model"
    ],
    "has_logq": [
      "self"
    ],
    "collect": [
      "self",
      "item",
      "part"
    ],
    "inputs": [],
    "symbolic_randoms": [],
    "scale_cost_to_minibatch": [
      "self",
      "value"
    ],
    "symbolic_normalizing_constant": [
      "self"
    ],
    "symbolic_logq": [
      "self"
    ],
    "logq": [
      "self"
    ],
    "logq_norm": [
      "self"
    ],
    "_sized_symbolic_varlogp_and_datalogp": [
      "self"
    ],
    "sized_symbolic_varlogp": [
      "self"
    ],
    "sized_symbolic_datalogp": [
      "self"
    ],
    "sized_symbolic_logp": [
      "self"
    ],
    "logp": [
      "self"
    ],
    "varlogp": [
      "self"
    ],
    "datalogp": [
      "self"
    ],
    "_single_symbolic_varlogp_and_datalogp": [
      "self"
    ],
    "single_symbolic_varlogp": [
      "self"
    ],
    "single_symbolic_datalogp": [
      "self"
    ],
    "single_symbolic_logp": [
      "self"
    ],
    "logp_norm": [
      "self"
    ],
    "varlogp_norm": [
      "self"
    ],
    "datalogp_norm": [
      "self"
    ],
    "replacements": [
      "self"
    ],
    "make_size_and_deterministic_replacements": [
      "self",
      "s",
      "d",
      "more_replacements"
    ],
    "set_size_and_deterministic": [
      "self",
      "node",
      "s",
      "d",
      "more_replacements"
    ],
    "to_flat_input": [
      "self",
      "node"
    ],
    "symbolic_sample_over_posterior": [
      "self",
      "node"
    ],
    "symbolic_single_sample": [
      "self",
      "node"
    ],
    "get_optimization_replacements": [
      "self",
      "s",
      "d"
    ],
    "sample_node": [
      "self",
      "node",
      "size",
      "deterministic",
      "more_replacements"
    ],
    "rslice": [
      "self",
      "name"
    ],
    "sample_dict_fn": [
      "self"
    ],
    "sample": [
      "self",
      "draws",
      "include_transformed"
    ],
    "ndim": [
      "self"
    ],
    "ddim": [
      "self"
    ],
    "has_local": [
      "self"
    ],
    "has_global": [
      "self"
    ],
    "has_batched": [
      "self"
    ],
    "symbolic_random": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "all_histograms": [
      "self"
    ],
    "any_histograms": [
      "self"
    ],
    "joint_histogram": [
      "self"
    ],
    "params": [
      "self"
    ]
  },
  "Callback": {
    "__call__": [
      "self",
      "approx",
      "loss",
      "i"
    ]
  },
  "relative": [
    "current",
    "prev",
    "eps"
  ],
  "absolute": [
    "current",
    "prev"
  ],
  "_diff": [],
  "CheckParametersConvergence": {
    "__init__": [
      "self",
      "every",
      "tolerance",
      "diff",
      "ord"
    ],
    "__call__": [
      "self",
      "approx",
      "_",
      "i"
    ],
    "flatten_shared": [
      "shared_list"
    ]
  },
  "Tracker": {
    "__init__": [
      "self"
    ],
    "record": [
      "self",
      "approx",
      "hist",
      "i"
    ],
    "clear": [
      "self"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "__call__": []
  },
  "Formula": {
    "__init__": [
      "self",
      "formula"
    ],
    "__call__": [
      "self",
      "z0",
      "dim",
      "jitter",
      "params",
      "batch_size"
    ],
    "__reduce__": [
      "self"
    ],
    "__latex__": [
      "self"
    ],
    "__repr__": [],
    "_latex_repr_": [],
    "get_param_spec_for": [
      "self"
    ]
  },
  "seems_like_formula": [
    "formula"
  ],
  "seems_like_flow_params": [
    "params"
  ],
  "AbstractFlow": {
    "shared_params": [],
    "__param_spec__": [],
    "short_name": [],
    "__param_registry": [],
    "__name_registry": [],
    "register": [
      "cls",
      "sbcls"
    ],
    "flow_for_params": [
      "cls",
      "params"
    ],
    "flow_for_short_name": [
      "cls",
      "name"
    ],
    "__init__": [
      "self",
      "z0",
      "dim",
      "jitter",
      "batch_size",
      "local"
    ],
    "add_param": [
      "self",
      "user",
      "name",
      "ref",
      "dtype"
    ],
    "params": [
      "self"
    ],
    "all_params": [
      "self"
    ],
    "sum_logdets": [
      "self"
    ],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ],
    "forward_pass": [
      "self",
      "z0"
    ],
    "__call__": [],
    "root": [
      "self"
    ],
    "formula": [
      "self"
    ],
    "isroot": [
      "self"
    ],
    "batched": [
      "self"
    ],
    "get_param_spec_for": [
      "cls"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "flow_for_params": [],
  "flow_for_short_name": [],
  "FlowFn": {
    "fn": [],
    "inv": [],
    "deriv": [],
    "__call__": [
      "self"
    ]
  },
  "LinearFlow": {
    "__param_spec__": [],
    "__init__": [
      "self",
      "h",
      "u",
      "w",
      "b"
    ],
    "u": [],
    "w": [],
    "b": [],
    "make_uw": [
      "self",
      "u",
      "w"
    ],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ]
  },
  "Tanh": {
    "fn": [],
    "inv": [],
    "deriv": []
  },
  "PlanarFlow": {
    "short_name": [],
    "__init__": [
      "self"
    ],
    "make_uw": [
      "self",
      "u",
      "w"
    ]
  },
  "ReferencePointFlow": {
    "__param_spec__": [],
    "__init__": [
      "self",
      "h",
      "a",
      "b",
      "z_ref"
    ],
    "a": [],
    "b": [],
    "z_ref": [],
    "make_ab": [
      "self",
      "a",
      "b"
    ],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ]
  },
  "Radial": {
    "fn": [],
    "inv": [],
    "deriv": []
  },
  "RadialFlow": {
    "short_name": [],
    "__init__": [
      "self"
    ],
    "make_ab": [
      "self",
      "a",
      "b"
    ]
  },
  "LocFlow": {
    "__param_spec__": [],
    "short_name": [],
    "__init__": [
      "self",
      "loc"
    ],
    "loc": [],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ]
  },
  "ScaleFlow": {
    "__param_spec__": [],
    "short_name": [],
    "__init__": [
      "self",
      "rho"
    ],
    "log_scale": [],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ]
  },
  "HouseholderFlow": {
    "__param_spec__": [],
    "short_name": [],
    "__init__": [
      "self",
      "v"
    ],
    "forward": [
      "self"
    ],
    "logdet": [
      "self"
    ]
  },
  "KL": {
    "__init__": [
      "self",
      "approx",
      "beta"
    ],
    "apply": [
      "self",
      "f"
    ]
  },
  "KSDObjective": {
    "__init__": [
      "self",
      "op",
      "tf"
    ],
    "__call__": [
      "self",
      "nmc"
    ]
  },
  "KSD": {
    "has_test_function": [],
    "returns_loss": [],
    "require_logq": [],
    "objective_class": [],
    "__init__": [
      "self",
      "approx",
      "temperature"
    ],
    "apply": [
      "self",
      "f"
    ]
  },
  "get_or_compute_grads": [
    "loss_or_grads",
    "params"
  ],
  "_get_call_kwargs": [
    "_locals_"
  ],
  "sgd": [
    "loss_or_grads",
    "params",
    "learning_rate"
  ],
  "apply_momentum": [
    "updates",
    "params",
    "momentum"
  ],
  "momentum": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "momentum"
  ],
  "apply_nesterov_momentum": [
    "updates",
    "params",
    "momentum"
  ],
  "nesterov_momentum": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "momentum"
  ],
  "adagrad": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "epsilon"
  ],
  "adagrad_window": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "epsilon",
    "n_win"
  ],
  "rmsprop": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "rho",
    "epsilon"
  ],
  "adadelta": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "rho",
    "epsilon"
  ],
  "adam": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "beta1",
    "beta2",
    "epsilon"
  ],
  "adamax": [
    "loss_or_grads",
    "params",
    "learning_rate",
    "beta1",
    "beta2",
    "epsilon"
  ],
  "norm_constraint": [
    "tensor_var",
    "max_norm",
    "norm_axes",
    "epsilon"
  ],
  "total_norm_constraint": [
    "tensor_vars",
    "max_norm",
    "epsilon",
    "return_norm"
  ],
  "Stein": {
    "__init__": [
      "self",
      "approx",
      "kernel",
      "use_histogram",
      "temperature"
    ],
    "input_joint_matrix": [
      "self"
    ],
    "approx_symbolic_matrices": [
      "self"
    ],
    "dlogp": [
      "self"
    ],
    "grad": [
      "self"
    ],
    "density_part_grad": [
      "self"
    ],
    "repulsive_part_grad": [
      "self"
    ],
    "Kxy": [
      "self"
    ],
    "dxkxy": [
      "self"
    ],
    "logp_norm": [
      "self"
    ],
    "_kernel": [
      "self"
    ]
  },
  "Kernel": {},
  "RBF": {
    "__call__": [
      "self",
      "X"
    ]
  },
  "rbf": [],
  "MeanFieldGroup": {
    "__param_spec__": [],
    "short_name": [],
    "alias_names": [],
    "mean": [
      "self"
    ],
    "rho": [
      "self"
    ],
    "cov": [
      "self"
    ],
    "std": [
      "self"
    ],
    "__init_group__": [
      "self",
      "group"
    ],
    "create_shared_params": [
      "self",
      "start"
    ],
    "symbolic_random": [
      "self"
    ],
    "symbolic_logq_not_scaled": [
      "self"
    ]
  },
  "FullRankGroup": {
    "__param_spec__": [],
    "short_name": [],
    "alias_names": [],
    "__init_group__": [
      "self",
      "group"
    ],
    "create_shared_params": [
      "self",
      "start"
    ],
    "L": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "cov": [
      "self"
    ],
    "std": [
      "self"
    ],
    "num_tril_entries": [
      "self"
    ],
    "tril_indices": [
      "self"
    ],
    "symbolic_logq_not_scaled": [
      "self"
    ],
    "symbolic_random": [
      "self"
    ]
  },
  "EmpiricalGroup": {
    "supports_batched": [],
    "has_logq": [],
    "__param_spec__": [],
    "short_name": [],
    "__init_group__": [
      "self",
      "group"
    ],
    "create_shared_params": [
      "self",
      "trace",
      "size",
      "jitter",
      "start"
    ],
    "_check_trace": [
      "self"
    ],
    "randidx": [
      "self",
      "size"
    ],
    "_new_initial": [
      "self",
      "size",
      "deterministic",
      "more_replacements"
    ],
    "symbolic_random": [
      "self"
    ],
    "histogram": [
      "self"
    ],
    "mean": [
      "self"
    ],
    "cov": [
      "self"
    ],
    "std": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "NormalizingFlowGroup": {
    "default_flow": [],
    "__init_group__": [
      "self",
      "group"
    ],
    "_check_user_params": [
      "self"
    ],
    "shared_params": [
      "self",
      "value"
    ],
    "params": [
      "self"
    ],
    "symbolic_logq_not_scaled": [
      "self"
    ],
    "symbolic_random": [
      "self"
    ],
    "bdim": [
      "self"
    ],
    "get_param_spec_for": [
      "cls",
      "flow"
    ]
  },
  "sample_approx": [
    "approx",
    "draws",
    "include_transformed"
  ],
  "SingleGroupApproximation": {
    "_group_class": [],
    "__init__": [
      "self"
    ],
    "__getattr__": [
      "self",
      "item"
    ],
    "__dir__": [
      "self"
    ]
  },
  "MeanField": {
    "__doc__": [],
    "_group_class": []
  },
  "FullRank": {
    "__doc__": [],
    "_group_class": []
  },
  "Empirical": {
    "__doc__": [],
    "_group_class": [],
    "__init__": [
      "self",
      "trace",
      "size"
    ],
    "evaluate_over_trace": [
      "self",
      "node"
    ]
  },
  "NormalizingFlow": {
    "__doc__": [],
    "_group_class": [],
    "__init__": [
      "self",
      "flow"
    ]
  },
  "Inference": {
    "__init__": [
      "self",
      "op",
      "approx",
      "tf"
    ],
    "approx": [],
    "_maybe_score": [
      "self",
      "score"
    ],
    "run_profiling": [
      "self",
      "n",
      "score"
    ],
    "fit": [
      "self",
      "n",
      "score",
      "callbacks",
      "progressbar"
    ],
    "_iterate_without_loss": [
      "self",
      "s",
      "_",
      "step_func",
      "progress",
      "callbacks"
    ],
    "_iterate_with_loss": [
      "self",
      "s",
      "n",
      "step_func",
      "progress",
      "callbacks"
    ],
    "refine": [
      "self",
      "n",
      "progressbar"
    ]
  },
  "KLqp": {
    "__init__": [
      "self",
      "approx",
      "beta"
    ]
  },
  "ADVI": {
    "__init__": [
      "self"
    ]
  },
  "FullRankADVI": {
    "__init__": [
      "self"
    ]
  },
  "ImplicitGradient": {
    "__init__": [
      "self",
      "approx",
      "estimator",
      "kernel"
    ]
  },
  "SVGD": {
    "__init__": [
      "self",
      "n_particles",
      "jitter",
      "model",
      "start",
      "random_seed",
      "estimator",
      "kernel"
    ]
  },
  "ASVGD": {
    "__init__": [
      "self",
      "approx",
      "estimator",
      "kernel"
    ],
    "fit": [
      "self",
      "n",
      "score",
      "callbacks",
      "progressbar",
      "obj_n_mc"
    ],
    "run_profiling": [
      "self",
      "n",
      "score",
      "obj_n_mc"
    ]
  },
  "NFVI": {
    "__init__": [
      "self"
    ]
  },
  "fit": [
    "n",
    "local_rv",
    "method",
    "model",
    "random_seed",
    "start",
    "inf_kwargs"
  ],
  "find_MAP": [
    "start",
    "vars",
    "method",
    "return_raw",
    "include_transformed",
    "progressbar",
    "maxeval",
    "model"
  ],
  "allfinite": [
    "x"
  ],
  "nan_to_high": [
    "x"
  ],
  "allinmodel": [
    "vars",
    "model"
  ],
  "CostFuncWrapper": {
    "__init__": [
      "self",
      "maxeval",
      "progressbar",
      "logp_func",
      "dlogp_func"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "update_progress_desc": [
      "self",
      "neg_value",
      "grad"
    ]
  },
  "fixed_hessian": [
    "point",
    "vars",
    "model"
  ],
  "find_hessian": [
    "point",
    "vars",
    "model"
  ],
  "find_hessian_diag": [
    "point",
    "vars",
    "model"
  ],
  "guess_scaling": [
    "point",
    "vars",
    "model",
    "scaling_bound"
  ],
  "adjust_scaling": [
    "s",
    "scaling_bound"
  ],
  "adjust_precision": [
    "tau",
    "scaling_bound"
  ],
  "bound": [
    "a",
    "l",
    "u"
  ],
  "eig_recompose": [
    "val",
    "vec"
  ],
  "trace_cov": [
    "trace",
    "vars",
    "model"
  ],
  "_QuadFormBase": {
    "__init__": [
      "self",
      "mu",
      "cov",
      "chol",
      "tau",
      "lower"
    ],
    "_quaddist": [
      "self",
      "value"
    ],
    "_quaddist_chol": [
      "self",
      "delta"
    ],
    "_quaddist_cov": [
      "self",
      "delta"
    ],
    "_quaddist_tau": [
      "self",
      "delta"
    ],
    "_cov_param_for_repr": [
      "self"
    ]
  },
  "MvNormal": {
    "__init__": [
      "self",
      "mu",
      "cov",
      "tau",
      "chol",
      "lower"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "MvStudentT": {
    "__init__": [
      "self",
      "nu",
      "Sigma",
      "mu",
      "cov",
      "tau",
      "chol",
      "lower"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Dirichlet": {
    "__init__": [
      "self",
      "a",
      "transform"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Multinomial": {
    "__init__": [
      "self",
      "n",
      "p"
    ],
    "_random": [
      "self",
      "n",
      "p",
      "size",
      "raw_size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "x"
    ]
  },
  "DirichletMultinomial": {
    "__init__": [
      "self",
      "n",
      "a",
      "shape"
    ],
    "_random": [
      "self",
      "n",
      "a",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "posdef": [
    "AA"
  ],
  "PosDefMatrix": {
    "__props__": [],
    "make_node": [
      "self",
      "x"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "outputs"
    ],
    "infer_shape": [
      "self",
      "fgraph",
      "node",
      "shapes"
    ],
    "grad": [
      "self",
      "inp",
      "grads"
    ],
    "__str__": [
      "self"
    ]
  },
  "matrix_pos_def": [],
  "Wishart": {
    "__init__": [
      "self",
      "nu",
      "V"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "X"
    ]
  },
  "WishartBartlett": [
    "name",
    "S",
    "nu",
    "is_cholesky",
    "return_cholesky",
    "testval"
  ],
  "_lkj_normalizing_constant": [
    "eta",
    "n"
  ],
  "_LKJCholeskyCov": {
    "__init__": [
      "self",
      "eta",
      "n",
      "sd_dist"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_random": [
      "self",
      "n",
      "eta",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "LKJCholeskyCov": [
    "name",
    "eta",
    "n",
    "sd_dist",
    "compute_corr",
    "store_in_trace"
  ],
  "LKJCorr": {
    "__init__": [
      "self",
      "eta",
      "n",
      "p",
      "transform"
    ],
    "_random": [
      "self",
      "n",
      "eta",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "MatrixNormal": {
    "__init__": [
      "self",
      "mu",
      "rowcov",
      "rowchol",
      "rowtau",
      "colcov",
      "colchol",
      "coltau",
      "shape"
    ],
    "_setup_matrices": [
      "self",
      "colcov",
      "colchol",
      "coltau",
      "rowcov",
      "rowchol",
      "rowtau"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_trquaddist": [
      "self",
      "value"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "KroneckerNormal": {
    "__init__": [
      "self",
      "mu",
      "covs",
      "chols",
      "evds",
      "sigma"
    ],
    "_setup": [
      "self",
      "covs",
      "chols",
      "evds",
      "sigma"
    ],
    "_setup_evd": [
      "self",
      "eigh_iterable"
    ],
    "_setup_random": [
      "self"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_quaddist": [
      "self",
      "value"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "all_discrete": [
    "comp_dists"
  ],
  "Mixture": {
    "__init__": [
      "self",
      "w",
      "comp_dists"
    ],
    "comp_dists": [
      "self",
      "comp_dists"
    ],
    "_comp_dist_random_wrapper": [
      "random"
    ],
    "_comp_logp": [
      "self",
      "value"
    ],
    "_comp_means": [
      "self"
    ],
    "_comp_modes": [
      "self"
    ],
    "_comp_samples": [
      "self",
      "point",
      "size",
      "comp_dist_shapes",
      "broadcast_shape"
    ],
    "infer_comp_dist_shapes": [
      "self",
      "point"
    ],
    "logp": [
      "self",
      "value"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "NormalMixture": {
    "__init__": [
      "self",
      "w",
      "mu",
      "sigma",
      "tau",
      "sd",
      "comp_shape"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "MixtureSameFamily": {
    "__init__": [
      "self",
      "w",
      "comp_dists",
      "mixture_axis"
    ],
    "logp": [
      "self",
      "value"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "AR1": {
    "__init__": [
      "self",
      "k",
      "tau_e"
    ],
    "logp": [
      "self",
      "x"
    ]
  },
  "AR": {
    "__init__": [
      "self",
      "rho",
      "sigma",
      "tau",
      "constant",
      "init",
      "sd"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "GaussianRandomWalk": {
    "__init__": [
      "self",
      "tau",
      "init",
      "sigma",
      "mu",
      "sd"
    ],
    "_mu_and_sigma": [
      "self",
      "mu",
      "sigma"
    ],
    "logp": [
      "self",
      "x"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "sigma",
      "mu",
      "size",
      "sample_shape"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "GARCH11": {
    "__init__": [
      "self",
      "omega",
      "alpha_1",
      "beta_1",
      "initial_vol"
    ],
    "get_volatility": [
      "self",
      "x"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "EulerMaruyama": {
    "__init__": [
      "self",
      "dt",
      "sde_fn",
      "sde_pars"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "MvGaussianRandomWalk": {
    "__init__": [
      "self",
      "mu",
      "cov",
      "tau",
      "chol",
      "lower",
      "init"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "random": [
      "self",
      "point",
      "size"
    ]
  },
  "MvStudentTRandomWalk": {
    "__init__": [
      "self",
      "nu"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Tree": {
    "__init__": [
      "self",
      "tree_id",
      "num_observations"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__setitem__": [
      "self",
      "index",
      "node"
    ],
    "copy": [
      "self"
    ],
    "get_node": [
      "self",
      "index"
    ],
    "set_node": [
      "self",
      "index",
      "node"
    ],
    "delete_node": [
      "self",
      "index"
    ],
    "predict_output": [
      "self"
    ],
    "predict_out_of_sample": [
      "self",
      "x"
    ],
    "_traverse_tree": [
      "self",
      "x",
      "node_index"
    ],
    "grow_tree": [
      "self",
      "index_leaf_node",
      "new_split_node",
      "new_left_node",
      "new_right_node"
    ],
    "init_tree": [
      "tree_id",
      "leaf_node_value",
      "idx_data_points"
    ]
  },
  "BaseNode": {
    "__init__": [
      "self",
      "index"
    ],
    "get_idx_parent_node": [
      "self"
    ],
    "get_idx_left_child": [
      "self"
    ],
    "get_idx_right_child": [
      "self"
    ]
  },
  "SplitNode": {
    "__init__": [
      "self",
      "index",
      "idx_split_variable",
      "split_value"
    ]
  },
  "LeafNode": {
    "__init__": [
      "self",
      "index",
      "value",
      "idx_data_points"
    ]
  },
  "Simulator": {
    "__init__": [
      "self",
      "function"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_str_repr": [
      "self",
      "name",
      "dist",
      "formatting"
    ]
  },
  "gaussian": [
    "epsilon",
    "obs_data",
    "sim_data"
  ],
  "laplace": [
    "epsilon",
    "obs_data",
    "sim_data"
  ],
  "KullbackLiebler": {
    "__init__": [
      "self",
      "obs_data"
    ],
    "__call__": [
      "self",
      "epsilon",
      "obs_data",
      "sim_data"
    ]
  },
  "HasName": {},
  "_TraceDict": {
    "__init__": [
      "self",
      "point_list",
      "multi_trace",
      "dict_"
    ],
    "__len__": [
      "self"
    ],
    "_extract_slice": [
      "self",
      "slc"
    ],
    "__getitem__": [
      "self",
      "item"
    ]
  },
  "fast_sample_posterior_predictive": [
    "trace",
    "samples",
    "model",
    "var_names",
    "keep_size",
    "random_seed"
  ],
  "posterior_predictive_draw_values": [
    "vars",
    "trace",
    "samples"
  ],
  "_PosteriorPredictiveSampler": {
    "__init__": [
      "self",
      "vars",
      "trace",
      "samples",
      "model",
      "size"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "draw_values": [
      "self"
    ],
    "init": [
      "self"
    ],
    "make_graph": [
      "self"
    ],
    "draw_value": [
      "self",
      "param",
      "trace",
      "givens"
    ]
  },
  "_param_shape": [
    "var_desig",
    "model"
  ],
  "Transform": {
    "name": [],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "backward": [
      "self",
      "z"
    ],
    "jacobian_det": [
      "self",
      "x"
    ],
    "apply": [
      "self",
      "dist"
    ],
    "__str__": [
      "self"
    ]
  },
  "ElemwiseTransform": {
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "TransformedDistribution": {
    "__init__": [
      "self",
      "dist",
      "transform"
    ],
    "logp": [
      "self",
      "x"
    ],
    "logp_nojac": [
      "self",
      "x"
    ],
    "_repr_latex_": [
      "self"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "transform": [],
  "Log": {
    "name": [],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "log": [],
  "LogExpM1": {
    "name": [],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "log_exp_m1": [],
  "LogOdds": {
    "name": [],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ]
  },
  "logodds": [],
  "Interval": {
    "name": [],
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "interval": [],
  "LowerBound": {
    "name": [],
    "__init__": [
      "self",
      "a"
    ],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "lowerbound": [],
  "UpperBound": {
    "name": [],
    "__init__": [
      "self",
      "b"
    ],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "upperbound": [],
  "Ordered": {
    "name": [],
    "backward": [
      "self",
      "y"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "y"
    ]
  },
  "ordered": [],
  "SumTo1": {
    "name": [],
    "backward": [
      "self",
      "y"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "jacobian_det": [
      "self",
      "x"
    ]
  },
  "sum_to_1": [],
  "StickBreaking": {
    "name": [],
    "__init__": [
      "self",
      "eps"
    ],
    "forward": [
      "self",
      "x_"
    ],
    "forward_val": [
      "self",
      "x_",
      "point"
    ],
    "backward": [
      "self",
      "y_"
    ],
    "jacobian_det": [
      "self",
      "y_"
    ]
  },
  "stick_breaking": [],
  "circular": [],
  "CholeskyCovPacked": {
    "name": [],
    "__init__": [
      "self",
      "n"
    ],
    "backward": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "y"
    ],
    "forward_val": [
      "self",
      "y",
      "point"
    ],
    "jacobian_det": [
      "self",
      "y"
    ]
  },
  "Chain": {
    "__init__": [
      "self",
      "transform_list"
    ],
    "forward": [
      "self",
      "x"
    ],
    "forward_val": [
      "self",
      "x",
      "point"
    ],
    "backward": [
      "self",
      "y"
    ],
    "jacobian_det": [
      "self",
      "y"
    ]
  },
  "PositiveContinuous": {
    "__init__": [
      "self",
      "transform"
    ]
  },
  "UnitContinuous": {
    "__init__": [
      "self",
      "transform"
    ]
  },
  "BoundedContinuous": {
    "__init__": [
      "self",
      "transform",
      "lower",
      "upper"
    ]
  },
  "assert_negative_support": [
    "var",
    "label",
    "distname",
    "value"
  ],
  "get_tau_sigma": [
    "tau",
    "sigma"
  ],
  "Uniform": {
    "__init__": [
      "self",
      "lower",
      "upper"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Flat": {
    "__init__": [
      "self"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "HalfFlat": {
    "__init__": [
      "self"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "TruncatedNormal": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "tau",
      "lower",
      "upper",
      "transform",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "mu",
      "sigma",
      "lower",
      "upper",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_normalization": [
      "self"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "HalfNormal": {
    "__init__": [
      "self",
      "sigma",
      "tau",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Wald": {
    "__init__": [
      "self",
      "mu",
      "lam",
      "phi",
      "alpha"
    ],
    "get_mu_lam_phi": [
      "self",
      "mu",
      "lam",
      "phi"
    ],
    "_random": [
      "self",
      "mu",
      "lam",
      "alpha",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Beta": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "mu",
      "sigma",
      "sd"
    ],
    "get_alpha_beta": [
      "self",
      "alpha",
      "beta",
      "mu",
      "sigma"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Kumaraswamy": {
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "_random": [
      "self",
      "a",
      "b",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "Laplace": {
    "__init__": [
      "self",
      "mu",
      "b"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "AsymmetricLaplace": {
    "__init__": [
      "self",
      "b",
      "kappa",
      "mu"
    ],
    "_random": [
      "self",
      "b",
      "kappa",
      "mu",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "LogNormal": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "tau",
      "sd"
    ],
    "_random": [
      "self",
      "mu",
      "tau",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Lognormal": [],
  "Pareto": {
    "__init__": [
      "self",
      "alpha",
      "m",
      "transform"
    ],
    "_random": [
      "self",
      "alpha",
      "m",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Cauchy": {
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "_random": [
      "self",
      "alpha",
      "beta",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "HalfCauchy": {
    "__init__": [
      "self",
      "beta"
    ],
    "_random": [
      "self",
      "beta",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Gamma": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "mu",
      "sigma",
      "sd"
    ],
    "get_alpha_beta": [
      "self",
      "alpha",
      "beta",
      "mu",
      "sigma"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "InverseGamma": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "mu",
      "sigma",
      "sd"
    ],
    "_calculate_mean": [
      "self"
    ],
    "_get_alpha_beta": [
      "alpha",
      "beta",
      "mu",
      "sigma"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "ChiSquared": {
    "__init__": [
      "self",
      "nu"
    ]
  },
  "Weibull": {
    "__init__": [
      "self",
      "alpha",
      "beta"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "HalfStudentT": {
    "__init__": [
      "self",
      "nu",
      "sigma",
      "lam",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "ExGaussian": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "nu",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "VonMises": {
    "__init__": [
      "self",
      "mu",
      "kappa",
      "transform"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "SkewNormal": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "tau",
      "alpha",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Triangular": {
    "__init__": [
      "self",
      "lower",
      "upper",
      "c"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "c",
      "lower",
      "upper",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Gumbel": {
    "__init__": [
      "self",
      "mu",
      "beta"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Rice": {
    "__init__": [
      "self",
      "nu",
      "sigma",
      "b",
      "sd"
    ],
    "get_nu_b": [
      "self",
      "nu",
      "b",
      "sigma"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "nu",
      "sigma",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Logistic": {
    "__init__": [
      "self",
      "mu",
      "s"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "LogitNormal": {
    "__init__": [
      "self",
      "mu",
      "sigma",
      "tau",
      "sd"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Interpolated": {
    "__init__": [
      "self",
      "x_points",
      "pdf_points"
    ],
    "_argcdf": [
      "self",
      "p"
    ],
    "_random": [
      "self",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Moyal": {
    "__init__": [
      "self",
      "mu",
      "sigma"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "to_tuple": [
    "shape"
  ],
  "_check_shape_type": [
    "shape"
  ],
  "shapes_broadcasting": [],
  "broadcast_dist_samples_shape": [
    "shapes",
    "size"
  ],
  "get_broadcastable_dist_samples": [
    "samples",
    "size",
    "must_bcast_with",
    "return_out_shape"
  ],
  "broadcast_distribution_samples": [
    "samples",
    "size"
  ],
  "broadcast_dist_samples_to": [
    "to_shape",
    "samples",
    "size"
  ],
  "_Bounded": {
    "__init__": [
      "self",
      "distribution",
      "lower",
      "upper",
      "default"
    ],
    "logp": [
      "self",
      "value"
    ],
    "_random": [
      "self",
      "lower",
      "upper",
      "point",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "_distr_name_for_repr": [
      "self"
    ],
    "_str_repr": [
      "self"
    ]
  },
  "_DiscreteBounded": {
    "__init__": [
      "self",
      "distribution",
      "lower",
      "upper",
      "transform"
    ]
  },
  "_ContinuousBounded": {
    "__init__": [
      "self",
      "distribution",
      "lower",
      "upper",
      "transform"
    ]
  },
  "Bound": {
    "__init__": [
      "self",
      "distribution",
      "lower",
      "upper"
    ],
    "__call__": [
      "self",
      "name"
    ],
    "dist": [
      "self"
    ]
  },
  "scalar_gammaln": [],
  "gammaln": [],
  "multigammaln": [
    "a",
    "p"
  ],
  "log_i0": [
    "x"
  ],
  "scalar_psi": [],
  "psi": [],
  "BaseBART": {
    "__init__": [
      "self",
      "X",
      "Y",
      "m",
      "alpha",
      "split_prior",
      "inv_link",
      "jitter"
    ],
    "preprocess_XY": [
      "self",
      "X",
      "Y"
    ],
    "init_list_of_trees": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__repr_latex": [
      "self"
    ],
    "get_available_splitting_rules": [
      "self",
      "idx_data_points_split_node",
      "idx_split_variable"
    ],
    "grow_tree": [
      "self",
      "tree",
      "index_leaf_node"
    ],
    "get_new_idx_data_points": [
      "self",
      "current_split_node",
      "idx_data_points"
    ],
    "get_residuals": [
      "self"
    ],
    "draw_leaf_value": [
      "self",
      "idx_data_points"
    ],
    "predict": [
      "self",
      "X_new"
    ]
  },
  "compute_prior_probability": [
    "alpha"
  ],
  "fast_mean": [],
  "discrete_uniform_sampler": [
    "upper_value"
  ],
  "SampleSplittingVariable": {
    "__init__": [
      "self",
      "prior",
      "num_variates"
    ],
    "rvs": [
      "self"
    ]
  },
  "BART": {
    "__init__": [
      "self",
      "X",
      "Y",
      "m",
      "alpha",
      "split_prior",
      "inv_link",
      "jitter"
    ],
    "_str_repr": [
      "self",
      "name",
      "dist",
      "formatting"
    ]
  },
  "f": [],
  "c": [],
  "_beta_clip_values": [],
  "alltrue_elemwise": [
    "vals"
  ],
  "alltrue_scalar": [
    "vals"
  ],
  "factln": [
    "n"
  ],
  "binomln": [
    "n",
    "k"
  ],
  "betaln": [
    "x",
    "y"
  ],
  "std_cdf": [
    "x"
  ],
  "normal_lcdf": [
    "mu",
    "sigma",
    "x"
  ],
  "normal_lccdf": [
    "mu",
    "sigma",
    "x"
  ],
  "log_diff_normal_cdf": [
    "mu",
    "sigma",
    "x",
    "y"
  ],
  "sigma2rho": [
    "sigma"
  ],
  "rho2sigma": [
    "rho"
  ],
  "rho2sd": [],
  "sd2rho": [],
  "log_normal": [
    "x",
    "mean"
  ],
  "MvNormalLogp": [],
  "SplineWrapper": {
    "__props__": [],
    "__init__": [
      "self",
      "spline"
    ],
    "make_node": [
      "self",
      "x"
    ],
    "grad_op": [
      "self"
    ],
    "perform": [
      "self",
      "node",
      "inputs",
      "output_storage"
    ],
    "grad": [
      "self",
      "inputs",
      "grads"
    ]
  },
  "I1e": {
    "nfunc_spec": [],
    "impl": [
      "self",
      "x"
    ]
  },
  "i1e_scalar": [],
  "i1e": [],
  "I0e": {
    "nfunc_spec": [],
    "impl": [
      "self",
      "x"
    ],
    "grad": [
      "self",
      "inp",
      "grads"
    ]
  },
  "i0e_scalar": [],
  "i0e": [],
  "random_choice": [],
  "zvalue": [
    "value",
    "sigma",
    "mu"
  ],
  "incomplete_beta_cfe": [
    "a",
    "b",
    "x",
    "small"
  ],
  "incomplete_beta_ps": [
    "a",
    "b",
    "value"
  ],
  "incomplete_beta": [
    "a",
    "b",
    "value"
  ],
  "clipped_beta_rvs": [
    "a",
    "b",
    "size",
    "dtype"
  ],
  "vectorized_ppc": [],
  "PLATFORM": [],
  "UNSET": [],
  "_Unpickling": {},
  "Distribution": {
    "__new__": [
      "cls",
      "name"
    ],
    "__getnewargs__": [
      "self"
    ],
    "dist": [
      "cls"
    ],
    "__init__": [
      "self",
      "shape",
      "dtype",
      "initval",
      "defaults",
      "transform",
      "broadcastable",
      "dims"
    ],
    "default": [
      "self"
    ],
    "get_test_val": [
      "self",
      "val",
      "defaults"
    ],
    "getattr_value": [
      "self",
      "val"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ],
    "_distr_name_for_repr": [
      "self"
    ],
    "_str_repr": [
      "self",
      "name",
      "dist",
      "formatting"
    ],
    "__str__": [
      "self"
    ],
    "_repr_latex_": [
      "self"
    ],
    "logp_nojac": [
      "self"
    ],
    "logp_sum": [
      "self"
    ],
    "__latex__": []
  },
  "TensorType": [
    "dtype",
    "shape",
    "broadcastable"
  ],
  "NoDistribution": {
    "__init__": [
      "self",
      "shape",
      "dtype",
      "testval",
      "defaults",
      "transform",
      "parent_dist"
    ],
    "__getattr__": [
      "self",
      "name"
    ],
    "logp": [
      "self",
      "x"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "Discrete": {
    "__init__": [
      "self",
      "shape",
      "dtype",
      "defaults"
    ]
  },
  "Continuous": {
    "__init__": [
      "self",
      "shape",
      "dtype",
      "defaults"
    ]
  },
  "DensityDist": {
    "__init__": [
      "self",
      "logp",
      "shape",
      "dtype",
      "initval",
      "random",
      "wrap_random_with_dist_shape",
      "check_shape_in_random"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "vals"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "_DrawValuesContext": {
    "__new__": [
      "cls"
    ],
    "__init__": [
      "self"
    ],
    "parent": [
      "self"
    ]
  },
  "_DrawValuesContextBlocker": {
    "__new__": [
      "cls"
    ],
    "__init__": [
      "self"
    ]
  },
  "is_fast_drawable": [
    "var"
  ],
  "draw_values": [
    "params",
    "point",
    "size"
  ],
  "_compile_theano_function": [
    "param",
    "vars",
    "givens"
  ],
  "vectorize_theano_function": [
    "f",
    "inputs",
    "output"
  ],
  "get_vectorize_signature": [
    "var",
    "var_name"
  ],
  "_draw_value": [
    "param",
    "point",
    "givens",
    "size"
  ],
  "generate_samples": [
    "generator"
  ],
  "BetaBinomial": {
    "__init__": [
      "self",
      "alpha",
      "beta",
      "n"
    ],
    "_random": [
      "self",
      "alpha",
      "beta",
      "n",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Bernoulli": {
    "__init__": [
      "self",
      "p",
      "logit_p"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ],
    "_distr_parameters_for_repr": [
      "self"
    ]
  },
  "DiscreteWeibull": {
    "__init__": [
      "self",
      "q",
      "beta"
    ],
    "_ppf": [
      "self",
      "p"
    ],
    "_random": [
      "self",
      "q",
      "beta",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Geometric": {
    "__init__": [
      "self",
      "p"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "HyperGeometric": {
    "__init__": [
      "self",
      "N",
      "k",
      "n"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "M",
      "n",
      "N",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "DiscreteUniform": {
    "__init__": [
      "self",
      "lower",
      "upper"
    ],
    "_random": [
      "self",
      "lower",
      "upper",
      "size"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "Categorical": {
    "__init__": [
      "self",
      "p"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "ConstantDist": [],
  "ZeroInflatedPoisson": {
    "__init__": [
      "self",
      "psi",
      "theta"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "ZeroInflatedBinomial": {
    "__init__": [
      "self",
      "psi",
      "n",
      "p"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "ZeroInflatedNegativeBinomial": {
    "__init__": [
      "self",
      "psi",
      "mu",
      "alpha"
    ],
    "random": [
      "self",
      "point",
      "size"
    ],
    "_random": [
      "self",
      "mu",
      "alpha",
      "size"
    ],
    "logp": [
      "self",
      "value"
    ],
    "logcdf": [
      "self",
      "value"
    ]
  },
  "OrderedLogistic": {
    "__init__": [
      "self",
      "eta",
      "cutpoints"
    ]
  },
  "OrderedProbit": {
    "__init__": [
      "self",
      "eta",
      "cutpoints"
    ],
    "logp": [
      "self",
      "value"
    ]
  },
  "SMC": {
    "__init__": [
      "self",
      "draws",
      "kernel",
      "n_steps",
      "start",
      "tune_steps",
      "p_acc_rate",
      "threshold",
      "save_sim_data",
      "save_log_pseudolikelihood",
      "model",
      "random_seed",
      "chain"
    ],
    "initialize_population": [
      "self"
    ],
    "setup_kernel": [
      "self"
    ],
    "initialize_logp": [
      "self"
    ],
    "update_weights_beta": [
      "self"
    ],
    "resample": [
      "self"
    ],
    "update_proposal": [
      "self"
    ],
    "tune": [
      "self"
    ],
    "mutate": [
      "self"
    ],
    "posterior_to_trace": [
      "self"
    ]
  },
  "logp_forw": [
    "out_vars",
    "vars",
    "shared"
  ],
  "PseudoLikelihood": {
    "__init__": [
      "self",
      "epsilon",
      "observations",
      "function",
      "params",
      "model",
      "var_info",
      "variables",
      "distance",
      "sum_stat",
      "size",
      "save_sim_data",
      "save_log_pseudolikelihood"
    ],
    "posterior_to_function": [
      "self",
      "posterior"
    ],
    "save_data": [
      "self",
      "sim_data"
    ],
    "get_data": [
      "self"
    ],
    "save_lpl": [
      "self",
      "elemwise"
    ],
    "get_lpl": [
      "self"
    ],
    "__call__": [
      "self",
      "posterior"
    ]
  },
  "sample_smc": [
    "draws",
    "kernel",
    "n_steps",
    "start",
    "tune_steps",
    "p_acc_rate",
    "threshold",
    "save_sim_data",
    "save_log_pseudolikelihood",
    "model",
    "random_seed",
    "parallel",
    "chains",
    "cores"
  ],
  "sample_smc_int": [
    "draws",
    "kernel",
    "n_steps",
    "start",
    "tune_steps",
    "p_acc_rate",
    "threshold",
    "save_sim_data",
    "save_log_pseudolikelihood",
    "model",
    "random_seed",
    "chain",
    "_log"
  ],
  "BackendError": {},
  "BaseTrace": {
    "supports_sampler_stats": [],
    "__init__": [
      "self",
      "name",
      "model",
      "vars",
      "test_point"
    ],
    "_add_warnings": [
      "self",
      "warnings"
    ],
    "_set_sampler_vars": [
      "self",
      "sampler_vars"
    ],
    "setup": [
      "self",
      "draws",
      "chain",
      "sampler_vars"
    ],
    "record": [
      "self",
      "point",
      "sampler_states"
    ],
    "close": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "__len__": [
      "self"
    ],
    "get_values": [
      "self",
      "varname",
      "burn",
      "thin"
    ],
    "get_sampler_stats": [
      "self",
      "stat_name",
      "sampler_idx",
      "burn",
      "thin"
    ],
    "_get_sampler_stats": [
      "self",
      "stat_name",
      "sampler_idx",
      "burn",
      "thin"
    ],
    "_slice": [
      "self",
      "idx"
    ],
    "point": [
      "self",
      "idx"
    ],
    "stat_names": [
      "self"
    ]
  },
  "MultiTrace": {
    "__init__": [
      "self",
      "straces"
    ],
    "__repr__": [
      "self"
    ],
    "nchains": [
      "self"
    ],
    "chains": [
      "self"
    ],
    "report": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "_attrs": [],
    "__getattr__": [
      "self",
      "name"
    ],
    "__len__": [
      "self"
    ],
    "varnames": [
      "self"
    ],
    "stat_names": [
      "self"
    ],
    "add_values": [
      "self",
      "vals",
      "overwrite"
    ],
    "remove_values": [
      "self",
      "name"
    ],
    "get_values": [
      "self",
      "varname",
      "burn",
      "thin",
      "combine",
      "chains",
      "squeeze"
    ],
    "get_sampler_stats": [
      "self",
      "stat_name",
      "burn",
      "thin",
      "combine",
      "chains",
      "squeeze"
    ],
    "_slice": [
      "self",
      "slice"
    ],
    "point": [
      "self",
      "idx",
      "chain"
    ],
    "points": [
      "self",
      "chains"
    ]
  },
  "merge_traces": [
    "mtraces"
  ],
  "_squeeze_cat": [
    "results",
    "combine",
    "squeeze"
  ],
  "WarningType": {
    "DIVERGENCE": [],
    "TUNING_DIVERGENCE": [],
    "DIVERGENCES": [],
    "TREEDEPTH": [],
    "BAD_PARAMS": [],
    "CONVERGENCE": [],
    "BAD_ACCEPTANCE": [],
    "BAD_ENERGY": []
  },
  "SamplerWarning": {},
  "_LEVELS": [],
  "SamplerReport": {
    "__init__": [
      "self"
    ],
    "_warnings": [
      "self"
    ],
    "ok": [
      "self"
    ],
    "n_tune": [
      "self"
    ],
    "n_draws": [
      "self"
    ],
    "t_sampling": [
      "self"
    ],
    "raise_ok": [
      "self",
      "level"
    ],
    "_run_convergence_checks": [
      "self",
      "idata",
      "model"
    ],
    "_add_warnings": [
      "self",
      "warnings",
      "chain"
    ],
    "_log_summary": [
      "self"
    ],
    "_slice": [
      "self",
      "start",
      "stop",
      "step"
    ]
  },
  "merge_reports": [
    "reports"
  ],
  "trace_to_dataframe": [
    "trace",
    "chains",
    "varnames",
    "include_transformed"
  ],
  "create_flat_names": [
    "varname",
    "shape"
  ],
  "_create_shape": [
    "flat_names"
  ],
  "save_trace": [
    "trace",
    "directory",
    "overwrite"
  ],
  "load_trace": [
    "directory",
    "model"
  ],
  "SerializeNDArray": {
    "metadata_file": [],
    "samples_file": [],
    "metadata_path": [],
    "samples_path": [],
    "__init__": [
      "self",
      "directory"
    ],
    "to_metadata": [
      "ndarray"
    ],
    "save": [
      "self",
      "ndarray"
    ],
    "load": [
      "self",
      "model"
    ]
  },
  "NDArray": {
    "supports_sampler_stats": [],
    "__init__": [
      "self",
      "name",
      "model",
      "vars",
      "test_point"
    ],
    "setup": [
      "self",
      "draws",
      "chain",
      "sampler_vars"
    ],
    "record": [
      "self",
      "point",
      "sampler_stats"
    ],
    "_get_sampler_stats": [
      "self",
      "varname",
      "sampler_idx",
      "burn",
      "thin"
    ],
    "close": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "get_values": [
      "self",
      "varname",
      "burn",
      "thin"
    ],
    "_slice": [
      "self",
      "idx"
    ],
    "point": [
      "self",
      "idx"
    ]
  },
  "_slice_as_ndarray": [
    "strace",
    "idx"
  ],
  "point_list_to_multitrace": [
    "point_list",
    "model"
  ],
  "make_sens_ic": [
    "n_states",
    "n_theta",
    "floatX"
  ],
  "augment_system": [
    "ode_func",
    "n_states",
    "n_theta"
  ],
  "DifferentialEquation": {
    "_itypes": [],
    "_otypes": [],
    "__props__": [],
    "__init__": [
      "self",
      "func",
      "times"
    ],
    "_system": [
      "self",
      "Y",
      "t",
      "p"
    ],
    "_simulate": [
      "self",
      "y0",
      "theta"
    ],
    "make_node": [
      "self",
      "y0",
      "theta"
    ],
    "__call__": [
      "self",
      "y0",
      "theta",
      "return_sens"
    ],
    "perform": [
      "self",
      "node",
      "inputs_storage",
      "output_storage"
    ],
    "infer_shape": [
      "self",
      "fgraph",
      "node",
      "input_shapes"
    ],
    "grad": [
      "self",
      "inputs",
      "output_grads"
    ]
  }
}