{
  "LOGGER_NAME": [],
  "Logger": {
    "log_level_translate": [],
    "LOG_PATH": [],
    "__check_path_create_dir": [
      "log_path"
    ],
    "set_logger_level": [
      "log_level"
    ],
    "get_logger": [],
    "set_log_file": [
      "log_folder"
    ],
    "shutdown": [],
    "critical": [
      "msg"
    ],
    "debug": [
      "msg"
    ],
    "info": [
      "msg"
    ],
    "warning": [
      "msg"
    ],
    "error": [
      "msg"
    ]
  },
  "set_log_folder": [
    "folder",
    "level"
  ],
  "create_model_metadata": [
    "fqc",
    "scheduling_info"
  ],
  "get_versions_dict": [
    "fqc"
  ],
  "get_scheduler_metadata": [
    "scheduler_info"
  ],
  "__version__": [],
  "DefaultDict": {
    "__init__": [
      "self",
      "known_dict",
      "default_value"
    ],
    "get": [
      "self",
      "key"
    ],
    "keys": [
      "self"
    ]
  },
  "TENSORFLOW": [],
  "PYTORCH": [],
  "WEIGHTS_SIGNED": [],
  "MIN_THRESHOLD": [],
  "EPS": [],
  "LUT_VALUES_BITWIDTH": [],
  "FP32_BYTES_PER_PARAMETER": [],
  "OUTPUT_SCALE": [],
  "THRESHOLD": [],
  "SIGNED": [],
  "LUT_VALUES": [],
  "SCALE_PER_CHANNEL": [],
  "RANGE_MIN": [],
  "RANGE_MAX": [],
  "REUSE": [],
  "REUSE_GROUP": [],
  "LAST_AXIS": [],
  "AXIS": [],
  "DATA_TYPE": [],
  "FLOAT_32": [],
  "NUM_SAMPLES_DISTANCE_TENSORBOARD": [],
  "SHIFT_NEGATIVE_NON_LINEAR_NUM_BITS": [],
  "FLOAT_BITWIDTH": [],
  "WEIGHTS_ATTRIBUTE": [],
  "ACTIVATION_ATTRIBUTE": [],
  "WEIGHTS_NBITS_ATTRIBUTE": [],
  "CORRECTED_BIAS_ATTRIBUTE": [],
  "ACTIVATION_N_BITS_ATTRIBUTE": [],
  "SUPPORTED_INPUT_ACTIVATION_NBITS_ATTRIBUTE": [],
  "WEIGHTS": [],
  "ACTIVATION": [],
  "SYMMETRIC_TENSOR_N_ITER": [],
  "SYMMETRIC_TENSOR_PER_CHANNEL_N_ITER": [],
  "SYMMETRIC_HISTOGRAM_N_ITER": [],
  "UNIFORM_TENSOR_N_ITER": [],
  "UNIFORM_TENSOR_PER_CHANNEL_N_ITER": [],
  "UNIFORM_HISTOGRAM_N_ITER": [],
  "SYMMETRIC_TENSOR_N_INTERVALS": [],
  "SYMMETRIC_TENSOR_PER_CHANNEL_N_INTERVALS": [],
  "SYMMETRIC_HISTOGRAM_N_INTERVALS": [],
  "SYMMETRIC_TENSOR_DEC_FREQ": [],
  "SYMMETRIC_TENSOR_PER_CHANNEL_DEC_FREQ": [],
  "SYMMETRIC_HISTOGRAM_DEC_FREQ": [],
  "UNIFORM_TENSOR_N_SAMPLES": [],
  "UNIFORM_HISTOGRAM_N_SAMPLES": [],
  "DEFAULT_DEC_FACTOR": [],
  "DEFAULT_TOL": [],
  "BOTTOM_FACTOR": [],
  "UPPER_FACTOR": [],
  "DEC_RANGE_BOTTOM": [],
  "DEC_RANGE_UPPER": [],
  "NUM_QPARAM_HESSIAN_SAMPLES": [],
  "BITS_TO_BYTES": [],
  "SOFTMAX_THRESHOLD": [],
  "VIRTUAL_WEIGHTS_SUFFIX": [],
  "VIRTUAL_ACTIVATION_SUFFIX": [],
  "VIRTUAL_ACTIVATION_WEIGHTS_NODE_PREFIX": [],
  "DUMMY_NODE": [],
  "DUMMY_TENSOR": [],
  "MIN_HESSIAN_ITER": [],
  "HESSIAN_COMP_TOLERANCE": [],
  "HESSIAN_OUTPUT_ALPHA": [],
  "HESSIAN_NUM_ITERATIONS": [],
  "HESSIAN_EPS": [],
  "ACT_HESSIAN_DEFAULT_BATCH_SIZE": [],
  "GPTQ_HESSIAN_NUM_SAMPLES": [],
  "MP_DEFAULT_NUM_SAMPLES": [],
  "PRUNING_NUM_SCORE_APPROXIMATIONS": [],
  "OPERATORS_SCHEDULING": [],
  "MAX_CUT": [],
  "CUTS": [],
  "FUSED_NODES_MAPPING": [],
  "OP_ORDER": [],
  "OP_RECORD": [],
  "MEM_ELEMENTS": [],
  "SHAPE": [],
  "NODE_NAME": [],
  "TOTAL_SIZE": [],
  "NODE_OUTPUT_INDEX": [],
  "FUSED_LAYER_PATTERN": [],
  "FUSED_OP_QUANT_CONFIG": [],
  "FOUND_TF": [],
  "FOUND_TORCH": [],
  "FOUND_TORCHVISION": [],
  "FOUND_ONNX": [],
  "FOUND_ONNXRUNTIME": [],
  "OriginalBNStatsHolder": {
    "__init__": [
      "self",
      "model",
      "bn_layer_types"
    ],
    "get_bn_layer_names": [
      "self"
    ],
    "get_mean": [
      "self",
      "bn_layer_name"
    ],
    "get_var": [
      "self",
      "bn_layer_name"
    ],
    "get_std": [
      "self",
      "bn_layer_name"
    ],
    "get_num_bn_layers": [
      "self"
    ],
    "get_bn_params": [
      "self",
      "model",
      "bn_layer_types"
    ]
  },
  "ActivationExtractor": {
    "__init__": [
      "self",
      "model",
      "layer_types_to_extract_inputs"
    ],
    "get_layer_input_activation": [
      "self",
      "layer_name"
    ],
    "get_output_layer_input_activation": [
      "self"
    ],
    "get_last_linear_layers_weights": [
      "self"
    ],
    "get_extractor_layer_names": [
      "self"
    ],
    "clear": [
      "self"
    ],
    "remove": [
      "self"
    ],
    "run_model": [
      "self",
      "inputs"
    ]
  },
  "get_data_generation_classes": [
    "data_generation_config",
    "output_image_size",
    "n_images",
    "image_pipeline_dict",
    "image_normalization_dict",
    "bn_layer_weighting_function_dict",
    "image_initialization_function_dict",
    "bn_alignment_loss_function_dict",
    "output_loss_function_dict"
  ],
  "BaseImagePipeline": {
    "__init__": [
      "self",
      "output_image_size",
      "extra_pixels",
      "image_clipping",
      "normalization"
    ],
    "get_image_input_size": [
      "self"
    ],
    "image_input_manipulation": [
      "self",
      "images"
    ],
    "image_output_finalize": [
      "self",
      "images"
    ]
  },
  "EnumBaseClass": {
    "get_values": [
      "cls"
    ],
    "get_enum_by_value": [
      "cls",
      "target_value"
    ]
  },
  "ImageGranularity": {
    "ImageWise": [],
    "BatchWise": [],
    "AllImages": []
  },
  "DataInitType": {
    "Gaussian": [],
    "Diverse": []
  },
  "ImagePipelineType": {
    "SMOOTHING_AND_AUGMENTATION": [],
    "IDENTITY": []
  },
  "ImageNormalizationType": {
    "TORCHVISION": [],
    "KERAS_APPLICATIONS": [],
    "NO_NORMALIZATION": []
  },
  "BNLayerWeightingType": {
    "AVERAGE": [],
    "FIRST_LAYER_MULTIPLIER": [],
    "GRAD": []
  },
  "BatchNormAlignemntLossType": {
    "L2_SQUARE": []
  },
  "OutputLossType": {
    "NONE": [],
    "NEGATIVE_MIN_MAX_DIFF": [],
    "INVERSE_MIN_MAX_DIFF": [],
    "REGULARIZED_MIN_MAX_DIFF": []
  },
  "SchedulerType": {
    "REDUCE_ON_PLATEAU": [],
    "REDUCE_ON_PLATEAU_WITH_RESET": [],
    "STEP": []
  },
  "DataGenerationConfig": {
    "__init__": [
      "self",
      "n_iter",
      "optimizer",
      "data_gen_batch_size",
      "initial_lr",
      "output_loss_multiplier",
      "image_granularity",
      "scheduler_type",
      "bn_alignment_loss_type",
      "output_loss_type",
      "data_init_type",
      "layer_weighting_type",
      "image_pipeline_type",
      "image_normalization_type",
      "extra_pixels",
      "bn_layer_types",
      "last_layer_types",
      "image_clipping"
    ]
  },
  "IMAGE_INPUT": [],
  "NUM_INPUT_CHANNELS": [],
  "DEFAULT_DATA_GEN_BS": [],
  "DEFAULT_N_ITER": [],
  "ImagesOptimizationHandler": {
    "__init__": [
      "self",
      "model",
      "data_gen_batch_size",
      "init_dataset",
      "optimizer",
      "image_pipeline",
      "activation_extractor",
      "image_granularity",
      "scheduler_step_fn",
      "scheduler",
      "normalization_mean",
      "normalization_std",
      "initial_lr",
      "eps"
    ],
    "random_batch_reorder": [
      "self"
    ],
    "get_random_batch_index": [
      "self",
      "index"
    ],
    "get_images_by_batch_index": [
      "self",
      "batch_index"
    ],
    "get_optimizer_by_batch_index": [
      "self",
      "batch_index"
    ],
    "get_scheduler_by_batch_index": [
      "self",
      "batch_index"
    ],
    "get_layer_accumulated_stats": [
      "self",
      "layer_name"
    ],
    "compute_bn_loss": [
      "self",
      "input_imgs",
      "batch_index",
      "activation_extractor",
      "orig_bn_stats_holder",
      "bn_alignment_loss_fn",
      "bn_layer_weights"
    ],
    "update_statistics": [
      "self",
      "input_imgs",
      "batch_index",
      "activation_extractor"
    ],
    "optimization_step": [
      "self",
      "batch_index",
      "loss",
      "i_ter"
    ],
    "zero_grad": [
      "self",
      "batch_index"
    ],
    "get_finalized_images": [
      "self"
    ]
  },
  "BatchOptimizationHolder": {
    "__init__": [
      "self",
      "images",
      "optimizer",
      "scheduler",
      "initial_lr"
    ],
    "get_images": [
      "self"
    ],
    "get_optimizer": [
      "self"
    ],
    "get_scheduler": [
      "self"
    ]
  },
  "AllImagesStatsHolder": {
    "__init__": [
      "self",
      "n_batches",
      "batch_size",
      "mean_axis"
    ],
    "get_batches_stats_holder_list": [
      "self"
    ],
    "update_batch_stats": [
      "self",
      "batch_index",
      "input_imgs",
      "activation_extractor",
      "to_differentiate"
    ],
    "get_stats": [
      "self",
      "batch_index",
      "layer_name"
    ]
  },
  "BatchStatsHolder": {
    "__init__": [
      "self",
      "mean_axis",
      "eps"
    ],
    "get_mean": [
      "self",
      "bn_layer_name"
    ],
    "get_second_moment": [
      "self",
      "bn_layer_name"
    ],
    "get_var": [
      "self",
      "bn_layer_name"
    ],
    "get_std": [
      "self",
      "bn_layer_name"
    ],
    "update_layer_stats": [
      "self",
      "bn_layer_name",
      "mean",
      "second_moment"
    ],
    "calc_bn_stats_from_activations": [
      "self",
      "input_imgs",
      "activation_extractor",
      "to_differentiate"
    ],
    "clear": [
      "self"
    ]
  },
  "PytorchOriginalBNStatsHolder": {
    "__init__": [
      "self",
      "model",
      "bn_layer_types"
    ],
    "get_bn_params": [
      "self",
      "model",
      "bn_layer_types"
    ]
  },
  "InputHook": {
    "__init__": [
      "self"
    ],
    "hook": [
      "self",
      "module",
      "input",
      "output"
    ],
    "clear": [
      "self"
    ]
  },
  "PytorchActivationExtractor": {
    "__init__": [
      "self",
      "model",
      "fx_model",
      "layer_types_to_extract_inputs",
      "last_layer_types_to_extract_inputs"
    ],
    "_set_hooks_for_layers": [
      "self"
    ],
    "_set_hooks_for_last_layers": [
      "self"
    ],
    "get_layer_input_activation": [
      "self",
      "layer_name"
    ],
    "get_output_layer_input_activation": [
      "self"
    ],
    "get_last_linear_layers_weights": [
      "self"
    ],
    "get_extractor_layer_names": [
      "self"
    ],
    "clear": [
      "self"
    ],
    "remove": [
      "self"
    ],
    "run_model": [
      "self",
      "inputs"
    ]
  },
  "PytorchIdentityImagePipeline": {
    "__init__": [
      "self",
      "output_image_size",
      "extra_pixels",
      "normalization",
      "image_clipping"
    ],
    "get_image_input_size": [
      "self"
    ],
    "image_input_manipulation": [
      "self",
      "images"
    ],
    "image_output_finalize": [
      "self",
      "images"
    ]
  },
  "PytorchSmoothAugmentationImagePipeline": {
    "__init__": [
      "self",
      "output_image_size",
      "extra_pixels",
      "normalization",
      "image_clipping",
      "smoothing_filter_size",
      "smoothing_filter_sigma"
    ],
    "get_image_input_size": [
      "self"
    ],
    "image_input_manipulation": [
      "self",
      "images"
    ],
    "image_output_finalize": [
      "self",
      "images"
    ],
    "clip_images": [
      "images",
      "valid_grid",
      "reflection"
    ]
  },
  "DEFAULT_PYTORCH_INITIAL_LR": [],
  "DEFAULT_PYTORCH_EXTRA_PIXELS": [],
  "DEFAULT_PYTORCH_OUTPUT_LOSS_MULTIPLIER": [],
  "DEFAULT_PYTORCH_BN_LAYER_TYPES": [],
  "DEFAULT_PYTORCH_LAST_LAYER_TYPES": [],
  "OUTPUT": [],
  "PytorchImagesOptimizationHandler": {
    "__init__": [
      "self",
      "model",
      "data_gen_batch_size",
      "init_dataset",
      "optimizer",
      "image_pipeline",
      "activation_extractor",
      "image_granularity",
      "scheduler_step_fn",
      "scheduler",
      "initial_lr",
      "normalization_mean",
      "normalization_std",
      "device",
      "eps"
    ],
    "get_layer_accumulated_stats": [
      "self",
      "layer_name"
    ],
    "optimization_step": [
      "self",
      "batch_index",
      "loss",
      "i_iter"
    ],
    "zero_grad": [
      "self",
      "batch_index"
    ],
    "get_finalized_images": [
      "self"
    ]
  },
  "PytorchBatchOptimizationHolder": {
    "__init__": [
      "self",
      "images",
      "optimizer",
      "scheduler",
      "initial_lr"
    ]
  },
  "PytorchAllImagesStatsHolder": {
    "get_batches_stats_holder_list": [
      "self"
    ]
  },
  "PytorchBatchStatsHolder": {
    "__init__": [
      "self",
      "mean_axis",
      "eps"
    ],
    "get_var": [
      "self",
      "bn_layer_name"
    ],
    "get_std": [
      "self",
      "bn_layer_name"
    ],
    "calc_bn_stats_from_activations": [
      "self",
      "input_imgs",
      "activation_extractor",
      "to_differentiate"
    ],
    "clear": [
      "self"
    ]
  },
  "DatasetFromList": {
    "__init__": [
      "self",
      "img_list"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "create_valid_grid": [
    "means",
    "stds"
  ],
  "Smoothing": {
    "__init__": [
      "self",
      "size",
      "sigma",
      "kernel"
    ],
    "forward": [
      "self",
      "image"
    ],
    "__repr__": [
      "self"
    ],
    "gaussian_kernel": [
      "size",
      "sigma"
    ]
  },
  "RandomDataset": {
    "__init__": [
      "self",
      "length",
      "sample_fn",
      "size"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "gaussian_sample": [
    "size"
  ],
  "diverse_sample": [
    "size"
  ],
  "default_data_init_fn": [
    "n_images",
    "size",
    "crop",
    "sample_fn",
    "batch_size"
  ],
  "inverse_min_max_diff": [
    "model_outputs",
    "activation_extractor",
    "device",
    "eps"
  ],
  "negative_min_max_diff": [
    "model_outputs",
    "activation_extractor",
    "device",
    "eps"
  ],
  "regularized_min_max_diff": [
    "model_outputs",
    "activation_extractor",
    "device",
    "eps"
  ],
  "no_output_loss": [
    "model_outputs",
    "activation_extractor",
    "device",
    "eps"
  ],
  "l2_square": [
    "bn_mean",
    "input_mean",
    "bn_std",
    "input_std"
  ],
  "get_reduce_lr_on_plateau_scheduler": [
    "n_iter"
  ],
  "get_reduce_lr_on_plateau_with_reset_scheduler": [
    "n_iter"
  ],
  "get_step_lr_scheduler": [
    "n_iter"
  ],
  "reduce_lr_on_platu_step_fn": [
    "scheduler",
    "i_iter",
    "loss_value"
  ],
  "scheduler_step_fn": [
    "scheduler",
    "i_iter",
    "loss_value"
  ],
  "ReduceLROnPlateauWithReset": {
    "__init__": [
      "self",
      "optimizer",
      "mode",
      "factor",
      "patience",
      "threshold",
      "threshold_mode",
      "cooldown",
      "min_lr",
      "eps",
      "verbose"
    ],
    "_reset": [
      "self"
    ],
    "step": [
      "self",
      "metrics",
      "epoch"
    ],
    "_reduce_lr": [
      "self",
      "epoch"
    ],
    "in_cooldown": [
      "self"
    ],
    "is_better": [
      "self",
      "a",
      "best"
    ],
    "_init_is_better": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state_dict"
    ]
  },
  "average_bn_layer_weighting_fn": [
    "orig_bn_stats_holder",
    "activation_extractor",
    "i_iter",
    "n_iter"
  ],
  "first_bn_multiplier_weighting_fn": [
    "orig_bn_stats_holder",
    "activation_extractor",
    "i_iter",
    "n_iter"
  ],
  "KerasOriginalBNStatsHolder": {
    "__init__": [
      "self",
      "model",
      "bn_layer_types"
    ],
    "get_bn_params": [
      "self",
      "model",
      "bn_layer_types"
    ]
  },
  "KerasActivationExtractor": {
    "__init__": [
      "self",
      "model",
      "layer_types_to_extract_inputs",
      "linear_layers"
    ],
    "get_layer_input_activation": [
      "self",
      "layer_name"
    ],
    "get_extractor_layer_names": [
      "self"
    ],
    "run_on_inputs": [
      "self",
      "inputs"
    ],
    "run_model": [
      "self",
      "inputs"
    ],
    "get_model_last_layer": [
      "self"
    ]
  },
  "TensorflowSmoothAugmentationImagePipeline": {
    "__init__": [
      "self",
      "output_image_size",
      "extra_pixels",
      "normalization",
      "image_clipping",
      "smoothing_filter_size",
      "smoothing_filter_sigma"
    ],
    "get_image_input_size": [
      "self"
    ],
    "image_input_manipulation": [
      "self",
      "images"
    ],
    "image_output_finalize": [
      "self",
      "images"
    ]
  },
  "TensorflowIdentityImagePipeline": {
    "__init__": [
      "self",
      "output_image_size",
      "extra_pixels",
      "normalization",
      "image_clipping"
    ],
    "get_image_input_size": [
      "self"
    ],
    "image_input_manipulation": [
      "self",
      "images"
    ],
    "image_output_finalize": [
      "self",
      "images"
    ]
  },
  "DEFAULT_KERAS_INITIAL_LR": [],
  "DEFAULT_KERAS_EXTRA_PIXELS": [],
  "DEFAULT_KERAS_OUTPUT_LOSS_MULTIPLIER": [],
  "IMAGE_MIN_VAL": [],
  "IMAGE_MAX_VAL": [],
  "KerasImagesOptimizationHandler": {
    "__init__": [
      "self",
      "model",
      "init_dataset",
      "image_pipeline",
      "activation_extractor",
      "scheduler",
      "normalization_mean",
      "normalization_std",
      "data_generation_config",
      "orig_bn_stats_holder",
      "eps"
    ],
    "clip_and_reflect": [
      "self",
      "z"
    ],
    "get_layer_accumulated_stats": [
      "self",
      "layer_name"
    ],
    "compute_bn_loss": [
      "self",
      "input_imgs",
      "batch_index",
      "activation_extractor",
      "bn_layer_weights",
      "bn_alignment_loss_fn"
    ],
    "update_statistics": [
      "self",
      "input_imgs",
      "batch_index",
      "activation_extractor"
    ],
    "optimization_step": [
      "self",
      "batch_index",
      "images",
      "gradients",
      "loss",
      "i_iter"
    ],
    "get_finilized_data_loader": [
      "self"
    ]
  },
  "KerasBatchOptimizationHolder": {
    "__init__": [
      "self",
      "images",
      "optimizer",
      "scheduler",
      "initial_lr"
    ]
  },
  "KerasAllImagesStatsHolder": {
    "get_batches_stats_holder_list": [
      "self"
    ],
    "update_batch_stats": [
      "self",
      "batch_index",
      "input_imgs",
      "activation_extractor"
    ],
    "get_stats": [
      "self",
      "batch_index",
      "layer_name"
    ]
  },
  "KerasBatchStatsHolder": {
    "calc_bn_stats_from_activations": [
      "self",
      "input_imgs",
      "activation_extractor"
    ]
  },
  "random_crop": [
    "image",
    "height_crop",
    "width_crop"
  ],
  "center_crop": [
    "image",
    "height_crop",
    "width_crop"
  ],
  "random_flip": [
    "image"
  ],
  "clip_images": [
    "images",
    "valid_grid",
    "reflection"
  ],
  "generate_gaussian_noise_images": [
    "mean",
    "std",
    "num_samples",
    "batch_size",
    "image_shape"
  ],
  "noise_generator": [
    "mean",
    "std",
    "total_images",
    "image_shape"
  ],
  "get_random_gaussian_data": [
    "batch_size",
    "n_images",
    "size",
    "mean_factor",
    "std_factor"
  ],
  "image_initialization_function_dict": [],
  "ReduceLROnPlateau": {
    "__init__": [
      "self",
      "optimizer",
      "mode",
      "factor",
      "patience",
      "threshold",
      "threshold_mode",
      "cooldown",
      "min_lr",
      "eps",
      "verbose"
    ],
    "_reset": [
      "self"
    ],
    "on_epoch_end": [
      "self",
      "epoch",
      "loss",
      "logs"
    ],
    "_reduce_lr": [
      "self",
      "epoch"
    ],
    "in_cooldown": [
      "self"
    ],
    "is_better": [
      "self",
      "a",
      "best"
    ],
    "_init_is_better": [
      "self",
      "mode",
      "threshold",
      "threshold_mode"
    ],
    "get_config": [
      "self"
    ],
    "set_config": [
      "self",
      "config"
    ]
  },
  "average_layer_weighting_fn": [
    "orig_bn_stats_holder",
    "activation_extractor",
    "i_iter",
    "n_iter"
  ],
  "ImmutableClass": {
    "_initialized": [],
    "__init__": [
      "self"
    ],
    "__setattr__": [
      "self"
    ],
    "initialized_done": [
      "self"
    ]
  },
  "_get_json_schema": [
    "tpc_json_path"
  ],
  "_get_tpc_from_json": [
    "tpc_path"
  ],
  "load_target_platform_capabilities": [
    "tpc_obj_or_path"
  ],
  "export_target_platform_capabilities": [
    "model",
    "export_path"
  ],
  "OPS_SET_LIST": [],
  "LATEST": [],
  "DEFAULT_TP_MODEL": [],
  "IMX500_TP_MODEL": [],
  "TFLITE_TP_MODEL": [],
  "QNNPACK_TP_MODEL": [],
  "KERNEL_ATTR": [],
  "BIAS_ATTR": [],
  "POS_ATTR": [],
  "KERAS_KERNEL": [],
  "KERAS_DEPTHWISE_KERNEL": [],
  "BIAS": [],
  "PYTORCH_KERNEL": [],
  "WEIGHTS_N_BITS": [],
  "WEIGHTS_QUANTIZATION_METHOD": [],
  "OperationsSetToLayers": {
    "__init__": [
      "self",
      "op_set_name",
      "layers",
      "attr_mapping"
    ],
    "__repr__": [
      "self"
    ]
  },
  "OperationsToLayers": {
    "__init__": [
      "self",
      "op_sets_to_layers"
    ],
    "get_layers_by_op": [
      "self",
      "op"
    ],
    "get_layers": [
      "self"
    ],
    "__add__": [
      "self",
      "op_set_to_layers"
    ],
    "validate_op_sets": [
      "self"
    ]
  },
  "Filter": {
    "match": [
      "self",
      "layer_config"
    ]
  },
  "AttributeFilter": {
    "__init__": [
      "self",
      "attr",
      "value",
      "op"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "match": [
      "self",
      "layer_config"
    ],
    "op_as_str": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "OrAttributeFilter": {
    "__init__": [
      "self"
    ],
    "match": [
      "self",
      "layer_config"
    ],
    "__repr__": [
      "self"
    ]
  },
  "AndAttributeFilter": {
    "__init__": [
      "self"
    ],
    "match": [
      "self",
      "layer_config"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Greater": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "GreaterEq": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "Smaller": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "SmallerEq": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "NotEq": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "Eq": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "Contains": {
    "__init__": [
      "self",
      "attr",
      "value"
    ],
    "op_as_str": [
      "self"
    ]
  },
  "AttachTpcToKeras": {
    "__init__": [
      "self"
    ]
  },
  "LayerFilterParams": {
    "__init__": [
      "self",
      "layer"
    ],
    "__hash__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "create_name": [
      "self"
    ]
  },
  "AttachTpcToFramework": {
    "__init__": [
      "self"
    ],
    "attach": [
      "self",
      "tpc_model",
      "custom_opset2layer"
    ]
  },
  "get_current_tpc": [],
  "_CurrentTPC": {
    "__init__": [
      "self"
    ],
    "get": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "set": [
      "self",
      "target_platform_capabilities"
    ]
  },
  "_current_tpc": [],
  "FrameworkQuantizationCapabilities": {
    "__init__": [
      "self",
      "tpc",
      "name"
    ],
    "get_layers_by_opset_name": [
      "self",
      "opset_name"
    ],
    "get_layers": [
      "self"
    ],
    "get_layers_by_opset": [
      "self",
      "op"
    ],
    "get_fusing_patterns": [
      "self"
    ],
    "get_info": [
      "self"
    ],
    "show": [
      "self"
    ],
    "append_component": [
      "self",
      "tpc_component"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "tb"
    ],
    "get_default_op_qc": [
      "self"
    ],
    "_get_config_options_mapping": [
      "self"
    ],
    "remove_fusing_names_from_not_used_list": [
      "self"
    ],
    "remove_opset_from_not_used_list": [
      "self",
      "opset_to_remove"
    ],
    "is_simd_padding": [
      "self"
    ],
    "insert_preserving_quantizers": [
      "self"
    ]
  },
  "AttachTpcToPytorch": {
    "__init__": [
      "self"
    ]
  },
  "FrameworkQuantizationCapabilitiesComponent": {
    "__init__": [
      "self",
      "name"
    ],
    "get_info": [
      "self"
    ]
  },
  "get_target_platform_capabilities": [
    "fw_name",
    "target_platform_name",
    "target_platform_version"
  ],
  "get_tpc_model": [
    "name",
    "tpc"
  ],
  "get_tpc": [],
  "get_op_quantization_configs": [],
  "generate_tpc": [
    "default_config",
    "base_config",
    "mixed_precision_cfg_list",
    "name"
  ],
  "OperatorSetNames": {
    "CONV": [],
    "DEPTHWISE_CONV": [],
    "CONV_TRANSPOSE": [],
    "FULLY_CONNECTED": [],
    "CONCATENATE": [],
    "STACK": [],
    "UNSTACK": [],
    "GATHER": [],
    "EXPAND": [],
    "BATCH_NORM": [],
    "L2NORM": [],
    "RELU": [],
    "RELU6": [],
    "LEAKY_RELU": [],
    "ELU": [],
    "HARD_TANH": [],
    "ADD": [],
    "SUB": [],
    "MUL": [],
    "DIV": [],
    "MIN": [],
    "MAX": [],
    "PRELU": [],
    "ADD_BIAS": [],
    "SWISH": [],
    "SIGMOID": [],
    "SOFTMAX": [],
    "LOG_SOFTMAX": [],
    "TANH": [],
    "GELU": [],
    "HARDSIGMOID": [],
    "HARDSWISH": [],
    "FLATTEN": [],
    "GET_ITEM": [],
    "RESHAPE": [],
    "UNSQUEEZE": [],
    "SQUEEZE": [],
    "PERMUTE": [],
    "TRANSPOSE": [],
    "DROPOUT": [],
    "SPLIT_CHUNK": [],
    "MAXPOOL": [],
    "AVGPOOL": [],
    "SIZE": [],
    "SHAPE": [],
    "EQUAL": [],
    "ARGMAX": [],
    "TOPK": [],
    "FAKE_QUANT": [],
    "COMBINED_NON_MAX_SUPPRESSION": [],
    "ZERO_PADDING2D": [],
    "CAST": [],
    "RESIZE": [],
    "PAD": [],
    "FOLD": [],
    "STRIDED_SLICE": [],
    "SSD_POST_PROCESS": [],
    "get_values": [
      "cls"
    ]
  },
  "Signedness": {
    "AUTO": [],
    "SIGNED": [],
    "UNSIGNED": []
  },
  "AttributeQuantizationConfig": {
    "model_config": [],
    "field_names": [
      "self"
    ],
    "clone_and_edit": [
      "self"
    ]
  },
  "OpQuantizationConfig": {
    "model_config": [],
    "validate_supported_input_activation_n_bits": [
      "cls",
      "v"
    ],
    "get_info": [
      "self"
    ],
    "clone_and_edit": [
      "self",
      "attr_to_edit"
    ]
  },
  "QuantizationConfigOptions": {
    "model_config": [],
    "validate_and_set_base_config": [
      "cls",
      "values"
    ],
    "clone_and_edit": [
      "self"
    ],
    "clone_and_edit_weight_attribute": [
      "self",
      "attrs"
    ],
    "clone_and_map_weights_attr_keys": [
      "self",
      "layer_attrs_mapping"
    ],
    "get_info": [
      "self"
    ]
  },
  "TargetPlatformModelComponent": {
    "model_config": []
  },
  "OperatorsSetBase": {},
  "OperatorsSet": {
    "model_config": [],
    "get_info": [
      "self"
    ]
  },
  "OperatorSetGroup": {
    "model_config": [],
    "validate_and_set_name": [
      "cls",
      "values"
    ],
    "get_info": [
      "self"
    ]
  },
  "Fusing": {
    "model_config": [],
    "validate_and_set_name": [
      "cls",
      "values"
    ],
    "validate_after_initialization": [
      "cls",
      "model"
    ],
    "contains": [
      "self",
      "other"
    ],
    "get_info": [
      "self"
    ]
  },
  "TargetPlatformCapabilities": {
    "model_config": [],
    "validate_after_initialization": [
      "cls",
      "model"
    ],
    "get_info": [
      "self"
    ],
    "show": [
      "self"
    ]
  },
  "max_input_activation_n_bits": [
    "op_quantization_config"
  ],
  "get_config_options_by_operators_set": [
    "tpc",
    "operators_set_name"
  ],
  "get_default_op_quantization_config": [
    "tpc"
  ],
  "is_opset_in_model": [
    "tpc",
    "opset_name"
  ],
  "get_opset_by_name": [
    "tpc",
    "opset_name"
  ],
  "ALL_SCHEMA_VERSIONS": [],
  "FUTURE_SCHEMA_VERSIONS": [],
  "all_tpc_types": [],
  "tpc_or_str_type": [],
  "is_tpc_instance": [
    "tpc_obj_or_path"
  ],
  "get_schema_by_version": [
    "schema_version"
  ],
  "_schema_v1_to_v2": [
    "tpc"
  ],
  "get_conversion_map": [],
  "tpc_to_current_schema_version": [
    "tpc"
  ],
  "ptq_runner": [
    "tg",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl",
    "tb_w"
  ],
  "get_weights_inferable_quantizer_kwargs": [
    "node_qc",
    "attr_name"
  ],
  "get_activation_inferable_quantizer_kwargs": [
    "node_qc"
  ],
  "get_weights_quantizer_for_node": [
    "node",
    "attr_name"
  ],
  "get_activations_quantizer_for_node": [
    "node"
  ],
  "get_inferable_quantizers": [
    "node",
    "get_weights_quantizer_for_node",
    "get_activations_quantizer_for_node",
    "attributes_names"
  ],
  "get_inferable_quantizer_kwargs": [
    "node_qc",
    "quantization_target",
    "attr_name"
  ],
  "DEFAULT_ONNX_OPSET_VERSION": [],
  "PytorchExportSerializationFormat": {
    "TORCHSCRIPT": [],
    "ONNX": []
  },
  "find_and_assign_metadata_attr": [
    "model",
    "attr_name"
  ],
  "_set_quantized_weights_in_wrapper": [
    "layer"
  ],
  "BasePyTorchExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path",
      "repr_dataset"
    ],
    "_substitute_fully_quantized_model": [
      "self",
      "replace_wrapped"
    ],
    "_replace_wrapped_with_unwrapped": [
      "self"
    ]
  },
  "FakelyQuantTorchScriptPyTorchExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path",
      "repr_dataset"
    ],
    "export": [
      "self",
      "output_names"
    ]
  },
  "layers": [],
  "FakelyQuantKerasExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path",
      "verbose"
    ],
    "export": [
      "self"
    ],
    "transform_model_cfg": [
      "self"
    ],
    "get_filtered_weights": [
      "self"
    ]
  },
  "DEFAULT_KERAS_EXPORT_EXTENTION": [],
  "BaseKerasExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path"
    ],
    "get_custom_objects": []
  },
  "KerasExportSerializationFormat": {
    "KERAS": [],
    "TFLITE": []
  },
  "MCTQKerasExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path"
    ],
    "export": [
      "self"
    ]
  },
  "FakelyQuantTFLiteExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path"
    ],
    "export": [
      "self"
    ]
  },
  "BIAS_INITIALIZER": [],
  "BIAS_REGULARIZER": [],
  "BIAS_CONSTRAINT": [],
  "ACTIVITY_REGULARIZER": [],
  "KERNEL_INITIALIZER": [],
  "KERNEL_REGULARIZER": [],
  "KERNEL_CONSTRAINT": [],
  "KERNEL_SIZE": [],
  "PADDING": [],
  "STRIDES": [],
  "LAYER_NAME": [],
  "TRAINABLE": [],
  "USE_BIAS": [],
  "FILTERS": [],
  "UNITS": [],
  "PAD_VALID": [],
  "KERNEL": [],
  "CONV_KERNEL_CHANNEL_AXIS": [],
  "CONV_INPUT_CHANNELS_DIM": [],
  "INT8TFLiteExporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path"
    ],
    "_get_pointwise_layer_to_replace_dense": [
      "self",
      "wrapped_layer"
    ],
    "export": [
      "self"
    ]
  },
  "Exporter": {
    "__init__": [
      "self",
      "model",
      "is_layer_exportable_fn",
      "save_model_path"
    ],
    "export": [
      "self"
    ]
  },
  "QuantizationFormat": {
    "FAKELY_QUANT": [],
    "INT8": [],
    "MCTQ": []
  },
  "_apply_gptq": [
    "gptq_config",
    "representative_data_gen",
    "tb_w",
    "tg",
    "tg_bias",
    "fw_info",
    "fw_impl",
    "hessian_info_service"
  ],
  "gptq_runner": [
    "tg",
    "core_config",
    "gptq_config",
    "representative_data_gen",
    "gptq_representative_data_gen",
    "fw_info",
    "fw_impl",
    "tb_w",
    "hessian_info_service"
  ],
  "RoundingType": {
    "STE": [],
    "SoftQuantizer": []
  },
  "GPTQHessianScoresConfig": {
    "__post_init__": [
      "self"
    ]
  },
  "QFractionLinearAnnealingConfig": {
    "__post_init__": [
      "self"
    ]
  },
  "GradualActivationQuantizationConfig": {},
  "GradientPTQConfig": {},
  "get_gradual_activation_quantizer_wrapper_factory": [
    "gptq_config",
    "get_total_grad_steps_fn",
    "fw_linear_annealing_scheduler"
  ],
  "GradualActivationQuantizerWrapper": {
    "__init__": [
      "self",
      "quantizer",
      "q_fraction_scheduler"
    ],
    "__call__": [
      "self",
      "x",
      "training"
    ],
    "initialize_quantization": [
      "self"
    ]
  },
  "AUXVAR": [],
  "ITERVAR": [],
  "SCALE_TENSOR": [],
  "AUXSHIFT": [],
  "WEIGHTS_QUANTIZATION_PARAMS": [],
  "PTQ_MIN_RANGE": [],
  "PTQ_MAX_RANGE": [],
  "PTQ_THRESHOLD": [],
  "SCALE_PTQ": [],
  "N_CYCLES": [],
  "MIM_TEMP": [],
  "MAX_TEMP": [],
  "REG_DEFAULT": [],
  "REG_DEFAULT_SLA": [],
  "MAX_LSB_CHANGE": [],
  "SOFT_ROUNDING_GAMMA": [],
  "SOFT_ROUNDING_ZETA": [],
  "QUANT_PARAM_LEARNING_STR": [],
  "MAX_LSB_STR": [],
  "LR_DEFAULT": [],
  "LR_REST_DEFAULT": [],
  "LR_BIAS_DEFAULT": [],
  "GPTQ_MOMENTUM": [],
  "GPTQTrainer": {
    "__init__": [
      "self",
      "graph_float",
      "graph_quant",
      "gptq_config",
      "fw_impl",
      "fw_info",
      "representative_data_gen_fn",
      "hessian_info_service"
    ],
    "get_optimizer_with_param": [
      "self",
      "flattened_trainable_weights",
      "flattened_bias_weights",
      "trainable_quantization_parameters"
    ],
    "compute_hessian_based_weights": [
      "self",
      "data_loader"
    ],
    "_build_hessian_request": [
      "self",
      "granularity",
      "data_loader",
      "n_samples"
    ],
    "build_gptq_model": [
      "self"
    ],
    "train": [
      "self"
    ],
    "update_graph": [
      "self"
    ]
  },
  "gptq_training": [
    "graph_float",
    "graph_quant",
    "gptq_config",
    "representative_data_gen",
    "fw_impl",
    "fw_info",
    "hessian_info_service"
  ],
  "GPTQFrameworkImplemantation": {
    "get_gptq_trainer_obj": [
      "self"
    ]
  },
  "WARMUP_STEP_FRACTION": [],
  "get_regularization": [
    "gptq_config",
    "get_total_grad_steps_fn",
    "SoftQuantizerRegularizationFWClass",
    "LinearAnnealingSchedulerFWClass"
  ],
  "get_compare_points": [
    "input_graph"
  ],
  "get_kernel_attribute_name_for_gptq": [
    "layer_type",
    "fw_info"
  ],
  "get_gptq_trainable_parameters": [
    "fxp_model",
    "add_bias"
  ],
  "get_weights_for_loss": [
    "fxp_model"
  ],
  "GPTQPytorchImplemantation": {
    "get_gptq_trainer_obj": [
      "self"
    ]
  },
  "PytorchGPTQTrainer": {
    "__init__": [
      "self",
      "graph_float",
      "graph_quant",
      "gptq_config",
      "fw_impl",
      "fw_info",
      "representative_data_gen",
      "hessian_info_service"
    ],
    "_prepare_train_dataloader_sla": [
      "self",
      "data_gen_fn"
    ],
    "_prepare_train_dataloader_for_non_sla": [
      "self",
      "data_gen_fn"
    ],
    "_is_gptq_weights_trainable": [
      "self",
      "node"
    ],
    "gptq_wrapper": [
      "self",
      "n",
      "layer"
    ],
    "get_activation_quantizer_holder": [
      "self",
      "n",
      "holder_type"
    ],
    "build_gptq_model": [
      "self"
    ],
    "train": [
      "self"
    ],
    "compute_gradients": [
      "self",
      "y_float",
      "input_tensors",
      "distill_loss_weights",
      "round_reg_weights"
    ],
    "micro_training_loop": [
      "self",
      "n_epochs"
    ],
    "update_graph": [
      "self"
    ],
    "_set_requires_grad": [
      "self"
    ]
  },
  "mse_loss": [
    "y",
    "x",
    "normalized"
  ],
  "multiple_tensors_mse_loss": [
    "y_list",
    "x_list",
    "fxp_w_list",
    "flp_w_list",
    "act_bn_mean",
    "act_bn_std",
    "loss_weights"
  ],
  "sample_layer_attention_loss": [
    "y_list",
    "x_list",
    "fxp_w_list",
    "flp_w_list",
    "act_bn_mean",
    "act_bn_std",
    "loss_weights"
  ],
  "power_of_two_max": [
    "max_tensor"
  ],
  "calculate_delta": [
    "max_tensor",
    "num_bits",
    "signed"
  ],
  "calculate_delta_uniform": [
    "min_tensor",
    "max_tensor",
    "num_bits"
  ],
  "ste_ceil": [
    "x"
  ],
  "ste_floor": [
    "x"
  ],
  "ste_round": [
    "x"
  ],
  "ste_clip": [
    "x",
    "min_val",
    "max_val"
  ],
  "fix_range_to_include_zero": [
    "range_min",
    "range_max",
    "n_bits"
  ],
  "quantization_builder": [
    "n",
    "gptq_config",
    "kernel_attr"
  ],
  "pertubation_symmetric_quantizer": [
    "input_tensor",
    "auxvar_tensor",
    "max_tensor",
    "num_bits",
    "signed",
    "power_of_two",
    "max_lsbs_change"
  ],
  "STEWeightGPTQQuantizer": {
    "__init__": [
      "self",
      "quantization_config",
      "max_lsbs_change_map"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "get_quant_config": [
      "self"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ]
  },
  "soft_rounding_unifrom_quantizer": [
    "input_tensor",
    "auxvar_tensor",
    "min_range",
    "max_range",
    "num_bits"
  ],
  "UniformSoftRoundingGPTQ": {
    "__init__": [
      "self",
      "quantization_config",
      "quantization_parameter_learning"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "get_soft_targets": [
      "self"
    ],
    "get_quant_config": [
      "self"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ]
  },
  "soft_rounding_symmetric_quantizer": [
    "input_tensor",
    "auxvar_tensor",
    "threshold_tensor",
    "num_bits",
    "signed",
    "power_of_two"
  ],
  "SymmetricSoftRoundingGPTQ": {
    "__init__": [
      "self",
      "quantization_config",
      "quantization_parameter_learning"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "get_soft_targets": [
      "self"
    ],
    "get_quant_config": [
      "self"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ]
  },
  "SoftQuantizerRegularization": {
    "__init__": [
      "self",
      "beta_scheduler"
    ],
    "__call__": [
      "self",
      "model",
      "entropy_reg",
      "layer_weights"
    ]
  },
  "GPTQKerasImplemantation": {
    "get_gptq_trainer_obj": [
      "self"
    ]
  },
  "KerasGPTQTrainer": {
    "__init__": [
      "self",
      "graph_float",
      "graph_quant",
      "gptq_config",
      "fw_impl",
      "fw_info",
      "representative_data_gen",
      "hessian_info_service"
    ],
    "_prepare_train_dataloader_sla": [
      "self",
      "data_gen_fn"
    ],
    "_prepare_train_dataloader_for_non_sla": [
      "self",
      "data_gen_fn"
    ],
    "_is_gptq_weights_trainable": [
      "self",
      "node"
    ],
    "gptq_wrapper": [
      "self",
      "n",
      "layer"
    ],
    "get_activation_quantizer_holder": [
      "self",
      "n"
    ],
    "build_gptq_model": [
      "self"
    ],
    "compute_gradients": [
      "self",
      "in_y_float",
      "input_data",
      "in_optimizer_with_param",
      "training",
      "distill_loss_weights",
      "reg_weights"
    ],
    "train": [
      "self"
    ],
    "nano_training_step": [
      "self",
      "input_data",
      "in_compute_gradients",
      "in_optimizer_with_param",
      "is_training",
      "distill_loss_weights",
      "reg_weights"
    ],
    "micro_training_loop": [
      "self",
      "in_compute_gradients",
      "in_optimizer_with_param",
      "n_epochs",
      "is_training"
    ],
    "update_graph": [
      "self"
    ]
  },
  "mse_loss_per_tensor": [
    "y",
    "x",
    "normalized",
    "p"
  ],
  "activation_mse": [
    "flp_act_list",
    "fxp_act_list",
    "p_vector",
    "weights_for_average_loss",
    "norm_loss"
  ],
  "GPTQMultipleTensorsLoss": {
    "__init__": [
      "self",
      "norm_loss"
    ],
    "__call__": [
      "self",
      "fxp_act_list",
      "flp_act_list",
      "fxp_w_list",
      "flp_w_list",
      "act_bn_mean",
      "act_bn_std",
      "weights_for_average_loss"
    ]
  },
  "safe_log": [
    "x",
    "eps"
  ],
  "log2": [
    "x"
  ],
  "clip": [
    "x",
    "max_val",
    "min_val"
  ],
  "soft_rounding_uniform_quantizer": [
    "input_tensor",
    "auxvar_tensor",
    "min_tensor",
    "max_tensor",
    "num_bits"
  ],
  "BaseLinearAnnealingScheduler": {
    "__init__": [
      "self",
      "t_start",
      "t_end",
      "initial_val",
      "target_val"
    ],
    "_compute_factor": [
      "self",
      "t"
    ],
    "__call__": [
      "self",
      "t"
    ]
  },
  "TrainingMethod": {
    "STE": [],
    "DQA": [],
    "LSQ": []
  },
  "TrainableQuantizerCandidateConfig": {
    "__init__": [
      "self",
      "n_bits",
      "quantization_params"
    ]
  },
  "TrainableQuantizerActivationConfig": {
    "__init__": [
      "self",
      "activation_quantization_method",
      "activation_n_bits",
      "activation_quantization_params",
      "enable_activation_quantization",
      "min_threshold",
      "activation_quantization_candidates"
    ]
  },
  "TrainableQuantizerWeightsConfig": {
    "__init__": [
      "self",
      "weights_quantization_method",
      "weights_n_bits",
      "weights_quantization_params",
      "enable_weights_quantization",
      "weights_channels_axis",
      "weights_per_channel_threshold",
      "min_threshold",
      "weights_quantization_candidates"
    ]
  },
  "get_trainable_quantizer_class": [
    "quant_target",
    "quantizer_id",
    "quant_method",
    "quantizer_base_class"
  ],
  "get_threshold_reshape_shape": [
    "tensor_shape",
    "quant_axis",
    "quant_axis_dim"
  ],
  "get_total_grad_steps": [
    "representative_data_gen"
  ],
  "get_trainable_quantizer_weights_config": [
    "n",
    "attr_name",
    "weights_quantization_candidates"
  ],
  "get_trainable_quantizer_activation_config": [
    "n",
    "activation_quantization_candidates"
  ],
  "get_trainable_quantizer_quantization_candidates": [
    "n",
    "attr"
  ],
  "FQ_MIN": [],
  "FQ_MAX": [],
  "THRESHOLD_TENSOR": [],
  "VAR": [],
  "GROUP": [],
  "VariableGroup": {
    "WEIGHTS": [],
    "QPARAMS": []
  },
  "BaseTrainableQuantizer": {
    "__init__": [
      "self",
      "quantization_config",
      "freeze_quant_params"
    ],
    "get_sig": [
      "cls"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "input2quantize",
      "training"
    ],
    "activation_quantization": [
      "self"
    ],
    "weights_quantization": [
      "self"
    ],
    "validate_weights": [
      "self"
    ],
    "validate_activation": [
      "self"
    ],
    "convert2inferable": [
      "self"
    ],
    "add_quantizer_variable": [
      "self",
      "name",
      "variable",
      "group"
    ],
    "get_quantizer_variable": [
      "self",
      "name"
    ],
    "get_trainable_variables": [
      "self",
      "group"
    ]
  },
  "PytorchLinearAnnealingScheduler": {
    "_compute_factor": [
      "self",
      "t"
    ]
  },
  "grad_scale": [
    "x",
    "scale"
  ],
  "adjust_range_to_include_zero": [
    "range_min",
    "range_max",
    "n_bits"
  ],
  "symmetric_quantizer": [
    "tensor_data",
    "threshold",
    "n_bits",
    "sign"
  ],
  "uniform_quantizer": [
    "tensor_data",
    "range_min",
    "range_max",
    "n_bits"
  ],
  "symmetric_lsq_quantizer": [
    "x",
    "thresholds",
    "num_bits",
    "sign",
    "min_int",
    "max_int",
    "scale_factor"
  ],
  "uniform_lsq_quantizer": [
    "x",
    "min_range",
    "max_range",
    "num_bits",
    "min_int",
    "max_int",
    "scale_factor"
  ],
  "BasePytorchActivationTrainableQuantizer": {},
  "LSQUniformActivationTrainableQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "LSQSymmetricActivationTrainableQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "STEUniformActivationTrainableQuantizer": {
    "__init__": [
      "self",
      "quantization_config",
      "freeze_quant_params"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "STESymmetricActivationTrainableQuantizer": {
    "__init__": [
      "self",
      "quantization_config",
      "freeze_quant_params"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "KerasLinearAnnealingScheduler": {
    "_compute_factor": [
      "self",
      "t"
    ]
  },
  "int_quantization_with_threshold": [
    "data",
    "n_bits",
    "signed",
    "threshold",
    "eps"
  ],
  "CONFIG": [],
  "VALUE": [],
  "transform_enum": [
    "v"
  ],
  "config_serialization": [
    "quantization_config"
  ],
  "config_deserialization": [
    "in_config"
  ],
  "BaseKerasActivationTrainableQuantizer": {},
  "is_qat_applicable": [
    "node",
    "fw_info"
  ],
  "QATConfig": {
    "__init__": [
      "self",
      "weight_training_method",
      "activation_training_method",
      "weight_quantizer_params_override",
      "activation_quantizer_params_override"
    ]
  },
  "get_activation_quantizer_holder": [
    "n",
    "qat_config",
    "holder_type"
  ],
  "STEUniformWeightQATQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "STEWeightQATQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "LSQUniformWeightQATQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "LSQWeightQATQuantizer": {
    "__init__": [
      "self",
      "quantization_config"
    ],
    "initialize_quantization": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training"
    ],
    "convert2inferable": [
      "self"
    ]
  },
  "analyzer_model_quantization": [
    "representative_data_gen",
    "tb_w",
    "float_graph",
    "quantized_graph",
    "fw_impl",
    "fw_info"
  ],
  "graph_preparation_runner": [
    "in_model",
    "representative_data_gen",
    "quantization_config",
    "fw_info",
    "fw_impl",
    "fqc",
    "bit_width_config",
    "tb_w",
    "mixed_precision_enable",
    "running_gptq"
  ],
  "get_finalized_graph": [
    "initial_graph",
    "fqc",
    "quant_config",
    "bit_width_config",
    "fw_info",
    "tb_w",
    "fw_impl",
    "mixed_precision_enable",
    "running_gptq"
  ],
  "read_model_to_graph": [
    "in_model",
    "representative_data_gen",
    "fqc",
    "fw_info",
    "fw_impl"
  ],
  "quantization_preparation_runner": [
    "graph",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl",
    "tb_w",
    "hessian_info_service"
  ],
  "core_runner": [
    "in_model",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl",
    "fqc",
    "target_resource_utilization",
    "running_gptq",
    "tb_w"
  ],
  "_set_final_resource_utilization": [
    "graph",
    "final_bit_widths_config",
    "target_resource_utilization",
    "fw_info",
    "fw_impl"
  ],
  "BaseSubstitution": {
    "__init__": [
      "self",
      "matcher_instance"
    ],
    "substitute": [
      "self",
      "graph",
      "object_to_sub"
    ]
  },
  "compute_quantize_tensor_memory_bytes": [
    "tensor_size",
    "n_bits"
  ],
  "ModelValidation": {
    "__init__": [
      "self",
      "model",
      "fw_info"
    ],
    "validate_output_channel_consistency": [
      "self"
    ],
    "validate": [
      "self"
    ]
  },
  "UserInformation": {
    "__init__": [
      "self"
    ],
    "set_input_scale": [
      "self",
      "scale_value"
    ],
    "set_mixed_precision_cfg": [
      "self",
      "mp_cfg"
    ]
  },
  "DEFAULT_KERNEL_ATTRIBUTES": [],
  "ChannelAxis": {
    "NHWC": [],
    "NCHW": []
  },
  "FrameworkInfo": {
    "__init__": [
      "self",
      "activation_quantizer_mapping",
      "kernel_channels_mapping",
      "activation_min_max_mapping",
      "layer_min_max_mapping",
      "kernel_ops_attributes_mapping",
      "out_channel_axis_mapping"
    ],
    "get_kernel_op_attributes": [
      "self",
      "node_type"
    ],
    "is_kernel_op": [
      "self",
      "node_type"
    ],
    "layers_has_min_max": [
      "self",
      "layer"
    ],
    "activation_has_min_max": [
      "self",
      "activation_name"
    ]
  },
  "NodePriorInfo": {
    "__init__": [
      "self",
      "min_output",
      "max_output",
      "mean_output",
      "std_output"
    ],
    "get_shifted_prior_info": [
      "self",
      "shift_val"
    ],
    "is_output_bounded": [
      "self"
    ]
  },
  "ModelBuilderMode": {
    "FLOAT": [],
    "QUANTIZED": [],
    "MIXEDPRECISION": []
  },
  "validate_before_compute_similarity": [
    "float_tensor",
    "fxp_tensor"
  ],
  "_similarity_tensor_norm": [
    "x",
    "p"
  ],
  "flatten_tensor": [
    "t",
    "batch",
    "axis"
  ],
  "compute_mse": [
    "float_tensor",
    "fxp_tensor",
    "norm",
    "norm_eps",
    "batch",
    "axis",
    "weights"
  ],
  "compute_mae": [
    "float_tensor",
    "fxp_tensor",
    "norm",
    "norm_eps",
    "batch",
    "axis"
  ],
  "compute_cs": [
    "float_tensor",
    "fxp_tensor",
    "eps",
    "batch",
    "axis"
  ],
  "compute_lp_norm": [
    "float_tensor",
    "fxp_tensor",
    "p",
    "norm",
    "norm_eps",
    "batch",
    "axis"
  ],
  "compute_kl_divergence": [
    "float_tensor",
    "fxp_tensor",
    "batch",
    "axis"
  ],
  "create_stats_collector_for_node": [
    "node",
    "fw_info",
    "quant_node_in_fln"
  ],
  "create_tensor2node": [
    "graph",
    "node",
    "fw_info"
  ],
  "ensure_matching_data_lengths": [
    "stats_collector",
    "tensor_data",
    "hessian_data"
  ],
  "convert_to_numpy_and_abs": [
    "tensor",
    "fw_impl"
  ],
  "ModelCollector": {
    "__init__": [
      "self",
      "graph",
      "fw_impl",
      "fw_info",
      "hessian_info_service",
      "qc"
    ],
    "infer": [
      "self",
      "inputs_list"
    ]
  },
  "FrameworkImplementation": {
    "constants": [
      "self"
    ],
    "get_hessian_scores_calculator": [
      "self",
      "graph",
      "input_images",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "to_numpy": [
      "self",
      "tensor"
    ],
    "to_tensor": [
      "self",
      "tensor"
    ],
    "is_tuple_of_tensors": [
      "self",
      "obj"
    ],
    "model_reader": [
      "self",
      "model",
      "representative_data_gen"
    ],
    "model_builder": [
      "self",
      "graph",
      "mode",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "run_model_inference": [
      "self",
      "model",
      "input_list",
      "requires_grad"
    ],
    "shift_negative_correction": [
      "self",
      "graph",
      "core_config",
      "fw_info"
    ],
    "compute_activation_bias_correction": [
      "self",
      "graph",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_channel_equalization": [
      "self",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_prepare_graph": [
      "self",
      "fw_info"
    ],
    "get_substitutions_pre_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_linear_collapsing_substitution": [
      "self"
    ],
    "get_op2d_add_const_collapsing_substitution": [
      "self"
    ],
    "get_substitutions_statistics_correction": [
      "self",
      "quant_config"
    ],
    "get_residual_collapsing_substitution": [
      "self"
    ],
    "get_substitutions_post_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_substitutions_virtual_weights_activation_coupling": [
      "self"
    ],
    "get_substitutions_after_second_moment_correction": [
      "self",
      "quant_config"
    ],
    "get_node_prior_info": [
      "self",
      "node",
      "fw_info",
      "graph"
    ],
    "count_node_for_mixed_precision_interest_points": [
      "self",
      "node"
    ],
    "get_mp_node_distance_fn": [
      "self",
      "n",
      "compute_distance_fn",
      "norm_mse"
    ],
    "is_output_node_compatible_for_hessian_score_computation": [
      "self",
      "node"
    ],
    "get_node_mac_operations": [
      "self",
      "node",
      "fw_info"
    ],
    "apply_second_moment_correction": [
      "self",
      "quantized_model",
      "core_config",
      "representative_data_gen",
      "graph"
    ],
    "sensitivity_eval_inference": [
      "self",
      "model",
      "inputs"
    ],
    "get_inferable_quantizers": [
      "self",
      "node"
    ],
    "convert_data_gen_to_dataloader": [
      "data_gen_fn",
      "batch_size"
    ]
  },
  "BaseModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "build_model": [
      "self"
    ]
  },
  "VirtualNode": {},
  "VirtualSplitNode": {
    "__init__": [
      "self",
      "origin_node"
    ]
  },
  "VirtualSplitWeightsNode": {
    "__init__": [
      "self",
      "origin_node",
      "kernel_attr"
    ]
  },
  "VirtualSplitActivationNode": {
    "__init__": [
      "self",
      "origin_node",
      "activation_class",
      "fw_attr"
    ]
  },
  "VirtualActivationWeightsNode": {
    "__init__": [
      "self",
      "act_node",
      "weights_node",
      "fw_info"
    ]
  },
  "NodeOperationMatcher": {
    "__init__": [
      "self",
      "operation"
    ],
    "apply": [
      "self",
      "input_node_object"
    ]
  },
  "NodeFrameworkAttrMatcher": {
    "__init__": [
      "self",
      "attr_name",
      "attr_value"
    ],
    "apply": [
      "self",
      "input_node_object"
    ]
  },
  "EdgeMatcher": {
    "__init__": [
      "self",
      "source_matcher",
      "target_matcher"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "WalkMatcher": {
    "__init__": [
      "self",
      "matcher_list"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "validate_graph_after_change": [
    "method"
  ],
  "OutTensor": [],
  "Graph": {
    "__init__": [
      "self",
      "name",
      "nodes",
      "input_nodes",
      "output_nodes",
      "edge_list",
      "fw_info"
    ],
    "skip_validation_check": [
      "self",
      "value"
    ],
    "fusing_info": [
      "self",
      "fusing_info"
    ],
    "set_fw_info": [
      "self",
      "fw_info"
    ],
    "set_fqc": [
      "self",
      "fqc"
    ],
    "get_topo_sorted_nodes": [
      "self"
    ],
    "get_op_list": [
      "self"
    ],
    "get_inputs": [
      "self"
    ],
    "get_outputs": [
      "self"
    ],
    "set_inputs": [
      "self",
      "input_nodes"
    ],
    "set_outputs": [
      "self",
      "output_nodes"
    ],
    "set_out_stats_collector_to_node": [
      "self",
      "n",
      "stats_collector"
    ],
    "get_out_stats_collector": [
      "self",
      "n"
    ],
    "get_in_stats_collector": [
      "self",
      "n"
    ],
    "scale_stats_collector": [
      "self",
      "node",
      "scale_factor"
    ],
    "shift_stats_collector": [
      "self",
      "node",
      "shift_value"
    ],
    "find_node_by_name": [
      "self",
      "name"
    ],
    "get_next_nodes": [
      "self",
      "node_obj"
    ],
    "get_prev_nodes": [
      "self",
      "node_obj",
      "sink_index_sorted"
    ],
    "reconnect_out_edges": [
      "self",
      "current_node",
      "new_node"
    ],
    "reconnect_in_edges": [
      "self",
      "current_node",
      "new_node"
    ],
    "add_node_with_in_edges": [
      "self",
      "new_node",
      "input_nodes",
      "input_nodes_output_index"
    ],
    "replace_output_node": [
      "self",
      "current_node",
      "new_node"
    ],
    "replace_input_node": [
      "self",
      "current_node",
      "new_node"
    ],
    "remove_node": [
      "self",
      "node_to_remove",
      "new_graph_inputs",
      "new_graph_outputs"
    ],
    "incoming_edges": [
      "self",
      "n",
      "sort_by_attr"
    ],
    "out_edges": [
      "self",
      "n",
      "sort_by_attr"
    ],
    "get_configurable_sorted_nodes_names": [
      "self",
      "fw_info",
      "include_reused_nodes"
    ],
    "get_weights_configurable_nodes": [
      "self",
      "fw_info",
      "include_reused_nodes"
    ],
    "get_sorted_weights_configurable_nodes": [
      "self",
      "fw_info",
      "include_reused_nodes"
    ],
    "get_activation_configurable_nodes": [
      "self"
    ],
    "get_sorted_activation_configurable_nodes": [
      "self"
    ],
    "get_configurable_sorted_nodes": [
      "self",
      "fw_info",
      "include_reused_nodes"
    ],
    "_sort_nodes_in_list": [
      "self",
      "nodes_list"
    ],
    "get_min_candidates_config": [
      "self",
      "fw_info"
    ],
    "get_max_candidates_config": [
      "self",
      "fw_info"
    ],
    "get_final_weights_config": [
      "self",
      "fw_info"
    ],
    "get_final_activation_config": [
      "self"
    ],
    "retrieve_preserved_quantization_node": [
      "self",
      "node"
    ],
    "has_any_configurable_activation": [
      "self"
    ],
    "has_any_configurable_weights": [
      "self"
    ],
    "replace_node": [
      "self",
      "node_to_replace",
      "new_node"
    ],
    "get_pruning_sections": [
      "self",
      "fw_impl"
    ],
    "get_pruning_sections_entry_nodes": [
      "self",
      "fw_impl"
    ],
    "_is_node_topology_prunable": [
      "self",
      "entry_node",
      "fw_impl"
    ],
    "_create_pruning_section": [
      "self",
      "entry_node",
      "fw_impl"
    ],
    "_find_intermediate_and_exit_nodes": [
      "self",
      "entry_node",
      "fw_impl"
    ],
    "disable_fused_nodes_activation_quantization": [
      "self"
    ],
    "validate": [
      "self"
    ],
    "add_edge": [
      "self"
    ],
    "remove_edge": [
      "self"
    ]
  },
  "GraphSearches": {
    "_node_filter": [
      "self",
      "node_matcher"
    ],
    "_edge_filter": [
      "self",
      "edge_matcher"
    ],
    "_walk_filter": [
      "self",
      "walk_matcher"
    ]
  },
  "EDGE_SOURCE_INDEX": [],
  "EDGE_SINK_INDEX": [],
  "Edge": {
    "__init__": [
      "self",
      "source_node",
      "sink_node",
      "source_index",
      "sink_index"
    ],
    "get_attributes": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "convert_to_edge": [
    "edge"
  ],
  "FunctionalNode": {
    "__init__": [
      "self",
      "name",
      "framework_attr",
      "input_shape",
      "output_shape",
      "weights",
      "layer_class",
      "op_call_args",
      "op_call_kwargs",
      "reuse",
      "reuse_group",
      "quantization_attr",
      "functional_op",
      "inputs_as_list",
      "has_activation",
      "tensor_input_allocs"
    ],
    "type": [
      "self"
    ],
    "is_match_type": [
      "self",
      "_type"
    ]
  },
  "WeightAttrT": [],
  "BaseNode": {
    "__init__": [
      "self",
      "name",
      "framework_attr",
      "input_shape",
      "output_shape",
      "weights",
      "layer_class",
      "reuse",
      "reuse_group",
      "inputs_as_list",
      "quantization_attr",
      "has_activation",
      "is_custom"
    ],
    "type": [
      "self"
    ],
    "get_has_activation": [
      "self"
    ],
    "has_positional_weights": [
      "self"
    ],
    "_is_single_quant_mode": [
      "self",
      "q_mode"
    ],
    "is_activation_quantization_enabled": [
      "self"
    ],
    "is_fln_quantization": [
      "self"
    ],
    "is_quantization_preserving": [
      "self"
    ],
    "is_weights_quantization_enabled": [
      "self",
      "attr_name"
    ],
    "is_configurable_weight": [
      "self",
      "attr_name"
    ],
    "has_any_configurable_weight": [
      "self"
    ],
    "has_configurable_activation": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "is_reused": [
      "self"
    ],
    "_get_weight_name": [
      "self",
      "name"
    ],
    "get_weights_by_keys": [
      "self",
      "name"
    ],
    "set_weights_by_keys": [
      "self",
      "name",
      "tensor"
    ],
    "get_weights_list": [
      "self"
    ],
    "get_node_weights_attributes": [
      "self"
    ],
    "insert_positional_weights_to_input_list": [
      "self",
      "input_tensors"
    ],
    "get_num_parameters": [
      "self",
      "fw_info"
    ],
    "get_memory_bytes": [
      "self",
      "fw_info"
    ],
    "get_unified_weights_candidates_dict": [
      "self",
      "fw_info"
    ],
    "get_unified_activation_candidates_dict": [
      "self"
    ],
    "is_all_activation_candidates_equal": [
      "self"
    ],
    "is_all_weights_candidates_equal": [
      "self",
      "attr"
    ],
    "has_kernel_weight_to_quantize": [
      "self",
      "fw_info"
    ],
    "has_any_weight_attr_to_quantize": [
      "self"
    ],
    "get_output_shapes_list": [
      "self"
    ],
    "get_total_output_params": [
      "self"
    ],
    "find_min_candidate_index": [
      "self"
    ],
    "find_max_candidate_index": [
      "self"
    ],
    "get_unique_weights_candidates": [
      "self",
      "attr"
    ],
    "get_unique_activation_candidates": [
      "self"
    ],
    "has_activation_quantization_enabled_candidate": [
      "self"
    ],
    "get_all_weights_attr_candidates": [
      "self",
      "attr"
    ],
    "get_qco": [
      "self",
      "fqc"
    ],
    "filter_node_qco_by_graph": [
      "self",
      "fqc",
      "next_nodes",
      "node_qc_options"
    ],
    "is_match_type": [
      "self",
      "_type"
    ],
    "is_match_filter_params": [
      "self",
      "layer_filter_params"
    ],
    "get_simd": [
      "self"
    ],
    "sort_node_candidates": [
      "self",
      "fw_info"
    ]
  },
  "DirectedBipartiteGraph": {
    "__init__": [
      "self",
      "name",
      "a_nodes",
      "b_nodes",
      "edges_ab",
      "edges_ba"
    ],
    "_update_nodes_sets": [
      "self"
    ],
    "_verify_edges": [
      "self",
      "edges_list"
    ],
    "add_nodes_to_a": [
      "self",
      "new_nodes"
    ],
    "add_nodes_to_b": [
      "self",
      "new_nodes"
    ],
    "add_edges": [
      "self",
      "new_edges"
    ]
  },
  "ActivationMemoryTensor": {
    "__init__": [
      "self",
      "shape",
      "node_name",
      "node_output_index",
      "init_size_to_zero"
    ],
    "_get_tensor_total_size": [
      "self"
    ]
  },
  "MemoryElements": {
    "__init__": [
      "self",
      "elements",
      "total_size"
    ],
    "add_element": [
      "self",
      "new_element"
    ],
    "add_elements_set": [
      "self",
      "new_elements_set"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__copy__": [
      "self"
    ]
  },
  "SchedulerInfo": [],
  "compute_graph_max_cut": [
    "memory_graph",
    "n_iter",
    "astar_n_iter",
    "eps"
  ],
  "MemoryGraph": {
    "__init__": [
      "self",
      "model_graph"
    ],
    "update_sources_a": [
      "self"
    ],
    "update_sinks_b": [
      "self"
    ],
    "activation_tensor_children": [
      "self",
      "activation_tensor"
    ],
    "activation_tensor_parents": [
      "self",
      "activation_tensor"
    ],
    "operation_node_children": [
      "self",
      "op_node"
    ],
    "operation_node_parents": [
      "self",
      "op_node"
    ]
  },
  "DummyType": {},
  "DummyBaseNodeGenerator": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "DummyActivationMemoryTensorGenerator": {
    "__init__": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "MaxCutAstar": {
    "__init__": [
      "self",
      "memory_graph"
    ],
    "solve": [
      "self",
      "estimate",
      "iter_limit",
      "time_limit"
    ],
    "_update_expanded_node": [
      "cut",
      "cost",
      "route",
      "open_list",
      "costs",
      "routes"
    ],
    "_get_cut_to_expand": [
      "self",
      "open_list",
      "costs",
      "routes",
      "estimate"
    ],
    "clean_memory_for_next_step": [
      "self",
      "cut"
    ],
    "can_expand": [
      "self",
      "op_node",
      "cut"
    ],
    "expand": [
      "self",
      "cut"
    ],
    "is_pivot": [
      "self",
      "cut"
    ],
    "accumulate": [
      "cost_1",
      "cost_2"
    ],
    "ordering": [
      "cost_1",
      "cost_2"
    ],
    "estimate": [
      "cut",
      "estimate"
    ],
    "get_init_estimate": [
      "memory_graph"
    ],
    "_remove_dummy_nodes_from_path": [
      "path"
    ],
    "_remove_dummy_tensors_from_cut": [
      "cut"
    ]
  },
  "Cut": {
    "sorted_elements_signature": [
      "self"
    ],
    "memory_size": [
      "self"
    ],
    "get_record_names": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "edit_network_graph": [
    "graph",
    "fw_info",
    "network_editor"
  ],
  "NodeTypeFilter": {
    "__init__": [
      "self",
      "node_type"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "NodeNameFilter": {
    "__init__": [
      "self",
      "node_name"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "NodeNameScopeFilter": {
    "__init__": [
      "self",
      "node_name_scope"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "_EditRule": [],
  "EditRule": {
    "__repr__": [
      "self"
    ]
  },
  "BaseAction": {
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeCandidatesWeightsQuantConfigAttr": {
    "__init__": [
      "self",
      "attr_name"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeFinalWeightsQuantConfigAttr": {
    "__init__": [
      "self",
      "attr_name"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeCandidatesActivationQuantConfigAttr": {
    "__init__": [
      "self"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeFinalActivationQuantConfigAttr": {
    "__init__": [
      "self"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeQuantizationParamFunction": {
    "__init__": [
      "self",
      "attr_name",
      "activation_quantization_params_fn",
      "weights_quantization_params_fn"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeFinalActivationQuantizationMethod": {
    "__init__": [
      "self",
      "activation_quantization_method"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeCandidatesActivationQuantizationMethod": {
    "__init__": [
      "self",
      "activation_quantization_method"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeFinalWeightsQuantizationMethod": {
    "__init__": [
      "self",
      "attr_name",
      "weights_quantization_method"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ChangeCandidatesWeightsQuantizationMethod": {
    "__init__": [
      "self",
      "attr_name",
      "weights_quantization_method"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "ReplaceLayer": {
    "__init__": [
      "self",
      "layer_type",
      "get_params_and_weights_fn"
    ],
    "apply": [
      "self",
      "node",
      "graph",
      "fw_info"
    ]
  },
  "Pruner": {
    "__init__": [
      "self",
      "float_graph",
      "fw_info",
      "fw_impl",
      "target_resource_utilization",
      "representative_data_gen",
      "pruning_config",
      "target_platform_capabilities"
    ],
    "prune_graph": [
      "self"
    ],
    "get_score_per_entry_point": [
      "self",
      "entry_nodes"
    ],
    "get_pruning_info": [
      "self"
    ]
  },
  "PruningSectionMask": {
    "__init__": [
      "self",
      "entry_node_ic_mask",
      "entry_node_oc_mask",
      "exit_node_ic_mask",
      "exit_node_oc_mask"
    ]
  },
  "PruningSection": {
    "__init__": [
      "self",
      "entry_node",
      "intermediate_nodes",
      "exit_node"
    ],
    "get_all_section_nodes": [
      "self"
    ],
    "apply_inner_section_mask": [
      "self",
      "pruning_section_mask",
      "fw_impl",
      "fw_info"
    ],
    "has_matching_channel_count": [
      "exit_node",
      "corresponding_entry_node",
      "fw_info"
    ]
  },
  "ChannelGrouping": {
    "__init__": [
      "self",
      "prunable_nodes",
      "fw_info"
    ],
    "simd_groups_indices": [
      "self"
    ],
    "group_scores_by_simd_groups": [
      "self",
      "score_by_node"
    ],
    "_group_node_scores": [
      "self",
      "scores",
      "simd"
    ]
  },
  "PruningInfo": {
    "__init__": [
      "self",
      "pruning_masks",
      "importance_scores"
    ],
    "pruning_masks": [
      "self"
    ],
    "importance_scores": [
      "self"
    ]
  },
  "unroll_simd_scores_to_per_channel_scores": [
    "simd_scores",
    "simd_groups_indices"
  ],
  "PruningFrameworkImplementation": {
    "prune_entry_node": [
      "self",
      "node",
      "output_mask",
      "fw_info"
    ],
    "prune_intermediate_node": [
      "self",
      "node",
      "input_mask",
      "output_mask",
      "fw_info"
    ],
    "prune_exit_node": [
      "self",
      "node",
      "input_mask",
      "fw_info"
    ],
    "is_node_entry_node": [
      "self",
      "node"
    ],
    "is_node_exit_node": [
      "self",
      "node",
      "corresponding_entry_node",
      "fw_info"
    ],
    "is_node_intermediate_pruning_section": [
      "self",
      "node"
    ],
    "attrs_oi_channels_info_for_pruning": [
      "self",
      "node",
      "fw_info"
    ]
  },
  "GreedyMaskCalculator": {
    "__init__": [
      "self",
      "prunable_nodes",
      "fw_info",
      "simd_groups_scores",
      "target_resource_utilization",
      "graph",
      "fw_impl",
      "fqc",
      "simd_groups_indices"
    ],
    "get_mask": [
      "self"
    ],
    "compute_mask": [
      "self"
    ],
    "_get_most_sensitive_simd_group_candidate": [
      "self"
    ]
  },
  "MemoryCalculator": {
    "__init__": [
      "self",
      "graph",
      "fw_info",
      "fw_impl"
    ],
    "get_pruned_graph_memory": [
      "self",
      "masks",
      "include_padded_channels"
    ],
    "get_pruned_graph_num_params": [
      "self",
      "masks",
      "include_padded_channels"
    ],
    "get_nparams_of_shared_nodes": [
      "self",
      "masks",
      "pruning_sections",
      "include_padded_channels"
    ],
    "get_nparams_of_pruning_sections": [
      "self",
      "masks",
      "pruning_sections",
      "include_padded_channels"
    ],
    "get_section_mask_from_node_mask": [
      "self",
      "masks",
      "pruning_section",
      "pruning_sections"
    ],
    "get_nparams_of_nonpruned_nodes": [
      "self",
      "pruning_sections",
      "include_padded_channels"
    ],
    "_get_exit_node_input_mask": [
      "self",
      "node",
      "pruning_sections",
      "masks"
    ],
    "_get_nodes_from_adjacent_sections": [
      "self",
      "pruning_sections"
    ],
    "_get_pruning_section_num_params": [
      "self",
      "pruning_section",
      "pruning_section_mask",
      "include_padded_channels"
    ],
    "get_pruned_node_num_params": [
      "self",
      "node",
      "input_mask",
      "output_mask",
      "include_padded_channels"
    ],
    "_prune_tensor": [
      "self",
      "w",
      "mask",
      "axis"
    ],
    "get_node_nparams_with_padded_channels": [
      "self",
      "node",
      "node_nparams",
      "num_oc",
      "node_simd"
    ]
  },
  "build_pruned_graph": [
    "graph",
    "masks",
    "fw_info",
    "fw_impl"
  ],
  "ImportanceMetric": {
    "LFH": []
  },
  "ChannelsFilteringStrategy": {
    "GREEDY": []
  },
  "PruningConfig": {
    "__init__": [
      "self",
      "num_score_approximations",
      "importance_metric",
      "channels_filtering_strategy"
    ]
  },
  "IMPORTANCE_METRIC_DICT": [],
  "get_importance_metric": [
    "im"
  ],
  "LFHImportanceMetric": {
    "__init__": [
      "self",
      "graph",
      "representative_data_gen",
      "fw_impl",
      "pruning_config",
      "fw_info"
    ],
    "get_entry_node_to_simd_score": [
      "self",
      "entry_nodes"
    ],
    "_get_entry_node_to_score": [
      "self",
      "entry_nodes"
    ],
    "_compute_simd_groups_indices": [
      "self",
      "entry_node_to_score"
    ],
    "_normalize_lfh_scores": [
      "self",
      "entry_node_to_squaredl2norm"
    ],
    "_count_oc_nparams": [
      "self",
      "entry_nodes"
    ],
    "_get_squaredl2norm": [
      "self",
      "entry_nodes",
      "grouped_indices"
    ],
    "_get_kernel_node_oc_info": [
      "self",
      "entry_node"
    ],
    "_concatenate_tensors_by_indices": [
      "self",
      "channels",
      "index_list"
    ]
  },
  "BaseImportanceMetric": {
    "get_entry_node_to_simd_score": [
      "self",
      "entry_nodes"
    ]
  },
  "MaskIndicator": {
    "PRUNED": [],
    "REMAINED": []
  },
  "PerChannelMask": {
    "__init__": [
      "self",
      "prunable_nodes",
      "fw_info"
    ],
    "get_mask": [
      "self"
    ],
    "set_mask_value_for_simd_group": [
      "self",
      "node",
      "channel_idx",
      "mask_indicator"
    ],
    "has_pruned_channel": [
      "self"
    ],
    "_init_masks": [
      "self"
    ],
    "_compute_num_of_out_channels": [
      "self",
      "node"
    ]
  },
  "PerSIMDGroupMask": {
    "__init__": [
      "self",
      "prunable_nodes",
      "fw_info",
      "simd_groups_indices"
    ],
    "get_mask_simd": [
      "self"
    ],
    "get_mask": [
      "self"
    ],
    "set_mask_value_for_simd_group": [
      "self",
      "node",
      "group_index",
      "mask_indicator"
    ],
    "has_pruned_channel": [
      "self"
    ],
    "_init_masks": [
      "self"
    ],
    "_update_mandatory_mask": [
      "self"
    ]
  },
  "apply_activation_bias_correction_to_graph": [
    "graph",
    "core_config",
    "fw_impl"
  ],
  "_apply_activation_bias_correction_to_node": [
    "node",
    "fw_impl",
    "qc"
  ],
  "get_previous_node_with_activation_quantization": [
    "linear_node",
    "graph"
  ],
  "calculate_bin_centers": [
    "bin_edges"
  ],
  "compute_activation_bias_correction": [
    "graph",
    "quant_config",
    "fw_info",
    "fw_impl",
    "linear_node",
    "prev_node",
    "kernel_size"
  ],
  "compute_activation_bias_correction_of_graph": [
    "graph",
    "quant_config",
    "fw_info",
    "fw_impl",
    "activation_bias_correction_node_matchers",
    "kernel_size"
  ],
  "statistics_correction_runner": [
    "transformed_graph",
    "core_config",
    "fw_info",
    "fw_impl",
    "tb_w"
  ],
  "apply_statistics_correction": [
    "transformed_graph",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl",
    "tb_w"
  ],
  "compute_bias_correction_of_graph": [
    "graph",
    "fw_info",
    "fw_impl"
  ],
  "_compute_bias_correction_per_candidate_qc": [
    "node",
    "kernel_attr",
    "fw_info",
    "node_in_stats_collector",
    "fw_impl"
  ],
  "is_non_positive_integer": [
    "x"
  ],
  "_compute_bias_correction": [
    "kernel",
    "quantized_kernel",
    "in_statistics_container",
    "output_channels_axis",
    "input_channels_axis",
    "node_name"
  ],
  "_get_bias_correction_term_of_node": [
    "input_channels_axis",
    "n",
    "node_in_stats_collector",
    "output_channels_axis",
    "quantized_kernel",
    "fw_impl"
  ],
  "_collect_and_assign_act_threshold": [
    "graph",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl"
  ],
  "quantized_model_builder_for_second_moment_correction": [
    "graph",
    "fw_info",
    "fw_impl"
  ],
  "apply_second_moment_correction_to_graph": [
    "graph",
    "representative_data_gen",
    "core_config",
    "fw_info",
    "fw_impl"
  ],
  "apply_bias_correction_to_graph": [
    "graph_to_apply_bias_correction",
    "core_config",
    "fw_impl"
  ],
  "_apply_bias_correction_to_node": [
    "node",
    "fw_impl",
    "qc"
  ],
  "FusedLayerType": {
    "__init__": [
      "self"
    ]
  },
  "GraphFuser": {
    "apply_node_fusion": [
      "self",
      "graph"
    ],
    "_create_fused_node": [
      "fused_node_id",
      "nodes"
    ],
    "_replace_nodes_with_fused_node": [
      "graph",
      "nodes_to_fuse",
      "fused_node"
    ]
  },
  "FUSED_OP_ID_PREFIX": [],
  "FusingInfo": {
    "__post_init__": [
      "self"
    ],
    "_init_node_mapping": [
      "self"
    ],
    "get_manual_nodes_to_fuse": [
      "self"
    ],
    "add_manual_nodes_to_fuse": [
      "self",
      "node_names"
    ],
    "_init_quantization_config_map": [
      "self"
    ],
    "add_fused_operation": [
      "self",
      "op_id",
      "nodes"
    ],
    "set_fused_op_quantization_config": [
      "self",
      "op_id",
      "nodes"
    ],
    "remove_fused_operation": [
      "self",
      "op_id"
    ],
    "get_fused_op_id_for_node": [
      "self",
      "node_name"
    ],
    "get_node_to_fused_node_map": [
      "self"
    ],
    "get_fusing_quantization_config_map": [
      "self"
    ],
    "get_fused_nodes": [
      "self",
      "op_id"
    ],
    "get_inner_fln_nodes": [
      "self"
    ],
    "get_fused_op_quantization_config": [
      "self",
      "op_id"
    ],
    "is_node_in_fused_op": [
      "self",
      "node"
    ],
    "is_quantized_node_in_fln": [
      "self",
      "node"
    ],
    "get_all_fused_operations": [
      "self"
    ],
    "generate_fused_op_id": [
      "nodes"
    ],
    "validate": [
      "self",
      "graph"
    ],
    "is_nodes_eligible_to_be_fused": [
      "self",
      "nodes"
    ],
    "__repr__": [
      "self"
    ]
  },
  "FusingInfoGenerator": {
    "__init__": [
      "self",
      "fusing_patterns",
      "manual_fused_ops"
    ],
    "generate_fusing_info": [
      "self",
      "graph"
    ]
  },
  "get_valid_fusing_patterns_for_node": [
    "fusing_patterns",
    "node",
    "idx"
  ],
  "is_valid_fusion": [
    "fusing_patterns",
    "nodes",
    "manual_fused_names"
  ],
  "_get_fusing_layer_patterns": [
    "fusing_patterns"
  ],
  "check_broadcastable": [
    "x",
    "weights"
  ],
  "WeightedHistogramCollector": {
    "__init__": [
      "self",
      "n_bins"
    ],
    "update": [
      "self",
      "x",
      "weights"
    ]
  },
  "interpolate_histogram": [
    "current_bins",
    "bins_to_interpolate",
    "counts_to_interpolate"
  ],
  "HistogramCollector": {
    "__init__": [
      "self",
      "n_bins"
    ],
    "_merge_histograms": [
      "self"
    ],
    "scale": [
      "self",
      "scale_factor"
    ],
    "shift": [
      "self",
      "shift_value"
    ],
    "get_histogram": [
      "self"
    ],
    "max": [
      "self"
    ],
    "min": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "BaseCollector": {
    "__init__": [
      "self"
    ],
    "scale": [
      "self",
      "scale_factor"
    ],
    "shift": [
      "self",
      "shift_value"
    ],
    "update_legal_status": [
      "self",
      "is_illegal"
    ],
    "validate_data_correctness": [
      "self"
    ]
  },
  "MeanCollector": {
    "__init__": [
      "self",
      "axis"
    ],
    "scale": [
      "self",
      "scale_factor"
    ],
    "shift": [
      "self",
      "shift_value"
    ],
    "state": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "BaseStatsCollector": {
    "require_collection": [
      "self"
    ],
    "update_statistics": [
      "self",
      "x"
    ]
  },
  "StatsCollector": {
    "__init__": [
      "self",
      "out_channel_axis",
      "init_min_value",
      "init_max_value"
    ],
    "update_statistics": [
      "self",
      "x",
      "weights"
    ],
    "get_mean": [
      "self"
    ],
    "get_min_max_values": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "require_collection": [
      "self"
    ]
  },
  "NoStatsCollector": {
    "__init__": [
      "self"
    ],
    "update_statistics": [
      "self",
      "x"
    ],
    "__repr__": [
      "self"
    ],
    "require_collection": [
      "self"
    ]
  },
  "is_number": [
    "num"
  ],
  "standardize_tensor": [
    "x"
  ],
  "shift_statistics": [
    "collector",
    "shift_value"
  ],
  "scale_statistics": [
    "collector",
    "scale_value"
  ],
  "MinMaxPerChannelCollector": {
    "__init__": [
      "self",
      "axis",
      "init_min_value",
      "init_max_value"
    ],
    "scale": [
      "self",
      "scale_factor"
    ],
    "shift": [
      "self",
      "shift_value"
    ],
    "min": [
      "self"
    ],
    "max": [
      "self"
    ],
    "max_per_channel": [
      "self"
    ],
    "min_per_channel": [
      "self"
    ],
    "update": [
      "self",
      "x"
    ]
  },
  "HessianMode": {
    "WEIGHTS": [],
    "ACTIVATION": []
  },
  "HessianScoresGranularity": {
    "PER_ELEMENT": [],
    "PER_OUTPUT_CHANNEL": [],
    "PER_TENSOR": []
  },
  "HessianScoresRequest": {
    "__post_init__": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "normalize_scores": [
    "hessian_approximations"
  ],
  "LayerName": [],
  "Tensor": [],
  "Query": {},
  "HessianCache": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "layers_hessians",
      "request"
    ],
    "fetch_hessian": [
      "self",
      "request"
    ],
    "clear": [
      "self"
    ]
  },
  "HessianInfoService": {
    "__init__": [
      "self",
      "graph",
      "fw_impl",
      "num_iterations_for_approximation"
    ],
    "fetch_hessian": [
      "self",
      "request",
      "activation_tensors",
      "force_compute"
    ],
    "clear_cache": [
      "self"
    ],
    "_fetch_hessians_with_compute": [
      "self",
      "request",
      "n_iterations"
    ],
    "_compute_hessians": [
      "self",
      "request",
      "n_iterations",
      "count_by_cache"
    ],
    "_compute_hessian_for_batch": [
      "self",
      "request",
      "inputs_batch",
      "n_iterations"
    ],
    "_get_primary_node": [
      "self",
      "node"
    ]
  },
  "HessianScoresCalculator": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "compute": [
      "self"
    ],
    "unfold_tensors_list": [
      "self",
      "tensors_to_unfold"
    ]
  },
  "fixed_mean_after_relu": [
    "mu",
    "std"
  ],
  "fixed_second_moment_after_relu": [
    "mu",
    "std"
  ],
  "scale_reshaping": [
    "scale",
    "op2d",
    "kernel_channel_mapping",
    "kernel_str",
    "in_channels"
  ],
  "update_linear_nodes": [
    "fw_info",
    "first_op2d_node",
    "second_op2d_node",
    "scale_factor",
    "kernel_str",
    "bias_str"
  ],
  "calculate_scale_correction": [
    "first_op2d_node"
  ],
  "scale_equalization_lnl": [
    "fw_info",
    "first_op2d_node",
    "second_op2d_node",
    "kernel_str",
    "bias_str"
  ],
  "BaseScaleEqualization": {
    "__init__": [
      "self",
      "quant_config",
      "fw_info",
      "matcher_instance",
      "kernel_str",
      "bias_str"
    ],
    "substitute": [
      "self",
      "graph",
      "nodes_list"
    ]
  },
  "BatchNormalizationReconstruction": {
    "__init__": [
      "self",
      "source_node",
      "create_bn_node",
      "gamma_str",
      "beta_str",
      "moving_mean_str",
      "moving_variance_str",
      "epsilon_val"
    ],
    "substitute": [
      "self",
      "graph",
      "source_node"
    ]
  },
  "op2d_bias_correction": [
    "op2d_node",
    "shift_to_correct",
    "fw_info",
    "bias_str",
    "bias_flag_str"
  ],
  "insert_node_between_two_nodes": [
    "graph",
    "node_to_insert",
    "first_node",
    "last_node"
  ],
  "insert_node_after_node": [
    "graph",
    "node_to_insert",
    "first_node"
  ],
  "insert_node_before_node": [
    "graph",
    "node_to_insert",
    "last_node"
  ],
  "remove_node_between_two_nodes": [
    "graph",
    "node_to_remove",
    "first_node",
    "last_node"
  ],
  "fuse_padding_with_op2d": [
    "graph",
    "pad_node",
    "op2d_node"
  ],
  "update_fused_op_with_add": [
    "graph",
    "non_linear_node",
    "add_node"
  ],
  "shift_negative_function": [
    "graph",
    "core_config",
    "non_linear_node",
    "op2d_node",
    "fw_info",
    "create_add_node",
    "get_padding_values",
    "create_pad_node",
    "padding_str",
    "bias_str",
    "bias_flag_str",
    "zero_padding_node",
    "bypass_nodes",
    "params_search_quantization_fn"
  ],
  "get_next_nodes_to_correct": [
    "n",
    "graph",
    "linear_node_types",
    "bypass_node_types",
    "pad_node_types",
    "is_padding_node_and_node_has_padding",
    "pad_node_to_consider",
    "bypass_nodes"
  ],
  "apply_shift_negative_correction": [
    "graph",
    "core_config",
    "fw_info",
    "snc_node_types",
    "linear_node_types",
    "bypass_node_types",
    "pad_node_types",
    "create_add_node",
    "get_padding_values",
    "create_pad_node",
    "is_padding_node_and_node_has_padding",
    "padding_str",
    "bias_str",
    "bias_flag_str",
    "params_search_quantization_fn"
  ],
  "BaseWeightsActivationSplit": {
    "__init__": [
      "self",
      "activation_layer_type",
      "fw_attr",
      "matcher_instance"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "substitute": [
    "graph",
    "substitutions_list"
  ],
  "BatchNormalizationRefusing": {
    "__init__": [
      "self",
      "source_node",
      "bn_node",
      "update_kernel_for_bn_refusing_fn",
      "kernel_str",
      "bias_str",
      "gamma_str",
      "beta_str",
      "moving_mean_str",
      "moving_variance_str",
      "epsilon_str",
      "use_bias",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ],
    "_calc_weights_quantization_params": [
      "self",
      "conv_bn",
      "weights_scale",
      "fw_info"
    ]
  },
  "ResidualCollapsing": {
    "__init__": [
      "self",
      "first_node",
      "second_node",
      "residual_collapsing_fn",
      "kernel_str",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ]
  },
  "BatchNormalizationFolding": {
    "__init__": [
      "self",
      "source_node",
      "bn_node",
      "update_kernel_for_bn_folding_fn",
      "kernel_str",
      "bias_str",
      "gamma_str",
      "beta_str",
      "moving_mean_str",
      "moving__variance_str",
      "epsilon_str",
      "use_bias",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ]
  },
  "BatchNormalizationForwardFolding": {
    "__init__": [
      "self",
      "bn_node",
      "conv_node",
      "update_weights_for_bn_forward_folding_fn",
      "get_kernel_hw_fn",
      "is_group_conv_fn",
      "get_foldable_node_type_and_validity_fn",
      "kernel_str",
      "bias_str",
      "gamma_str",
      "beta_str",
      "moving_mean_str",
      "moving__variance_str",
      "epsilon_str",
      "use_bias",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ]
  },
  "remove_identity_node": [
    "graph",
    "node"
  ],
  "linear_collapsing_substitute": [
    "graph",
    "linear_collapsing_substitution"
  ],
  "SoftmaxShift": {
    "__init__": [
      "self",
      "nodes",
      "bias_str"
    ],
    "substitute": [
      "self",
      "graph",
      "nodes"
    ]
  },
  "BaseVirtualActivationWeightsComposition": {
    "__init__": [
      "self",
      "matcher_instance"
    ],
    "substitute": [
      "self",
      "graph",
      "weights_node"
    ]
  },
  "get_input_activation_if_composable": [
    "graph",
    "weights_node",
    "warn"
  ],
  "Conv2DCollapsing": {
    "__init__": [
      "self",
      "first_node",
      "second_node",
      "conv2d_collapsing_fn",
      "kernel_str",
      "kernel_size",
      "bias_str",
      "use_bias_str",
      "strides_str",
      "paddings_str",
      "dilations_str",
      "groups_str",
      "filters_str",
      "data_format_str",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ]
  },
  "Op2DAddConstCollapsing": {
    "__init__": [
      "self",
      "first_node",
      "second_node",
      "op2d_collapsing_fn",
      "bias_str",
      "use_bias_str",
      "layer_name_str"
    ],
    "substitute": [
      "self",
      "graph",
      "edge_nodes"
    ]
  },
  "ConfigurableQuantizerIdentifier": {
    "CONFIGURABLE_ID": []
  },
  "set_bit_widths": [
    "mixed_precision_enable",
    "graph",
    "bit_widths_config"
  ],
  "_get_node_qc_by_bit_widths": [
    "node",
    "node_bit_width_cfg",
    "fw_info"
  ],
  "_set_node_final_qc": [
    "node_bit_width_cfg",
    "node",
    "fw_info"
  ],
  "filter_candidates_for_mixed_precision": [
    "graph",
    "target_resource_utilization",
    "fw_info",
    "fqc"
  ],
  "MpDistanceWeighting": {
    "AVG": [],
    "LAST_LAYER": [],
    "EXP": [],
    "HESSIAN": []
  },
  "MpMetricNormalization": {
    "MAXBIT": [],
    "MINBIT": [],
    "NONE": []
  },
  "MixedPrecisionQuantizationConfig": {
    "__post_init__": [
      "self"
    ],
    "set_mixed_precision_enable": [
      "self"
    ],
    "is_mixed_precision_enabled": [
      "self"
    ]
  },
  "verify_candidates_descending_order": [
    "node_q_cfg",
    "kernel_attr"
  ],
  "init_quantized_weights": [
    "node_q_cfg",
    "float_weights",
    "fw_tensor_convert_func",
    "kernel_attr"
  ],
  "init_activation_quantizers": [
    "node_q_cfg"
  ],
  "greedy_solution_refinement_procedure": [
    "mp_solution",
    "search_manager",
    "target_resource_utilization"
  ],
  "_get_valid_candidates_indices": [
    "node_candidates",
    "current_chosen_index",
    "is_activation_restricted",
    "is_weight_restricted"
  ],
  "MixedPrecisionSearchManager": {
    "__init__": [
      "self",
      "graph",
      "fw_info",
      "fw_impl",
      "sensitivity_evaluator",
      "target_resource_utilization",
      "mp_config"
    ],
    "search": [
      "self"
    ],
    "_prepare_and_run_solver": [
      "self"
    ],
    "_get_relative_ru_constraint_per_mem_element": [
      "self"
    ],
    "_build_sensitivity_mapping": [
      "self"
    ],
    "_get_mp_graph": [
      "self",
      "graph",
      "target_resource_utilization"
    ],
    "_compute_relative_ru_matrices": [
      "self"
    ],
    "copy_config_with_replacement": [
      "mp_cfg",
      "node",
      "candidate_idx"
    ],
    "compute_resource_utilization_for_config": [
      "self",
      "config"
    ],
    "_finalize_distance_metric": [
      "self",
      "layer_to_metrics_mapping"
    ]
  },
  "ConfigReconstructionHelper": {
    "__init__": [
      "self",
      "original_graph"
    ],
    "reconstruct_full_configuration": [
      "self",
      "virtual_cfg",
      "include_non_configurable"
    ],
    "reconstruct_separate_aw_configs": [
      "self",
      "virtual_cfg",
      "include_non_configurable"
    ],
    "_retrieve_matching_orig_a_candidates": [
      "self",
      "virtual_node",
      "virtual_qc_ind"
    ],
    "_retrieve_matching_orig_w_candidates": [
      "self",
      "virtual_node",
      "virtual_qc_ind"
    ]
  },
  "BitWidthSearchMethod": {
    "INTEGER_PROGRAMMING": []
  },
  "search_bit_width": [
    "graph",
    "fw_info",
    "fw_impl",
    "target_resource_utilization",
    "mp_config",
    "representative_data_gen",
    "search_method",
    "hessian_info_service"
  ],
  "MixedPrecisionRUHelper": {
    "__init__": [
      "self",
      "graph",
      "fw_info",
      "fw_impl"
    ],
    "compute_utilization": [
      "self",
      "ru_targets",
      "mp_cfg"
    ],
    "get_quantization_candidates": [
      "self",
      "mp_cfg"
    ]
  },
  "compute_resource_utilization_data": [
    "in_model",
    "representative_data_gen",
    "core_config",
    "fqc",
    "fw_info",
    "fw_impl"
  ],
  "RUTarget": {
    "WEIGHTS": [],
    "ACTIVATION": [],
    "TOTAL": [],
    "BOPS": []
  },
  "ResourceUtilization": {
    "weight_restricted": [
      "self"
    ],
    "activation_restricted": [
      "self"
    ],
    "total_mem_restricted": [
      "self"
    ],
    "bops_restricted": [
      "self"
    ],
    "get_resource_utilization_dict": [
      "self",
      "restricted_only"
    ],
    "is_satisfied_by": [
      "self",
      "ru"
    ],
    "get_restricted_targets": [
      "self"
    ],
    "is_any_restricted": [
      "self"
    ],
    "get_summary_str": [
      "self",
      "restricted"
    ],
    "_is_restricted": [
      "self",
      "v"
    ]
  },
  "BitwidthMode": {
    "Float": [],
    "QMaxBit": [],
    "QMinBit": [],
    "QCustom": [],
    "QDefaultSP": []
  },
  "TargetInclusionCriterion": {
    "QConfigurable": [],
    "QNonConfigurable": [],
    "AnyQuantized": [],
    "Any": [],
    "AnyQuantizedNonFused": []
  },
  "Utilization": {
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ]
  },
  "NodeName": [],
  "ActivationQCfgPerNode": [],
  "WeightsQCfgPerNode": [],
  "DetailedMem": [],
  "ResourceUtilizationCalculator": {
    "_bitwidth_mode_fn": [],
    "unexpected_qc_error": [],
    "unexpected_qc_nodes_error": [],
    "__init__": [
      "self",
      "graph",
      "fw_impl",
      "fw_info"
    ],
    "cuts": [
      "self"
    ],
    "compute_resource_utilization": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs",
      "w_qcs",
      "ru_targets",
      "allow_unused_qcs",
      "return_detailed"
    ],
    "compute_weights_utilization": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "w_qcs"
    ],
    "compute_node_weights_utilization": [
      "self",
      "n",
      "target_criterion",
      "bitwidth_mode",
      "qc"
    ],
    "compute_activations_utilization": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs"
    ],
    "_extract_qc": [
      "self",
      "n",
      "act_qcs"
    ],
    "compute_activation_utilization_by_cut": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs"
    ],
    "compute_activation_tensors_utilization": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs",
      "include_reused"
    ],
    "compute_node_activation_tensor_utilization": [
      "self",
      "n",
      "target_criterion",
      "bitwidth_mode",
      "qc"
    ],
    "compute_bops": [
      "self",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs",
      "w_qcs"
    ],
    "compute_node_bops": [
      "self",
      "n",
      "target_criterion",
      "bitwidth_mode",
      "act_qcs",
      "w_qc"
    ],
    "_compute_cuts": [
      "self"
    ],
    "_get_cut_target_nodes": [
      "self",
      "cut",
      "target_criterion"
    ],
    "_collect_target_nodes_w_attrs": [
      "self",
      "target_criterion",
      "include_reused"
    ],
    "_get_target_weight_attrs": [
      "n",
      "target_criterion"
    ],
    "_topo_sort": [
      "self",
      "nodes"
    ],
    "_get_target_activation_nodes": [
      "self",
      "target_criterion",
      "include_reused",
      "nodes"
    ],
    "_get_activation_nbits": [
      "self",
      "n",
      "bitwidth_mode",
      "act_qc"
    ],
    "_get_weight_nbits": [
      "cls",
      "n",
      "w_attr",
      "bitwidth_mode",
      "w_qc"
    ],
    "_validate_custom_qcs": [
      "self",
      "qcs",
      "bitwidth_mode"
    ]
  },
  "MetricCalculator": {
    "compute": [
      "self",
      "mp_model"
    ]
  },
  "CustomMetricCalculator": {
    "__init__": [
      "self",
      "graph",
      "custom_metric_fn"
    ],
    "compute": [
      "self",
      "mp_model"
    ]
  },
  "DistanceMetricCalculator": {
    "__init__": [
      "self",
      "graph",
      "mp_config",
      "representative_data_gen",
      "fw_info",
      "fw_impl",
      "hessian_info_service"
    ],
    "compute": [
      "self",
      "mp_model"
    ],
    "_init_metric_points_lists": [
      "self",
      "points"
    ],
    "_init_baseline_tensors_list": [
      "self"
    ],
    "_compute_hessian_based_scores": [
      "self",
      "hessian_info_service"
    ],
    "_compute_points_distance": [
      "self",
      "baseline_tensors",
      "mp_tensors",
      "points_distance_fns",
      "points_axis"
    ],
    "_compute_distance": [
      "self",
      "mp_model"
    ],
    "_compute_mp_distance_measure": [
      "self",
      "ipts_distances",
      "out_pts_distances"
    ],
    "_compute_ipts_distance_measure": [
      "self",
      "ipts_distances"
    ],
    "_get_images_batches": [
      "self",
      "num_of_images"
    ],
    "get_mp_interest_points": [
      "cls",
      "graph",
      "interest_points_classifier",
      "num_ip_factor"
    ],
    "get_output_nodes_for_metric": [
      "graph"
    ],
    "bound_num_interest_points": [
      "sorted_ip_list",
      "num_ip_factor"
    ]
  },
  "SensitivityEvaluation": {
    "__init__": [
      "self",
      "graph",
      "mp_config",
      "representative_data_gen",
      "fw_info",
      "fw_impl",
      "disable_activation_for_metric",
      "hessian_info_service"
    ],
    "compute_metric": [
      "self",
      "mp_a_cfg",
      "mp_w_cfg"
    ],
    "_build_mp_model": [
      "self",
      "graph",
      "outputs",
      "disable_activations"
    ],
    "_configured_mp_model": [
      "self",
      "mp_a_cfg",
      "mp_w_cfg"
    ]
  },
  "set_activation_quant_layer_to_bitwidth": [
    "quantization_layer",
    "bitwidth_idx",
    "fw_impl"
  ],
  "set_weights_quant_layer_to_bitwidth": [
    "quantization_layer",
    "bitwidth_idx",
    "fw_impl"
  ],
  "SOLVER_TIME_LIMIT": [],
  "MixedPrecisionIntegerLPSolver": {
    "__init__": [
      "self",
      "layer_to_sensitivity_mapping",
      "candidates_ru",
      "ru_constraints"
    ],
    "run": [
      "self"
    ],
    "_init_problem_vars": [
      "layer_to_metrics_mapping"
    ],
    "_formalize_problem": [
      "self"
    ],
    "_add_ru_constraints": [
      "self",
      "lp_problem"
    ]
  },
  "filter_nodes_candidates": [
    "graph"
  ],
  "_filter_bit_method_dups": [
    "candidates",
    "kernel_attr"
  ],
  "filter_node_candidates": [
    "node",
    "fw_info"
  ],
  "CustomOpsetLayers": {},
  "QuantizationErrorMethod": {
    "NOCLIPPING": [],
    "MSE": [],
    "MAE": [],
    "KL": [],
    "LP": [],
    "HMSE": []
  },
  "QuantizationConfig": {},
  "DEFAULTCONFIG": [],
  "ActivationQuantizationMode": {
    "QUANT": [],
    "FLN_QUANT": [],
    "PRESERVE_QUANT": [],
    "NO_QUANT": []
  },
  "BaseNodeQuantizationConfig": {
    "set_quant_config_attr": [
      "self",
      "config_parameter_name",
      "config_parameter_value"
    ],
    "__repr__": [
      "self"
    ]
  },
  "NodeActivationQuantizationConfig": {
    "__init__": [
      "self",
      "qc",
      "op_cfg",
      "activation_quantization_fn",
      "activation_quantization_params_fn"
    ],
    "enable_activation_quantization": [
      "self"
    ],
    "quantization_preserving": [
      "self"
    ],
    "fln_quantization": [
      "self"
    ],
    "quantize_node_output": [
      "self",
      "tensors"
    ],
    "activation_error_method": [
      "self",
      "value"
    ],
    "set_activation_quantization_fn": [
      "self",
      "activation_quantization_fn"
    ],
    "set_activation_quantization_params_fn": [
      "self",
      "activation_quantization_params_fn"
    ],
    "set_activation_quantization_param": [
      "self",
      "activation_params"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "WeightsAttrQuantizationConfig": {
    "__init__": [
      "self",
      "qc",
      "weights_attr_cfg",
      "weights_channels_axis"
    ],
    "weights_error_method": [
      "self",
      "value"
    ],
    "set_weights_quantization_fn": [
      "self",
      "weights_quantization_fn"
    ],
    "set_weights_quantization_params_fn": [
      "self",
      "weights_quantization_params_fn"
    ],
    "set_weights_quantization_param": [
      "self",
      "weights_params"
    ],
    "calculate_and_set_weights_params": [
      "self",
      "tensor_data",
      "min_threshold"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "NodeWeightsQuantizationConfig": {
    "__init__": [
      "self",
      "qc",
      "op_cfg",
      "weights_channels_axis",
      "node_attrs_list"
    ],
    "get_attr_config": [
      "self",
      "attr_name"
    ],
    "set_attr_config": [
      "self",
      "attr_name",
      "attr_qc"
    ],
    "has_attribute_config": [
      "self",
      "attr_name"
    ],
    "all_weight_attrs": [
      "self"
    ],
    "get_all_weight_attrs_configs": [
      "self"
    ],
    "disable_all_weights_quantization": [
      "self"
    ],
    "_extract_config_for_attributes_with_name": [
      "self",
      "attr_name"
    ],
    "set_quant_config_attr": [
      "self",
      "config_parameter_name",
      "config_parameter_value",
      "attr_name"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__hash__": [
      "self"
    ]
  },
  "get_activation_quantization_params_fn": [
    "activation_quantization_method"
  ],
  "get_weights_quantization_params_fn": [
    "weights_quantization_method"
  ],
  "set_quantization_configuration_to_graph": [
    "graph",
    "quant_config",
    "bit_width_config",
    "mixed_precision_enable",
    "running_gptq"
  ],
  "filter_node_qco_by_graph": [
    "node",
    "fqc",
    "graph",
    "node_qc_options"
  ],
  "set_quantization_configs_to_node": [
    "node",
    "graph",
    "quant_config",
    "fw_info",
    "fqc",
    "mixed_precision_enable",
    "manual_bit_width_override"
  ],
  "create_node_activation_qc": [
    "qc",
    "fw_info",
    "op_cfg"
  ],
  "_create_node_single_candidate_qc": [
    "qc",
    "fw_info",
    "weight_channel_axis",
    "op_cfg",
    "node_attrs_list"
  ],
  "_create_node_candidates_qc": [
    "qc",
    "fw_info",
    "weight_channel_axis",
    "node_qc_options_list",
    "base_config",
    "node",
    "mixed_precision_enable"
  ],
  "filter_qc_options_with_manual_bit_width": [
    "node",
    "node_qc_options_list",
    "base_config",
    "manual_bit_width_override",
    "mixed_precision_enable"
  ],
  "filter_activation_qc_options_with_manual_bit_width": [
    "node",
    "node_qc_options_list",
    "base_config",
    "activation_manual_bit_width_override",
    "mixed_precision_enable"
  ],
  "filter_weights_qc_options_with_manual_bit_width": [
    "node",
    "node_qc_options_list",
    "base_config",
    "weights_manual_bit_width_override",
    "mixed_precision_enable"
  ],
  "_is_valid_option": [
    "op_cfg",
    "attr",
    "bit_width"
  ],
  "_filter_options": [
    "node_qc_options_list",
    "weights_manual_bit_width_override"
  ],
  "get_quantized_weights_attr_by_qc": [
    "attr_name",
    "n",
    "weights_qc"
  ],
  "quantize_graph_weights": [
    "graph_to_quantize"
  ],
  "DebugConfig": {},
  "CandidateNodeQuantizationConfig": {
    "__init__": [
      "self",
      "qc",
      "op_cfg",
      "activation_quantization_cfg",
      "activation_quantization_fn",
      "activation_quantization_params_fn",
      "weights_quantization_cfg",
      "weights_channels_axis",
      "node_attrs_list"
    ]
  },
  "CoreConfig": {
    "is_mixed_precision_enabled": [
      "self"
    ]
  },
  "get_weights_quantization_fn": [
    "weights_quantization_method"
  ],
  "ManualBitWidthSelection": {},
  "ManualWeightsBitWidthSelection": {},
  "BitWidthConfig": {
    "set_manual_activation_bit_width": [
      "self",
      "filters",
      "bit_widths"
    ],
    "set_manual_weights_bit_width": [
      "self",
      "filters",
      "bit_widths",
      "attrs"
    ],
    "get_nodes_to_manipulate_activation_bit_widths": [
      "self",
      "graph"
    ],
    "get_nodes_to_manipulate_weights_bit_widths": [
      "self",
      "graph"
    ],
    "_expand_to_list_core": [
      "filters",
      "vals"
    ],
    "_expand_to_list": [
      "filters",
      "bit_widths",
      "attrs"
    ],
    "_construct_node_to_new_activation_bit_mapping": [
      "self",
      "graph"
    ],
    "_construct_node_to_new_weights_bit_mapping": [
      "self",
      "graph"
    ]
  },
  "uniform_selection_tensor": [
    "tensor_data",
    "p",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "uniform_selection_histogram": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "uniform_no_clipping_selection_min_max": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "z_score_filter": [
    "z_threshold",
    "bins",
    "counts"
  ],
  "lut_kmeans_tensor": [
    "tensor_data",
    "p",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_symmetric",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "lut_kmeans_histogram": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "_mse_error_histogram": [
    "q_bins",
    "q_count",
    "bins",
    "counts"
  ],
  "_mae_error_histogram": [
    "q_bins",
    "q_count",
    "bins",
    "counts"
  ],
  "_lp_error_histogram": [
    "q_bins",
    "q_count",
    "bins",
    "counts",
    "p"
  ],
  "_kl_error_function": [
    "x",
    "range_min",
    "range_max",
    "n_bins",
    "n_bits"
  ],
  "_kl_error_function_wrapper": [
    "x",
    "range_min",
    "range_max",
    "n_bins",
    "n_bits",
    "per_channel"
  ],
  "_kl_error_histogram": [
    "q_bins",
    "q_count",
    "bins",
    "counts",
    "range_min",
    "range_max"
  ],
  "_get_bins_indices_from_range": [
    "bins",
    "range_min",
    "range_max"
  ],
  "_is_range_valid": [
    "bins",
    "range_min",
    "range_max"
  ],
  "_smooth_distribution": [
    "probability"
  ],
  "_compute_clipped_counts": [
    "counts",
    "counts_subset",
    "first_bin_idx",
    "last_bin_idx"
  ],
  "_get_sliced_histogram": [
    "bins",
    "counts",
    "first_bin_idx",
    "last_bin_idx"
  ],
  "_compute_hessian_for_hmse": [
    "node",
    "hessian_info_service",
    "num_hessian_samples",
    "dataloader"
  ],
  "_hmse_error_function_wrapper": [
    "float_tensor",
    "fxp_tensor",
    "axis",
    "norm",
    "hessian_scores"
  ],
  "get_threshold_selection_tensor_error_function": [
    "quantization_method",
    "quant_error_method",
    "p",
    "axis",
    "norm",
    "n_bits",
    "signed",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "get_threshold_selection_histogram_error_function": [
    "quantization_method",
    "quant_error_method",
    "p"
  ],
  "symmetric_selection_tensor": [
    "tensor_data",
    "p",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "symmetric_selection_histogram": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "symmetric_no_clipping_selection_min_max": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "get_init_threshold": [
    "min_threshold",
    "tensor_max",
    "per_channel"
  ],
  "get_histogram_data": [
    "activation_quant_cfg",
    "out_stats_container"
  ],
  "determine_signedness": [
    "activation_quant_cfg",
    "nodes_prior_info",
    "min_value",
    "bins_values",
    "bins_counts"
  ],
  "update_activation_quantization_params_fn": [
    "activation_quant_cfg",
    "nodes_prior_info"
  ],
  "get_activations_qparams": [
    "activation_quant_cfg",
    "nodes_prior_info",
    "out_stats_container"
  ],
  "qparams_selection_tensor_search": [
    "error_function",
    "tensor_data",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "signed"
  ],
  "qparams_selection_histogram_search": [
    "error_function",
    "bins",
    "counts",
    "n_bits",
    "constrained",
    "n_iter",
    "min_threshold",
    "is_signed"
  ],
  "qparams_symmetric_iterative_minimization": [
    "x0",
    "x",
    "loss_fn",
    "n_bits",
    "signed",
    "n_intervals",
    "n_iter",
    "alpha",
    "beta",
    "dec_factor",
    "dec_freq",
    "tolerance",
    "per_channel"
  ],
  "iterative_uniform_dynamic_range_search": [
    "x0",
    "x",
    "scalers",
    "loss_fn",
    "n_bits",
    "n_iter",
    "tolerance",
    "per_channel"
  ],
  "search_fixed_range_intervals": [
    "range_bounds",
    "x",
    "loss_fn",
    "n_bits",
    "signed",
    "n_intervals",
    "per_channel"
  ],
  "search_dynamic_range": [
    "base_range",
    "x",
    "scalers",
    "loss_fn",
    "n_bits",
    "per_channel"
  ],
  "qparams_symmetric_selection_tensor_search": [
    "error_function",
    "tensor_data",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "signed"
  ],
  "qparams_uniform_selection_tensor_search": [
    "error_function",
    "tensor_data",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter"
  ],
  "qparams_symmetric_selection_histogram_search": [
    "error_function",
    "tensor_max",
    "bins",
    "counts",
    "n_bits",
    "n_iter",
    "min_threshold",
    "is_signed"
  ],
  "kl_qparams_symmetric_selection_histogram_search": [
    "error_function",
    "tensor_max",
    "bins",
    "counts",
    "n_bits",
    "n_iter",
    "min_threshold",
    "is_signed"
  ],
  "qparams_uniform_selection_histogram_search": [
    "error_function",
    "tensor_min_max",
    "bins",
    "counts",
    "n_bits",
    "n_iter"
  ],
  "qparams_selection_histogram_search_error_function": [
    "error_function",
    "bins",
    "q_bins",
    "counts",
    "threshold",
    "min_max_range"
  ],
  "kl_qparams_selection_histogram_search_error_function": [
    "error_function",
    "bins",
    "q_bins",
    "counts",
    "min_max_range"
  ],
  "_error_function_wrapper": [
    "error_function",
    "float_tensor",
    "q_tensor",
    "in_params"
  ],
  "power_of_two_selection_tensor": [
    "tensor_data",
    "p",
    "n_bits",
    "per_channel",
    "channel_axis",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "power_of_two_selection_histogram": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "power_of_two_no_clipping_selection_min_max": [
    "bins",
    "counts",
    "p",
    "n_bits",
    "min_value",
    "max_value",
    "constrained",
    "n_iter",
    "min_threshold",
    "quant_error_method",
    "is_signed"
  ],
  "_collect_nodes_for_hmse": [
    "nodes_list",
    "graph"
  ],
  "calculate_quantization_params": [
    "graph",
    "fw_impl",
    "repr_data_gen_fn",
    "nodes",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "get_weights_qparams": [
    "weights_attr_values",
    "weights_quant_config",
    "attr_quant_config",
    "output_channels_axis",
    "node",
    "hessian_info_service",
    "num_hessian_samples"
  ],
  "threshold_is_power_of_two": [
    "threshold",
    "per_channel"
  ],
  "power_of_two_quantizer": [
    "tensor_data",
    "n_bits",
    "signed",
    "quantization_params",
    "per_channel",
    "output_channels_axis"
  ],
  "max_power_of_two": [
    "x",
    "min_threshold"
  ],
  "quantize_tensor": [
    "tensor_data",
    "threshold",
    "n_bits",
    "signed"
  ],
  "uniform_quantize_tensor": [
    "tensor_data",
    "range_min",
    "range_max",
    "n_bits"
  ],
  "kmeans_assign_clusters": [
    "lut_values",
    "query"
  ],
  "get_quantized_tensor": [
    "centers",
    "scale",
    "n_bits"
  ],
  "get_tensor_max": [
    "tensor_data",
    "per_channel",
    "channel_axis",
    "n_bits",
    "is_uniform_quantization"
  ],
  "get_tensor_min": [
    "tensor_data",
    "per_channel",
    "channel_axis"
  ],
  "reshape_tensor_for_per_channel_search": [
    "tensor_data",
    "channel_axis"
  ],
  "get_output_shape": [
    "tensor_shape",
    "channel_axis"
  ],
  "lut_kmeans_quantizer": [
    "tensor_data",
    "n_bits",
    "signed",
    "quantization_params",
    "per_channel",
    "output_channels_axis"
  ],
  "BaseEdgeMatcher": {
    "__init__": [
      "self",
      "source_matcher",
      "target_matcher"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "logic_not": [
      "self"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "EdgeAndMatcher": {
    "__init__": [
      "self",
      "matcher_a",
      "matcher_b"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "EdgeOrMatcher": {
    "__init__": [
      "self",
      "matcher_a",
      "matcher_b"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "EdgeAnyMatcher": {
    "apply": [
      "self",
      "input_object"
    ]
  },
  "EdgeNotMatcher": {
    "__init__": [
      "self",
      "matcher_a"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "is_node_matcher": [
    "matcher"
  ],
  "is_edge_matcher": [
    "matcher"
  ],
  "is_walk_matcher": [
    "matcher"
  ],
  "BaseWalkMatcher": {},
  "WalkMatcherList": {
    "__init__": [
      "self",
      "matcher_list"
    ]
  },
  "BaseGraphFilter": {
    "filter": [
      "self",
      "matcher"
    ],
    "_node_filter": [
      "self",
      "node_matcher"
    ],
    "_edge_filter": [
      "self",
      "edge_matcher"
    ],
    "_walk_filter": [
      "self",
      "walk_matcher"
    ]
  },
  "BaseMatcher": {
    "apply": [
      "self",
      "input_object"
    ],
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "logic_not": [
      "self"
    ],
    "logic_and": [
      "self",
      "other"
    ],
    "logic_or": [
      "self",
      "other"
    ]
  },
  "BaseNodeMatcher": {
    "__and__": [
      "self",
      "other"
    ],
    "__or__": [
      "self",
      "other"
    ],
    "logic_not": [
      "self"
    ]
  },
  "NodeAndMatcher": {
    "__init__": [
      "self",
      "matcher_a",
      "matcher_b"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "NodeOrMatcher": {
    "__init__": [
      "self",
      "matcher_a",
      "matcher_b"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "NodeAnyMatcher": {
    "apply": [
      "self",
      "input_object"
    ]
  },
  "NodeNotMatcher": {
    "__init__": [
      "self",
      "matcher_a"
    ],
    "apply": [
      "self",
      "input_object"
    ]
  },
  "_get_compare_points": [
    "input_graph"
  ],
  "NNVisualizer": {
    "__init__": [
      "self",
      "graph_float",
      "graph_quantized",
      "fw_impl",
      "fw_info"
    ],
    "has_compare_points": [
      "self"
    ],
    "plot_distance_graph": [
      "self",
      "input_image",
      "sample_index",
      "distance_fn",
      "convert_to_range"
    ]
  },
  "get_kernel_layer_represent_name": [
    "node"
  ],
  "WeightsFinalBitwidthConfigVisualizer": {
    "__init__": [
      "self",
      "final_weights_nodes_config"
    ],
    "plot_config_bitwidth": [
      "self"
    ]
  },
  "ActivationFinalBitwidthConfigVisualizer": {
    "__init__": [
      "self",
      "final_activation_nodes_config"
    ],
    "plot_config_bitwidth": [
      "self"
    ],
    "plot_tensor_sizes": [
      "self",
      "graph"
    ]
  },
  "DEVICE_STEP_STATS": [],
  "get_node_properties": [
    "node_dict_to_log",
    "output_shapes"
  ],
  "TensorboardWriter": {
    "__init__": [
      "self",
      "dir_path",
      "fw_info"
    ],
    "close": [
      "self"
    ],
    "add_histograms": [
      "self",
      "graph",
      "main_tag_name"
    ],
    "add_graph": [
      "self",
      "graph",
      "main_tag_name"
    ],
    "__get_event_writer_by_tag_name": [
      "self",
      "main_tag_name"
    ],
    "add_min_max": [
      "self",
      "graph",
      "main_tag_name"
    ],
    "add_mean": [
      "self",
      "graph",
      "main_tag_name"
    ],
    "add_all_statistics": [
      "self",
      "graph",
      "main_tag_name"
    ],
    "add_figure": [
      "self",
      "figure",
      "figure_tag",
      "main_tag_name"
    ],
    "add_text": [
      "self",
      "text",
      "main_tag_name"
    ]
  },
  "init_tensorboard_writer": [
    "fw_info"
  ],
  "finalize_bitwidth_in_tb": [
    "tb_w",
    "weights_conf_nodes_bitwidth",
    "activation_conf_nodes_bitwidth"
  ],
  "set_model": [
    "model",
    "train_mode"
  ],
  "to_torch_tensor": [
    "data",
    "dtype"
  ],
  "torch_tensor_to_numpy": [
    "tensor"
  ],
  "clip_inf_values_float16": [
    "tensor"
  ],
  "KERNEL_ATTRIBUTES": [],
  "DEFAULT_CHANNEL_AXIS_DICT": [],
  "DEFAULT_OUT_CHANNEL_AXIS_DICT": [],
  "ACTIVATION2MINMAX": [],
  "LAYER2MINMAX": [],
  "ACTIVATION_QUANTIZER_MAPPING": [],
  "DEFAULT_PYTORCH_INFO": [],
  "PytorchImplementation": {
    "weights_quant_layer_cls": [],
    "activation_quant_layer_cls": [],
    "configurable_weights_quantizer_cls": [],
    "configurable_activation_quantizer_cls": [],
    "__init__": [
      "self"
    ],
    "constants": [
      "self"
    ],
    "to_numpy": [
      "self",
      "tensor"
    ],
    "to_tensor": [
      "self",
      "tensor"
    ],
    "is_tuple_of_tensors": [
      "self",
      "obj"
    ],
    "model_reader": [
      "self",
      "module",
      "representative_data_gen"
    ],
    "model_builder": [
      "self",
      "graph",
      "mode",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "run_model_inference": [
      "self",
      "model",
      "input_list",
      "requires_grad"
    ],
    "shift_negative_correction": [
      "self",
      "graph",
      "core_config",
      "fw_info"
    ],
    "compute_activation_bias_correction": [
      "self",
      "graph",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_channel_equalization": [
      "self",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_prepare_graph": [
      "self",
      "fw_info"
    ],
    "get_substitutions_pre_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_substitutions_statistics_correction": [
      "self",
      "quant_config"
    ],
    "get_residual_collapsing_substitution": [
      "self"
    ],
    "get_linear_collapsing_substitution": [
      "self"
    ],
    "get_op2d_add_const_collapsing_substitution": [
      "self"
    ],
    "get_substitutions_post_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_substitutions_virtual_weights_activation_coupling": [
      "self"
    ],
    "get_substitutions_after_second_moment_correction": [
      "self",
      "quant_config"
    ],
    "get_node_prior_info": [
      "self",
      "node",
      "fw_info",
      "graph"
    ],
    "count_node_for_mixed_precision_interest_points": [
      "self",
      "node"
    ],
    "get_mp_node_distance_fn": [
      "self",
      "n",
      "compute_distance_fn",
      "norm_mse"
    ],
    "is_output_node_compatible_for_hessian_score_computation": [
      "self",
      "node"
    ],
    "get_node_mac_operations": [
      "self",
      "node",
      "fw_info"
    ],
    "apply_second_moment_correction": [
      "self",
      "quantized_model",
      "core_config",
      "representative_data_gen",
      "graph"
    ],
    "sensitivity_eval_inference": [
      "self",
      "model",
      "inputs"
    ],
    "get_hessian_scores_calculator": [
      "self",
      "graph",
      "input_images",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "get_inferable_quantizers": [
      "self",
      "node"
    ],
    "convert_data_gen_to_dataloader": [
      "data_gen_fn",
      "batch_size"
    ]
  },
  "create_node_prior_info": [
    "node",
    "fw_info",
    "graph"
  ],
  "_get_mean_std_outputs": [
    "node",
    "graph"
  ],
  "DeviceManager": {
    "_instance": [],
    "__new__": [
      "cls"
    ],
    "set_device": [
      "self",
      "device_name"
    ],
    "get_device": [
      "self"
    ],
    "is_valid_device": [
      "device_name"
    ]
  },
  "set_working_device": [
    "device_name"
  ],
  "get_working_device": [],
  "flat_gen_fn": [
    "data_gen_fn"
  ],
  "IterableDatasetFromGenerator": {
    "__init__": [
      "self",
      "data_gen_fn"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "FixedDatasetFromGenerator": {
    "__init__": [
      "self",
      "data_gen_fn",
      "n_samples"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "FixedSampleInfoDataset": {
    "__init__": [
      "self",
      "samples"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ]
  },
  "IterableSampleWithConstInfoDataset": {
    "__init__": [
      "self",
      "samples_dataset"
    ],
    "__iter__": [
      "self"
    ]
  },
  "get_collate_fn_with_extra_outputs": [],
  "data_gen_to_dataloader": [
    "data_gen_fn",
    "batch_size"
  ],
  "PLACEHOLDER": [],
  "CALL_FUNCTION": [],
  "CALL_METHOD": [],
  "GET_ATTR": [],
  "GROUPS": [],
  "DILATIONS": [],
  "TENSOR_META": [],
  "OUTPUT_PADDING": [],
  "TYPE": [],
  "PAD": [],
  "FUNCTIONAL_OP": [],
  "OP_CALL_ARGS": [],
  "OP_CALL_KWARGS": [],
  "INPUTS_AS_LIST": [],
  "TENSOR_INPUT_ALLOCS": [],
  "INPLACE": [],
  "HARDTANH_MIN_VAL": [],
  "HARDTANH_MAX_VAL": [],
  "GAMMA": [],
  "BETA": [],
  "WEIGHT": [],
  "MOVING_MEAN": [],
  "MOVING_VARIANCE": [],
  "EPSILON": [],
  "EPSILON_VAL": [],
  "MOMENTUM": [],
  "MOMENTUM_VAL": [],
  "NORMALIZED_SHAPE": [],
  "DIM": [],
  "IN_CHANNELS": [],
  "OUT_CHANNELS": [],
  "NUM_FEATURES": [],
  "NUM_PARAMETERS": [],
  "IN_FEATURES": [],
  "OUT_FEATURES": [],
  "CUDA": [],
  "CPU": [],
  "RELU_POT_BOUND": [],
  "EMBED_DIM": [],
  "NUM_HEADS": [],
  "DROPOUT": [],
  "ADD_ZERO_ATTN": [],
  "KEY_DIM": [],
  "VALUE_DIM": [],
  "BATCH_FIRST": [],
  "OUT_PROJ_WEIGHT": [],
  "OUT_PROJ_BIAS": [],
  "V_PROJ_WEIGHT": [],
  "K_PROJ_WEIGHT": [],
  "Q_PROJ_WEIGHT": [],
  "IN_PROJ_WEIGHT": [],
  "IN_PROJ_BIAS": [],
  "BIAS_K": [],
  "BIAS_V": [],
  "BATCH_DIM_VALUE": [],
  "MAX_FLOAT16": [],
  "MIN_FLOAT16": [],
  "FloatPyTorchModel": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ]
  },
  "FloatPyTorchModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "build_model": [
      "self"
    ]
  },
  "pytorch_model_builders": [],
  "get_pytorch_model_builder": [
    "mode"
  ],
  "QuantizedPyTorchModel": {
    "__init__": [
      "self",
      "graph",
      "append2output"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ]
  },
  "QuantizedPyTorchModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "build_model": [
      "self"
    ]
  },
  "node_builder": [
    "n"
  ],
  "_build_input_tensors_list": [
    "node",
    "graph",
    "inputs",
    "node_to_output_tensors_dict"
  ],
  "_merge_inputs": [
    "_node",
    "input_tensors",
    "op_call_args",
    "op_call_kwargs",
    "tensor_input_allocs"
  ],
  "_run_operation": [
    "n",
    "input_tensors",
    "op_func",
    "quantize_node_activation_fn",
    "use_activation_quantization"
  ],
  "_find_by_node_name": [
    "node_to_output_tensors_dict",
    "node_name"
  ],
  "_generate_outputs": [
    "out_nodes",
    "node_to_output_tensors_dict"
  ],
  "PytorchModel": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "return_float_outputs",
      "wrapper",
      "get_activation_quantizer_holder_fn"
    ],
    "use_activation_holder_during_model_building": [
      "self"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ],
    "wrap": [
      "self",
      "node"
    ],
    "_add_all_modules": [
      "self"
    ],
    "_add_modules": [
      "self",
      "reused_nodes_only"
    ],
    "forward": [
      "self"
    ],
    "_get_op_func": [
      "self",
      "node",
      "configurable_nodes_names"
    ],
    "_get_activation_quantization_fn": [
      "self",
      "node"
    ]
  },
  "PyTorchModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs",
      "wrapper",
      "get_activation_quantizer_holder_fn"
    ],
    "build_model": [
      "self"
    ]
  },
  "MixedPrecisionPyTorchModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "mixed_precision_wrapper": [
      "self",
      "n",
      "layer"
    ],
    "_get_weights_configurable_quantizer_kwargs": [
      "self",
      "n",
      "attr"
    ],
    "mixed_precision_activation_holder": [
      "self",
      "n",
      "holder_type"
    ],
    "build_model": [
      "self"
    ],
    "_get_weights_quant_layers": [
      "n",
      "named_layers"
    ],
    "_get_activation_quant_layers": [
      "n",
      "named_layers"
    ],
    "_find_layers_in_model_by_node": [
      "self",
      "n",
      "named_layers"
    ]
  },
  "QuantizedLayerWrapper": {
    "__init__": [
      "self",
      "n",
      "quantize_config"
    ],
    "forward": [
      "self",
      "x"
    ],
    "_build_layer": [
      "self",
      "n"
    ],
    "_quantize_weights": [
      "self",
      "n"
    ],
    "_load_quantized_weights": [
      "self"
    ],
    "_get_quantized_weights": [
      "self",
      "float_weights"
    ]
  },
  "WrapperQuantizeConfig": {
    "__init__": [
      "self",
      "is_weight_quantized",
      "is_activation_quantized"
    ],
    "get_weight_quantizers": [
      "self"
    ],
    "get_activation_quantizers": [
      "self"
    ]
  },
  "PruningPytorchImplementation": {
    "prune_entry_node": [
      "self",
      "node",
      "output_mask",
      "fw_info"
    ],
    "prune_intermediate_node": [
      "self",
      "node",
      "input_mask",
      "output_mask",
      "fw_info"
    ],
    "prune_exit_node": [
      "self",
      "node",
      "input_mask",
      "fw_info"
    ],
    "is_node_entry_node": [
      "self",
      "node"
    ],
    "is_node_exit_node": [
      "self",
      "node",
      "corresponding_entry_node",
      "fw_info"
    ],
    "is_node_intermediate_pruning_section": [
      "self",
      "node"
    ],
    "attrs_oi_channels_info_for_pruning": [
      "self",
      "node",
      "fw_info"
    ]
  },
  "_is_pytorch_node_pruning_section_edge": [
    "node"
  ],
  "_prune_pytorch_edge_node": [
    "node",
    "mask",
    "fw_info",
    "is_exit_node"
  ],
  "_edit_node_input_shape": [
    "node",
    "input_mask",
    "fw_info"
  ],
  "activation_bias_correction_node_matchers": [],
  "pytorch_compute_activation_bias_correction_of_graph": [
    "graph",
    "quant_config",
    "fw_info",
    "fw_impl"
  ],
  "pytorch_apply_second_moment_correction": [
    "quantized_model",
    "core_config",
    "representative_data_gen",
    "graph"
  ],
  "DummyPlaceHolder": {
    "__name__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_trace_model": [
    "root"
  ],
  "generate_module_dict": [
    "model"
  ],
  "build_graph": [
    "model",
    "to_numpy"
  ],
  "fx_graph_module_generation": [
    "pytorch_model",
    "representative_data_gen",
    "to_tensor"
  ],
  "remove_broken_nodes_from_graph": [
    "graph"
  ],
  "model_reader": [
    "model",
    "representative_data_gen",
    "to_numpy",
    "to_tensor"
  ],
  "_extract_parameters_and_buffers": [
    "module"
  ],
  "is_instance_first_arg": [
    "n",
    "expected_type"
  ],
  "_build_input_alloc_and_call_args": [
    "n",
    "input_tensors_in_node_kwargs",
    "inputs_as_list"
  ],
  "_extract_torch_layer_data": [
    "node_module"
  ],
  "_extract_input_and_output_shapes": [
    "_node"
  ],
  "nodes_builder": [
    "model",
    "module_dict",
    "to_numpy"
  ],
  "edges_builder": [
    "model",
    "fx_node_2_graph_node"
  ],
  "create_reuse_group": [
    "target",
    "weights"
  ],
  "WeightsHessianScoresCalculatorPytorch": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "compute": [
      "self"
    ]
  },
  "HessianScoresCalculatorPytorch": {
    "_generate_random_vectors_batch": [
      "self",
      "shape",
      "device"
    ],
    "concat_tensors": [
      "self",
      "tensors_to_concate"
    ]
  },
  "ActivationHessianScoresCalculatorPytorch": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "forward_pass": [
      "self"
    ],
    "_prep_tensors_for_compute": [
      "self",
      "model_output_tensors"
    ],
    "compute": [
      "self"
    ]
  },
  "activation_lut_kmean_quantizer": [
    "activation_n_bits",
    "quantization_params"
  ],
  "PytorchLUTFakeQuant": {
    "__init__": [
      "self",
      "quantization_params"
    ],
    "forward": [
      "self",
      "x"
    ],
    "lut_kmeans_quantizer": [
      "self",
      "tensor_data"
    ],
    "int_quantization_with_threshold": [
      "self",
      "data",
      "n_bits",
      "eps"
    ]
  },
  "get_symmetric_quantization_range_and_scale": [
    "activation_is_signed",
    "activation_n_bits",
    "activation_threshold"
  ],
  "power_of_two_quantization": [
    "activation_n_bits",
    "quantization_params"
  ],
  "symmetric_quantization": [
    "activation_n_bits",
    "quantization_params"
  ],
  "uniform_quantization": [
    "activation_n_bits",
    "quantization_params"
  ],
  "q": [
    "x",
    "min_value",
    "max_value",
    "scale",
    "zero_point"
  ],
  "MatMulParams": {
    "__init__": [
      "self",
      "matmul_node"
    ],
    "update_nodes": [
      "self",
      "input_node",
      "other_node"
    ]
  },
  "MatMulDecomposition": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "matmul_node"
    ],
    "_expand_inputs": [
      "graph",
      "matmul_node",
      "params"
    ],
    "_reshape_input": [
      "graph",
      "matmul_node",
      "params"
    ],
    "_split_inputs": [
      "graph",
      "matmul_node",
      "params"
    ],
    "_calc_single_matmul": [
      "graph",
      "matmul_node",
      "input_split_node",
      "other_split_node",
      "dim_index",
      "params"
    ],
    "_stack_matmul_outputs": [
      "graph",
      "matmul_node",
      "split_matmul_nodes",
      "params"
    ],
    "_connect_to_graph": [
      "graph",
      "matmul_node",
      "head_input_node",
      "head_other_node",
      "output_node"
    ]
  },
  "FunctionalLayerNorm": {
    "__init__": [
      "self"
    ],
    "get_attributes_from_weights": [
      "node",
      "normalized_shape"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "FunctionalLinear": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "func_node"
    ]
  },
  "ReLUBoundToPowerOfTwo": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "nodes_list"
    ]
  },
  "activation_nodes": [],
  "op2d_node": [],
  "zeropad_node": [],
  "MATCHER": [],
  "MATCHER_WITH_PAD": [],
  "ScaleEqualization": {
    "__init__": [
      "self",
      "quant_config",
      "fw_info"
    ]
  },
  "ScaleEqualizationWithPad": {
    "__init__": [
      "self",
      "quant_config",
      "fw_info"
    ]
  },
  "batchnorm_reconstruction_node_matchers": [],
  "create_bn_node": [
    "source_node",
    "bn_node_weights"
  ],
  "pytorch_batchnorm_reconstruction": [],
  "params_search_quantization_fn": [
    "quantization_fw",
    "bins_to_quantize"
  ],
  "shift_negative_activation_node_matchers": [],
  "create_add_node": [
    "add_value",
    "prev_node_name",
    "input_shape"
  ],
  "create_pad_node": [
    "next_node_name",
    "prev_node_name",
    "value_to_pad",
    "input_shape",
    "pad_top",
    "pad_btm",
    "pad_left",
    "pad_right"
  ],
  "compute_op2d_padding": [],
  "get_padding_values": [
    "op2d_node"
  ],
  "is_padding_node_and_node_has_padding": [
    "pad_node_to_consider",
    "next_node"
  ],
  "pytorch_apply_shift_negative_correction": [
    "graph",
    "core_config",
    "fw_info"
  ],
  "OP2D_NODE": [],
  "WeightsActivationSplit": {
    "__init__": [
      "self"
    ]
  },
  "TransformFunctionCallMethod": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "batchnorm_refusing_node_matchers": [],
  "pytorch_batchnorm_refusing": [],
  "residual_collapsing_node_matchers": [],
  "residual_collapsing_fn": [
    "first_node",
    "kernel_str"
  ],
  "pytorch_residual_collapsing": [],
  "ReshapeWithStaticShapes": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "clean_graph_from_nodes_without_out_edges": [
    "graph",
    "node"
  ],
  "ConcatThresholdUpdate": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "ConvtransposeDynamicPadding": {
    "__init__": [
      "self"
    ],
    "calc_dynamic_output_size": [
      "self",
      "node"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "batchnorm_folding_node_matchers": [],
  "batchnorm_forward_folding_node_matchers": [],
  "update_kernel_for_bn_folding_fn": [
    "conv_node",
    "kernel",
    "weights_scale"
  ],
  "update_weights_for_bn_forward_folding_fn": [
    "conv_node",
    "kernel",
    "bias",
    "weights_scale",
    "bias_factor"
  ],
  "get_kernel_hw_fn": [
    "kernel"
  ],
  "is_group_conv_fn": [
    "node"
  ],
  "get_foldable_node_type_and_validity_fn": [
    "node"
  ],
  "pytorch_batchnorm_folding": [],
  "pytorch_batchnorm_forward_folding": [],
  "RemoveIdentity": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "FunctionalConvSubstitution": {
    "__init__": [
      "self",
      "fw_info"
    ],
    "substitute": [
      "self",
      "graph",
      "func_node"
    ]
  },
  "softmax_shift_matcher": [],
  "pytorch_softmax_shift": [],
  "WEIGHTS_NODE": [],
  "VirtualActivationWeightsComposition": {
    "__init__": [
      "self"
    ]
  },
  "FunctionalBatchNorm": {
    "__init__": [
      "self"
    ],
    "get_attributes_from_weights": [
      "node"
    ],
    "substitute": [
      "self",
      "graph",
      "node"
    ]
  },
  "MHAParams": {
    "__init__": [
      "self",
      "mha_node"
    ]
  },
  "MultiHeadAttentionDecomposition": {
    "__init__": [
      "self"
    ],
    "_project_input": [
      "self",
      "graph",
      "mha_node",
      "params"
    ],
    "_arrange_before_split": [
      "graph",
      "mha_node",
      "q_node",
      "k_node",
      "v_node",
      "params"
    ],
    "_split_projected": [
      "graph",
      "name",
      "q_transpose_node",
      "k_reshape_node",
      "v_transpose_node",
      "params"
    ],
    "_calc_attention_head": [
      "graph",
      "q_in_node",
      "k_in_node",
      "v_in_node",
      "mha_node",
      "head_index",
      "params"
    ],
    "_cat_heads_reshape": [
      "graph",
      "name",
      "att_head_output_nodes",
      "params"
    ],
    "_project_output": [
      "self",
      "graph",
      "mha_node",
      "attn_reshape_node",
      "params"
    ],
    "_connect_to_graph": [
      "graph",
      "mha_node",
      "q_node",
      "k_node",
      "v_node",
      "output_permute_node"
    ],
    "substitute": [
      "self",
      "graph",
      "mha_node"
    ]
  },
  "linear_collapsing_node_matchers": [],
  "conv2d_collapsing_fn": [
    "first_node",
    "second_node",
    "kernel_str",
    "bias_str"
  ],
  "pytorch_linear_collapsing": [],
  "ScaledDotProductDecomposition": {
    "__init__": [
      "self"
    ],
    "_get_input_by_name": [
      "self",
      "attention_node",
      "input_name",
      "input_index",
      "default_value"
    ],
    "_get_attention_input_nodes": [
      "self",
      "graph",
      "attention_node"
    ],
    "_get_transpose_k_node": [
      "self",
      "attention_node_name",
      "key_node"
    ],
    "_get_scale_node": [
      "self",
      "attention_node",
      "q_node",
      "matmul_node"
    ],
    "_get_matmul_node": [
      "self",
      "attention_node_name",
      "q_node",
      "transposed_k_node"
    ],
    "_get_mask_node": [
      "self",
      "attention_node",
      "scale_node"
    ],
    "_get_softmax_node": [
      "self",
      "attention_node_name",
      "in_out_shape"
    ],
    "_get_matmul2_node": [
      "self",
      "attention_node_name",
      "softmax_node",
      "v_node"
    ],
    "_get_attention_mask_tensor": [
      "self",
      "attention_node"
    ],
    "_get_dropout_node": [
      "self",
      "attention_node",
      "in_out_shape"
    ],
    "substitute": [
      "self",
      "graph",
      "attention_node"
    ]
  },
  "ConfigurableWeightsQuantizer": {
    "__init__": [
      "self",
      "node_q_cfg",
      "float_weights",
      "kernel_attr",
      "max_candidate_idx"
    ],
    "set_weights_bit_width_index": [
      "self",
      "index"
    ],
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "ConfigurableActivationQuantizer": {
    "__init__": [
      "self",
      "node_q_cfg",
      "max_candidate_idx",
      "kernel_attr"
    ],
    "set_active_activation_quantizer": [
      "self",
      "index"
    ],
    "__call__": [
      "self",
      "inputs"
    ]
  },
  "KerasImplementation": {
    "weights_quant_layer_cls": [],
    "activation_quant_layer_cls": [],
    "configurable_weights_quantizer_cls": [],
    "configurable_activation_quantizer_cls": [],
    "constants": [
      "self"
    ],
    "model_reader": [
      "self",
      "model",
      "representative_data_gen"
    ],
    "to_numpy": [
      "self",
      "tensor"
    ],
    "to_tensor": [
      "self",
      "tensor"
    ],
    "is_tuple_of_tensors": [
      "self",
      "obj"
    ],
    "model_builder": [
      "self",
      "graph",
      "mode",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "run_model_inference": [
      "self",
      "model",
      "input_list",
      "requires_grad"
    ],
    "shift_negative_correction": [
      "self",
      "graph",
      "core_config",
      "fw_info"
    ],
    "compute_activation_bias_correction": [
      "self",
      "graph",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_channel_equalization": [
      "self",
      "quant_config",
      "fw_info"
    ],
    "get_substitutions_prepare_graph": [
      "self",
      "fw_info"
    ],
    "get_substitutions_pre_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_substitutions_statistics_correction": [
      "self",
      "quant_config"
    ],
    "get_residual_collapsing_substitution": [
      "self"
    ],
    "get_linear_collapsing_substitution": [
      "self"
    ],
    "get_op2d_add_const_collapsing_substitution": [
      "self"
    ],
    "get_substitutions_post_statistics_collection": [
      "self",
      "quant_config"
    ],
    "get_substitutions_virtual_weights_activation_coupling": [
      "self"
    ],
    "get_substitutions_after_second_moment_correction": [
      "self",
      "quant_config"
    ],
    "get_node_prior_info": [
      "self",
      "node",
      "fw_info",
      "graph"
    ],
    "count_node_for_mixed_precision_interest_points": [
      "self",
      "node"
    ],
    "get_mp_node_distance_fn": [
      "self",
      "n",
      "compute_distance_fn",
      "norm_mse"
    ],
    "is_sigmoid": [
      "node"
    ],
    "is_softmax": [
      "node"
    ],
    "get_hessian_scores_calculator": [
      "self",
      "graph",
      "input_images",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "is_output_node_compatible_for_hessian_score_computation": [
      "self",
      "node"
    ],
    "get_node_mac_operations": [
      "self",
      "node",
      "fw_info"
    ],
    "apply_second_moment_correction": [
      "self",
      "quantized_model",
      "core_config",
      "representative_data_gen",
      "graph"
    ],
    "sensitivity_eval_inference": [
      "self",
      "model",
      "inputs"
    ],
    "get_inferable_quantizers": [
      "self",
      "node"
    ],
    "convert_data_gen_to_dataloader": [
      "data_gen_fn",
      "batch_size"
    ]
  },
  "DEFAULT_KERAS_INFO": [],
  "to_tf_tensor": [
    "tensor"
  ],
  "tf_tensor_to_numpy": [
    "tensor",
    "is_single_tensor"
  ],
  "KerasModelValidation": {
    "__init__": [
      "self",
      "model",
      "fw_info"
    ],
    "validate_output_channel_consistency": [
      "self"
    ]
  },
  "_get_min_max_outputs": [
    "node",
    "fw_info"
  ],
  "get_tensor_spec": [
    "item",
    "ignore_batch_dim"
  ],
  "TFDatasetFromGenerator": {
    "__init__": [
      "self",
      "data_gen_fn"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "FixedTFDataset": {
    "__init__": [
      "self",
      "data_gen_fn",
      "n_samples"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "create_tf_dataloader": [
    "mct_dataset",
    "batch_size",
    "shuffle",
    "collate_fn"
  ],
  "SOFTMAX": [],
  "SIGMOID": [],
  "LINEAR": [],
  "IDENTITY": [],
  "TANH": [],
  "SWISH": [],
  "RELU": [],
  "SELU": [],
  "GELU": [],
  "ARGMAX": [],
  "DILATION_RATE": [],
  "DATA_FORMAT": [],
  "PAD_SAME": [],
  "RELU_MAX_VALUE": [],
  "NEGATIVE_SLOPE": [],
  "CHANNELS_FORMAT": [],
  "CHANNELS_FORMAT_FIRST": [],
  "CHANNELS_FORMAT_LAST": [],
  "AXES": [],
  "DIMS": [],
  "TARGET_SHAPE": [],
  "TRANSPOSE_A": [],
  "TRANSPOSE_B": [],
  "ADJOINT_A": [],
  "ADJOINT_B": [],
  "DEPTH_MULTIPLIER": [],
  "DEPTHWISE_INITIALIZER": [],
  "DEPTHWISE_REGULARIZER": [],
  "DEPTHWISE_CONSTRAINT": [],
  "RATE": [],
  "FUNCTION": [],
  "F_RESHAPE": [],
  "F_STRIDED_SLICE": [],
  "F_MATMUL": [],
  "F_STACK": [],
  "F_STRIDED_SLICE_BEGIN": [],
  "F_STRIDED_SLICE_END": [],
  "F_SWISH": [],
  "DEPTHWISE_KERNEL": [],
  "CENTER": [],
  "SCALE": [],
  "QUERY_SHAPE": [],
  "KEY_SHAPE": [],
  "VALUE_SHAPE": [],
  "OUTPUT_SHAPE": [],
  "ATTENTION_AXES": [],
  "Q_KERNEL": [],
  "K_KERNEL": [],
  "V_KERNEL": [],
  "Q_BIAS": [],
  "K_BIAS": [],
  "V_BIAS": [],
  "OUTPUT_KERNEL": [],
  "OUTPUT_BIAS": [],
  "ADD": [],
  "COMBINED_NMS": [],
  "SOFTMAX_AXIS_DEFAULT": [],
  "is_keras_custom_layer": [
    "layer_class"
  ],
  "FQ_NODE_OP_V2_3": [],
  "FQ_NODE_OP_V2_4": [],
  "BATCH_INPUT_SHAPE": [],
  "KerasModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs",
      "wrapper",
      "get_activation_quantizer_holder_fn"
    ],
    "use_activation_holder_during_model_building": [
      "self"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ],
    "build_model": [
      "self"
    ],
    "_convert_node2name": [
      "self",
      "in_node_to_output_tensors_dict"
    ],
    "_build_input_tensors_list": [
      "self",
      "node",
      "node_to_output_tensors_dict"
    ],
    "_run_operation": [
      "self",
      "n",
      "input_tensors",
      "op_func",
      "input_nodes_to_input_tensors"
    ],
    "_run_operation_activation_quantization": [
      "self",
      "node",
      "node_outputs"
    ]
  },
  "FloatKerasModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ]
  },
  "keras_model_builders": [],
  "get_keras_model_builder": [
    "mode"
  ],
  "QuantizedKerasModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "_quantize_node_activations": [
      "self",
      "node",
      "input_tensors"
    ]
  },
  "OperationHandler": {
    "__init__": [
      "self",
      "graph",
      "wrapper"
    ],
    "get_node_op_function": [
      "self",
      "n"
    ]
  },
  "instance_builder": [
    "toposort",
    "wrapper"
  ],
  "MixedPrecisionKerasModelBuilder": {
    "__init__": [
      "self",
      "graph",
      "append2output",
      "fw_info",
      "return_float_outputs"
    ],
    "mixed_precision_wrapper": [
      "self",
      "n",
      "layer"
    ],
    "_get_weights_configurable_quantizer_kwargs": [
      "self",
      "n",
      "attr"
    ],
    "mixed_precision_activation_holder": [
      "self",
      "n"
    ],
    "build_model": [
      "self"
    ],
    "_get_weights_quant_layers": [
      "n",
      "layers_list"
    ],
    "_get_activation_quant_layers": [
      "n",
      "layers_list"
    ],
    "_find_layers_in_model_by_node": [
      "self",
      "n",
      "layers_list"
    ]
  },
  "PruningKerasImplementation": {
    "prune_entry_node": [
      "self",
      "node",
      "output_mask",
      "fw_info"
    ],
    "prune_intermediate_node": [
      "self",
      "node",
      "input_mask",
      "output_mask",
      "fw_info"
    ],
    "prune_exit_node": [
      "self",
      "node",
      "input_mask",
      "fw_info"
    ],
    "is_node_entry_node": [
      "self",
      "node"
    ],
    "is_node_exit_node": [
      "self",
      "node",
      "corresponding_entry_node",
      "fw_info"
    ],
    "is_node_intermediate_pruning_section": [
      "self",
      "node"
    ],
    "attrs_oi_channels_info_for_pruning": [
      "self",
      "node",
      "fw_info"
    ]
  },
  "_is_keras_node_pruning_section_edge": [
    "node"
  ],
  "_prune_keras_edge_node": [
    "node",
    "mask",
    "fw_info",
    "is_exit_node"
  ],
  "keras_compute_activation_bias_correction_of_graph": [
    "graph",
    "quant_config",
    "fw_info",
    "fw_impl"
  ],
  "keras_apply_second_moment_correction": [
    "quantized_model",
    "core_config",
    "representative_data_gen",
    "graph"
  ],
  "is_node_an_input_layer": [
    "node"
  ],
  "is_node_a_model": [
    "node"
  ],
  "keras": [],
  "REUSED_IDENTIFIER": [],
  "is_const": [],
  "is_tensor": [],
  "get_tf_function_symbols": [],
  "get_kwargs2index": [
    "tfoplambda_layer"
  ],
  "_extract_const_attrs_from_kwargs": [
    "op_call_kwargs",
    "kwarg2index",
    "weights"
  ],
  "_build_arguments_alloc": [
    "n",
    "inputs_as_list",
    "kwarg2index"
  ],
  "_extract_const_attrs_from_args": [
    "op_call_args",
    "op_call_kwargs",
    "inputs_as_list",
    "tensor_inputs_alloc",
    "weights"
  ],
  "_has_const_attributes": [
    "op_call_args",
    "op_call_kwargs",
    "input_as_list"
  ],
  "build_node": [
    "node",
    "node_name_to_node"
  ],
  "__is_functional_inputs_a_list": [
    "op_call_args",
    "keras_layer"
  ],
  "__is_node_inputs_a_list": [
    "op_call_args",
    "keras_layer"
  ],
  "ConnectivityHandler": {
    "__init__": [
      "self"
    ],
    "get_nodes": [
      "self"
    ],
    "is_tensor_connected": [
      "self",
      "tensor"
    ],
    "input_tensor2nodes": [
      "self",
      "in_tensor"
    ],
    "output_tensor2node": [
      "self",
      "out_tensor"
    ],
    "node2input_tensors": [
      "self",
      "node"
    ],
    "node2output_tensors": [
      "self",
      "node"
    ],
    "build_inputs_list": [
      "self",
      "model_input_tensors_list"
    ],
    "build_outputs_list": [
      "self",
      "model_output_tensors_list"
    ],
    "add_node": [
      "self",
      "node",
      "input_tensors_list",
      "outputs_tensors_list"
    ],
    "get_edge_indices": [
      "self",
      "src_node",
      "dst_node",
      "connecting_tensor"
    ],
    "get_out_edges_params_list": [
      "self",
      "src_node"
    ],
    "convert_to_internal_nodes": [
      "self"
    ]
  },
  "get_edges": [
    "connectivity_handler"
  ],
  "build_tensors_list": [
    "tensors_list"
  ],
  "build_connectivity_handler": [
    "model"
  ],
  "parse_model": [
    "model"
  ],
  "flatten_nested_model": [
    "outer_graph",
    "inner_model_node",
    "outer_keras_model"
  ],
  "merge_models_edges": [
    "inner_model_node",
    "outer_graph",
    "inner_graph"
  ],
  "rewire_outgoing_edged": [
    "inner_model_outputs",
    "model_node_out_edges",
    "res_edges"
  ],
  "rewire_incoming_edges": [
    "inner_inputs_out_edges",
    "inner_model_inputs_dict",
    "model_node_in_edges",
    "res_edge_list"
  ],
  "get_inner_inputs_successors": [
    "inner_graph"
  ],
  "get_model_node_edges": [
    "model_node",
    "outer_edge_list"
  ],
  "merge_graphs": [
    "inner_model_node",
    "outer_graph",
    "inner_graph"
  ],
  "merge_models_outputs": [
    "inner_model_node",
    "outer_graph",
    "inner_graph"
  ],
  "merge_models_nodes": [
    "inner_model_node",
    "outer_graph",
    "inner_graph"
  ],
  "ActivationHessianScoresCalculatorKeras": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "compute": [
      "self"
    ]
  },
  "HessianScoresCalculatorKeras": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "_concat_tensors": [
      "self",
      "tensors_to_concate"
    ],
    "_generate_random_vectors_batch": [
      "self",
      "shape"
    ]
  },
  "WeightsHessianScoresCalculatorKeras": {
    "__init__": [
      "self",
      "graph",
      "input_images",
      "fw_impl",
      "hessian_scores_request",
      "num_iterations_for_approximation"
    ],
    "compute": [
      "self"
    ],
    "_reshape_gradients": [
      "self",
      "gradients",
      "output_channel_axis",
      "num_of_scores"
    ],
    "_get_num_scores_by_granularity": [
      "self",
      "weight_tensor",
      "output_channel_axis"
    ]
  },
  "LUTFakeQuant": {
    "__init__": [
      "self",
      "quantization_params"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "input_data"
    ],
    "lut_kmeans_quantizer": [
      "self",
      "tensor_data"
    ],
    "int_quantization_with_threshold": [
      "self",
      "data",
      "n_bits",
      "eps"
    ]
  },
  "quantizer_min_max_calculator": [
    "threshold",
    "num_bits",
    "signed"
  ],
  "DwconvToConv": {
    "__init__": [
      "self"
    ],
    "_get_weight_by_name": [
      "node",
      "w_str"
    ],
    "substitute": [
      "self",
      "graph",
      "dwconv_node"
    ]
  },
  "MulSigmoidToSwish": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "sigmoid_mul_edge"
    ]
  },
  "extract_bias_node_data": [
    "_node",
    "_graph"
  ],
  "replace_conv_node": [
    "graph",
    "new_node",
    "old_node",
    "remove_add_node"
  ],
  "Conv2dFuncToConv2dLayer": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "conv_func_node"
    ],
    "_parse_tf_stride_dilation": [
      "self",
      "node",
      "key"
    ]
  },
  "DwConv2dFuncToDwConv2dLayer": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "dwconv_func_node"
    ]
  },
  "homogeneous_activation_nodes": [],
  "MATCHER_MID": [],
  "MATCHER_MID_WITH_PAD": [],
  "ScaleEqualizationMidActivation": {
    "__init__": [
      "self",
      "quant_config",
      "fw_info"
    ]
  },
  "ScaleEqualizationMidActivationWithPad": {
    "__init__": [
      "self",
      "quant_config",
      "fw_info"
    ]
  },
  "keras_batchnorm_reconstruction": [],
  "keras_apply_shift_negative_correction": [
    "graph",
    "core_config",
    "fw_info"
  ],
  "keras_batchnorm_refusing": [],
  "input_node": [],
  "INPUT_MATCHER": [],
  "INPUT_MATCHER_WITH_PAD": [],
  "BaseInputScaling": {
    "__init__": [
      "self",
      "matcher_instance"
    ],
    "substitute": [
      "self",
      "graph",
      "nodes_list"
    ]
  },
  "InputScaling": {
    "__init__": [
      "self"
    ]
  },
  "InputScalingWithPad": {
    "__init__": [
      "self"
    ]
  },
  "MatmulToDenseSubstitution": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "matmul_node"
    ]
  },
  "keras_residual_collapsing": [],
  "ActivationDecomposition": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "op2d_node"
    ]
  },
  "POINTWISE_KERNEL": [],
  "SEPARABLE_PW_KERNEL_INITIALIZER": [],
  "SEPARABLE_PW_KERNEL_REGULARIZER": [],
  "SEPARABLE_PW_KERNEL_CONSTRAINT": [],
  "SeparableConvDecomposition": {
    "__init__": [
      "self"
    ],
    "substitute": [
      "self",
      "graph",
      "separable_node"
    ]
  },
  "keras_batchnorm_folding": [],
  "keras_batchnorm_forward_folding": [],
  "keras_softmax_shift": [],
  "keras_linear_collapsing": [],
  "op2d_add_const_collapsing_node_matchers": [],
  "op2d_add_const_collapsing_fn": [
    "op2d_node",
    "add_node",
    "bias_str"
  ],
  "keras_op2d_add_const_collapsing": [],
  "ModelFoldingUtils": {
    "__init__": [
      "self",
      "fw_info",
      "fw_impl",
      "fw_default_fqc"
    ],
    "create_float_folded_model": [
      "self",
      "float_model",
      "representative_dataset"
    ],
    "create_float_folded_graph": [
      "self",
      "model",
      "repr_dataset"
    ]
  },
  "TensorboardUtils": {
    "__init__": [
      "self",
      "report_dir",
      "fw_info",
      "fw_impl"
    ],
    "get_graph_for_tensorboard_display": [
      "self",
      "quantized_model",
      "similarity_metrics",
      "repr_dataset",
      "quantized_model_metadata"
    ],
    "add_histograms_to_tensorboard": [
      "self",
      "graph"
    ],
    "add_graph_to_tensorboard": [
      "self",
      "quantized_model",
      "similarity_metrics",
      "repr_dataset",
      "quantized_model_metadata"
    ],
    "add_text_information": [
      "self",
      "similarity_metrics",
      "quantized_model_metadata"
    ]
  },
  "DEFAULT_SIMILARITY_METRICS_NAMES": [],
  "SimilarityFunctions": {
    "compute_mse": [
      "x",
      "y"
    ],
    "compute_cs": [
      "x",
      "y"
    ],
    "compute_sqnr": [
      "x",
      "y"
    ],
    "get_default_similarity_metrics": [
      "self"
    ]
  },
  "DatasetUtils": {
    "prepare_dataset": [
      "dataset",
      "is_validation",
      "device"
    ]
  },
  "XQuantConfig": {
    "__init__": [
      "self",
      "report_dir",
      "custom_similarity_metrics",
      "quantize_reported_dir",
      "threshold_quantize_error",
      "is_detect_under_threshold_quantize_error",
      "threshold_degrade_layer_ratio",
      "threshold_zscore_outlier_removal",
      "threshold_ratio_unbalanced_concatenation",
      "threshold_bitwidth_mixed_precision_with_model_output_loss_objective"
    ]
  },
  "CS_SIMILARITY_METRIC_NAME": [],
  "SQNR_SIMILARITY_METRIC_NAME": [],
  "MSE_SIMILARITY_METRIC_NAME": [],
  "OUTPUT_SIMILARITY_METRICS_REPR": [],
  "OUTPUT_SIMILARITY_METRICS_VAL": [],
  "INTERMEDIATE_SIMILARITY_METRICS_REPR": [],
  "INTERMEDIATE_SIMILARITY_METRICS_VAL": [],
  "XQUANT_REPR": [],
  "XQUANT_VAL": [],
  "CUT_MEMORY_ELEMENTS": [],
  "CUT_TOTAL_SIZE": [],
  "REPORT_FILENAME": [],
  "TROUBLESHOOT_REPORT_FILENAME": [],
  "TENSORBOARD_DEFAULT_TAG": [],
  "MODEL_OUTPUT_KEY": [],
  "ModelAnalyzer": {
    "extract_model_activations": [
      "self",
      "float_model",
      "quantized_model",
      "float_name2quant_name",
      "data"
    ],
    "identify_quantized_compare_points": [
      "self",
      "quantized_model"
    ],
    "find_corresponding_float_layer": [
      "self",
      "quant_compare_point",
      "quantized_model"
    ],
    "extract_float_layer_names": [
      "self",
      "float_model"
    ]
  },
  "make_similarity_graph": [
    "metrics_name",
    "dataset_name",
    "intermediate_similarity",
    "degrade_layers",
    "xquant_config"
  ],
  "_compute_zscore": [
    "statistics_collector"
  ],
  "_save_outlier_histogram": [
    "layer_name",
    "zscore_hist",
    "z_threshold",
    "img_filename"
  ],
  "judge_outlier_removal": [
    "degrade_layers",
    "float_graph",
    "xquant_config"
  ],
  "judge_shift_negative_activation": [
    "float_graph",
    "xquant_config"
  ],
  "_compute_activations": [
    "name",
    "activations"
  ],
  "judge_unbalanced_concatnation": [
    "degrade_layers",
    "float_model",
    "dataset",
    "xquant_config"
  ],
  "judge_mixed_precision_with_model_output_loss_objective": [
    "quantized_model",
    "xquant_config"
  ],
  "PytorchReportUtils": {
    "__init__": [
      "self",
      "report_dir"
    ]
  },
  "core_report_generator": [
    "float_model",
    "quantized_model",
    "repr_dataset",
    "validation_dataset",
    "fw_report_utils",
    "xquant_config"
  ],
  "core_report_generator_troubleshoot": [
    "float_model",
    "quantized_model",
    "repr_dataset",
    "validation_dataset",
    "fw_report_utils",
    "xquant_config"
  ],
  "NODES_WITHOUT_CUT_INFO": [],
  "is_wrapped_linear_op": [
    "quantized_model",
    "node"
  ],
  "PytorchTensorboardUtils": {
    "__init__": [
      "self",
      "report_dir",
      "fw_info",
      "fw_impl"
    ],
    "get_graph_for_tensorboard_display": [
      "self",
      "quantized_model",
      "similarity_metrics",
      "repr_dataset",
      "quantized_model_metadata"
    ]
  },
  "populate_fused_node_memory_elements": [
    "quantized_model_metadata"
  ],
  "assign_cut_info_to_node": [
    "node",
    "memory_elements"
  ],
  "process_node_cut_info": [
    "node",
    "fused_node_to_memory_elements",
    "quantized_model_metadata",
    "quantized_model"
  ],
  "insert_cut_info_into_graph": [
    "quant_graph",
    "quantized_model_metadata",
    "quantized_model"
  ],
  "FrameworkReportUtils": {
    "__init__": [
      "self",
      "fw_info",
      "fw_impl",
      "similarity_calculator",
      "dataset_utils",
      "model_folding_utils",
      "tb_utils",
      "get_metadata_fn"
    ],
    "dump_report_to_json": [
      "self",
      "report_dir",
      "collected_data"
    ],
    "dump_troubleshoot_report_to_json": [
      "self",
      "report_dir",
      "collected_data"
    ]
  },
  "PytorchSimilarityFunctions": {
    "compute_mse": [
      "x",
      "y"
    ],
    "compute_cs": [
      "x",
      "y"
    ],
    "compute_sqnr": [
      "x",
      "y"
    ]
  },
  "PytorchDatasetUtils": {
    "prepare_dataset": [
      "dataset",
      "is_validation",
      "device"
    ]
  },
  "SimilarityCalculator": {
    "__init__": [
      "self",
      "dataset_utils",
      "model_folding",
      "similarity_functions",
      "model_analyzer_utils",
      "device"
    ],
    "compute_tensors_similarity": [
      "tensors_to_compare",
      "similarity_metrics"
    ],
    "_get_float_to_quantized_compare_points": [
      "self",
      "quantized_model",
      "float_model"
    ],
    "compute_similarity_metrics": [
      "self",
      "float_model",
      "quantized_model",
      "dataset",
      "custom_similarity_metrics",
      "is_validation"
    ]
  },
  "core_detect_degrade_layer": [
    "repl_similarity",
    "val_similarity",
    "xquant_config"
  ],
  "core_judge_troubleshoot": [
    "float_model",
    "quantized_model",
    "float_graph",
    "degrade_layers",
    "dataset",
    "xquant_config"
  ],
  "PytorchModelAnalyzer": {
    "extract_model_activations": [
      "self",
      "float_model",
      "quantized_model",
      "float_name2quant_name",
      "data"
    ],
    "identify_quantized_compare_points": [
      "self",
      "quantized_model"
    ],
    "find_corresponding_float_layer": [
      "self",
      "quant_compare_point",
      "quantized_model"
    ],
    "extract_float_layer_names": [
      "self",
      "float_model"
    ]
  },
  "KerasReportUtils": {
    "__init__": [
      "self",
      "report_dir"
    ]
  },
  "KerasTensorboardUtils": {
    "__init__": [
      "self",
      "report_dir",
      "fw_info",
      "fw_impl"
    ],
    "get_graph_for_tensorboard_display": [
      "self",
      "quantized_model",
      "similarity_metrics",
      "repr_dataset",
      "quantized_model_metadata"
    ]
  },
  "KerasSimilarityFunctions": {
    "compute_mse": [
      "x",
      "y"
    ],
    "compute_cs": [
      "x",
      "y"
    ],
    "compute_sqnr": [
      "x",
      "y"
    ]
  },
  "KerasDatasetUtils": {
    "prepare_dataset": [
      "dataset",
      "is_validation",
      "device"
    ]
  },
  "KerasModelAnalyzer": {
    "extract_model_activations": [
      "self",
      "float_model",
      "quantized_model",
      "float_name2quant_name",
      "data"
    ],
    "identify_quantized_compare_points": [
      "self",
      "quantized_model"
    ],
    "find_corresponding_float_layer": [
      "self",
      "quant_compare_point",
      "quantized_model"
    ],
    "extract_float_layer_names": [
      "self",
      "float_model"
    ]
  }
}