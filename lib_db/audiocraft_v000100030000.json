{
  "NAME": [],
  "DESCRIPTION": [],
  "URL": [],
  "AUTHOR": [],
  "EMAIL": [],
  "REQUIRES_PYTHON": [],
  "HERE": [],
  "REQUIRED": [],
  "MODEL": [],
  "SPACE_ID": [],
  "MAX_BATCH_SIZE": [],
  "N_REPEATS": [],
  "INTERRUPTING": [],
  "MBD": [],
  "_old_call": [],
  "PROD_STRIDE_1": [],
  "_call_nostderr": [],
  "pool": [],
  "interrupt": [],
  "FileCleaner": {
    "__init__": [
      "self",
      "file_lifetime"
    ],
    "add": [
      "self",
      "path"
    ],
    "_cleanup": [
      "self"
    ]
  },
  "file_cleaner": [],
  "make_waveform": [],
  "load_model": [
    "version"
  ],
  "_do_predictions": [
    "texts",
    "progress",
    "gradio_progress"
  ],
  "predict_batched": [
    "texts",
    "melodies"
  ],
  "predict_full": [
    "model",
    "model_path",
    "text",
    "temperature",
    "topp",
    "max_cfg_coef",
    "min_cfg_coef",
    "decoding_steps1",
    "decoding_steps2",
    "decoding_steps3",
    "decoding_steps4",
    "span_score",
    "progress"
  ],
  "ui_full": [
    "launch_kwargs"
  ],
  "IS_BATCHED": [],
  "BATCHED_DURATION": [],
  "load_diffusion": [],
  "toggle_audio_src": [
    "choice"
  ],
  "toggle_diffusion": [
    "choice"
  ],
  "ui_batched": [
    "launch_kwargs"
  ],
  "test_mel_l1_loss": [],
  "test_msspec_loss": [],
  "test_mrstft_loss": [],
  "test_sisnr_loss": [],
  "test_stft_loss": [],
  "get_white_noise": [
    "chs",
    "num_frames"
  ],
  "get_batch_white_noise": [
    "bs",
    "chs",
    "num_frames"
  ],
  "save_wav": [
    "path",
    "wav",
    "sample_rate"
  ],
  "TempDirMixin": {
    "temp_dir_": [],
    "get_base_temp_dir": [
      "cls"
    ],
    "tearDownClass": [
      "cls"
    ],
    "id": [
      "self"
    ],
    "get_temp_path": [
      "self"
    ],
    "get_temp_dir": [
      "self"
    ]
  },
  "TestMultiPeriodDiscriminator": {
    "test_mpd_discriminator": [
      "self"
    ]
  },
  "TestMultiScaleDiscriminator": {
    "test_msd_discriminator": [
      "self"
    ]
  },
  "TestMultiScaleStftDiscriminator": {
    "test_msstftd_discriminator": [
      "self"
    ]
  },
  "TestAdversarialLoss": {
    "test_adversarial_single_multidiscriminator": [
      "self"
    ],
    "test_adversarial_feat_loss": [
      "self"
    ]
  },
  "TestGeneratorAdversarialLoss": {
    "test_hinge_generator_adv_loss": [
      "self"
    ],
    "test_mse_generator_adv_loss": [
      "self"
    ]
  },
  "TestDiscriminatorAdversarialLoss": {
    "_disc_loss": [
      "self",
      "loss_type",
      "fake",
      "real"
    ],
    "test_hinge_discriminator_adv_loss": [
      "self"
    ],
    "test_mse_discriminator_adv_loss": [
      "self"
    ]
  },
  "TestFeatureMatchingLoss": {
    "test_features_matching_loss_base": [
      "self"
    ],
    "test_features_matching_loss_raises_exception": [
      "self"
    ],
    "test_features_matching_loss_output": [
      "self"
    ]
  },
  "TestConvertAudioChannels": {
    "test_convert_audio_channels_downmix": [
      "self"
    ],
    "test_convert_audio_channels_nochange": [
      "self"
    ],
    "test_convert_audio_channels_upmix": [
      "self"
    ],
    "test_convert_audio_channels_upmix_error": [
      "self"
    ]
  },
  "TestConvertAudio": {
    "test_convert_audio_channels_downmix": [
      "self"
    ],
    "test_convert_audio_channels_upmix": [
      "self"
    ],
    "test_convert_audio_upsample": [
      "self"
    ],
    "test_convert_audio_resample": [
      "self"
    ]
  },
  "TestNormalizeAudio": {
    "test_clip_wav": [
      "self"
    ],
    "test_normalize_audio_clip": [
      "self"
    ],
    "test_normalize_audio_rms": [
      "self"
    ],
    "test_normalize_audio_peak": [
      "self"
    ]
  },
  "TestInfo": {
    "test_info_mp3": [
      "self"
    ],
    "_test_info_format": [
      "self",
      "ext"
    ],
    "test_info_wav": [
      "self"
    ],
    "test_info_flac": [
      "self"
    ],
    "test_info_ogg": [
      "self"
    ],
    "test_info_m4a": [
      "self"
    ]
  },
  "TestRead": {
    "test_read_full_wav": [
      "self"
    ],
    "test_read_partial_wav": [
      "self"
    ],
    "test_read_seek_time_wav": [
      "self"
    ],
    "test_read_seek_time_wav_padded": [
      "self"
    ]
  },
  "TestAvRead": {
    "test_avread_seek_base": [
      "self"
    ],
    "test_avread_seek_partial": [
      "self"
    ],
    "test_avread_seek_outofbound": [
      "self"
    ],
    "test_avread_seek_edge": [
      "self"
    ]
  },
  "TestAudioWrite": {
    "test_audio_write_wav": [
      "self"
    ]
  },
  "TestAudioMeta": {
    "test_get_audio_meta": [
      "self"
    ],
    "test_save_audio_meta": [
      "self"
    ],
    "test_load_audio_meta": [
      "self"
    ]
  },
  "TestAudioDataset": {
    "_create_audio_files": [
      "self",
      "root_name",
      "num_examples",
      "durations",
      "sample_rate",
      "channels"
    ],
    "_create_audio_dataset": [
      "self",
      "root_name",
      "total_num_examples",
      "durations",
      "sample_rate",
      "channels",
      "segment_duration",
      "num_examples",
      "shuffle",
      "return_info"
    ],
    "test_dataset_full": [
      "self"
    ],
    "test_dataset_segment": [
      "self"
    ],
    "test_dataset_equal_audio_and_segment_durations": [
      "self"
    ],
    "test_dataset_samples": [
      "self"
    ],
    "test_dataset_return_info": [
      "self"
    ],
    "test_dataset_return_info_no_segment_duration": [
      "self"
    ],
    "test_dataset_collate_fn": [
      "self"
    ],
    "test_dataset_with_meta_collate_fn": [
      "self",
      "segment_duration"
    ],
    "test_sample_with_weight": [
      "self",
      "segment_duration",
      "sample_on_weight",
      "sample_on_duration",
      "a_hist",
      "b_hist",
      "c_hist"
    ],
    "test_meta_duration_filter_all": [
      "self"
    ],
    "test_meta_duration_filter_long": [
      "self"
    ]
  },
  "TestStreamableLSTM": {
    "test_lstm": [
      "self"
    ],
    "test_lstm_skip": [
      "self"
    ]
  },
  "test_get_extra_padding_for_conv1d": [],
  "test_pad1d_zeros": [],
  "test_pad1d_reflect": [],
  "test_unpad1d": [],
  "TestNormConv1d": {
    "test_norm_conv1d_modules": [
      "self"
    ]
  },
  "TestNormConvTranspose1d": {
    "test_normalizations": [
      "self"
    ]
  },
  "TestStreamableConv1d": {
    "get_streamable_conv1d_output_length": [
      "self",
      "length",
      "kernel_size",
      "stride",
      "dilation"
    ],
    "test_streamable_conv1d": [
      "self"
    ]
  },
  "TestStreamableConvTranspose1d": {
    "get_streamable_convtr1d_output_length": [
      "self",
      "length",
      "kernel_size",
      "stride"
    ],
    "test_streamable_convtr1d": [
      "self"
    ]
  },
  "test_transformer_causal_streaming": [],
  "test_transformer_vs_pytorch": [],
  "test_streaming_api": [],
  "test_memory_efficient": [],
  "test_attention_as_float32": [],
  "test_streaming_memory_efficient": [],
  "test_cross_attention": [],
  "test_cross_attention_compat": [],
  "test_repeat_kv": [],
  "test_qk_layer_norm": [],
  "TestSEANetModel": {
    "test_base": [
      "self"
    ],
    "test_causal": [
      "self"
    ],
    "test_conv_skip_connection": [
      "self"
    ],
    "test_seanet_encoder_decoder_final_act": [
      "self"
    ],
    "_check_encoder_blocks_norm": [
      "self",
      "encoder",
      "n_disable_blocks",
      "norm"
    ],
    "test_encoder_disable_norm": [
      "self"
    ],
    "_check_decoder_blocks_norm": [
      "self",
      "decoder",
      "n_disable_blocks",
      "norm"
    ],
    "test_decoder_disable_norm": [
      "self"
    ],
    "test_disable_norm_raises_exception": [
      "self"
    ]
  },
  "TestParallelPatternProvider": {
    "test_get_pattern": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_pattern_content": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_pattern_max_delay": [
      "self",
      "n_q",
      "timesteps"
    ]
  },
  "TestDelayedPatternProvider": {
    "test_get_pattern": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_pattern_content": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_pattern_max_delay": [
      "self",
      "timesteps",
      "delay"
    ]
  },
  "TestUnrolledPatternProvider": {
    "test_get_pattern": [
      "self",
      "timesteps",
      "flattening",
      "delays"
    ],
    "test_pattern_max_delay": [
      "self",
      "timesteps",
      "flattening",
      "delays"
    ]
  },
  "TestPattern": {
    "ref_build_pattern_sequence": [
      "self",
      "z",
      "pattern",
      "special_token"
    ],
    "ref_revert_pattern_sequence": [
      "self",
      "z",
      "pattern",
      "special_token"
    ],
    "ref_revert_pattern_logits": [
      "self",
      "z",
      "pattern",
      "special_token"
    ],
    "_get_pattern_providers": [
      "self",
      "n_q"
    ],
    "test_build_pattern_sequence": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_revert_pattern_sequence": [
      "self",
      "n_q",
      "timesteps"
    ],
    "test_revert_pattern_logits": [
      "self",
      "n_q",
      "timesteps",
      "card"
    ]
  },
  "test_rope": [],
  "test_rope_io_dtypes": [],
  "test_transformer_with_rope": [],
  "test_rope_streaming": [],
  "test_rope_streaming_past_context": [],
  "test_rope_memory_efficient": [],
  "test_rope_with_xpos": [],
  "test_positional_scale": [],
  "TestActivations": {
    "test_custom_glu_calculation": [
      "self"
    ]
  },
  "__version__": [],
  "logger": [],
  "resolve_config_dset_paths": [
    "cfg"
  ],
  "get_solver": [
    "cfg"
  ],
  "get_solver_from_xp": [
    "xp",
    "override_cfg",
    "restore",
    "load_best",
    "ignore_state_keys",
    "disable_fsdp"
  ],
  "get_solver_from_sig": [
    "sig"
  ],
  "init_seed_and_system": [
    "cfg"
  ],
  "main": [
    "cfg"
  ],
  "AudioCraftEnvironment": {
    "_instance": [],
    "DEFAULT_TEAM": [],
    "__init__": [
      "self"
    ],
    "_get_cluster_config": [
      "self"
    ],
    "instance": [
      "cls"
    ],
    "reset": [
      "cls"
    ],
    "get_team": [
      "cls"
    ],
    "get_cluster": [
      "cls"
    ],
    "get_dora_dir": [
      "cls"
    ],
    "get_reference_dir": [
      "cls"
    ],
    "get_slurm_exclude": [
      "cls"
    ],
    "get_slurm_partitions": [
      "cls",
      "partition_types"
    ],
    "resolve_reference_path": [
      "cls",
      "path"
    ],
    "apply_dataset_mappers": [
      "cls",
      "path"
    ]
  },
  "_unfold": [
    "a",
    "kernel_size",
    "stride"
  ],
  "_center": [
    "x"
  ],
  "_norm2": [
    "x"
  ],
  "SISNR": {
    "__init__": [
      "self",
      "sample_rate",
      "segment",
      "overlap",
      "epsilon"
    ],
    "forward": [
      "self",
      "out_sig",
      "ref_sig"
    ]
  },
  "MelSpectrogramWrapper": {
    "__init__": [
      "self",
      "n_fft",
      "hop_length",
      "win_length",
      "n_mels",
      "sample_rate",
      "f_min",
      "f_max",
      "log",
      "normalized",
      "floor_level"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MelSpectrogramL1Loss": {
    "__init__": [
      "self",
      "sample_rate",
      "n_fft",
      "hop_length",
      "win_length",
      "n_mels",
      "f_min",
      "f_max",
      "log",
      "normalized",
      "floor_level"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "MultiScaleMelSpectrogramLoss": {
    "__init__": [
      "self",
      "sample_rate",
      "range_start",
      "range_end",
      "n_mels",
      "f_min",
      "f_max",
      "normalized",
      "alphas",
      "floor_level"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "_stft": [
    "x",
    "fft_size",
    "hop_length",
    "win_length",
    "window",
    "normalized"
  ],
  "SpectralConvergenceLoss": {
    "__init__": [
      "self",
      "epsilon"
    ],
    "forward": [
      "self",
      "x_mag",
      "y_mag"
    ]
  },
  "LogSTFTMagnitudeLoss": {
    "__init__": [
      "self",
      "epsilon"
    ],
    "forward": [
      "self",
      "x_mag",
      "y_mag"
    ]
  },
  "STFTLosses": {
    "__init__": [
      "self",
      "n_fft",
      "hop_length",
      "win_length",
      "window",
      "normalized",
      "epsilon"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "STFTLoss": {
    "__init__": [
      "self",
      "n_fft",
      "hop_length",
      "win_length",
      "window",
      "normalized",
      "factor_sc",
      "factor_mag",
      "epsilon"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "MRSTFTLoss": {
    "__init__": [
      "self",
      "n_ffts",
      "hop_lengths",
      "win_lengths",
      "window",
      "factor_sc",
      "factor_mag",
      "normalized",
      "epsilon"
    ],
    "forward": [
      "self",
      "x",
      "y"
    ]
  },
  "Balancer": {
    "__init__": [
      "self",
      "weights",
      "balance_grads",
      "total_norm",
      "ema_decay",
      "per_batch_item",
      "epsilon",
      "monitor"
    ],
    "metrics": [
      "self"
    ],
    "backward": [
      "self",
      "losses",
      "input"
    ]
  },
  "TextConsistencyMetric": {
    "update": [
      "self",
      "audio",
      "text",
      "sizes",
      "sample_rates"
    ],
    "compute": [
      "self"
    ]
  },
  "CLAPTextConsistencyMetric": {
    "__init__": [
      "self",
      "model_path",
      "model_arch",
      "enable_fusion"
    ],
    "_initialize_model": [
      "self",
      "model_path",
      "model_arch",
      "enable_fusion"
    ],
    "_tokenizer": [
      "self",
      "texts"
    ],
    "update": [
      "self",
      "audio",
      "text",
      "sizes",
      "sample_rates"
    ],
    "compute": [
      "self"
    ]
  },
  "ViSQOL": {
    "SAMPLE_RATES_MODES": [],
    "ALLOWED_SAMPLE_RATES": [],
    "__init__": [
      "self",
      "bin",
      "mode",
      "model",
      "debug"
    ],
    "_get_target_sr": [
      "self",
      "mode"
    ],
    "_prepare_files": [
      "self",
      "ref_sig",
      "deg_sig",
      "sr",
      "target_sr",
      "pad_with_silence"
    ],
    "_flush_files": [
      "self",
      "tmp_dir"
    ],
    "_collect_moslqo_score": [
      "self",
      "results_csv_path"
    ],
    "_collect_debug_data": [
      "self",
      "debug_json_path"
    ],
    "visqol_model": [
      "self"
    ],
    "_run_visqol": [
      "self",
      "input_csv_path",
      "results_csv_path",
      "debug_csv_path"
    ],
    "__call__": [
      "self",
      "ref_sig",
      "deg_sig",
      "sr",
      "pad_with_silence"
    ]
  },
  "ChromaCosineSimilarityMetric": {
    "__init__": [
      "self",
      "sample_rate",
      "n_chroma",
      "radix2_exp",
      "argmax",
      "eps"
    ],
    "update": [
      "self",
      "preds",
      "targets",
      "sizes",
      "sample_rates"
    ],
    "compute": [
      "self"
    ]
  },
  "db_to_scale": [
    "volume"
  ],
  "scale_to_db": [
    "scale",
    "min_volume"
  ],
  "RelativeVolumeMel": {
    "__init__": [
      "self",
      "sample_rate",
      "n_mels",
      "n_fft",
      "hop_length",
      "min_relative_volume",
      "max_relative_volume",
      "max_initial_gain",
      "min_activity_volume",
      "num_aggregated_bands"
    ],
    "forward": [
      "self",
      "estimate",
      "ground_truth"
    ]
  },
  "VGGISH_SAMPLE_RATE": [],
  "VGGISH_CHANNELS": [],
  "FrechetAudioDistanceMetric": {
    "__init__": [
      "self",
      "bin",
      "model_path",
      "format",
      "batch_size",
      "log_folder"
    ],
    "reset": [
      "self",
      "log_folder"
    ],
    "update": [
      "self",
      "preds",
      "targets",
      "sizes",
      "sample_rates",
      "stems"
    ],
    "_get_samples_name": [
      "self",
      "is_background"
    ],
    "_create_embedding_beams": [
      "self",
      "is_background",
      "gpu_index"
    ],
    "_compute_fad_score": [
      "self",
      "gpu_index"
    ],
    "_log_process_result": [
      "self",
      "returncode",
      "log_file",
      "is_background"
    ],
    "_parallel_create_embedding_beams": [
      "self",
      "num_of_gpus"
    ],
    "_sequential_create_embedding_beams": [
      "self"
    ],
    "_local_compute_frechet_audio_distance": [
      "self"
    ],
    "compute": [
      "self"
    ]
  },
  "_patch_passt_stft": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "kl_divergence": [
    "pred_probs",
    "target_probs",
    "epsilon"
  ],
  "KLDivergenceMetric": {
    "__init__": [
      "self"
    ],
    "_get_label_distribution": [
      "self",
      "x",
      "sizes",
      "sample_rates"
    ],
    "update": [
      "self",
      "preds",
      "targets",
      "sizes",
      "sample_rates"
    ],
    "compute": [
      "self"
    ]
  },
  "PasstKLDivergenceMetric": {
    "__init__": [
      "self",
      "pretrained_length"
    ],
    "_initialize_model": [
      "self",
      "pretrained_length"
    ],
    "_load_base_model": [
      "self",
      "pretrained_length"
    ],
    "_process_audio": [
      "self",
      "wav",
      "sample_rate",
      "wav_len"
    ],
    "_get_model_preds": [
      "self",
      "wav"
    ],
    "_get_label_distribution": [
      "self",
      "x",
      "sizes",
      "sample_rates"
    ]
  },
  "get_sheep_ping": [
    "sheep"
  ],
  "BaseExplorer": {
    "stages": [
      "self"
    ],
    "get_grid_meta": [
      "self"
    ],
    "get_grid_metrics": [
      "self"
    ],
    "process_sheep": [
      "self",
      "sheep",
      "history"
    ]
  },
  "explorer": [
    "launcher"
  ],
  "DiffusionExplorer": {
    "eval_metrics": [],
    "stages": [
      "self"
    ],
    "get_grid_meta": [
      "self"
    ],
    "get_grid_metrics": [
      "self"
    ]
  },
  "eval": [
    "launcher",
    "batch_size"
  ],
  "CompressionExplorer": {
    "eval_metrics": [],
    "stages": [
      "self"
    ],
    "get_grid_meta": [
      "self"
    ],
    "get_grid_metrics": [
      "self"
    ]
  },
  "LMExplorer": {
    "stages": [
      "self"
    ],
    "get_grid_metrics": [
      "self"
    ],
    "process_sheep": [
      "self",
      "sheep",
      "history"
    ]
  },
  "GenerationEvalExplorer": {
    "stages": [
      "self"
    ],
    "get_grid_metrics": [
      "self"
    ]
  },
  "DeadlockDetect": {
    "__init__": [
      "self",
      "use",
      "timeout"
    ],
    "update": [
      "self",
      "stage"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_val",
      "exc_tb"
    ],
    "_detector_thread": [
      "self"
    ]
  },
  "export_encodec": [
    "checkpoint_path",
    "out_file"
  ],
  "export_pretrained_compression_model": [
    "pretrained_encodec",
    "out_file"
  ],
  "export_lm": [
    "checkpoint_path",
    "out_file"
  ],
  "BestStateDictManager": {
    "__init__": [
      "self",
      "device",
      "dtype"
    ],
    "_get_parameter_ids": [
      "self",
      "state_dict"
    ],
    "_validate_no_parameter_ids_overlap": [
      "self",
      "name",
      "param_ids"
    ],
    "update": [
      "self",
      "name",
      "source"
    ],
    "register": [
      "self",
      "name",
      "source"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state"
    ]
  },
  "get_full_embed": [
    "full_embed",
    "x",
    "idx",
    "device"
  ],
  "EmbeddingCache": {
    "__init__": [
      "self",
      "cache_path",
      "device",
      "compute_embed_fn",
      "extract_embed_fn"
    ],
    "_get_cache_path": [
      "self",
      "path"
    ],
    "_get_full_embed_from_cache": [
      "cache"
    ],
    "get_embed_from_cache": [
      "self",
      "paths",
      "x"
    ],
    "populate_embed_cache": [
      "self",
      "paths",
      "x"
    ]
  },
  "CachedBatchWriter": {
    "__init__": [
      "self",
      "cache_folder"
    ],
    "start_epoch": [
      "self",
      "epoch"
    ],
    "_get_zip_path": [
      "cache_folder",
      "epoch",
      "index"
    ],
    "_zip_path": [
      "self"
    ],
    "save": [
      "self"
    ]
  },
  "CachedBatchLoader": {
    "__init__": [
      "self",
      "cache_folder",
      "batch_size",
      "num_workers",
      "min_length"
    ],
    "__len__": [
      "self"
    ],
    "start_epoch": [
      "self",
      "epoch"
    ],
    "_zip_path": [
      "self",
      "index"
    ],
    "_load_one": [
      "self",
      "index"
    ],
    "__iter__": [
      "self"
    ]
  },
  "CheckpointSource": {
    "CURRENT_XP": [],
    "PRETRAINED": [],
    "OTHER": []
  },
  "checkpoint_name": [
    "name",
    "rank",
    "use_fsdp"
  ],
  "is_sharded_checkpoint": [
    "path"
  ],
  "resolve_checkpoint_path": [
    "sig_or_path",
    "name",
    "use_fsdp"
  ],
  "load_checkpoint": [
    "checkpoint_path",
    "is_sharded"
  ],
  "save_checkpoint": [
    "state",
    "checkpoint_path",
    "is_sharded"
  ],
  "flush_stale_checkpoints": [
    "checkpoint_path",
    "keep_last"
  ],
  "check_sharded_checkpoint": [
    "checkpoint_path",
    "rank0_checkpoint_path"
  ],
  "_safe_save_checkpoint": [
    "state",
    "checkpoint_path",
    "is_sharded"
  ],
  "_clean_lm_cfg": [
    "cfg"
  ],
  "model_hash": [
    "model"
  ],
  "dict_from_config": [
    "cfg"
  ],
  "random_subset": [
    "dataset",
    "max_samples",
    "seed"
  ],
  "get_loader": [
    "dataset",
    "num_samples",
    "batch_size",
    "num_workers",
    "seed"
  ],
  "get_dataset_from_loader": [
    "dataloader"
  ],
  "multinomial": [
    "input",
    "num_samples",
    "replacement"
  ],
  "sample_top_k": [
    "probs",
    "k"
  ],
  "sample_top_p": [
    "probs",
    "p"
  ],
  "DummyPoolExecutor": {
    "__init__": [
      "self",
      "workers",
      "mp_context"
    ],
    "submit": [
      "self",
      "func"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "exc_tb"
    ]
  },
  "get_pool_executor": [
    "num_workers",
    "mp_context"
  ],
  "length_to_mask": [
    "lengths",
    "max_len"
  ],
  "hash_trick": [
    "word",
    "vocab_size"
  ],
  "with_rank_rng": [
    "base_seed"
  ],
  "collate": [
    "tensors",
    "dim"
  ],
  "copy_state": [
    "state",
    "device",
    "dtype"
  ],
  "swap_state": [
    "model",
    "state"
  ],
  "warn_once": [
    "logger",
    "msg"
  ],
  "is_jsonable": [
    "x"
  ],
  "load_clap_state_dict": [
    "clap_model",
    "path"
  ],
  "ClusterType": {
    "AWS": [],
    "FAIR": [],
    "RSC": [],
    "LOCAL_DARWIN": [],
    "DEFAULT": []
  },
  "_guess_cluster_type": [],
  "get_cluster_type": [
    "cluster_type"
  ],
  "get_slurm_parameters": [
    "cfg",
    "cluster_type"
  ],
  "display_audio": [
    "samples",
    "sample_rate"
  ],
  "TorchAutocast": {
    "__init__": [
      "self",
      "enabled"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "Profiler": {
    "__init__": [
      "self",
      "module",
      "enabled"
    ],
    "step": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self",
      "exc_type",
      "exc_value",
      "exc_tb"
    ]
  },
  "ReferenceSample": {},
  "Sample": {
    "__hash__": [
      "self"
    ],
    "audio": [
      "self"
    ],
    "audio_prompt": [
      "self"
    ],
    "audio_reference": [
      "self"
    ]
  },
  "SampleManager": {
    "__init__": [
      "self",
      "xp",
      "map_reference_to_sample_id"
    ],
    "latest_epoch": [
      "self"
    ],
    "_load_samples": [
      "self"
    ],
    "_load_sample": [
      "json_file"
    ],
    "_init_hash": [
      "self"
    ],
    "_get_tensor_id": [
      "self",
      "tensor"
    ],
    "_get_sample_id": [
      "self",
      "index",
      "prompt_wav",
      "conditions"
    ],
    "_store_audio": [
      "self",
      "wav",
      "stem_path",
      "overwrite"
    ],
    "add_sample": [
      "self",
      "sample_wav",
      "epoch",
      "index",
      "conditions",
      "prompt_wav",
      "ground_truth_wav",
      "generation_args"
    ],
    "add_samples": [
      "self",
      "samples_wavs",
      "epoch",
      "conditioning",
      "prompt_wavs",
      "ground_truth_wavs",
      "generation_args"
    ],
    "get_samples": [
      "self",
      "epoch",
      "max_epoch",
      "exclude_prompted",
      "exclude_unprompted",
      "exclude_conditioned",
      "exclude_unconditioned"
    ]
  },
  "slugify": [
    "value",
    "allow_unicode"
  ],
  "_match_stable_samples": [
    "samples_per_xp"
  ],
  "_match_unstable_samples": [
    "samples_per_xp"
  ],
  "get_samples_for_xps": [
    "xps"
  ],
  "ADVERSARIAL_LOSSES": [],
  "AdvLossType": [],
  "FeatLossType": [],
  "AdversarialLoss": {
    "__init__": [
      "self",
      "adversary",
      "optimizer",
      "loss",
      "loss_real",
      "loss_fake",
      "loss_feat",
      "normalize"
    ],
    "_save_to_state_dict": [
      "self",
      "destination",
      "prefix",
      "keep_vars"
    ],
    "_load_from_state_dict": [
      "self",
      "state_dict",
      "prefix"
    ],
    "get_adversary_pred": [
      "self",
      "x"
    ],
    "train_adv": [
      "self",
      "fake",
      "real"
    ],
    "forward": [
      "self",
      "fake",
      "real"
    ]
  },
  "get_adv_criterion": [
    "loss_type"
  ],
  "get_fake_criterion": [
    "loss_type"
  ],
  "get_real_criterion": [
    "loss_type"
  ],
  "mse_real_loss": [
    "x"
  ],
  "mse_fake_loss": [
    "x"
  ],
  "hinge_real_loss": [
    "x"
  ],
  "hinge_fake_loss": [
    "x"
  ],
  "mse_loss": [
    "x"
  ],
  "hinge_loss": [
    "x"
  ],
  "hinge2_loss": [
    "x"
  ],
  "FeatureMatchingLoss": {
    "__init__": [
      "self",
      "loss",
      "normalize"
    ],
    "forward": [
      "self",
      "fmap_fake",
      "fmap_real"
    ]
  },
  "FeatureMapType": [],
  "LogitsType": [],
  "MultiDiscriminatorOutputType": [],
  "MultiDiscriminator": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ],
    "num_discriminators": [
      "self"
    ]
  },
  "ScaleDiscriminator": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_sizes",
      "filters",
      "max_filters",
      "downsample_scales",
      "inner_kernel_sizes",
      "groups",
      "strides",
      "paddings",
      "norm",
      "activation",
      "activation_params",
      "pad",
      "pad_params"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MultiScaleDiscriminator": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "downsample_factor",
      "scale_norms"
    ],
    "num_discriminators": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "get_padding": [
    "kernel_size",
    "dilation"
  ],
  "PeriodDiscriminator": {
    "__init__": [
      "self",
      "period",
      "in_channels",
      "out_channels",
      "n_layers",
      "kernel_sizes",
      "stride",
      "filters",
      "filters_scale",
      "max_filters",
      "norm",
      "activation",
      "activation_params"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MultiPeriodDiscriminator": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "periods"
    ],
    "num_discriminators": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "get_2d_padding": [
    "kernel_size",
    "dilation"
  ],
  "DiscriminatorSTFT": {
    "__init__": [
      "self",
      "filters",
      "in_channels",
      "out_channels",
      "n_fft",
      "hop_length",
      "win_length",
      "max_filters",
      "filters_scale",
      "kernel_size",
      "dilations",
      "stride",
      "normalized",
      "norm",
      "activation",
      "activation_params"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MultiScaleSTFTDiscriminator": {
    "__init__": [
      "self",
      "filters",
      "in_channels",
      "out_channels",
      "sep_channels",
      "n_ffts",
      "hop_lengths",
      "win_lengths"
    ],
    "num_discriminators": [
      "self"
    ],
    "_separate_channels": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_av_initialized": [],
  "_init_av": [],
  "AudioFileInfo": {},
  "_av_info": [
    "filepath"
  ],
  "_soundfile_info": [
    "filepath"
  ],
  "audio_info": [
    "filepath"
  ],
  "_av_read": [
    "filepath",
    "seek_time",
    "duration"
  ],
  "audio_read": [
    "filepath",
    "seek_time",
    "duration",
    "pad"
  ],
  "_piping_to_ffmpeg": [
    "out_path",
    "wav",
    "sample_rate",
    "flags"
  ],
  "audio_write": [
    "stem_name",
    "wav",
    "sample_rate",
    "format",
    "mp3_rate",
    "ogg_rate",
    "normalize",
    "strategy",
    "peak_clip_headroom_db",
    "rms_headroom_db",
    "loudness_headroom_db",
    "loudness_compressor",
    "log_clipping",
    "make_parent_dir",
    "add_suffix"
  ],
  "EPS": [],
  "TARGET_LEVEL_LOWER": [],
  "TARGET_LEVEL_UPPER": [],
  "SoundInfo": {
    "has_sound_meta": [
      "self"
    ],
    "to_condition_attributes": [
      "self"
    ],
    "attribute_getter": [
      "attribute"
    ],
    "from_dict": [
      "cls",
      "dictionary",
      "fields_required"
    ]
  },
  "SoundDataset": {
    "__init__": [
      "self"
    ],
    "_get_info_path": [
      "self",
      "path"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "collater": [
      "self",
      "samples"
    ]
  },
  "rms_f": [
    "x"
  ],
  "normalize": [
    "audio",
    "target_level"
  ],
  "is_clipped": [
    "audio",
    "clipping_threshold"
  ],
  "mix_pair": [
    "src",
    "dst",
    "min_overlap"
  ],
  "snr_mixer": [
    "clean",
    "noise",
    "snr",
    "min_overlap",
    "target_level",
    "clipping_threshold"
  ],
  "snr_mix": [
    "src",
    "dst",
    "snr_low",
    "snr_high",
    "min_overlap"
  ],
  "mix_text": [
    "src_text",
    "dst_text"
  ],
  "mix_samples": [
    "wavs",
    "infos",
    "aug_p",
    "mix_p",
    "snr_low",
    "snr_high",
    "min_overlap"
  ],
  "DEFAULT_SIZE": [],
  "MODE": [],
  "PathInZip": {
    "INFO_PATH_SEP": [],
    "__init__": [
      "self",
      "path"
    ],
    "from_paths": [
      "cls",
      "zip_path",
      "file_path"
    ],
    "__str__": [
      "self"
    ]
  },
  "_open_zip": [
    "path",
    "mode"
  ],
  "_cached_open_zip": [],
  "set_zip_cache_size": [
    "max_size"
  ],
  "open_file_in_zip": [
    "path_in_zip",
    "mode"
  ],
  "BaseInfo": {
    "_dict2fields": [
      "cls",
      "dictionary"
    ],
    "from_dict": [
      "cls",
      "dictionary"
    ],
    "to_dict": [
      "self"
    ]
  },
  "AudioMeta": {
    "from_dict": [
      "cls",
      "dictionary"
    ],
    "to_dict": [
      "self"
    ]
  },
  "SegmentInfo": {},
  "DEFAULT_EXTS": [],
  "_get_audio_meta": [
    "file_path",
    "minimal"
  ],
  "_resolve_audio_meta": [
    "m",
    "fast"
  ],
  "find_audio_files": [
    "path",
    "exts",
    "resolve",
    "minimal",
    "progress",
    "workers"
  ],
  "load_audio_meta": [
    "path",
    "resolve",
    "fast"
  ],
  "save_audio_meta": [
    "path",
    "meta"
  ],
  "AudioDataset": {
    "__init__": [
      "self",
      "meta",
      "segment_duration",
      "shuffle",
      "num_samples",
      "sample_rate",
      "channels",
      "pad",
      "sample_on_duration",
      "sample_on_weight",
      "min_segment_ratio",
      "max_read_retry",
      "return_info",
      "min_audio_duration",
      "max_audio_duration",
      "shuffle_seed",
      "load_wav",
      "permutation_on_files"
    ],
    "start_epoch": [
      "self",
      "epoch"
    ],
    "__len__": [
      "self"
    ],
    "_get_sampling_probabilities": [
      "self",
      "normalized"
    ],
    "_get_file_permutation": [
      "num_files",
      "permutation_index",
      "base_seed"
    ],
    "sample_file": [
      "self",
      "index",
      "rng"
    ],
    "_audio_read": [
      "self",
      "path",
      "seek_time",
      "duration"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "collater": [
      "self",
      "samples"
    ],
    "_filter_duration": [
      "self",
      "meta"
    ],
    "from_meta": [
      "cls",
      "root"
    ],
    "from_path": [
      "cls",
      "root",
      "minimal_meta",
      "exts"
    ]
  },
  "_clusterify_meta": [
    "meta"
  ],
  "clusterify_all_meta": [
    "meta"
  ],
  "AudioInfo": {
    "to_condition_attributes": [
      "self"
    ]
  },
  "InfoAudioDataset": {
    "__init__": [
      "self",
      "meta"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "get_keyword_or_keyword_list": [
    "value"
  ],
  "get_string": [
    "value"
  ],
  "get_keyword": [
    "value"
  ],
  "get_keyword_list": [
    "values"
  ],
  "convert_audio_channels": [
    "wav",
    "channels"
  ],
  "convert_audio": [
    "wav",
    "from_rate",
    "to_rate",
    "to_channels"
  ],
  "normalize_loudness": [
    "wav",
    "sample_rate",
    "loudness_headroom_db",
    "loudness_compressor",
    "energy_floor"
  ],
  "_clip_wav": [
    "wav",
    "log_clipping",
    "stem_name"
  ],
  "normalize_audio": [
    "wav",
    "normalize",
    "strategy",
    "peak_clip_headroom_db",
    "rms_headroom_db",
    "loudness_headroom_db",
    "loudness_compressor",
    "log_clipping",
    "sample_rate",
    "stem_name"
  ],
  "f32_pcm": [
    "wav"
  ],
  "i16_pcm": [
    "wav"
  ],
  "MusicInfo": {
    "has_music_meta": [
      "self"
    ],
    "to_condition_attributes": [
      "self"
    ],
    "attribute_getter": [
      "attribute"
    ],
    "from_dict": [
      "cls",
      "dictionary",
      "fields_required"
    ]
  },
  "augment_music_info_description": [
    "music_info",
    "merge_text_p",
    "drop_desc_p",
    "drop_other_p"
  ],
  "Paraphraser": {
    "__init__": [
      "self",
      "paraphrase_source",
      "paraphrase_p"
    ],
    "sample_paraphrase": [
      "self",
      "audio_path",
      "description"
    ]
  },
  "MusicDataset": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "index"
    ]
  },
  "get_musical_key": [
    "value"
  ],
  "get_bpm": [
    "value"
  ],
  "is_fsdp_used": [],
  "is_sharded_tensor": [
    "x"
  ],
  "switch_to_full_state_dict": [
    "models"
  ],
  "wrap_with_fsdp": [
    "cfg",
    "model",
    "block_classes"
  ],
  "purge_fsdp": [
    "model"
  ],
  "_FSDPFixStateDict": {
    "_name_without_fsdp_prefix": [
      "name"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state"
    ]
  },
  "_hook_fixed": [],
  "_fix_post_backward_hook": [],
  "PolynomialDecayLRScheduler": {
    "__init__": [
      "self",
      "optimizer",
      "warmup_steps",
      "total_steps",
      "end_lr",
      "zero_lr_warmup_steps",
      "power"
    ],
    "_get_sched_lr": [
      "self",
      "lr",
      "step"
    ],
    "get_lr": [
      "self"
    ]
  },
  "CosineLRScheduler": {
    "__init__": [
      "self",
      "optimizer",
      "total_steps",
      "warmup_steps",
      "lr_min_ratio",
      "cycle_length"
    ],
    "_get_sched_lr": [
      "self",
      "lr",
      "step"
    ],
    "get_lr": [
      "self"
    ]
  },
  "_params_t": [],
  "to_real": [
    "x"
  ],
  "DAdaptAdam": {
    "__init__": [
      "self",
      "params",
      "lr",
      "betas",
      "eps",
      "weight_decay",
      "log_every",
      "decouple",
      "d0",
      "growth_rate"
    ],
    "supports_memory_efficient_fp16": [
      "self"
    ],
    "supports_flat_params": [
      "self"
    ],
    "step": [
      "self",
      "closure"
    ]
  },
  "_get_all_non_persistent_buffers_set": [
    "module",
    "root"
  ],
  "_get_named_tensors": [
    "module"
  ],
  "ModuleDictEMA": {
    "__init__": [
      "self",
      "module_dict",
      "decay",
      "unbias",
      "device"
    ],
    "_init": [
      "self"
    ],
    "step": [
      "self"
    ],
    "state_dict": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state"
    ]
  },
  "LinearWarmupLRScheduler": {
    "__init__": [
      "self",
      "optimizer",
      "warmup_steps",
      "warmup_init_lr"
    ],
    "_get_sched_lr": [
      "self",
      "lr",
      "step"
    ],
    "get_lr": [
      "self"
    ]
  },
  "InverseSquareRootLRScheduler": {
    "__init__": [
      "self",
      "optimizer",
      "warmup_steps",
      "warmup_init_lr"
    ],
    "_get_sched_lr": [
      "self",
      "lr",
      "step"
    ],
    "get_lr": [
      "self"
    ]
  },
  "exists": [
    "val"
  ],
  "default": [
    "val",
    "d"
  ],
  "l2norm": [
    "t"
  ],
  "ema_inplace": [
    "moving_avg",
    "new",
    "decay"
  ],
  "laplace_smoothing": [
    "x",
    "n_categories",
    "epsilon"
  ],
  "uniform_init": [],
  "sample_vectors": [
    "samples",
    "num"
  ],
  "kmeans": [
    "samples",
    "num_clusters",
    "num_iters"
  ],
  "orthogonal_loss_fn": [
    "t"
  ],
  "EuclideanCodebook": {
    "__init__": [
      "self",
      "dim",
      "codebook_size",
      "kmeans_init",
      "kmeans_iters",
      "decay",
      "epsilon",
      "threshold_ema_dead_code"
    ],
    "init_embed_": [
      "self",
      "data"
    ],
    "replace_": [
      "self",
      "samples",
      "mask"
    ],
    "expire_codes_": [
      "self",
      "batch_samples"
    ],
    "preprocess": [
      "self",
      "x"
    ],
    "quantize": [
      "self",
      "x"
    ],
    "postprocess_emb": [
      "self",
      "embed_ind",
      "shape"
    ],
    "dequantize": [
      "self",
      "embed_ind"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "embed_ind"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "VectorQuantization": {
    "__init__": [
      "self",
      "dim",
      "codebook_size",
      "codebook_dim",
      "decay",
      "epsilon",
      "kmeans_init",
      "kmeans_iters",
      "threshold_ema_dead_code",
      "channels_last",
      "commitment_weight",
      "orthogonal_reg_weight",
      "orthogonal_reg_active_codes_only",
      "orthogonal_reg_max_codes"
    ],
    "codebook": [
      "self"
    ],
    "inited": [
      "self"
    ],
    "_preprocess": [
      "self",
      "x"
    ],
    "_postprocess": [
      "self",
      "quantize"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "embed_ind"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ResidualVectorQuantization": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "n_q"
    ],
    "encode": [
      "self",
      "x",
      "n_q"
    ],
    "decode": [
      "self",
      "q_indices"
    ]
  },
  "QuantizedResult": {},
  "BaseQuantizer": {
    "forward": [
      "self",
      "x",
      "frame_rate"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes"
    ],
    "total_codebooks": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ]
  },
  "DummyQuantizer": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "frame_rate"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes"
    ],
    "total_codebooks": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ]
  },
  "ResidualVectorQuantizer": {
    "__init__": [
      "self",
      "dimension",
      "n_q",
      "q_dropout",
      "bins",
      "decay",
      "kmeans_init",
      "kmeans_iters",
      "threshold_ema_dead_code",
      "orthogonal_reg_weight",
      "orthogonal_reg_active_codes_only",
      "orthogonal_reg_max_codes"
    ],
    "forward": [
      "self",
      "x",
      "frame_rate"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes"
    ],
    "total_codebooks": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ]
  },
  "AudioGenSolver": {},
  "DatasetType": {
    "AUDIO": [],
    "MUSIC": [],
    "SOUND": []
  },
  "get_optim_parameter_groups": [
    "model"
  ],
  "get_optimizer": [
    "params",
    "cfg"
  ],
  "get_lr_scheduler": [
    "optimizer",
    "cfg",
    "total_updates"
  ],
  "get_ema": [
    "module_dict",
    "cfg"
  ],
  "get_loss": [
    "loss_name",
    "cfg"
  ],
  "get_balancer": [
    "loss_weights",
    "cfg"
  ],
  "get_adversary": [
    "name",
    "cfg"
  ],
  "get_adversarial_losses": [
    "cfg"
  ],
  "get_visqol": [
    "cfg"
  ],
  "get_fad": [
    "cfg"
  ],
  "get_kldiv": [
    "cfg"
  ],
  "get_text_consistency": [
    "cfg"
  ],
  "get_chroma_cosine_similarity": [
    "cfg"
  ],
  "get_audio_datasets": [
    "cfg",
    "dataset_type"
  ],
  "StandardSolver": {
    "__init__": [
      "self",
      "cfg"
    ],
    "autocast": [
      "self"
    ],
    "_get_state_source": [
      "self",
      "name"
    ],
    "best_metric_name": [
      "self"
    ],
    "register_best_state": [
      "self"
    ],
    "register_ema": [
      "self"
    ],
    "wrap_with_fsdp": [
      "self",
      "model"
    ],
    "update_best_state_from_stage": [
      "self",
      "stage_name"
    ],
    "_load_new_state_dict": [
      "self",
      "state_dict"
    ],
    "swap_best_state": [
      "self"
    ],
    "swap_ema_state": [
      "self"
    ],
    "is_training": [
      "self"
    ],
    "log_model_summary": [
      "self",
      "model"
    ],
    "build_model": [
      "self"
    ],
    "initialize_ema": [
      "self"
    ],
    "build_dataloaders": [
      "self"
    ],
    "show": [
      "self"
    ],
    "log_updates": [
      "self"
    ],
    "checkpoint_path": [
      "self"
    ],
    "epoch_checkpoint_path": [
      "self",
      "epoch"
    ],
    "checkpoint_path_with_name": [
      "self",
      "name"
    ],
    "save_checkpoints": [
      "self"
    ],
    "load_from_pretrained": [
      "self",
      "name"
    ],
    "load_checkpoints": [
      "self",
      "load_best",
      "ignore_state_keys"
    ],
    "restore": [
      "self",
      "load_best",
      "replay_metrics",
      "ignore_state_keys"
    ],
    "commit": [
      "self",
      "save_checkpoints"
    ],
    "run_epoch": [
      "self"
    ],
    "run": [
      "self"
    ],
    "should_stop_training": [
      "self"
    ],
    "should_run_stage": [
      "self",
      "stage_name"
    ],
    "run_step": [
      "self",
      "idx",
      "batch",
      "metrics"
    ],
    "common_train_valid": [
      "self",
      "dataset_split"
    ],
    "train": [
      "self"
    ],
    "valid": [
      "self"
    ],
    "evaluate": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "run_one_stage": [
      "self",
      "stage_name"
    ],
    "get_eval_solver_from_sig": [
      "sig",
      "dtype",
      "device",
      "autocast",
      "batch_size",
      "override_cfg"
    ]
  },
  "CompressionSolver": {
    "__init__": [
      "self",
      "cfg"
    ],
    "best_metric_name": [
      "self"
    ],
    "build_model": [
      "self"
    ],
    "build_dataloaders": [
      "self"
    ],
    "show": [
      "self"
    ],
    "run_step": [
      "self",
      "idx",
      "batch",
      "metrics"
    ],
    "run_epoch": [
      "self"
    ],
    "evaluate": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "load_from_pretrained": [
      "self",
      "name"
    ],
    "model_from_checkpoint": [
      "checkpoint_path",
      "device"
    ],
    "wrapped_model_from_checkpoint": [
      "cfg",
      "checkpoint_path",
      "device"
    ]
  },
  "evaluate_audio_reconstruction": [
    "y_pred",
    "y",
    "cfg"
  ],
  "MusicGenSolver": {
    "__init__": [
      "self",
      "cfg"
    ],
    "get_eval_solver_from_sig": [
      "sig",
      "dtype",
      "device",
      "autocast",
      "batch_size",
      "override_cfg"
    ],
    "get_formatter": [
      "self",
      "stage_name"
    ],
    "best_metric_name": [
      "self"
    ],
    "build_model": [
      "self"
    ],
    "build_dataloaders": [
      "self"
    ],
    "show": [
      "self"
    ],
    "load_state_dict": [
      "self",
      "state"
    ],
    "load_from_pretrained": [
      "self",
      "name"
    ],
    "_compute_cross_entropy": [
      "self",
      "logits",
      "targets",
      "mask"
    ],
    "_prepare_tokens_and_attributes": [
      "self",
      "batch",
      "check_synchronization_points"
    ],
    "run_step": [
      "self",
      "idx",
      "batch",
      "metrics"
    ],
    "run_generate_step": [
      "self",
      "batch",
      "gen_duration",
      "prompt_duration",
      "remove_prompt"
    ],
    "generate_audio": [
      "self"
    ],
    "generate": [
      "self"
    ],
    "run_epoch": [
      "self"
    ],
    "train": [
      "self"
    ],
    "evaluate_audio_generation": [
      "self"
    ],
    "evaluate": [
      "self"
    ]
  },
  "MagnetSolver": {
    "__init__": [
      "self",
      "cfg"
    ],
    "build_model": [
      "self"
    ],
    "_calc_mean_maskrate_to_u_LUT": [
      "self",
      "T"
    ],
    "_non_spans_mask": [
      "self",
      "mask_probs",
      "B",
      "T",
      "device"
    ],
    "_spans_mask": [
      "self",
      "mask_probs",
      "B",
      "T",
      "device"
    ],
    "_get_mask": [
      "self",
      "mask_probs",
      "B",
      "T",
      "device"
    ],
    "_compute_cross_entropy_magnet": [
      "self",
      "logits",
      "targets",
      "mask",
      "stage"
    ],
    "run_step": [
      "self",
      "idx",
      "batch",
      "metrics"
    ]
  },
  "AudioMagnetSolver": {},
  "PerStageMetrics": {
    "__init__": [
      "self",
      "num_steps",
      "num_stages"
    ],
    "__call__": [
      "self",
      "losses",
      "step"
    ]
  },
  "DataProcess": {
    "__init__": [
      "self",
      "initial_sr",
      "target_sr",
      "use_resampling",
      "use_filter",
      "n_bands",
      "idx_band",
      "device",
      "cutoffs",
      "boost"
    ],
    "process_data": [
      "self",
      "x",
      "metric"
    ],
    "inverse_process": [
      "self",
      "x"
    ]
  },
  "DiffusionSolver": {
    "__init__": [
      "self",
      "cfg"
    ],
    "best_metric_name": [
      "self"
    ],
    "get_condition": [
      "self",
      "wav"
    ],
    "build_model": [
      "self"
    ],
    "build_dataloaders": [
      "self"
    ],
    "show": [
      "self"
    ],
    "run_step": [
      "self",
      "idx",
      "batch",
      "metrics"
    ],
    "run_epoch": [
      "self"
    ],
    "evaluate": [
      "self"
    ],
    "regenerate": [
      "self",
      "wav",
      "step_list"
    ],
    "generate": [
      "self"
    ]
  },
  "AudioGen": {
    "__init__": [
      "self",
      "name",
      "compression_model",
      "lm",
      "max_duration"
    ],
    "get_pretrained": [
      "name",
      "device"
    ],
    "set_generation_params": [
      "self",
      "use_sampling",
      "top_k",
      "top_p",
      "temperature",
      "duration",
      "cfg_coef",
      "two_step_cfg",
      "extend_stride"
    ]
  },
  "CompressionModel": {
    "forward": [
      "self",
      "x"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes",
      "scale"
    ],
    "decode_latent": [
      "self",
      "codes"
    ],
    "channels": [
      "self"
    ],
    "frame_rate": [
      "self"
    ],
    "sample_rate": [
      "self"
    ],
    "cardinality": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "total_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ],
    "get_pretrained": [
      "name",
      "device"
    ]
  },
  "EncodecModel": {
    "__init__": [
      "self",
      "encoder",
      "decoder",
      "quantizer",
      "frame_rate",
      "sample_rate",
      "channels",
      "causal",
      "renormalize"
    ],
    "total_codebooks": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ],
    "cardinality": [
      "self"
    ],
    "preprocess": [
      "self",
      "x"
    ],
    "postprocess": [
      "self",
      "x",
      "scale"
    ],
    "forward": [
      "self",
      "x"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes",
      "scale"
    ],
    "decode_latent": [
      "self",
      "codes"
    ]
  },
  "DAC": {
    "__init__": [
      "self",
      "model_type"
    ],
    "forward": [
      "self",
      "x"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes",
      "scale"
    ],
    "decode_latent": [
      "self",
      "codes"
    ],
    "channels": [
      "self"
    ],
    "frame_rate": [
      "self"
    ],
    "sample_rate": [
      "self"
    ],
    "cardinality": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "total_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ]
  },
  "HFEncodecCompressionModel": {
    "__init__": [
      "self",
      "model"
    ],
    "forward": [
      "self",
      "x"
    ],
    "encode": [
      "self",
      "x"
    ],
    "decode": [
      "self",
      "codes",
      "scale"
    ],
    "decode_latent": [
      "self",
      "codes"
    ],
    "channels": [
      "self"
    ],
    "frame_rate": [
      "self"
    ],
    "sample_rate": [
      "self"
    ],
    "cardinality": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "total_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ]
  },
  "InterleaveStereoCompressionModel": {
    "__init__": [
      "self",
      "model",
      "per_timestep"
    ],
    "total_codebooks": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "set_num_codebooks": [
      "self",
      "n"
    ],
    "num_virtual_steps": [
      "self"
    ],
    "frame_rate": [
      "self"
    ],
    "sample_rate": [
      "self"
    ],
    "channels": [
      "self"
    ],
    "cardinality": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ],
    "encode": [
      "self",
      "x"
    ],
    "get_left_right_codes": [
      "self",
      "codes"
    ],
    "decode": [
      "self",
      "codes",
      "scale"
    ],
    "decode_latent": [
      "self",
      "codes"
    ]
  },
  "get_quantizer": [
    "quantizer",
    "cfg",
    "dimension"
  ],
  "get_encodec_autoencoder": [
    "encoder_name",
    "cfg"
  ],
  "get_compression_model": [
    "cfg"
  ],
  "get_lm_model": [
    "cfg"
  ],
  "get_conditioner_provider": [
    "output_dim",
    "cfg"
  ],
  "get_condition_fuser": [
    "cfg"
  ],
  "get_codebooks_pattern_provider": [
    "n_q",
    "cfg"
  ],
  "get_debug_compression_model": [
    "device",
    "sample_rate"
  ],
  "get_diffusion_model": [
    "cfg"
  ],
  "get_processor": [
    "cfg",
    "sample_rate"
  ],
  "get_debug_lm_model": [
    "device"
  ],
  "get_wrapped_compression_model": [
    "compression_model",
    "cfg"
  ],
  "BaseGenModel": {
    "__init__": [
      "self",
      "name",
      "compression_model",
      "lm",
      "max_duration"
    ],
    "frame_rate": [
      "self"
    ],
    "sample_rate": [
      "self"
    ],
    "audio_channels": [
      "self"
    ],
    "set_custom_progress_callback": [
      "self",
      "progress_callback"
    ],
    "set_generation_params": [
      "self"
    ],
    "get_pretrained": [
      "name",
      "device"
    ],
    "_prepare_tokens_and_attributes": [
      "self",
      "descriptions",
      "prompt"
    ],
    "generate_unconditional": [
      "self",
      "num_samples",
      "progress",
      "return_tokens"
    ],
    "generate": [
      "self",
      "descriptions",
      "progress",
      "return_tokens"
    ],
    "generate_continuation": [
      "self",
      "prompt",
      "prompt_sample_rate",
      "descriptions",
      "progress",
      "return_tokens"
    ],
    "_generate_tokens": [
      "self",
      "attributes",
      "prompt_tokens",
      "progress"
    ],
    "generate_audio": [
      "self",
      "gen_tokens"
    ]
  },
  "Output": {},
  "get_model": [
    "cfg",
    "channels",
    "side",
    "num_steps"
  ],
  "ResBlock": {
    "__init__": [
      "self",
      "channels",
      "kernel",
      "norm_groups",
      "dilation",
      "activation",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DecoderLayer": {
    "__init__": [
      "self",
      "chin",
      "chout",
      "kernel",
      "stride",
      "norm_groups",
      "res_blocks",
      "activation",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "EncoderLayer": {
    "__init__": [
      "self",
      "chin",
      "chout",
      "kernel",
      "stride",
      "norm_groups",
      "res_blocks",
      "activation",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "BLSTM": {
    "__init__": [
      "self",
      "dim",
      "layers"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "DiffusionUnet": {
    "__init__": [
      "self",
      "chin",
      "hidden",
      "depth",
      "growth",
      "max_channels",
      "num_steps",
      "emb_all_layers",
      "cross_attention",
      "bilstm",
      "transformer",
      "codec_dim"
    ],
    "forward": [
      "self",
      "x",
      "step",
      "condition"
    ]
  },
  "MelodyList": [],
  "MelodyType": [],
  "_HF_MODEL_CHECKPOINTS_MAP": [],
  "MusicGen": {
    "__init__": [
      "self",
      "name",
      "compression_model",
      "lm",
      "max_duration"
    ],
    "get_pretrained": [
      "name",
      "device"
    ],
    "set_generation_params": [
      "self",
      "use_sampling",
      "top_k",
      "top_p",
      "temperature",
      "duration",
      "cfg_coef",
      "two_step_cfg",
      "extend_stride"
    ],
    "generate_with_chroma": [
      "self",
      "descriptions",
      "melody_wavs",
      "melody_sample_rate",
      "progress",
      "return_tokens"
    ],
    "_prepare_tokens_and_attributes": [
      "self",
      "descriptions",
      "prompt",
      "melody_wavs"
    ],
    "_generate_tokens": [
      "self",
      "attributes",
      "prompt_tokens",
      "progress"
    ]
  },
  "ConditionTensors": [],
  "CFGConditions": [],
  "MagnetLMModel": {
    "__init__": [
      "self",
      "subcodes_context",
      "compression_model_framerate",
      "segment_duration",
      "span_len"
    ],
    "restricted_context_attn_mask": [
      "self",
      "seq_len",
      "device",
      "dtype"
    ],
    "_stage_attn_mask": [
      "self",
      "stage",
      "seq_len",
      "num_heads",
      "device",
      "dtype"
    ],
    "_build_attn_masks": [
      "self",
      "compression_model_framerate",
      "segment_duration",
      "num_heads",
      "device",
      "dtype"
    ],
    "generate": [
      "self",
      "prompt",
      "conditions",
      "num_samples",
      "max_gen_len",
      "use_sampling",
      "temp",
      "top_k",
      "top_p",
      "cfg_coef",
      "two_step_cfg",
      "remove_prompts",
      "check",
      "callback"
    ],
    "_generate_magnet": [
      "self",
      "prompt",
      "conditions",
      "num_samples",
      "max_gen_len",
      "use_sampling",
      "temp",
      "top_k",
      "top_p",
      "callback",
      "max_cfg_coef",
      "min_cfg_coef",
      "decoding_steps",
      "anneal_temp",
      "span_scoring",
      "span_arrangement"
    ],
    "_generate_stage": [
      "self",
      "gen_sequence",
      "condition_tensors",
      "stage",
      "device",
      "prompt_length",
      "prompt",
      "use_sampling",
      "temp",
      "max_cfg_coef",
      "min_cfg_coef",
      "top_k",
      "top_p",
      "timesteps",
      "anneal_temp",
      "span_scoring",
      "span_arrangement",
      "curr_step",
      "total_steps",
      "callback"
    ],
    "_construct_spans_mask": [
      "self",
      "span_starts",
      "T",
      "device"
    ],
    "_least_probable_span_masking": [
      "self",
      "scores",
      "num_masked_trg"
    ]
  },
  "DiffusionProcess": {
    "__init__": [
      "self",
      "model",
      "noise_schedule"
    ],
    "generate": [
      "self",
      "condition",
      "initial_noise",
      "step_list"
    ]
  },
  "MultiBandDiffusion": {
    "__init__": [
      "self",
      "DPs",
      "codec_model"
    ],
    "sample_rate": [
      "self"
    ],
    "get_mbd_musicgen": [
      "device"
    ],
    "get_mbd_24khz": [
      "bw",
      "device",
      "n_q"
    ],
    "get_condition": [
      "self",
      "wav",
      "sample_rate"
    ],
    "get_emb": [
      "self",
      "codes"
    ],
    "generate": [
      "self",
      "emb",
      "size",
      "step_list"
    ],
    "re_eq": [
      "self",
      "wav",
      "ref",
      "n_bands",
      "strictness"
    ],
    "regenerate": [
      "self",
      "wav",
      "sample_rate"
    ],
    "tokens_to_wav": [
      "self",
      "tokens",
      "n_bands"
    ]
  },
  "MAGNeT": {
    "__init__": [
      "self"
    ],
    "get_pretrained": [
      "name",
      "device"
    ],
    "set_generation_params": [
      "self",
      "use_sampling",
      "top_k",
      "top_p",
      "temperature",
      "max_cfg_coef",
      "min_cfg_coef",
      "decoding_steps",
      "span_arrangement"
    ]
  },
  "get_audiocraft_cache_dir": [],
  "_get_state_dict": [
    "file_or_url_or_id",
    "filename",
    "device",
    "cache_dir"
  ],
  "load_compression_model_ckpt": [
    "file_or_url_or_id",
    "cache_dir"
  ],
  "load_compression_model": [
    "file_or_url_or_id",
    "device",
    "cache_dir"
  ],
  "load_lm_model_ckpt": [
    "file_or_url_or_id",
    "cache_dir"
  ],
  "_delete_param": [
    "cfg",
    "full_name"
  ],
  "load_lm_model": [
    "file_or_url_or_id",
    "device",
    "cache_dir"
  ],
  "load_lm_model_magnet": [
    "file_or_url_or_id",
    "compression_model_frame_rate",
    "device",
    "cache_dir"
  ],
  "load_mbd_ckpt": [
    "file_or_url_or_id",
    "filename",
    "cache_dir"
  ],
  "load_diffusion_models": [
    "file_or_url_or_id",
    "device",
    "filename",
    "cache_dir"
  ],
  "get_init_fn": [
    "method",
    "input_dim",
    "init_depth"
  ],
  "init_layer": [
    "m",
    "method",
    "init_depth",
    "zero_bias_init"
  ],
  "ScaledEmbedding": {
    "__init__": [
      "self"
    ],
    "make_optim_group": [
      "self"
    ]
  },
  "LMOutput": {},
  "LMModel": {
    "__init__": [
      "self",
      "pattern_provider",
      "condition_provider",
      "fuser",
      "n_q",
      "card",
      "dim",
      "num_heads",
      "hidden_scale",
      "norm",
      "norm_first",
      "emb_lr",
      "bias_proj",
      "weight_init",
      "depthwise_init",
      "zero_bias_init",
      "cfg_dropout",
      "cfg_coef",
      "attribute_dropout",
      "two_step_cfg"
    ],
    "_init_weights": [
      "self",
      "weight_init",
      "depthwise_init",
      "zero_bias_init"
    ],
    "special_token_id": [
      "self"
    ],
    "num_codebooks": [
      "self"
    ],
    "forward": [
      "self",
      "sequence",
      "conditions",
      "condition_tensors",
      "stage"
    ],
    "compute_predictions": [
      "self",
      "codes",
      "conditions",
      "condition_tensors",
      "stage",
      "keep_only_valid_steps"
    ],
    "_sample_next_token": [
      "self",
      "sequence",
      "cfg_conditions",
      "unconditional_state",
      "use_sampling",
      "temp",
      "top_k",
      "top_p",
      "cfg_coef",
      "two_step_cfg"
    ],
    "generate": [
      "self",
      "prompt",
      "conditions",
      "num_samples",
      "max_gen_len",
      "use_sampling",
      "temp",
      "top_k",
      "top_p",
      "cfg_coef",
      "two_step_cfg",
      "remove_prompts",
      "check",
      "callback"
    ]
  },
  "TextCondition": [],
  "ConditionType": [],
  "WavCondition": {},
  "JointEmbedCondition": {},
  "ConditioningAttributes": {
    "__getitem__": [
      "self",
      "item"
    ],
    "text_attributes": [
      "self"
    ],
    "wav_attributes": [
      "self"
    ],
    "joint_embed_attributes": [
      "self"
    ],
    "attributes": [
      "self"
    ],
    "to_flat_dict": [
      "self"
    ],
    "from_flat_dict": [
      "cls",
      "x"
    ]
  },
  "SegmentWithAttributes": {
    "to_condition_attributes": [
      "self"
    ]
  },
  "nullify_condition": [
    "condition",
    "dim"
  ],
  "nullify_wav": [
    "cond"
  ],
  "nullify_joint_embed": [
    "embed"
  ],
  "Tokenizer": {
    "__call__": [
      "self",
      "texts"
    ]
  },
  "WhiteSpaceTokenizer": {
    "PUNCTUATION": [],
    "__init__": [
      "self",
      "n_bins",
      "pad_idx",
      "language",
      "lemma",
      "stopwords"
    ],
    "__call__": [
      "self",
      "texts",
      "return_text"
    ]
  },
  "NoopTokenizer": {
    "__init__": [
      "self",
      "n_bins",
      "pad_idx"
    ],
    "__call__": [
      "self",
      "texts"
    ]
  },
  "BaseConditioner": {
    "__init__": [
      "self",
      "dim",
      "output_dim"
    ],
    "tokenize": [
      "self"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "TextConditioner": {},
  "LUTConditioner": {
    "__init__": [
      "self",
      "n_bins",
      "dim",
      "output_dim",
      "tokenizer",
      "pad_idx"
    ],
    "tokenize": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "T5Conditioner": {
    "MODELS": [],
    "MODELS_DIMS": [],
    "__init__": [
      "self",
      "name",
      "output_dim",
      "finetune",
      "device",
      "autocast_dtype",
      "word_dropout",
      "normalize_text"
    ],
    "tokenize": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "WaveformConditioner": {
    "__init__": [
      "self",
      "dim",
      "output_dim",
      "device"
    ],
    "tokenize": [
      "self",
      "x"
    ],
    "_get_wav_embedding": [
      "self",
      "x"
    ],
    "_downsampling_factor": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ChromaStemConditioner": {
    "__init__": [
      "self",
      "output_dim",
      "sample_rate",
      "n_chroma",
      "radix2_exp",
      "duration",
      "match_len_on_eval",
      "eval_wavs",
      "n_eval_wavs",
      "cache_path",
      "device"
    ],
    "_downsampling_factor": [
      "self"
    ],
    "_load_eval_wavs": [
      "self",
      "path",
      "num_samples"
    ],
    "reset_eval_wavs": [
      "self",
      "eval_wavs"
    ],
    "has_eval_wavs": [
      "self"
    ],
    "_sample_eval_wavs": [
      "self",
      "num_samples"
    ],
    "_get_chroma_len": [
      "self"
    ],
    "_get_stemmed_wav": [
      "self",
      "wav",
      "sample_rate"
    ],
    "_extract_chroma": [
      "self",
      "wav"
    ],
    "_compute_wav_embedding": [
      "self",
      "wav",
      "sample_rate"
    ],
    "_get_full_chroma_for_cache": [
      "self",
      "path",
      "x",
      "idx"
    ],
    "_extract_chroma_chunk": [
      "self",
      "full_chroma",
      "x",
      "idx"
    ],
    "_get_wav_embedding": [
      "self",
      "x"
    ],
    "tokenize": [
      "self",
      "x"
    ]
  },
  "JointEmbeddingConditioner": {
    "__init__": [
      "self",
      "dim",
      "output_dim",
      "device",
      "attribute",
      "autocast_dtype",
      "quantize",
      "n_q",
      "bins"
    ],
    "_get_embed": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ],
    "tokenize": [
      "self",
      "x"
    ]
  },
  "CLAPEmbeddingConditioner": {
    "__init__": [
      "self",
      "dim",
      "output_dim",
      "device",
      "attribute",
      "quantize",
      "n_q",
      "bins",
      "checkpoint",
      "model_arch",
      "enable_fusion",
      "sample_rate",
      "max_audio_length",
      "audio_stride",
      "normalize",
      "text_p",
      "batch_size",
      "autocast_dtype",
      "cache_path"
    ],
    "_tokenizer": [
      "self",
      "texts"
    ],
    "_compute_text_embedding": [
      "self",
      "text"
    ],
    "_get_text_embedding_for_cache": [
      "self",
      "path",
      "x",
      "idx"
    ],
    "_preprocess_wav": [
      "self",
      "wav",
      "length",
      "sample_rates"
    ],
    "_compute_wav_embedding": [
      "self",
      "wav",
      "length",
      "sample_rates",
      "reduce_mean"
    ],
    "_get_wav_embedding_for_cache": [
      "self",
      "path",
      "x",
      "idx"
    ],
    "_extract_wav_embedding_chunk": [
      "self",
      "full_embed",
      "x",
      "idx"
    ],
    "_get_text_embedding": [
      "self",
      "x"
    ],
    "_get_wav_embedding": [
      "self",
      "x"
    ],
    "tokenize": [
      "self",
      "x"
    ],
    "_get_embed": [
      "self",
      "x"
    ]
  },
  "dropout_condition": [
    "sample",
    "condition_type",
    "condition"
  ],
  "DropoutModule": {
    "__init__": [
      "self",
      "seed"
    ]
  },
  "AttributeDropout": {
    "__init__": [
      "self",
      "p",
      "active_on_eval",
      "seed"
    ],
    "forward": [
      "self",
      "samples"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ClassifierFreeGuidanceDropout": {
    "__init__": [
      "self",
      "p",
      "seed"
    ],
    "forward": [
      "self",
      "samples"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ConditioningProvider": {
    "__init__": [
      "self",
      "conditioners",
      "device"
    ],
    "joint_embed_conditions": [
      "self"
    ],
    "has_joint_embed_conditions": [
      "self"
    ],
    "text_conditions": [
      "self"
    ],
    "wav_conditions": [
      "self"
    ],
    "has_wav_condition": [
      "self"
    ],
    "tokenize": [
      "self",
      "inputs"
    ],
    "forward": [
      "self",
      "tokenized"
    ],
    "_collate_text": [
      "self",
      "samples"
    ],
    "_collate_wavs": [
      "self",
      "samples"
    ],
    "_collate_joint_embeds": [
      "self",
      "samples"
    ]
  },
  "ConditionFuser": {
    "FUSING_METHODS": [],
    "__init__": [
      "self",
      "fuse2cond",
      "cross_attention_pos_emb",
      "cross_attention_pos_emb_scale"
    ],
    "forward": [
      "self",
      "input",
      "conditions"
    ]
  },
  "LayoutCoord": [],
  "PatternLayout": [],
  "Pattern": {
    "__post_init__": [
      "self"
    ],
    "_validate_layout": [
      "self"
    ],
    "num_sequence_steps": [
      "self"
    ],
    "max_delay": [
      "self"
    ],
    "valid_layout": [
      "self"
    ],
    "starts_with_special_token": [
      "self"
    ],
    "get_sequence_coords_with_timestep": [
      "self",
      "t",
      "q"
    ],
    "get_steps_with_timestep": [
      "self",
      "t",
      "q"
    ],
    "get_first_step_with_timesteps": [
      "self",
      "t",
      "q"
    ],
    "_build_pattern_sequence_scatter_indexes": [
      "self",
      "timesteps",
      "n_q",
      "keep_only_valid_steps",
      "device"
    ],
    "build_pattern_sequence": [
      "self",
      "z",
      "special_token",
      "keep_only_valid_steps"
    ],
    "_build_reverted_sequence_scatter_indexes": [
      "self",
      "sequence_steps",
      "n_q",
      "keep_only_valid_steps",
      "is_model_output",
      "device"
    ],
    "revert_pattern_sequence": [
      "self",
      "s",
      "special_token",
      "keep_only_valid_steps"
    ],
    "revert_pattern_logits": [
      "self",
      "logits",
      "special_token",
      "keep_only_valid_steps"
    ]
  },
  "CodebooksPatternProvider": {
    "__init__": [
      "self",
      "n_q",
      "cached"
    ],
    "get_pattern": [
      "self",
      "timesteps"
    ]
  },
  "DelayedPatternProvider": {
    "__init__": [
      "self",
      "n_q",
      "delays",
      "flatten_first",
      "empty_initial"
    ],
    "get_pattern": [
      "self",
      "timesteps"
    ]
  },
  "ParallelPatternProvider": {
    "__init__": [
      "self",
      "n_q",
      "empty_initial"
    ]
  },
  "UnrolledPatternProvider": {
    "FlattenedCodebook": [],
    "__init__": [
      "self",
      "n_q",
      "flattening",
      "delays"
    ],
    "_build_flattened_codebooks": [
      "self",
      "delays",
      "flattening"
    ],
    "_num_inner_steps": [
      "self"
    ],
    "num_virtual_steps": [
      "self",
      "timesteps"
    ],
    "get_pattern": [
      "self",
      "timesteps"
    ]
  },
  "CoarseFirstPattern": {
    "__init__": [
      "self",
      "n_q",
      "delays"
    ],
    "get_pattern": [
      "self",
      "timesteps"
    ]
  },
  "MusicLMPattern": {
    "__init__": [
      "self",
      "n_q",
      "group_by"
    ],
    "get_pattern": [
      "self",
      "timesteps"
    ]
  },
  "CONV_NORMALIZATIONS": [],
  "apply_parametrization_norm": [
    "module",
    "norm"
  ],
  "get_norm_module": [
    "module",
    "causal",
    "norm"
  ],
  "get_extra_padding_for_conv1d": [
    "x",
    "kernel_size",
    "stride",
    "padding_total"
  ],
  "pad_for_conv1d": [
    "x",
    "kernel_size",
    "stride",
    "padding_total"
  ],
  "pad1d": [
    "x",
    "paddings",
    "mode",
    "value"
  ],
  "unpad1d": [
    "x",
    "paddings"
  ],
  "NormConv1d": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "NormConv2d": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "NormConvTranspose1d": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "NormConvTranspose2d": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "StreamableConv1d": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "dilation",
      "groups",
      "bias",
      "causal",
      "norm",
      "norm_kwargs",
      "pad_mode"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "StreamableConvTranspose1d": {
    "__init__": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "causal",
      "norm",
      "trim_right_ratio",
      "norm_kwargs"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "CustomGLU": {
    "__init__": [
      "self",
      "activation",
      "dim"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SwiGLU": {
    "__init__": [
      "self",
      "dim"
    ]
  },
  "GeGLU": {
    "__init__": [
      "self",
      "dim"
    ]
  },
  "ReGLU": {
    "__init__": [
      "self",
      "dim"
    ]
  },
  "get_activation_fn": [
    "activation"
  ],
  "ChromaExtractor": {
    "__init__": [
      "self",
      "sample_rate",
      "n_chroma",
      "radix2_exp",
      "nfft",
      "winlen",
      "winhop",
      "argmax",
      "norm"
    ],
    "forward": [
      "self",
      "wav"
    ]
  },
  "TrainingItem": [],
  "betas_from_alpha_bar": [
    "alpha_bar"
  ],
  "SampleProcessor": {
    "project_sample": [
      "self",
      "x"
    ],
    "return_sample": [
      "self",
      "z"
    ]
  },
  "MultiBandProcessor": {
    "__init__": [
      "self",
      "n_bands",
      "sample_rate",
      "num_samples",
      "power_std"
    ],
    "mean": [
      "self"
    ],
    "std": [
      "self"
    ],
    "target_std": [
      "self"
    ],
    "project_sample": [
      "self",
      "x"
    ],
    "return_sample": [
      "self",
      "x"
    ]
  },
  "NoiseSchedule": {
    "__init__": [
      "self",
      "beta_t0",
      "beta_t1",
      "num_steps",
      "variance",
      "clip",
      "rescale",
      "device",
      "beta_exp",
      "repartition",
      "alpha_sigmoid",
      "n_bands",
      "sample_processor",
      "noise_scale"
    ],
    "get_beta": [
      "self",
      "step"
    ],
    "get_initial_noise": [
      "self",
      "x"
    ],
    "get_alpha_bar": [
      "self",
      "step"
    ],
    "get_training_item": [
      "self",
      "x",
      "tensor_step"
    ],
    "generate": [
      "self",
      "model",
      "initial",
      "condition",
      "return_list"
    ],
    "generate_subsampled": [
      "self",
      "model",
      "initial",
      "step_list",
      "condition",
      "return_list"
    ]
  },
  "set_efficient_attention_backend": [
    "backend"
  ],
  "_get_attention_time_dimension": [
    "memory_efficient"
  ],
  "_is_profiled": [],
  "create_norm_fn": [
    "norm_type",
    "dim"
  ],
  "create_sin_embedding": [
    "positions",
    "dim",
    "max_period",
    "dtype"
  ],
  "expand_repeated_kv": [
    "x",
    "n_rep",
    "memory_efficient"
  ],
  "LayerScale": {
    "__init__": [
      "self",
      "channels",
      "init",
      "channel_last",
      "device",
      "dtype"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "StreamingMultiheadAttention": {
    "__init__": [
      "self",
      "embed_dim",
      "num_heads",
      "dropout",
      "bias",
      "causal",
      "past_context",
      "custom",
      "memory_efficient",
      "attention_as_float32",
      "rope",
      "cross_attention",
      "safe_streaming",
      "qk_layer_norm",
      "kv_repeat",
      "device",
      "dtype"
    ],
    "_load_from_state_dict": [
      "self",
      "state_dict",
      "prefix"
    ],
    "_get_mask": [
      "self",
      "current_steps",
      "device",
      "dtype"
    ],
    "_complete_kv": [
      "self",
      "k",
      "v"
    ],
    "_apply_rope": [
      "self",
      "query",
      "key"
    ],
    "forward": [
      "self",
      "query",
      "key",
      "value",
      "key_padding_mask",
      "need_weights",
      "attn_mask",
      "average_attn_weights",
      "is_causal"
    ]
  },
  "StreamingTransformerLayer": {
    "__init__": [
      "self",
      "d_model",
      "num_heads",
      "dim_feedforward",
      "dropout",
      "bias_ff",
      "bias_attn",
      "causal",
      "past_context",
      "custom",
      "memory_efficient",
      "attention_as_float32",
      "qk_layer_norm",
      "qk_layer_norm_cross",
      "cross_attention",
      "layer_scale",
      "rope",
      "attention_dropout",
      "kv_repeat",
      "norm",
      "device",
      "dtype"
    ],
    "_cross_attention_block": [
      "self",
      "src",
      "cross_attention_src"
    ],
    "forward": [
      "self",
      "src",
      "src_mask",
      "src_key_padding_mask",
      "cross_attention_src"
    ]
  },
  "StreamingTransformer": {
    "__init__": [
      "self",
      "d_model",
      "num_heads",
      "num_layers",
      "dim_feedforward",
      "dropout",
      "bias_ff",
      "bias_attn",
      "causal",
      "past_context",
      "custom",
      "memory_efficient",
      "attention_as_float32",
      "cross_attention",
      "layer_scale",
      "positional_embedding",
      "max_period",
      "positional_scale",
      "xpos",
      "lr",
      "weight_decay",
      "layer_class",
      "checkpointing",
      "device",
      "dtype"
    ],
    "_apply_layer": [
      "self",
      "layer"
    ],
    "forward": [
      "self",
      "x"
    ],
    "make_optim_group": [
      "self"
    ]
  },
  "_verify_xformers_memory_efficient_compat": [],
  "_verify_xformers_internal_compat": [],
  "_is_custom": [
    "custom",
    "memory_efficient"
  ],
  "StreamableLSTM": {
    "__init__": [
      "self",
      "dimension",
      "num_layers",
      "skip"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "State": [],
  "StreamingModule": {
    "__init__": [
      "self"
    ],
    "_apply_named_streaming": [
      "self",
      "fn"
    ],
    "_set_streaming": [
      "self",
      "streaming"
    ],
    "streaming": [
      "self"
    ],
    "reset_streaming": [
      "self"
    ],
    "get_streaming_state": [
      "self"
    ],
    "set_streaming_state": [
      "self",
      "state"
    ],
    "flush": [
      "self",
      "x"
    ]
  },
  "StreamingSequential": {
    "flush": [
      "self",
      "x"
    ]
  },
  "SEANetResnetBlock": {
    "__init__": [
      "self",
      "dim",
      "kernel_sizes",
      "dilations",
      "activation",
      "activation_params",
      "norm",
      "norm_params",
      "causal",
      "pad_mode",
      "compress",
      "true_skip"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SEANetEncoder": {
    "__init__": [
      "self",
      "channels",
      "dimension",
      "n_filters",
      "n_residual_layers",
      "ratios",
      "activation",
      "activation_params",
      "norm",
      "norm_params",
      "kernel_size",
      "last_kernel_size",
      "residual_kernel_size",
      "dilation_base",
      "causal",
      "pad_mode",
      "true_skip",
      "compress",
      "lstm",
      "disable_norm_outer_blocks"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SEANetDecoder": {
    "__init__": [
      "self",
      "channels",
      "dimension",
      "n_filters",
      "n_residual_layers",
      "ratios",
      "activation",
      "activation_params",
      "final_activation",
      "final_activation_params",
      "norm",
      "norm_params",
      "kernel_size",
      "last_kernel_size",
      "residual_kernel_size",
      "dilation_base",
      "causal",
      "pad_mode",
      "true_skip",
      "compress",
      "lstm",
      "disable_norm_outer_blocks",
      "trim_right_ratio"
    ],
    "forward": [
      "self",
      "z"
    ]
  },
  "XPos": {
    "__init__": [
      "self",
      "dim",
      "smoothing",
      "base_scale",
      "device",
      "dtype"
    ],
    "get_decay": [
      "self",
      "start",
      "end"
    ]
  },
  "RotaryEmbedding": {
    "__init__": [
      "self",
      "dim",
      "max_period",
      "xpos",
      "scale",
      "device",
      "dtype"
    ],
    "get_rotation": [
      "self",
      "start",
      "end"
    ],
    "rotate": [
      "self",
      "x",
      "start",
      "time_dim",
      "invert_decay"
    ],
    "rotate_qk": [
      "self",
      "query",
      "key",
      "start",
      "time_dim"
    ]
  },
  "read_txt_files": [
    "path"
  ],
  "read_egs_files": [
    "path"
  ],
  "process_dataset": [
    "args",
    "n_shards",
    "node_index",
    "task_index"
  ],
  "SAMPLES_PER_PAGE": [],
  "MAX_RATING": [],
  "storage": [],
  "surveys": [],
  "magma_root": [],
  "app": [],
  "normalize_path": [
    "path"
  ],
  "get_full_path": [
    "normalized_path"
  ],
  "get_signature": [
    "xps"
  ],
  "ensure_logged": [
    "func"
  ],
  "login": [],
  "index": [],
  "survey": [
    "signature"
  ],
  "audio": [
    "path"
  ],
  "mean": [
    "x"
  ],
  "std": [
    "x"
  ],
  "results": [
    "signature"
  ]
}