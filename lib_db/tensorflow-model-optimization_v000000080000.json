{
  "_ensure_tf_install": [],
  "_API_MODULE": [],
  "_sparsity_api_dir": [],
  "_current_module": [],
  "__version__": [],
  "_MAJOR_VERSION": [],
  "_MINOR_VERSION": [],
  "_PATCH_VERSION": [],
  "_VERSION_SUFFIX": [],
  "DEFAULT_RTOL": [],
  "DEFAULT_ATOL": [],
  "TestData": [],
  "ParameterizedABCMeta": {},
  "BaseEncodingStageTest": {
    "is_lossless": [
      "self"
    ],
    "default_encoding_stage": [
      "self"
    ],
    "default_input": [
      "self"
    ],
    "common_asserts_for_test_data": [
      "self",
      "data"
    ],
    "test_default_encoding_stage": [
      "self"
    ],
    "test_encoding_stage_constructor_does_not_modify_graph": [
      "self"
    ],
    "test_encoding_stage_name": [
      "self"
    ],
    "test_default_input_is_tensor_with_fully_defined_shape": [
      "self"
    ],
    "test_basic_encode_decode": [
      "self"
    ],
    "test_one_to_many_encode_decode": [
      "self"
    ],
    "test_many_to_one_encode_decode": [
      "self"
    ],
    "encode_decode_x": [
      "self",
      "stage",
      "x",
      "encode_params",
      "decode_params"
    ],
    "run_one_to_many_encode_decode": [
      "self",
      "stage",
      "input_fn",
      "state"
    ],
    "run_many_to_one_encode_decode": [
      "self",
      "stage",
      "input_values",
      "state"
    ],
    "evaluate_tf_py_list": [
      "self",
      "fetches",
      "session"
    ],
    "evaluate_test_data": [
      "self",
      "test_data",
      "session"
    ],
    "maybe_evaluate": [
      "self",
      "fetches",
      "session"
    ],
    "generic_asserts": [
      "self",
      "test_data",
      "stage"
    ],
    "asserts_for_test_many_to_one_encode_decode": [
      "self",
      "data"
    ],
    "assert_commutes_with_sum": [
      "self",
      "server_test_data",
      "stage",
      "decode_params",
      "shape"
    ]
  },
  "PlusOneEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "ADD_PARAM_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "TimesTwoEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "FACTOR_PARAM_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "SimpleLinearEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "A_PARAM_KEY": [],
    "B_PARAM_KEY": [],
    "__init__": [
      "self",
      "a",
      "b"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "ReduceMeanEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "RandomAddSubtractOneEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "SignIntFloatEncodingStage": {
    "ENCODED_SIGNS_KEY": [],
    "ENCODED_INTS_KEY": [],
    "ENCODED_FLOATS_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "dummy_rng_source": [
    "seed",
    "num_elements"
  ],
  "PlusRandomNumEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "SEED_PARAM_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "PlusOneOverNEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "ADD_PARAM_KEY": [],
    "ITERATION_STATE_KEY": [],
    "__init__": [
      "self"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors"
    ],
    "get_params": [
      "self",
      "state"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "AdaptiveNormalizeEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "FACTOR_PARAM_KEY": [],
    "FACTOR_STATE_KEY": [],
    "NORM_STATE_UPDATE_KEY": [],
    "__init__": [
      "self"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors"
    ],
    "get_params": [
      "self",
      "state"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "StateUpdateTensorsEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "SUM_STATE_UPDATE_KEY": [],
    "MIN_STATE_UPDATE_KEY": [],
    "MAX_STATE_UPDATE_KEY": [],
    "STACK_STATE_UPDATE_KEY": [],
    "LAST_SUM_STATE_KEY": [],
    "LAST_MIN_STATE_KEY": [],
    "LAST_MAX_STATE_KEY": [],
    "LAST_COUNT_STATE_KEY": [],
    "__init__": [
      "self"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors"
    ],
    "get_params": [
      "self",
      "state"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "get_tensor_with_random_shape": [
    "expected_num_elements",
    "source_fn"
  ],
  "is_adaptive_stage": [
    "stage"
  ],
  "aggregate_state_update_tensors": [
    "stage",
    "state_update_tensors"
  ],
  "as_simple_encoder": [
    "encoder",
    "tensorspec"
  ],
  "as_gather_encoder": [
    "encoder",
    "tensorspec"
  ],
  "identity": [],
  "uniform_quantization": [
    "bits"
  ],
  "hadamard_quantization": [
    "bits"
  ],
  "IdentityEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "FlattenEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "HadamardEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "SEED_PARAMS_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ],
    "_validate_and_expand_encode_input": [
      "self",
      "x"
    ],
    "_pad": [
      "self",
      "x"
    ],
    "_random_signs": [
      "self",
      "num_elements",
      "seed",
      "dtype"
    ]
  },
  "UniformQuantizationEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "MIN_MAX_VALUES_KEY": [],
    "MAX_INT_VALUE_PARAMS_KEY": [],
    "_ALLOWED_BITS_ARG": [],
    "__init__": [
      "self",
      "bits",
      "min_max",
      "stochastic"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "BitpackingEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "DUMMY_TYPE_VALUES_KEY": [],
    "_ALLOWED_INPUT_BITS_ARG": [],
    "__init__": [
      "self",
      "input_bits"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "ClipByNormEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "NORM_PARAMS_KEY": [],
    "__init__": [
      "self",
      "clip_norm"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "ClipByValueEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "MIN_PARAMS_KEY": [],
    "MAX_PARAMS_KEY": [],
    "__init__": [
      "self",
      "clip_value_min",
      "clip_value_max"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "PRNGUniformQuantizationEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "MIN_MAX_VALUES_KEY": [],
    "MAX_INT_VALUE_PARAMS_KEY": [],
    "SEED_PARAMS_KEY": [],
    "_ALLOWED_BITS_ARG": [],
    "__init__": [
      "self",
      "bits"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ],
    "_random_floats": [
      "self",
      "num_elements",
      "seed",
      "dtype"
    ]
  },
  "PerChannelUniformQuantizationEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "MIN_MAX_VALUES_KEY": [],
    "MAX_INT_VALUE_PARAMS_KEY": [],
    "SEED_PARAMS_KEY": [],
    "_ALLOWED_BITS_ARG": [],
    "__init__": [
      "self",
      "bits",
      "stochastic"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "PerChannelPRNGUniformQuantizationEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "MIN_MAX_VALUES_KEY": [],
    "MAX_INT_VALUE_PARAMS_KEY": [],
    "SEED_PARAMS_KEY": [],
    "_ALLOWED_BITS_ARG": [],
    "__init__": [
      "self",
      "bits"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ],
    "_random_floats": [
      "self",
      "num_elements",
      "seed",
      "dtype"
    ]
  },
  "KashinHadamardEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "ETA_PARAMS_KEY": [],
    "DELTA_PARAMS_KEY": [],
    "SEED_PARAMS_KEY": [],
    "__init__": [
      "self",
      "num_iters",
      "eta",
      "delta",
      "last_iter_clip",
      "pad_extra_level_threshold"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ],
    "_kashin_forward": [
      "self",
      "x",
      "signs",
      "clip_level",
      "clip"
    ],
    "_kashin_backward": [
      "self",
      "x",
      "shape",
      "signs"
    ],
    "_kashin_iter": [
      "self",
      "x",
      "kashin_coefficients",
      "signs",
      "clip_level"
    ],
    "_validate_and_expand_encode_input": [
      "self",
      "x"
    ],
    "_get_pad_dim": [
      "self",
      "dim"
    ],
    "_pad": [
      "self",
      "x"
    ],
    "_random_signs": [
      "self",
      "num_elements",
      "seed",
      "dtype"
    ]
  },
  "SplitBySmallValueEncodingStage": {
    "ENCODED_INDICES_KEY": [],
    "ENCODED_VALUES_KEY": [],
    "THRESHOLD_PARAMS_KEY": [],
    "__init__": [
      "self",
      "threshold"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "DifferenceBetweenIntegersEncodingStage": {
    "ENCODED_VALUES_KEY": [],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "OrderedEnum": {
    "__ge__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ]
  },
  "static_or_dynamic_shape": [
    "value"
  ],
  "split_dict_py_tf": [
    "dictionary"
  ],
  "merge_dicts": [
    "dict1",
    "dict2"
  ],
  "flatten_with_joined_string_paths": [
    "structure",
    "separator"
  ],
  "assert_compatible": [
    "spec",
    "value"
  ],
  "fast_walsh_hadamard_transform": [
    "x"
  ],
  "_cmwc_random_sequence": [
    "num_elements",
    "seed"
  ],
  "random_signs": [
    "num_elements",
    "seed",
    "dtype"
  ],
  "random_floats": [
    "num_elements",
    "seed",
    "dtype"
  ],
  "random_signs_cmwc": [
    "num_elements",
    "seed",
    "dtype"
  ],
  "random_floats_cmwc": [
    "num_elements",
    "seed",
    "dtype"
  ],
  "pack_into_int": [
    "value",
    "input_bitrange",
    "target_bitrange"
  ],
  "unpack_from_int": [
    "value",
    "original_bitrange",
    "target_bitrange",
    "shape"
  ],
  "_pack_binary_form": [
    "value",
    "target_bits"
  ],
  "_expand_to_binary_form": [
    "value",
    "input_bits"
  ],
  "_pack_into_int_6_28": [
    "value"
  ],
  "_pack_into_int_7_28": [
    "value"
  ],
  "_pack_into_int_8_28": [
    "value"
  ],
  "_pack_into_int_12_28": [
    "value"
  ],
  "_unpack_from_int_6_28": [
    "value",
    "shape"
  ],
  "_unpack_from_int_7_28": [
    "value",
    "shape"
  ],
  "_unpack_from_int_8_28": [
    "value",
    "shape"
  ],
  "_unpack_from_int_12_28": [
    "value",
    "shape"
  ],
  "_PARAMS": [],
  "_SHAPES": [],
  "_TENSORS": [],
  "GatherEncoder": {
    "__init__": [
      "self",
      "tensorspec",
      "commuting_structure",
      "state_update_aggregation_modes",
      "initial_state_fn",
      "get_params_fn",
      "encode_fn",
      "decode_before_sum_fn",
      "decode_after_sum_fn",
      "update_state_fn"
    ],
    "from_encoder": [
      "cls",
      "encoder",
      "tensorspec"
    ],
    "input_tensorspec": [
      "self"
    ],
    "fully_commutes_with_sum": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self",
      "name"
    ],
    "get_params": [
      "self",
      "state",
      "name"
    ],
    "encode": [
      "self",
      "x",
      "encode_params",
      "name"
    ],
    "decode_before_sum": [
      "self",
      "encoded_x",
      "decode_before_sum_params",
      "name"
    ],
    "decode_after_sum": [
      "self",
      "part_decoded_x",
      "decode_after_sum_params",
      "num_summands",
      "name"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors",
      "name"
    ]
  },
  "INITIAL_STATE_SCOPE_SUFFIX": [],
  "UPDATE_STATE_SCOPE_SUFFIX": [],
  "GET_PARAMS_SCOPE_SUFFIX": [],
  "ENCODE_SCOPE_SUFFIX": [],
  "DECODE_SCOPE_SUFFIX": [],
  "StateAggregationMode": {
    "SUM": [],
    "MIN": [],
    "MAX": [],
    "STACK": []
  },
  "EncodingStageInterface": {
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "get_params": [
      "self"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "AdaptiveEncodingStageInterface": {
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors"
    ],
    "get_params": [
      "self",
      "state"
    ],
    "encode": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "tf_style_encoding_stage": [
    "cls"
  ],
  "tf_style_adaptive_encoding_stage": [
    "cls"
  ],
  "_tf_style_initial_state": [
    "initial_state_fn"
  ],
  "_tf_style_update_state": [
    "update_state_fn"
  ],
  "_tf_style_get_params": [
    "get_params_fn"
  ],
  "_tf_style_adaptive_get_params": [
    "get_params_fn"
  ],
  "_tf_style_encode": [
    "encode_fn"
  ],
  "_tf_style_decode": [
    "decode_fn"
  ],
  "as_adaptive_encoding_stage": [
    "stage"
  ],
  "NoneStateAdaptiveEncodingStage": {
    "__init__": [
      "self",
      "wrapped_stage"
    ],
    "__getattr__": [
      "self",
      "attr"
    ],
    "name": [
      "self"
    ],
    "compressible_tensors_keys": [
      "self"
    ],
    "commutes_with_sum": [
      "self"
    ],
    "decode_needs_input_shape": [
      "self"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self",
      "name"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors",
      "name"
    ],
    "get_params": [
      "self",
      "state",
      "name"
    ],
    "encode": [
      "self",
      "x",
      "encode_params",
      "name"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape",
      "name"
    ]
  },
  "EncoderKeys": {
    "CHILDREN": [],
    "PARAMS": [],
    "SHAPE": [],
    "STATE": [],
    "TENSORS": [],
    "COMMUTE": []
  },
  "Encoder": {
    "__init__": [
      "self",
      "stage",
      "children"
    ],
    "fully_commutes_with_sum": [
      "self"
    ],
    "commuting_structure": [
      "self"
    ],
    "_commuting_structure_impl": [
      "self",
      "previous"
    ],
    "state_update_aggregation_modes": [
      "self"
    ],
    "initial_state": [
      "self",
      "name"
    ],
    "_initial_state_impl": [
      "self"
    ],
    "update_state": [
      "self",
      "state",
      "state_update_tensors",
      "name"
    ],
    "_update_state_impl": [
      "self",
      "state",
      "state_update_tensors"
    ],
    "get_params": [
      "self",
      "state",
      "name"
    ],
    "_get_params_impl": [
      "self",
      "state"
    ],
    "encode": [
      "self",
      "x",
      "encode_params",
      "name"
    ],
    "_encode_impl": [
      "self",
      "x",
      "encode_params"
    ],
    "decode": [
      "self",
      "encoded_tensors",
      "decode_params",
      "shape",
      "name"
    ],
    "decode_before_sum": [
      "self",
      "encoded_tensors",
      "decode_params",
      "shape",
      "name"
    ],
    "_decode_before_sum_impl": [
      "self",
      "encoded_tensors",
      "decode_params",
      "shape",
      "force_decode"
    ],
    "decode_after_sum": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape",
      "name"
    ],
    "_decode_after_sum_impl": [
      "self",
      "encoded_tensors",
      "decode_params",
      "num_summands",
      "shape"
    ]
  },
  "EncoderComposer": {
    "__init__": [
      "self",
      "stage"
    ],
    "add_child": [
      "self",
      "stage",
      "key"
    ],
    "add_parent": [
      "self",
      "stage",
      "key"
    ],
    "make": [
      "self"
    ]
  },
  "split_params_by_commuting_structure": [
    "params",
    "commuting_structure"
  ],
  "split_shapes_by_commuting_structure": [
    "shapes",
    "commuting_structure"
  ],
  "_split_value_by_commuting_structure": [
    "value",
    "encoder_key",
    "commuting_structure"
  ],
  "SimpleEncoder": {
    "__init__": [
      "self",
      "encoder",
      "tensorspec"
    ],
    "input_tensorspec": [
      "self"
    ],
    "initial_state": [
      "self",
      "name"
    ],
    "encode": [
      "self",
      "x",
      "state",
      "name"
    ],
    "decode": [
      "self",
      "encoded_x",
      "name"
    ]
  },
  "ClusterableLayer": {
    "get_clusterable_weights": [
      "self"
    ],
    "get_clusterable_algorithm": [
      "self",
      "weight_name"
    ]
  },
  "k": [],
  "CentroidInitialization": [],
  "AbstractCentroidsInitialisation": {
    "__init__": [
      "self",
      "weights",
      "number_of_clusters",
      "cluster_per_channel",
      "data_format",
      "preserve_sparsity"
    ],
    "_calculate_centroids_for_interval": [
      "self",
      "weight_interval",
      "number_of_clusters_for_interval"
    ],
    "_regular_clustering": [
      "self"
    ],
    "_per_channel_clustering": [
      "self"
    ],
    "_zero_centroid_initialization": [
      "self",
      "weights_to_cluster"
    ],
    "_per_channel_zero_centroid_initialization": [
      "self"
    ],
    "get_cluster_centroids": [
      "self"
    ]
  },
  "LinearCentroidsInitialisation": {
    "_calculate_centroids_for_interval": [
      "self",
      "weight_interval",
      "number_of_clusters_for_interval"
    ]
  },
  "KmeansPlusPlusCentroidsInitialisation": {
    "_calculate_centroids_for_interval": [
      "self",
      "weight_interval",
      "number_of_clusters_for_interval"
    ]
  },
  "RandomCentroidsInitialisation": {
    "_calculate_centroids_for_interval": [
      "self",
      "weight_interval",
      "number_of_clusters_for_interval"
    ]
  },
  "TFLinearEquationSolver": {
    "__init__": [
      "self",
      "x1",
      "y1",
      "x2",
      "y2"
    ],
    "solve_for_x": [
      "self",
      "y"
    ],
    "solve_for_y": [
      "self",
      "x"
    ]
  },
  "TFCumulativeDistributionFunction": {
    "__init__": [
      "self",
      "weights"
    ],
    "get_cdf_value": [
      "self",
      "given_weight"
    ]
  },
  "DensityBasedCentroidsInitialisation": {
    "_get_centroids": [
      "self",
      "cdf_x_grid",
      "cdf_values",
      "matching_indices"
    ],
    "_calculate_centroids_for_interval": [
      "self",
      "weight_interval",
      "number_of_clusters_for_interval"
    ]
  },
  "CentroidsInitializerFactory": {
    "_initialisers": [],
    "init_is_supported": [
      "cls",
      "init_method"
    ],
    "get_centroid_initializer": [
      "cls",
      "init_method"
    ]
  },
  "ClusteringAlgorithm": {
    "__init__": [
      "self",
      "clusters_centroids",
      "cluster_gradient_aggregation",
      "data_format"
    ],
    "average_centroids_gradient_by_cluster_size": [
      "self",
      "cluster_centroids",
      "cluster_sizes"
    ],
    "add_gradient_to_original_weight": [
      "self",
      "clustered_weight",
      "original_weight"
    ],
    "get_pulling_indices": [
      "self",
      "weight",
      "centroids"
    ],
    "get_clustered_weight": [
      "self",
      "pulling_indices",
      "original_weight"
    ]
  },
  "ClusteringAlgorithmPerChannel": {
    "get_pulling_indices": [
      "self",
      "weight"
    ],
    "get_clustered_weight": [
      "self",
      "pulling_indices",
      "original_weight"
    ]
  },
  "CustomObjectScope": [],
  "Layer": [],
  "InputLayer": [],
  "cluster_scope": [],
  "cluster_weights": [
    "to_cluster",
    "number_of_clusters",
    "cluster_centroids_init"
  ],
  "_cluster_weights": [
    "to_cluster",
    "number_of_clusters",
    "cluster_centroids_init",
    "preserve_sparsity",
    "cluster_per_channel"
  ],
  "strip_clustering": [
    "model"
  ],
  "layer_has_enough_weights_to_cluster": [
    "layer",
    "number_of_clusters",
    "cluster_per_channel"
  ],
  "GradientAggregation": {
    "SUM": [],
    "AVG": []
  },
  "attrgetter": [],
  "Wrapper": [],
  "ClusterWeights": {
    "__init__": [
      "self",
      "layer",
      "number_of_clusters",
      "cluster_centroids_init",
      "preserve_sparsity",
      "cluster_per_channel",
      "cluster_gradient_aggregation"
    ],
    "_make_layer_name": [
      "self",
      "layer"
    ],
    "_get_zero_idx_mask": [
      "self",
      "centroids",
      "zero_cluster"
    ],
    "_get_zero_centroid": [
      "self",
      "centroids",
      "zero_idx_mask"
    ],
    "get_weight_from_layer": [
      "self",
      "weight_name"
    ],
    "set_weight_to_layer": [
      "self",
      "weight_name",
      "new_weight"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "update_clustered_weights_associations": [
      "self"
    ],
    "call": [
      "self",
      "inputs",
      "training"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ],
    "trainable": [
      "self",
      "value"
    ],
    "trainable_weights": [
      "self"
    ],
    "non_trainable_weights": [
      "self"
    ],
    "updates": [
      "self"
    ],
    "losses": [
      "self"
    ],
    "get_weights": [
      "self"
    ],
    "set_weights": [
      "self",
      "weights"
    ]
  },
  "ClusterWeightsRNN": {
    "get_weight_name_without_index": [
      "self",
      "weight_name"
    ],
    "get_return_layer_cell": [
      "self",
      "index"
    ],
    "get_weight_from_layer": [
      "self",
      "weight_name"
    ],
    "set_weight_to_layer": [
      "self",
      "weight_name",
      "new_weight"
    ]
  },
  "ClusterWeightsMHA": {
    "get_weight_from_layer": [
      "self",
      "weight_name"
    ],
    "set_weight_to_layer": [
      "self",
      "weight_name",
      "new_weight"
    ],
    "strip_clustering": [
      "self"
    ]
  },
  "layers": [],
  "ClusteringLookupRegistry": {
    "get_clustering_impl": [
      "cls",
      "layer",
      "weight_name",
      "cluster_per_channel"
    ]
  },
  "ClusteringRegistry": {
    "_LAYERS_WEIGHTS_MAP": [],
    "_SUPPORTED_RNN_CELLS": [],
    "_SUPPORTED_RNN_LAYERS": [],
    "_SUPPORTED_MHA_LAYERS": [],
    "supports": [
      "cls",
      "layer"
    ],
    "_get_rnn_cells": [
      "rnn_layer"
    ],
    "_weight_names": [
      "cls",
      "layer"
    ],
    "make_clusterable": [
      "cls",
      "layer"
    ]
  },
  "ClusteringSummaries": {
    "__init__": [
      "self",
      "log_dir",
      "cluster_update_freq"
    ],
    "on_train_batch_begin": [
      "self",
      "batch",
      "logs"
    ],
    "on_train_batch_end": [
      "self",
      "batch",
      "logs"
    ],
    "on_epoch_end": [
      "self",
      "epoch",
      "logs"
    ],
    "_write_summary": [
      "self"
    ]
  },
  "MonitorBoolGauge": {
    "_PRUNE_FOR_BENCHMARK_USAGE": [],
    "_PRUNE_LOW_MAGNITUDE_USAGE": [],
    "_PRUNE_WRAPPER_USAGE": [],
    "_QUANTIZE_APPLY_USAGE": [],
    "_QUANTIZE_WRAPPER_USAGE": [],
    "_SUCCESS_LABEL": [],
    "_FAILURE_LABEL": [],
    "__init__": [
      "self",
      "name"
    ],
    "get_usage_gauge": [
      "self",
      "name"
    ],
    "__call__": [
      "self",
      "func"
    ],
    "set": [
      "self",
      "label",
      "value"
    ]
  },
  "_get_keras_instance": [],
  "keras": [],
  "assign": [
    "ref",
    "value",
    "name"
  ],
  "initialize_variables": [
    "testcase"
  ],
  "is_v1_apis": [],
  "PER_GRAPH_OBJECT_NAME_UIDS": [],
  "get_default_graph_uid_map": [],
  "unique_object_name": [
    "name",
    "name_uid_map",
    "avoid_names",
    "namespace",
    "zero_based",
    "avoid_observed_names"
  ],
  "smart_cond": [
    "pred",
    "true_fn",
    "false_fn",
    "name"
  ],
  "deserialize_keras_object": [],
  "serialize_keras_object": [],
  "QuantizeWrapper": {
    "__init__": [
      "self",
      "layer",
      "quantize_config",
      "name_prefix"
    ],
    "_make_layer_name": [
      "self",
      "layer",
      "name_prefix"
    ],
    "_weight_name": [
      "self",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "_make_quantizer_fn": [
      "self",
      "quantizer",
      "x",
      "training",
      "quantizer_vars"
    ],
    "call": [
      "self",
      "inputs",
      "training"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "trainable": [
      "self",
      "value"
    ],
    "trainable_weights": [
      "self"
    ],
    "non_trainable_weights": [
      "self"
    ],
    "updates": [
      "self"
    ],
    "losses": [
      "self"
    ]
  },
  "QuantizeWrapperV2": {
    "build": [
      "self",
      "input_shape"
    ],
    "trainable_weights": [
      "self"
    ]
  },
  "QuantizeScheme": {
    "get_layout_transformer": [
      "self"
    ],
    "get_quantize_registry": [
      "self"
    ]
  },
  "QuantizeLayer": {
    "__init__": [
      "self",
      "quantizer"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "training"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "serialize_layer": [
    "layer",
    "use_legacy_format"
  ],
  "deserialize_layer": [
    "config",
    "use_legacy_format"
  ],
  "serialize_activation": [
    "activation",
    "use_legacy_format"
  ],
  "deserialize_activation": [
    "config",
    "use_legacy_format"
  ],
  "convert_keras_to_tflite": [
    "model",
    "output_path",
    "custom_objects",
    "is_quantized",
    "inference_type",
    "inference_input_type",
    "input_quant_params"
  ],
  "FixedQuantize": [
    "inputs",
    "init_min",
    "init_max",
    "scope",
    "narrow_range"
  ],
  "AllValuesQuantize": [
    "inputs",
    "min_var",
    "max_var",
    "name_prefix",
    "is_training",
    "num_bits",
    "narrow_range",
    "symmetric"
  ],
  "LastValueQuantize": [
    "inputs",
    "min_var",
    "max_var",
    "per_channel",
    "name_prefix",
    "is_training",
    "num_bits",
    "narrow_range",
    "symmetric"
  ],
  "MovingAvgQuantize": [
    "inputs",
    "min_var",
    "max_var",
    "per_channel",
    "ema_decay",
    "name_prefix",
    "is_training",
    "num_bits",
    "narrow_range",
    "symmetric"
  ],
  "_FakeQuantWithMinMaxVars": [
    "inputs",
    "min_var",
    "max_var",
    "per_channel",
    "num_bits",
    "narrow_range"
  ],
  "quantize_scope": [],
  "quantize_model": [
    "to_quantize",
    "quantized_layer_name_prefix"
  ],
  "quantize_annotate_model": [
    "to_annotate"
  ],
  "quantize_annotate_layer": [
    "to_annotate",
    "quantize_config"
  ],
  "quantize_apply": [
    "model",
    "scheme",
    "quantized_layer_name_prefix"
  ],
  "_unwrap_first_input_name": [
    "inbound_nodes"
  ],
  "_wrap_fixed_range": [
    "quantize_config",
    "num_bits",
    "init_min",
    "init_max",
    "narrow_range"
  ],
  "_is_serialized_node_data": [
    "nested"
  ],
  "_nested_to_flatten_node_data_list": [
    "nested"
  ],
  "fix_input_output_range": [
    "model",
    "num_bits",
    "input_min",
    "input_max",
    "output_min",
    "output_max",
    "narrow_range"
  ],
  "_is_functional_model": [
    "model"
  ],
  "remove_input_range": [
    "model"
  ],
  "QuantizeLayoutTransform": {
    "apply": [
      "self",
      "model",
      "layer_quantize_map"
    ]
  },
  "QuantizeAnnotate": {
    "_UNSUPPORTED_LAYER_ERROR_MSG": [],
    "__init__": [
      "self",
      "layer",
      "quantize_config"
    ],
    "call": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "trainable": [
      "self",
      "value"
    ],
    "trainable_weights": [
      "self"
    ],
    "non_trainable_weights": [
      "self"
    ],
    "updates": [
      "self"
    ],
    "losses": [
      "self"
    ],
    "get_weights": [
      "self"
    ],
    "set_weights": [
      "self",
      "weights"
    ]
  },
  "QuantizeRegistry": {
    "get_quantize_config": [
      "self",
      "layer"
    ]
  },
  "Quantizer": {
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "_QuantizeHelper": {
    "_add_range_weights": [
      "self",
      "layer",
      "name",
      "per_axis",
      "tensor_shape"
    ]
  },
  "LastValueQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "per_axis",
      "symmetric",
      "narrow_range"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "MovingAverageQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "per_axis",
      "symmetric",
      "narrow_range"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "AllValuesQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "per_axis",
      "symmetric",
      "narrow_range"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "FixedQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "init_min",
      "init_max",
      "narrow_range"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "NoQuantizer": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "_types_dict": [],
  "QuantizeConfig": {
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "OutputOnlyConfig": {
    "__init__": [
      "self",
      "quantize_config"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "FixedQuantizeConfig": {
    "__init__": [
      "self",
      "config",
      "num_bits",
      "init_min",
      "init_max",
      "narrow_range"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "activations": [],
  "NoOpActivation": {
    "__call__": [
      "self",
      "x"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "QuantizeAwareActivation": {
    "_PRE_QUANT_ACTIVATIONS": [],
    "_POST_QUANT_ACTIVATIONS": [],
    "_NO_QUANTIZE_ACTIVATIONS": [],
    "_CUSTOM_ACTIVATION_ERR_MSG": [],
    "__init__": [
      "self",
      "activation",
      "quantizer",
      "step",
      "quantize_wrapper"
    ],
    "_name": [
      "self",
      "activation"
    ],
    "_is_supported_activation": [
      "self",
      "activation"
    ],
    "_should_pre_quantize": [
      "self"
    ],
    "_should_post_quantize": [
      "self"
    ],
    "training": [
      "self",
      "value"
    ],
    "_dict_vars": [
      "self",
      "min_var",
      "max_var"
    ],
    "__call__": [
      "self",
      "inputs"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "get_config": [
      "self"
    ]
  },
  "Default8BitQuantizeLayoutTransform": {
    "apply": [
      "self",
      "model",
      "layer_quantize_map"
    ]
  },
  "Default8BitConvWeightsQuantizer": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ]
  },
  "Default8BitConvTransposeWeightsQuantizer": {
    "__init__": [
      "self"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ]
  },
  "LayerNode": [],
  "LayerPattern": [],
  "_get_conv_bn_layers": [
    "bn_layer_node"
  ],
  "_get_weights": [
    "bn_layer_node"
  ],
  "_get_params": [
    "conv_layer",
    "bn_layer",
    "relu_layer"
  ],
  "_get_layer_node": [
    "fused_layer",
    "weights"
  ],
  "_get_quantize_config": [
    "layer_node"
  ],
  "_has_custom_quantize_config": [],
  "_normalize_tuple": [
    "value"
  ],
  "Conv2DBatchNormQuantize": {
    "pattern": [
      "self"
    ],
    "_replace": [
      "self",
      "bn_layer_node",
      "conv_layer_node"
    ],
    "replacement": [
      "self",
      "match_layer"
    ],
    "custom_objects": [
      "self"
    ]
  },
  "Conv2DReshapeBatchNormQuantize": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "Conv2DBatchNormReLUQuantize": {
    "pattern": [
      "self"
    ],
    "_replace": [
      "self",
      "relu_layer_node",
      "bn_layer_node",
      "conv_layer_node"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "Conv2DBatchNormActivationQuantize": {
    "pattern": [
      "self"
    ]
  },
  "Conv2DReshapeBatchNormReLUQuantize": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "Conv2DReshapeBatchNormActivationQuantize": {
    "pattern": [
      "self"
    ]
  },
  "DenseBatchNormQuantize": {
    "pattern": [
      "self"
    ],
    "_replace": [
      "self",
      "bn_layer_node",
      "dense_layer_node"
    ],
    "replacement": [
      "self",
      "match_layer"
    ],
    "custom_objects": [
      "self"
    ]
  },
  "DenseBatchNormReLUQuantize": {
    "pattern": [
      "self"
    ],
    "_replace": [
      "self",
      "relu_layer_node",
      "bn_layer_node",
      "dense_layer_node"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "DenseBatchNormActivationQuantize": {
    "pattern": [
      "self"
    ]
  },
  "SeparableConv1DQuantize": {
    "pattern": [
      "self"
    ],
    "_get_name": [
      "self",
      "prefix"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "SeparableConvQuantize": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "LayerReLUQuantize": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ],
    "custom_objects": [
      "self"
    ]
  },
  "LayerReluActivationQuantize": {
    "pattern": [
      "self"
    ]
  },
  "InputLayerQuantize": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ],
    "custom_objects": [
      "self"
    ]
  },
  "ConcatTransform": {
    "pattern": [
      "self"
    ],
    "_get_layer_type": [
      "self",
      "layer_class_name"
    ],
    "_disable_output_quantize": [
      "self",
      "quantize_config"
    ],
    "replacement": [
      "self",
      "match_layer"
    ]
  },
  "ConcatTransform3Inputs": {
    "pattern": [
      "self"
    ]
  },
  "ConcatTransform4Inputs": {
    "pattern": [
      "self"
    ]
  },
  "ConcatTransform5Inputs": {
    "pattern": [
      "self"
    ]
  },
  "ConcatTransform6Inputs": {
    "pattern": [
      "self"
    ]
  },
  "Default8BitQuantizeScheme": {
    "__init__": [
      "self",
      "disable_per_axis"
    ],
    "get_layout_transformer": [
      "self"
    ],
    "get_quantize_registry": [
      "self"
    ]
  },
  "_QuantizeInfo": {
    "__init__": [
      "self",
      "layer_type",
      "weight_attrs",
      "activation_attrs",
      "quantize_output"
    ]
  },
  "_no_quantize": [
    "layer_type"
  ],
  "_RNNHelper": {
    "_get_rnn_cells": [
      "self",
      "rnn_layer"
    ]
  },
  "Default8BitQuantizeRegistry": {
    "_LAYER_QUANTIZE_INFO": [],
    "__init__": [
      "self",
      "disable_per_axis"
    ],
    "_is_supported_layer": [
      "self",
      "layer_class"
    ],
    "_is_rnn_layer": [
      "self",
      "layer"
    ],
    "_get_quantize_info": [
      "self",
      "layer_class"
    ],
    "supports": [
      "self",
      "layer"
    ],
    "_get_quantize_config": [
      "self",
      "layer_type"
    ],
    "get_quantize_config": [
      "self",
      "layer"
    ]
  },
  "Default8BitQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "Default8BitQuantizeConfigRNN": {
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "_flatten": [
      "self",
      "list_of_lists"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ]
  },
  "Default8BitActivationQuantizeConfig": {
    "__init__": [
      "self",
      "quantize_output"
    ],
    "_assert_activation_layer": [
      "self",
      "layer"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "Default8BitConvQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output"
    ]
  },
  "Default8BitConvTransposeQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output"
    ]
  },
  "Default8BitOutputQuantizeConfig": {
    "__init__": [
      "self",
      "quantize_output"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ]
  },
  "NoOpQuantizeConfig": {
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ]
  },
  "Transform": {
    "pattern": [
      "self"
    ],
    "replacement": [
      "self",
      "match_layer"
    ],
    "custom_objects": [
      "self"
    ]
  },
  "K": [],
  "ModelTransformer": {
    "__init__": [
      "self",
      "model",
      "transforms",
      "candidate_layers",
      "layer_metadata"
    ],
    "_is_sequential_or_functional_model": [
      "self",
      "model"
    ],
    "_is_functional_model": [
      "self",
      "model"
    ],
    "_inbound_node_generator": [
      "self",
      "layer"
    ],
    "_get_inbound_layer_names": [
      "self",
      "layer"
    ],
    "_get_consuming_layers": [
      "self",
      "check_layer"
    ],
    "_get_output_consumers": [
      "self",
      "check_layer"
    ],
    "_get_layers": [
      "self",
      "layer_names"
    ],
    "_get_layer_weights": [
      "self",
      "layer_name"
    ],
    "_get_layer_names_and_weights": [
      "self",
      "layer_name"
    ],
    "_get_layer_metadata": [
      "self",
      "layer_name"
    ],
    "_match_pattern": [
      "self",
      "target",
      "pattern"
    ],
    "_match_layer": [
      "self",
      "layer",
      "pattern"
    ],
    "_is_match_supported": [
      "self",
      "layer",
      "is_head_node"
    ],
    "_get_input_layer_names": [
      "self",
      "layer"
    ],
    "_match_layer_with_inputs": [
      "self",
      "layer",
      "pattern",
      "is_head_node"
    ],
    "_find_pattern": [
      "self",
      "pattern",
      "matched_layers"
    ],
    "_get_leaf_layers": [
      "self",
      "match_layer"
    ],
    "_get_layer_names": [
      "self",
      "layer_node"
    ],
    "_remove_layers": [
      "self",
      "layers_to_remove",
      "layers_to_remove_names"
    ],
    "_replace": [
      "self",
      "match_layer_node",
      "replacement_layer_node"
    ],
    "_replace_functional": [
      "self",
      "match_layer_node",
      "replacement_layer_node"
    ],
    "_replace_sequential": [
      "self",
      "match_layer_node",
      "replacement_layer_node"
    ],
    "_weight_name": [
      "self",
      "name"
    ],
    "_get_keras_layer_weights": [
      "self",
      "keras_layer"
    ],
    "_get_keras_layer_names_and_weights": [
      "self",
      "keras_layer"
    ],
    "_set_layer_weights": [
      "self",
      "layer",
      "weights_map"
    ],
    "_set_layer_names_and_weights": [
      "self",
      "layer",
      "names_and_weights"
    ],
    "_name": [
      "self",
      "obj"
    ],
    "_get_matched_layers": [
      "self",
      "transform"
    ],
    "_store_successful_match": [
      "self",
      "transform",
      "layer_node"
    ],
    "transform": [
      "self"
    ]
  },
  "DefaultNBitConvWeightsQuantizer": {
    "__init__": [
      "self",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ]
  },
  "DefaultNBitConvTransposeWeightsQuantizer": {
    "__init__": [
      "self",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ]
  },
  "DefaultNBitQuantizeLayoutTransform": {
    "__init__": [
      "self",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "apply": [
      "self",
      "model",
      "layer_quantize_map"
    ]
  },
  "DefaultNBitQuantizeScheme": {
    "__init__": [
      "self",
      "disable_per_axis",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "get_layout_transformer": [
      "self"
    ],
    "get_quantize_registry": [
      "self"
    ]
  },
  "DefaultNBitOutputQuantizeConfig": {
    "__init__": [
      "self",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ]
  },
  "DefaultNBitQuantizeRegistry": {
    "_LAYER_QUANTIZE_INFO": [],
    "__init__": [
      "self",
      "disable_per_axis",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "_is_supported_layer": [
      "self",
      "layer_class"
    ],
    "_is_rnn_layer": [
      "self",
      "layer"
    ],
    "_get_quantize_info": [
      "self",
      "layer_class"
    ],
    "supports": [
      "self",
      "layer"
    ],
    "_get_quantize_config": [
      "self",
      "layer_type"
    ],
    "get_quantize_config": [
      "self",
      "layer"
    ]
  },
  "DefaultNBitQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "get_config": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ]
  },
  "DefaultNBitQuantizeConfigRNN": {
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "_flatten": [
      "self",
      "list_of_lists"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ]
  },
  "DefaultNBitActivationQuantizeConfig": {
    "__init__": [
      "self",
      "num_bits_weight",
      "num_bits_activation"
    ],
    "_assert_activation_layer": [
      "self",
      "layer"
    ],
    "get_weights_and_quantizers": [
      "self",
      "layer"
    ],
    "get_activations_and_quantizers": [
      "self",
      "layer"
    ],
    "set_quantize_weights": [
      "self",
      "layer",
      "quantize_weights"
    ],
    "set_quantize_activations": [
      "self",
      "layer",
      "quantize_activations"
    ],
    "get_output_quantizers": [
      "self",
      "layer"
    ],
    "get_config": [
      "self"
    ]
  },
  "DefaultNBitConvQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output",
      "num_bits_weight",
      "num_bits_activation"
    ]
  },
  "DefaultNBitConvTransposeQuantizeConfig": {
    "__init__": [
      "self",
      "weight_attrs",
      "activation_attrs",
      "quantize_output",
      "num_bits_weight",
      "num_bits_activation"
    ]
  },
  "CLUSTER_CENTROIDS": [],
  "PULLING_INDICES": [],
  "ORIGINAL_WEIGHTS": [],
  "WEIGHT_NAME": [],
  "CLUSTERING_IMPL": [],
  "CENTROIDS_MASK": [],
  "SPARSITY_MASK": [],
  "get_unique": [
    "t"
  ],
  "get_centroids": [
    "layer",
    "weight",
    "data_format"
  ],
  "_ClusterPreserveInfo": {
    "__init__": [
      "self",
      "weight_attrs",
      "quantize_config_attrs"
    ]
  },
  "ClusterPreserveQuantizeRegistry": {
    "_LAYERS_CONFIG_MAP": [],
    "_DISABLE_CLUSTER_PRESERVE": [],
    "__init__": [
      "self",
      "preserve_sparsity"
    ],
    "_no_trainable_weights": [
      "cls",
      "layer"
    ],
    "_disable_cluster_preserve": [
      "cls",
      "layer"
    ],
    "supports": [
      "cls",
      "layer"
    ],
    "_weight_names": [
      "cls",
      "layer"
    ],
    "apply_cluster_preserve_quantize_config": [
      "self",
      "layer",
      "quantize_config"
    ]
  },
  "Default8bitClusterPreserveQuantizeRegistry": {
    "get_quantize_config": [
      "self",
      "layer"
    ]
  },
  "ClusterPreserveDefaultWeightsQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "per_axis",
      "symmetric",
      "narrow_range",
      "preserve_sparsity"
    ],
    "_build_clusters": [
      "self",
      "name",
      "layer"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ]
  },
  "ClusterPreserveDefault8BitWeightsQuantizer": {
    "__init__": [
      "self",
      "preserve_sparsity"
    ]
  },
  "ClusterPreserveDefault8BitConvWeightsQuantizer": {
    "__init__": [
      "self",
      "preserve_sparsity"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ]
  },
  "_type_model": [
    "model"
  ],
  "strip_clustering_cqat": [
    "to_strip"
  ],
  "Default8BitClusterPreserveQuantizeScheme": {
    "__init__": [
      "self",
      "preserve_sparsity"
    ],
    "get_quantize_registry": [
      "self"
    ]
  },
  "_PrunePreserveInfo": {
    "__init__": [
      "self",
      "weight_attrs",
      "quantize_config_attrs"
    ]
  },
  "PrunePreserveQuantizeRegistry": {
    "_LAYERS_CONFIG_MAP": [],
    "_DISABLE_PRUNE_PRESERVE": [],
    "__init__": [
      "self"
    ],
    "_no_trainable_weights": [
      "cls",
      "layer"
    ],
    "_disable_prune_preserve": [
      "cls",
      "layer"
    ],
    "supports": [
      "cls",
      "layer"
    ],
    "_weight_names": [
      "cls",
      "layer"
    ],
    "get_sparsity_preservable_weights": [
      "cls",
      "layer"
    ],
    "get_suppport_quantize_config_names": [
      "cls",
      "layer"
    ],
    "apply_sparsity_preserve_quantize_config": [
      "self",
      "layer",
      "quantize_config"
    ]
  },
  "Default8bitPrunePreserveQuantizeRegistry": {
    "get_quantize_config": [
      "self",
      "layer"
    ]
  },
  "PrunePreserveDefaultWeightsQuantizer": {
    "__init__": [
      "self",
      "num_bits",
      "per_axis",
      "symmetric",
      "narrow_range"
    ],
    "_build_sparsity_mask": [
      "self",
      "name",
      "layer"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ],
    "__call__": [
      "self",
      "inputs",
      "training",
      "weights"
    ]
  },
  "PrunePreserveDefault8BitWeightsQuantizer": {
    "__init__": [
      "self"
    ]
  },
  "PrunePreserveDefault8BitConvWeightsQuantizer": {
    "__init__": [
      "self"
    ],
    "build": [
      "self",
      "tensor_shape",
      "name",
      "layer"
    ]
  },
  "Default8BitPrunePreserveQuantizeScheme": {
    "get_quantize_registry": [
      "self"
    ]
  },
  "kronecker_product": [
    "mat1",
    "mat2"
  ],
  "expand_tensor": [
    "tensor",
    "block_size"
  ],
  "factorized_pool": [
    "input_tensor",
    "window_shape",
    "pooling_type",
    "strides",
    "padding",
    "name"
  ],
  "convert_to_tuple_of_two_int": [
    "value",
    "name"
  ],
  "weights_rearrange": [
    "weights"
  ],
  "m_by_n_sparsity_mask_prepare": [
    "mask",
    "weights_shape"
  ],
  "generate_m_by_n_mask": [
    "weights",
    "m_by_n"
  ],
  "is_pruned_m_by_n": [
    "weights",
    "m_by_n",
    "last_channel"
  ],
  "_to_snake_case": [
    "name"
  ],
  "PruneLowMagnitude": {
    "_PRUNE_CALLBACK_ERROR_MSG": [],
    "__init__": [
      "self",
      "layer",
      "pruning_schedule",
      "block_size",
      "block_pooling_type",
      "sparsity_m_by_n"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "training"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ],
    "trainable": [
      "self",
      "value"
    ],
    "trainable_weights": [
      "self"
    ],
    "non_trainable_weights": [
      "self"
    ],
    "updates": [
      "self"
    ],
    "losses": [
      "self"
    ],
    "get_weights": [
      "self"
    ],
    "set_weights": [
      "self",
      "weights"
    ]
  },
  "collect_prunable_layers": [
    "model"
  ],
  "layers_compat_v1": [],
  "PruneRegistry": {
    "_LAYERS_WEIGHTS_MAP": [],
    "_RNN_CELLS_WEIGHTS_MAP": [],
    "_RNN_LAYERS": [],
    "_RNN_CELLS_STR": [],
    "_RNN_CELL_ERROR_MSG": [],
    "supports": [
      "cls",
      "layer"
    ],
    "_get_rnn_cells": [
      "cls",
      "rnn_layer"
    ],
    "_is_rnn_layer": [
      "cls",
      "layer"
    ],
    "_is_mha_layer": [
      "cls",
      "layer"
    ],
    "_weight_names": [
      "cls",
      "layer"
    ],
    "make_prunable": [
      "cls",
      "layer"
    ]
  },
  "custom_object_scope": [],
  "prune_scope": [],
  "prune_low_magnitude": [
    "to_prune",
    "pruning_schedule",
    "block_size",
    "block_pooling_type",
    "pruning_policy",
    "sparsity_m_by_n"
  ],
  "strip_pruning": [
    "model"
  ],
  "PruningPolicy": {
    "allow_pruning": [
      "self",
      "layer"
    ],
    "ensure_model_supports_pruning": [
      "self",
      "model"
    ]
  },
  "PruneForLatencyOnXNNPack": {
    "allow_pruning": [
      "self",
      "layer"
    ],
    "_get_producers": [
      "self",
      "layer"
    ],
    "_get_consumers": [
      "self",
      "layer"
    ],
    "_lookup_layers": [
      "self",
      "source_layers",
      "stop_fn",
      "next_fn"
    ],
    "_start_layer_stop_fn": [
      "self",
      "layer"
    ],
    "_end_layer_stop_fn": [
      "self",
      "layer"
    ],
    "_check_layer_support": [
      "self",
      "layer"
    ],
    "ensure_model_supports_pruning": [
      "self",
      "model"
    ]
  },
  "callbacks": [],
  "UpdatePruningStep": {
    "__init__": [
      "self"
    ],
    "on_train_begin": [
      "self",
      "logs"
    ],
    "on_epoch_end": [
      "self",
      "batch",
      "logs"
    ]
  },
  "PruningSummaries": {
    "__init__": [
      "self",
      "log_dir",
      "update_freq"
    ],
    "_log_pruning_metrics": [
      "self",
      "logs",
      "prefix",
      "step"
    ],
    "on_epoch_begin": [
      "self",
      "epoch",
      "logs"
    ]
  },
  "PruningSchedule": {
    "_should_prune_in_step": [
      "self",
      "step",
      "begin_step",
      "end_step",
      "frequency"
    ],
    "_validate_step": [
      "self",
      "begin_step",
      "end_step",
      "frequency",
      "allow_negative_1"
    ],
    "_validate_sparsity": [
      "self",
      "sparsity",
      "variable_name"
    ],
    "__call__": [
      "self",
      "step"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "ConstantSparsity": {
    "__init__": [
      "self",
      "target_sparsity",
      "begin_step",
      "end_step",
      "frequency"
    ],
    "__call__": [
      "self",
      "step"
    ],
    "get_config": [
      "self"
    ]
  },
  "PolynomialDecay": {
    "__init__": [
      "self",
      "initial_sparsity",
      "final_sparsity",
      "begin_step",
      "end_step",
      "power",
      "frequency"
    ],
    "__call__": [
      "self",
      "step"
    ],
    "get_config": [
      "self"
    ]
  },
  "PrunableLayer": {
    "get_prunable_weights": [
      "self"
    ]
  },
  "Pruning": {
    "__init__": [
      "self",
      "training_step_fn",
      "pruning_vars",
      "pruning_schedule",
      "block_size",
      "block_pooling_type",
      "sparsity_m_by_n"
    ],
    "_validate_block": [
      "self"
    ],
    "_update_mask": [
      "self",
      "weights"
    ],
    "_update_mask_sparsity_m_by_n": [
      "self",
      "weights",
      "m_by_n"
    ],
    "_maybe_update_block_mask": [
      "self",
      "weights"
    ],
    "_weight_assign_objs": [
      "self"
    ],
    "weight_mask_op": [
      "self"
    ],
    "conditional_mask_update": [
      "self"
    ],
    "add_pruning_summaries": [
      "self"
    ]
  }
}