{
  "compute_stepsize_dask": [
    "beta",
    "step",
    "Xbeta",
    "Xstep",
    "y",
    "curr_val",
    "family",
    "stepSize",
    "armijoMult",
    "backtrackMult"
  ],
  "gradient_descent": [
    "X",
    "y",
    "max_iter",
    "tol",
    "family"
  ],
  "newton": [
    "X",
    "y",
    "max_iter",
    "tol",
    "family"
  ],
  "admm": [
    "X",
    "y",
    "regularizer",
    "lamduh",
    "rho",
    "over_relax",
    "max_iter",
    "abstol",
    "reltol",
    "family"
  ],
  "local_update": [
    "X",
    "y",
    "beta",
    "z",
    "u",
    "rho",
    "f",
    "fprime",
    "solver"
  ],
  "lbfgs": [
    "X",
    "y",
    "regularizer",
    "lamduh",
    "max_iter",
    "tol",
    "family",
    "verbose"
  ],
  "proximal_grad": [
    "X",
    "y",
    "regularizer",
    "lamduh",
    "family",
    "max_iter",
    "tol"
  ],
  "_solvers": [],
  "normalize": [
    "algo"
  ],
  "zeros": [
    "shape",
    "arr"
  ],
  "sigmoid": [
    "x"
  ],
  "exp": [
    "A"
  ],
  "absolute": [
    "A"
  ],
  "sign": [
    "A"
  ],
  "log1p": [
    "A"
  ],
  "dot": [
    "A",
    "B"
  ],
  "sum": [
    "A"
  ],
  "is_dask_array_sparse": [
    "X"
  ],
  "add_intercept": [
    "X"
  ],
  "make_y": [
    "X",
    "beta",
    "chunks"
  ],
  "mean_squared_error": [
    "y_true",
    "y_pred"
  ],
  "accuracy_score": [
    "y_true",
    "y_pred"
  ],
  "poisson_deviance": [
    "y_true",
    "y_pred"
  ],
  "package_of": [
    "obj"
  ],
  "scatter_array": [
    "arr",
    "dask_client"
  ],
  "get_distributed_client": [],
  "maybe_to_cupy": [
    "beta",
    "X"
  ],
  "to_dask_cupy_array": [
    "X",
    "cupy"
  ],
  "to_dask_cupy_array_xy": [
    "X",
    "y",
    "cupy"
  ],
  "Logistic": {
    "loglike": [
      "Xbeta",
      "y"
    ],
    "pointwise_loss": [
      "beta",
      "X",
      "y"
    ],
    "pointwise_gradient": [
      "beta",
      "X",
      "y"
    ],
    "gradient": [
      "Xbeta",
      "X",
      "y"
    ],
    "hessian": [
      "Xbeta",
      "X"
    ]
  },
  "Normal": {
    "loglike": [
      "Xbeta",
      "y"
    ],
    "pointwise_loss": [
      "beta",
      "X",
      "y"
    ],
    "pointwise_gradient": [
      "beta",
      "X",
      "y"
    ],
    "gradient": [
      "Xbeta",
      "X",
      "y"
    ],
    "hessian": [
      "Xbeta",
      "X"
    ]
  },
  "Poisson": {
    "loglike": [
      "Xbeta",
      "y"
    ],
    "pointwise_loss": [
      "beta",
      "X",
      "y"
    ],
    "pointwise_gradient": [
      "beta",
      "X",
      "y"
    ],
    "gradient": [
      "Xbeta",
      "X",
      "y"
    ],
    "hessian": [
      "Xbeta",
      "X"
    ]
  },
  "Regularizer": {
    "name": [],
    "f": [
      "self",
      "beta"
    ],
    "gradient": [
      "self",
      "beta"
    ],
    "hessian": [
      "self",
      "beta"
    ],
    "proximal_operator": [
      "self",
      "beta",
      "t"
    ],
    "add_reg_f": [
      "self",
      "f",
      "lam"
    ],
    "add_reg_grad": [
      "self",
      "grad",
      "lam"
    ],
    "add_reg_hessian": [
      "self",
      "hess",
      "lam"
    ],
    "get": [
      "cls",
      "obj"
    ]
  },
  "L2": {
    "name": [],
    "f": [
      "self",
      "beta"
    ],
    "gradient": [
      "self",
      "beta"
    ],
    "hessian": [
      "self",
      "beta"
    ],
    "proximal_operator": [
      "self",
      "beta",
      "t"
    ]
  },
  "L1": {
    "name": [],
    "f": [
      "self",
      "beta"
    ],
    "gradient": [
      "self",
      "beta"
    ],
    "hessian": [
      "self",
      "beta"
    ],
    "proximal_operator": [
      "self",
      "beta",
      "t"
    ]
  },
  "ElasticNet": {
    "name": [],
    "__init__": [
      "self",
      "weight"
    ],
    "_weighted": [
      "self",
      "left",
      "right"
    ],
    "f": [
      "self",
      "beta"
    ],
    "gradient": [
      "self",
      "beta"
    ],
    "hessian": [
      "self",
      "beta"
    ],
    "proximal_operator": [
      "self",
      "beta",
      "t"
    ]
  },
  "_GLM": {
    "family": [
      "self"
    ],
    "__init__": [
      "self",
      "fit_intercept",
      "solver",
      "regularizer",
      "max_iter",
      "tol",
      "lamduh",
      "rho",
      "over_relax",
      "abstol",
      "reltol"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "_maybe_add_intercept": [
      "self",
      "X"
    ]
  },
  "LogisticRegression": {
    "family": [],
    "predict": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "LinearRegression": {
    "family": [],
    "predict": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X",
      "y"
    ]
  },
  "PoissonRegression": {
    "family": [],
    "predict": [
      "self",
      "X"
    ],
    "get_deviance": [
      "self",
      "X",
      "y"
    ]
  },
  "make_classification": [
    "n_samples",
    "n_features",
    "n_informative",
    "scale",
    "chunksize",
    "is_sparse"
  ],
  "make_regression": [
    "n_samples",
    "n_features",
    "n_informative",
    "scale",
    "chunksize",
    "is_sparse"
  ],
  "make_poisson": [
    "n_samples",
    "n_features",
    "n_informative",
    "scale",
    "chunksize",
    "is_sparse"
  ],
  "test_local_update": [
    "N",
    "beta",
    "family"
  ],
  "test_admm_with_large_lamduh": [
    "N",
    "p",
    "nchunks",
    "is_cupy"
  ],
  "add_l1": [
    "f",
    "lam"
  ],
  "make_intercept_data": [
    "N",
    "p",
    "seed"
  ],
  "make_array_type": [
    "type"
  ],
  "maybe_compute": [
    "expr"
  ],
  "test_methods": [
    "N",
    "p",
    "seed",
    "opt",
    "array_type"
  ],
  "test_basic_unreg_descent": [
    "func",
    "kwargs",
    "N",
    "nchunks",
    "family",
    "array_type"
  ],
  "test_basic_reg_descent": [
    "func",
    "kwargs",
    "N",
    "nchunks",
    "family",
    "lam",
    "reg",
    "array_type"
  ],
  "test_determinism": [
    "func",
    "kwargs",
    "scheduler",
    "array_type"
  ],
  "test_base_class_raises_notimplementederror": [
    "func",
    "args"
  ],
  "FooRegularizer": {
    "f": [
      "self",
      "beta"
    ],
    "gradient": [
      "self",
      "beta"
    ],
    "hessian": [
      "self",
      "beta"
    ]
  },
  "test_add_reg_funcs": [
    "func"
  ],
  "test_regularizer_get_passes_through_instance": [],
  "test_regularizer_get_unnamed_raises": [],
  "test_regularizer_gets_from_name": [],
  "test_l2_function": [
    "beta",
    "expected"
  ],
  "test_l2_gradient": [
    "beta"
  ],
  "test_l2_hessian": [
    "beta"
  ],
  "test_l2_proximal_operator": [
    "beta",
    "expected"
  ],
  "test_l1_function": [
    "beta",
    "expected"
  ],
  "test_l1_gradient": [
    "beta",
    "expected"
  ],
  "test_l1_gradient_raises_near_zero": [
    "beta"
  ],
  "test_l1_hessian": [],
  "test_l1_hessian_raises": [],
  "test_l1_proximal_operator": [
    "beta",
    "expected"
  ],
  "test_elastic_net_function": [
    "beta",
    "expected"
  ],
  "test_elastic_net_function_zero_weight_is_l2": [],
  "test_elastic_net_function_zero_weight_is_l1": [],
  "test_elastic_net_gradient": [],
  "test_elastic_net_gradient_zero_weight_is_l2": [],
  "test_elastic_net_gradient_zero_weight_is_l1": [],
  "test_elastic_net_hessian": [],
  "test_elastic_net_hessian_raises": [],
  "test_elastic_net_proximal_operator": [],
  "test_normalize_normalizes": [],
  "test_normalize_doesnt_normalize": [],
  "test_normalize_normalizes_if_intercept_not_present": [],
  "test_normalize_raises_if_multiple_constants": [],
  "test_add_intercept": [],
  "test_add_intercept_dask": [],
  "test_add_intercept_sparse": [],
  "test_add_intercept_sparse_dask": [],
  "test_sparse": [],
  "test_dask_array_is_sparse": [],
  "test_dok_dask_array_is_sparse": [],
  "test_dot_with_cupy": [],
  "test_dot_with_sparse": [],
  "pytest_addoption": [
    "parser"
  ],
  "pytest_configure": [
    "config"
  ],
  "pytest_collection_modifyitems": [
    "config",
    "items"
  ],
  "solver": [
    "request"
  ],
  "regularizer": [
    "request"
  ],
  "DoNothingTransformer": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "transform": [
      "self",
      "X",
      "y"
    ],
    "fit_transform": [
      "self",
      "X",
      "y"
    ],
    "get_params": [
      "self",
      "deep"
    ]
  },
  "test_lr_init": [
    "solver"
  ],
  "test_pr_init": [
    "solver"
  ],
  "_maybe_skip_sparse_error": [
    "fit_intercept",
    "is_sparse",
    "is_cupy"
  ],
  "test_fit": [
    "fit_intercept",
    "is_sparse",
    "is_cupy"
  ],
  "test_lm": [
    "fit_intercept",
    "is_sparse",
    "is_cupy"
  ],
  "test_big": [
    "fit_intercept",
    "is_sparse",
    "is_cupy"
  ],
  "test_poisson_fit": [
    "fit_intercept",
    "is_sparse",
    "is_cupy"
  ],
  "test_in_pipeline": [],
  "test_gridsearch": []
}