{
  "INCLUSIVE_MIN_TF_VERSION": [],
  "EXCLUSIVE_MAX_TF_VERSION": [],
  "_MAJOR_VERSION": [],
  "_MINOR_VERSION": [],
  "_PATCH_VERSION": [],
  "_VERSION_SUFFIX": [],
  "__version__": [],
  "register_all": [
    "keras_objects",
    "custom_kernels"
  ],
  "register_keras_objects": [],
  "register_custom_kernels": [],
  "_get_all_shared_objects": [],
  "add_doctest_namespace": [
    "doctest_namespace"
  ],
  "_FALLBACK_WARNING_TEMPLATE": [],
  "warn_fallback": [
    "op_name"
  ],
  "enable_custom_kernel": [],
  "disable_custom_kernel": [],
  "is_custom_kernel_disabled": [],
  "tanhshrink": [
    "x"
  ],
  "sparsemax": [
    "logits",
    "axis"
  ],
  "_swap_axis": [
    "logits",
    "dim_index",
    "last_index"
  ],
  "_compute_2d_sparsemax": [
    "logits"
  ],
  "rrelu": [
    "x",
    "lower",
    "upper",
    "training",
    "seed",
    "rng"
  ],
  "softshrink": [
    "x",
    "lower",
    "upper"
  ],
  "gelu": [
    "x",
    "approximate"
  ],
  "mish": [
    "x"
  ],
  "snake": [
    "x",
    "frequency"
  ],
  "hardshrink": [
    "x",
    "lower",
    "upper"
  ],
  "lisht": [
    "x"
  ],
  "check_metric_serialization": [
    "metric",
    "y_true",
    "y_pred",
    "sample_weight",
    "strict"
  ],
  "check_config": [
    "config",
    "class_",
    "strict"
  ],
  "assert_all_arrays_close": [
    "list1",
    "list2"
  ],
  "get_random_array": [
    "shape"
  ],
  "WeightedKappaLoss": {
    "__init__": [
      "self",
      "num_classes",
      "weightage",
      "name",
      "epsilon",
      "reduction"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_config": [
      "self"
    ]
  },
  "sparsemax_loss": [
    "logits",
    "sparsemax",
    "labels",
    "name"
  ],
  "sparsemax_loss_from_logits": [
    "y_true",
    "logits_pred"
  ],
  "SparsemaxLoss": {
    "__init__": [
      "self",
      "from_logits",
      "reduction",
      "name"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_config": [
      "self"
    ]
  },
  "npairs_loss": [
    "y_true",
    "y_pred"
  ],
  "npairs_multilabel_loss": [
    "y_true",
    "y_pred"
  ],
  "NpairsLoss": {
    "__init__": [
      "self",
      "name"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "NpairsMultilabelLoss": {
    "__init__": [
      "self",
      "name"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "lifted_struct_loss": [
    "labels",
    "embeddings",
    "margin"
  ],
  "LiftedStructLoss": {
    "__init__": [
      "self",
      "margin",
      "name"
    ]
  },
  "SigmoidFocalCrossEntropy": {
    "__init__": [
      "self",
      "from_logits",
      "alpha",
      "gamma",
      "reduction",
      "name"
    ]
  },
  "sigmoid_focal_crossentropy": [
    "y_true",
    "y_pred",
    "alpha",
    "gamma",
    "from_logits"
  ],
  "pinball_loss": [
    "y_true",
    "y_pred",
    "tau"
  ],
  "PinballLoss": {
    "__init__": [
      "self",
      "tau",
      "reduction",
      "name"
    ]
  },
  "_masked_maximum": [
    "data",
    "mask",
    "dim"
  ],
  "_masked_minimum": [
    "data",
    "mask",
    "dim"
  ],
  "triplet_semihard_loss": [
    "y_true",
    "y_pred",
    "margin",
    "distance_metric"
  ],
  "triplet_hard_loss": [
    "y_true",
    "y_pred",
    "margin",
    "soft",
    "distance_metric"
  ],
  "TripletSemiHardLoss": {
    "__init__": [
      "self",
      "margin",
      "distance_metric",
      "name"
    ]
  },
  "TripletHardLoss": {
    "__init__": [
      "self",
      "margin",
      "soft",
      "distance_metric",
      "name"
    ]
  },
  "contrastive_loss": [
    "y_true",
    "y_pred",
    "margin"
  ],
  "ContrastiveLoss": {
    "__init__": [
      "self",
      "margin",
      "reduction",
      "name"
    ]
  },
  "GIoULoss": {
    "__init__": [
      "self",
      "mode",
      "reduction",
      "name"
    ]
  },
  "giou_loss": [
    "y_true",
    "y_pred",
    "mode"
  ],
  "_calculate_giou": [
    "b1",
    "b2",
    "mode"
  ],
  "pairwise_distance": [
    "feature",
    "squared"
  ],
  "angular_distance": [
    "feature"
  ],
  "MultiLabelConfusionMatrix": {
    "__init__": [
      "self",
      "num_classes",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "CorrelationBase": {
    "__init__": [
      "self",
      "actual_min",
      "actual_max",
      "preds_min",
      "preds_max",
      "actual_cutpoints",
      "preds_cutpoints",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "KendallsTauBase": {
    "_compute_variables": [
      "self"
    ]
  },
  "KendallsTauB": {
    "result": [
      "self"
    ]
  },
  "KendallsTauC": {
    "result": [
      "self"
    ]
  },
  "SpearmansRank": {
    "result": [
      "self"
    ]
  },
  "PearsonsCorrelation": {
    "result": [
      "self"
    ]
  },
  "HarmonicMean": {
    "__init__": [
      "self",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "values",
      "sample_weight"
    ],
    "result": [
      "self"
    ]
  },
  "MeanMetricWrapper": {
    "__init__": [
      "self",
      "fn",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "get_config": [
      "self"
    ]
  },
  "_get_model": [
    "metric",
    "num_output"
  ],
  "sample_weight_shape_match": [
    "v",
    "sample_weight"
  ],
  "GeometricMean": {
    "__init__": [
      "self",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "values",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "CohenKappa": {
    "__init__": [
      "self",
      "num_classes",
      "name",
      "weightage",
      "sparse_labels",
      "regression",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "_update_binary_class_model": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "_update_multi_class_model": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "_cast_ypred": [
      "self",
      "y_pred"
    ],
    "_safe_squeeze": [
      "self",
      "y"
    ],
    "_update_confusion_matrix": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "MatthewsCorrelationCoefficient": {
    "__init__": [
      "self",
      "num_classes",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "_VALID_MULTIOUTPUT": [],
  "_reduce_average": [
    "input_tensor",
    "axis",
    "keepdims",
    "weights"
  ],
  "RSquare": {
    "__init__": [
      "self",
      "name",
      "dtype",
      "multioutput",
      "num_regressors"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ],
    "get_config": [
      "self"
    ]
  },
  "hamming_distance": [
    "actuals",
    "predictions"
  ],
  "hamming_loss_fn": [
    "y_true",
    "y_pred",
    "threshold",
    "mode"
  ],
  "HammingLoss": {
    "__init__": [
      "self",
      "mode",
      "name",
      "threshold",
      "dtype"
    ]
  },
  "FBetaScore": {
    "__init__": [
      "self",
      "num_classes",
      "average",
      "beta",
      "threshold",
      "name",
      "dtype"
    ],
    "update_state": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "result": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "reset_state": [
      "self"
    ],
    "reset_states": [
      "self"
    ]
  },
  "F1Score": {
    "__init__": [
      "self",
      "num_classes",
      "average",
      "threshold",
      "name",
      "dtype"
    ],
    "get_config": [
      "self"
    ]
  },
  "LayerNormLSTMCell": {
    "__init__": [
      "self",
      "units",
      "activation",
      "recurrent_activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "unit_forget_bias",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "norm_gamma_initializer",
      "norm_beta_initializer",
      "norm_epsilon"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "states",
      "training"
    ],
    "get_config": [
      "self"
    ],
    "_create_norm_layer": [
      "self",
      "name"
    ]
  },
  "ESNCell": {
    "__init__": [
      "self",
      "units",
      "connectivity",
      "leaky",
      "spectral_radius",
      "use_norm2",
      "use_bias",
      "activation",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer"
    ],
    "state_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "build": [
      "self",
      "inputs_shape"
    ],
    "call": [
      "self",
      "inputs",
      "state"
    ],
    "get_config": [
      "self"
    ]
  },
  "LayerNormSimpleRNNCell": {
    "__init__": [
      "self",
      "units",
      "activation",
      "use_bias",
      "layernorm_epsilon",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "gamma_initializer",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "gamma_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "gamma_constraint",
      "dropout",
      "recurrent_dropout"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "states",
      "training"
    ],
    "get_config": [
      "self"
    ]
  },
  "_generate_zero_filled_state_for_cell": [
    "cell",
    "inputs",
    "batch_size",
    "dtype"
  ],
  "_generate_zero_filled_state": [
    "batch_size_tensor",
    "state_size",
    "dtype"
  ],
  "AbstractRNNCell": {
    "call": [
      "self",
      "inputs",
      "states"
    ],
    "state_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "get_initial_state": [
      "self",
      "inputs",
      "batch_size",
      "dtype"
    ]
  },
  "PeepholeLSTMCell": {
    "build": [
      "self",
      "input_shape"
    ],
    "_compute_carry_and_output": [
      "self",
      "x",
      "h_tm1",
      "c_tm1"
    ],
    "_compute_carry_and_output_fused": [
      "self",
      "z",
      "c_tm1"
    ]
  },
  "NASCell": {
    "_NAS_BASE": [],
    "__init__": [
      "self",
      "units",
      "projection",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "projection_initializer",
      "bias_initializer"
    ],
    "state_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "build": [
      "self",
      "inputs_shape"
    ],
    "call": [
      "self",
      "inputs",
      "state"
    ],
    "get_config": [
      "self"
    ]
  },
  "CRFModelWrapper": {
    "__init__": [
      "self",
      "base_model",
      "units",
      "chain_initializer",
      "use_boundary",
      "boundary_initializer",
      "use_kernel"
    ],
    "unpack_training_data": [
      "self",
      "data"
    ],
    "call": [
      "self",
      "inputs",
      "training",
      "mask",
      "return_crf_internal"
    ],
    "compute_crf_loss": [
      "self",
      "potentials",
      "sequence_length",
      "kernel",
      "y",
      "sample_weight"
    ],
    "train_step": [
      "self",
      "data"
    ],
    "test_step": [
      "self",
      "data"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "crf_filtered_inputs": [
    "inputs",
    "tag_bitmap"
  ],
  "crf_sequence_score": [
    "inputs",
    "tag_indices",
    "sequence_lengths",
    "transition_params"
  ],
  "crf_multitag_sequence_score": [
    "inputs",
    "tag_bitmap",
    "sequence_lengths",
    "transition_params"
  ],
  "crf_log_norm": [
    "inputs",
    "sequence_lengths",
    "transition_params"
  ],
  "crf_log_likelihood": [
    "inputs",
    "tag_indices",
    "sequence_lengths",
    "transition_params"
  ],
  "crf_unary_score": [
    "tag_indices",
    "sequence_lengths",
    "inputs"
  ],
  "crf_binary_score": [
    "tag_indices",
    "sequence_lengths",
    "transition_params"
  ],
  "crf_forward": [
    "inputs",
    "state",
    "transition_params",
    "sequence_lengths"
  ],
  "viterbi_decode": [
    "score",
    "transition_params"
  ],
  "CrfDecodeForwardRnnCell": {
    "__init__": [
      "self",
      "transition_params"
    ],
    "state_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "state"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "crf_decode_forward": [
    "inputs",
    "state",
    "transition_params",
    "sequence_lengths"
  ],
  "crf_decode_backward": [
    "inputs",
    "state"
  ],
  "crf_decode": [
    "potentials",
    "transition_params",
    "sequence_length"
  ],
  "crf_constrained_decode": [
    "potentials",
    "tag_bitmap",
    "transition_params",
    "sequence_length"
  ],
  "_skip_gram_so": [],
  "skip_gram_sample": [
    "input_tensor",
    "min_skips",
    "max_skips",
    "start",
    "limit",
    "emit_self_as_target",
    "vocab_freq_table",
    "vocab_min_count",
    "vocab_subsampling",
    "corpus_size",
    "seed",
    "name"
  ],
  "skip_gram_sample_with_text_vocab": [
    "input_tensor",
    "vocab_freq_file",
    "vocab_token_index",
    "vocab_token_dtype",
    "vocab_freq_index",
    "vocab_freq_dtype",
    "vocab_delimiter",
    "vocab_min_count",
    "vocab_subsampling",
    "corpus_size",
    "min_skips",
    "max_skips",
    "start",
    "limit",
    "emit_self_as_target",
    "seed",
    "name"
  ],
  "_filter_input": [
    "input_tensor",
    "vocab_freq_table",
    "vocab_min_count",
    "vocab_subsampling",
    "corpus_size",
    "seed"
  ],
  "IS_WINDOWS": [],
  "_parse_time_so": [],
  "parse_time": [
    "time_string",
    "time_format",
    "output_unit"
  ],
  "_check_tf_version": [],
  "is_tensor_or_variable": [
    "x"
  ],
  "LossFunctionWrapper": {
    "__init__": [
      "self",
      "fn",
      "reduction",
      "name"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ],
    "get_config": [
      "self"
    ]
  },
  "normalize_data_format": [
    "value"
  ],
  "normalize_tuple": [
    "value",
    "n",
    "name"
  ],
  "_hasattr": [
    "obj",
    "attr_name"
  ],
  "assert_like_rnncell": [
    "cell_name",
    "cell"
  ],
  "NUMBER_OF_WORKERS": [],
  "WORKER_ID": [],
  "NUMBER_OF_GPUS": [],
  "is_gpu_available": [],
  "finalizer": [],
  "pytest_make_parametrize_id": [
    "config",
    "val",
    "argname"
  ],
  "maybe_run_functions_eagerly": [
    "request"
  ],
  "only_run_functions_eagerly": [
    "request"
  ],
  "run_custom_and_py_ops": [
    "request"
  ],
  "run_with_mixed_precision_policy": [
    "request"
  ],
  "data_format": [
    "request"
  ],
  "set_seeds": [],
  "pytest_addoption": [
    "parser"
  ],
  "gpus_for_testing": [],
  "set_global_variables": [
    "request"
  ],
  "pytest_configure": [
    "config"
  ],
  "device": [
    "request"
  ],
  "get_marks": [
    "device_name"
  ],
  "pytest_generate_tests": [
    "metafunc"
  ],
  "pytest_collection_modifyitems": [
    "items"
  ],
  "assert_not_allclose": [
    "a",
    "b"
  ],
  "assert_allclose_according_to_type": [
    "a",
    "b",
    "rtol",
    "atol",
    "float_rtol",
    "float_atol",
    "half_rtol",
    "half_atol",
    "bfloat16_rtol",
    "bfloat16_atol"
  ],
  "discover_classes": [
    "module",
    "parent",
    "class_exceptions"
  ],
  "string_test": [
    "actual",
    "expected"
  ],
  "numeric_test": [
    "actual",
    "expected"
  ],
  "layer_test": [
    "layer_cls",
    "kwargs",
    "input_shape",
    "input_dtype",
    "input_data",
    "expected_output",
    "expected_output_dtype",
    "expected_output_shape",
    "validate_training",
    "adapt_data",
    "custom_objects",
    "test_harness",
    "supports_masking"
  ],
  "_thread_local_data": [],
  "should_run_eagerly": [],
  "Number": [],
  "Initializer": [],
  "Regularizer": [],
  "Constraint": [],
  "Activation": [],
  "TensorLike": [],
  "FloatTensorLike": [],
  "AcceptableDTypes": [],
  "INCLUSIVE_MIN_TF_VERSION_FOR_ABI_COMPATIBILITY": [],
  "EXCLUSIVE_MAX_TF_VERSION_FOR_ABI_COMPATIBILITY": [],
  "abi_warning_already_raised": [],
  "SKIP_CUSTOM_OPS": [],
  "get_project_root": [],
  "get_path_to_datafile": [
    "path",
    "is_so"
  ],
  "LazySO": {
    "__init__": [
      "self",
      "relative_path"
    ],
    "ops": [
      "self"
    ],
    "display_warning_if_incompatible": [
      "self"
    ]
  },
  "abi_is_compatible": [],
  "_convert_maybe_argspec_to_fullargspec": [
    "argspec"
  ],
  "currentframe": [],
  "getargspec": [
    "obj"
  ],
  "_get_argspec_for_partial": [
    "obj"
  ],
  "getfullargspec": [
    "obj"
  ],
  "_print_eol_warning": [],
  "AverageModelCheckpoint": {
    "__init__": [
      "self",
      "update_weights",
      "filepath",
      "monitor",
      "verbose",
      "save_best_only",
      "save_weights_only",
      "mode",
      "save_freq"
    ],
    "_get_optimizer": [
      "self"
    ],
    "set_model": [
      "self",
      "model"
    ],
    "_save_model": [
      "self"
    ]
  },
  "TQDMProgressBar": {
    "__init__": [
      "self",
      "metrics_separator",
      "overall_bar_format",
      "epoch_bar_format",
      "metrics_format",
      "update_per_second",
      "leave_epoch_progress",
      "leave_overall_progress",
      "show_epoch_progress",
      "show_overall_progress"
    ],
    "_initialize_progbar": [
      "self",
      "hook",
      "epoch",
      "logs"
    ],
    "_clean_up_progbar": [
      "self",
      "hook",
      "logs"
    ],
    "_update_progbar": [
      "self",
      "logs"
    ],
    "on_train_begin": [
      "self",
      "logs"
    ],
    "on_train_end": [
      "self",
      "logs"
    ],
    "on_test_begin": [
      "self",
      "logs"
    ],
    "on_test_end": [
      "self",
      "logs"
    ],
    "on_epoch_begin": [
      "self",
      "epoch",
      "logs"
    ],
    "on_epoch_end": [
      "self",
      "epoch",
      "logs"
    ],
    "on_test_batch_end": [
      "self",
      "batch",
      "logs"
    ],
    "on_batch_end": [
      "self",
      "batch",
      "logs"
    ],
    "format_metrics": [
      "self",
      "logs",
      "factor"
    ],
    "get_config": [
      "self"
    ]
  },
  "TimeStopping": {
    "__init__": [
      "self",
      "seconds",
      "verbose"
    ],
    "on_train_begin": [
      "self",
      "logs"
    ],
    "on_epoch_end": [
      "self",
      "epoch",
      "logs"
    ],
    "on_train_end": [
      "self",
      "logs"
    ],
    "get_config": [
      "self"
    ]
  },
  "translations_to_projective_transforms": [
    "translations",
    "name"
  ],
  "translate": [
    "images",
    "translations",
    "interpolation",
    "fill_mode",
    "name",
    "fill_value"
  ],
  "translate_xy": [
    "image",
    "translate_to",
    "replace"
  ],
  "_IMAGE_DTYPES": [],
  "transform": [
    "images",
    "transforms",
    "interpolation",
    "fill_mode",
    "output_shape",
    "name",
    "fill_value"
  ],
  "compose_transforms": [
    "transforms",
    "name"
  ],
  "flat_transforms_to_matrices": [
    "transforms",
    "name"
  ],
  "matrices_to_flat_transforms": [
    "transform_matrices",
    "name"
  ],
  "angles_to_projective_transforms": [
    "angles",
    "image_height",
    "image_width",
    "name"
  ],
  "rotate": [
    "images",
    "angles",
    "interpolation",
    "fill_mode",
    "name",
    "fill_value"
  ],
  "shear_x": [
    "image",
    "level",
    "replace"
  ],
  "shear_y": [
    "image",
    "level",
    "replace"
  ],
  "_resampler_so": [],
  "resampler": [
    "data",
    "warp",
    "name"
  ],
  "_resampler_grad": [
    "op",
    "grad_output"
  ],
  "_pad": [
    "image",
    "filter_shape",
    "mode",
    "constant_values"
  ],
  "mean_filter2d": [
    "image",
    "filter_shape",
    "padding",
    "constant_values",
    "name"
  ],
  "median_filter2d": [
    "image",
    "filter_shape",
    "padding",
    "constant_values",
    "name"
  ],
  "_get_gaussian_kernel": [
    "sigma",
    "filter_shape"
  ],
  "_get_gaussian_kernel_2d": [
    "gaussian_filter_x",
    "gaussian_filter_y"
  ],
  "gaussian_filter2d": [
    "image",
    "filter_shape",
    "sigma",
    "padding",
    "constant_values",
    "name"
  ],
  "blend": [
    "image1",
    "image2",
    "factor"
  ],
  "get_ndims": [
    "image"
  ],
  "to_4D_image": [
    "image"
  ],
  "_dynamic_to_4D_image": [
    "image"
  ],
  "from_4D_image": [
    "image",
    "ndims"
  ],
  "_dynamic_from_4D_image": [
    "image",
    "original_rank"
  ],
  "wrap": [
    "image"
  ],
  "unwrap": [
    "image",
    "replace"
  ],
  "_norm_params": [
    "mask_size",
    "offset"
  ],
  "_random_center": [
    "mask_dim_length",
    "image_dim_length",
    "batch_size",
    "seed"
  ],
  "random_cutout": [
    "images",
    "mask_size",
    "constant_values",
    "seed"
  ],
  "cutout": [
    "images",
    "mask_size",
    "offset",
    "constant_values"
  ],
  "_generate_masks": [
    "args"
  ],
  "_image_so": [],
  "connected_components": [
    "images",
    "name"
  ],
  "euclidean_dist_transform": [
    "images",
    "dtype",
    "name"
  ],
  "interpolate_bilinear": [
    "grid",
    "query_points",
    "indexing",
    "name"
  ],
  "_interpolate_bilinear_with_checks": [
    "grid",
    "query_points",
    "indexing",
    "name"
  ],
  "_interpolate_bilinear_impl": [
    "grid",
    "query_points",
    "indexing",
    "name"
  ],
  "_get_dim": [
    "x",
    "idx"
  ],
  "dense_image_warp": [
    "image",
    "flow",
    "name"
  ],
  "dense_image_warp_annotated": [
    "image",
    "flow"
  ],
  "_get_grid_locations": [
    "image_height",
    "image_width"
  ],
  "_expand_to_minibatch": [
    "array",
    "batch_size"
  ],
  "_get_boundary_locations": [
    "image_height",
    "image_width",
    "num_points_per_edge"
  ],
  "_add_zero_flow_controls_at_boundary": [
    "control_point_locations",
    "control_point_flows",
    "image_height",
    "image_width",
    "boundary_points_per_edge"
  ],
  "sparse_image_warp": [
    "image",
    "source_control_point_locations",
    "dest_control_point_locations",
    "interpolation_order",
    "regularization_weight",
    "num_boundary_points",
    "name"
  ],
  "_distort_image_so": [],
  "random_hsv_in_yiq": [
    "image",
    "max_delta_hue",
    "lower_saturation",
    "upper_saturation",
    "lower_value",
    "upper_value",
    "seed",
    "name"
  ],
  "_adjust_hsv_in_yiq": [
    "image",
    "delta_hue",
    "scale_saturation",
    "scale_value"
  ],
  "adjust_hsv_in_yiq": [
    "image",
    "delta_hue",
    "scale_saturation",
    "scale_value",
    "name"
  ],
  "EPSILON": [],
  "_cross_squared_distance_matrix": [
    "x",
    "y"
  ],
  "_pairwise_squared_distance_matrix": [
    "x"
  ],
  "_solve_interpolation": [
    "train_points",
    "train_values",
    "order",
    "regularization_weight"
  ],
  "_apply_interpolation": [
    "query_points",
    "train_points",
    "w",
    "v",
    "order"
  ],
  "_phi": [
    "r",
    "order"
  ],
  "interpolate_spline": [
    "train_points",
    "train_values",
    "query_points",
    "order",
    "regularization_weight",
    "name"
  ],
  "_scale_channel": [
    "image",
    "channel",
    "bins"
  ],
  "_equalize_image": [
    "image",
    "bins"
  ],
  "equalize": [
    "image",
    "bins",
    "name"
  ],
  "_sharpness_image": [
    "image",
    "factor"
  ],
  "sharpness": [
    "image",
    "factor",
    "name"
  ],
  "CyclicalLearningRate": {
    "__init__": [
      "self",
      "initial_learning_rate",
      "maximal_learning_rate",
      "step_size",
      "scale_fn",
      "scale_mode",
      "name"
    ],
    "__call__": [
      "self",
      "step"
    ],
    "get_config": [
      "self"
    ]
  },
  "TriangularCyclicalLearningRate": {
    "__init__": [
      "self",
      "initial_learning_rate",
      "maximal_learning_rate",
      "step_size",
      "scale_mode",
      "name"
    ],
    "get_config": [
      "self"
    ]
  },
  "Triangular2CyclicalLearningRate": {
    "__init__": [
      "self",
      "initial_learning_rate",
      "maximal_learning_rate",
      "step_size",
      "scale_mode",
      "name"
    ],
    "get_config": [
      "self"
    ]
  },
  "ExponentialCyclicalLearningRate": {
    "__init__": [
      "self",
      "initial_learning_rate",
      "maximal_learning_rate",
      "step_size",
      "scale_mode",
      "gamma",
      "name"
    ],
    "get_config": [
      "self"
    ]
  },
  "LazyAdam": {
    "__init__": [
      "self",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "amsgrad",
      "name"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices"
    ],
    "_resource_scatter_update": [
      "self",
      "resource",
      "indices",
      "update"
    ],
    "_resource_scatter_sub": [
      "self",
      "resource",
      "indices",
      "update"
    ],
    "_resource_scatter_operate": [
      "self",
      "resource",
      "indices",
      "update",
      "resource_scatter_op"
    ],
    "get_config": [
      "self"
    ]
  },
  "ProximalAdagrad": {
    "__init__": [
      "self",
      "learning_rate",
      "initial_accumulator_value",
      "l1_regularization_strength",
      "l2_regularization_strength",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "get_config": [
      "self"
    ]
  },
  "Lookahead": {
    "__init__": [
      "self",
      "optimizer",
      "sync_period",
      "slow_step_size",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_create_hypers": [
      "self"
    ],
    "_prepare": [
      "self",
      "var_list"
    ],
    "apply_gradients": [
      "self",
      "grads_and_vars",
      "name"
    ],
    "_look_ahead_op": [
      "self",
      "var"
    ],
    "weights": [
      "self"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices"
    ],
    "get_config": [
      "self"
    ],
    "learning_rate": [
      "self",
      "learning_rate"
    ],
    "lr": [
      "self",
      "lr"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ]
  },
  "ConditionalGradient": {
    "__init__": [
      "self",
      "learning_rate",
      "lambda_",
      "epsilon",
      "ord",
      "name"
    ],
    "get_config": [
      "self"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "_frobenius_norm": [
      "m"
    ],
    "_top_singular_vector": [
      "m"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ]
  },
  "MultiOptimizer": {
    "__init__": [
      "self",
      "optimizers_and_layers",
      "optimizer_specs",
      "name"
    ],
    "apply_gradients": [
      "self",
      "grads_and_vars"
    ],
    "get_config": [
      "self"
    ],
    "create_optimizer_spec": [
      "cls",
      "optimizer",
      "layers_or_model"
    ],
    "maybe_initialize_optimizer_spec": [
      "cls",
      "optimizer_spec"
    ],
    "__repr__": [
      "self"
    ]
  },
  "fit_bn": [
    "model"
  ],
  "get_variable_name": [
    "variable"
  ],
  "is_variable_matched_by_regexes": [
    "variable",
    "regexes"
  ],
  "LAMB": {
    "__init__": [
      "self",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "weight_decay",
      "exclude_from_weight_decay",
      "exclude_from_layer_adaptation",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "get_config": [
      "self"
    ],
    "_do_use_weight_decay": [
      "self",
      "variable"
    ],
    "_do_layer_adaptation": [
      "self",
      "variable"
    ]
  },
  "AdaBelief": {
    "__init__": [
      "self",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "weight_decay",
      "amsgrad",
      "rectify",
      "sma_threshold",
      "total_steps",
      "warmup_proportion",
      "min_lr",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "set_weights": [
      "self",
      "weights"
    ],
    "_decayed_wd": [
      "self",
      "var_dtype"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices"
    ],
    "get_config": [
      "self"
    ]
  },
  "DecoupledWeightDecayExtension": {
    "__init__": [
      "self",
      "weight_decay",
      "exclude_from_weight_decay"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ],
    "minimize": [
      "self",
      "loss",
      "var_list",
      "grad_loss",
      "name",
      "decay_var_list",
      "tape"
    ],
    "apply_gradients": [
      "self",
      "grads_and_vars",
      "name",
      "decay_var_list"
    ],
    "_decay_weights_op": [
      "self",
      "var",
      "apply_state"
    ],
    "_decay_weights_sparse_op": [
      "self",
      "var",
      "indices",
      "apply_state"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "_decayed_wd": [
      "self",
      "var_dtype"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "_set_decay_var_list": [
      "self",
      "var_list",
      "decay_var_list"
    ],
    "_do_use_weight_decay": [
      "self",
      "var"
    ]
  },
  "extend_with_decoupled_weight_decay": [
    "base_optimizer"
  ],
  "SGDW": {
    "__init__": [
      "self",
      "weight_decay",
      "learning_rate",
      "momentum",
      "nesterov",
      "name"
    ]
  },
  "AdamW": {
    "__init__": [
      "self",
      "weight_decay",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "amsgrad",
      "name"
    ]
  },
  "SWA": {
    "__init__": [
      "self",
      "optimizer",
      "start_averaging",
      "average_period",
      "name"
    ],
    "average_op": [
      "self",
      "var",
      "average_var",
      "local_apply_state"
    ],
    "get_config": [
      "self"
    ]
  },
  "AveragedOptimizerWrapper": {
    "__init__": [
      "self",
      "optimizer",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_create_hypers": [
      "self"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "apply_gradients": [
      "self",
      "grads_and_vars",
      "name"
    ],
    "average_op": [
      "self",
      "var",
      "average_var",
      "local_apply_state"
    ],
    "_apply_average_op": [
      "self",
      "train_op",
      "var",
      "apply_state"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "_resource_apply_sparse_duplicate_indices": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "assign_average_vars": [
      "self",
      "var_list"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ],
    "weights": [
      "self"
    ],
    "lr": [
      "self",
      "lr"
    ],
    "learning_rate": [
      "self",
      "learning_rate"
    ]
  },
  "RectifiedAdam": {
    "__init__": [
      "self",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "weight_decay",
      "amsgrad",
      "sma_threshold",
      "total_steps",
      "warmup_proportion",
      "min_lr",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "set_weights": [
      "self",
      "weights"
    ],
    "_decayed_wd": [
      "self",
      "var_dtype"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "get_config": [
      "self"
    ]
  },
  "NovoGrad": {
    "__init__": [
      "self",
      "learning_rate",
      "beta_1",
      "beta_2",
      "epsilon",
      "weight_decay",
      "grad_averaging",
      "amsgrad",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "set_weights": [
      "self",
      "weights"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices",
      "apply_state"
    ],
    "get_config": [
      "self"
    ]
  },
  "COCOB": {
    "__init__": [
      "self",
      "alpha",
      "use_locking",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "handle",
      "apply_state"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "handle",
      "indices",
      "apply_state"
    ],
    "get_config": [
      "self"
    ]
  },
  "_solve": [
    "a",
    "b",
    "c"
  ],
  "Yogi": {
    "__init__": [
      "self",
      "learning_rate",
      "beta1",
      "beta2",
      "epsilon",
      "l1_regularization_strength",
      "l2_regularization_strength",
      "initial_accumulator_value",
      "activation",
      "name"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "_resource_apply_dense": [
      "self",
      "grad",
      "var"
    ],
    "_resource_apply_sparse": [
      "self",
      "grad",
      "var",
      "indices"
    ],
    "get_config": [
      "self"
    ]
  },
  "MovingAverage": {
    "__init__": [
      "self",
      "optimizer",
      "average_decay",
      "num_updates",
      "start_step",
      "dynamic_decay",
      "name"
    ],
    "_get_decay": [
      "self",
      "step"
    ],
    "_prepare_local": [
      "self",
      "var_device",
      "var_dtype",
      "apply_state"
    ],
    "average_op": [
      "self",
      "var",
      "average_var",
      "local_apply_state"
    ],
    "get_config": [
      "self"
    ],
    "_create_slots": [
      "self",
      "var_list"
    ],
    "shadow_copy": [
      "self",
      "model_weights"
    ],
    "has_shadow_copy": [
      "self"
    ],
    "swap_weights": [
      "self"
    ],
    "_swap_weights": [
      "self"
    ]
  },
  "_embedding_bag_so": [],
  "_embedding_bag": [
    "indices",
    "params",
    "weights",
    "combiner",
    "name"
  ],
  "_embedding_bag_grad": [
    "op",
    "grads"
  ],
  "EmbeddingBag": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "embeddings_initializer",
      "embeddings_regularizer",
      "embeddings_constraint",
      "mask_zero",
      "combiner"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "indices",
      "weights"
    ],
    "get_config": [
      "self"
    ]
  },
  "ESN": {
    "__init__": [
      "self",
      "units",
      "connectivity",
      "leaky",
      "spectral_radius",
      "use_norm2",
      "use_bias",
      "activation",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "return_sequences",
      "go_backwards",
      "unroll"
    ],
    "call": [
      "self",
      "inputs",
      "mask",
      "training",
      "initial_state"
    ],
    "units": [
      "self"
    ],
    "connectivity": [
      "self"
    ],
    "leaky": [
      "self"
    ],
    "spectral_radius": [
      "self"
    ],
    "use_norm2": [
      "self"
    ],
    "use_bias": [
      "self"
    ],
    "activation": [
      "self"
    ],
    "kernel_initializer": [
      "self"
    ],
    "recurrent_initializer": [
      "self"
    ],
    "bias_initializer": [
      "self"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config"
    ]
  },
  "SpectralNormalization": {
    "__init__": [
      "self",
      "layer",
      "power_iterations"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "training"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "normalize_weights": [
      "self"
    ],
    "get_config": [
      "self"
    ]
  },
  "Sparsemax": {
    "__init__": [
      "self",
      "axis"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ]
  },
  "GroupNormalization": {
    "__init__": [
      "self",
      "groups",
      "axis",
      "epsilon",
      "center",
      "scale",
      "beta_initializer",
      "gamma_initializer",
      "beta_regularizer",
      "gamma_regularizer",
      "beta_constraint",
      "gamma_constraint"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "_reshape_into_groups": [
      "self",
      "inputs",
      "input_shape",
      "tensor_input_shape"
    ],
    "_apply_normalization": [
      "self",
      "reshaped_inputs",
      "input_shape"
    ],
    "_get_reshaped_weights": [
      "self",
      "input_shape"
    ],
    "_check_if_input_shape_is_none": [
      "self",
      "input_shape"
    ],
    "_set_number_of_groups_for_instance_norm": [
      "self",
      "input_shape"
    ],
    "_check_size_of_dimensions": [
      "self",
      "input_shape"
    ],
    "_check_axis": [
      "self"
    ],
    "_create_input_spec": [
      "self",
      "input_shape"
    ],
    "_add_gamma_weight": [
      "self",
      "input_shape"
    ],
    "_add_beta_weight": [
      "self",
      "input_shape"
    ],
    "_create_broadcast_shape": [
      "self",
      "input_shape"
    ]
  },
  "InstanceNormalization": {
    "__init__": [
      "self"
    ]
  },
  "FilterResponseNormalization": {
    "__init__": [
      "self",
      "epsilon",
      "axis",
      "beta_initializer",
      "gamma_initializer",
      "beta_regularizer",
      "gamma_regularizer",
      "beta_constraint",
      "gamma_constraint",
      "learned_epsilon",
      "learned_epsilon_constraint",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "_create_input_spec": [
      "self",
      "input_shape"
    ],
    "_check_axis": [
      "self",
      "axis"
    ],
    "_check_if_input_shape_is_none": [
      "self",
      "input_shape"
    ],
    "_add_gamma_weight": [
      "self",
      "input_shape"
    ],
    "_add_beta_weight": [
      "self",
      "input_shape"
    ]
  },
  "SpatialPyramidPooling2D": {
    "__init__": [
      "self",
      "bins",
      "data_format"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "TLU": {
    "__init__": [
      "self",
      "affine",
      "tau_initializer",
      "tau_regularizer",
      "tau_constraint",
      "alpha_initializer",
      "alpha_regularizer",
      "alpha_constraint"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ]
  },
  "GELU": {
    "__init__": [
      "self",
      "approximate"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ]
  },
  "PolynomialCrossing": {
    "__init__": [
      "self",
      "projection_dim",
      "diag_scale",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ]
  },
  "_scaled_noise": [
    "size",
    "dtype"
  ],
  "NoisyDense": {
    "__init__": [
      "self",
      "units",
      "sigma",
      "use_factorised",
      "activation",
      "use_bias",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "kernel": [
      "self"
    ],
    "bias": [
      "self"
    ],
    "reset_noise": [
      "self"
    ],
    "remove_noise": [
      "self"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ]
  },
  "WeightNormalization": {
    "__init__": [
      "self",
      "layer",
      "data_init"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "_initialize_weights": [
      "self",
      "inputs"
    ],
    "_init_norm": [
      "self"
    ],
    "_data_dep_init": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ],
    "remove": [
      "self"
    ]
  },
  "NetVLAD": {
    "__init__": [
      "self",
      "num_clusters"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "frames"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "AdaptivePooling1D": {
    "__init__": [
      "self",
      "reduce_function",
      "output_size",
      "data_format"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "AdaptiveAveragePooling1D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "AdaptiveMaxPooling1D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "AdaptivePooling2D": {
    "__init__": [
      "self",
      "reduce_function",
      "output_size",
      "data_format"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "AdaptiveAveragePooling2D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "AdaptiveMaxPooling2D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "AdaptivePooling3D": {
    "__init__": [
      "self",
      "reduce_function",
      "output_size",
      "data_format"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "AdaptiveAveragePooling3D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "AdaptiveMaxPooling3D": {
    "__init__": [
      "self",
      "output_size",
      "data_format"
    ]
  },
  "CRF": {
    "__init__": [
      "self",
      "units",
      "chain_initializer",
      "use_boundary",
      "boundary_initializer",
      "use_kernel"
    ],
    "call": [
      "self",
      "inputs",
      "mask"
    ],
    "_get_sequence_length": [
      "self",
      "input_",
      "mask"
    ],
    "mask_to_sequence_length": [
      "self",
      "mask"
    ],
    "_compute_mask_right_boundary": [
      "mask"
    ],
    "_compute_mask_left_boundary": [
      "mask"
    ],
    "add_boundary_energy": [
      "self",
      "potentials",
      "mask",
      "start",
      "end"
    ],
    "get_viterbi_decoding": [
      "self",
      "potentials",
      "sequence_length"
    ],
    "get_config": [
      "self"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "compute_mask": [
      "self",
      "input_",
      "mask"
    ],
    "_compute_dtype": [
      "self"
    ]
  },
  "MultiHeadAttention": {
    "__init__": [
      "self",
      "head_size",
      "num_heads",
      "output_size",
      "dropout",
      "use_projection_bias",
      "return_attn_coef",
      "kernel_initializer",
      "kernel_regularizer",
      "kernel_constraint",
      "bias_initializer",
      "bias_regularizer",
      "bias_constraint"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs",
      "training",
      "mask"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "Snake": {
    "__init__": [
      "self",
      "frequency_initializer"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "get_config": [
      "self"
    ]
  },
  "_correlation_cost_so": [],
  "_correlation_cost": [
    "input_a",
    "input_b",
    "kernel_size",
    "max_displacement",
    "stride_1",
    "stride_2",
    "pad",
    "data_format",
    "name"
  ],
  "_correlation_cost_grad": [
    "op",
    "grad_output"
  ],
  "CorrelationCost": {
    "__init__": [
      "self",
      "kernel_size",
      "max_displacement",
      "stride_1",
      "stride_2",
      "pad",
      "data_format"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "_calculate_output_shape": [
    "input_shape",
    "pool_size",
    "strides",
    "padding"
  ],
  "_max_unpooling_2d": [
    "updates",
    "mask",
    "pool_size",
    "strides",
    "padding"
  ],
  "MaxUnpooling2D": {
    "__init__": [
      "self",
      "pool_size",
      "strides",
      "padding"
    ],
    "call": [
      "self",
      "updates",
      "mask"
    ],
    "compute_output_shape": [
      "self",
      "input_shapes"
    ],
    "get_config": [
      "self"
    ]
  },
  "StochasticDepth": {
    "__init__": [
      "self",
      "survival_probability"
    ],
    "call": [
      "self",
      "x",
      "training"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "_max_unpooling_2d_v2": [
    "updates",
    "mask",
    "output_size"
  ],
  "MaxUnpooling2DV2": {
    "__init__": [
      "self",
      "output_size"
    ],
    "call": [
      "self",
      "updates",
      "mask"
    ],
    "get_config": [
      "self"
    ]
  },
  "Maxout": {
    "__init__": [
      "self",
      "num_units",
      "axis"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "PoincareNormalize": {
    "__init__": [
      "self",
      "axis",
      "epsilon"
    ],
    "call": [
      "self",
      "inputs"
    ],
    "compute_output_shape": [
      "self",
      "input_shape"
    ],
    "get_config": [
      "self"
    ]
  },
  "sequence_loss": [
    "logits",
    "targets",
    "weights",
    "average_across_timesteps",
    "average_across_batch",
    "sum_over_timesteps",
    "sum_over_batch",
    "softmax_loss_function",
    "name"
  ],
  "SequenceLoss": {
    "__init__": [
      "self",
      "average_across_timesteps",
      "average_across_batch",
      "sum_over_timesteps",
      "sum_over_batch",
      "softmax_loss_function",
      "name"
    ],
    "__call__": [
      "self",
      "y_true",
      "y_pred",
      "sample_weight"
    ],
    "call": [
      "self",
      "y_true",
      "y_pred"
    ]
  },
  "AttentionMechanism": {
    "__init__": [
      "self",
      "memory",
      "probability_fn",
      "query_layer",
      "memory_layer",
      "memory_sequence_length"
    ],
    "memory_initialized": [
      "self"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "__call__": [
      "self",
      "inputs"
    ],
    "call": [
      "self",
      "inputs",
      "mask",
      "setup_memory"
    ],
    "setup_memory": [
      "self",
      "memory",
      "memory_sequence_length",
      "memory_mask"
    ],
    "_calculate_attention": [
      "self",
      "query",
      "state"
    ],
    "compute_mask": [
      "self",
      "inputs",
      "mask"
    ],
    "get_config": [
      "self"
    ],
    "_process_probability_fn": [
      "self",
      "func_name"
    ],
    "deserialize_inner_layer_from_config": [
      "cls",
      "config",
      "custom_objects"
    ],
    "alignments_size": [
      "self"
    ],
    "state_size": [
      "self"
    ],
    "initial_alignments": [
      "self",
      "batch_size",
      "dtype"
    ],
    "initial_state": [
      "self",
      "batch_size",
      "dtype"
    ]
  },
  "_luong_score": [
    "query",
    "keys",
    "scale"
  ],
  "LuongAttention": {
    "__init__": [
      "self",
      "units",
      "memory",
      "memory_sequence_length",
      "scale",
      "probability_fn",
      "dtype",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "_calculate_attention": [
      "self",
      "query",
      "state"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ]
  },
  "_bahdanau_score": [
    "processed_query",
    "keys",
    "attention_v",
    "attention_g",
    "attention_b"
  ],
  "BahdanauAttention": {
    "__init__": [
      "self",
      "units",
      "memory",
      "memory_sequence_length",
      "normalize",
      "probability_fn",
      "kernel_initializer",
      "dtype",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "_calculate_attention": [
      "self",
      "query",
      "state"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ]
  },
  "safe_cumprod": [
    "x"
  ],
  "monotonic_attention": [
    "p_choose_i",
    "previous_attention",
    "mode"
  ],
  "_monotonic_probability_fn": [
    "score",
    "previous_alignments",
    "sigmoid_noise",
    "mode",
    "seed"
  ],
  "_BaseMonotonicAttentionMechanism": {
    "initial_alignments": [
      "self",
      "batch_size",
      "dtype"
    ]
  },
  "BahdanauMonotonicAttention": {
    "__init__": [
      "self",
      "units",
      "memory",
      "memory_sequence_length",
      "normalize",
      "sigmoid_noise",
      "sigmoid_noise_seed",
      "score_bias_init",
      "mode",
      "kernel_initializer",
      "dtype",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "_calculate_attention": [
      "self",
      "query",
      "state"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ]
  },
  "LuongMonotonicAttention": {
    "__init__": [
      "self",
      "units",
      "memory",
      "memory_sequence_length",
      "scale",
      "sigmoid_noise",
      "sigmoid_noise_seed",
      "score_bias_init",
      "mode",
      "dtype",
      "name"
    ],
    "build": [
      "self",
      "input_shape"
    ],
    "_calculate_attention": [
      "self",
      "query",
      "state"
    ],
    "get_config": [
      "self"
    ],
    "from_config": [
      "cls",
      "config",
      "custom_objects"
    ]
  },
  "AttentionWrapperState": {
    "clone": [
      "self"
    ]
  },
  "_prepare_memory": [
    "memory",
    "memory_sequence_length",
    "memory_mask",
    "check_inner_dims_defined"
  ],
  "_maybe_mask_score": [
    "score",
    "memory_sequence_length",
    "memory_mask",
    "score_mask_value"
  ],
  "hardmax": [
    "logits",
    "name"
  ],
  "_compute_attention": [
    "attention_mechanism",
    "cell_output",
    "attention_state",
    "attention_layer"
  ],
  "AttentionWrapper": {
    "__init__": [
      "self",
      "cell",
      "attention_mechanism",
      "attention_layer_size",
      "alignment_history",
      "cell_input_fn",
      "output_attention",
      "initial_cell_state",
      "name",
      "attention_layer",
      "attention_fn"
    ],
    "_attention_mechanisms_checks": [
      "self"
    ],
    "_batch_size_checks": [
      "self",
      "batch_size",
      "error_message"
    ],
    "_get_attention_layer_size": [
      "self"
    ],
    "_item_or_tuple": [
      "self",
      "seq"
    ],
    "output_size": [
      "self"
    ],
    "state_size": [
      "self"
    ],
    "get_initial_state": [
      "self",
      "inputs",
      "batch_size",
      "dtype"
    ],
    "call": [
      "self",
      "inputs",
      "state"
    ]
  },
  "Decoder": {
    "batch_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "output_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "name"
    ],
    "step": [
      "self",
      "time",
      "inputs",
      "state",
      "training",
      "name"
    ],
    "finalize": [
      "self",
      "outputs",
      "final_state",
      "sequence_lengths"
    ],
    "tracks_own_finished": [
      "self"
    ]
  },
  "BaseDecoder": {
    "__init__": [
      "self",
      "output_time_major",
      "impute_finished",
      "maximum_iterations",
      "parallel_iterations",
      "swap_memory"
    ],
    "call": [
      "self",
      "inputs",
      "initial_state",
      "training"
    ],
    "batch_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "output_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "inputs",
      "initial_state"
    ],
    "step": [
      "self",
      "time",
      "inputs",
      "state",
      "training"
    ],
    "finalize": [
      "self",
      "outputs",
      "final_state",
      "sequence_lengths"
    ],
    "tracks_own_finished": [
      "self"
    ]
  },
  "dynamic_decode": [
    "decoder",
    "output_time_major",
    "impute_finished",
    "maximum_iterations",
    "parallel_iterations",
    "swap_memory",
    "training",
    "scope",
    "enable_tflite_convertible"
  ],
  "_prepend_batch": [
    "batch_size",
    "shape"
  ],
  "_transpose_batch_time": [
    "tensor"
  ],
  "_beam_search_so": [],
  "BeamSearchDecoderState": {},
  "BeamSearchDecoderOutput": {},
  "FinalBeamSearchDecoderOutput": {},
  "_tile_batch": [
    "t",
    "multiplier"
  ],
  "tile_batch": [
    "t",
    "multiplier",
    "name"
  ],
  "_gather_tree": [
    "step_ids",
    "parent_ids",
    "max_sequence_lengths",
    "end_token"
  ],
  "gather_tree": [
    "step_ids",
    "parent_ids",
    "max_sequence_lengths",
    "end_token"
  ],
  "gather_tree_from_array": [
    "t",
    "parent_ids",
    "sequence_length"
  ],
  "_check_ndims": [
    "t"
  ],
  "_check_static_batch_beam_maybe": [
    "shape",
    "batch_size",
    "beam_width"
  ],
  "_check_batch_beam": [
    "t",
    "batch_size",
    "beam_width"
  ],
  "_as_shape": [
    "value"
  ],
  "BeamSearchDecoderMixin": {
    "__init__": [
      "self",
      "cell",
      "beam_width",
      "output_layer",
      "length_penalty_weight",
      "coverage_penalty_weight",
      "reorder_tensor_arrays",
      "output_all_scores"
    ],
    "batch_size": [
      "self"
    ],
    "_rnn_output_size": [
      "self"
    ],
    "tracks_own_finished": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "finalize": [
      "self",
      "outputs",
      "final_state",
      "sequence_lengths"
    ],
    "_merge_batch_beams": [
      "self",
      "t",
      "s"
    ],
    "_split_batch_beams": [
      "self",
      "t",
      "s"
    ],
    "_maybe_split_batch_beams": [
      "self",
      "t",
      "s"
    ],
    "_maybe_merge_batch_beams": [
      "self",
      "t",
      "s"
    ],
    "_maybe_sort_array_beams": [
      "self",
      "t",
      "parent_ids",
      "sequence_length"
    ],
    "step": [
      "self",
      "time",
      "inputs",
      "state",
      "training",
      "name"
    ]
  },
  "BeamSearchDecoder": {
    "__init__": [
      "self",
      "cell",
      "beam_width",
      "embedding_fn",
      "output_layer",
      "length_penalty_weight",
      "coverage_penalty_weight",
      "reorder_tensor_arrays"
    ],
    "initialize": [
      "self",
      "embedding",
      "start_tokens",
      "end_token",
      "initial_state"
    ],
    "output_dtype": [
      "self"
    ],
    "call": [
      "self",
      "embedding",
      "start_tokens",
      "end_token",
      "initial_state",
      "training"
    ]
  },
  "_beam_search_step": [
    "time",
    "logits",
    "next_cell_state",
    "beam_state",
    "batch_size",
    "beam_width",
    "end_token",
    "length_penalty_weight",
    "coverage_penalty_weight",
    "output_all_scores"
  ],
  "get_attention_probs": [
    "next_cell_state",
    "coverage_penalty_weight"
  ],
  "_get_scores": [
    "log_probs",
    "sequence_lengths",
    "length_penalty_weight",
    "coverage_penalty_weight",
    "finished",
    "accumulated_attention_probs"
  ],
  "attention_probs_from_attn_state": [
    "attention_state"
  ],
  "_length_penalty": [
    "sequence_lengths",
    "penalty_factor"
  ],
  "_mask_probs": [
    "probs",
    "eos_token",
    "finished"
  ],
  "_maybe_tensor_gather_helper": [
    "gather_indices",
    "gather_from",
    "batch_size",
    "range_size",
    "gather_shape"
  ],
  "_tensor_gather_helper": [
    "gather_indices",
    "gather_from",
    "batch_size",
    "range_size",
    "gather_shape",
    "name"
  ],
  "Sampler": {
    "initialize": [
      "self",
      "inputs"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ],
    "batch_size": [
      "self"
    ],
    "sample_ids_shape": [
      "self"
    ],
    "sample_ids_dtype": [
      "self"
    ]
  },
  "CustomSampler": {
    "__init__": [
      "self",
      "initialize_fn",
      "sample_fn",
      "next_inputs_fn",
      "sample_ids_shape",
      "sample_ids_dtype"
    ],
    "batch_size": [
      "self"
    ],
    "sample_ids_shape": [
      "self"
    ],
    "sample_ids_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "inputs"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "TrainingSampler": {
    "__init__": [
      "self",
      "time_major"
    ],
    "batch_size": [
      "self"
    ],
    "sample_ids_shape": [
      "self"
    ],
    "sample_ids_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "inputs",
      "sequence_length",
      "mask"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "ScheduledEmbeddingTrainingSampler": {
    "__init__": [
      "self",
      "sampling_probability",
      "embedding_fn",
      "time_major",
      "seed",
      "scheduling_seed"
    ],
    "initialize": [
      "self",
      "inputs",
      "sequence_length",
      "mask",
      "embedding"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "ScheduledOutputTrainingSampler": {
    "__init__": [
      "self",
      "sampling_probability",
      "time_major",
      "seed",
      "next_inputs_fn"
    ],
    "initialize": [
      "self",
      "inputs",
      "sequence_length",
      "mask",
      "auxiliary_inputs"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "GreedyEmbeddingSampler": {
    "__init__": [
      "self",
      "embedding_fn"
    ],
    "batch_size": [
      "self"
    ],
    "sample_ids_shape": [
      "self"
    ],
    "sample_ids_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "embedding",
      "start_tokens",
      "end_token"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "SampleEmbeddingSampler": {
    "__init__": [
      "self",
      "embedding_fn",
      "softmax_temperature",
      "seed"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ]
  },
  "InferenceSampler": {
    "__init__": [
      "self",
      "sample_fn",
      "sample_shape",
      "sample_dtype",
      "end_fn",
      "next_inputs_fn"
    ],
    "batch_size": [
      "self"
    ],
    "sample_ids_shape": [
      "self"
    ],
    "sample_ids_dtype": [
      "self"
    ],
    "initialize": [
      "self",
      "start_inputs"
    ],
    "sample": [
      "self",
      "time",
      "outputs",
      "state"
    ],
    "next_inputs": [
      "self",
      "time",
      "outputs",
      "state",
      "sample_ids"
    ]
  },
  "_call_sampler": [
    "sample_n_fn",
    "sample_shape",
    "name"
  ],
  "bernoulli_sample": [
    "probs",
    "logits",
    "dtype",
    "sample_shape",
    "seed"
  ],
  "categorical_sample": [
    "logits",
    "dtype",
    "sample_shape",
    "seed"
  ],
  "_unstack_ta": [
    "inp"
  ],
  "_check_sequence_is_right_padded": [
    "mask",
    "time_major"
  ],
  "BasicDecoderOutput": {},
  "BasicDecoder": {
    "__init__": [
      "self",
      "cell",
      "sampler",
      "output_layer"
    ],
    "initialize": [
      "self",
      "inputs",
      "initial_state"
    ],
    "batch_size": [
      "self"
    ],
    "_rnn_output_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "output_dtype": [
      "self"
    ],
    "step": [
      "self",
      "time",
      "inputs",
      "state",
      "training"
    ]
  }
}