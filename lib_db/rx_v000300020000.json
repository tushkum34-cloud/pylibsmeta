{
  "__version__": [],
  "amb": [],
  "case": [
    "mapper",
    "sources",
    "default_source"
  ],
  "catch": [],
  "catch_with_iterable": [
    "sources"
  ],
  "create": [
    "subscribe"
  ],
  "combine_latest": [],
  "concat": [],
  "concat_with_iterable": [
    "sources"
  ],
  "defer": [
    "factory"
  ],
  "empty": [
    "scheduler"
  ],
  "for_in": [
    "values",
    "mapper"
  ],
  "fork_join": [],
  "from_callable": [
    "supplier",
    "scheduler"
  ],
  "from_callback": [
    "func",
    "mapper"
  ],
  "from_future": [
    "future"
  ],
  "from_iterable": [
    "iterable",
    "scheduler"
  ],
  "from_": [],
  "from_list": [],
  "from_marbles": [
    "string",
    "timespan",
    "scheduler",
    "lookup",
    "error"
  ],
  "cold": [],
  "generate_with_relative_time": [
    "initial_state",
    "condition",
    "iterate",
    "time_mapper"
  ],
  "generate": [
    "initial_state",
    "condition",
    "iterate"
  ],
  "hot": [
    "string",
    "timespan",
    "duetime",
    "scheduler",
    "lookup",
    "error"
  ],
  "if_then": [
    "condition",
    "then_source",
    "else_source"
  ],
  "interval": [
    "period",
    "scheduler"
  ],
  "merge": [],
  "never": [],
  "of": [],
  "on_error_resume_next": [],
  "range": [
    "start",
    "stop",
    "step",
    "scheduler"
  ],
  "return_value": [
    "value",
    "scheduler"
  ],
  "just": [],
  "repeat_value": [
    "value",
    "repeat_count"
  ],
  "start": [
    "func",
    "scheduler"
  ],
  "start_async": [
    "function_async"
  ],
  "throw": [
    "exception",
    "scheduler"
  ],
  "timer": [
    "duetime",
    "period",
    "scheduler"
  ],
  "to_async": [
    "func",
    "scheduler"
  ],
  "using": [
    "resource_factory",
    "observable_factory"
  ],
  "with_latest_from": [],
  "zip": [],
  "MockObserver": {
    "__init__": [
      "self",
      "scheduler"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ]
  },
  "TestScheduler": {
    "__test__": [],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "add": [
      "cls",
      "absolute",
      "relative"
    ],
    "start": [
      "self",
      "create",
      "created",
      "subscribed",
      "disposed"
    ],
    "create_hot_observable": [
      "self"
    ],
    "create_cold_observable": [
      "self"
    ],
    "create_observer": [
      "self"
    ]
  },
  "is_prime": [
    "i"
  ],
  "OnNextPredicate": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "OnErrorPredicate": {
    "__init__": [
      "self",
      "predicate"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "ReactiveTest": {
    "created": [],
    "subscribed": [],
    "disposed": [],
    "on_next": [
      "ticks",
      "value"
    ],
    "on_error": [
      "ticks",
      "exception"
    ],
    "on_completed": [
      "ticks"
    ],
    "subscribe": [
      "start",
      "end"
    ]
  },
  "Subscription": {
    "__init__": [
      "self",
      "start",
      "end"
    ],
    "equals": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "new_thread_scheduler": [],
  "MarblesContext": [],
  "marbles_testing": [
    "timespan"
  ],
  "messages_to_records": [
    "messages"
  ],
  "MockDisposable": {
    "__init__": [
      "self",
      "scheduler"
    ],
    "dispose": [
      "self"
    ]
  },
  "Recorded": {
    "__init__": [
      "self",
      "time",
      "value",
      "comparer"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "equals": [],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ColdObservable": {
    "__init__": [
      "self",
      "scheduler",
      "messages"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "TestSubscriber": {
    "__init__": [
      "self",
      "observable",
      "scheduler"
    ],
    "results": [
      "self"
    ]
  },
  "HotObservable": {
    "__init__": [
      "self",
      "scheduler",
      "messages"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "add_ref": [
    "xs",
    "r"
  ],
  "is_future": [
    "fut"
  ],
  "infinite": [],
  "alias": [
    "name",
    "doc",
    "fun"
  ],
  "NotSet": {
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "noop": [],
  "identity": [
    "x"
  ],
  "default_now": [],
  "default_comparer": [
    "x",
    "y"
  ],
  "default_sub_comparer": [
    "x",
    "y"
  ],
  "default_key_serializer": [
    "x"
  ],
  "default_error": [
    "err"
  ],
  "default_thread_factory": [
    "target"
  ],
  "synchronized": [
    "lock"
  ],
  "SequenceContainsNoElementsError": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "ArgumentOutOfRangeException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "DisposedException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "ReEntracyException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "CompletedException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "WouldBlockException": {
    "__init__": [
      "self",
      "msg"
    ]
  },
  "DELTA_ZERO": [],
  "UTC_ZERO": [],
  "PriorityQueue": {
    "MIN_COUNT": [],
    "__init__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "peek": [
      "self"
    ],
    "dequeue": [
      "self"
    ],
    "enqueue": [
      "self",
      "item"
    ],
    "remove": [
      "self",
      "item"
    ],
    "clear": [
      "self"
    ]
  },
  "all": [
    "predicate"
  ],
  "as_observable": [],
  "average": [
    "key_mapper"
  ],
  "buffer": [
    "boundaries"
  ],
  "buffer_when": [
    "closing_mapper"
  ],
  "buffer_toggle": [
    "openings",
    "closing_mapper"
  ],
  "buffer_with_count": [
    "count",
    "skip"
  ],
  "buffer_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "buffer_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "contains": [
    "value",
    "comparer"
  ],
  "count": [
    "predicate"
  ],
  "debounce": [
    "duetime",
    "scheduler"
  ],
  "throttle_with_timeout": [],
  "default_if_empty": [
    "default_value"
  ],
  "delay_subscription": [
    "duetime",
    "scheduler"
  ],
  "delay_with_mapper": [
    "subscription_delay",
    "delay_duration_mapper"
  ],
  "dematerialize": [],
  "delay": [
    "duetime",
    "scheduler"
  ],
  "distinct": [
    "key_mapper",
    "comparer"
  ],
  "distinct_until_changed": [
    "key_mapper",
    "comparer"
  ],
  "do": [
    "observer"
  ],
  "do_action": [
    "on_next",
    "on_error",
    "on_completed"
  ],
  "do_while": [
    "condition"
  ],
  "element_at": [
    "index"
  ],
  "element_at_or_default": [
    "index",
    "default_value"
  ],
  "exclusive": [],
  "expand": [
    "mapper"
  ],
  "filter": [
    "predicate"
  ],
  "filter_indexed": [
    "predicate_indexed"
  ],
  "finally_action": [
    "action"
  ],
  "find": [
    "predicate"
  ],
  "find_index": [
    "predicate"
  ],
  "first": [
    "predicate"
  ],
  "first_or_default": [
    "predicate",
    "default_value"
  ],
  "flat_map": [
    "mapper"
  ],
  "flat_map_indexed": [
    "mapper_indexed"
  ],
  "flat_map_latest": [
    "mapper"
  ],
  "group_by": [
    "key_mapper",
    "element_mapper",
    "subject_mapper"
  ],
  "group_by_until": [
    "key_mapper",
    "element_mapper",
    "duration_mapper",
    "subject_mapper"
  ],
  "group_join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "ignore_elements": [],
  "is_empty": [],
  "join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "last": [
    "predicate"
  ],
  "last_or_default": [
    "predicate",
    "default_value"
  ],
  "map": [
    "mapper"
  ],
  "map_indexed": [
    "mapper_indexed"
  ],
  "materialize": [],
  "max": [
    "comparer"
  ],
  "max_by": [
    "key_mapper",
    "comparer"
  ],
  "merge_all": [],
  "min": [
    "comparer"
  ],
  "min_by": [
    "key_mapper",
    "comparer"
  ],
  "multicast": [
    "subject",
    "subject_factory",
    "mapper"
  ],
  "observe_on": [
    "scheduler"
  ],
  "pairwise": [],
  "partition": [
    "predicate"
  ],
  "partition_indexed": [
    "predicate_indexed"
  ],
  "pluck": [
    "key"
  ],
  "pluck_attr": [
    "prop"
  ],
  "publish": [
    "mapper"
  ],
  "publish_value": [
    "initial_value",
    "mapper"
  ],
  "reduce": [
    "accumulator",
    "seed"
  ],
  "ref_count": [],
  "repeat": [
    "repeat_count"
  ],
  "replay": [
    "mapper",
    "buffer_size",
    "window",
    "scheduler"
  ],
  "retry": [
    "retry_count"
  ],
  "sample": [
    "sampler",
    "scheduler"
  ],
  "scan": [
    "accumulator",
    "seed"
  ],
  "sequence_equal": [
    "second",
    "comparer"
  ],
  "share": [],
  "single": [
    "predicate"
  ],
  "single_or_default": [
    "predicate",
    "default_value"
  ],
  "single_or_default_async": [
    "has_default",
    "default_value"
  ],
  "skip": [
    "count"
  ],
  "skip_last": [
    "count"
  ],
  "skip_last_with_time": [
    "duration",
    "scheduler"
  ],
  "skip_until": [
    "other"
  ],
  "skip_until_with_time": [
    "start_time",
    "scheduler"
  ],
  "skip_while": [
    "predicate"
  ],
  "skip_while_indexed": [
    "predicate"
  ],
  "skip_with_time": [
    "duration",
    "scheduler"
  ],
  "slice": [
    "start",
    "stop",
    "step"
  ],
  "some": [
    "predicate"
  ],
  "starmap": [
    "mapper"
  ],
  "starmap_indexed": [
    "mapper"
  ],
  "start_with": [],
  "subscribe_on": [
    "scheduler"
  ],
  "sum": [
    "key_mapper"
  ],
  "switch_latest": [],
  "take": [
    "count"
  ],
  "take_last": [
    "count"
  ],
  "take_last_buffer": [
    "count"
  ],
  "take_last_with_time": [
    "duration",
    "scheduler"
  ],
  "take_until": [
    "other"
  ],
  "take_until_with_time": [
    "end_time",
    "scheduler"
  ],
  "take_while": [
    "predicate",
    "inclusive"
  ],
  "take_while_indexed": [
    "predicate",
    "inclusive"
  ],
  "take_with_time": [
    "duration",
    "scheduler"
  ],
  "throttle_first": [
    "window_duration",
    "scheduler"
  ],
  "throttle_with_mapper": [
    "throttle_duration_mapper"
  ],
  "timestamp": [
    "scheduler"
  ],
  "timeout": [
    "duetime",
    "other",
    "scheduler"
  ],
  "timeout_with_mapper": [
    "first_timeout",
    "timeout_duration_mapper",
    "other"
  ],
  "time_interval": [
    "scheduler"
  ],
  "to_dict": [
    "key_mapper",
    "element_mapper"
  ],
  "to_future": [
    "future_ctor"
  ],
  "to_iterable": [],
  "to_list": [],
  "to_marbles": [
    "timespan",
    "scheduler"
  ],
  "to_set": [],
  "while_do": [
    "condition"
  ],
  "window": [
    "boundaries"
  ],
  "window_when": [
    "closing_mapper"
  ],
  "window_toggle": [
    "openings",
    "closing_mapper"
  ],
  "window_with_count": [
    "count",
    "skip"
  ],
  "window_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "window_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "zip_with_iterable": [
    "second"
  ],
  "zip_with_list": [],
  "AsyncSubject": {
    "__init__": [
      "self"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "Subject": {
    "__init__": [
      "self"
    ],
    "check_disposed": [
      "self"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "InnerSubscription": {
    "__init__": [
      "self",
      "subject",
      "observer"
    ],
    "dispose": [
      "self"
    ]
  },
  "BehaviorSubject": {
    "__init__": [
      "self",
      "value"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "dispose": [
      "self"
    ]
  },
  "RemovableDisposable": {
    "__init__": [
      "self",
      "subject",
      "observer"
    ],
    "dispose": [
      "self"
    ]
  },
  "QueueItem": {},
  "ReplaySubject": {
    "__init__": [
      "self",
      "buffer_size",
      "window",
      "scheduler"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "_trim": [
      "self",
      "now"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "MultipleAssignmentDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "BooleanDisposable": {
    "__init__": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "CompositeDisposable": {
    "__init__": [
      "self"
    ],
    "add": [
      "self",
      "item"
    ],
    "remove": [
      "self",
      "item"
    ],
    "dispose": [
      "self"
    ],
    "clear": [
      "self"
    ],
    "contains": [
      "self",
      "item"
    ],
    "to_list": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "length": [
      "self"
    ]
  },
  "RefCountDisposable": {
    "__init__": [
      "self",
      "disposable"
    ],
    "dispose": [
      "self"
    ],
    "release": [
      "self"
    ],
    "disposable": [
      "self"
    ]
  },
  "SingleAssignmentDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "Disposable": {
    "__init__": [
      "self",
      "action"
    ],
    "dispose": [
      "self"
    ]
  },
  "ScheduledDisposable": {
    "__init__": [
      "self",
      "scheduler",
      "disposable"
    ],
    "dispose": [
      "self"
    ]
  },
  "SerialDisposable": {
    "__init__": [
      "self"
    ],
    "get_disposable": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "disposable": [],
    "dispose": [
      "self"
    ]
  },
  "TimeoutScheduler": {
    "_lock": [],
    "singleton": [
      "cls"
    ],
    "__new__": [
      "cls"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "log": [],
  "NewThreadScheduler": {
    "__init__": [
      "self",
      "thread_factory"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "MAX_SPINNING": [],
  "VirtualTimeScheduler": {
    "__init__": [
      "self",
      "initial_clock"
    ],
    "_get_clock": [
      "self"
    ],
    "clock": [],
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "start": [
      "self"
    ],
    "stop": [
      "self"
    ],
    "advance_to": [
      "self",
      "time"
    ],
    "advance_by": [
      "self",
      "time"
    ],
    "sleep": [
      "self",
      "time"
    ],
    "add": [
      "cls",
      "absolute",
      "relative"
    ]
  },
  "Scheduler": {
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "invoke_action": [
      "self",
      "action",
      "state"
    ],
    "to_seconds": [
      "cls",
      "value"
    ],
    "to_datetime": [
      "cls",
      "value"
    ],
    "to_timedelta": [
      "cls",
      "value"
    ]
  },
  "TrampolineScheduler": {
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_required": [
      "self"
    ],
    "ensure_trampoline": [
      "self",
      "action"
    ]
  },
  "ScheduledItem": {
    "__init__": [
      "self",
      "scheduler",
      "state",
      "action",
      "duetime"
    ],
    "invoke": [
      "self"
    ],
    "cancel": [
      "self"
    ],
    "is_cancelled": [
      "self"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "ImmediateScheduler": {
    "_lock": [],
    "singleton": [
      "cls"
    ],
    "__new__": [
      "cls"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "HistoricalScheduler": {
    "__init__": [
      "self",
      "initial_clock"
    ],
    "now": [
      "self"
    ],
    "add": [
      "cls",
      "absolute",
      "relative"
    ]
  },
  "PeriodicScheduler": {
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "ThreadPoolScheduler": {
    "__init__": [
      "self",
      "max_workers"
    ]
  },
  "EventLoopScheduler": {
    "__init__": [
      "self",
      "thread_factory",
      "exit_if_empty"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ],
    "_has_thread": [
      "self"
    ],
    "_ensure_thread": [
      "self"
    ],
    "run": [
      "self"
    ],
    "dispose": [
      "self"
    ]
  },
  "CatchScheduler": {
    "__init__": [
      "self",
      "scheduler",
      "handler"
    ],
    "now": [
      "self"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ],
    "_clone": [
      "self",
      "scheduler"
    ],
    "_wrap": [
      "self",
      "action"
    ],
    "_get_recursive_wrapper": [
      "self",
      "scheduler"
    ]
  },
  "Trampoline": {
    "__init__": [
      "self"
    ],
    "idle": [
      "self"
    ],
    "run": [
      "self",
      "item"
    ],
    "_run": [
      "self"
    ]
  },
  "CurrentThreadScheduler": {
    "singleton": [
      "cls"
    ],
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ]
  },
  "_Local": {
    "__init__": [
      "self"
    ]
  },
  "CurrentThreadSchedulerSingleton": {
    "_local": [],
    "__init__": [
      "self"
    ],
    "get_trampoline": [
      "self"
    ]
  },
  "QtScheduler": {
    "__init__": [
      "self",
      "qtcore"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "TkinterScheduler": {
    "__init__": [
      "self",
      "root"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ]
  },
  "WxScheduler": {
    "__init__": [
      "self",
      "wx"
    ],
    "cancel_all": [
      "self"
    ],
    "_wxtimer_schedule": [
      "self",
      "time",
      "action",
      "state",
      "periodic"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "GtkScheduler": {
    "__init__": [
      "self",
      "glib"
    ],
    "_gtk_schedule": [
      "self",
      "time",
      "action",
      "state",
      "periodic"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_periodic": [
      "self",
      "period",
      "action",
      "state"
    ]
  },
  "PyGameScheduler": {
    "__init__": [
      "self",
      "pygame"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "run": [
      "self"
    ]
  },
  "GEventScheduler": {
    "__init__": [
      "self",
      "gevent"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "EventletScheduler": {
    "__init__": [
      "self",
      "eventlet"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "AsyncIOScheduler": {
    "__init__": [
      "self",
      "loop"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "AsyncIOThreadSafeScheduler": {
    "__init__": [
      "self",
      "loop"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "_on_self_loop_or_not_running": [
      "self"
    ]
  },
  "IOLoopScheduler": {
    "__init__": [
      "self",
      "loop"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "TwistedScheduler": {
    "__init__": [
      "self",
      "reactor"
    ],
    "schedule": [
      "self",
      "action",
      "state"
    ],
    "schedule_relative": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "schedule_absolute": [
      "self",
      "duetime",
      "action",
      "state"
    ],
    "now": [
      "self"
    ]
  },
  "Notification": {
    "__init__": [
      "self"
    ],
    "accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "to_observable": [
      "self",
      "scheduler"
    ],
    "equals": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "OnNext": {
    "__init__": [
      "self",
      "value"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "OnError": {
    "__init__": [
      "self",
      "exception"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "OnCompleted": {
    "__init__": [
      "self"
    ],
    "_accept": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "_accept_observer": [
      "self",
      "observer"
    ],
    "__str__": [
      "self"
    ]
  },
  "from_notifier": [
    "handler"
  ],
  "A": [],
  "B": [],
  "C": [],
  "D": [],
  "E": [],
  "F": [],
  "G": [],
  "pipe": [],
  "T_out": [],
  "T_in": [],
  "TState": [],
  "T1": [],
  "T2": [],
  "Action": [],
  "Mapper": [],
  "MapperIndexed": [],
  "Predicate": [],
  "PredicateIndexed": [],
  "Comparer": [],
  "SubComparer": [],
  "Accumulator": [],
  "AbsoluteTime": [],
  "RelativeTime": [],
  "AbsoluteOrRelativeTime": [],
  "ScheduledAction": [],
  "ScheduledPeriodicAction": [],
  "ScheduledSingleOrPeriodicAction": [],
  "Startable": [],
  "StartableTarget": [],
  "StartableFactory": [],
  "Observer": {
    "__slots__": [],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ]
  },
  "Observable": {
    "__slots__": [],
    "subscribe": [
      "self",
      "observer"
    ]
  },
  "scheduler": [],
  "run": [
    "source"
  ],
  "AsyncObservable": {
    "__slots__": [],
    "subscribe_async": [
      "self",
      "observer"
    ]
  },
  "AsyncObserver": {
    "__slots__": [],
    "on_next_async": [
      "self",
      "value"
    ],
    "on_error_async": [
      "self",
      "error"
    ],
    "on_completed_async": [
      "self"
    ],
    "subscribe_async": [
      "self",
      "observer"
    ]
  },
  "_delay_with_mapper": [
    "subscription_delay",
    "delay_duration_mapper"
  ],
  "_merge": [],
  "_merge_all": [],
  "_find_value": [
    "predicate",
    "yield_index"
  ],
  "_expand": [
    "mapper"
  ],
  "_sum": [
    "key_mapper"
  ],
  "_amb": [
    "right_source"
  ],
  "_repeat": [
    "repeat_count"
  ],
  "_skip_until_with_time": [
    "start_time",
    "scheduler"
  ],
  "Timestamp": {},
  "_timestamp": [
    "scheduler"
  ],
  "_filter": [
    "predicate"
  ],
  "_filter_indexed": [
    "predicate_indexed"
  ],
  "observable_delay_timespan": [
    "source",
    "duetime",
    "scheduler"
  ],
  "_delay": [
    "duetime",
    "scheduler"
  ],
  "_skip_until": [
    "other"
  ],
  "_throttle_first": [
    "window_duration",
    "scheduler"
  ],
  "_fork_join": [],
  "_max": [
    "comparer"
  ],
  "last_or_default_async": [
    "source",
    "has_default",
    "default_value"
  ],
  "_last_or_default": [
    "predicate",
    "default_value"
  ],
  "_do_action": [
    "on_next",
    "on_error",
    "on_completed"
  ],
  "do_after_next": [
    "source",
    "after_next"
  ],
  "do_on_subscribe": [
    "source",
    "on_subscribe"
  ],
  "do_on_dispose": [
    "source",
    "on_dispose"
  ],
  "do_on_terminate": [
    "source",
    "on_terminate"
  ],
  "do_after_terminate": [
    "source",
    "after_terminate"
  ],
  "do_finally": [
    "finally_action"
  ],
  "_to_marbles": [
    "scheduler",
    "timespan"
  ],
  "stringify": [
    "value"
  ],
  "_concat": [],
  "AverageValue": {
    "__init__": [
      "self",
      "sum",
      "count"
    ]
  },
  "_average": [
    "key_mapper"
  ],
  "array_index_of_comparer": [
    "array",
    "item",
    "comparer"
  ],
  "HashSet": {
    "__init__": [
      "self",
      "comparer"
    ],
    "push": [
      "self",
      "value"
    ]
  },
  "_distinct": [
    "key_mapper",
    "comparer"
  ],
  "_buffer_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "_timeout": [
    "duetime",
    "other",
    "scheduler"
  ],
  "_take_last_buffer": [
    "count"
  ],
  "_combine_latest": [],
  "catch_handler": [
    "source",
    "handler"
  ],
  "_catch": [
    "handler"
  ],
  "_group_by": [
    "key_mapper",
    "element_mapper",
    "subject_mapper"
  ],
  "_distinct_until_changed": [
    "key_mapper",
    "comparer"
  ],
  "_with_latest_from": [],
  "_replay": [
    "mapper",
    "buffer_size",
    "window",
    "scheduler"
  ],
  "_take": [
    "count"
  ],
  "_subscribe_on": [
    "scheduler"
  ],
  "_dematerialize": [],
  "_skip": [
    "count"
  ],
  "TimeInterval": {},
  "_time_interval": [
    "scheduler"
  ],
  "determine_median": [
    "sorted_list"
  ],
  "median": [
    "source"
  ],
  "mode": [
    "source"
  ],
  "variance": [
    "source"
  ],
  "standard_deviation": [
    "source"
  ],
  "_all": [
    "predicate"
  ],
  "_zip": [],
  "_zip_with_iterable": [
    "seq"
  ],
  "_start_with": [],
  "_reduce": [
    "accumulator",
    "seed"
  ],
  "_merge_scan": [
    "accumulator",
    "seed"
  ],
  "_debounce": [
    "duetime",
    "scheduler"
  ],
  "_throttle_with_mapper": [
    "throttle_duration_mapper"
  ],
  "_window_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "_slice": [
    "start",
    "stop",
    "step"
  ],
  "_to_set": [],
  "_first_or_default_async": [
    "has_default",
    "default_value"
  ],
  "_first_or_default": [
    "predicate",
    "default_value"
  ],
  "_last": [
    "predicate"
  ],
  "_finally_action": [
    "action"
  ],
  "_map": [
    "mapper"
  ],
  "_map_indexed": [
    "mapper_indexed"
  ],
  "_delay_subscription": [
    "duetime",
    "scheduler"
  ],
  "_to_future": [
    "future_ctor",
    "scheduler"
  ],
  "_partition": [
    "predicate"
  ],
  "_partition_indexed": [
    "predicate_indexed"
  ],
  "_group_by_until": [
    "key_mapper",
    "element_mapper",
    "duration_mapper",
    "subject_mapper"
  ],
  "_scan": [
    "accumulator",
    "seed"
  ],
  "_pluck": [
    "key"
  ],
  "_pluck_attr": [
    "prop"
  ],
  "_take_while": [
    "predicate",
    "inclusive"
  ],
  "_take_while_indexed": [
    "predicate",
    "inclusive"
  ],
  "_take_until": [
    "other"
  ],
  "_flat_map_internal": [
    "source",
    "mapper",
    "mapper_indexed"
  ],
  "_flat_map": [
    "mapper"
  ],
  "_flat_map_indexed": [
    "mapper_indexed"
  ],
  "_flat_map_latest": [
    "mapper"
  ],
  "_publish": [
    "mapper"
  ],
  "_share": [],
  "_to_dict": [
    "key_mapper",
    "element_mapper"
  ],
  "_single": [
    "predicate"
  ],
  "_count": [
    "predicate"
  ],
  "_skip_last_with_time": [
    "duration",
    "scheduler"
  ],
  "first_only": [
    "x"
  ],
  "_min": [
    "comparer"
  ],
  "_pairwise": [],
  "_multicast": [
    "subject",
    "subject_factory",
    "mapper"
  ],
  "_skip_with_time": [
    "duration",
    "scheduler"
  ],
  "_window_with_time_or_count": [
    "timespan",
    "count",
    "scheduler"
  ],
  "_join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "_buffer_with_time": [
    "timespan",
    "timeshift",
    "scheduler"
  ],
  "_default_if_empty": [
    "default_value"
  ],
  "_sequence_equal": [
    "second",
    "comparer"
  ],
  "_do_while": [
    "condition"
  ],
  "_some": [
    "predicate"
  ],
  "_on_error_resume_next": [
    "second"
  ],
  "_materialize": [],
  "_window_with_count": [
    "count",
    "skip"
  ],
  "_element_at_or_default": [
    "index",
    "has_default",
    "default_value"
  ],
  "_observe_on": [
    "scheduler"
  ],
  "_as_observable": [],
  "_retry": [
    "retry_count"
  ],
  "_take_with_time": [
    "duration",
    "scheduler"
  ],
  "_group_join": [
    "right",
    "left_duration_mapper",
    "right_duration_mapper"
  ],
  "_first": [
    "predicate"
  ],
  "extrema_by": [
    "source",
    "key_mapper",
    "comparer"
  ],
  "_min_by": [
    "key_mapper",
    "comparer"
  ],
  "_window_toggle": [
    "openings",
    "closing_mapper"
  ],
  "_window": [
    "boundaries"
  ],
  "_window_when": [
    "closing_mapper"
  ],
  "_ignore_elements": [],
  "sample_observable": [
    "source",
    "sampler"
  ],
  "_sample": [
    "sampler",
    "scheduler"
  ],
  "_max_by": [
    "key_mapper",
    "comparer"
  ],
  "_take_last": [
    "count"
  ],
  "_to_iterable": [],
  "_while_do": [
    "condition"
  ],
  "_contains": [
    "value",
    "comparer"
  ],
  "_single_or_default_async": [
    "has_default",
    "default_value"
  ],
  "_single_or_default": [
    "predicate",
    "default_value"
  ],
  "_is_empty": [],
  "_skip_while": [
    "predicate"
  ],
  "_skip_while_indexed": [
    "predicate"
  ],
  "_timeout_with_mapper": [
    "first_timeout",
    "timeout_duration_mapper",
    "other"
  ],
  "_skip_last": [
    "count"
  ],
  "_take_last_with_time": [
    "duration",
    "scheduler"
  ],
  "_exclusive": [],
  "_take_until_with_time": [
    "end_time",
    "scheduler"
  ],
  "_switch_latest": [],
  "_publish_value": [
    "initial_value",
    "mapper"
  ],
  "_buffer": [
    "boundaries"
  ],
  "_buffer_when": [
    "closing_mapper"
  ],
  "_buffer_toggle": [
    "openings",
    "closing_mapper"
  ],
  "_buffer_with_count": [
    "count",
    "skip"
  ],
  "_ref_count": [],
  "AutoDetachObserver": {
    "__init__": [
      "self",
      "on_next",
      "on_error",
      "on_completed"
    ],
    "on_next": [
      "self",
      "value"
    ],
    "on_error": [
      "self",
      "error"
    ],
    "on_completed": [
      "self"
    ],
    "set_disposable": [
      "self",
      "value"
    ],
    "subscription": [],
    "dispose": [
      "self"
    ],
    "fail": [
      "self",
      "exn"
    ]
  },
  "ScheduledObserver": {
    "__init__": [
      "self",
      "scheduler",
      "observer"
    ],
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ],
    "ensure_active": [
      "self"
    ],
    "run": [
      "self",
      "scheduler",
      "state"
    ],
    "dispose": [
      "self"
    ]
  },
  "ObserveOnObserver": {
    "_on_next_core": [
      "self",
      "value"
    ],
    "_on_error_core": [
      "self",
      "error"
    ],
    "_on_completed_core": [
      "self"
    ]
  },
  "_generate": [
    "initial_state",
    "condition",
    "iterate"
  ],
  "_repeat_value": [
    "value",
    "repeat_count"
  ],
  "_start": [
    "func",
    "scheduler"
  ],
  "_concat_with_iterable": [
    "sources"
  ],
  "ConnectableObservable": {
    "__init__": [
      "self",
      "source",
      "subject"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ],
    "connect": [
      "self",
      "scheduler"
    ],
    "auto_connect": [
      "self",
      "subscriber_count"
    ]
  },
  "_catch_with_iterable": [
    "sources"
  ],
  "_return_value": [
    "value",
    "scheduler"
  ],
  "_from_callable": [
    "supplier",
    "scheduler"
  ],
  "_throw": [
    "exception",
    "scheduler"
  ],
  "_using": [
    "resource_factory",
    "observable_factory"
  ],
  "pattern_group": [],
  "pattern_ticks": [],
  "pattern_comma_error": [],
  "pattern_element": [],
  "pattern": [],
  "tokens": [],
  "parse": [
    "string",
    "timespan",
    "time_shift",
    "lookup",
    "error",
    "raise_stopped"
  ],
  "_start_async": [
    "function_async"
  ],
  "_interval": [
    "period",
    "scheduler"
  ],
  "_defer": [
    "factory"
  ],
  "GroupedObservable": {
    "__init__": [
      "self",
      "key",
      "underlying_observable",
      "merged_disposable"
    ],
    "_subscribe_core": [
      "self",
      "observer",
      "scheduler"
    ]
  },
  "_empty": [
    "scheduler"
  ],
  "_generate_with_relative_time": [
    "initial_state",
    "condition",
    "iterate",
    "time_mapper"
  ],
  "_never": [],
  "_to_async": [
    "func",
    "scheduler"
  ],
  "observable_timer_date": [
    "duetime",
    "scheduler"
  ],
  "observable_timer_duetime_and_period": [
    "duetime",
    "period",
    "scheduler"
  ],
  "observable_timer_timespan": [
    "duetime",
    "scheduler"
  ],
  "observable_timer_timespan_and_period": [
    "duetime",
    "period",
    "scheduler"
  ],
  "_timer": [
    "duetime",
    "period",
    "scheduler"
  ],
  "_if_then": [
    "condition",
    "then_source",
    "else_source"
  ],
  "_range": [
    "start",
    "stop",
    "step",
    "scheduler"
  ],
  "_from_future": [
    "future"
  ],
  "_case": [
    "mapper",
    "sources",
    "default_source"
  ],
  "_from_callback": [
    "func",
    "mapper"
  ]
}