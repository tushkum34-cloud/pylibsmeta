{
  "SignificanceTestType": {
    "AUTO": [],
    "BOOTSTRAP": [],
    "NORMAL": []
  },
  "logger": [],
  "CausalRefuter": {
    "DEFAULT_NUM_SIMULATIONS": [],
    "PROGRESS_BAR_COLOR": [],
    "__init__": [
      "self",
      "data",
      "identified_estimand",
      "estimate"
    ],
    "choose_variables": [
      "self",
      "required_variables"
    ],
    "test_significance": [
      "self",
      "estimate",
      "simulations",
      "test_type",
      "significance_level"
    ],
    "perform_bootstrap_test": [
      "self",
      "estimate",
      "simulations"
    ],
    "perform_normal_distribution_test": [
      "self",
      "estimate",
      "simulations"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "choose_variables": [
    "required_variables",
    "variables_of_interest"
  ],
  "perform_bootstrap_test": [
    "estimate",
    "simulations"
  ],
  "perform_normal_distribution_test": [
    "estimate",
    "simulations"
  ],
  "test_significance": [
    "estimate",
    "simulations",
    "test_type",
    "significance_level"
  ],
  "CausalRefutation": {
    "__init__": [
      "self",
      "estimated_effect",
      "new_effect",
      "refutation_type"
    ],
    "add_significance_test_results": [
      "self",
      "refutation_result"
    ],
    "add_refuter": [
      "self",
      "refuter_instance"
    ],
    "interpret": [
      "self",
      "method_name"
    ],
    "__str__": [
      "self"
    ]
  },
  "GraphLearner": {
    "__init__": [
      "self",
      "data",
      "library_class"
    ],
    "learn_graph": [
      "self"
    ]
  },
  "SMALL_SIZE": [],
  "MEDIUM_SIZE": [],
  "BIGGER_SIZE": [],
  "plot_treatment_outcome": [
    "treatment",
    "outcome",
    "time_var"
  ],
  "plot_causal_effect": [
    "estimate",
    "treatment",
    "outcome"
  ],
  "CausalEstimator": {
    "DEFAULT_NUMBER_OF_SIMULATIONS_STAT_TEST": [],
    "DEFAULT_NUMBER_OF_SIMULATIONS_CI": [],
    "DEFAULT_SAMPLE_SIZE_FRACTION": [],
    "DEFAULT_CONFIDENCE_LEVEL": [],
    "NUM_QUANTILES_TO_DISCRETIZE_CONT_COLS": [],
    "TEMP_CAT_COLUMN_PREFIX": [],
    "DEFAULT_NOTIMPLEMENTEDERROR_MSG": [],
    "BootstrapEstimates": [],
    "DEFAULT_INTERPRET_METHOD": [],
    "_STD_INIT_ARGS": [],
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "reset_encoders": [
      "self"
    ],
    "_encode": [
      "self",
      "data",
      "encoder_name"
    ],
    "_set_effect_modifiers": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "_set_identified_estimand": [
      "self",
      "new_identified_estimand"
    ],
    "get_new_estimator_object": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals"
    ],
    "estimate_effect_naive": [
      "self",
      "data"
    ],
    "_estimate_effect_fn": [
      "self",
      "data_df"
    ],
    "_estimate_conditional_effects": [
      "self",
      "data",
      "estimate_effect_fn",
      "effect_modifier_names",
      "num_quantiles"
    ],
    "_do": [
      "self",
      "x",
      "data_df"
    ],
    "do": [
      "self",
      "x",
      "data_df"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ],
    "_generate_bootstrap_estimates": [
      "self",
      "data",
      "num_bootstrap_simulations",
      "sample_size_fraction"
    ],
    "_estimate_confidence_intervals_with_bootstrap": [
      "self",
      "data",
      "estimate_value",
      "confidence_level",
      "num_simulations",
      "sample_size_fraction"
    ],
    "_estimate_confidence_intervals": [
      "self",
      "confidence_level",
      "method"
    ],
    "estimate_confidence_intervals": [
      "self",
      "data",
      "estimate_value",
      "confidence_level",
      "method"
    ],
    "_estimate_std_error_with_bootstrap": [
      "self",
      "data",
      "num_simulations",
      "sample_size_fraction"
    ],
    "_estimate_std_error": [
      "self",
      "method"
    ],
    "estimate_std_error": [
      "self",
      "data",
      "method"
    ],
    "_test_significance_with_bootstrap": [
      "self",
      "data",
      "estimate_value",
      "num_null_simulations"
    ],
    "_test_significance": [
      "self",
      "estimate_value",
      "method"
    ],
    "test_significance": [
      "self",
      "data",
      "estimate_value",
      "method"
    ],
    "evaluate_effect_strength": [
      "self",
      "data",
      "estimate"
    ],
    "_evaluate_effect_strength": [
      "self",
      "data",
      "estimate",
      "method"
    ],
    "update_input": [
      "self",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "is_bootstrap_parameter_changed": [
      "bootstrap_estimates_params",
      "given_params"
    ],
    "target_units_tostr": [
      "self"
    ],
    "signif_results_tostr": [
      "self",
      "signif_results"
    ]
  },
  "estimate_effect": [
    "data",
    "treatment",
    "outcome",
    "identifier_name",
    "estimator",
    "control_value",
    "treatment_value",
    "target_units",
    "effect_modifiers",
    "fit_estimator",
    "method_params"
  ],
  "CausalEstimate": {
    "__init__": [
      "self",
      "data",
      "treatment_name",
      "outcome_name",
      "estimate",
      "target_estimand",
      "realized_estimand_expr",
      "control_value",
      "treatment_value",
      "conditional_estimates"
    ],
    "add_estimator": [
      "self",
      "estimator_instance"
    ],
    "add_effect_strength": [
      "self",
      "strength_dict"
    ],
    "add_params": [
      "self"
    ],
    "get_confidence_intervals": [
      "self",
      "confidence_level",
      "method"
    ],
    "get_standard_error": [
      "self",
      "method"
    ],
    "test_stat_significance": [
      "self",
      "method"
    ],
    "estimate_conditional_effects": [
      "self",
      "effect_modifiers",
      "num_quantiles"
    ],
    "interpret": [
      "self",
      "method_name"
    ],
    "__str__": [
      "self"
    ]
  },
  "RealizedEstimand": {
    "__init__": [
      "self",
      "identified_estimand",
      "estimator_name"
    ],
    "update_assumptions": [
      "self",
      "estimator_assumptions"
    ],
    "update_estimand_expression": [
      "self",
      "estimand_expression"
    ],
    "__str__": [
      "self"
    ]
  },
  "DimensionalityReducer": {
    "__init__": [
      "self",
      "data_array",
      "ndims"
    ],
    "reduce": [
      "self",
      "target_dimensions"
    ]
  },
  "DoSampler": {
    "__init__": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "data",
      "params",
      "variable_types",
      "num_cores",
      "keep_original_treatment",
      "estimand_type"
    ],
    "_sample_point": [
      "self",
      "x_z"
    ],
    "reset": [
      "self"
    ],
    "make_treatment_effective": [
      "self",
      "x"
    ],
    "disrupt_causes": [
      "self"
    ],
    "point_sample": [
      "self"
    ],
    "sample": [
      "self"
    ],
    "do_sample": [
      "self",
      "x"
    ],
    "_infer_variable_types": [
      "self"
    ]
  },
  "CausalGraph": {
    "__init__": [
      "self",
      "treatment_name",
      "outcome_name",
      "graph",
      "common_cause_names",
      "instrument_names",
      "effect_modifier_names",
      "mediator_names",
      "observed_node_names",
      "missing_nodes_as_confounders"
    ],
    "view_graph": [
      "self",
      "layout",
      "size",
      "file_name"
    ],
    "build_graph": [
      "self",
      "common_cause_names",
      "instrument_names",
      "effect_modifier_names",
      "mediator_names"
    ],
    "add_node_attributes": [
      "self",
      "observed_node_names"
    ],
    "add_missing_nodes_as_common_causes": [
      "self",
      "observed_node_names"
    ],
    "add_unobserved_common_cause": [
      "self",
      "observed_node_names",
      "color"
    ],
    "get_unconfounded_observed_subgraph": [
      "self"
    ],
    "do_surgery": [
      "self",
      "node_names",
      "remove_outgoing_edges",
      "remove_incoming_edges",
      "target_node_names",
      "remove_only_direct_edges_to_target"
    ],
    "get_causes": [
      "self",
      "nodes",
      "remove_edges"
    ],
    "check_dseparation": [
      "self",
      "nodes1",
      "nodes2",
      "nodes3",
      "new_graph",
      "dseparation_algo"
    ],
    "check_valid_backdoor_set": [
      "self",
      "nodes1",
      "nodes2",
      "nodes3",
      "backdoor_paths",
      "new_graph",
      "dseparation_algo"
    ],
    "get_backdoor_paths": [
      "self",
      "nodes1",
      "nodes2"
    ],
    "is_blocked": [
      "self",
      "path",
      "conditioned_nodes"
    ],
    "get_common_causes": [
      "self",
      "nodes1",
      "nodes2"
    ],
    "get_effect_modifiers": [
      "self",
      "nodes1",
      "nodes2"
    ],
    "get_parents": [
      "self",
      "node_name"
    ],
    "get_ancestors": [
      "self",
      "node_name",
      "new_graph"
    ],
    "get_descendants": [
      "self",
      "nodes"
    ],
    "all_observed": [
      "self",
      "node_names"
    ],
    "get_all_nodes": [
      "self",
      "include_unobserved"
    ],
    "filter_unobserved_variables": [
      "self",
      "node_names"
    ],
    "get_instruments": [
      "self",
      "treatment_nodes",
      "outcome_nodes"
    ],
    "get_all_directed_paths": [
      "self",
      "nodes1",
      "nodes2"
    ],
    "has_directed_path": [
      "self",
      "action_nodes",
      "outcome_nodes"
    ],
    "get_adjacency_matrix": [
      "self"
    ],
    "check_valid_frontdoor_set": [
      "self",
      "nodes1",
      "nodes2",
      "candidate_nodes",
      "frontdoor_paths",
      "new_graph",
      "dseparation_algo"
    ],
    "check_valid_mediation_set": [
      "self",
      "nodes1",
      "nodes2",
      "candidate_nodes",
      "mediation_paths"
    ]
  },
  "_logger": [],
  "HasNodes": {
    "nodes": [
      "self"
    ]
  },
  "HasEdges": {
    "edges": [
      "self"
    ]
  },
  "DirectedGraph": {
    "predecessors": [
      "self",
      "node"
    ]
  },
  "is_root_node": [
    "causal_graph",
    "node"
  ],
  "get_ordered_predecessors": [
    "causal_graph",
    "node"
  ],
  "node_connected_subgraph_view": [
    "g",
    "node"
  ],
  "validate_acyclic": [
    "causal_graph"
  ],
  "validate_node_in_graph": [
    "causal_graph",
    "node"
  ],
  "check_valid_backdoor_set": [
    "graph",
    "nodes1",
    "nodes2",
    "nodes3",
    "backdoor_paths",
    "new_graph",
    "dseparation_algo"
  ],
  "do_surgery": [
    "graph",
    "node_names",
    "remove_outgoing_edges",
    "remove_incoming_edges",
    "target_node_names",
    "remove_only_direct_edges_to_target"
  ],
  "get_backdoor_paths": [
    "graph",
    "nodes1",
    "nodes2"
  ],
  "is_blocked": [
    "graph",
    "path",
    "conditioned_nodes"
  ],
  "get_ancestors": [
    "graph",
    "nodes"
  ],
  "get_descendants": [
    "graph",
    "nodes"
  ],
  "get_proper_causal_path_nodes": [
    "graph",
    "action_nodes",
    "outcome_nodes"
  ],
  "get_proper_backdoor_graph": [
    "graph",
    "action_nodes",
    "outcome_nodes"
  ],
  "check_dseparation": [
    "graph",
    "nodes1",
    "nodes2",
    "nodes3",
    "new_graph",
    "dseparation_algo"
  ],
  "get_all_nodes": [
    "graph",
    "observed_nodes",
    "include_unobserved_nodes"
  ],
  "get_instruments": [
    "graph",
    "treatment_nodes",
    "outcome_nodes"
  ],
  "check_valid_frontdoor_set": [
    "graph",
    "nodes1",
    "nodes2",
    "candidate_nodes",
    "frontdoor_paths",
    "new_graph",
    "dseparation_algo"
  ],
  "get_all_directed_paths": [
    "graph",
    "nodes1",
    "nodes2"
  ],
  "has_directed_path": [
    "graph",
    "action_nodes",
    "outcome_nodes"
  ],
  "check_valid_mediation_set": [
    "graph",
    "nodes1",
    "nodes2",
    "candidate_nodes",
    "mediation_paths"
  ],
  "get_adjacency_matrix": [
    "graph"
  ],
  "build_graph": [
    "action_nodes",
    "outcome_nodes",
    "common_cause_nodes",
    "instrument_nodes",
    "effect_modifier_nodes",
    "mediator_nodes"
  ],
  "build_graph_from_str": [
    "graph_str"
  ],
  "__version__": [],
  "__all__": [],
  "CausalModel": {
    "__init__": [
      "self",
      "data",
      "treatment",
      "outcome",
      "graph",
      "common_causes",
      "instruments",
      "effect_modifiers",
      "estimand_type",
      "proceed_when_unidentifiable",
      "missing_nodes_as_confounders",
      "identify_vars"
    ],
    "get_estimator": [
      "self",
      "method_name"
    ],
    "init_graph": [
      "self",
      "graph",
      "identify_vars"
    ],
    "get_common_causes": [
      "self"
    ],
    "get_instruments": [
      "self"
    ],
    "get_effect_modifiers": [
      "self"
    ],
    "learn_graph": [
      "self",
      "method_name"
    ],
    "identify_effect": [
      "self",
      "estimand_type",
      "method_name",
      "proceed_when_unidentifiable",
      "optimize_backdoor"
    ],
    "estimate_effect": [
      "self",
      "identified_estimand",
      "method_name",
      "control_value",
      "treatment_value",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "target_units",
      "effect_modifiers",
      "fit_estimator",
      "method_params"
    ],
    "do": [
      "self",
      "x",
      "identified_estimand",
      "method_name",
      "fit_estimator",
      "method_params"
    ],
    "refute_estimate": [
      "self",
      "estimand",
      "estimate",
      "method_name",
      "show_progress_bar"
    ],
    "view_model": [
      "self",
      "layout",
      "size",
      "file_name"
    ],
    "interpret": [
      "self",
      "method_name"
    ],
    "summary": [
      "self",
      "print_to_stdout"
    ],
    "refute_graph": [
      "self",
      "k",
      "independence_test",
      "independence_constraints"
    ]
  },
  "_warn_if_unobserved_graph_variables": [
    "graph_variable_names",
    "data_variable_names",
    "logger"
  ],
  "_warn_if_unused_data_variables": [
    "data_variable_names",
    "graph_variable_names",
    "logger"
  ],
  "DISCRETE": [],
  "BINARY": [],
  "CONTINUOUS": [],
  "sigmoid": [
    "x"
  ],
  "convert_to_binary": [
    "x",
    "stochastic"
  ],
  "stochastically_convert_to_three_level_categorical": [
    "x"
  ],
  "convert_to_categorical": [
    "arr",
    "num_vars",
    "num_discrete_vars",
    "quantiles",
    "one_hot_encode"
  ],
  "construct_col_names": [
    "name",
    "num_vars",
    "num_discrete_vars",
    "num_discrete_levels",
    "one_hot_encode"
  ],
  "linear_dataset": [
    "beta",
    "num_common_causes",
    "num_samples",
    "num_instruments",
    "num_effect_modifiers",
    "num_treatments",
    "num_frontdoor_variables",
    "treatment_is_binary",
    "treatment_is_category",
    "outcome_is_binary",
    "stochastic_discretization",
    "num_discrete_common_causes",
    "num_discrete_instruments",
    "num_discrete_effect_modifiers",
    "stddev_treatment_noise",
    "stddev_outcome_noise",
    "one_hot_encode"
  ],
  "simple_iv_dataset": [
    "beta",
    "num_samples",
    "num_treatments",
    "treatment_is_binary",
    "outcome_is_binary"
  ],
  "create_dot_graph": [
    "treatments",
    "outcome",
    "common_causes",
    "instruments",
    "effect_modifiers",
    "frontdoor_variables"
  ],
  "create_gml_graph": [
    "treatments",
    "outcome",
    "common_causes",
    "instruments",
    "effect_modifiers",
    "frontdoor_variables"
  ],
  "xy_dataset": [
    "num_samples",
    "effect",
    "num_common_causes",
    "is_linear",
    "sd_error"
  ],
  "create_discrete_column": [
    "num_samples",
    "std_dev"
  ],
  "convert_continuous_to_discrete": [
    "arr"
  ],
  "generate_random_graph": [
    "n",
    "max_iter"
  ],
  "check_all_node_types_are_specified": [
    "graph",
    "variable_type_dict"
  ],
  "exact_ate_of_linear_graph": [
    "graph",
    "treatments",
    "outcome"
  ],
  "linear_dataset_from_graph": [
    "graph",
    "treatments",
    "outcome",
    "treatments_are_binary",
    "outcome_is_binary",
    "variable_type_dict",
    "num_samples"
  ],
  "dataset_from_random_graph": [
    "num_vars",
    "num_samples",
    "prob_edge",
    "random_seed",
    "prob_type_of_data"
  ],
  "partially_linear_dataset": [
    "beta",
    "num_common_causes",
    "num_unobserved_common_causes",
    "strength_unobserved_confounding",
    "num_samples",
    "num_treatments",
    "treatment_is_binary",
    "treatment_is_category",
    "outcome_is_binary",
    "stochastic_discretization",
    "num_discrete_common_causes",
    "stddev_treatment_noise",
    "stddev_outcome_noise",
    "one_hot_encode",
    "training_sample_size",
    "random_state"
  ],
  "lalonde_dataset": [],
  "psid_dataset": [],
  "sales_dataset": [
    "start_date",
    "end_date",
    "frequency",
    "num_shopping_events",
    "original_product_price",
    "product_production_cost",
    "based_ad_spending",
    "change_of_price",
    "change_of_demand",
    "page_visitor_factor"
  ],
  "Interpreter": {
    "SUPPORTED_MODELS": [],
    "SUPPORTED_ESTIMATORS": [],
    "SUPPORTED_REFUTERS": [],
    "__init__": [
      "self",
      "instance"
    ],
    "interpret": [
      "self"
    ]
  },
  "IdentifiedEstimand": {
    "__init__": [
      "self",
      "identifier",
      "treatment_variable",
      "outcome_variable",
      "estimand_type",
      "estimands",
      "backdoor_variables",
      "general_adjustment_variables",
      "instrumental_variables",
      "frontdoor_variables",
      "mediator_variables",
      "mediation_first_stage_confounders",
      "mediation_second_stage_confounders",
      "default_backdoor_id",
      "default_adjustment_set_id",
      "identifier_method",
      "no_directed_path"
    ],
    "set_identifier_method": [
      "self",
      "identifier_name"
    ],
    "get_backdoor_variables": [
      "self",
      "key"
    ],
    "set_backdoor_variables": [
      "self",
      "bdoor_variables_arr",
      "key"
    ],
    "get_frontdoor_variables": [
      "self"
    ],
    "get_mediator_variables": [
      "self"
    ],
    "get_instrumental_variables": [
      "self"
    ],
    "get_general_adjustment_variables": [
      "self",
      "key"
    ],
    "set_general_adjustment_variables": [
      "self",
      "variables_arr",
      "key"
    ],
    "get_adjustment_set": [
      "self",
      "key"
    ],
    "set_adjustment_set": [
      "self",
      "variables_arr",
      "key"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "__str__": [
      "self",
      "only_target_estimand",
      "show_all_backdoor_sets"
    ]
  },
  "IDExpression": {
    "__init__": [
      "self"
    ],
    "add_product": [
      "self",
      "element"
    ],
    "add_sum": [
      "self",
      "element"
    ],
    "get_val": [
      "self",
      "return_type"
    ],
    "_print_estimator": [
      "self",
      "prefix",
      "estimator",
      "start"
    ],
    "__str__": [
      "self"
    ]
  },
  "IDIdentifier": {
    "identify_effect": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes"
    ]
  },
  "identify_effect_id": [
    "graph",
    "action_nodes",
    "outcome_nodes"
  ],
  "__adjacency_matrix_identify_effect": [
    "adjacency_matrix",
    "treatment_name",
    "outcome_name",
    "tsort_node_names",
    "node_names"
  ],
  "__idx_node_mapping": [
    "node_names"
  ],
  "EstimandType": {
    "NONPARAMETRIC_ATE": [],
    "NONPARAMETRIC_NDE": [],
    "NONPARAMETRIC_NIE": [],
    "NONPARAMETRIC_CDE": []
  },
  "BackdoorAdjustment": {
    "BACKDOOR_DEFAULT": [],
    "BACKDOOR_EXHAUSTIVE": [],
    "BACKDOOR_MIN": [],
    "BACKDOOR_MAX": [],
    "BACKDOOR_EFFICIENT": [],
    "BACKDOOR_MIN_EFFICIENT": [],
    "BACKDOOR_MINCOST_EFFICIENT": []
  },
  "GeneralizedAdjustment": {
    "GENERALIZED_ADJUSTMENT_DEFAULT": [],
    "GENERALIZED_ADJUSTMENT_EXHAUSTIVE": []
  },
  "MAX_BACKDOOR_ITERATIONS": [],
  "METHOD_NAMES": [],
  "EFFICIENT_METHODS": [],
  "DEFAULT_BACKDOOR_METHOD": [],
  "AutoIdentifier": {
    "__init__": [
      "self",
      "estimand_type",
      "backdoor_adjustment",
      "optimize_backdoor",
      "costs",
      "generalized_adjustment"
    ],
    "identify_effect": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "conditional_node_names"
    ],
    "identify_backdoor": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "include_unobserved",
      "dseparation_algo",
      "direct_effect"
    ]
  },
  "identify_effect_auto": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "estimand_type",
    "conditional_node_names",
    "backdoor_adjustment",
    "optimize_backdoor",
    "costs",
    "generalized_adjustment"
  ],
  "identify_ate_effect": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "optimize_backdoor",
    "estimand_type",
    "costs",
    "conditional_node_names",
    "generalized_adjustment"
  ],
  "identify_cde_effect": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "estimand_type"
  ],
  "identify_nie_effect": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "estimand_type"
  ],
  "identify_nde_effect": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "estimand_type"
  ],
  "identify_backdoor": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "include_unobserved",
    "dseparation_algo",
    "direct_effect"
  ],
  "identify_efficient_backdoor": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment",
    "costs",
    "conditional_node_names"
  ],
  "find_valid_adjustment_sets": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_paths",
    "bdoor_graph",
    "dseparation_algo",
    "backdoor_sets",
    "filt_eligible_variables",
    "backdoor_adjustment",
    "max_iterations"
  ],
  "get_default_adjustment_set_id": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "adjustment_sets_dict"
  ],
  "build_adjustment_set_estimands_dict": [
    "treatment_names",
    "outcome_names",
    "observed_nodes",
    "adjustment_sets",
    "estimands_dict"
  ],
  "identify_frontdoor": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "dseparation_algo"
  ],
  "identify_generalized_adjustment_set": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes",
    "generalized_adjustment"
  ],
  "identify_mediation": [
    "graph",
    "action_nodes",
    "outcome_nodes"
  ],
  "identify_mediation_first_stage_confounders": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "mediator_nodes",
    "observed_nodes",
    "backdoor_adjustment"
  ],
  "identify_mediation_second_stage_confounders": [
    "graph",
    "action_nodes",
    "mediator_nodes",
    "outcome_nodes",
    "observed_nodes",
    "backdoor_adjustment"
  ],
  "construct_adjustment_estimand": [
    "treatment_name",
    "outcome_name",
    "common_causes"
  ],
  "construct_iv_estimand": [
    "treatment_name",
    "outcome_name",
    "instrument_names"
  ],
  "construct_frontdoor_estimand": [
    "treatment_name",
    "outcome_name",
    "frontdoor_variables_names"
  ],
  "construct_mediation_estimand": [
    "estimand_type",
    "action_nodes",
    "outcome_nodes",
    "mediator_nodes"
  ],
  "EXCEPTION_NO_ADJ": [],
  "EXCEPTION_COND_NO_OPT": [],
  "EfficientBackdoor": {
    "__init__": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "conditional_node_names",
      "costs"
    ],
    "ancestors_all": [
      "self",
      "nodes"
    ],
    "backdoor_graph": [
      "self",
      "G"
    ],
    "causal_vertices": [
      "self"
    ],
    "forbidden": [
      "self"
    ],
    "ignore": [
      "self"
    ],
    "unblocked": [
      "self",
      "H",
      "Z"
    ],
    "build_H0": [
      "self"
    ],
    "build_H1": [
      "self"
    ],
    "build_D": [
      "self"
    ],
    "compute_smallest_mincut": [
      "self"
    ],
    "h_operator": [
      "self",
      "S"
    ],
    "optimal_adj_set": [
      "self"
    ],
    "optimal_minimal_adj_set": [
      "self"
    ],
    "optimal_mincost_adj_set": [
      "self"
    ]
  },
  "NodePair": {
    "__init__": [
      "self",
      "node1",
      "node2"
    ],
    "update": [
      "self",
      "path",
      "condition_vars"
    ],
    "get_condition_vars": [
      "self"
    ],
    "set_complete": [
      "self"
    ],
    "is_complete": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "Path": {
    "__init__": [
      "self"
    ],
    "update": [
      "self",
      "path",
      "is_blocked"
    ],
    "is_blocked": [
      "self"
    ],
    "get_condition_vars": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "Backdoor": {
    "__init__": [
      "self",
      "graph",
      "nodes1",
      "nodes2"
    ],
    "get_backdoor_vars": [
      "self"
    ],
    "is_backdoor": [
      "self",
      "path"
    ],
    "_path_search_util": [
      "self",
      "graph",
      "node1",
      "node2",
      "vis",
      "path",
      "path_dict",
      "is_blocked",
      "prev_arrow"
    ],
    "_path_search": [
      "self",
      "graph",
      "node1",
      "node2",
      "path_dict"
    ]
  },
  "HittingSetAlgorithm": {
    "__init__": [
      "self",
      "list_of_sets",
      "colliders"
    ],
    "num_sets": [
      "self"
    ],
    "find_set": [
      "self"
    ],
    "_count_vars": [
      "self",
      "set_index"
    ],
    "_modify_count": [
      "self",
      "indices_covered"
    ],
    "_max_occurence_var": [
      "self",
      "var_dict"
    ],
    "_indices_covered": [
      "self",
      "el",
      "set_index"
    ],
    "_is_covered": [
      "self",
      "indices_covered",
      "num_indices"
    ]
  },
  "CausalIdentifier": {
    "identify_effect": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes"
    ]
  },
  "identify_effect": [
    "graph",
    "action_nodes",
    "outcome_nodes",
    "observed_nodes"
  ],
  "AdjustmentSet": {
    "BACKDOOR": [],
    "GENERAL": [],
    "__init__": [
      "self",
      "adjustment_type",
      "adjustment_variables",
      "num_paths_blocked_by_observed_nodes"
    ],
    "get_adjustment_type": [
      "self"
    ],
    "get_adjustment_variables": [
      "self"
    ],
    "get_num_paths_blocked_by_observed_nodes": [
      "self"
    ]
  },
  "ConfounderDistributionInterpreter": {
    "SUPPORTED_ESTIMATORS": [],
    "__init__": [
      "self",
      "estimate",
      "fig_size",
      "font_size",
      "var_name",
      "var_type"
    ],
    "discrete_dist_plot": [
      "labels",
      "not_treated_counts",
      "treated_counts",
      "ax",
      "title",
      "var_name",
      "font_size",
      "width"
    ],
    "interpret": [
      "self",
      "data"
    ]
  },
  "VisualInterpreter": {
    "__init__": [
      "self",
      "instance"
    ],
    "show": [
      "self",
      "interpret_plot"
    ]
  },
  "get_class_object": [
    "method_name"
  ],
  "TextualEffectInterpreter": {
    "SUPPORTED_ESTIMATORS": [],
    "__init__": [
      "self",
      "instance"
    ],
    "interpret": [
      "self",
      "data"
    ]
  },
  "PropensityBalanceInterpreter": {
    "SUPPORTED_ESTIMATORS": [],
    "__init__": [
      "self",
      "estimate"
    ],
    "interpret": [
      "self",
      "data"
    ]
  },
  "TextualInterpreter": {
    "__init__": [
      "self",
      "instance"
    ],
    "show": [
      "self",
      "interpret_text"
    ]
  },
  "get_discovery_class_object": [
    "method_name"
  ],
  "get_library_class_object": [
    "module_method_name"
  ],
  "LINGAM": {
    "__init__": [
      "self",
      "data",
      "full_method_name"
    ],
    "learn_graph": [
      "self",
      "labels"
    ]
  },
  "CDT": {
    "__init__": [
      "self",
      "data",
      "full_method_name"
    ],
    "learn_graph": [
      "self",
      "labels"
    ]
  },
  "GES": {
    "__init__": [
      "self",
      "data",
      "full_method_name"
    ],
    "learn_graph": [
      "self",
      "labels"
    ]
  },
  "PCAReducer": {
    "__init__": [
      "self"
    ],
    "reduce": [
      "self"
    ]
  },
  "create_graph_from_user": [],
  "create_graph_from_csv": [
    "file_path"
  ],
  "create_graph_from_dot_format": [
    "file_path"
  ],
  "create_graph_from_networkx_array": [
    "array",
    "var_names"
  ],
  "plot_causal_graph_graphviz": [
    "causal_graph",
    "layout_prog",
    "display_causal_strengths",
    "causal_strengths",
    "colors",
    "filename",
    "display_plot",
    "figure_size"
  ],
  "plot": [
    "causal_graph",
    "layout_prog",
    "causal_strengths",
    "colors",
    "filename",
    "display_plot",
    "figure_size"
  ],
  "plot_adjacency_matrix": [
    "adjacency_matrix",
    "is_directed",
    "filename",
    "display_plot"
  ],
  "bar_plot": [
    "values",
    "uncertainties",
    "ylabel",
    "filename",
    "display_plot",
    "figure_size",
    "bar_width",
    "xticks",
    "xticks_rotation",
    "sort_names"
  ],
  "_calc_arrow_width": [
    "strength",
    "max_strength"
  ],
  "_plot_as_pyplot_figure": [
    "pygraphviz_graph",
    "figure_size"
  ],
  "pretty_print_graph": [
    "graph"
  ],
  "plot_causal_graph_networkx": [
    "causal_graph",
    "layout_prog",
    "causal_strengths",
    "colors",
    "filename",
    "display_plot",
    "label_wrap_length",
    "figure_size"
  ],
  "_draw_graph_with_custom_layout": [
    "graph",
    "colors",
    "edge_widths",
    "figure_size"
  ],
  "_custom_assign_layers": [
    "graph"
  ],
  "_custom_count_nodes_vertically": [
    "graph"
  ],
  "_custom_create_vertical_neighbor_indicator": [
    "graph",
    "pos"
  ],
  "query_yes_no": [
    "question",
    "default"
  ],
  "OrderedSet": {
    "__init__": [
      "self",
      "elements"
    ],
    "add": [
      "self",
      "element"
    ],
    "get_all": [
      "self"
    ],
    "is_empty": [
      "self"
    ],
    "union": [
      "self",
      "other_set"
    ],
    "intersection": [
      "self",
      "other_set"
    ],
    "difference": [
      "self",
      "other_set"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__iter__": [
      "self"
    ],
    "__next__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__eq__": [
      "self",
      "other"
    ]
  },
  "parse_state": [
    "state"
  ],
  "compute_ci": [
    "r",
    "nx",
    "ny",
    "confidence"
  ],
  "partial_corr": [
    "data",
    "x",
    "y",
    "z",
    "method"
  ],
  "entropy": [
    "x"
  ],
  "conditional_MI": [
    "data",
    "x",
    "y",
    "z"
  ],
  "DataGeneratingProcess": {
    "DEFAULT_PERCENTILE": [],
    "__init__": [
      "self"
    ],
    "generate_data": [
      "self"
    ],
    "generation_process": [
      "self"
    ],
    "convert_to_binary": [
      "self",
      "data",
      "deterministic"
    ],
    "__str__": [
      "self"
    ]
  },
  "get_numeric_features": [
    "X"
  ],
  "generate_moment_function": [
    "W",
    "g"
  ],
  "create_polynomial_function": [
    "max_degree"
  ],
  "adjacency_matrix_to_adjacency_list": [
    "adjacency_matrix",
    "labels"
  ],
  "adjacency_matrix_to_graph": [
    "adjacency_matrix",
    "labels"
  ],
  "str_to_dot": [
    "string"
  ],
  "find_ancestor": [
    "node_set",
    "node_names",
    "adjacency_matrix",
    "node2idx",
    "idx2node"
  ],
  "induced_graph": [
    "node_set",
    "adjacency_matrix",
    "node2idx"
  ],
  "find_c_components": [
    "adjacency_matrix",
    "node_set",
    "idx2node"
  ],
  "daggity_to_dot": [
    "daggity_string"
  ],
  "get_simple_ordered_tree": [
    "n"
  ],
  "is_connected": [
    "g"
  ],
  "convert_to_undirected_graph": [
    "g"
  ],
  "get_random_node_pair": [
    "n"
  ],
  "find_predecessor": [
    "i",
    "j",
    "g"
  ],
  "del_edge": [
    "i",
    "j",
    "g"
  ],
  "add_edge": [
    "i",
    "j",
    "g"
  ],
  "one_hot_encode": [
    "data",
    "columns",
    "drop_first",
    "encoder"
  ],
  "Encoders": {
    "__init__": [
      "self",
      "drop_first"
    ],
    "reset": [
      "self"
    ],
    "encode": [
      "self",
      "data",
      "encoder_name"
    ]
  },
  "propensity_of_treatment_score": [
    "data",
    "covariates",
    "treatment",
    "model",
    "variable_types"
  ],
  "state_propensity_score": [
    "data",
    "covariates",
    "treatments",
    "variable_types"
  ],
  "binary_treatment_model": [
    "data",
    "covariates",
    "treatment",
    "variable_types"
  ],
  "categorical_treatment_model": [
    "data",
    "covariates",
    "treatment",
    "variable_types"
  ],
  "continuous_treatment_model": [
    "data",
    "covariates",
    "treatment",
    "variable_types"
  ],
  "get_type_string": [
    "variables",
    "variable_types"
  ],
  "binarize_discrete": [
    "data",
    "covariates",
    "variable_types"
  ],
  "discrete_to_integer": [
    "discrete"
  ],
  "QuadraticDataGeneratingProcess": {
    "POWER": [],
    "NAME": [],
    "__init__": [
      "self"
    ],
    "generate_data": [
      "self",
      "sample_size"
    ],
    "generation_process": [
      "self"
    ],
    "generate_weights": [
      "self",
      "dimensions"
    ],
    "generate_bias": [
      "self",
      "dimensions"
    ],
    "__str__": [
      "self"
    ]
  },
  "RandomNeuralNetwork": {
    "TRAINING_SAMPLE_SIZE": [],
    "RANDOM_STATE": [],
    "DEFAULT_ARCH": [],
    "DEFAULT_ARCH_DICT": [],
    "NAME": [],
    "__init__": [
      "self"
    ],
    "generate_data": [
      "self",
      "sample_size"
    ],
    "generation_process": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "LinearDataGeneratingProcess": {
    "NAME": [],
    "__init__": [
      "self"
    ],
    "generate_data": [
      "self",
      "sample_size"
    ],
    "generation_process": [
      "self"
    ],
    "generate_weights": [
      "self",
      "dimensions"
    ],
    "generate_bias": [
      "self",
      "dimensions"
    ],
    "__str__": [
      "self"
    ]
  },
  "CubicDataGeneratingProcess": {
    "POWER": [],
    "NAME": [],
    "__init__": [
      "self"
    ],
    "generate_data": [
      "self",
      "sample_size"
    ],
    "generation_process": [
      "self"
    ],
    "generate_weights": [
      "self",
      "dimensions"
    ],
    "generate_bias": [
      "self",
      "dimensions"
    ],
    "__str__": [
      "self"
    ]
  },
  "KernelDensitySampler": {
    "__init__": [
      "self"
    ],
    "_fit_conditional": [
      "self"
    ],
    "_infer_variable_types": [
      "self"
    ],
    "_construct_sampler": [
      "self"
    ]
  },
  "KernelSampler": {
    "__init__": [
      "self",
      "outcome_upper_support",
      "outcome_lower_support",
      "outcome_names",
      "treatment_names",
      "backdoor_variables",
      "data",
      "dep_type",
      "indep_type",
      "bw",
      "defaults"
    ],
    "sample_point": [
      "self",
      "x_z"
    ],
    "_evaluate_cdf": [
      "self",
      "y",
      "x_z"
    ]
  },
  "MultivariateWeightingSampler": {
    "__init__": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "data",
      "params",
      "variable_types",
      "num_cores",
      "keep_original_treatment",
      "estimand_type"
    ],
    "make_treatment_effective": [
      "self",
      "x"
    ],
    "disrupt_causes": [
      "self"
    ],
    "sample": [
      "self"
    ],
    "compute_weights": [
      "self"
    ]
  },
  "PACKAGE_NAME": [],
  "WeightingSampler": {
    "__init__": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "data",
      "params",
      "variable_types",
      "num_cores",
      "keep_original_treatment",
      "estimand_type"
    ],
    "make_treatment_effective": [
      "self",
      "x"
    ],
    "disrupt_causes": [
      "self"
    ],
    "sample": [
      "self"
    ],
    "compute_weights": [
      "self"
    ]
  },
  "McmcSampler": {
    "__init__": [
      "self",
      "graph",
      "action_nodes",
      "outcome_nodes",
      "observed_nodes",
      "data",
      "params",
      "variable_types",
      "num_cores",
      "keep_original_treatment",
      "estimand_type"
    ],
    "apply_data_types": [
      "self",
      "g",
      "data_types"
    ],
    "apply_parents": [
      "self",
      "g"
    ],
    "apply_parameters": [
      "self",
      "g",
      "df",
      "initialization_trace"
    ],
    "build_bayesian_network": [
      "self",
      "g",
      "df"
    ],
    "fit_causal_model": [
      "self",
      "g",
      "df",
      "data_types",
      "initialization_trace"
    ],
    "sample_prior_causal_model": [
      "self",
      "g",
      "df",
      "data_types",
      "initialization_trace"
    ],
    "do_x_surgery": [
      "self",
      "g",
      "x"
    ],
    "make_intervention_effective": [
      "self",
      "x"
    ],
    "do_sample": [
      "self",
      "x"
    ],
    "_construct_sampler": [
      "self"
    ]
  },
  "CausalAccessor": {
    "__init__": [
      "self",
      "pandas_obj"
    ],
    "reset": [
      "self"
    ],
    "do": [
      "self",
      "x",
      "method",
      "num_cores",
      "variable_types",
      "outcome",
      "params",
      "graph",
      "common_causes",
      "estimand_type",
      "stateful"
    ],
    "convert_to_custom_type": [
      "self",
      "input_type"
    ],
    "parse_x": [
      "self",
      "x"
    ]
  },
  "PropensityScoreStratificationEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "num_strata",
      "clipping_threshold",
      "propensity_score_model",
      "propensity_score_column"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "_get_strata": [
      "self",
      "data",
      "num_strata",
      "clipping_threshold"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "TwoStageRegressionEstimator": {
    "DEFAULT_FIRST_STAGE_MODEL": [],
    "DEFAULT_SECOND_STAGE_MODEL": [],
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "first_stage_model",
      "second_stage_model"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "build_first_stage_features": [
      "self",
      "data_df"
    ],
    "construct_symbolic_estimator": [
      "self",
      "first_stage_symbolic",
      "second_stage_symbolic",
      "total_effect_symbolic",
      "estimand_type"
    ]
  },
  "DistanceMatchingEstimator": {
    "Valid_Dist_Metric_Params": [],
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "num_matches_per_unit",
      "distance_metric"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names",
      "exact_match_cols"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "PropensityScoreWeightingEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "min_ps_score",
      "max_ps_score",
      "weighting_scheme",
      "propensity_score_model",
      "propensity_score_column"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "PropensityScoreEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "propensity_score_model",
      "propensity_score_column"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "predict_proba": [
      "self",
      "data"
    ],
    "estimate_propensity_score_column": [
      "self",
      "data"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "LinearRegressionEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ],
    "predict_fn": [
      "self",
      "data",
      "model",
      "features"
    ],
    "_build_model": [
      "self",
      "data"
    ],
    "_estimate_confidence_intervals": [
      "self",
      "confidence_level",
      "method"
    ],
    "_estimate_std_error": [
      "self",
      "method"
    ],
    "_test_significance": [
      "self",
      "estimate_value",
      "method"
    ]
  },
  "_EconmlEstimator": {
    "fit": [
      "self"
    ],
    "effect": [
      "self"
    ],
    "effect_interval": [
      "self"
    ],
    "effect_inference": [
      "self"
    ],
    "shap_values": [
      "self"
    ]
  },
  "Econml": {
    "__init__": [
      "self",
      "identified_estimand",
      "econml_estimator",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "_get_econml_class_object": [
      "self",
      "module_method_name"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "_estimate_confidence_intervals": [
      "self",
      "confidence_level",
      "method"
    ],
    "_do": [
      "self",
      "x",
      "data_df"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ],
    "shap_values": [
      "self",
      "df"
    ],
    "apply_multitreatment": [
      "self",
      "df",
      "fun"
    ],
    "effect": [
      "self",
      "df"
    ],
    "effect_interval": [
      "self",
      "df"
    ],
    "effect_inference": [
      "self",
      "df"
    ],
    "effect_tt": [
      "self",
      "df",
      "treatment_value"
    ]
  },
  "RegressionDiscontinuityEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "rd_variable_name",
      "rd_threshold_value",
      "rd_bandwidth"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "InstrumentalVariableEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "iv_instrument_name",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "_CausalmlEstimator": {
    "estimate_ate": [
      "self"
    ],
    "fit_predict": [
      "self"
    ]
  },
  "Causalml": {
    "__init__": [
      "self",
      "identified_estimand",
      "causalml_estimator",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "_get_causalml_class_object": [
      "self",
      "module_method_name"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "GeneralizedLinearModelEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "glm_family",
      "predict_score"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "_build_model": [
      "self",
      "data"
    ],
    "predict_fn": [
      "self",
      "data",
      "model",
      "features"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "PropensityScoreMatchingEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "propensity_score_model",
      "propensity_score_column"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "RegressionEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "treatment_value",
      "control_value",
      "target_units",
      "need_conditional_estimates"
    ],
    "_estimate_effect_fn": [
      "self",
      "data_df"
    ],
    "_build_features": [
      "self",
      "data_df",
      "treatment_values"
    ],
    "interventional_outcomes": [
      "self",
      "data_df",
      "treatment_val"
    ],
    "predict": [
      "self",
      "data_df"
    ],
    "_do": [
      "self",
      "treatment_val",
      "data_df"
    ]
  },
  "DoublyRobustEstimator": {
    "__init__": [
      "self",
      "identified_estimand",
      "test_significance",
      "evaluate_effect_strength",
      "confidence_intervals",
      "num_null_simulations",
      "num_simulations",
      "sample_size_fraction",
      "confidence_level",
      "need_conditional_estimates",
      "num_quantiles_to_discretize_cont_cols",
      "regression_estimator",
      "propensity_score_model",
      "propensity_score_column",
      "min_ps_score",
      "max_ps_score"
    ],
    "fit": [
      "self",
      "data",
      "effect_modifier_names"
    ],
    "estimate_effect": [
      "self",
      "data",
      "control_value",
      "treatment_value",
      "target_units"
    ],
    "_do": [
      "self",
      "treatment",
      "received_treatment_value",
      "data_df"
    ],
    "construct_symbolic_estimator": [
      "self",
      "estimand"
    ]
  },
  "EValueSensitivityAnalyzer": {
    "__init__": [
      "self",
      "estimate",
      "estimand",
      "data",
      "treatment_name",
      "outcome_name",
      "no_effect_baseline"
    ],
    "check_sensitivity": [
      "self",
      "data",
      "plot"
    ],
    "get_evalue": [
      "self",
      "coef_est",
      "coef_se"
    ],
    "plot": [
      "self",
      "num_points_per_contour",
      "plot_size",
      "contour_colors",
      "benchmarking_color",
      "xy_limit"
    ],
    "_plot_contour": [
      "self",
      "ax",
      "rr",
      "evalue",
      "n_pts",
      "color",
      "xy_limit",
      "point_est"
    ],
    "benchmark": [
      "self",
      "data"
    ],
    "_observed_covariate_e_value": [
      "self",
      "ci",
      "new_ci"
    ],
    "_evalue_OLS": [
      "self",
      "est",
      "se",
      "sd",
      "no_effect_baseline"
    ],
    "_evalue_MD": [
      "self",
      "est",
      "se",
      "no_effect_baseline"
    ],
    "_evalue_OR": [
      "self",
      "est",
      "lo",
      "hi",
      "rare",
      "no_effect_baseline"
    ],
    "_evalue_RR": [
      "self",
      "est",
      "lo",
      "hi",
      "no_effect_baseline"
    ],
    "_threshold": [
      "self",
      "x",
      "no_effect_baseline"
    ],
    "_to_smd": [
      "self",
      "est",
      "sd",
      "delta"
    ],
    "_md_to_rr": [
      "self",
      "est"
    ],
    "_hr_to_rr": [
      "self",
      "est",
      "rare"
    ],
    "_or_to_rr": [
      "self",
      "est",
      "rare"
    ],
    "__str__": [
      "self"
    ]
  },
  "DEFAULT_PROBABILITY_OF_BINOMIAL": [],
  "DEFAULT_NUMBER_OF_TRIALS": [],
  "DEFAULT_MEAN_OF_NORMAL": [],
  "DEFAULT_STD_DEV_OF_NORMAL": [],
  "PlaceboType": {
    "DEFAULT": [],
    "PERMUTE": []
  },
  "PlaceboTreatmentRefuter": {
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "_refute_once": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_names",
    "type_dict",
    "placebo_type",
    "random_state"
  ],
  "refute_placebo_treatment": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_names",
    "num_simulations",
    "placebo_type",
    "random_state",
    "show_progress_bar",
    "n_jobs",
    "verbose"
  ],
  "AssessOverlap": {
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "assess_support_and_overlap_overrule": [
    "data",
    "backdoor_vars",
    "treatment_name",
    "cat_feats",
    "overlap_config",
    "support_config",
    "overlap_eps",
    "support_only",
    "overlap_only",
    "verbose"
  ],
  "PartialLinearSensitivityAnalyzer": {
    "__init__": [
      "self",
      "estimator",
      "num_splits",
      "shuffle_data",
      "shuffle_random_seed",
      "reisz_polynomial_max_degree",
      "significance_level",
      "effect_strength_treatment",
      "effect_strength_outcome",
      "benchmark_common_causes",
      "frac_strength_treatment",
      "frac_strength_outcome",
      "observed_common_causes",
      "treatment",
      "outcome",
      "g_s_estimator_list",
      "alpha_s_estimator_list",
      "g_s_estimator_param_list",
      "alpha_s_estimator_param_list"
    ],
    "is_benchmarking_needed": [
      "self"
    ],
    "get_phi_lower_upper": [
      "self",
      "Cg",
      "Calpha"
    ],
    "get_confidence_levels": [
      "self",
      "r2yu_tw",
      "r2tu_w",
      "significance_level",
      "is_partial_linear"
    ],
    "calculate_robustness_value": [
      "self",
      "alpha",
      "is_partial_linear"
    ],
    "perform_benchmarking": [
      "self",
      "r2yu_tw",
      "r2tu_w",
      "significance_level",
      "is_partial_linear"
    ],
    "get_regression_r2": [
      "self",
      "X",
      "Y",
      "numeric_features",
      "split_indices",
      "regression_model"
    ],
    "compute_r2diff_benchmarking_covariates": [
      "self",
      "treatment_df",
      "features",
      "T",
      "Y",
      "W",
      "benchmark_common_causes",
      "split_indices",
      "second_stage_linear",
      "is_partial_linear"
    ],
    "check_sensitivity": [
      "self",
      "plot"
    ],
    "plot": [
      "self",
      "plot_type",
      "plot_size",
      "contours_color",
      "critical_contour_color",
      "label_fontsize",
      "contour_linewidths",
      "contour_linestyles",
      "contours_label_color",
      "critical_label_color",
      "unadjusted_estimate_marker",
      "unadjusted_estimate_color",
      "adjusted_estimate_marker",
      "adjusted_estimate_color",
      "legend_position"
    ],
    "__str__": [
      "self"
    ]
  },
  "NonParametricSensitivityAnalyzer": {
    "__init__": [
      "self"
    ],
    "check_sensitivity": [
      "self",
      "plot"
    ],
    "get_phi_lower_upper": [
      "self",
      "Cg",
      "Calpha"
    ],
    "get_alpharegression_var": [
      "self",
      "X",
      "numeric_features",
      "split_indices",
      "reisz_model"
    ]
  },
  "TestFraction": [],
  "SUPPORTED_ESTIMATORS": [],
  "DEFAULT_STD_DEV": [],
  "DEFAULT_BUCKET_SCALE_FACTOR": [],
  "MIN_DATA_POINT_THRESHOLD": [],
  "DEFAULT_TRANSFORMATION": [],
  "DEFAULT_TRUE_CAUSAL_EFFECT": [],
  "DEFAULT_TEST_FRACTION": [],
  "DEFAULT_NEW_DATA_WITH_UNOBSERVED_CONFOUNDING": [],
  "DummyOutcomeRefuter": {
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "refute_dummy_outcome": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_name",
    "outcome_name",
    "required_variables",
    "min_data_point_threshold",
    "bucket_size_scale_factor",
    "num_simulations",
    "transformation_list",
    "test_fraction",
    "unobserved_confounder_values",
    "true_causal_effect",
    "show_progress_bar"
  ],
  "process_data": [
    "outcome_name",
    "X_train",
    "outcome_train",
    "X_validation",
    "outcome_validation",
    "transformation_list"
  ],
  "_has_estimator": [
    "transformation_list"
  ],
  "preprocess_data_by_treatment": [
    "data",
    "treatment_name",
    "unobserved_confounder_values",
    "bucket_size_scale_factor",
    "chosen_variables"
  ],
  "_estimate_dummy_outcome": [
    "action",
    "X_train",
    "outcome"
  ],
  "_get_regressor_object": [
    "action"
  ],
  "permute": [
    "outcome_name",
    "outcome",
    "permute_fraction"
  ],
  "noise": [
    "outcome",
    "std_dev"
  ],
  "BootstrapRefuter": {
    "DEFAULT_STD_DEV": [],
    "DEFAULT_SUCCESS_PROBABILITY": [],
    "DEFAULT_NUMBER_OF_TRIALS": [],
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "refute_bootstrap": [
    "data",
    "target_estimand",
    "estimate",
    "num_simulations",
    "random_state",
    "sample_size",
    "required_variables",
    "noise",
    "probability_of_change",
    "show_progress_bar",
    "n_jobs",
    "verbose"
  ],
  "SupportConfig": {},
  "OverlapConfig": {},
  "OverruleAnalyzer": {
    "__init__": [
      "self",
      "backdoor_vars",
      "treatment_name",
      "cat_feats",
      "support_config",
      "overlap_config",
      "prop_estimator",
      "overlap_eps",
      "support_only",
      "overlap_only",
      "verbose"
    ],
    "fit": [
      "self",
      "data"
    ],
    "_assess_propensity_overlap": [
      "self",
      "X",
      "t"
    ],
    "_predict_overlap_support": [
      "self",
      "X"
    ],
    "predict_overlap_support": [
      "self",
      "data"
    ],
    "filter_dataframe": [
      "self",
      "data"
    ],
    "describe_all_rules": [
      "self"
    ],
    "describe_support_rules": [
      "self"
    ],
    "describe_overlap_rules": [
      "self"
    ],
    "_describe_rules": [
      "self",
      "estimator",
      "X",
      "estimator_name"
    ],
    "_print_rule": [
      "self",
      "rule"
    ],
    "_check_is_fitted": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "LinearSensitivityAnalyzer": {
    "__init__": [
      "self",
      "estimator",
      "data",
      "treatment_name",
      "percent_change_estimate",
      "significance_level",
      "confounder_increases_estimate",
      "benchmark_common_causes",
      "null_hypothesis_effect",
      "frac_strength_treatment",
      "frac_strength_outcome",
      "common_causes_order"
    ],
    "treatment_regression": [
      "self"
    ],
    "partial_r2_func": [
      "self",
      "estimator_model",
      "treatment"
    ],
    "robustness_value_func": [
      "self",
      "alpha"
    ],
    "compute_bias_adjusted": [
      "self",
      "r2tu_w",
      "r2yu_tw"
    ],
    "check_sensitivity": [
      "self",
      "plot"
    ],
    "plot_estimate": [
      "self",
      "r2tu_w",
      "r2yu_tw"
    ],
    "plot_t": [
      "self",
      "r2tu_w",
      "r2yu_tw"
    ],
    "plot": [
      "self",
      "plot_type",
      "critical_value",
      "x_limit",
      "y_limit",
      "num_points_per_contour",
      "plot_size",
      "contours_color",
      "critical_contour_color",
      "label_fontsize",
      "contour_linewidths",
      "contour_linestyles",
      "contours_label_color",
      "critical_label_color",
      "unadjusted_estimate_marker",
      "unadjusted_estimate_color",
      "adjusted_estimate_marker",
      "adjusted_estimate_color",
      "legend_position"
    ],
    "__str__": [
      "self"
    ]
  },
  "get_alpha_estimator": [
    "cv",
    "X",
    "max_degree",
    "estimator_list",
    "estimator_param_list",
    "numeric_features",
    "plugin_reisz"
  ],
  "PluginReisz": {
    "__init__": [
      "self",
      "propensity_model"
    ],
    "fit": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "propensity": [
      "self",
      "X"
    ]
  },
  "reisz_scoring": [
    "g",
    "X"
  ],
  "ReiszRepresenter": {
    "__init__": [
      "self"
    ],
    "_get_alpha_and_pointJ": [
      "self",
      "X",
      "T",
      "y"
    ],
    "_get_n_outputs_decomposition": [
      "self",
      "X",
      "T",
      "y"
    ],
    "_translate": [
      "self",
      "point",
      "TX"
    ],
    "fit": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X_test"
    ]
  },
  "get_generic_regressor": [
    "cv",
    "X",
    "Y",
    "max_degree",
    "estimator_list",
    "estimator_param_list",
    "numeric_features"
  ],
  "DataSubsetRefuter": {
    "DEFAULT_SUBSET_FRACTION": [],
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "refute_data_subset": [
    "data",
    "target_estimand",
    "estimate",
    "subset_fraction",
    "num_simulations",
    "random_state",
    "show_progress_bar",
    "n_jobs",
    "verbose"
  ],
  "GraphRefuter": {
    "__init__": [
      "self",
      "data",
      "method_name_discrete",
      "method_name_continuous"
    ],
    "set_refutation_result": [
      "self",
      "number_of_constraints_model"
    ],
    "partial_correlation": [
      "self",
      "x",
      "y",
      "z"
    ],
    "conditional_mutual_information": [
      "self",
      "x",
      "y",
      "z"
    ],
    "refute_model": [
      "self",
      "independence_constraints"
    ]
  },
  "GraphRefutation": {
    "__init__": [
      "self",
      "method_name_discrete",
      "method_name_continuous"
    ],
    "add_conditional_independence_test_result": [
      "self",
      "number_of_constraints_model",
      "number_of_constraints_satisfied",
      "refutation_result"
    ],
    "__str__": [
      "self"
    ]
  },
  "RandomCommonCause": {
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ]
  },
  "refute_random_common_cause": [
    "data",
    "target_estimand",
    "estimate",
    "num_simulations",
    "random_state",
    "show_progress_bar",
    "n_jobs",
    "verbose"
  ],
  "ALL_REFUTERS": [],
  "refute_estimate": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_name",
    "outcome_name",
    "refuters"
  ],
  "DEFAULT_CONVERGENCE_THRESHOLD": [],
  "DEFAULT_C_STAR_MAX": [],
  "AddUnobservedCommonCause": {
    "__init__": [
      "self"
    ],
    "refute_estimate": [
      "self",
      "show_progress_bar"
    ],
    "include_simulated_confounder": [
      "self",
      "convergence_threshold",
      "c_star_max"
    ]
  },
  "preprocess_observed_common_causes": [
    "data",
    "target_estimand",
    "no_common_causes_error_message"
  ],
  "_infer_default_kappa_t": [
    "data",
    "target_estimand",
    "treatment_name",
    "effect_on_t",
    "frac_strength_treatment",
    "len_kappa_t"
  ],
  "_compute_min_max_coeff": [
    "min_coeff",
    "max_coeff",
    "effect_strength_fraction"
  ],
  "_infer_default_kappa_y": [
    "data",
    "target_estimand",
    "outcome_name",
    "effect_on_y",
    "frac_strength_outcome",
    "len_kappa_y"
  ],
  "_include_confounders_effect": [
    "data",
    "new_data",
    "effect_on_t",
    "treatment_name",
    "kappa_t",
    "effect_on_y",
    "outcome_name",
    "kappa_y"
  ],
  "include_simulated_confounder": [
    "data",
    "treatment_name",
    "outcome_name",
    "kappa_t",
    "kappa_y",
    "variables_of_interest",
    "convergence_threshold",
    "c_star_max"
  ],
  "_generate_confounder_from_residuals": [
    "c1",
    "c2",
    "d_y",
    "d_t",
    "X"
  ],
  "sensitivity_linear_partial_r2": [
    "data",
    "estimate",
    "treatment_name",
    "frac_strength_treatment",
    "frac_strength_outcome",
    "percent_change_estimate",
    "benchmark_common_causes",
    "significance_level",
    "null_hypothesis_effect",
    "plot_estimate"
  ],
  "sensitivity_non_parametric_partial_r2": [
    "estimate",
    "kappa_t",
    "kappa_y",
    "frac_strength_treatment",
    "frac_strength_outcome",
    "benchmark_common_causes",
    "plot_estimate",
    "alpha_s_estimator_list",
    "alpha_s_estimator_param_list",
    "g_s_estimator_list",
    "g_s_estimator_param_list",
    "plugin_reisz"
  ],
  "sensitivity_e_value": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_name",
    "outcome_name",
    "plot_estimate"
  ],
  "sensitivity_simulation": [
    "data",
    "target_estimand",
    "estimate",
    "treatment_name",
    "outcome_name",
    "kappa_t",
    "kappa_y",
    "confounders_effect_on_treatment",
    "confounders_effect_on_outcome",
    "frac_strength_treatment",
    "frac_strength_outcome",
    "plotmethod",
    "show_progress_bar"
  ],
  "sampleUnif": [
    "x",
    "n",
    "seed"
  ],
  "sample_reference": [
    "x",
    "n",
    "cat_cols",
    "seed",
    "ref_range"
  ],
  "fatom": [
    "f",
    "o",
    "v",
    "fmt"
  ],
  "rule_str": [
    "C",
    "fmt"
  ],
  "BCSRulesetEstimator": {
    "__init__": [
      "self",
      "n_ref_multiplier",
      "lambda0",
      "lambda1",
      "cat_cols",
      "negations",
      "num_thresh",
      "seed",
      "ref_range",
      "thresh_override"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "init_estimator_": [
      "self"
    ],
    "fit": [
      "self",
      "x",
      "o"
    ],
    "predict": [
      "self",
      "x"
    ],
    "predict_rules": [
      "self",
      "x"
    ],
    "rules": [
      "self",
      "as_str",
      "transform",
      "fmt",
      "labels"
    ],
    "get_params": [
      "self",
      "deep"
    ],
    "set_params": [
      "self"
    ]
  },
  "FeatureBinarizer": {
    "__init__": [
      "self",
      "colCateg",
      "numThresh",
      "negations",
      "threshStr",
      "threshOverride"
    ],
    "fit": [
      "self",
      "X"
    ],
    "transform": [
      "self",
      "X"
    ]
  },
  "OverlapBooleanRule": {
    "__init__": [
      "self",
      "alpha",
      "lambda0",
      "lambda1",
      "K",
      "D",
      "B",
      "iterMax",
      "eps",
      "silent",
      "verbose",
      "solver",
      "rounding"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "state"
    ],
    "fit": [
      "self",
      "X",
      "y"
    ],
    "greedy_round_": [
      "self",
      "X",
      "y",
      "xi",
      "use_lp"
    ],
    "round_": [
      "self",
      "X",
      "y",
      "scoring",
      "xi",
      "use_lp"
    ],
    "get_objective_value": [
      "self",
      "X",
      "o",
      "rounded"
    ],
    "compute_conjunctions": [
      "self",
      "X"
    ],
    "predict_": [
      "self",
      "X",
      "w"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_rules": [
      "self",
      "X"
    ],
    "get_params": [
      "self"
    ],
    "set_params": [
      "self"
    ]
  },
  "PricingInstance": {
    "__init__": [
      "self",
      "rp",
      "rn",
      "Xp",
      "Xn",
      "v0",
      "z0"
    ],
    "eval_singletons": [
      "self",
      "lambda1"
    ],
    "compute_LB": [
      "self",
      "lambda1"
    ]
  },
  "beam_search": [
    "r",
    "X",
    "lambda0",
    "lambda1",
    "K",
    "UB",
    "D",
    "B",
    "wLB",
    "eps"
  ],
  "add_lagged_edges": [
    "graph",
    "start_node"
  ],
  "shift_columns_by_lag_using_unrolled_graph": [
    "df",
    "unrolled_graph"
  ],
  "arrow_strength": [
    "causal_model",
    "target_node",
    "parent_samples",
    "num_samples_conditional",
    "max_num_runs",
    "tolerance",
    "n_jobs",
    "difference_estimation_func"
  ],
  "arrow_strength_of_model": [
    "conditional_stochastic_model",
    "input_samples",
    "num_samples_from_conditional",
    "max_num_runs",
    "tolerance",
    "n_jobs",
    "difference_estimation_func",
    "input_subsets"
  ],
  "_estimate_direct_strength": [
    "draw_samples_func",
    "distribution_samples",
    "parents_subset",
    "difference_estimation_func",
    "num_samples_conditional",
    "max_num_runs",
    "tolerance"
  ],
  "intrinsic_causal_influence": [
    "causal_model",
    "target_node",
    "prediction_model",
    "attribution_func",
    "num_training_samples",
    "num_samples_randomization",
    "num_samples_baseline",
    "max_batch_size",
    "auto_assign_quality",
    "shapley_config"
  ],
  "intrinsic_causal_influence_sample": [
    "causal_model",
    "target_node",
    "baseline_samples",
    "noise_feature_samples",
    "prediction_model",
    "subset_scoring_func",
    "num_noise_feature_samples",
    "max_batch_size",
    "auto_assign_quality",
    "shapley_config"
  ],
  "_estimate_iccs": [
    "attribution_func",
    "prediction_method",
    "noise_samples",
    "baseline_noise_samples",
    "max_batch_size",
    "shapley_config"
  ],
  "_get_icc_noise_function": [
    "causal_model",
    "target_node",
    "prediction_model",
    "noise_samples",
    "node_names",
    "target_samples",
    "auto_assign_quality",
    "target_is_categorical"
  ],
  "estimate_entropy_using_discretization": [
    "X",
    "bin_width"
  ],
  "estimate_entropy_kmeans": [
    "X"
  ],
  "estimate_gaussian_entropy": [
    "X"
  ],
  "estimate_variance": [
    "X"
  ],
  "estimate_entropy_of_probabilities": [
    "X"
  ],
  "estimate_entropy_discrete": [
    "X"
  ],
  "fit": [
    "causal_model",
    "data",
    "return_evaluation_summary"
  ],
  "fit_causal_model_of_target": [
    "causal_model",
    "target_node",
    "training_data"
  ],
  "draw_samples": [
    "causal_model",
    "num_samples"
  ],
  "_parent_samples_of": [
    "node",
    "scm",
    "samples"
  ],
  "CAUSAL_MECHANISM": [],
  "PARENTS_DURING_FIT": [],
  "ProbabilisticCausalModel": {
    "__init__": [
      "self",
      "graph",
      "graph_copier",
      "remove_existing_mechanisms"
    ],
    "set_causal_mechanism": [
      "self",
      "node",
      "mechanism"
    ],
    "causal_mechanism": [
      "self",
      "node"
    ],
    "clone": [
      "self"
    ]
  },
  "StructuralCausalModel": {
    "set_causal_mechanism": [
      "self",
      "node",
      "mechanism"
    ],
    "causal_mechanism": [
      "self",
      "node"
    ]
  },
  "InvertibleStructuralCausalModel": {
    "set_causal_mechanism": [
      "self",
      "target_node",
      "mechanism"
    ],
    "causal_mechanism": [
      "self",
      "node"
    ]
  },
  "validate_causal_model_assignment": [
    "causal_graph",
    "target_node"
  ],
  "validate_node_has_causal_model": [
    "causal_graph",
    "node"
  ],
  "validate_causal_dag": [
    "causal_graph"
  ],
  "validate_causal_graph": [
    "causal_graph"
  ],
  "validate_node": [
    "causal_graph",
    "node"
  ],
  "validate_local_structure": [
    "causal_graph",
    "node"
  ],
  "clone_causal_models": [
    "source",
    "destination"
  ],
  "MedianCDFQuantileScorer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "RescaledMedianCDFQuantileScorer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "RankBasedAnomalyScorer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "ITAnomalyScorer": {
    "__init__": [
      "self",
      "anomaly_scorer"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "MeanDeviationScorer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "MedianDeviationScorer": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "InverseDensityScorer": {
    "__init__": [
      "self",
      "density_estimator"
    ],
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "AnomalyScorer": {
    "fit": [
      "self",
      "X"
    ],
    "score": [
      "self",
      "X"
    ]
  },
  "DensityEstimator": {
    "fit": [
      "self",
      "X"
    ],
    "density": [
      "self",
      "X"
    ]
  },
  "conditional_anomaly_scores": [
    "parent_samples",
    "target_samples",
    "causal_mechanism",
    "anomaly_scorer_factory",
    "num_samples_conditional"
  ],
  "anomaly_scores": [
    "causal_model",
    "anomaly_data",
    "num_samples_conditional",
    "num_samples_unconditional",
    "anomaly_scorer_factory"
  ],
  "attribute_anomalies": [
    "causal_model",
    "target_node",
    "anomaly_samples",
    "anomaly_scorer",
    "attribute_mean_deviation",
    "num_distribution_samples",
    "shapley_config"
  ],
  "attribute_anomaly_scores": [
    "anomaly_samples",
    "distribution_samples",
    "anomaly_scoring_func",
    "attribute_mean_deviation",
    "shapley_config"
  ],
  "_relative_frequency": [
    "conditions"
  ],
  "parent_relevance": [
    "causal_model",
    "target_node",
    "parent_samples",
    "subset_scoring_func",
    "num_samples_randomization",
    "num_samples_baseline",
    "max_batch_size",
    "shapley_config"
  ],
  "feature_relevance_distribution": [
    "prediction_method",
    "feature_samples",
    "subset_scoring_func",
    "max_num_samples_randomization",
    "max_num_baseline_samples",
    "max_batch_size",
    "randomize_features_jointly",
    "shapley_config"
  ],
  "feature_relevance_sample": [
    "prediction_method",
    "feature_samples",
    "baseline_samples",
    "subset_scoring_func",
    "baseline_target_values",
    "average_set_function",
    "max_batch_size",
    "randomize_features_jointly",
    "shapley_config"
  ],
  "merge_p_values_average": [
    "p_values",
    "randomization"
  ],
  "merge_p_values_quantile": [
    "p_values",
    "p_values_scaling",
    "quantile"
  ],
  "merge_p_values_fdr": [
    "p_values",
    "fdr_method"
  ],
  "marginal_expectation": [
    "prediction_method",
    "feature_samples",
    "baseline_samples",
    "baseline_feature_indices",
    "return_averaged_results",
    "feature_perturbation",
    "max_batch_size"
  ],
  "permute_features": [
    "feature_samples",
    "features_to_permute",
    "randomize_features_jointly"
  ],
  "estimate_ftest_pvalue": [
    "X_training_a",
    "X_training_b",
    "Y_training",
    "X_test_a",
    "X_test_b",
    "Y_test"
  ],
  "estimate_geometric_median": [
    "X"
  ],
  "confidence_intervals": [
    "estimation_func",
    "confidence_level",
    "num_bootstrap_resamples",
    "bootstrap_results_summary_func",
    "n_jobs"
  ],
  "_estimate_percentile_bounds": [
    "X",
    "quantile"
  ],
  "_LIST_OF_POTENTIAL_CLASSIFIERS_GOOD": [],
  "_LIST_OF_POTENTIAL_REGRESSORS_GOOD": [],
  "_LIST_OF_POTENTIAL_CLASSIFIERS_BETTER": [],
  "_LIST_OF_POTENTIAL_REGRESSORS_BETTER": [],
  "_LIST_OF_REGRESSOR_SUPPORTING_MISSING_DATA_GOOD": [],
  "_LIST_OF_REGRESSOR_SUPPORTING_MISSING_DATA_BETTER": [],
  "_LIST_OF_CLASSIFIER_SUPPORTING_MISSING_DATA_GOOD": [],
  "_LIST_OF_CLASSIFIER_SUPPORTING_MISSING_DATA_BETTER": [],
  "AssignmentQuality": {
    "GOOD": [],
    "BETTER": [],
    "BEST": []
  },
  "AutoAssignmentSummary": {
    "__init__": [
      "self"
    ],
    "_init_node_entry": [
      "self",
      "node"
    ],
    "add_node_log_message": [
      "self",
      "node",
      "message"
    ],
    "add_model_performance": [
      "self",
      "node",
      "model",
      "performance",
      "metric_name"
    ],
    "__str__": [
      "self"
    ]
  },
  "assign_causal_mechanisms": [
    "causal_model",
    "based_on",
    "quality",
    "override_models",
    "experimental_allow_nans"
  ],
  "assign_causal_mechanism_node": [
    "causal_model",
    "node",
    "based_on",
    "quality"
  ],
  "select_model": [
    "X",
    "Y",
    "model_selection_quality"
  ],
  "has_linear_relationship": [
    "X",
    "Y",
    "max_num_samples"
  ],
  "find_best_model": [
    "prediction_model_factories",
    "X",
    "Y",
    "metric",
    "max_samples_per_split",
    "model_selection_splits",
    "n_jobs"
  ],
  "_CONTINUOUS_DISTRIBUTIONS": [],
  "_DISCRETE_DISTRIBUTIONS": [],
  "ScipyDistribution": {
    "__init__": [
      "self",
      "scipy_distribution"
    ],
    "draw_samples": [
      "self",
      "num_samples"
    ],
    "fit": [
      "self",
      "X"
    ],
    "parameters": [
      "self"
    ],
    "scipy_distribution": [
      "self"
    ],
    "clone": [
      "self"
    ],
    "find_suitable_continuous_distribution": [
      "distribution_samples",
      "divergence_threshold"
    ],
    "map_scipy_distribution_parameters_to_names": [
      "scipy_distribution",
      "parameters"
    ],
    "__str__": [
      "self"
    ]
  },
  "EmpiricalDistribution": {
    "__init__": [
      "self"
    ],
    "data": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "draw_samples": [
      "self",
      "num_samples"
    ],
    "clone": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "BayesianGaussianMixtureDistribution": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "_get_optimal_number_of_components": [
      "X"
    ],
    "draw_samples": [
      "self",
      "num_samples"
    ],
    "__str__": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "auto_estimate_kl_divergence": [
    "X",
    "Y"
  ],
  "estimate_kl_divergence_continuous_knn": [
    "X",
    "Y",
    "k",
    "remove_common_elements",
    "n_jobs"
  ],
  "estimate_kl_divergence_continuous_clf": [
    "samples_P",
    "samples_Q",
    "n_splits",
    "classifier_model",
    "epsilon"
  ],
  "estimate_kl_divergence_categorical": [
    "X",
    "Y"
  ],
  "estimate_kl_divergence_of_probabilities": [
    "X",
    "Y"
  ],
  "is_probability_matrix": [
    "X"
  ],
  "ThetaC": {
    "__init__": [
      "self",
      "C",
      "h_fn",
      "warn_th"
    ],
    "_simplify_C": [
      "self",
      "all_indep"
    ],
    "_train_reg": [
      "self",
      "X_train",
      "y_train",
      "T_train",
      "w_train",
      "regressor"
    ],
    "_train_cla": [
      "self",
      "X_train",
      "T_train",
      "X_eval",
      "w_train",
      "classifier",
      "calibrator",
      "X_calib",
      "T_calib",
      "w_calib"
    ],
    "_get_alphas": [
      "self",
      "X_eval",
      "T_eval",
      "ratio",
      "calibrator",
      "crop"
    ],
    "est_scores": [
      "self",
      "X_eval",
      "y_eval",
      "T_eval",
      "X_train",
      "y_train",
      "T_train",
      "w_eval",
      "w_train",
      "method",
      "regressor",
      "classifier",
      "calibrator",
      "X_calib",
      "T_calib",
      "w_calib",
      "all_indep",
      "crop"
    ],
    "est_theta": [
      "self",
      "X_eval",
      "y_eval",
      "T_eval",
      "X_train",
      "y_train",
      "T_train",
      "w_eval",
      "w_train",
      "method",
      "regressor",
      "classifier",
      "calibrator",
      "X_calib",
      "T_calib",
      "w_calib",
      "all_indep",
      "crop"
    ]
  },
  "distribution_change_robust": [
    "causal_model",
    "old_data",
    "new_data",
    "target_node",
    "target_functional",
    "sample_weight",
    "xfit",
    "xfit_folds",
    "train_size",
    "calib_size",
    "split_random_state",
    "method",
    "regressor",
    "classifier",
    "calibrator",
    "all_indep",
    "crop",
    "shapley_config"
  ],
  "show_progress_bars": [],
  "default_n_jobs": [],
  "enable_progress_bars": [],
  "disable_progress_bars": [],
  "set_default_n_jobs": [
    "n_jobs"
  ],
  "LinearPredictionModel": {
    "coefficients": [
      "self"
    ]
  },
  "SklearnLinearRegressionModel": {
    "__init__": [
      "self",
      "sklearn_mdl"
    ],
    "coefficients": [
      "self"
    ]
  },
  "unit_change": [
    "background_df",
    "foreground_df",
    "input_column_names",
    "background_mechanism",
    "foreground_mechanism",
    "shapley_config"
  ],
  "unit_change_nonlinear": [
    "background_mechanism",
    "background_df",
    "foreground_mechanism",
    "foreground_df",
    "input_column_names",
    "shapley_config"
  ],
  "unit_change_linear": [
    "background_mechanism",
    "background_df",
    "foreground_mechanism",
    "foreground_df",
    "input_column_names"
  ],
  "unit_change_nonlinear_input_only": [
    "mechanism",
    "background_df",
    "foreground_df",
    "input_column_names",
    "shapley_config"
  ],
  "unit_change_linear_input_only": [
    "mechanism",
    "background_df",
    "foreground_df",
    "input_column_names"
  ],
  "_check_if_input_columns_exist": [
    "background_df",
    "foreground_df",
    "input_column_names"
  ],
  "interventional_samples": [
    "causal_model",
    "interventions",
    "observed_data",
    "num_samples_to_draw"
  ],
  "_interventional_samples": [
    "pcm",
    "observed_data",
    "interventions"
  ],
  "_get_nodes_affected_by_intervention": [
    "causal_graph",
    "target_nodes"
  ],
  "counterfactual_samples": [
    "causal_model",
    "interventions",
    "observed_data",
    "noise_data"
  ],
  "_counterfactual_samples": [
    "scm",
    "interventions",
    "noise_data"
  ],
  "_evaluate_intervention": [
    "node",
    "interventions",
    "pre_intervention_data"
  ],
  "average_causal_effect": [
    "causal_model",
    "target_node",
    "interventions_alternative",
    "interventions_reference",
    "observed_data",
    "num_samples_to_draw"
  ],
  "compute_data_from_noise": [
    "causal_model",
    "noise_data"
  ],
  "compute_noise_from_data": [
    "causal_model",
    "observed_data"
  ],
  "get_noise_dependent_function": [
    "causal_model",
    "target_node",
    "approx_prediction_model",
    "num_training_samples"
  ],
  "_get_exact_noise_dependent_function": [
    "causal_model",
    "target_node"
  ],
  "_get_approx_noise_dependent_function": [
    "causal_model",
    "target_node",
    "approx_prediction_model",
    "num_training_samples"
  ],
  "noise_samples_of_ancestors": [
    "causal_model",
    "target_node",
    "num_samples"
  ],
  "mechanism_change_test": [
    "target_original_data",
    "target_new_data",
    "parents_original_data",
    "parents_new_data",
    "independence_test",
    "conditional_independence_test"
  ],
  "distribution_change": [
    "causal_model",
    "old_data",
    "new_data",
    "target_node",
    "invariant_nodes",
    "num_samples",
    "difference_estimation_func",
    "independence_test",
    "conditional_independence_test",
    "mechanism_change_test_significance_level",
    "mechanism_change_test_fdr_control_method",
    "auto_assignment_quality",
    "return_additional_info",
    "shapley_config",
    "graph_factory"
  ],
  "distribution_change_of_graphs": [
    "causal_model_old",
    "causal_model_new",
    "target_node",
    "num_samples",
    "difference_estimation_func",
    "shapley_config",
    "graph_factory"
  ],
  "_remove_invariant_nodes": [
    "invariant_nodes",
    "causal_model",
    "old_data",
    "auto_assignment_quality"
  ],
  "_fit_accounting_for_mechanism_change": [
    "causal_model_old",
    "causal_model_new",
    "old_data",
    "new_data",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "fdr_control_method",
    "invariant_nodes"
  ],
  "_estimate_marginal_distribution_change": [
    "causal_model_old",
    "causal_model_new",
    "target_node",
    "num_samples",
    "difference_estimation_func",
    "shapley_config",
    "graph_factory"
  ],
  "estimate_distribution_change_scores": [
    "causal_model",
    "original_data",
    "new_data",
    "difference_estimation_func",
    "max_num_evaluation_samples",
    "num_joint_samples",
    "early_stopping_percentage",
    "independence_test",
    "conditional_independence_test",
    "mechanism_change_test_significance_level",
    "mechanism_change_test_fdr_control_method"
  ],
  "_check_significant_mechanism_change": [
    "graph",
    "old_data",
    "new_data",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "fdr_control_method"
  ],
  "_estimate_distribution_change_score": [
    "parent_original_data",
    "parent_new_data",
    "target_new_data",
    "causal_model_original",
    "difference_estimation_func",
    "max_num_evaluation_samples",
    "num_joint_samples",
    "early_stopping_percentage"
  ],
  "RejectionResult": {
    "REJECTED": [],
    "NOT_REJECTED": []
  },
  "refute_causal_structure": [
    "causal_graph",
    "data",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "fdr_control_method"
  ],
  "refute_invertible_model": [
    "causal_model",
    "data",
    "independence_test",
    "significance_level",
    "fdr_control_method"
  ],
  "_get_non_descendants": [
    "causal_graph",
    "node",
    "exclude_parents"
  ],
  "_STOCHASTIC_MODEL_TYPES": [],
  "_NOISE_MODEL_PATTERN": [],
  "_NODE_NAME_PATTERN": [],
  "_UNKNOWN_MODEL_PATTERN": [],
  "_allowed_callables": [],
  "_np_functions": [],
  "_scipy_functions": [],
  "_builtin_functions": [],
  "create_causal_model_from_equations": [
    "node_equations"
  ],
  "_parse_args": [
    "args"
  ],
  "_add_parent_nodes_to_graph": [
    "causal_graph",
    "parent_nodes",
    "node_name"
  ],
  "_identify_noise_model": [
    "causal_mechanism_name",
    "parsed_args"
  ],
  "_extract_noise_model_components": [
    "noise_eq"
  ],
  "_extract_equation_components": [
    "equation"
  ],
  "_get_sorted_parent_nodes": [
    "parent_node_candidates"
  ],
  "_add_undefined_nodes_info": [
    "causal_nodes_info",
    "present_nodes"
  ],
  "_check_node_redundancy": [
    "causal_nodes_info",
    "node_name"
  ],
  "_sanitize_input_expression": [
    "expression",
    "banned_characters"
  ],
  "_check_if_model_is_unknown": [
    "equation",
    "expression"
  ],
  "CustomEquationModel": {
    "__init__": [
      "self",
      "custom_func",
      "parent_nodes"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "clone": [
      "self"
    ]
  },
  "GaussianMixtureDensityEstimator": {
    "__init__": [
      "self",
      "num_components"
    ],
    "fit": [
      "self",
      "X"
    ],
    "density": [
      "self",
      "X"
    ]
  },
  "KernelDensityEstimator1D": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "X"
    ],
    "_validate_data": [
      "self",
      "X"
    ],
    "density": [
      "self",
      "X"
    ]
  },
  "StochasticModel": {
    "fit": [
      "self",
      "X"
    ],
    "draw_samples": [
      "self",
      "num_samples"
    ],
    "clone": [
      "self"
    ]
  },
  "ConditionalStochasticModel": {
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "draw_samples": [
      "self",
      "parent_samples"
    ],
    "clone": [
      "self"
    ]
  },
  "FunctionalCausalModel": {
    "draw_samples": [
      "self",
      "parent_samples"
    ],
    "draw_noise_samples": [
      "self",
      "num_samples"
    ],
    "evaluate": [
      "self",
      "parent_samples",
      "noise_samples"
    ]
  },
  "InvertibleFunctionalCausalModel": {
    "estimate_noise": [
      "self",
      "target_samples",
      "parent_samples"
    ]
  },
  "PostNonlinearModel": {
    "__init__": [
      "self",
      "prediction_model",
      "noise_model",
      "invertible_function"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "estimate_noise": [
      "self",
      "target_samples",
      "parent_samples"
    ],
    "draw_noise_samples": [
      "self",
      "num_samples"
    ],
    "evaluate": [
      "self",
      "parent_samples",
      "noise_samples"
    ],
    "__str__": [
      "self"
    ],
    "clone": [
      "self"
    ],
    "prediction_model": [
      "self"
    ],
    "noise_model": [
      "self"
    ],
    "invertible_function": [
      "self"
    ]
  },
  "AdditiveNoiseModel": {
    "__init__": [
      "self",
      "prediction_model",
      "noise_model"
    ],
    "clone": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "DiscreteAdditiveNoiseModel": {
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "evaluate": [
      "self",
      "parent_samples",
      "noise_samples"
    ],
    "estimate_noise": [
      "self",
      "target_samples",
      "parent_samples"
    ],
    "_rounded_prediction": [
      "self",
      "X"
    ],
    "clone": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "ProbabilityEstimatorModel": {
    "estimate_probabilities": [
      "self",
      "parent_samples"
    ]
  },
  "ClassifierFCM": {
    "__init__": [
      "self",
      "classifier_model"
    ],
    "draw_noise_samples": [
      "self",
      "num_samples"
    ],
    "evaluate": [
      "self",
      "parent_samples",
      "noise_samples"
    ],
    "estimate_probabilities": [
      "self",
      "parent_samples"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "clone": [
      "self"
    ],
    "get_class_names": [
      "self",
      "class_indices"
    ],
    "classifier_model": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "EPS": [],
  "EvaluateCausalModelConfig": {
    "__init__": [
      "self",
      "mechanism_evaluation_kfolds",
      "baseline_models_regression",
      "baseline_models_classification",
      "independence_test_invertible",
      "significance_level_invertible",
      "fdr_control_method_invertible",
      "bootstrap_runs_invertible",
      "max_num_permutations_falsify",
      "independence_test_falsify",
      "conditional_independence_test_falsify",
      "falsify_graph_significance_level",
      "n_jobs"
    ]
  },
  "MechanismPerformanceResult": {
    "__init__": [
      "self",
      "node_name",
      "is_root",
      "crps",
      "kl_divergence",
      "mse",
      "nmse",
      "r2",
      "f1",
      "count_better_performance",
      "best_baseline_model",
      "total_number_baselines",
      "best_baseline_performance"
    ]
  },
  "CausalModelEvaluationResult": {
    "__str__": [
      "self"
    ]
  },
  "evaluate_causal_model": [
    "causal_model",
    "data",
    "max_num_samples",
    "evaluate_causal_mechanisms",
    "compare_mechanism_baselines",
    "evaluate_invertibility_assumptions",
    "evaluate_overall_kl_divergence",
    "evaluate_causal_structure",
    "config"
  ],
  "_evaluate_model_performances": [
    "causal_model",
    "data",
    "compare_mechanism_baselines",
    "baseline_models_regression",
    "baseline_models_classification",
    "kfolds",
    "n_jobs"
  ],
  "_evaluate_invertibility_assumptions": [
    "causal_model",
    "data",
    "independence_test_invertible",
    "significance_level_invertible",
    "fdr_control_method_invertible",
    "bootstrap_runs_invertible",
    "max_num_samples_per_run"
  ],
  "_estimate_conditional_expectations": [
    "causal_mechanism",
    "parent_samples",
    "categorical",
    "num_samples_conditional_samples"
  ],
  "nmse": [
    "y_true",
    "y_pred",
    "squared"
  ],
  "crps": [
    "X",
    "Y",
    "conditional_sampling_method",
    "num_conditional_samples",
    "normalize"
  ],
  "_get_kl_divergence_interpretation_string": [
    "kl_divergence"
  ],
  "_get_crps_interpretation_string": [
    "crps"
  ],
  "_get_baseline_model_interpretation_string": [
    "count_better",
    "count_total",
    "best_baseline_model",
    "best_baseline_performance"
  ],
  "ShapleyApproximationMethods": {
    "AUTO": [],
    "EXACT": [],
    "EXACT_FAST": [],
    "EARLY_STOPPING": [],
    "PERMUTATION": [],
    "SUBSET_SAMPLING": []
  },
  "ShapleyConfig": {
    "__init__": [
      "self",
      "approximation_method",
      "num_permutations",
      "num_subset_samples",
      "min_percentage_change_threshold",
      "n_jobs"
    ]
  },
  "estimate_shapley_values": [
    "set_func",
    "num_players",
    "shapley_config"
  ],
  "_estimate_shapley_values_exact": [
    "set_func",
    "num_players",
    "n_jobs"
  ],
  "_approximate_shapley_values_via_least_squares_regression": [
    "set_func",
    "num_players",
    "use_subset_approximation",
    "num_samples_for_approximation",
    "n_jobs",
    "full_and_empty_subset_weight"
  ],
  "_approximate_shapley_values_via_permutation_sampling": [
    "set_func",
    "num_players",
    "num_permutations",
    "n_jobs",
    "use_halton_sequence"
  ],
  "_approximate_shapley_values_via_early_stopping": [
    "set_func",
    "num_players",
    "max_num_permutations",
    "min_percentage_change_threshold",
    "n_jobs",
    "num_permutations_per_run",
    "use_halton_sequence",
    "num_consecutive_converged_runs"
  ],
  "_check_convergence": [
    "new_shap_proxy",
    "old_shap_proxy",
    "min_percentage_change_threshold"
  ],
  "_create_subsets_and_weights_exact": [
    "num_players",
    "high_weight"
  ],
  "_create_subsets_and_weights_approximation": [
    "num_players",
    "high_weight",
    "num_subset_samples"
  ],
  "_convert_list_of_indices_to_binary_vector_as_tuple": [
    "list_of_indices",
    "num_players"
  ],
  "_evaluate_set_function": [
    "set_func",
    "evaluation_subsets",
    "parallel_context",
    "show_progressbar"
  ],
  "_estimate_full_and_emtpy_subset_results": [
    "set_func",
    "num_players"
  ],
  "_create_index_order_and_subset_tuples": [
    "permutation"
  ],
  "_estimate_shapley_values_of_permutation": [
    "permutation",
    "evaluated_subsets",
    "full_subset_result",
    "empty_subset_result"
  ],
  "VIOLATION_COLOR": [],
  "COLORS": [],
  "FalsifyConst": {
    "N_VIOLATIONS": [],
    "N_TESTS": [],
    "P_VALUE": [],
    "P_VALUES": [],
    "GIVEN_VIOLATIONS": [],
    "PERM_VIOLATIONS": [],
    "F_GIVEN_VIOLATIONS": [],
    "F_PERM_VIOLATIONS": [],
    "LOCAL_VIOLATION_INSIGHT": [],
    "METHOD": [],
    "VALIDATE_LMC": [],
    "VALIDATE_TPA": [],
    "VALIDATE_PD": [],
    "VALIDATE_CM": [],
    "PERM_GRAPHS": [],
    "MEC": []
  },
  "FALSIFY_METHODS": [],
  "_PValuesMemory": {
    "add_p_value": [
      "self",
      "p_value",
      "X",
      "Y",
      "Z"
    ],
    "get_p_value": [
      "self",
      "X",
      "Y",
      "Z"
    ],
    "__contains__": [
      "self",
      "item"
    ]
  },
  "validate_lmc": [
    "causal_graph",
    "data",
    "p_values_memory",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "include_unconditional",
    "n_jobs"
  ],
  "validate_tpa": [
    "causal_graph",
    "causal_graph_reference",
    "include_unconditional"
  ],
  "validate_pd": [
    "causal_graph",
    "data",
    "p_values_memory",
    "n_pairs",
    "independence_test",
    "significance_level",
    "adjacent_only",
    "n_jobs"
  ],
  "validate_cm": [
    "causal_graph",
    "data",
    "p_values_memory",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "n_jobs"
  ],
  "run_validations": [
    "causal_graph",
    "data",
    "methods"
  ],
  "EvaluationResult": {
    "update_significance_level": [
      "self",
      "significance_level"
    ],
    "__post_init__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_can_evaluate": [
      "self"
    ]
  },
  "falsify_graph": [
    "causal_graph",
    "data",
    "suggestions",
    "independence_test",
    "conditional_independence_test",
    "significance_level",
    "significance_ci",
    "n_permutations",
    "show_progress_bar",
    "n_jobs",
    "plot_histogram",
    "plot_kwargs",
    "allow_data_subset"
  ],
  "apply_suggestions": [
    "causal_graph",
    "evaluation_result",
    "edges_to_keep"
  ],
  "plot_evaluation_results": [
    "evaluation_result",
    "figsize",
    "bins",
    "title",
    "savepath",
    "display"
  ],
  "plot_local_insights": [
    "causal_graph",
    "evaluation_result",
    "method"
  ],
  "_generate_table": [
    "validation_repr",
    "suggestion_repr",
    "width",
    "validation_name",
    "suggestion_name"
  ],
  "_compute_p_value": [
    "data",
    "X",
    "Y",
    "Z",
    "independence_test",
    "conditional_independence_test",
    "seed"
  ],
  "_get_parental_triples": [
    "causal_graph",
    "include_unconditional"
  ],
  "_permutation_based": [
    "causal_graph",
    "data",
    "methods",
    "exclude_original_order",
    "n_permutations",
    "show_progress_bar"
  ],
  "_PermuteNodes": {
    "__init__": [
      "self",
      "causal_graph",
      "exclude_original_order",
      "n_permutations"
    ],
    "iter_all_permutations": [
      "self"
    ],
    "iter_random_permutations": [
      "self"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "_to_frozenset": [
    "x"
  ],
  "bootstrap_sampling": [],
  "fit_and_compute": [
    "f",
    "causal_model",
    "bootstrap_training_data",
    "bootstrap_data_subset_size_fraction",
    "auto_assign_quality"
  ],
  "kernel_based": [
    "X",
    "Y",
    "Z",
    "use_bootstrap",
    "bootstrap_num_runs",
    "max_num_samples_run",
    "bootstrap_n_jobs",
    "p_value_adjust_func"
  ],
  "approx_kernel_based": [
    "X",
    "Y",
    "Z",
    "num_random_features_X",
    "num_random_features_Y",
    "num_random_features_Z",
    "num_permutations",
    "approx_kernel",
    "scale_data",
    "use_bootstrap",
    "bootstrap_num_runs",
    "bootstrap_num_samples",
    "bootstrap_n_jobs",
    "p_value_adjust_func"
  ],
  "_rit": [
    "X",
    "Y",
    "num_random_features_X",
    "num_random_features_Y",
    "num_permutations",
    "num_runs",
    "num_max_samples_per_run",
    "approx_kernel",
    "scale_data",
    "n_jobs",
    "p_value_adjust_func"
  ],
  "_rcit": [
    "X",
    "Y",
    "Z",
    "num_random_features_X",
    "num_random_features_Y",
    "num_random_features_Z",
    "num_permutations",
    "num_runs",
    "num_max_samples_per_run",
    "approx_kernel",
    "scale_data",
    "n_jobs",
    "p_value_adjust_func"
  ],
  "_estimate_rit_statistic": [
    "X",
    "Y"
  ],
  "_estimate_column_wise_covariances": [
    "X",
    "Y"
  ],
  "_convert_to_numeric": [],
  "_remove_constant_columns": [
    "X"
  ],
  "generalised_cov_based": [
    "X",
    "Y",
    "Z",
    "prediction_model_X",
    "prediction_model_Y"
  ],
  "_create_model": [
    "input_features",
    "target",
    "model"
  ],
  "independence_test": [
    "X",
    "Y",
    "conditioned_on",
    "method"
  ],
  "apply_rbf_kernel": [
    "X",
    "precision"
  ],
  "apply_rbf_kernel_with_adaptive_precision": [
    "X"
  ],
  "apply_delta_kernel": [
    "X"
  ],
  "approximate_rbf_kernel_features": [
    "X",
    "num_random_components",
    "precision"
  ],
  "approximate_delta_kernel_features": [
    "X",
    "num_random_components"
  ],
  "_median_based_precision": [
    "distances"
  ],
  "regression_based": [
    "X",
    "Y",
    "Z",
    "max_num_components_all_inputs",
    "k_folds",
    "p_value_adjust_func",
    "max_samples_per_fold",
    "n_jobs"
  ],
  "ClassificationModel": {
    "predict_probabilities": [
      "self",
      "X"
    ],
    "classes": [
      "self"
    ]
  },
  "SklearnClassificationModel": {
    "predict_probabilities": [
      "self",
      "X"
    ],
    "classes": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "SklearnClassificationModelWeighted": {
    "predict_probabilities": [
      "self",
      "X"
    ],
    "classes": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "create_random_forest_classifier": [],
  "create_gaussian_process_classifier": [],
  "create_hist_gradient_boost_classifier": [],
  "create_logistic_regression_classifier": [],
  "create_extra_trees_classifier": [],
  "create_ada_boost_classifier": [],
  "create_support_vector_classifier": [],
  "create_knn_classifier": [],
  "create_gaussian_nb_classifier": [],
  "create_polynom_logistic_regression_classifier": [
    "degree"
  ],
  "create_decision_tree_classifier": [],
  "SklearnRegressionModel": {
    "__init__": [
      "self",
      "sklearn_mdl"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "sklearn_model": [
      "self"
    ],
    "clone": [
      "self"
    ],
    "__str__": [
      "self"
    ]
  },
  "SklearnRegressionModelWeighted": {
    "fit": [
      "self",
      "X",
      "Y",
      "sample_weight"
    ]
  },
  "LinearRegressionWithFixedParameter": {
    "__init__": [
      "self",
      "coefficients",
      "intercept"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "clone": [
      "self"
    ]
  },
  "create_linear_regressor_with_given_parameters": [
    "coefficients",
    "intercept"
  ],
  "create_linear_regressor": [],
  "create_ridge_regressor": [],
  "create_lasso_regressor": [],
  "create_lasso_lars_ic_regressor": [],
  "create_elastic_net_regressor": [],
  "create_gaussian_process_regressor": [],
  "create_support_vector_regressor": [],
  "create_random_forest_regressor": [],
  "create_hist_gradient_boost_regressor": [],
  "create_extra_trees_regressor": [],
  "create_knn_regressor": [],
  "create_ada_boost_regressor": [],
  "create_polynom_regressor": [
    "degree"
  ],
  "InvertibleFunction": {
    "evaluate": [
      "self",
      "X"
    ],
    "evaluate_inverse": [
      "self",
      "X"
    ]
  },
  "InvertibleIdentityFunction": {
    "evaluate": [
      "self",
      "X"
    ],
    "evaluate_inverse": [
      "self",
      "X"
    ]
  },
  "InvertibleExponentialFunction": {
    "evaluate": [
      "self",
      "X"
    ],
    "evaluate_inverse": [
      "self",
      "X"
    ]
  },
  "InvertibleLogarithmicFunction": {
    "evaluate": [
      "self",
      "X"
    ],
    "evaluate_inverse": [
      "self",
      "X"
    ]
  },
  "PredictionModel": {
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "clone": [
      "self"
    ]
  },
  "_AutoGluonModel": {
    "__init__": [
      "self",
      "verbosity",
      "eval_metric",
      "path",
      "model_persistence_max_memory"
    ],
    "fit": [
      "self",
      "X",
      "Y"
    ],
    "predict": [
      "self",
      "X"
    ],
    "auto_gluon_model": [
      "self"
    ],
    "fit_parameters": [
      "self"
    ]
  },
  "AutoGluonRegressor": {
    "__init__": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "AutoGluonClassifier": {
    "__init__": [
      "self"
    ],
    "predict_probabilities": [
      "self",
      "X"
    ],
    "classes": [
      "self"
    ],
    "clone": [
      "self"
    ]
  },
  "CatBoostEncoder": {
    "__init__": [
      "self",
      "p",
      "alpha"
    ],
    "fit": [
      "self",
      "X",
      "Y",
      "use_alpha_when_unique"
    ],
    "fit_transform": [
      "self",
      "X",
      "Y",
      "use_alpha_when_unique"
    ],
    "transform": [
      "self",
      "X",
      "Y",
      "use_alpha_when_unique"
    ],
    "_fit_transform": [
      "self",
      "X",
      "Y",
      "use_alpha_when_unique",
      "train"
    ]
  },
  "shape_into_2d": [],
  "set_random_seed": [
    "random_seed"
  ],
  "auto_fit_encoders": [
    "X",
    "Y",
    "catboost_threshold"
  ],
  "auto_apply_encoders": [
    "X",
    "encoder_map",
    "Y"
  ],
  "fit_one_hot_encoders": [
    "X"
  ],
  "apply_one_hot_encoding": [
    "X",
    "one_hot_encoder_map"
  ],
  "fit_catboost_encoders": [
    "X",
    "Y"
  ],
  "apply_catboost_encoding": [
    "X",
    "catboost_encoder_map",
    "Y"
  ],
  "is_categorical": [
    "X"
  ],
  "has_categorical": [
    "X"
  ],
  "is_discrete": [
    "X"
  ],
  "setdiff2d": [
    "ar1",
    "ar2",
    "assume_unique"
  ],
  "means_difference": [
    "randomized_predictions",
    "baseline_values"
  ],
  "variance_of_deviations": [
    "randomized_predictions",
    "baseline_values"
  ],
  "variance_of_matching_values": [
    "randomized_predictions",
    "baseline_values"
  ],
  "geometric_median": [
    "x"
  ],
  "MNISTCausalAttribute": {
    "N_STEPS": [],
    "CHECKPOINT_FREQ": [],
    "ENVIRONMENTS": [],
    "INPUT_SHAPE": [],
    "__init__": [
      "self",
      "root",
      "download"
    ],
    "color_dataset": [
      "self",
      "images",
      "labels",
      "environment"
    ],
    "torch_bernoulli_": [
      "self",
      "p",
      "size"
    ],
    "torch_xor_": [
      "self",
      "a",
      "b"
    ]
  },
  "MNISTIndAttribute": {
    "N_STEPS": [],
    "CHECKPOINT_FREQ": [],
    "ENVIRONMENTS": [],
    "INPUT_SHAPE": [],
    "__init__": [
      "self",
      "root",
      "download"
    ],
    "rotate_dataset": [
      "self",
      "images",
      "labels",
      "env_id",
      "angle"
    ],
    "torch_bernoulli_": [
      "self",
      "p",
      "size"
    ],
    "torch_xor_": [
      "self",
      "a",
      "b"
    ]
  },
  "MNISTCausalIndAttribute": {
    "N_STEPS": [],
    "CHECKPOINT_FREQ": [],
    "ENVIRONMENTS": [],
    "INPUT_SHAPE": [],
    "__init__": [
      "self",
      "root",
      "download"
    ],
    "color_rot_dataset": [
      "self",
      "images",
      "labels",
      "environment",
      "env_id",
      "angle"
    ],
    "color_dataset": [
      "self",
      "images",
      "labels",
      "environment"
    ],
    "rotate_dataset": [
      "self",
      "images",
      "angle"
    ],
    "torch_bernoulli_": [
      "self",
      "p",
      "size"
    ],
    "torch_xor_": [
      "self",
      "a",
      "b"
    ]
  },
  "MultipleDomainDataset": {
    "N_STEPS": [],
    "CHECKPOINT_FREQ": [],
    "N_WORKERS": [],
    "ENVIRONMENTS": [],
    "INPUT_SHAPE": [],
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ]
  },
  "_InfiniteSampler": {
    "__init__": [
      "self",
      "sampler"
    ],
    "__iter__": [
      "self"
    ]
  },
  "InfiniteDataLoader": {
    "__init__": [
      "self",
      "dataset",
      "weights",
      "batch_size",
      "num_workers"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "FastDataLoader": {
    "__init__": [
      "self",
      "dataset",
      "batch_size",
      "num_workers"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "make_weights_for_balanced_classes": [
    "dataset"
  ],
  "_SplitDataset": {
    "__init__": [
      "self",
      "underlying_dataset",
      "keys"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__len__": [
      "self"
    ]
  },
  "split_dataset": [
    "dataset",
    "n",
    "seed"
  ],
  "seed_hash": [],
  "get_train_loader": [
    "dataset",
    "envs",
    "batch_size",
    "class_balanced"
  ],
  "get_eval_loader": [
    "dataset",
    "envs",
    "batch_size",
    "class_balanced"
  ],
  "get_train_eval_loader": [
    "dataset",
    "envs",
    "batch_size",
    "class_balanced",
    "holdout_fraction",
    "trial_seed"
  ],
  "get_loaders": [
    "dataset",
    "train_envs",
    "batch_size",
    "val_envs",
    "test_envs",
    "class_balanced",
    "holdout_fraction",
    "trial_seed"
  ],
  "CACM": {
    "__init__": [
      "self",
      "model",
      "optimizer",
      "lr",
      "weight_decay",
      "betas",
      "momentum",
      "kernel_type",
      "ci_test",
      "attr_types",
      "E_conditioned",
      "E_eq_A",
      "gamma",
      "lambda_causal",
      "lambda_conf",
      "lambda_ind",
      "lambda_sel"
    ],
    "training_step": [
      "self",
      "train_batch",
      "batch_idx"
    ]
  },
  "PredictionAlgorithm": {
    "__init__": [
      "self",
      "model",
      "optimizer",
      "lr",
      "weight_decay",
      "betas",
      "momentum"
    ],
    "training_step": [
      "self",
      "train_batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "batch",
      "batch_idx",
      "dataloader_idx"
    ],
    "test_step": [
      "self",
      "batch",
      "batch_idx",
      "dataloader_idx"
    ],
    "configure_optimizers": [
      "self"
    ]
  },
  "gaussian_kernel": [
    "x",
    "y",
    "gamma"
  ],
  "mmd_compute": [
    "x",
    "y",
    "kernel_type",
    "gamma"
  ],
  "Regularizer": {
    "__init__": [
      "self",
      "E_conditioned",
      "ci_test",
      "kernel_type",
      "gamma"
    ],
    "mmd": [
      "self",
      "x",
      "y"
    ],
    "unconditional_reg": [
      "self",
      "classifs",
      "attribute_labels",
      "num_envs",
      "E_eq_A"
    ],
    "conditional_reg": [
      "self",
      "classifs",
      "attribute_labels",
      "conditioning_subset",
      "num_envs",
      "E_eq_A"
    ]
  },
  "ERM": {
    "__init__": [
      "self",
      "model",
      "optimizer",
      "lr",
      "weight_decay",
      "betas",
      "momentum"
    ],
    "training_step": [
      "self",
      "train_batch",
      "batch_idx"
    ]
  },
  "Identity": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MLP": {
    "__init__": [
      "self",
      "n_inputs",
      "n_outputs",
      "mlp_width",
      "mlp_depth",
      "mlp_dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "MNIST_MLP": {
    "__init__": [
      "self",
      "input_shape"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ResNet": {
    "__init__": [
      "self",
      "input_shape",
      "resnet18",
      "resnet_dropout"
    ],
    "forward": [
      "self",
      "x"
    ],
    "train": [
      "self",
      "mode"
    ],
    "freeze_bn": [
      "self"
    ]
  },
  "MNIST_CNN": {
    "n_outputs": [],
    "__init__": [
      "self",
      "input_shape"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ContextNet": {
    "__init__": [
      "self",
      "input_shape"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "Classifier": [
    "in_features",
    "out_features",
    "is_nonlinear"
  ]
}