{
  "logger": [],
  "DIMS": [],
  "TIME_AX": [],
  "COMP_AX": [],
  "SMPL_AX": [],
  "AXES": [],
  "VALID_INDEX_TYPES": [],
  "STATIC_COV_TAG": [],
  "DEFAULT_GLOBAL_STATIC_COV_NAME": [],
  "HIERARCHY_TAG": [],
  "METADATA_TAG": [],
  "TimeSeries": {
    "__init__": [
      "self",
      "times",
      "values",
      "fill_missing_dates",
      "freq",
      "components",
      "fillna_value",
      "static_covariates",
      "hierarchy",
      "metadata",
      "copy"
    ],
    "from_xarray": [
      "cls",
      "xa",
      "fill_missing_dates",
      "freq",
      "fillna_value",
      "copy"
    ],
    "from_csv": [
      "cls",
      "filepath_or_buffer",
      "time_col",
      "value_cols",
      "fill_missing_dates",
      "freq",
      "fillna_value",
      "static_covariates",
      "hierarchy",
      "metadata"
    ],
    "from_dataframe": [
      "cls",
      "df",
      "time_col",
      "value_cols",
      "fill_missing_dates",
      "freq",
      "fillna_value",
      "static_covariates",
      "hierarchy",
      "metadata",
      "copy"
    ],
    "from_group_dataframe": [
      "cls",
      "df",
      "group_cols",
      "time_col",
      "value_cols",
      "static_cols",
      "metadata_cols",
      "fill_missing_dates",
      "freq",
      "fillna_value",
      "drop_group_cols",
      "n_jobs",
      "verbose",
      "copy"
    ],
    "from_series": [
      "cls",
      "pd_series",
      "fill_missing_dates",
      "freq",
      "fillna_value",
      "static_covariates",
      "metadata",
      "copy"
    ],
    "from_times_and_values": [
      "cls",
      "times",
      "values",
      "fill_missing_dates",
      "freq",
      "columns",
      "fillna_value",
      "static_covariates",
      "hierarchy",
      "metadata",
      "copy"
    ],
    "from_values": [
      "cls",
      "values",
      "columns",
      "fillna_value",
      "static_covariates",
      "hierarchy",
      "metadata",
      "copy"
    ],
    "from_json": [
      "cls",
      "json_str",
      "static_covariates",
      "hierarchy",
      "metadata"
    ],
    "from_pickle": [
      "cls",
      "path"
    ],
    "static_covariates": [
      "self"
    ],
    "hierarchy": [
      "self"
    ],
    "metadata": [
      "self"
    ],
    "top_level_component": [
      "self"
    ],
    "bottom_level_components": [
      "self"
    ],
    "top_level_series": [
      "self"
    ],
    "bottom_level_series": [
      "self"
    ],
    "shape": [
      "self"
    ],
    "n_timesteps": [
      "self"
    ],
    "n_samples": [
      "self"
    ],
    "n_components": [
      "self"
    ],
    "width": [
      "self"
    ],
    "is_deterministic": [
      "self"
    ],
    "is_stochastic": [
      "self"
    ],
    "is_probabilistic": [
      "self"
    ],
    "is_univariate": [
      "self"
    ],
    "freq": [
      "self"
    ],
    "freq_str": [
      "self"
    ],
    "dtype": [
      "self"
    ],
    "components": [
      "self"
    ],
    "columns": [
      "self"
    ],
    "time_index": [
      "self"
    ],
    "time_dim": [
      "self"
    ],
    "has_datetime_index": [
      "self"
    ],
    "has_range_index": [
      "self"
    ],
    "has_hierarchy": [
      "self"
    ],
    "has_static_covariates": [
      "self"
    ],
    "has_metadata": [
      "self"
    ],
    "duration": [
      "self"
    ],
    "data_array": [
      "self",
      "copy"
    ],
    "to_series": [
      "self",
      "copy",
      "backend"
    ],
    "to_dataframe": [
      "self",
      "copy",
      "backend",
      "time_as_index",
      "suppress_warnings",
      "add_static_covariates",
      "add_metadata"
    ],
    "schema": [
      "self",
      "copy"
    ],
    "astype": [
      "self",
      "dtype"
    ],
    "start_time": [
      "self"
    ],
    "end_time": [
      "self"
    ],
    "first_value": [
      "self"
    ],
    "last_value": [
      "self"
    ],
    "first_values": [
      "self"
    ],
    "last_values": [
      "self"
    ],
    "values": [
      "self",
      "copy",
      "sample"
    ],
    "random_component_values": [
      "self",
      "copy"
    ],
    "all_values": [
      "self",
      "copy"
    ],
    "univariate_values": [
      "self",
      "copy",
      "sample"
    ],
    "static_covariates_values": [
      "self",
      "copy"
    ],
    "head": [
      "self",
      "size",
      "axis"
    ],
    "tail": [
      "self",
      "size",
      "axis"
    ],
    "concatenate": [
      "self",
      "other",
      "axis",
      "ignore_time_axis",
      "ignore_static_covariates",
      "drop_hierarchy",
      "drop_metadata"
    ],
    "gaps": [
      "self",
      "mode"
    ],
    "copy": [
      "self"
    ],
    "get_index_at_point": [
      "self",
      "point",
      "after"
    ],
    "get_timestamp_at_point": [
      "self",
      "point"
    ],
    "_split_at": [
      "self",
      "split_point",
      "after"
    ],
    "split_after": [
      "self",
      "split_point"
    ],
    "split_before": [
      "self",
      "split_point"
    ],
    "drop_after": [
      "self",
      "split_point",
      "keep_point"
    ],
    "drop_before": [
      "self",
      "split_point",
      "keep_point"
    ],
    "slice": [
      "self",
      "start_ts",
      "end_ts"
    ],
    "slice_n_points_after": [
      "self",
      "start_ts",
      "n"
    ],
    "slice_n_points_before": [
      "self",
      "end_ts",
      "n"
    ],
    "slice_intersect": [
      "self",
      "other"
    ],
    "slice_intersect_values": [
      "self",
      "other",
      "copy"
    ],
    "slice_intersect_times": [
      "self",
      "other",
      "copy"
    ],
    "_slice_intersect_bounds": [
      "self",
      "other"
    ],
    "strip": [
      "self",
      "how"
    ],
    "longest_contiguous_slice": [
      "self",
      "max_gap_size",
      "mode"
    ],
    "rescale_with_value": [
      "self",
      "value_at_first_step"
    ],
    "shift": [
      "self",
      "n"
    ],
    "diff": [
      "self",
      "n",
      "periods",
      "dropna"
    ],
    "cumsum": [
      "self"
    ],
    "has_same_time_as": [
      "self",
      "other"
    ],
    "append": [
      "self",
      "other"
    ],
    "append_values": [
      "self",
      "values"
    ],
    "prepend": [
      "self",
      "other"
    ],
    "prepend_values": [
      "self",
      "values"
    ],
    "with_times_and_values": [
      "self",
      "times",
      "values",
      "fill_missing_dates",
      "freq",
      "fillna_value"
    ],
    "with_values": [
      "self",
      "values"
    ],
    "with_static_covariates": [
      "self",
      "covariates"
    ],
    "with_hierarchy": [
      "self",
      "hierarchy"
    ],
    "with_metadata": [
      "self",
      "metadata"
    ],
    "stack": [
      "self",
      "other"
    ],
    "drop_columns": [
      "self",
      "col_names"
    ],
    "univariate_component": [
      "self",
      "index"
    ],
    "add_datetime_attribute": [
      "self",
      "attribute",
      "one_hot",
      "cyclic",
      "tz"
    ],
    "add_holidays": [
      "self",
      "country_code",
      "prov",
      "state",
      "tz"
    ],
    "resample": [
      "self",
      "freq",
      "method",
      "method_kwargs"
    ],
    "is_within_range": [
      "self",
      "ts"
    ],
    "map": [
      "self",
      "fn"
    ],
    "window_transform": [
      "self",
      "transforms",
      "treat_na",
      "forecasting_safe",
      "keep_non_transformed",
      "include_current",
      "keep_names"
    ],
    "to_json": [
      "self"
    ],
    "to_csv": [
      "self"
    ],
    "to_pickle": [
      "self",
      "path",
      "protocol"
    ],
    "plot": [
      "self",
      "new_plot",
      "central_quantile",
      "low_quantile",
      "high_quantile",
      "default_formatting",
      "title",
      "label",
      "max_nr_components",
      "ax",
      "alpha",
      "color",
      "c"
    ],
    "plotly": [
      "self",
      "fig",
      "central_quantile",
      "low_quantile",
      "high_quantile",
      "title",
      "label",
      "max_nr_components",
      "alpha",
      "color",
      "c",
      "downsample_threshold"
    ],
    "with_columns_renamed": [
      "self",
      "col_names",
      "col_names_new"
    ],
    "mean": [
      "self",
      "axis"
    ],
    "median": [
      "self",
      "axis"
    ],
    "sum": [
      "self",
      "axis"
    ],
    "min": [
      "self",
      "axis"
    ],
    "max": [
      "self",
      "axis"
    ],
    "quantile": [
      "self",
      "q"
    ],
    "var": [
      "self",
      "ddof"
    ],
    "std": [
      "self",
      "ddof"
    ],
    "skew": [
      "self"
    ],
    "kurtosis": [
      "self"
    ],
    "_extract_values": [
      "self",
      "other"
    ],
    "_fill_missing_dates": [
      "cls",
      "times",
      "values",
      "freq"
    ],
    "_sort_index": [
      "times",
      "values"
    ],
    "_observed_freq_datetime_index": [
      "index"
    ],
    "_observed_freq_integer_index": [
      "index"
    ],
    "_restore_range_indexed": [
      "cls",
      "times",
      "values"
    ],
    "_restore_from_frequency": [
      "cls",
      "times",
      "values",
      "freq"
    ],
    "_get_axis": [
      "axis"
    ],
    "_get_agg_dims": [
      "self",
      "new_cname",
      "axis"
    ],
    "_get_first_timestamp_after": [
      "self",
      "ts"
    ],
    "_get_last_timestamp_before": [
      "self",
      "ts"
    ],
    "_assert_univariate": [
      "self"
    ],
    "_assert_deterministic": [
      "self"
    ],
    "_assert_stochastic": [
      "self"
    ],
    "_raise_if_not_within": [
      "self",
      "ts"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__ne__": [
      "self",
      "other"
    ],
    "__len__": [
      "self"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__radd__": [
      "self",
      "other"
    ],
    "__sub__": [
      "self",
      "other"
    ],
    "__rsub__": [
      "self",
      "other"
    ],
    "__mul__": [
      "self",
      "other"
    ],
    "__rmul__": [
      "self",
      "other"
    ],
    "__pow__": [
      "self",
      "n"
    ],
    "__truediv__": [
      "self",
      "other"
    ],
    "__rtruediv__": [
      "self",
      "n"
    ],
    "__abs__": [
      "self"
    ],
    "__neg__": [
      "self"
    ],
    "__contains__": [
      "self",
      "ts"
    ],
    "__round__": [
      "self",
      "n"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__gt__": [
      "self",
      "other"
    ],
    "__le__": [
      "self",
      "other"
    ],
    "__ge__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_repr_html_": [
      "self"
    ],
    "_get_values_repr": [
      "self",
      "repr_type"
    ],
    "__copy__": [
      "self",
      "deep"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "__getitem__": [
      "self",
      "key"
    ]
  },
  "_concat_static_covs": [
    "series"
  ],
  "_concat_hierarchy": [
    "series"
  ],
  "concatenate": [
    "series",
    "axis",
    "ignore_time_axis",
    "ignore_static_covariates",
    "drop_hierarchy",
    "drop_metadata"
  ],
  "slice_intersect": [
    "series"
  ],
  "to_group_dataframe": [
    "series",
    "copy",
    "backend",
    "time_as_index",
    "suppress_warnings",
    "add_static_covariates",
    "add_metadata",
    "add_group_col"
  ],
  "_finite_rows_boundaries": [
    "values",
    "how"
  ],
  "_clean_components": [
    "components"
  ],
  "__version__": [],
  "__all__": [],
  "get_logger": [
    "name"
  ],
  "raise_deprecation_warning": [
    "message",
    "logger"
  ],
  "raise_if_not": [
    "condition",
    "message",
    "logger"
  ],
  "raise_if": [
    "condition",
    "message",
    "logger"
  ],
  "raise_log": [
    "exception",
    "logger"
  ],
  "time_log": [
    "logger"
  ],
  "SuppressStdoutStderr": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "execute_and_suppress_output": [
    "function",
    "logger",
    "suppression_threshold_level"
  ],
  "suppress_lightning_warnings": [
    "suppress_all"
  ],
  "_DARTS_COLORS": [],
  "_Option": {
    "__init__": [
      "self",
      "key",
      "default_value",
      "description",
      "validator",
      "callback"
    ],
    "set": [
      "self",
      "value"
    ],
    "reset": [
      "self"
    ],
    "get": [
      "self"
    ]
  },
  "_OptionsManager": {
    "__init__": [
      "self"
    ],
    "_validate_positive_int": [
      "value"
    ],
    "_validate_bool": [
      "value"
    ],
    "_on_plotting_style_change": [
      "self",
      "value"
    ],
    "_find_option": [
      "self",
      "pattern",
      "check_unique"
    ],
    "get_option": [
      "self",
      "pattern"
    ],
    "set_option": [
      "self",
      "pattern",
      "value"
    ],
    "reset_option": [
      "self",
      "pattern"
    ],
    "describe_option": [
      "self",
      "pattern"
    ],
    "option_context": [
      "self"
    ]
  },
  "_global_options": [],
  "get_option": [
    "pat"
  ],
  "set_option": [
    "pat",
    "value"
  ],
  "reset_option": [
    "pat"
  ],
  "describe_option": [
    "pat"
  ],
  "option_context": [],
  "MIN_BACKGROUND_SAMPLE": [],
  "_ShapMethod": {
    "TREE": [],
    "GRADIENT": [],
    "DEEP": [],
    "KERNEL": [],
    "SAMPLING": [],
    "PARTITION": [],
    "LINEAR": [],
    "PERMUTATION": [],
    "ADDITIVE": []
  },
  "ShapMethod": [],
  "ShapExplainer": {
    "__init__": [
      "self",
      "model",
      "background_series",
      "background_past_covariates",
      "background_future_covariates",
      "background_num_samples",
      "shap_method"
    ],
    "explain": [
      "self",
      "foreground_series",
      "foreground_past_covariates",
      "foreground_future_covariates",
      "horizons",
      "target_components"
    ],
    "summary_plot": [
      "self",
      "horizons",
      "target_components",
      "num_samples",
      "plot_type"
    ],
    "force_plot_from_ts": [
      "self",
      "foreground_series",
      "foreground_past_covariates",
      "foreground_future_covariates",
      "horizon",
      "target_component"
    ]
  },
  "_RegressionShapExplainers": {
    "default_sklearn_shap_explainers": [],
    "__init__": [
      "self",
      "model",
      "n",
      "target_components",
      "past_covariates_components",
      "future_covariates_components",
      "background_series",
      "background_past_covariates",
      "background_future_covariates",
      "shap_method",
      "background_num_samples"
    ],
    "shap_explanations": [
      "self",
      "foreground_X",
      "horizons",
      "target_components"
    ],
    "_build_explainer_sklearn": [
      "self",
      "model_sklearn",
      "background_X",
      "shap_method"
    ],
    "_create_regression_model_shap_X": [
      "self",
      "target_series",
      "past_covariates",
      "future_covariates",
      "n_samples",
      "train"
    ]
  },
  "process_input": [
    "model",
    "input_type",
    "series",
    "past_covariates",
    "future_covariates",
    "fallback_series",
    "fallback_past_covariates",
    "fallback_future_covariates",
    "check_component_names",
    "requires_input",
    "requires_covariates_encoding",
    "test_stationarity"
  ],
  "process_horizons_and_targets": [
    "horizons",
    "fallback_horizon",
    "target_components",
    "fallback_target_components",
    "check_component_names"
  ],
  "get_component_names": [
    "series",
    "past_covariates",
    "future_covariates",
    "idx"
  ],
  "_check_valid_input": [
    "model",
    "input_type",
    "series",
    "past_covariates",
    "future_covariates",
    "target_components",
    "past_covariates_components",
    "future_covariates_components",
    "check_component_names",
    "requires_input",
    "test_stationarity"
  ],
  "_test_stationarity": [
    "series"
  ],
  "TFTExplainer": {
    "__init__": [
      "self",
      "model",
      "background_series",
      "background_past_covariates",
      "background_future_covariates"
    ],
    "explain": [
      "self",
      "foreground_series",
      "foreground_past_covariates",
      "foreground_future_covariates",
      "horizons",
      "target_components"
    ],
    "plot_variable_selection": [
      "self",
      "expl_result",
      "fig_size",
      "max_nr_series"
    ],
    "plot_attention": [
      "self",
      "expl_result",
      "plot_type",
      "show_index_as",
      "ax",
      "max_nr_series",
      "show_plot"
    ],
    "_encoder_importance": [
      "self"
    ],
    "_decoder_importance": [
      "self"
    ],
    "_static_covariates_importance": [
      "self"
    ],
    "_get_importance": [
      "self",
      "weight",
      "names",
      "n_decimals"
    ],
    "_name_mapping": [
      "self"
    ],
    "_plot_cov_selection": [
      "importance",
      "title",
      "ax"
    ]
  },
  "_ForecastingModelExplainer": {
    "__init__": [
      "self",
      "model",
      "background_series",
      "background_past_covariates",
      "background_future_covariates",
      "requires_background",
      "requires_covariates_encoding",
      "check_component_names",
      "test_stationarity"
    ],
    "explain": [
      "self",
      "foreground_series",
      "foreground_past_covariates",
      "foreground_future_covariates",
      "horizons",
      "target_components"
    ],
    "_process_foreground": [
      "self",
      "foreground_series",
      "foreground_past_covariates",
      "foreground_future_covariates"
    ],
    "_process_horizons_and_targets": [
      "self",
      "horizons",
      "target_components"
    ]
  },
  "_ExplainabilityResult": {
    "get_explanation": [
      "self"
    ]
  },
  "ComponentBasedExplainabilityResult": {
    "__init__": [
      "self",
      "explained_components"
    ],
    "get_explanation": [
      "self",
      "component"
    ],
    "_query_explainability_result": [
      "self",
      "attr",
      "component"
    ],
    "_validate_input_for_querying_explainability_result": [
      "self",
      "component"
    ]
  },
  "HorizonBasedExplainabilityResult": {
    "__init__": [
      "self",
      "explained_forecasts"
    ],
    "get_explanation": [
      "self",
      "horizon",
      "component"
    ],
    "_query_explainability_result": [
      "self",
      "attr",
      "horizon",
      "component"
    ],
    "_validate_input_for_querying_explainability_result": [
      "self",
      "horizon",
      "component"
    ]
  },
  "ShapExplainabilityResult": {
    "__init__": [
      "self",
      "explained_forecasts",
      "feature_values",
      "shap_explanation_object"
    ],
    "get_feature_values": [
      "self",
      "horizon",
      "component"
    ],
    "get_shap_explanation_object": [
      "self",
      "horizon",
      "component"
    ]
  },
  "TFTExplainabilityResult": {
    "__init__": [
      "self",
      "explanations"
    ],
    "get_attention": [
      "self"
    ],
    "get_feature_importances": [
      "self"
    ],
    "get_encoder_importance": [
      "self"
    ],
    "get_decoder_importance": [
      "self"
    ],
    "get_static_covariates_importance": [
      "self"
    ]
  },
  "eval_metric_from_scores": [
    "anomalies",
    "pred_scores",
    "window",
    "metric"
  ],
  "eval_metric_from_binary_prediction": [
    "anomalies",
    "pred_anomalies",
    "window",
    "metric"
  ],
  "_eval_metric": [
    "anomalies",
    "pred_series",
    "window",
    "metric",
    "pred_is_binary"
  ],
  "show_anomalies_from_scores": [
    "series",
    "anomalies",
    "pred_series",
    "pred_scores",
    "window",
    "names_of_scorers",
    "title",
    "metric",
    "component_wise"
  ],
  "_assert_binary": [
    "series",
    "name"
  ],
  "_assert_timeseries": [
    "series",
    "name"
  ],
  "_sanity_check_two_series": [
    "series_1",
    "series_2",
    "name_series_1",
    "name_series_2"
  ],
  "_max_pooling": [
    "series",
    "window"
  ],
  "_assert_same_length": [
    "list_series_1",
    "list_series_2",
    "name_series_1",
    "name_series_2"
  ],
  "_plot_series": [
    "series",
    "ax_id",
    "linewidth",
    "label_name"
  ],
  "_check_input": [
    "series",
    "name",
    "width_expected",
    "check_deterministic",
    "check_binary",
    "check_multivariate",
    "num_series_expected",
    "extra_checks"
  ],
  "_assert_fit_called": [
    "fit_called",
    "name"
  ],
  "_plot_series_and_anomalies": [
    "series",
    "anomalies",
    "pred_series",
    "pred_scores",
    "window",
    "names_of_scorers",
    "metric",
    "axs",
    "index_ax"
  ],
  "IQRDetector": {
    "__init__": [
      "self",
      "scale"
    ],
    "_fit_core": [
      "self",
      "series"
    ]
  },
  "Detector": {
    "__init__": [
      "self"
    ],
    "detect": [
      "self",
      "series",
      "name"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "pred_scores",
      "window",
      "metric"
    ],
    "_detect_core": [
      "self",
      "series",
      "name"
    ]
  },
  "FittableDetector": {
    "__init__": [
      "self"
    ],
    "detect": [
      "self",
      "series",
      "name"
    ],
    "fit": [
      "self",
      "series"
    ],
    "fit_detect": [
      "self",
      "series"
    ],
    "_fit_core": [
      "self",
      "series"
    ]
  },
  "_BoundedDetectorMixin": {
    "_prepare_boundaries": [
      "lower_bound_name",
      "upper_bound_name",
      "lower_bound",
      "upper_bound"
    ],
    "_expand_threshold": [
      "series",
      "threshold"
    ],
    "low_threshold": [
      "self"
    ],
    "high_threshold": [
      "self"
    ]
  },
  "QuantileDetector": {
    "__init__": [
      "self",
      "low_quantile",
      "high_quantile"
    ],
    "_fit_core": [
      "self",
      "series"
    ],
    "_detect_core": [
      "self",
      "series",
      "name"
    ],
    "low_threshold": [
      "self"
    ],
    "high_threshold": [
      "self"
    ]
  },
  "ThresholdDetector": {
    "__init__": [
      "self",
      "low_threshold",
      "high_threshold"
    ],
    "_detect_core": [
      "self",
      "series",
      "name"
    ],
    "low_threshold": [
      "self"
    ],
    "high_threshold": [
      "self"
    ]
  },
  "NormScorer": {
    "__init__": [
      "self",
      "ord",
      "component_wise"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_from_prediction": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "LaplaceNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "AnomalyScorer": {
    "__init__": [
      "self",
      "is_univariate",
      "window"
    ],
    "score_from_prediction": [
      "self",
      "series",
      "pred_series"
    ],
    "eval_metric_from_prediction": [
      "self",
      "anomalies",
      "series",
      "pred_series",
      "metric"
    ],
    "show_anomalies_from_prediction": [
      "self",
      "series",
      "pred_series",
      "scorer_name",
      "anomalies",
      "title",
      "metric",
      "component_wise"
    ],
    "is_probabilistic": [
      "self"
    ],
    "is_univariate": [
      "self"
    ],
    "is_trainable": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_from_prediction": [
      "self",
      "vals",
      "pred_vals"
    ],
    "_check_univariate_scorer": [
      "self",
      "anomalies"
    ],
    "_check_window_size": [
      "self",
      "series"
    ],
    "_assert_stochastic": [
      "self",
      "series",
      "name_series"
    ],
    "_extract_deterministic_series": [
      "self",
      "series",
      "name_series"
    ],
    "_extract_deterministic_values": [
      "self",
      "series",
      "name_series"
    ]
  },
  "FittableAnomalyScorer": {
    "__init__": [
      "self",
      "is_univariate",
      "window",
      "window_agg",
      "diff_fn",
      "n_jobs"
    ],
    "fit": [
      "self",
      "series"
    ],
    "fit_from_prediction": [
      "self",
      "series",
      "pred_series"
    ],
    "score": [
      "self",
      "series"
    ],
    "score_from_prediction": [
      "self",
      "series",
      "pred_series"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "series",
      "metric"
    ],
    "show_anomalies": [
      "self",
      "series",
      "anomalies",
      "scorer_name",
      "title",
      "metric",
      "component_wise"
    ],
    "is_trainable": [
      "self"
    ],
    "_fit_core": [
      "self",
      "series"
    ],
    "_score_core": [
      "self",
      "series"
    ],
    "_score_core_from_prediction": [
      "self",
      "vals",
      "pred_vals"
    ],
    "_diff_series": [
      "self",
      "series",
      "pred_series"
    ],
    "_fun_window_agg": [
      "self",
      "scores",
      "window"
    ],
    "_check_fit_called": [
      "self"
    ]
  },
  "WindowedAnomalyScorer": {
    "__init__": [
      "self",
      "is_univariate",
      "window",
      "window_agg",
      "diff_fn"
    ],
    "_model_score_method": [
      "self",
      "model",
      "data"
    ],
    "_fit_core": [
      "self",
      "series"
    ],
    "_score_core": [
      "self",
      "series"
    ],
    "_tabularize_series": [
      "self",
      "series",
      "component_wise"
    ],
    "_convert_tabular_to_series": [
      "self",
      "series",
      "score_vals"
    ]
  },
  "NLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "is_probabilistic": [
      "self"
    ],
    "_score_core_from_prediction": [
      "self",
      "vals",
      "pred_vals"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "KMeansScorer": {
    "__init__": [
      "self",
      "window",
      "k",
      "component_wise",
      "window_agg",
      "diff_fn"
    ],
    "__str__": [
      "self"
    ],
    "_model_score_method": [
      "self",
      "model",
      "data"
    ]
  },
  "CauchyNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "ExponentialNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "PyODScorer": {
    "__init__": [
      "self",
      "model",
      "window",
      "component_wise",
      "window_agg",
      "diff_fn"
    ],
    "__str__": [
      "self"
    ],
    "_model_score_method": [
      "self",
      "model",
      "data"
    ]
  },
  "DifferenceScorer": {
    "__init__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_from_prediction": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "GammaNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "GaussianNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "WassersteinScorer": {
    "__init__": [
      "self",
      "window",
      "component_wise",
      "window_agg",
      "diff_fn"
    ],
    "__str__": [
      "self"
    ],
    "_fit_core": [
      "self",
      "series"
    ],
    "_model_score_method": [
      "self",
      "model",
      "data"
    ]
  },
  "PoissonNLLScorer": {
    "__init__": [
      "self",
      "window"
    ],
    "__str__": [
      "self"
    ],
    "_score_core_nllikelihood": [
      "self",
      "vals",
      "pred_vals"
    ]
  },
  "Aggregator": {
    "__init__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_predict_core": [
      "self",
      "series"
    ],
    "predict": [
      "self",
      "series",
      "name"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "series",
      "window",
      "metric"
    ]
  },
  "FittableAggregator": {
    "__init__": [
      "self"
    ],
    "_fit_core": [
      "self",
      "anomalies",
      "series"
    ],
    "fit": [
      "self",
      "anomalies",
      "series"
    ],
    "predict": [
      "self",
      "series",
      "name"
    ]
  },
  "OrAggregator": {
    "__init__": [
      "self",
      "n_jobs"
    ],
    "__str__": [
      "self"
    ],
    "_predict_core": [
      "self",
      "series"
    ]
  },
  "AndAggregator": {
    "__init__": [
      "self",
      "n_jobs"
    ],
    "__str__": [
      "self"
    ],
    "_predict_core": [
      "self",
      "series"
    ]
  },
  "EnsembleSklearnAggregator": {
    "__init__": [
      "self",
      "model"
    ],
    "__str__": [
      "self"
    ],
    "_fit_core": [
      "self",
      "anomalies",
      "series"
    ],
    "_predict_core": [
      "self",
      "series"
    ]
  },
  "ForecastingAnomalyModel": {
    "__init__": [
      "self",
      "model",
      "scorer"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "allow_model_training",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization"
    ],
    "score": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization",
      "return_model_prediction"
    ],
    "predict_series": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization",
      "metric"
    ],
    "show_anomalies": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization",
      "anomalies",
      "names_of_scorers",
      "title",
      "metric",
      "component_wise"
    ],
    "_fit_core": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "allow_model_training",
      "forecast_horizon",
      "start",
      "start_format",
      "num_samples",
      "verbose",
      "show_warnings",
      "enable_optimization"
    ]
  },
  "FilteringAnomalyModel": {
    "__init__": [
      "self",
      "model",
      "scorer"
    ],
    "fit": [
      "self",
      "series",
      "allow_model_training"
    ],
    "score": [
      "self",
      "series",
      "return_model_prediction"
    ],
    "predict_series": [
      "self",
      "series"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "series",
      "metric"
    ],
    "show_anomalies": [
      "self",
      "series",
      "anomalies",
      "names_of_scorers",
      "title",
      "metric"
    ],
    "_fit_core": [
      "self",
      "series",
      "allow_model_training"
    ]
  },
  "AnomalyModel": {
    "__init__": [
      "self",
      "model",
      "scorer"
    ],
    "fit": [
      "self",
      "series",
      "allow_model_training"
    ],
    "score": [
      "self",
      "series",
      "return_model_prediction"
    ],
    "predict_series": [
      "self",
      "series"
    ],
    "eval_metric": [
      "self",
      "anomalies",
      "series",
      "metric"
    ],
    "show_anomalies": [
      "self",
      "series",
      "anomalies",
      "predict_kwargs",
      "names_of_scorers",
      "title",
      "metric",
      "component_wise"
    ],
    "scorers_are_univariate": [
      "self"
    ],
    "scorers_are_trainable": [
      "self"
    ],
    "_fit_core": [
      "self",
      "series",
      "allow_model_training"
    ],
    "_fit_scorers": [
      "self",
      "list_series",
      "list_pred"
    ],
    "_process_input_series": [
      "series"
    ]
  },
  "err": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "merr": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ae": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mae": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ase": [
    "actual_series",
    "pred_series",
    "insample",
    "m",
    "intersect"
  ],
  "mase": [
    "actual_series",
    "pred_series",
    "insample",
    "m",
    "intersect"
  ],
  "se": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mse": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "sse": [
    "actual_series",
    "pred_series",
    "insample",
    "m",
    "intersect"
  ],
  "msse": [
    "actual_series",
    "pred_series",
    "insample",
    "m",
    "intersect"
  ],
  "rmse": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "rmsse": [
    "actual_series",
    "pred_series",
    "insample",
    "m",
    "intersect"
  ],
  "sle": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "rmsle": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ape": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mape": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "wmape": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "sape": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "smape": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ope": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "arre": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "marre": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "r2_score": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "coefficient_of_variation": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "_tolerance_coverages": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "autc": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "dtw_metric": [
    "actual_series",
    "pred_series",
    "metric"
  ],
  "qr": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ql": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mql": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "iw": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "miw": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "iws": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "miws": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "ic": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mic": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "incs_qr": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "mincs_qr": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "accuracy": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "precision": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "recall": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "f1": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "confusion_matrix": [
    "actual_series",
    "pred_series",
    "intersect"
  ],
  "_TN_IDX": [],
  "_FP_IDX": [],
  "_FN_IDX": [],
  "_TP_IDX": [],
  "_PARAM_Q": [],
  "_PARAM_Q_INTERVAL": [],
  "_PARAM_LABELS": [],
  "_PARAM_LABEL_REDUCTION": [],
  "_PARAM_SERIES_REDUCTION": [],
  "_PARAM_TIME_REDUCTION": [],
  "_PARAM_COMPONENT_REDUCTION": [],
  "PROBA_SUFFIX": [],
  "_LabelReduction": {
    "NONE": [],
    "MACRO": [],
    "MICRO": [],
    "WEIGHTED": [],
    "has_value": [
      "cls",
      "value"
    ]
  },
  "METRIC_OUTPUT_TYPE": [],
  "METRIC_TYPE": [],
  "interval_support": [
    "func"
  ],
  "classification_support": [
    "func"
  ],
  "multi_ts_support": [
    "func"
  ],
  "multivariate_support": [
    "func"
  ],
  "_regression_handling": [
    "actual_series",
    "pred_series",
    "params",
    "kwargs"
  ],
  "_classification_handling": [
    "actual_series",
    "pred_series"
  ],
  "_get_values": [
    "vals",
    "vals_components",
    "actual_components",
    "q",
    "is_classification"
  ],
  "_get_values_or_raise": [
    "actual_series",
    "pred_series",
    "intersect",
    "q",
    "remove_nan_union",
    "is_insample",
    "is_classification"
  ],
  "_get_quantile_intervals": [
    "vals",
    "q",
    "q_interval"
  ],
  "_mode": [
    "vals"
  ],
  "_get_highest_count_label": [
    "vals"
  ],
  "_get_highest_probability_label": [
    "vals",
    "vals_components",
    "actual_components"
  ],
  "_get_wrapped_metric": [
    "func",
    "n_wrappers"
  ],
  "_get_reduction": [
    "kwargs",
    "params",
    "red_name",
    "axis",
    "sanity_check"
  ],
  "_get_error_scale": [
    "insample",
    "pred_series",
    "m",
    "metric"
  ],
  "_unique_labels": [
    "y_true",
    "y_pred"
  ],
  "_confusion_matrix": [
    "y_true",
    "y_pred",
    "labels",
    "compute_multilabel"
  ],
  "_compute_score": [
    "y_true",
    "y_pred",
    "score_func",
    "label_reduction",
    "labels"
  ],
  "_get_tolerance_levels": [
    "min_tolerance",
    "max_tolerance",
    "step"
  ],
  "TIME_DEPENDENT_METRICS": [],
  "CLASSIFICATION_METRICS": [],
  "DatasetLoaderMetadata": {},
  "DatasetLoadingException": {},
  "DatasetLoader": {
    "_DEFAULT_DIRECTORY": [],
    "__init__": [
      "self",
      "metadata",
      "root_path"
    ],
    "load": [
      "self"
    ],
    "_check_dataset_integrity_or_raise": [
      "self"
    ],
    "_download_dataset": [
      "self"
    ],
    "_download_zip_dataset": [
      "self"
    ],
    "_load_from_disk": [
      "self",
      "path_to_file",
      "metadata"
    ],
    "_get_path_dataset": [
      "self"
    ],
    "_is_already_downloaded": [
      "self"
    ],
    "_format_time_column": [
      "self",
      "df"
    ]
  },
  "DatasetLoaderCSV": {
    "__init__": [
      "self",
      "metadata",
      "root_path"
    ],
    "_load_from_disk": [
      "self",
      "path_to_file",
      "metadata"
    ]
  },
  "_DEFAULT_PATH": [],
  "AirPassengersDataset": {
    "__init__": [
      "self"
    ]
  },
  "AusBeerDataset": {
    "__init__": [
      "self"
    ]
  },
  "AustralianTourismDataset": {
    "__init__": [
      "self"
    ]
  },
  "EnergyDataset": {
    "__init__": [
      "self"
    ]
  },
  "GasRateCO2Dataset": {
    "__init__": [
      "self"
    ]
  },
  "HeartRateDataset": {
    "__init__": [
      "self"
    ]
  },
  "IceCreamHeaterDataset": {
    "__init__": [
      "self"
    ]
  },
  "MonthlyMilkDataset": {
    "__init__": [
      "self"
    ]
  },
  "MonthlyMilkIncompleteDataset": {
    "__init__": [
      "self"
    ]
  },
  "SunspotsDataset": {
    "__init__": [
      "self"
    ]
  },
  "TaylorDataset": {
    "__init__": [
      "self"
    ]
  },
  "TemperatureDataset": {
    "__init__": [
      "self"
    ]
  },
  "USGasolineDataset": {
    "__init__": [
      "self"
    ]
  },
  "WineDataset": {
    "__init__": [
      "self"
    ]
  },
  "WoolyDataset": {
    "__init__": [
      "self"
    ]
  },
  "ETTh1Dataset": {
    "__init__": [
      "self"
    ]
  },
  "ETTh2Dataset": {
    "__init__": [
      "self"
    ]
  },
  "ETTm1Dataset": {
    "__init__": [
      "self"
    ]
  },
  "ETTm2Dataset": {
    "__init__": [
      "self"
    ]
  },
  "TaxiNewYorkDataset": {
    "__init__": [
      "self"
    ]
  },
  "ElectricityDataset": {
    "__init__": [
      "self",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "UberTLCDataset": {
    "__init__": [
      "self",
      "sample_freq",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "ILINetDataset": {
    "__init__": [
      "self",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "ExchangeRateDataset": {
    "__init__": [
      "self",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "TrafficDataset": {
    "__init__": [
      "self",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "WeatherDataset": {
    "__init__": [
      "self",
      "multivariate"
    ],
    "_to_multi_series": [
      "self",
      "series"
    ]
  },
  "ElectricityConsumptionZurichDataset": {
    "__init__": [
      "self"
    ]
  },
  "Pipeline": {
    "__init__": [
      "self",
      "transformers",
      "copy",
      "verbose",
      "n_jobs"
    ],
    "fit": [
      "self",
      "data"
    ],
    "fit_transform": [
      "self",
      "data"
    ],
    "transform": [
      "self",
      "data",
      "series_idx"
    ],
    "inverse_transform": [
      "self",
      "data",
      "partial",
      "series_idx"
    ],
    "invertible": [
      "self"
    ],
    "fittable": [
      "self"
    ],
    "_fit_called": [
      "self"
    ],
    "__getitem__": [
      "self",
      "key"
    ],
    "__iter__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__copy__": [
      "self",
      "deep"
    ],
    "__deepcopy__": [
      "self",
      "memo"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "component_masking": [
    "transformer_method"
  ],
  "BaseDataTransformer": {
    "__init__": [
      "self",
      "name",
      "n_jobs",
      "verbose",
      "parallel_params",
      "mask_components"
    ],
    "set_verbose": [
      "self",
      "value"
    ],
    "set_n_jobs": [
      "self",
      "value"
    ],
    "_ts_transform": [
      "cls"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "transform": [
      "self",
      "series"
    ],
    "_get_params": [
      "self",
      "transformer_selector",
      "series_specified"
    ],
    "_check_fixed_params": [
      "self",
      "transformer_selector"
    ],
    "_process_series_idx": [
      "series_idx"
    ],
    "apply_component_mask": [
      "series",
      "component_mask",
      "return_ts"
    ],
    "unapply_component_mask": [
      "series",
      "vals",
      "component_mask"
    ],
    "stack_samples": [
      "vals"
    ],
    "unstack_samples": [
      "vals",
      "n_timesteps",
      "n_samples",
      "series"
    ],
    "name": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "__repr__": [
      "self"
    ]
  },
  "MissingValuesFiller": {
    "__init__": [
      "self",
      "fill",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_transform": [
      "series",
      "params"
    ]
  },
  "Diff": {
    "__init__": [
      "self",
      "lags",
      "dropna",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ],
    "_get_component_mask": [
      "kwargs",
      "dropna"
    ]
  },
  "FittableDataTransformer": {
    "__init__": [
      "self",
      "name",
      "n_jobs",
      "verbose",
      "parallel_params",
      "mask_components",
      "global_fit"
    ],
    "_ts_fit": [
      "cls"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "fit": [
      "self",
      "series"
    ],
    "transform": [
      "self",
      "series"
    ],
    "fit_transform": [
      "self",
      "series"
    ],
    "_get_params": [
      "self",
      "transformer_selector",
      "calling_fit",
      "series_specified"
    ],
    "_get_fitted_params": [
      "self",
      "transformer_selector",
      "calling_fit",
      "series_specified"
    ]
  },
  "StaticCovariatesTransformer": {
    "__init__": [
      "self",
      "transformer_num",
      "transformer_cat",
      "cols_num",
      "cols_cat",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "_process_static_cov_columns": [
      "stat_covs",
      "cols_num",
      "cols_cat"
    ],
    "_create_category_mappings": [
      "untransformed_stat_covs",
      "transformer_cat",
      "mask_cat",
      "cols_cat"
    ],
    "_create_inv_component_masks": [
      "mask_num",
      "mask_cat",
      "cat_mapping",
      "cols_cat"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ],
    "_transform_static_covs": [
      "series",
      "fitted_params",
      "method"
    ],
    "_extract_static_covs": [
      "series",
      "mask_num",
      "mask_cat"
    ],
    "_add_back_static_covs": [
      "series",
      "vals_num",
      "vals_cat",
      "mask_num",
      "mask_cat",
      "col_map_cat"
    ]
  },
  "InvertibleDataTransformer": {
    "__init__": [
      "self",
      "name",
      "n_jobs",
      "verbose",
      "parallel_params",
      "mask_components"
    ],
    "_ts_inverse_transform": [
      "cls"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ],
    "inverse_transform": [
      "self",
      "series"
    ]
  },
  "_get_summation_matrix": [
    "series"
  ],
  "_reconcile_from_S_and_G": [
    "series",
    "S",
    "G"
  ],
  "BottomUpReconciliator": {
    "get_projection_matrix": [
      "series"
    ],
    "ts_transform": [
      "series",
      "params"
    ]
  },
  "TopDownReconciliator": {
    "ts_fit": [
      "series",
      "params"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "get_projection_matrix": [
      "series"
    ]
  },
  "MinTReconciliator": {
    "__init__": [
      "self",
      "method"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "_assert_deterministic": [
      "series"
    ],
    "get_matrices": [
      "series",
      "method"
    ]
  },
  "WindowTransformer": {
    "__init__": [
      "self",
      "transforms",
      "treat_na",
      "forecasting_safe",
      "keep_non_transformed",
      "include_current",
      "keep_names",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_transform": [
      "series",
      "params"
    ]
  },
  "MapperFn": [],
  "Mapper": {
    "__init__": [
      "self",
      "fn",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_transform": [
      "series",
      "params"
    ]
  },
  "InvertibleMapper": {
    "__init__": [
      "self",
      "fn",
      "inverse_fn",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ]
  },
  "BoxCox": {
    "__init__": [
      "self",
      "name",
      "lmbda",
      "optim_method",
      "global_fit",
      "n_jobs",
      "verbose"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ]
  },
  "Scaler": {
    "__init__": [
      "self",
      "scaler",
      "name",
      "global_fit",
      "n_jobs",
      "verbose"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ],
    "ts_fit": [
      "series",
      "params"
    ]
  },
  "MIDAS": {
    "__init__": [
      "self",
      "low_freq",
      "strip",
      "drop_static_covariates",
      "name",
      "n_jobs",
      "verbose"
    ],
    "ts_fit": [
      "series",
      "params"
    ],
    "ts_transform": [
      "series",
      "params"
    ],
    "ts_inverse_transform": [
      "series",
      "params"
    ],
    "_verify_series": [
      "series",
      "high_freq",
      "low_freq"
    ],
    "_process_static_covariates": [
      "series",
      "n_midas",
      "drop_static_covariates",
      "inverse_transform"
    ],
    "_create_midas_df": [
      "series",
      "arr",
      "time_index",
      "n_midas",
      "drop_static_covariates",
      "inverse_transform",
      "feature_sep"
    ]
  },
  "SeriesValue": [],
  "DistanceFunc": [],
  "_dtw_cost_matrix": [
    "x",
    "y",
    "dist",
    "window"
  ],
  "_dtw_path": [
    "dtw"
  ],
  "_down_sample": [
    "high_res"
  ],
  "_expand_window": [
    "low_res_path",
    "n",
    "m",
    "radius"
  ],
  "_fast_dtw": [
    "x",
    "y",
    "dist",
    "radius",
    "depth"
  ],
  "_default_distance_multi": [
    "x_values",
    "y_values"
  ],
  "_default_distance_uni": [
    "x_value",
    "y_value"
  ],
  "DTWAlignment": {
    "__init__": [
      "self",
      "series1",
      "series2",
      "cost"
    ],
    "path": [
      "self"
    ],
    "distance": [
      "self"
    ],
    "mean_distance": [
      "self"
    ],
    "warped": [
      "self"
    ]
  },
  "dtw": [
    "series1",
    "series2",
    "window",
    "distance",
    "multi_grid_radius"
  ],
  "plot": [
    "self",
    "new_plot",
    "show_series",
    "show_cost",
    "cost_cmap",
    "args_path",
    "args_cost",
    "args_series1",
    "args_series2"
  ],
  "plot_alignment": [
    "self",
    "new_plot",
    "series1_y_offset",
    "series2_y_offset",
    "components",
    "args_line",
    "args_series1",
    "args_series2"
  ],
  "Window": {
    "init_size": [
      "self",
      "n",
      "m"
    ],
    "__len__": [
      "self"
    ],
    "column_index": [
      "self",
      "elem"
    ],
    "__contains__": [
      "self",
      "item"
    ],
    "column_length": [
      "self",
      "column"
    ],
    "column_lengths": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "NoWindow": {
    "__len__": [
      "self"
    ],
    "column_index": [
      "self",
      "elem"
    ],
    "column_length": [
      "self",
      "column"
    ],
    "column_lengths": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "gtz": [
    "value"
  ],
  "CRWindow": {
    "__init__": [
      "self",
      "n",
      "m",
      "ranges"
    ],
    "add_range": [
      "self",
      "column",
      "start",
      "end"
    ],
    "add": [
      "self",
      "elem"
    ],
    "column_length": [
      "self",
      "column"
    ],
    "column_index": [
      "self",
      "elem"
    ],
    "__contains__": [
      "self",
      "elem"
    ],
    "__iter__": [
      "self"
    ],
    "column_lengths": [
      "self"
    ],
    "__len__": [
      "self"
    ]
  },
  "Itakura": {
    "__init__": [
      "self",
      "max_slope"
    ],
    "init_size": [
      "self",
      "n",
      "m"
    ]
  },
  "SakoeChiba": {
    "__init__": [
      "self",
      "window_size"
    ],
    "init_size": [
      "self",
      "n",
      "m"
    ]
  },
  "Elem": [],
  "CostMatrix": {
    "fill": [
      "self",
      "value"
    ],
    "__getitem__": [
      "self",
      "item"
    ],
    "__setitem__": [
      "self",
      "key",
      "value"
    ],
    "__iter__": [
      "self"
    ],
    "to_dense": [
      "self"
    ],
    "_from_window": [
      "window"
    ]
  },
  "DenseCostMatrix": {
    "__new__": [
      "self",
      "n",
      "m"
    ],
    "to_dense": [
      "self"
    ],
    "__iter__": [
      "self"
    ]
  },
  "SparseCostMatrix": {
    "__init__": [
      "self",
      "window"
    ],
    "fill": [
      "self",
      "value"
    ],
    "to_dense": [
      "self"
    ],
    "__getitem__": [
      "self",
      "elem"
    ],
    "__setitem__": [
      "self",
      "elem",
      "value"
    ],
    "__iter__": [
      "self"
    ]
  },
  "SupportedIndex": [],
  "EncoderOutputType": [],
  "_EncoderMethod": {
    "__init__": [
      "self",
      "stage"
    ]
  },
  "CovariatesIndexGenerator": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ],
    "generate_train_idx": [
      "self",
      "target",
      "covariates"
    ],
    "generate_inference_idx": [
      "self",
      "n",
      "target",
      "covariates"
    ],
    "generate_train_inference_idx": [
      "self",
      "n",
      "target",
      "covariates"
    ],
    "base_component_name": [
      "self"
    ],
    "_verify_scenario": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ],
    "_verify_lags": [
      "self",
      "min_covariates_lag",
      "max_covariates_lag"
    ]
  },
  "PastCovariatesIndexGenerator": {
    "generate_train_idx": [
      "self",
      "target",
      "covariates"
    ],
    "generate_inference_idx": [
      "self",
      "n",
      "target",
      "covariates"
    ],
    "base_component_name": [
      "self"
    ],
    "_verify_lags": [
      "self",
      "min_covariates_lag",
      "max_covariates_lag"
    ]
  },
  "FutureCovariatesIndexGenerator": {
    "generate_train_idx": [
      "self",
      "target",
      "covariates"
    ],
    "generate_inference_idx": [
      "self",
      "n",
      "target",
      "covariates"
    ],
    "base_component_name": [
      "self"
    ]
  },
  "Encoder": {
    "__init__": [
      "self"
    ],
    "encode_train": [
      "self",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "encode_inference": [
      "self",
      "n",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "encode_train_inference": [
      "self",
      "n",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "_merge_covariates": [
      "encoded",
      "covariates"
    ],
    "_drop_encoded_components": [
      "covariates",
      "components"
    ],
    "fit_called": [
      "self"
    ],
    "requires_fit": [
      "self"
    ]
  },
  "SingleEncoder": {
    "__init__": [
      "self",
      "index_generator"
    ],
    "_encode": [
      "self",
      "index",
      "target_end",
      "dtype"
    ],
    "encode_train": [
      "self",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "encode_inference": [
      "self",
      "n",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "encode_train_inference": [
      "self",
      "n",
      "target",
      "covariates",
      "merge_covariates"
    ],
    "accept_transformer": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ],
    "components": [
      "self"
    ],
    "base_component_name": [
      "self"
    ]
  },
  "SequentialEncoderTransformer": {
    "__init__": [
      "self",
      "transformer",
      "transform_mask"
    ],
    "transform": [
      "self",
      "covariates"
    ],
    "_update_mask": [
      "self",
      "covariates"
    ],
    "fit_called": [
      "self"
    ]
  },
  "_generate_train_idx": [
    "target",
    "steps_ahead_start",
    "steps_ahead_end"
  ],
  "SupportedTimeSeries": [],
  "ENCODER_KEYS": [],
  "FUTURE": [],
  "PAST": [],
  "VALID_TIME_PARAMS": [],
  "VALID_ENCODER_DTYPES": [],
  "TZ_KEYS": [],
  "TRANSFORMER_KEYS": [],
  "VALID_TRANSFORMER_DTYPES": [],
  "INTEGER_INDEX_ATTRIBUTES": [],
  "CyclicTemporalEncoder": {
    "__init__": [
      "self",
      "index_generator",
      "attribute",
      "tz"
    ],
    "_encode": [
      "self",
      "index",
      "target_end",
      "dtype"
    ],
    "accept_transformer": [
      "self"
    ],
    "requires_fit": [
      "self"
    ],
    "base_component_name": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ]
  },
  "PastCyclicEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates",
      "tz"
    ]
  },
  "FutureCyclicEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates",
      "tz"
    ]
  },
  "DatetimeAttributeEncoder": {
    "__init__": [
      "self",
      "index_generator",
      "attribute",
      "tz"
    ],
    "_encode": [
      "self",
      "index",
      "target_end",
      "dtype"
    ],
    "accept_transformer": [
      "self"
    ],
    "requires_fit": [
      "self"
    ],
    "base_component_name": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ]
  },
  "PastDatetimeAttributeEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates",
      "tz"
    ]
  },
  "FutureDatetimeAttributeEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates",
      "tz"
    ]
  },
  "IntegerIndexEncoder": {
    "__init__": [
      "self",
      "index_generator",
      "attribute"
    ],
    "_encode": [
      "self",
      "index",
      "target_end",
      "dtype"
    ],
    "accept_transformer": [
      "self"
    ],
    "requires_fit": [
      "self"
    ],
    "base_component_name": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ]
  },
  "PastIntegerIndexEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ]
  },
  "FutureIntegerIndexEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ]
  },
  "CallableIndexEncoder": {
    "__init__": [
      "self",
      "index_generator",
      "attribute"
    ],
    "_encode": [
      "self",
      "index",
      "target_end",
      "dtype"
    ],
    "accept_transformer": [
      "self"
    ],
    "requires_fit": [
      "self"
    ],
    "base_component_name": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ]
  },
  "PastCallableIndexEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ]
  },
  "FutureCallableIndexEncoder": {
    "__init__": [
      "self",
      "attribute",
      "input_chunk_length",
      "output_chunk_length",
      "lags_covariates"
    ]
  },
  "SequentialEncoder": {
    "__init__": [
      "self",
      "add_encoders",
      "input_chunk_length",
      "output_chunk_length",
      "lags_past_covariates",
      "lags_future_covariates",
      "takes_past_covariates",
      "takes_future_covariates"
    ],
    "encode_train": [
      "self",
      "target",
      "past_covariates",
      "future_covariates",
      "encode_past",
      "encode_future"
    ],
    "encode_inference": [
      "self",
      "n",
      "target",
      "past_covariates",
      "future_covariates",
      "encode_past",
      "encode_future"
    ],
    "encode_train_inference": [
      "self",
      "n",
      "target",
      "past_covariates",
      "future_covariates",
      "encode_past",
      "encode_future"
    ],
    "_launch_encoder": [
      "self",
      "target",
      "past_covariates",
      "future_covariates",
      "encoder_method",
      "n",
      "encode_past",
      "encode_future"
    ],
    "_encode_sequence": [
      "self",
      "encoders",
      "transformer",
      "target",
      "covariates",
      "covariates_type",
      "encoder_method",
      "n"
    ],
    "past_encoders": [
      "self"
    ],
    "future_encoders": [
      "self"
    ],
    "encoders": [
      "self"
    ],
    "past_components": [
      "self"
    ],
    "future_components": [
      "self"
    ],
    "components": [
      "self"
    ],
    "encoding_n_components": [
      "self"
    ],
    "past_transformer": [
      "self"
    ],
    "future_transformer": [
      "self"
    ],
    "transformers": [
      "self"
    ],
    "encoder_map": [
      "self"
    ],
    "_setup_encoders": [
      "self",
      "params"
    ],
    "_setup_transformer": [
      "self",
      "params"
    ],
    "_process_input_encoders": [
      "self",
      "params"
    ],
    "_process_input_transformer": [
      "self",
      "params"
    ],
    "_process_timezone": [
      "params"
    ],
    "requires_fit": [
      "self"
    ]
  },
  "T": [],
  "MonteCarloDropout": {
    "_mc_dropout_enabled": [],
    "forward": [
      "self",
      "input"
    ],
    "mc_dropout_enabled": [
      "self"
    ]
  },
  "random_method": [
    "decorated"
  ],
  "_divide_no_nan": [
    "a",
    "b"
  ],
  "SmapeLoss": {
    "__init__": [
      "self",
      "block_denom_grad"
    ],
    "forward": [
      "self",
      "inpt",
      "tgt"
    ]
  },
  "MapeLoss": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "inpt",
      "tgt"
    ]
  },
  "MAELoss": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "inpt",
      "tgt"
    ]
  },
  "TFMProgressBar": {
    "__init__": [
      "self",
      "enable_sanity_check_bar",
      "enable_train_bar",
      "enable_validation_bar",
      "enable_prediction_bar",
      "enable_train_bar_only"
    ],
    "init_sanity_tqdm": [
      "self"
    ],
    "init_predict_tqdm": [
      "self"
    ],
    "init_train_tqdm": [
      "self"
    ],
    "init_validation_tqdm": [
      "self"
    ]
  },
  "format_bytes": [
    "nbytes",
    "precision"
  ],
  "truncate_key": [
    "key",
    "max_len"
  ],
  "format_dict": [
    "d",
    "max_items",
    "pad",
    "render_html",
    "max_value_len"
  ],
  "format_list": [
    "lst",
    "max_items",
    "render_html"
  ],
  "make_collapsible_section": [
    "title",
    "content",
    "open_by_default"
  ],
  "make_paragraph": [
    "text",
    "bold",
    "margin_left"
  ],
  "check_seasonality": [
    "ts",
    "m",
    "max_lag",
    "alpha"
  ],
  "_bartlett_formula": [
    "r",
    "m",
    "length"
  ],
  "extract_trend_and_seasonality": [
    "ts",
    "freq",
    "model",
    "method"
  ],
  "remove_from_series": [
    "ts",
    "other",
    "model"
  ],
  "remove_seasonality": [
    "ts",
    "freq",
    "model",
    "method"
  ],
  "remove_trend": [
    "ts",
    "model",
    "method"
  ],
  "stationarity_tests": [
    "ts",
    "p_value_threshold_adfuller",
    "p_value_threshold_kpss"
  ],
  "stationarity_test_kpss": [
    "ts",
    "regression",
    "nlags"
  ],
  "stationarity_test_adf": [
    "ts",
    "maxlag",
    "regression",
    "autolag"
  ],
  "granger_causality_tests": [
    "ts_cause",
    "ts_effect",
    "maxlag",
    "addconst"
  ],
  "plot_acf": [
    "ts",
    "m",
    "max_lag",
    "alpha",
    "bartlett_confint",
    "fig_size",
    "axis",
    "default_formatting"
  ],
  "plot_pacf": [
    "ts",
    "m",
    "max_lag",
    "method",
    "alpha",
    "fig_size",
    "axis",
    "default_formatting"
  ],
  "plot_ccf": [
    "ts",
    "ts_other",
    "m",
    "max_lag",
    "alpha",
    "bartlett_confint",
    "fig_size",
    "axis",
    "default_formatting"
  ],
  "plot_hist": [
    "data",
    "bins",
    "density",
    "title",
    "fig_size",
    "ax"
  ],
  "plot_residuals_analysis": [
    "residuals",
    "num_bins",
    "fill_nan",
    "default_formatting",
    "acf_max_lag"
  ],
  "plot_tolerance_curve": [
    "actual_series",
    "pred_series",
    "intersect",
    "min_tolerance",
    "max_tolerance",
    "step",
    "q",
    "n_jobs",
    "verbose",
    "fig_size",
    "axis"
  ],
  "MAX_TORCH_SEED_VALUE": [],
  "MAX_NUMPY_SEED_VALUE": [],
  "SUPPORTED_RESAMPLE_METHODS": [],
  "NotImportedModule": {
    "usable": [],
    "__init__": [
      "self",
      "module_name",
      "warn"
    ],
    "__call__": [
      "self"
    ]
  },
  "SeasonalityMode": {
    "MULTIPLICATIVE": [],
    "ADDITIVE": [],
    "NONE": []
  },
  "TrendMode": {
    "LINEAR": [],
    "EXPONENTIAL": []
  },
  "ModelMode": {
    "MULTIPLICATIVE": [],
    "ADDITIVE": [],
    "NONE": []
  },
  "_build_tqdm_iterator": [
    "iterable",
    "verbose"
  ],
  "_with_sanity_checks": [],
  "_parallel_apply": [
    "iterator",
    "fn",
    "n_jobs",
    "fn_args",
    "fn_kwargs"
  ],
  "_is_method": [
    "func"
  ],
  "_check_quantiles": [
    "quantiles"
  ],
  "slice_index": [
    "index",
    "start",
    "end"
  ],
  "drop_before_index": [
    "index",
    "split_point"
  ],
  "drop_after_index": [
    "index",
    "split_point"
  ],
  "n_steps_between": [
    "end",
    "start",
    "freq"
  ],
  "infer_freq_intersection": [
    "freq",
    "other"
  ],
  "generate_index": [
    "start",
    "end",
    "length",
    "freq",
    "name"
  ],
  "expand_arr": [
    "arr",
    "ndim"
  ],
  "sample_from_quantiles": [
    "vals",
    "quantiles",
    "num_samples"
  ],
  "ModelType": {
    "FORECASTING_REGRESSOR": [],
    "FORECASTING_CLASSIFIER": []
  },
  "dataframe_col_to_time_index": [
    "df",
    "time_col"
  ],
  "_prepare_plot_params": [
    "series",
    "central_quantile",
    "low_quantile",
    "high_quantile",
    "label",
    "max_nr_components",
    "color",
    "c",
    "alpha"
  ],
  "_compute_central_series": [
    "comp_ts",
    "central_quantile"
  ],
  "_compute_quantile_bounds": [
    "comp_ts",
    "low_quantile",
    "high_quantile"
  ],
  "plotly": [
    "series",
    "fig",
    "central_quantile",
    "low_quantile",
    "high_quantile",
    "title",
    "label",
    "max_nr_components",
    "alpha",
    "color",
    "c",
    "downsample_threshold"
  ],
  "missing_values_ratio": [
    "series"
  ],
  "fill_missing_values": [
    "series",
    "fill"
  ],
  "extract_subseries": [
    "series",
    "min_gap_size",
    "mode"
  ],
  "_const_fill": [
    "series",
    "fill"
  ],
  "_auto_fill": [
    "series"
  ],
  "MODEL_AWARE": [],
  "SIMPLE": [],
  "SplitTimeSeriesSequence": {
    "__init__": [
      "self",
      "type",
      "data",
      "test_size",
      "axis",
      "input_size",
      "horizon",
      "vertical_split_type"
    ],
    "_get_horizontal_split_index": [
      "self"
    ],
    "_get_vertical_split_indices": [
      "self",
      "ts_length"
    ],
    "__getitem__": [
      "self",
      "i"
    ],
    "__len__": [
      "self"
    ],
    "make_splitter": [
      "cls",
      "data",
      "test_size",
      "axis",
      "input_size",
      "horizon",
      "vertical_split_type",
      "lazy"
    ]
  },
  "train_test_split": [
    "data",
    "test_size",
    "axis",
    "input_size",
    "horizon",
    "vertical_split_type",
    "lazy"
  ],
  "_SEQ_TYPE_NAMES": [],
  "SeriesType": {
    "NONE": [],
    "SINGLE": [],
    "SEQ": [],
    "SEQ_SEQ": [],
    "_check_member": [
      "self",
      "other"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__lt__": [
      "self",
      "other"
    ],
    "__add__": [
      "self",
      "other"
    ],
    "__str__": [
      "self"
    ]
  },
  "series2seq": [
    "ts",
    "seq_type_out",
    "nested"
  ],
  "seq2series": [
    "ts"
  ],
  "get_single_series": [
    "ts"
  ],
  "get_series_seq_type": [
    "ts"
  ],
  "retain_period_common_to_all": [
    "series"
  ],
  "prepare_onnx_inputs": [
    "model",
    "series",
    "past_covariates",
    "future_covariates"
  ],
  "ONE_INDEXED_FREQS": [],
  "TIMES_NAME": [],
  "constant_timeseries": [
    "value",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "linear_timeseries": [
    "start_value",
    "end_value",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "sine_timeseries": [
    "value_frequency",
    "value_amplitude",
    "value_phase",
    "value_y_offset",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "gaussian_timeseries": [
    "mean",
    "std",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "random_walk_timeseries": [
    "mean",
    "std",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "autoregressive_timeseries": [
    "coef",
    "start_values",
    "start",
    "end",
    "length",
    "freq",
    "column_name",
    "dtype"
  ],
  "_extend_time_index_until": [
    "time_index",
    "until",
    "add_length",
    "name"
  ],
  "holidays_timeseries": [
    "time_index",
    "country_code",
    "prov",
    "state",
    "column_name",
    "until",
    "add_length",
    "dtype",
    "tz"
  ],
  "datetime_attribute_timeseries": [
    "time_index",
    "attribute",
    "one_hot",
    "cyclic",
    "until",
    "add_length",
    "dtype",
    "with_columns",
    "tz"
  ],
  "_build_forecast_series": [
    "points_preds",
    "input_series",
    "custom_columns",
    "with_static_covs",
    "with_hierarchy",
    "pred_start",
    "time_index",
    "copy"
  ],
  "_build_forecast_series_from_schema": [
    "values",
    "schema",
    "pred_start",
    "predict_likelihood_parameters",
    "likelihood_component_names_fn",
    "copy"
  ],
  "_generate_new_dates": [
    "n",
    "input_series",
    "start"
  ],
  "_process_time_index": [
    "time_index",
    "tz",
    "until",
    "add_length"
  ],
  "MultiOutputMixin": {
    "__init__": [
      "self",
      "estimator",
      "eval_set_name",
      "eval_weight_name",
      "output_chunk_length"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "supports_sample_weight": [
      "self"
    ]
  },
  "MultiOutputRegressor": {},
  "MultiOutputClassifier": {
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ]
  },
  "get_multioutput_estimator_cls": [
    "model_type"
  ],
  "_optimized_historical_forecasts": [
    "model",
    "series",
    "past_covariates",
    "future_covariates",
    "num_samples",
    "start",
    "start_format",
    "forecast_horizon",
    "stride",
    "overlap_end",
    "last_points_only",
    "show_warnings",
    "verbose",
    "predict_likelihood_parameters",
    "random_state",
    "predict_kwargs"
  ],
  "_optimized_historical_forecasts_regression": [
    "model",
    "series",
    "past_covariates",
    "future_covariates",
    "num_samples",
    "start",
    "start_format",
    "forecast_horizon",
    "stride",
    "overlap_end",
    "show_warnings",
    "verbose",
    "predict_likelihood_parameters",
    "random_state",
    "predict_kwargs",
    "last_points_only"
  ],
  "TimeIndex": [],
  "_historical_forecasts_general_checks": [
    "model",
    "series",
    "kwargs",
    "is_conformal"
  ],
  "_historical_forecasts_sanitize_kwargs": [
    "model",
    "fit_kwargs",
    "predict_kwargs",
    "retrain",
    "val_length",
    "show_warnings"
  ],
  "_historical_forecasts_check_kwargs": [
    "hfc_args",
    "name_kwargs",
    "dict_kwargs"
  ],
  "_get_start_index": [
    "series",
    "series_idx",
    "start",
    "start_format",
    "stride",
    "historical_forecasts_time_index"
  ],
  "_adjust_start": [
    "rel_start",
    "stride"
  ],
  "_check_start": [
    "series",
    "start_idx",
    "start",
    "start_format",
    "series_start",
    "ref_start",
    "ref_end",
    "stride",
    "series_idx",
    "is_historical_forecast"
  ],
  "_get_historical_forecasts_setup": [
    "model",
    "series",
    "past_covariates",
    "future_covariates",
    "series_idx",
    "forecast_horizon",
    "start",
    "start_format",
    "stride",
    "overlap_end",
    "retrain",
    "train_length",
    "val_length",
    "show_warnings"
  ],
  "_get_maximum_historical_forecastable_time_index": [
    "model",
    "series",
    "forecast_horizon",
    "overlap_end",
    "past_covariates",
    "future_covariates",
    "is_training"
  ],
  "_adjust_historical_forecasts_time_index": [
    "series",
    "series_idx",
    "historical_forecasts_time_index",
    "start",
    "start_format",
    "stride",
    "show_warnings"
  ],
  "_adjust_historical_forecasts_time_index_training": [
    "model",
    "historical_forecasts_time_index",
    "series",
    "series_idx",
    "retrain",
    "train_length",
    "val_length",
    "show_warnings"
  ],
  "_get_historical_forecast_boundaries": [
    "model",
    "series",
    "series_idx",
    "past_covariates",
    "future_covariates",
    "start",
    "start_format",
    "forecast_horizon",
    "overlap_end",
    "stride",
    "freq",
    "show_warnings"
  ],
  "_check_optimizable_historical_forecasts_global_models": [
    "retrain"
  ],
  "_process_historical_forecast_input": [
    "model",
    "series",
    "past_covariates",
    "future_covariates",
    "forecast_horizon"
  ],
  "_process_predict_start_points_bounds": [
    "series",
    "bounds",
    "stride"
  ],
  "_convert_data_transformers": [
    "data_transformers",
    "copy"
  ],
  "_apply_data_transformers": [
    "series",
    "pred_series",
    "past_covariates",
    "future_covariates",
    "data_transformers",
    "max_future_cov_lag",
    "fit_transformers"
  ],
  "_apply_inverse_data_transformers": [
    "series",
    "forecasts",
    "data_transformers",
    "series_idx"
  ],
  "_slice_intersect_series": [
    "series",
    "past_covariates",
    "future_covariates",
    "sample_weight"
  ],
  "_pack_series_in_list": [
    "series",
    "past_covariates",
    "future_covariates",
    "sample_weight"
  ],
  "_process_historical_forecast_for_backtest": [
    "series",
    "historical_forecasts",
    "last_points_only"
  ],
  "_extend_series_for_overlap_end": [
    "series",
    "historical_forecasts"
  ],
  "SUPPORTED_SAMPLE_WEIGHT": [],
  "FeatureType": {
    "PAST_TARGET": [],
    "FUTURE_TARGET": [],
    "PAST_COVARIATES": [],
    "FUTURE_PAST_COVARIATES": [],
    "HISTORIC_FUTURE_COVARIATES": [],
    "FUTURE_COVARIATES": [],
    "STATIC_COVARIATES": [],
    "SAMPLE_WEIGHT": []
  },
  "_SERIES_TYPES": [],
  "_get_matching_index": [
    "ts_target",
    "ts_covariate",
    "idx"
  ],
  "_process_sample_weight": [
    "sample_weight",
    "target_series"
  ],
  "STABLE_SORT_KWARGS": [],
  "ArrayOrArraySequence": [],
  "create_lagged_data": [
    "target_series",
    "past_covariates",
    "future_covariates",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "output_chunk_length",
    "output_chunk_shift",
    "uses_static_covariates",
    "last_static_covariates_shape",
    "max_samples_per_ts",
    "multi_models",
    "check_inputs",
    "use_moving_windows",
    "is_training",
    "concatenate",
    "sample_weight",
    "stride",
    "show_warnings"
  ],
  "create_lagged_training_data": [
    "target_series",
    "output_chunk_length",
    "output_chunk_shift",
    "past_covariates",
    "future_covariates",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "uses_static_covariates",
    "last_static_covariates_shape",
    "max_samples_per_ts",
    "multi_models",
    "check_inputs",
    "use_moving_windows",
    "concatenate",
    "stride",
    "sample_weight"
  ],
  "create_lagged_prediction_data": [
    "target_series",
    "past_covariates",
    "future_covariates",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "uses_static_covariates",
    "last_static_covariates_shape",
    "max_samples_per_ts",
    "check_inputs",
    "use_moving_windows",
    "concatenate",
    "stride",
    "show_warnings"
  ],
  "add_static_covariates_to_lagged_data": [
    "features",
    "target_series",
    "uses_static_covariates",
    "last_shape"
  ],
  "create_lagged_component_names": [
    "target_series",
    "past_covariates",
    "future_covariates",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "output_chunk_length",
    "concatenate",
    "use_static_covariates"
  ],
  "_get_lagged_indices": [
    "lags",
    "lags_past_covariates",
    "lags_future_covariates"
  ],
  "_create_lagged_data_by_moving_window": [
    "target_series",
    "output_chunk_length",
    "output_chunk_shift",
    "past_covariates",
    "future_covariates",
    "sample_weight",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "lags_extract",
    "lags_order",
    "max_samples_per_ts",
    "multi_models",
    "check_inputs",
    "is_training",
    "stride",
    "show_warnings"
  ],
  "_extract_lagged_vals_from_windows": [
    "windows",
    "lags_to_extract",
    "lags_shift"
  ],
  "_create_lagged_data_by_intersecting_times": [
    "target_series",
    "output_chunk_length",
    "output_chunk_shift",
    "past_covariates",
    "future_covariates",
    "sample_weight",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "max_samples_per_ts",
    "multi_models",
    "check_inputs",
    "is_training",
    "stride",
    "show_warnings"
  ],
  "_create_lagged_data_autoregression": [
    "target_series",
    "t_pred",
    "shift",
    "last_step_shift",
    "series_matrix",
    "covariate_matrices",
    "lags",
    "component_lags",
    "relative_cov_lags",
    "uses_static_covariates",
    "last_static_covariates_shape",
    "num_samples"
  ],
  "_extract_component_lags_autoregression": [
    "series_type",
    "values_matrix",
    "shift",
    "last_step_shift",
    "t_pred",
    "lags",
    "component_lags"
  ],
  "FeatureTimes": [],
  "MinLags": [],
  "MaxLags": [],
  "_get_feature_times": [
    "target_series",
    "past_covariates",
    "future_covariates",
    "lags",
    "lags_past_covariates",
    "lags_future_covariates",
    "output_chunk_length",
    "output_chunk_shift",
    "is_training",
    "return_min_and_max_lags",
    "check_inputs",
    "show_warnings"
  ],
  "get_shared_times": [],
  "get_shared_times_bounds": [],
  "strided_moving_window": [
    "x",
    "window_len",
    "stride",
    "axis",
    "check_inputs"
  ],
  "_extend_time_index": [
    "time_index",
    "freq",
    "new_start",
    "new_end"
  ],
  "_get_freqs": [],
  "_all_equal_freq": [],
  "_check_lags": [
    "lags",
    "lags_past_covariates",
    "lags_future_covariates"
  ],
  "_check_series_length": [
    "series",
    "lags",
    "output_chunk_length",
    "output_chunk_shift",
    "is_training",
    "name"
  ],
  "_extract_sample_weight": [
    "sample_weight",
    "target_series"
  ],
  "TorchInferenceDataset": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "SequentialTorchInferenceDataset": {
    "__init__": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "n",
      "stride",
      "bounds",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "use_static_covariates"
    ],
    "__len__": [
      "self"
    ],
    "_find_list_index": [
      "index",
      "cumulative_lengths",
      "bounds",
      "stride"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "TorchTrainingDatasetOutput": [],
  "TorchTrainingBatch": [],
  "TorchTrainingSample": [],
  "TorchInferenceDatasetOutput": [],
  "TorchInferenceBatch": [],
  "TorchBatch": [],
  "PLModuleInput": [],
  "_SampleIndexType": [],
  "TorchDataset": {
    "__init__": [
      "self"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "_memory_indexer": [
      "self",
      "series_idx",
      "series",
      "shift",
      "input_chunk_length",
      "output_chunk_length",
      "end_of_output_idx",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "n"
    ]
  },
  "TorchTrainingDataset": {
    "__init__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ]
  },
  "ShiftedTorchTrainingDataset": {
    "__init__": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "input_chunk_length",
      "output_chunk_length",
      "shift",
      "stride",
      "max_samples_per_ts",
      "use_static_covariates",
      "sample_weight"
    ],
    "__len__": [
      "self"
    ],
    "__getitem__": [
      "self",
      "idx"
    ],
    "_get_end_of_output_idx": [
      "self",
      "series",
      "series_idx",
      "idx"
    ]
  },
  "SequentialTorchTrainingDataset": {
    "__init__": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "stride",
      "max_samples_per_ts",
      "use_static_covariates",
      "sample_weight"
    ]
  },
  "HorizonBasedTorchTrainingDataset": {
    "__init__": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "stride",
      "lh",
      "lookback",
      "use_static_covariates",
      "sample_weight"
    ],
    "_get_end_of_output_idx": [
      "self",
      "series",
      "series_idx",
      "idx"
    ]
  },
  "MIN_CAUCHY_GAMMA_SAMPLING": [],
  "_check": [
    "param",
    "predicate",
    "param_name",
    "condition_str"
  ],
  "_check_strict_positive": [
    "param",
    "param_name"
  ],
  "_check_in_open_0_1_intvl": [
    "param",
    "param_name"
  ],
  "TorchLikelihood": {
    "__init__": [
      "self",
      "likelihood_type",
      "parameter_names",
      "prior_strength"
    ],
    "compute_loss": [
      "self",
      "model_output",
      "target",
      "sample_weight"
    ],
    "_nllloss": [
      "self",
      "params_out",
      "target",
      "sample_weight"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "_get_equality_attrs": [
      "likelihood",
      "ignore_attrs"
    ]
  },
  "GaussianLikelihood": {
    "__init__": [
      "self",
      "prior_mu",
      "prior_sigma",
      "prior_strength",
      "beta_nll"
    ],
    "_nllloss": [
      "self",
      "params_out",
      "target",
      "sample_weight"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "PoissonLikelihood": {
    "__init__": [
      "self",
      "prior_lambda",
      "prior_strength"
    ],
    "_nllloss": [
      "self",
      "params_out",
      "target",
      "sample_weight"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "NegativeBinomialLikelihood": {
    "__init__": [
      "self"
    ],
    "_prior_params": [
      "self"
    ],
    "_get_r_and_p_from_mu_and_alpha": [
      "mu",
      "alpha"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "BernoulliLikelihood": {
    "__init__": [
      "self",
      "prior_p",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "BetaLikelihood": {
    "__init__": [
      "self",
      "prior_alpha",
      "prior_beta",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "CauchyLikelihood": {
    "__init__": [
      "self",
      "prior_xzero",
      "prior_gamma",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "ContinuousBernoulliLikelihood": {
    "__init__": [
      "self",
      "prior_lambda",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "DirichletLikelihood": {
    "__init__": [
      "self",
      "prior_alphas",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "ExponentialLikelihood": {
    "__init__": [
      "self",
      "prior_lambda",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "GammaLikelihood": {
    "__init__": [
      "self",
      "prior_alpha",
      "prior_beta",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "GeometricLikelihood": {
    "__init__": [
      "self",
      "prior_p",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "GumbelLikelihood": {
    "__init__": [
      "self",
      "prior_mu",
      "prior_beta",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "HalfNormalLikelihood": {
    "__init__": [
      "self",
      "prior_sigma",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "LaplaceLikelihood": {
    "__init__": [
      "self",
      "prior_mu",
      "prior_b",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "LogNormalLikelihood": {
    "__init__": [
      "self",
      "prior_mu",
      "prior_sigma",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "WeibullLikelihood": {
    "__init__": [
      "self",
      "prior_strength"
    ],
    "_prior_params": [
      "self"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "QuantileRegression": {
    "__init__": [
      "self",
      "quantiles"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "compute_loss": [
      "self",
      "model_output",
      "target",
      "sample_weight"
    ],
    "_distr_from_params": [
      "self",
      "params"
    ],
    "_params_from_output": [
      "self",
      "model_output"
    ]
  },
  "LikelihoodType": {
    "Gaussian": [],
    "Poisson": [],
    "NegativeBinomial": [],
    "Bernoulli": [],
    "Beta": [],
    "Cauchy": [],
    "ContinuousBernoulli": [],
    "Dirichlet": [],
    "Exponential": [],
    "Gamma": [],
    "Geometric": [],
    "Gumbel": [],
    "HalfNormal": [],
    "Laplace": [],
    "LogNormal": [],
    "Weibull": [],
    "Quantile": [],
    "ClassProbability": []
  },
  "Likelihood": {
    "__init__": [
      "self",
      "likelihood_type",
      "parameter_names"
    ],
    "fit": [
      "self",
      "model"
    ],
    "component_names": [
      "self",
      "series",
      "components"
    ],
    "type": [
      "self"
    ],
    "parameter_names": [
      "self"
    ],
    "num_parameters": [
      "self"
    ],
    "_get_equality_attrs": [
      "likelihood",
      "ignore_attrs"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "__repr__": [
      "self"
    ]
  },
  "likelihood_component_names": [
    "components",
    "parameter_names"
  ],
  "quantile_names": [
    "q",
    "component"
  ],
  "quantile_interval_names": [
    "q_interval",
    "component"
  ],
  "QuantilePrediction": {
    "__init__": [
      "self",
      "quantiles"
    ],
    "predict": [
      "self",
      "model_output",
      "num_samples"
    ],
    "sample": [
      "self",
      "model_output",
      "num_samples"
    ]
  },
  "SKLearnLikelihood": {
    "__init__": [
      "self",
      "likelihood_type",
      "parameter_names",
      "n_outputs"
    ],
    "predict": [
      "self",
      "model",
      "x",
      "num_samples",
      "predict_likelihood_parameters"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "_estimator_predict": [
      "self",
      "model",
      "x"
    ],
    "_get_median_prediction": [
      "self",
      "model_output"
    ]
  },
  "ClassProbabilityLikelihood": {
    "__init__": [
      "self",
      "n_outputs"
    ],
    "fit": [
      "self",
      "model"
    ],
    "component_names": [
      "self",
      "series",
      "components"
    ],
    "_estimator_predict": [
      "self",
      "model",
      "x"
    ],
    "sample": [
      "self",
      "model_output"
    ],
    "predict_likelihood_parameters": [
      "self",
      "model_output"
    ],
    "_get_median_prediction": [
      "self",
      "model_output"
    ]
  },
  "_get_likelihood": [
    "likelihood",
    "n_outputs",
    "available_likelihoods",
    "quantiles"
  ],
  "RMSNorm": {
    "__init__": [
      "self",
      "dim",
      "eps"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "LayerNormNoBias": {
    "__init__": [
      "self",
      "input_size"
    ]
  },
  "LayerNorm": {
    "__init__": [
      "self",
      "input_size"
    ]
  },
  "RINorm": {
    "__init__": [
      "self",
      "input_dim",
      "eps",
      "affine"
    ],
    "forward": [
      "self",
      "x"
    ],
    "inverse": [
      "self",
      "x"
    ]
  },
  "_TOLERANCE": [],
  "_ResidualBlockConfig": {},
  "_TransformerConfig": {},
  "_StackedTransformersConfig": {},
  "_RMSNorm": {
    "__init__": [
      "self",
      "num_features"
    ],
    "forward": [
      "self",
      "inputs"
    ]
  },
  "_ResidualBlock": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_make_attn_mask": [
    "query_length",
    "num_all_masked_kv",
    "kv_length"
  ],
  "_RotaryPositionalEmbedding": {
    "__init__": [
      "self",
      "embedding_dims",
      "min_timescale",
      "max_timescale"
    ],
    "forward": [
      "self",
      "inputs",
      "position"
    ]
  },
  "_torch_dot_product_attention": [
    "query",
    "key",
    "value",
    "mask"
  ],
  "_PerDimScale": {
    "__init__": [
      "self",
      "num_dims"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_MultiHeadAttention": {
    "__init__": [
      "self",
      "num_heads",
      "in_features"
    ],
    "forward": [
      "self",
      "inputs_q"
    ]
  },
  "_Transformer": {
    "__init__": [
      "self",
      "config"
    ],
    "forward": [
      "self",
      "input_embeddings",
      "patch_mask"
    ]
  },
  "_update_running_stats": [
    "n",
    "mu",
    "sigma",
    "x",
    "mask"
  ],
  "_revin": [
    "x",
    "mu",
    "sigma",
    "reverse"
  ],
  "CustomFeedForwardEncoderLayer": {
    "__init__": [
      "self",
      "ffn",
      "dropout"
    ],
    "_ff_block": [
      "self",
      "x"
    ]
  },
  "CustomFeedForwardDecoderLayer": {
    "__init__": [
      "self",
      "ffn",
      "dropout"
    ],
    "_ff_block": [
      "self",
      "x"
    ]
  },
  "GLU_FFN": [],
  "GLU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "Bilinear": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ReGLU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "GEGLU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "SwiGLU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "ReLU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "GELU": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_Patch": {
    "__init__": [
      "self",
      "patch_size",
      "patch_stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_InstanceNorm": {
    "__init__": [
      "self",
      "eps",
      "use_arcsinh"
    ],
    "forward": [
      "self",
      "x",
      "loc_scale"
    ],
    "inverse": [
      "self",
      "x",
      "loc_scale"
    ]
  },
  "_RoPE": {
    "__init__": [
      "self",
      "dim",
      "base"
    ],
    "forward": [
      "self",
      "x",
      "position_ids"
    ],
    "rotate_half": [
      "x"
    ],
    "apply_rotary_pos_emb": [
      "q",
      "k",
      "cos",
      "sin",
      "unsqueeze_dim"
    ]
  },
  "_MHA": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "num_heads",
      "dropout_rate",
      "rope_theta",
      "attn_implementation",
      "use_rope"
    ],
    "_eager_attention": [
      "self",
      "query_states",
      "key_states",
      "value_states",
      "mask"
    ],
    "_sdpa_attention": [
      "self",
      "query_states",
      "key_states",
      "value_states",
      "mask"
    ],
    "forward": [
      "self",
      "hidden_states",
      "mask",
      "position_ids"
    ]
  },
  "_Chronos2LayerNorm": {
    "__init__": [
      "self",
      "hidden_size",
      "eps"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "_TimeSelfAttention": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "num_heads",
      "dropout_rate",
      "rope_theta",
      "attn_implementation",
      "layer_norm_epsilon"
    ],
    "forward": [
      "self",
      "hidden_states",
      "attention_mask",
      "position_ids"
    ]
  },
  "_GroupSelfAttention": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "num_heads",
      "dropout_rate",
      "rope_theta",
      "attn_implementation",
      "layer_norm_epsilon"
    ],
    "forward": [
      "self",
      "hidden_states",
      "attention_mask"
    ]
  },
  "_MLP": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout_rate",
      "dense_act_fn"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "_FeedForward": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout_rate",
      "dense_act_fn",
      "is_gated_act",
      "layer_norm_epsilon"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "_Chronos2EncoderBlock": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "d_ff",
      "num_heads",
      "dropout_rate",
      "rope_theta",
      "attn_implementation",
      "dense_act_fn",
      "layer_norm_epsilon",
      "is_gated_act"
    ],
    "forward": [
      "self",
      "hidden_states"
    ]
  },
  "_Chronos2Encoder": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "d_ff",
      "num_heads",
      "dropout_rate",
      "rope_theta",
      "attn_implementation",
      "dense_act_fn",
      "layer_norm_epsilon",
      "is_gated_act",
      "num_layers"
    ],
    "_expand_and_invert_time_attention_mask": [
      "attention_mask",
      "floating_type"
    ],
    "_construct_and_invert_group_time_mask": [
      "group_ids",
      "attention_mask",
      "floating_type"
    ],
    "forward": [
      "self",
      "inputs_embeds"
    ]
  },
  "HuggingFaceConnector": {
    "__init__": [
      "self",
      "model_name",
      "model_revision",
      "local_dir",
      "config_file",
      "model_file"
    ],
    "load_config": [
      "self"
    ],
    "load_model_weights": [
      "self",
      "module"
    ],
    "load_model": [
      "self",
      "module_class",
      "pl_module_params",
      "additional_params"
    ],
    "_get_file_path": [
      "self",
      "filename"
    ],
    "_extract_module_params": [
      "module_class",
      "config"
    ]
  },
  "FeedForward": {
    "__init__": [
      "self",
      "d_model",
      "d_ff",
      "dropout",
      "activation",
      "is_gated",
      "bias1",
      "bias2",
      "bias_gate"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "FilteringModel": {
    "__init__": [
      "self"
    ],
    "filter": [
      "self",
      "series"
    ]
  },
  "KalmanFilter": {
    "__init__": [
      "self",
      "dim_x",
      "kf"
    ],
    "__str__": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "covariates",
      "num_block_rows"
    ],
    "filter": [
      "self",
      "series",
      "covariates",
      "num_samples"
    ]
  },
  "GaussianProcessFilter": {
    "__init__": [
      "self",
      "kernel"
    ],
    "filter": [
      "self",
      "series",
      "num_samples"
    ]
  },
  "MovingAverageFilter": {
    "__init__": [
      "self",
      "window",
      "centered"
    ],
    "filter": [
      "self",
      "series"
    ]
  },
  "HiddenState": [],
  "get_embedding_size": [
    "n",
    "max_size"
  ],
  "_TimeDistributedEmbeddingBag": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_MultiEmbedding": {
    "__init__": [
      "self",
      "embedding_sizes",
      "variable_names"
    ],
    "input_size": [
      "self"
    ],
    "output_size": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_TimeDistributedInterpolation": {
    "__init__": [
      "self",
      "output_size",
      "batch_first",
      "trainable"
    ],
    "interpolate": [
      "self",
      "x"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_GatedLinearUnit": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "dropout"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_ResampleNorm": {
    "__init__": [
      "self",
      "input_size",
      "output_size",
      "trainable_add",
      "norm",
      "skip_interpolation"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_AddNorm": {
    "__init__": [
      "self",
      "input_size",
      "skip_size",
      "trainable_add",
      "norm",
      "skip_interpolation"
    ],
    "forward": [
      "self",
      "x",
      "skip"
    ]
  },
  "_GateAddNorm": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "skip_size",
      "trainable_add",
      "dropout",
      "layer_norm",
      "skip_interpolation"
    ],
    "forward": [
      "self",
      "x",
      "skip"
    ]
  },
  "_GatedResidualNetwork": {
    "__init__": [
      "self",
      "input_size",
      "hidden_size",
      "output_size",
      "dropout",
      "context_size",
      "residual",
      "layer_norm",
      "skip_interpolation"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "context",
      "residual"
    ]
  },
  "_VariableSelectionNetwork": {
    "__init__": [
      "self",
      "input_sizes",
      "hidden_size",
      "input_embedding_flags",
      "dropout",
      "context_size",
      "single_variable_grns",
      "prescalers",
      "layer_norm",
      "skip_interpolation"
    ],
    "input_size_total": [
      "self"
    ],
    "num_inputs": [
      "self"
    ],
    "forward": [
      "self",
      "x",
      "context"
    ]
  },
  "_ScaledDotProductAttention": {
    "__init__": [
      "self",
      "dropout",
      "scale"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "mask"
    ]
  },
  "_InterpretableMultiHeadAttention": {
    "__init__": [
      "self",
      "n_head",
      "d_model",
      "dropout"
    ],
    "init_weights": [
      "self"
    ],
    "forward": [
      "self",
      "q",
      "k",
      "v",
      "mask"
    ]
  },
  "BUILT_IN": [],
  "FFN": [],
  "_generate_coder": [
    "d_model",
    "dim_ff",
    "dropout",
    "nhead",
    "num_layers",
    "norm_layer",
    "coder_cls",
    "layer_cls",
    "ffn_cls"
  ],
  "_PositionalEncoding": {
    "__init__": [
      "self",
      "d_model",
      "dropout",
      "max_len"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_TransformerModule": {
    "__init__": [
      "self",
      "input_size",
      "output_size",
      "nr_params",
      "d_model",
      "nhead",
      "num_encoder_layers",
      "num_decoder_layers",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_type",
      "custom_encoder",
      "custom_decoder"
    ],
    "_create_transformer_inputs": [
      "self",
      "data"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "TransformerModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "d_model",
      "nhead",
      "num_encoder_layers",
      "num_decoder_layers",
      "dim_feedforward",
      "dropout",
      "activation",
      "norm_type",
      "custom_encoder",
      "custom_decoder"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "ACTIVATIONS": [],
  "_Block": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "num_layers",
      "layer_width",
      "nr_params",
      "pooling_kernel_size",
      "n_freq_downsample",
      "batch_norm",
      "dropout",
      "activation",
      "MaxPool1d"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_Stack": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "num_blocks",
      "num_layers",
      "layer_width",
      "nr_params",
      "pooling_kernel_sizes",
      "n_freq_downsample",
      "batch_norm",
      "dropout",
      "activation",
      "MaxPool1d"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_NHiTSModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "nr_params",
      "num_stacks",
      "num_blocks",
      "num_layers",
      "layer_widths",
      "pooling_kernel_sizes",
      "n_freq_downsample",
      "batch_norm",
      "dropout",
      "activation",
      "MaxPool1d"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "NHiTSModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "num_stacks",
      "num_blocks",
      "num_layers",
      "layer_widths",
      "pooling_kernel_sizes",
      "n_freq_downsample",
      "dropout",
      "activation",
      "MaxPool1d"
    ],
    "_prepare_pooling_downsampling": [
      "pooling_kernel_sizes",
      "n_freq_downsample",
      "in_len",
      "out_len",
      "num_blocks",
      "num_stacks"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "RandomForestModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "n_estimators",
      "max_depth",
      "multi_models",
      "use_static_covariates",
      "random_state"
    ]
  },
  "RandomForest": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "n_estimators",
      "max_depth",
      "multi_models",
      "use_static_covariates",
      "random_state"
    ]
  },
  "KalmanForecaster": {
    "__init__": [
      "self",
      "dim_x",
      "kf",
      "add_encoders",
      "random_state"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ]
  },
  "AutoCES": {
    "__init__": [
      "self"
    ]
  },
  "CatBoostModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "categorical_past_covariates",
      "categorical_future_covariates",
      "categorical_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "val_sample_weight",
      "verbose"
    ],
    "_add_val_set_to_kwargs": [
      "self",
      "kwargs",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "val_sample_weight",
      "max_samples_per_ts",
      "stride"
    ],
    "_supports_val_series": [
      "self"
    ],
    "val_set_params": [
      "self"
    ],
    "_supports_native_multioutput": [
      "self"
    ],
    "_categorical_fit_param": [
      "self"
    ],
    "_format_samples": [
      "self",
      "samples",
      "labels"
    ]
  },
  "CatBoostClassifierModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "categorical_past_covariates",
      "categorical_future_covariates",
      "categorical_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "_format_samples": [
      "self",
      "samples",
      "labels"
    ],
    "_supports_native_multioutput": [
      "self"
    ]
  },
  "StatsForecastModel": {
    "__init__": [
      "self",
      "model",
      "add_encoders",
      "quantiles",
      "random_state"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "_estimator_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "levels"
    ],
    "_get_target_residuals": [
      "self",
      "series",
      "future_covariates"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "_supports_range_index": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_supports_native_transferable_series": [
      "self"
    ],
    "_supports_native_future_covariates": [
      "self"
    ],
    "likelihood": [
      "self"
    ],
    "_supports_non_retrainable_historical_forecasts": [
      "self"
    ]
  },
  "_SFModel": {
    "fit": [
      "self"
    ],
    "predict": [
      "self"
    ],
    "forecast": [
      "self"
    ],
    "forward": [
      "self"
    ]
  },
  "_unpack_sf_dict": [
    "forecast_dict",
    "levels"
  ],
  "_Chronos2ForecastingConfig": {},
  "_Chronos2Module": {
    "__init__": [
      "self",
      "d_model",
      "d_kv",
      "d_ff",
      "num_layers",
      "num_heads",
      "dropout_rate",
      "layer_norm_epsilon",
      "feed_forward_proj",
      "rope_theta",
      "attn_implementation",
      "chronos_config"
    ],
    "_prepare_patched_context": [
      "self",
      "context"
    ],
    "_prepare_patched_future": [
      "self",
      "future_covariates",
      "loc_scale",
      "num_output_patches",
      "batch_size"
    ],
    "_forward": [
      "self",
      "context",
      "group_ids",
      "future_covariates",
      "num_output_patches"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "Chronos2Model": {
    "_allows_finetuning": [],
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "likelihood",
      "hub_model_name",
      "hub_model_revision",
      "local_dir"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "ModelMeta": {
    "__call__": [
      "cls"
    ]
  },
  "ForecastingModel": {
    "__init__": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "_supports_range_index": [
      "self"
    ],
    "likelihood": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_supports_non_retrainable_historical_forecasts": [
      "self"
    ],
    "_supports_val_series": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "supports_sample_weight": [
      "self"
    ],
    "supports_likelihood_parameter_prediction": [
      "self"
    ],
    "supports_transferable_series_prediction": [
      "self"
    ],
    "uses_past_covariates": [
      "self"
    ],
    "uses_future_covariates": [
      "self"
    ],
    "uses_static_covariates": [
      "self"
    ],
    "considers_static_covariates": [
      "self"
    ],
    "supports_optimized_historical_forecasts": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "output_chunk_shift": [
      "self"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "_fit_wrapper": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "val_series"
    ],
    "_predict_wrapper": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "predict_likelihood_parameters",
      "random_state"
    ],
    "min_train_series_length": [
      "self"
    ],
    "min_train_samples": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ],
    "_generate_new_dates": [
      "self",
      "n",
      "input_series"
    ],
    "_build_forecast_series": [
      "self",
      "points_preds",
      "input_series",
      "custom_components",
      "with_static_covs",
      "with_hierarchy",
      "pred_start"
    ],
    "_historical_forecasts_sanity_checks": [
      "self"
    ],
    "_get_last_prediction_time": [
      "self",
      "series",
      "forecast_horizon",
      "overlap_end",
      "latest_possible_prediction_start"
    ],
    "_check_optimizable_historical_forecasts": [
      "self",
      "retrain"
    ],
    "historical_forecasts": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "random_state"
    ],
    "backtest": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "historical_forecasts",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "metric",
      "reduction",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "metric_kwargs",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "random_state"
    ],
    "gridsearch": [
      "model_class",
      "parameters",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "stride",
      "start",
      "start_format",
      "last_points_only",
      "show_warnings",
      "val_series",
      "use_fitted_values",
      "metric",
      "reduction",
      "verbose",
      "n_jobs",
      "n_random_samples",
      "data_transformers",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "random_state"
    ],
    "residuals": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "historical_forecasts",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "metric",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "metric_kwargs",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "values_only",
      "random_state"
    ],
    "initialize_encoders": [
      "self",
      "default"
    ],
    "generate_fit_encodings": [
      "self",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "generate_predict_encodings": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "generate_fit_predict_encodings": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "_process_validation_set": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "_sample_params": [
      "model_class",
      "params",
      "n_random_samples"
    ],
    "_extract_model_creation_params": [
      "self"
    ],
    "untrained_model": [
      "self"
    ],
    "model_params": [
      "self"
    ],
    "_default_save_path": [
      "cls"
    ],
    "_clean": [
      "self"
    ],
    "save": [
      "self",
      "path",
      "clean"
    ],
    "load": [
      "path"
    ],
    "_assert_univariate": [
      "self",
      "series"
    ],
    "_assert_multivariate": [
      "self",
      "series"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_get_model_description_string": [
      "self",
      "include_default_params"
    ],
    "_get_default_model_params": [
      "cls"
    ],
    "_verify_static_covariates": [
      "self",
      "static_covariates"
    ],
    "_optimized_historical_forecasts": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "start",
      "start_format",
      "forecast_horizon",
      "stride",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "random_state",
      "predict_kwargs"
    ],
    "_sanity_check_predict_likelihood_parameters": [
      "self",
      "n",
      "output_chunk_length",
      "num_samples"
    ]
  },
  "LocalForecastingModel": {
    "__init__": [
      "self",
      "add_encoders"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "extreme_lags": [
      "self"
    ],
    "supports_transferable_series_prediction": [
      "self"
    ],
    "min_train_samples": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ]
  },
  "GlobalForecastingModel": {
    "__init__": [
      "self",
      "add_encoders"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "verbose",
      "predict_likelihood_parameters",
      "show_warnings",
      "random_state"
    ],
    "_clean": [
      "self"
    ],
    "_supports_non_retrainable_historical_forecasts": [
      "self"
    ],
    "supports_optimized_historical_forecasts": [
      "self"
    ],
    "supports_transferable_series_prediction": [
      "self"
    ],
    "supports_sample_weight": [
      "self"
    ]
  },
  "FutureCovariatesLocalForecastingModel": {
    "fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "_predict": [
      "self",
      "n",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "_verify_passed_predict_covariates": [
      "self",
      "future_covariates"
    ],
    "_supress_generate_predict_encoding": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ]
  },
  "TransferableFutureCovariatesLocalForecastingModel": {
    "predict": [
      "self",
      "n",
      "series",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "generate_predict_encodings": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "supports_transferable_series_prediction": [
      "self"
    ],
    "_supports_non_retrainable_historical_forecasts": [
      "self"
    ],
    "_supress_generate_predict_encoding": [
      "self"
    ]
  },
  "EnsembleModel": {
    "__init__": [
      "self",
      "forecasting_models",
      "ensemble_model",
      "train_num_samples",
      "train_samples_reduction",
      "train_forecasting_models",
      "train_n_points",
      "show_warnings"
    ],
    "untrained_model": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "verbose"
    ],
    "_stack_ts_seq": [
      "self",
      "predictions"
    ],
    "_stack_ts_multiseq": [
      "self",
      "predictions_list"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "_make_multiple_predictions": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "random_state",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "verbose",
      "predict_likelihood_parameters",
      "show_warnings",
      "random_state"
    ],
    "ensemble": [
      "self",
      "predictions",
      "series",
      "num_samples",
      "predict_likelihood_parameters",
      "random_state",
      "verbose"
    ],
    "_predictions_reduction": [
      "self",
      "predictions"
    ],
    "_clean": [
      "self"
    ],
    "save": [
      "self",
      "path",
      "clean"
    ],
    "load": [
      "path",
      "pl_trainer_kwargs"
    ],
    "min_train_samples": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "_models_are_probabilistic": [
      "self"
    ],
    "_models_same_likelihood": [
      "self"
    ],
    "supports_likelihood_parameter_prediction": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_optimized_historical_forecasts": [
      "self"
    ],
    "_supports_non_retrainable_historical_forecasts": [
      "self"
    ],
    "_full_past_covariates_support": [
      "self"
    ],
    "_full_future_covariates_support": [
      "self"
    ],
    "_verify_past_future_covariates": [
      "self",
      "past_covariates",
      "future_covariates"
    ]
  },
  "_GType": {
    "GENERIC": [],
    "TREND": [],
    "SEASONALITY": []
  },
  "GTypes": [],
  "_TrendGenerator": {
    "__init__": [
      "self",
      "expansion_coefficient_dim",
      "target_length"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_SeasonalityGenerator": {
    "__init__": [
      "self",
      "target_length"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_NBEATSModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "nr_params",
      "generic_architecture",
      "num_stacks",
      "num_blocks",
      "num_layers",
      "layer_widths",
      "expansion_coefficient_dim",
      "trend_polynomial_degree",
      "batch_norm",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "NBEATSModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "generic_architecture",
      "num_stacks",
      "num_blocks",
      "num_layers",
      "layer_widths",
      "expansion_coefficient_dim",
      "trend_polynomial_degree",
      "dropout",
      "activation"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "_TimesFM2p5_200M_Definition": {
    "context_limit": []
  },
  "_TimesFM2p5Module": {
    "config": [],
    "__init__": [
      "self"
    ],
    "_forward": [
      "self",
      "inputs",
      "masks"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "TimesFM2p5Model": {
    "_allows_finetuning": [],
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "likelihood",
      "hub_model_name",
      "hub_model_revision",
      "local_dir"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ]
  },
  "AutoARIMA": {
    "__init__": [
      "self"
    ]
  },
  "FoundationModel": {
    "__init__": [
      "self",
      "enable_finetuning"
    ],
    "_requires_training": [
      "self"
    ]
  },
  "xgb_quantile_loss": [
    "labels",
    "preds",
    "quantile"
  ],
  "XGBModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "val_sample_weight",
      "verbose"
    ],
    "_supports_val_series": [
      "self"
    ],
    "val_set_params": [
      "self"
    ],
    "_supports_native_multioutput": [
      "self"
    ]
  },
  "XGBClassifierModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "random_state",
      "multi_models",
      "use_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "_supports_native_multioutput": [
      "self"
    ]
  },
  "LightGBMModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "categorical_past_covariates",
      "categorical_future_covariates",
      "categorical_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "val_sample_weight",
      "verbose"
    ],
    "_supports_val_series": [
      "self"
    ],
    "val_set_params": [
      "self"
    ],
    "_categorical_fit_param": [
      "self"
    ]
  },
  "LightGBMClassifierModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "random_state",
      "multi_models",
      "use_static_covariates",
      "categorical_past_covariates",
      "categorical_future_covariates",
      "categorical_static_covariates"
    ],
    "_create_model": [],
    "_set_likelihood": [
      "self",
      "likelihood",
      "output_chunk_length",
      "multi_models",
      "quantiles"
    ],
    "_supports_native_multioutput": [
      "self"
    ]
  },
  "LAGS_TYPE": [],
  "FUTURE_LAGS_TYPE": [],
  "SKLearnModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "model",
      "multi_models",
      "use_static_covariates",
      "random_state"
    ],
    "_validate_lags": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates"
    ],
    "_generate_lags": [
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_shift"
    ],
    "_get_lags": [
      "self",
      "lags_type"
    ],
    "_get_lagged_features": [
      "self",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "min_train_samples": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "output_chunk_shift": [
      "self"
    ],
    "get_estimator": [
      "self",
      "horizon",
      "target_dim",
      "quantile"
    ],
    "_add_val_set_to_kwargs": [
      "self",
      "kwargs",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "val_sample_weight",
      "max_samples_per_ts",
      "stride"
    ],
    "_create_lagged_data": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "sample_weight",
      "stride",
      "last_static_covariates_shape"
    ],
    "_format_samples": [
      "self",
      "samples",
      "labels"
    ],
    "_fit_model": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "sample_weight",
      "stride",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "val_sample_weight",
      "verbose"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "stride",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "verbose",
      "predict_likelihood_parameters",
      "show_warnings",
      "random_state"
    ],
    "_predict": [
      "self",
      "x",
      "num_samples",
      "predict_likelihood_parameters",
      "random_state",
      "verbose"
    ],
    "lagged_feature_names": [
      "self"
    ],
    "lagged_label_names": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "likelihood": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "supports_sample_weight": [
      "self"
    ],
    "val_set_params": [
      "self"
    ],
    "_check_optimizable_historical_forecasts": [
      "self",
      "retrain"
    ],
    "_optimized_historical_forecasts": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "start",
      "start_format",
      "forecast_horizon",
      "stride",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "random_state",
      "predict_kwargs"
    ],
    "_supports_native_multioutput": [
      "self"
    ],
    "_model_type": [
      "self"
    ]
  },
  "_QuantileModelContainer": {
    "__init__": [
      "self"
    ]
  },
  "SKLearnModelWithCategoricalFeatures": {
    "__init__": [
      "self",
      "model",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "multi_models",
      "use_static_covariates",
      "categorical_past_covariates",
      "categorical_future_covariates",
      "categorical_static_covariates",
      "random_state"
    ],
    "_get_categorical_features": [
      "self",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "_fit_model": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "sample_weight",
      "verbose"
    ],
    "_validate_categorical_components": [
      "self",
      "samples"
    ],
    "_format_samples": [
      "self",
      "samples",
      "labels"
    ],
    "_categorical_fit_param": [
      "self"
    ]
  },
  "RegressionModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "model",
      "multi_models",
      "use_static_covariates",
      "random_state"
    ]
  },
  "_ClassifierMixin": {
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "stride",
      "verbose"
    ],
    "class_labels": [
      "self"
    ],
    "_validate_lags": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates"
    ],
    "_model_type": [
      "self"
    ]
  },
  "SKLearnClassifierModel": {
    "__init__": [
      "self",
      "model",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "multi_models",
      "use_static_covariates",
      "random_state"
    ]
  },
  "_NLinearModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "future_cov_dim",
      "static_cov_dim",
      "nr_params",
      "shared_weights",
      "const_init",
      "normalize"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "NLinearModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "shared_weights",
      "const_init",
      "normalize",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ]
  },
  "_TCNModule": {
    "__init__": [
      "self",
      "input_size",
      "kernel_size",
      "num_filters",
      "num_layers",
      "dilation_base",
      "weight_norm",
      "target_size",
      "nr_params",
      "target_length",
      "dropout"
    ],
    "forward": [
      "self",
      "x_in"
    ],
    "first_prediction_index": [
      "self"
    ]
  },
  "TCNModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "kernel_size",
      "num_filters",
      "num_layers",
      "dilation_base",
      "weight_norm",
      "dropout"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_build_train_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "max_samples_per_ts",
      "stride"
    ]
  },
  "DEFAULT_DARTS_FOLDER": [],
  "CHECKPOINTS_FOLDER": [],
  "RUNS_FOLDER": [],
  "INIT_MODEL_NAME": [],
  "TORCH_NP_DTYPES": [],
  "TFM_ATTRS_NO_PICKLE": [],
  "_get_checkpoint_folder": [
    "work_dir",
    "model_name"
  ],
  "_get_logs_folder": [
    "work_dir",
    "model_name"
  ],
  "_get_runs_folder": [
    "work_dir",
    "model_name"
  ],
  "_get_checkpoint_fname": [
    "work_dir",
    "model_name",
    "best"
  ],
  "TorchForecastingModel": {
    "__init__": [
      "self",
      "batch_size",
      "n_epochs",
      "model_name",
      "work_dir",
      "log_tensorboard",
      "nr_epochs_val_period",
      "force_reset",
      "save_checkpoints",
      "add_encoders",
      "random_state",
      "pl_trainer_kwargs",
      "show_warnings"
    ],
    "_validate_model_params": [
      "cls"
    ],
    "_extract_torch_model_params": [
      "cls"
    ],
    "_extract_pl_module_params": [],
    "_create_save_dirs": [
      "self"
    ],
    "_remove_save_dirs": [
      "self"
    ],
    "reset_model": [
      "self"
    ],
    "_init_model": [
      "self",
      "trainer"
    ],
    "_setup_trainer": [
      "self",
      "trainer",
      "model",
      "verbose",
      "epochs"
    ],
    "_init_trainer": [
      "trainer_params",
      "max_epochs"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_build_train_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "max_samples_per_ts",
      "stride"
    ],
    "_build_inference_dataset": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "stride",
      "bounds"
    ],
    "_verify_train_dataset_type": [
      "train_dataset"
    ],
    "_verify_inference_dataset_type": [
      "inference_dataset"
    ],
    "_validate_predict_sample": [
      "train_sample",
      "predict_sample"
    ],
    "_verify_past_future_covariates": [
      "self",
      "past_covariates",
      "future_covariates"
    ],
    "_update_covariates_use": [
      "self"
    ],
    "to_onnx": [
      "self",
      "path"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "trainer",
      "verbose",
      "epochs",
      "max_samples_per_ts",
      "dataloader_kwargs",
      "sample_weight",
      "val_sample_weight",
      "stride",
      "load_best"
    ],
    "_setup_for_fit_from_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "stride",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "val_sample_weight",
      "trainer",
      "verbose",
      "epochs",
      "max_samples_per_ts",
      "dataloader_kwargs",
      "load_best"
    ],
    "fit_from_dataset": [
      "self",
      "train_dataset",
      "val_dataset",
      "trainer",
      "verbose",
      "epochs",
      "dataloader_kwargs",
      "load_best"
    ],
    "_setup_for_train": [
      "self",
      "train_dataset",
      "val_dataset",
      "trainer",
      "verbose",
      "epochs",
      "dataloader_kwargs",
      "load_best"
    ],
    "_train": [
      "self",
      "trainer",
      "model",
      "train_loader",
      "val_loader",
      "load_best"
    ],
    "lr_find": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "val_series",
      "val_past_covariates",
      "val_future_covariates",
      "sample_weight",
      "val_sample_weight",
      "trainer",
      "verbose",
      "epochs",
      "max_samples_per_ts",
      "dataloader_kwargs",
      "min_lr",
      "max_lr",
      "num_training",
      "mode",
      "early_stop_threshold"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "trainer",
      "batch_size",
      "verbose",
      "n_jobs",
      "roll_size",
      "num_samples",
      "dataloader_kwargs",
      "mc_dropout",
      "predict_likelihood_parameters",
      "show_warnings",
      "random_state"
    ],
    "predict_from_dataset": [
      "self",
      "n",
      "dataset",
      "trainer",
      "batch_size",
      "verbose",
      "n_jobs",
      "roll_size",
      "num_samples",
      "dataloader_kwargs",
      "mc_dropout",
      "predict_likelihood_parameters",
      "random_state",
      "values_only"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "_batch_collate_fn": [
      "batch"
    ],
    "_clean": [
      "self"
    ],
    "save": [
      "self",
      "path",
      "clean"
    ],
    "load": [
      "path",
      "pl_trainer_kwargs"
    ],
    "load_from_checkpoint": [
      "model_name",
      "work_dir",
      "file_name",
      "best"
    ],
    "_load_from_checkpoint": [
      "self",
      "file_path"
    ],
    "load_weights_from_checkpoint": [
      "self",
      "model_name",
      "work_dir",
      "file_name",
      "best",
      "strict",
      "load_encoders",
      "skip_checks"
    ],
    "load_weights": [
      "self",
      "path",
      "load_encoders",
      "skip_checks"
    ],
    "to_cpu": [
      "self"
    ],
    "model_created": [
      "self"
    ],
    "epochs_trained": [
      "self"
    ],
    "likelihood": [
      "self"
    ],
    "input_chunk_length": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "output_chunk_shift": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_supports_val_series": [
      "self"
    ],
    "min_train_samples": [
      "self"
    ],
    "_requires_training": [
      "self"
    ],
    "_check_optimizable_historical_forecasts": [
      "self",
      "retrain"
    ],
    "_optimized_historical_forecasts": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "start",
      "start_format",
      "forecast_horizon",
      "stride",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "random_state",
      "predict_kwargs"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "_load_encoders": [
      "self",
      "tfm_save",
      "load_encoders"
    ],
    "_check_ckpt_parameters": [
      "self",
      "tfm_save"
    ],
    "__getstate__": [
      "self"
    ],
    "__setstate__": [
      "self",
      "d"
    ]
  },
  "_raise_if_wrong_type": [
    "obj",
    "exp_type",
    "msg"
  ],
  "PastCovariatesTorchModel": {
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ]
  },
  "FutureCovariatesTorchModel": {
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ]
  },
  "DualCovariatesTorchModel": {
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ]
  },
  "MixedCovariatesTorchModel": {
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ]
  },
  "SplitCovariatesTorchModel": {
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ]
  },
  "AutoMFLES": {
    "__init__": [
      "self"
    ],
    "_supports_native_future_covariates": [
      "self"
    ]
  },
  "CustomBlockRNNModule": {
    "__init__": [
      "self",
      "input_size",
      "hidden_dim",
      "future_cov_dim",
      "num_layers",
      "target_size",
      "nr_params",
      "num_layers_out_fc",
      "dropout",
      "activation"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "_BlockRNNModule": {
    "__init__": [
      "self",
      "name",
      "activation"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "BlockRNNModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "model",
      "hidden_dim",
      "n_rnn_layers",
      "hidden_fc_sizes",
      "dropout",
      "activation",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_check_ckpt_parameters": [
      "self",
      "tfm_save"
    ],
    "supports_static_covariates": [
      "self"
    ]
  },
  "_MovingAvg": {
    "__init__": [
      "self",
      "kernel_size",
      "stride"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_SeriesDecomp": {
    "__init__": [
      "self",
      "kernel_size"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_DLinearModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "future_cov_dim",
      "static_cov_dim",
      "nr_params",
      "shared_weights",
      "kernel_size",
      "const_init"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "DLinearModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "shared_weights",
      "kernel_size",
      "const_init",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ]
  },
  "_check_approximate_seasonality": [
    "series",
    "seasonality_period",
    "period_error_margin",
    "max_seasonality_order"
  ],
  "_find_relevant_timestamp_attributes": [
    "series"
  ],
  "_compare_timestamps_on_attributes": [
    "ts_1",
    "ts_2",
    "required_matches"
  ],
  "_crop_to_match_seasons": [
    "series",
    "required_matches"
  ],
  "FFT": {
    "__init__": [
      "self",
      "nr_freqs_to_keep",
      "required_matches",
      "trend",
      "trend_poly_degree"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_exp_trend": [
      "self",
      "x"
    ],
    "_poly_trend": [
      "self",
      "trend_coefficients"
    ],
    "_null_trend": [
      "self",
      "x"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ]
  },
  "VARIMA": {
    "__init__": [
      "self",
      "p",
      "d",
      "q",
      "trend",
      "add_encoders",
      "random_state"
    ],
    "_differentiate_series": [
      "self",
      "series"
    ],
    "fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "_invert_transformation": [
      "self",
      "series_df"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_supports_range_index": [
      "self"
    ]
  },
  "Prophet": {
    "__init__": [
      "self",
      "add_seasonalities",
      "add_regressor_configs",
      "country_holidays",
      "cap",
      "floor",
      "add_encoders",
      "random_state",
      "suppress_stdout_stderror"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_predict": [
      "self",
      "n",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "_add_capacities_to_df": [
      "self",
      "df"
    ],
    "_generate_predict_df": [
      "self",
      "n",
      "future_covariates"
    ],
    "_check_seasonality_conditions": [
      "self",
      "future_covariates"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_stochastic_samples": [
      "self",
      "predict_df",
      "n_samples"
    ],
    "predict_raw": [
      "self",
      "n",
      "future_covariates",
      "verbose"
    ],
    "add_seasonality": [
      "self",
      "name",
      "seasonal_periods",
      "fourier_order",
      "prior_scale",
      "mode",
      "condition_name"
    ],
    "_store_add_seasonality_call": [
      "self",
      "seasonality_call"
    ],
    "_extract_auto_seasonality": [
      "prophet_kwargs"
    ],
    "_freq_to_days": [
      "freq"
    ],
    "_supports_range_index": [
      "self"
    ]
  },
  "AutoTheta": {
    "__init__": [
      "self"
    ]
  },
  "CustomRNNModule": {
    "__init__": [
      "self",
      "input_size",
      "hidden_dim",
      "num_layers",
      "target_size",
      "nr_params",
      "dropout"
    ],
    "forward": [
      "self",
      "x_in",
      "h"
    ],
    "_produce_train_output": [
      "self",
      "input_batch"
    ],
    "_process_input_batch": [
      "self",
      "input_batch"
    ],
    "_produce_predict_output": [
      "self",
      "x",
      "last_hidden_state"
    ],
    "_get_batch_prediction": [
      "self",
      "n",
      "input_batch",
      "roll_size"
    ]
  },
  "_RNNModule": {
    "__init__": [
      "self",
      "name"
    ],
    "forward": [
      "self",
      "x_in",
      "h"
    ]
  },
  "RNNModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "model",
      "hidden_dim",
      "n_rnn_layers",
      "dropout",
      "training_length"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_build_train_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "max_samples_per_ts",
      "stride"
    ],
    "_verify_train_dataset_type": [
      "self",
      "train_dataset"
    ],
    "min_train_samples": [
      "self"
    ]
  },
  "LinearRegressionModel": {
    "__init__": [
      "self",
      "lags",
      "lags_past_covariates",
      "lags_future_covariates",
      "output_chunk_length",
      "output_chunk_shift",
      "add_encoders",
      "likelihood",
      "quantiles",
      "random_state",
      "multi_models",
      "use_static_covariates"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "max_samples_per_ts",
      "n_jobs_multioutput_wrapper",
      "sample_weight",
      "verbose"
    ]
  },
  "TBATS": {
    "__init__": [
      "self"
    ]
  },
  "ConformalModel": {
    "__init__": [
      "self",
      "model",
      "quantiles",
      "symmetric",
      "cal_length",
      "cal_stride",
      "cal_num_samples",
      "random_state"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "series",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "verbose",
      "predict_likelihood_parameters",
      "show_warnings",
      "random_state"
    ],
    "historical_forecasts": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "random_state"
    ],
    "backtest": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "historical_forecasts",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "metric",
      "reduction",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "metric_kwargs",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "random_state"
    ],
    "residuals": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "historical_forecasts",
      "forecast_horizon",
      "num_samples",
      "train_length",
      "val_length",
      "start",
      "start_format",
      "stride",
      "retrain",
      "apply_globally",
      "overlap_end",
      "last_points_only",
      "metric",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "enable_optimization",
      "data_transformers",
      "metric_kwargs",
      "fit_kwargs",
      "predict_kwargs",
      "sample_weight",
      "values_only",
      "random_state"
    ],
    "_calibrate_forecasts": [
      "self",
      "series",
      "forecasts",
      "num_samples",
      "start",
      "start_format",
      "forecast_horizon",
      "stride",
      "overlap_end",
      "last_points_only",
      "verbose",
      "show_warnings",
      "predict_likelihood_parameters",
      "random_state"
    ],
    "_clean": [
      "self"
    ],
    "save": [
      "self",
      "path",
      "clean"
    ],
    "load": [
      "path",
      "pl_trainer_kwargs"
    ],
    "_calibrate_interval": [
      "self",
      "residuals"
    ],
    "_apply_interval": [
      "self",
      "pred",
      "q_hat"
    ],
    "_residuals_metric": [
      "self"
    ],
    "_historical_forecasts_sanity_checks": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "output_chunk_shift": [
      "self"
    ],
    "_model_encoder_settings": [
      "self"
    ],
    "extreme_lags": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "min_train_samples": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "supports_sample_weight": [
      "self"
    ],
    "supports_likelihood_parameter_prediction": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "uses_past_covariates": [
      "self"
    ],
    "uses_future_covariates": [
      "self"
    ],
    "uses_static_covariates": [
      "self"
    ],
    "considers_static_covariates": [
      "self"
    ],
    "likelihood": [
      "self"
    ]
  },
  "ConformalNaiveModel": {
    "__init__": [
      "self",
      "model",
      "quantiles",
      "symmetric",
      "cal_length",
      "cal_stride",
      "cal_num_samples",
      "random_state"
    ],
    "_calibrate_interval": [
      "self",
      "residuals"
    ],
    "_apply_interval": [
      "self",
      "pred",
      "q_hat"
    ],
    "_residuals_metric": [
      "self"
    ]
  },
  "ConformalQRModel": {
    "__init__": [
      "self",
      "model",
      "quantiles",
      "symmetric",
      "cal_length",
      "cal_stride",
      "cal_num_samples",
      "random_state"
    ],
    "_calibrate_interval": [
      "self",
      "residuals"
    ],
    "_apply_interval": [
      "self",
      "pred",
      "q_hat"
    ],
    "_residuals_metric": [
      "self"
    ]
  },
  "_get_calibration_hfc_start": [
    "series",
    "horizon",
    "output_chunk_shift",
    "cal_length",
    "cal_stride",
    "start",
    "start_format"
  ],
  "ARIMA": {
    "__init__": [
      "self",
      "p",
      "d",
      "q",
      "seasonal_order",
      "trend",
      "random_state",
      "add_encoders"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_fit": [
      "self",
      "series",
      "future_covariates",
      "verbose"
    ],
    "_predict": [
      "self",
      "n",
      "series",
      "historic_future_covariates",
      "future_covariates",
      "num_samples",
      "predict_likelihood_parameters",
      "verbose",
      "random_state"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ]
  },
  "Croston": {
    "__init__": [
      "self",
      "version",
      "alpha_d",
      "alpha_p",
      "add_encoders",
      "quantiles",
      "random_state"
    ]
  },
  "_TFTModule": {
    "__init__": [
      "self",
      "output_dim",
      "variables_meta",
      "num_static_components",
      "hidden_size",
      "lstm_layers",
      "num_attention_heads",
      "full_attention",
      "feed_forward",
      "hidden_continuous_size",
      "categorical_embedding_sizes",
      "dropout",
      "add_relative_index",
      "norm_type",
      "skip_interpolation"
    ],
    "reals": [
      "self"
    ],
    "static_variables": [
      "self"
    ],
    "numeric_static_variables": [
      "self"
    ],
    "categorical_static_variables": [
      "self"
    ],
    "encoder_variables": [
      "self"
    ],
    "decoder_variables": [
      "self"
    ],
    "expand_static_context": [
      "context"
    ],
    "get_relative_index": [
      "encoder_length",
      "decoder_length",
      "batch_size",
      "dtype",
      "device"
    ],
    "get_attention_mask_full": [
      "time_steps",
      "batch_size",
      "dtype",
      "device"
    ],
    "get_attention_mask_future": [
      "encoder_length",
      "decoder_length",
      "batch_size",
      "device",
      "full_attention"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "TFTModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "hidden_size",
      "lstm_layers",
      "num_attention_heads",
      "full_attention",
      "feed_forward",
      "dropout",
      "hidden_continuous_size",
      "categorical_embedding_sizes",
      "add_relative_index",
      "skip_interpolation",
      "loss_fn",
      "likelihood",
      "norm_type",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_build_train_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "max_samples_per_ts",
      "stride"
    ],
    "supports_static_covariates": [
      "self"
    ]
  },
  "NORMS": [],
  "_time_to_feature": [
    "x"
  ],
  "TimeBatchNorm2d": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_FeatureMixing": {
    "__init__": [
      "self",
      "sequence_length",
      "input_dim",
      "output_dim",
      "ff_size",
      "activation",
      "dropout",
      "normalize_before",
      "norm_type"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_TimeMixing": {
    "__init__": [
      "self",
      "sequence_length",
      "input_dim",
      "activation",
      "dropout",
      "normalize_before",
      "norm_type"
    ],
    "forward": [
      "self",
      "x"
    ]
  },
  "_ConditionalMixerLayer": {
    "__init__": [
      "self",
      "sequence_length",
      "input_dim",
      "output_dim",
      "static_cov_dim",
      "ff_size",
      "activation",
      "dropout",
      "normalize_before",
      "norm_type"
    ],
    "forward": [
      "self",
      "x",
      "x_static"
    ]
  },
  "_TSMixerModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "past_cov_dim",
      "future_cov_dim",
      "static_cov_dim",
      "nr_params",
      "hidden_size",
      "ff_size",
      "num_blocks",
      "activation",
      "dropout",
      "norm_type",
      "normalize_before"
    ],
    "_build_mixer": [
      "prediction_length",
      "num_blocks",
      "hidden_size",
      "future_cov_dim",
      "static_cov_dim"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "TSMixerModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "hidden_size",
      "ff_size",
      "num_blocks",
      "activation",
      "dropout",
      "norm_type",
      "normalize_before",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "supports_static_covariates": [
      "self"
    ]
  },
  "AutoTBATS": {
    "__init__": [
      "self"
    ]
  },
  "ExponentialSmoothing": {
    "__init__": [
      "self",
      "trend",
      "damped",
      "seasonal",
      "seasonal_periods",
      "error",
      "random_errors",
      "random_state",
      "kwargs"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "supports_multivariate": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ]
  },
  "AutoETS": {
    "__init__": [
      "self"
    ]
  },
  "_extract_targets": [
    "batch",
    "n_targets"
  ],
  "_repeat_along_output_chunk": [
    "x",
    "ocl"
  ],
  "_GlobalNaiveModule": {
    "__init__": [
      "self"
    ],
    "forward": [
      "self",
      "x_in"
    ],
    "_forward": [
      "self",
      "x_in"
    ]
  },
  "_GlobalNaiveModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "use_static_covariates"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates"
    ],
    "load_from_checkpoint": [
      "model_name",
      "work_dir",
      "file_name",
      "best"
    ],
    "load_weights_from_checkpoint": [
      "self",
      "model_name",
      "work_dir",
      "file_name",
      "best",
      "strict",
      "load_encoders",
      "skip_checks"
    ],
    "_verify_predict_sample": [
      "self",
      "predict_sample"
    ],
    "supports_likelihood_parameter_prediction": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "supports_static_covariates": [
      "self"
    ],
    "_requires_training": [
      "self"
    ],
    "_build_train_dataset": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "max_samples_per_ts",
      "stride"
    ]
  },
  "_NoCovariatesMixin": {
    "supports_static_covariates": [
      "self"
    ],
    "supports_future_covariates": [
      "self"
    ],
    "supports_past_covariates": [
      "self"
    ]
  },
  "_GlobalNaiveAggregateModule": {
    "__init__": [
      "self",
      "agg_fn"
    ],
    "_forward": [
      "self",
      "x_in"
    ]
  },
  "GlobalNaiveAggregate": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "agg_fn"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "_GlobalNaiveSeasonalModule": {
    "_forward": [
      "self",
      "x_in"
    ]
  },
  "GlobalNaiveSeasonal": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "_GlobalNaiveDrift": {
    "_forward": [
      "self",
      "x_in"
    ]
  },
  "GlobalNaiveDrift": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ]
  },
  "RegressionEnsembleModel": {
    "__init__": [
      "self",
      "forecasting_models",
      "regression_train_n_points",
      "regression_model",
      "regression_train_num_samples",
      "regression_train_samples_reduction",
      "train_forecasting_models",
      "train_using_historical_forecasts",
      "show_warnings"
    ],
    "_split_multi_ts_sequence": [
      "self",
      "n",
      "ts_sequence"
    ],
    "_make_multiple_historical_forecasts": [
      "self",
      "train_n_points",
      "series",
      "direct_predictions",
      "past_covariates",
      "future_covariates",
      "num_samples",
      "verbose"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "verbose"
    ],
    "ensemble": [
      "self",
      "predictions",
      "series",
      "num_samples",
      "predict_likelihood_parameters",
      "random_state",
      "verbose"
    ],
    "output_chunk_length": [
      "self"
    ],
    "supports_likelihood_parameter_prediction": [
      "self"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ]
  },
  "NaiveMean": {
    "__init__": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ]
  },
  "NaiveSeasonal": {
    "__init__": [
      "self",
      "K"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ]
  },
  "NaiveDrift": {
    "__init__": [
      "self"
    ],
    "supports_multivariate": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ]
  },
  "NaiveMovingAverage": {
    "__init__": [
      "self",
      "input_chunk_length"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ]
  },
  "NaiveEnsembleModel": {
    "__init__": [
      "self",
      "forecasting_models",
      "train_forecasting_models",
      "show_warnings"
    ],
    "fit": [
      "self",
      "series",
      "past_covariates",
      "future_covariates",
      "sample_weight",
      "verbose"
    ],
    "ensemble": [
      "self",
      "predictions",
      "series",
      "num_samples",
      "predict_likelihood_parameters",
      "random_state",
      "verbose"
    ],
    "_target_average": [
      "self",
      "prediction",
      "series"
    ],
    "_params_average": [
      "self",
      "prediction",
      "series"
    ]
  },
  "_TideModule": {
    "__init__": [
      "self",
      "input_dim",
      "output_dim",
      "future_cov_dim",
      "static_cov_dim",
      "nr_params",
      "num_encoder_layers",
      "num_decoder_layers",
      "decoder_output_dim",
      "hidden_size",
      "temporal_decoder_hidden",
      "temporal_width_past",
      "temporal_width_future",
      "use_layer_norm",
      "dropout",
      "temporal_hidden_size_past",
      "temporal_hidden_size_future"
    ],
    "forward": [
      "self",
      "x_in"
    ]
  },
  "TiDEModel": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "num_encoder_layers",
      "num_decoder_layers",
      "decoder_output_dim",
      "hidden_size",
      "temporal_width_past",
      "temporal_width_future",
      "temporal_hidden_size_past",
      "temporal_hidden_size_future",
      "temporal_decoder_hidden",
      "use_layer_norm",
      "dropout",
      "use_static_covariates"
    ],
    "_create_model": [
      "self",
      "train_sample"
    ],
    "_check_ckpt_parameters": [
      "self",
      "tfm_save"
    ],
    "supports_static_covariates": [
      "self"
    ]
  },
  "ALPHA_START": [],
  "Theta": {
    "__init__": [
      "self",
      "theta",
      "seasonality_period",
      "season_mode"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ]
  },
  "FourTheta": {
    "__init__": [
      "self",
      "theta",
      "seasonality_period",
      "season_mode",
      "model_mode",
      "trend_mode",
      "normalization"
    ],
    "fit": [
      "self",
      "series",
      "verbose"
    ],
    "predict": [
      "self",
      "n",
      "num_samples",
      "verbose",
      "show_warnings",
      "random_state"
    ],
    "select_best_model": [
      "ts",
      "thetas",
      "m",
      "normalization",
      "n_jobs"
    ],
    "supports_multivariate": [
      "self"
    ],
    "_target_window_lengths": [
      "self"
    ]
  },
  "io_processor": [
    "forward"
  ],
  "PLForecastingModule": {
    "__init__": [
      "self",
      "input_chunk_length",
      "output_chunk_length",
      "output_chunk_shift",
      "train_sample_shape",
      "loss_fn",
      "torch_metrics",
      "likelihood",
      "optimizer_cls",
      "optimizer_kwargs",
      "lr_scheduler_cls",
      "lr_scheduler_kwargs",
      "use_reversible_instance_norm"
    ],
    "first_prediction_index": [
      "self"
    ],
    "forward": [
      "self",
      "x_in"
    ],
    "training_step": [
      "self",
      "train_batch",
      "batch_idx"
    ],
    "validation_step": [
      "self",
      "val_batch",
      "batch_idx"
    ],
    "_train_val_step": [
      "self",
      "batch",
      "name",
      "criterion",
      "metrics"
    ],
    "on_fit_end": [
      "self"
    ],
    "on_train_epoch_end": [
      "self"
    ],
    "on_validation_epoch_end": [
      "self"
    ],
    "on_predict_start": [
      "self"
    ],
    "on_predict_end": [
      "self"
    ],
    "predict_step": [
      "self",
      "batch",
      "batch_idx",
      "dataloader_idx"
    ],
    "set_predict_parameters": [
      "self",
      "n",
      "num_samples",
      "roll_size",
      "batch_size",
      "predict_likelihood_parameters",
      "mc_dropout"
    ],
    "_compute_loss": [
      "self",
      "output",
      "target",
      "criterion",
      "sample_weight"
    ],
    "_update_metrics": [
      "self",
      "output",
      "target",
      "metrics"
    ],
    "_compute_metrics": [
      "self",
      "metrics"
    ],
    "configure_optimizers": [
      "self"
    ],
    "_produce_train_output": [
      "self",
      "input_batch"
    ],
    "_process_input_batch": [
      "self",
      "input_batch"
    ],
    "_get_batch_prediction": [
      "self",
      "n",
      "input_batch",
      "roll_size"
    ],
    "_sample_tiling": [
      "input_data_tuple",
      "batch_sample_size"
    ],
    "_get_mc_dropout_modules": [
      "self"
    ],
    "set_mc_dropout": [
      "self",
      "active"
    ],
    "supports_probabilistic_prediction": [
      "self"
    ],
    "_produce_predict_output": [
      "self",
      "x"
    ],
    "on_save_checkpoint": [
      "self",
      "checkpoint"
    ],
    "on_load_checkpoint": [
      "self",
      "checkpoint"
    ],
    "to_dtype": [
      "self",
      "dtype"
    ],
    "epochs_trained": [
      "self"
    ],
    "output_chunk_length": [
      "self"
    ],
    "configure_torch_metrics": [
      "torch_metrics"
    ]
  }
}