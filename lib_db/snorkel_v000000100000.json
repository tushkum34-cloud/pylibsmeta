{
  "_MAJOR": [],
  "_MINOR": [],
  "_REVISION": [],
  "VERSION_SHORT": [],
  "VERSION": [],
  "MapFunction": [],
  "get_parameters": [
    "f",
    "allow_args",
    "allow_kwargs"
  ],
  "is_hashable": [
    "obj"
  ],
  "get_hashable": [
    "obj"
  ],
  "BaseMapper": {
    "__init__": [
      "self",
      "name",
      "pre",
      "memoize",
      "memoize_key"
    ],
    "reset_cache": [
      "self"
    ],
    "_generate_mapped_data_point": [
      "self",
      "x"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Mapper": {
    "__init__": [
      "self",
      "name",
      "field_names",
      "mapped_field_names",
      "pre",
      "memoize",
      "memoize_key"
    ],
    "run": [
      "self"
    ],
    "_update_fields": [
      "self",
      "x",
      "mapped_fields"
    ],
    "_generate_mapped_data_point": [
      "self",
      "x"
    ]
  },
  "LambdaMapper": {
    "__init__": [
      "self",
      "name",
      "f",
      "pre",
      "memoize",
      "memoize_key"
    ],
    "_generate_mapped_data_point": [
      "self",
      "x"
    ]
  },
  "lambda_mapper": {
    "__init__": [
      "self",
      "name",
      "pre",
      "memoize",
      "memoize_key"
    ],
    "__call__": [
      "self",
      "f"
    ]
  },
  "_update_fields": [
    "x",
    "mapped_fields"
  ],
  "make_spark_mapper": [
    "mapper"
  ],
  "BaseTransformationFunction": [],
  "TransformationFunction": {},
  "LambdaTransformationFunction": {},
  "transformation_function": {},
  "BaseTFApplier": {
    "__init__": [
      "self",
      "tfs",
      "policy"
    ],
    "_apply_policy_to_data_point": [
      "self",
      "x"
    ],
    "__repr__": [
      "self"
    ]
  },
  "TFApplier": {
    "apply_generator": [
      "self",
      "data_points",
      "batch_size"
    ],
    "apply": [
      "self",
      "data_points",
      "progress_bar"
    ]
  },
  "PandasTFApplier": {
    "apply_generator": [
      "self",
      "df",
      "batch_size"
    ],
    "apply": [
      "self",
      "df",
      "progress_bar"
    ]
  },
  "Policy": {
    "__init__": [
      "self",
      "n_tfs",
      "n_per_original",
      "keep_original"
    ],
    "generate_for_example": [
      "self"
    ],
    "generate": [
      "self"
    ]
  },
  "ApplyAllPolicy": {
    "generate": [
      "self"
    ]
  },
  "ApplyOnePolicy": {
    "__init__": [
      "self",
      "n_per_original",
      "keep_original"
    ]
  },
  "ApplyEachPolicy": {
    "__init__": [
      "self",
      "n_tfs",
      "keep_original"
    ],
    "generate_for_example": [
      "self"
    ]
  },
  "MeanFieldPolicy": {
    "__init__": [
      "self",
      "n_tfs",
      "sequence_length",
      "p",
      "n_per_original",
      "keep_original"
    ],
    "generate": [
      "self"
    ]
  },
  "RandomPolicy": {
    "__init__": [
      "self",
      "n_tfs",
      "sequence_length",
      "n_per_original",
      "keep_original"
    ]
  },
  "BasePreprocessor": [],
  "Preprocessor": {},
  "LambdaPreprocessor": {},
  "preprocessor": {},
  "EN_CORE_WEB_SM": [],
  "SpacyPreprocessor": {
    "__init__": [
      "self",
      "text_field",
      "doc_field",
      "language",
      "disable",
      "pre",
      "memoize",
      "memoize_key",
      "gpu"
    ],
    "run": [
      "self",
      "text"
    ]
  },
  "merge_config": [
    "config",
    "config_updates"
  ],
  "_hash": [
    "i"
  ],
  "probs_to_preds": [
    "probs",
    "tie_break_policy",
    "tol"
  ],
  "preds_to_probs": [
    "preds",
    "num_classes"
  ],
  "to_int_label_array": [
    "X",
    "flatten_vector"
  ],
  "filter_labels": [
    "label_dict",
    "filter_dict"
  ],
  "_get_mask": [
    "label_array",
    "filter_values"
  ],
  "SGDOptimizerConfig": {},
  "AdamOptimizerConfig": {},
  "AdamaxOptimizerConfig": {},
  "OptimizerConfig": {},
  "ExponentialLRSchedulerConfig": {},
  "StepLRSchedulerConfig": {},
  "LRSchedulerConfig": {},
  "check_unique_names": [
    "names"
  ],
  "slice_dataframe": [
    "df",
    "slicing_function"
  ],
  "add_slice_labels": [
    "dataloader",
    "base_task",
    "S"
  ],
  "convert_to_slice_tasks": [
    "base_task",
    "slice_names"
  ],
  "SliceAwareClassifier": {
    "__init__": [
      "self",
      "base_architecture",
      "head_dim",
      "slice_names",
      "input_data_key",
      "task_name",
      "scorer"
    ],
    "make_slice_dataloader": [
      "self",
      "dataset",
      "S"
    ],
    "score_slices": [
      "self",
      "dataloaders",
      "as_dataframe"
    ]
  },
  "SlicingFunction": {},
  "slicing_function": {
    "__init__": [
      "self",
      "name",
      "resources",
      "pre"
    ],
    "__call__": [
      "self",
      "f"
    ]
  },
  "NLPSlicingFunction": {
    "_create_preprocessor": [
      "cls",
      "parameters"
    ]
  },
  "nlp_slicing_function": {
    "_lf_cls": []
  },
  "SFApplier": {
    "_use_recarray": []
  },
  "PandasSFApplier": {
    "_use_recarray": []
  },
  "DaskSFApplier": {
    "_use_recarray": []
  },
  "PandasParallelSFApplier": {
    "_use_recarray": []
  },
  "SliceCombinerModule": {
    "__init__": [
      "self",
      "slice_ind_key",
      "slice_pred_key",
      "slice_pred_feat_key",
      "temperature"
    ],
    "forward": [
      "self",
      "output_dict"
    ]
  },
  "Outputs": [],
  "cross_entropy_with_probs": [
    "input",
    "target",
    "weight",
    "reduction"
  ],
  "Operation": {
    "__init__": [
      "self",
      "module_name",
      "inputs",
      "name"
    ],
    "__repr__": [
      "self"
    ]
  },
  "Task": {
    "__init__": [
      "self",
      "name",
      "module_pool",
      "op_sequence",
      "scorer",
      "loss_func",
      "output_func"
    ],
    "__repr__": [
      "self"
    ]
  },
  "TensorCollection": [],
  "list_to_tensor": [
    "item_list"
  ],
  "pad_batch": [
    "batch",
    "max_len",
    "pad_value",
    "left_padded"
  ],
  "move_to_device": [
    "obj",
    "device"
  ],
  "collect_flow_outputs_by_suffix": [
    "output_dict",
    "suffix"
  ],
  "metrics_dict_to_dataframe": [
    "metrics_dict"
  ],
  "OutputDict": [],
  "ClassifierConfig": {},
  "MultitaskClassifier": {
    "__init__": [
      "self",
      "tasks",
      "name"
    ],
    "__repr__": [
      "self"
    ],
    "_build_network": [
      "self",
      "tasks"
    ],
    "add_task": [
      "self",
      "task"
    ],
    "forward": [
      "self",
      "X_dict",
      "task_names"
    ],
    "calculate_loss": [
      "self",
      "X_dict",
      "Y_dict"
    ],
    "_calculate_probs": [
      "self",
      "X_dict",
      "task_names"
    ],
    "predict": [
      "self",
      "dataloader",
      "return_preds",
      "remap_labels"
    ],
    "score": [
      "self",
      "dataloaders",
      "remap_labels",
      "as_dataframe"
    ],
    "_get_labels_to_tasks": [
      "self",
      "label_names",
      "remap_labels"
    ],
    "_move_to_device": [
      "self"
    ],
    "save": [
      "self",
      "model_path"
    ],
    "load": [
      "self",
      "model_path"
    ]
  },
  "XDict": [],
  "YDict": [],
  "Batch": [],
  "DEFAULT_INPUT_DATA_KEY": [],
  "DEFAULT_DATASET_NAME": [],
  "DEFAULT_TASK_NAME": [],
  "DictDataset": {
    "__init__": [
      "self",
      "name",
      "split",
      "X_dict",
      "Y_dict"
    ],
    "__getitem__": [
      "self",
      "index"
    ],
    "__len__": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "from_tensors": [
      "cls",
      "X_tensor",
      "Y_tensor",
      "split",
      "input_data_key",
      "task_name",
      "dataset_name"
    ]
  },
  "collate_dicts": [
    "batch"
  ],
  "DictDataLoader": {
    "__init__": [
      "self",
      "dataset",
      "collate_fn"
    ]
  },
  "Metrics": [],
  "TrainerConfig": {},
  "Trainer": {
    "__init__": [
      "self",
      "name"
    ],
    "fit": [
      "self",
      "model",
      "dataloaders"
    ],
    "_check_dataloaders": [
      "self",
      "dataloaders"
    ],
    "_set_log_writer": [
      "self"
    ],
    "_set_checkpointer": [
      "self"
    ],
    "_set_log_manager": [
      "self"
    ],
    "_set_optimizer": [
      "self",
      "model"
    ],
    "_set_lr_scheduler": [
      "self"
    ],
    "_set_warmup_scheduler": [
      "self"
    ],
    "_update_lr_scheduler": [
      "self",
      "step"
    ],
    "_set_batch_scheduler": [
      "self"
    ],
    "_evaluate": [
      "self",
      "model",
      "dataloaders",
      "split"
    ],
    "_logging": [
      "self",
      "model",
      "dataloaders",
      "batch_size"
    ],
    "_log_metrics": [
      "self",
      "metric_dict"
    ],
    "_checkpoint_model": [
      "self",
      "model",
      "metric_dict"
    ],
    "_aggregate_losses": [
      "self"
    ],
    "_reset_losses": [
      "self"
    ],
    "save": [
      "self",
      "trainer_path"
    ],
    "load": [
      "self",
      "trainer_path",
      "model"
    ]
  },
  "BatchIterator": [],
  "Scheduler": {
    "__init__": [
      "self"
    ],
    "get_batches": [
      "self",
      "dataloaders"
    ]
  },
  "SequentialScheduler": {
    "__init__": [
      "self"
    ],
    "get_batches": [
      "self",
      "dataloaders"
    ]
  },
  "batch_schedulers": [],
  "ShuffledScheduler": {
    "__init__": [
      "self"
    ],
    "get_batches": [
      "self",
      "dataloaders"
    ]
  },
  "CheckpointerConfig": {},
  "Checkpointer": {
    "__init__": [
      "self",
      "counter_unit",
      "evaluation_freq"
    ],
    "checkpoint": [
      "self",
      "iteration",
      "model",
      "metric_dict"
    ],
    "_is_new_best": [
      "self",
      "metric_dict"
    ],
    "clear": [
      "self"
    ],
    "load_best_model": [
      "self",
      "model"
    ],
    "_validate_config": [
      "self"
    ],
    "_make_metric_map": [
      "self",
      "metric_mode_iter"
    ]
  },
  "LogWriterConfig": {},
  "LogWriter": {
    "__init__": [
      "self"
    ],
    "add_scalar": [
      "self",
      "name",
      "value",
      "step"
    ],
    "write_config": [
      "self",
      "config",
      "config_filename"
    ],
    "write_log": [
      "self",
      "log_filename"
    ],
    "write_text": [
      "self",
      "text",
      "filename"
    ],
    "write_json": [
      "self",
      "dict_to_write",
      "filename"
    ],
    "cleanup": [
      "self"
    ]
  },
  "LogManagerConfig": {},
  "LogManager": {
    "__init__": [
      "self",
      "n_batches_per_epoch",
      "log_writer",
      "checkpointer"
    ],
    "update": [
      "self",
      "batch_size"
    ],
    "trigger_evaluation": [
      "self"
    ],
    "trigger_checkpointing": [
      "self"
    ],
    "reset": [
      "self"
    ],
    "cleanup": [
      "self",
      "model"
    ]
  },
  "TensorBoardWriter": {
    "__init__": [
      "self"
    ],
    "add_scalar": [
      "self",
      "name",
      "value",
      "step"
    ],
    "write_config": [
      "self",
      "config",
      "config_filename"
    ],
    "cleanup": [
      "self"
    ]
  },
  "LFAnalysis": {
    "__init__": [
      "self",
      "L",
      "lfs"
    ],
    "_covered_data_points": [
      "self"
    ],
    "_overlapped_data_points": [
      "self"
    ],
    "_conflicted_data_points": [
      "self"
    ],
    "label_coverage": [
      "self"
    ],
    "label_overlap": [
      "self"
    ],
    "label_conflict": [
      "self"
    ],
    "lf_polarities": [
      "self"
    ],
    "lf_coverages": [
      "self"
    ],
    "lf_overlaps": [
      "self",
      "normalize_by_coverage"
    ],
    "lf_conflicts": [
      "self",
      "normalize_by_overlaps"
    ],
    "lf_empirical_accuracies": [
      "self",
      "Y"
    ],
    "lf_empirical_probs": [
      "self",
      "Y",
      "k"
    ],
    "lf_summary": [
      "self",
      "Y",
      "est_weights"
    ]
  },
  "filter_unlabeled_dataframe": [
    "X",
    "y",
    "L"
  ],
  "RowData": [],
  "ApplierMetadata": {},
  "_FunctionCaller": {
    "__init__": [
      "self",
      "fault_tolerant"
    ],
    "__call__": [
      "self",
      "f",
      "x"
    ]
  },
  "BaseLFApplier": {
    "_use_recarray": [],
    "__init__": [
      "self",
      "lfs"
    ],
    "_numpy_from_row_data": [
      "self",
      "labels"
    ],
    "__repr__": [
      "self"
    ]
  },
  "apply_lfs_to_data_point": [
    "x",
    "index",
    "lfs",
    "f_caller"
  ],
  "LFApplier": {
    "apply": [
      "self",
      "data_points",
      "progress_bar",
      "fault_tolerant",
      "return_meta"
    ]
  },
  "DaskLFApplier": {
    "apply": [
      "self",
      "df",
      "scheduler",
      "fault_tolerant"
    ]
  },
  "PandasParallelLFApplier": {
    "apply": [
      "self",
      "df",
      "n_parallel",
      "scheduler",
      "fault_tolerant"
    ]
  },
  "SparkLFApplier": {
    "apply": [
      "self",
      "data_points",
      "fault_tolerant"
    ]
  },
  "PandasRowData": [],
  "rows_to_triplets": [
    "labels"
  ],
  "PandasLFApplier": {
    "apply": [
      "self",
      "df",
      "progress_bar",
      "fault_tolerant",
      "return_meta"
    ]
  },
  "LabelingFunction": {
    "__init__": [
      "self",
      "name",
      "f",
      "resources",
      "pre"
    ],
    "_preprocess_data_point": [
      "self",
      "x"
    ],
    "__call__": [
      "self",
      "x"
    ],
    "__repr__": [
      "self"
    ]
  },
  "labeling_function": {
    "__init__": [
      "self",
      "name",
      "resources",
      "pre"
    ],
    "__call__": [
      "self",
      "f"
    ]
  },
  "SpacyPreprocessorParameters": {},
  "SpacyPreprocessorConfig": {},
  "BaseNLPLabelingFunction": {
    "_create_preprocessor": [
      "cls",
      "parameters"
    ],
    "_create_or_check_preprocessor": [
      "cls",
      "text_field",
      "doc_field",
      "language",
      "disable",
      "pre",
      "memoize",
      "memoize_key",
      "gpu"
    ],
    "__init__": [
      "self",
      "name",
      "f",
      "resources",
      "pre",
      "text_field",
      "doc_field",
      "language",
      "disable",
      "memoize",
      "memoize_key",
      "gpu"
    ]
  },
  "NLPLabelingFunction": {
    "_create_preprocessor": [
      "cls",
      "parameters"
    ]
  },
  "base_nlp_labeling_function": {
    "__init__": [
      "self",
      "name",
      "resources",
      "pre",
      "text_field",
      "doc_field",
      "language",
      "disable",
      "memoize",
      "memoize_key",
      "gpu"
    ],
    "__call__": [
      "self",
      "f"
    ]
  },
  "nlp_labeling_function": {
    "_lf_cls": []
  },
  "SparkNLPLabelingFunction": {
    "_create_preprocessor": [
      "cls",
      "parameters"
    ]
  },
  "spark_nlp_labeling_function": {
    "_lf_cls": []
  },
  "Logger": {
    "__init__": [
      "self",
      "log_freq"
    ],
    "check": [
      "self"
    ],
    "log": [
      "self",
      "metrics_dict"
    ]
  },
  "BaseLabeler": {
    "__init__": [
      "self",
      "cardinality"
    ],
    "predict_proba": [
      "self",
      "L"
    ],
    "predict": [
      "self",
      "L",
      "return_probs",
      "tie_break_policy"
    ],
    "score": [
      "self",
      "L",
      "Y",
      "metrics",
      "tie_break_policy"
    ],
    "save": [
      "self",
      "destination"
    ],
    "load": [
      "self",
      "source"
    ]
  },
  "get_clique_tree": [
    "nodes",
    "edges"
  ],
  "TrainConfig": {},
  "LabelModelConfig": {},
  "_CliqueData": {},
  "LabelModel": {
    "__init__": [
      "self",
      "cardinality"
    ],
    "_create_L_ind": [
      "self",
      "L"
    ],
    "_get_augmented_label_matrix": [
      "self",
      "L",
      "higher_order"
    ],
    "_build_mask": [
      "self"
    ],
    "_generate_O": [
      "self",
      "L",
      "higher_order"
    ],
    "_init_params": [
      "self"
    ],
    "_get_conditional_probs": [
      "self",
      "mu"
    ],
    "get_conditional_probs": [
      "self"
    ],
    "get_weights": [
      "self"
    ],
    "predict_proba": [
      "self",
      "L"
    ],
    "predict": [
      "self",
      "L",
      "return_probs",
      "tie_break_policy"
    ],
    "score": [
      "self",
      "L",
      "Y",
      "metrics",
      "tie_break_policy"
    ],
    "_loss_l2": [
      "self",
      "l2"
    ],
    "_loss_mu": [
      "self",
      "l2"
    ],
    "_set_class_balance": [
      "self",
      "class_balance",
      "Y_dev"
    ],
    "_set_constants": [
      "self",
      "L"
    ],
    "_create_tree": [
      "self"
    ],
    "_execute_logging": [
      "self",
      "loss"
    ],
    "_set_logger": [
      "self"
    ],
    "_set_optimizer": [
      "self"
    ],
    "_set_lr_scheduler": [
      "self"
    ],
    "_set_warmup_scheduler": [
      "self"
    ],
    "_update_lr_scheduler": [
      "self",
      "step"
    ],
    "_clamp_params": [
      "self"
    ],
    "_break_col_permutation_symmetry": [
      "self"
    ],
    "fit": [
      "self",
      "L_train",
      "Y_dev",
      "class_balance",
      "progress_bar"
    ]
  },
  "RandomVoter": {
    "predict_proba": [
      "self",
      "L"
    ]
  },
  "MajorityClassVoter": {
    "fit": [
      "self",
      "balance"
    ],
    "predict_proba": [
      "self",
      "L"
    ]
  },
  "MajorityLabelVoter": {
    "predict_proba": [
      "self",
      "L"
    ]
  },
  "Config": [],
  "HashingFunction": [],
  "DataPoint": [],
  "DataPoints": [],
  "Field": [],
  "FieldMap": [],
  "get_label_buckets": [],
  "get_label_instances": [
    "bucket",
    "x"
  ],
  "Metric": {},
  "metric_score": [
    "golds",
    "preds",
    "probs",
    "metric",
    "filter_dict"
  ],
  "_coverage_score": [
    "preds"
  ],
  "_roc_auc_score": [
    "golds",
    "probs"
  ],
  "_f1_score": [
    "golds",
    "preds"
  ],
  "_f1_micro_score": [
    "golds",
    "preds"
  ],
  "_f1_macro_score": [
    "golds",
    "preds"
  ],
  "METRICS": [],
  "Scorer": {
    "__init__": [
      "self",
      "metrics",
      "custom_metric_funcs",
      "abstain_label"
    ],
    "score": [
      "self",
      "golds",
      "preds",
      "probs"
    ],
    "score_slices": [
      "self",
      "S",
      "golds",
      "preds",
      "probs",
      "as_dataframe"
    ]
  },
  "generate_simple_label_matrix": [
    "n",
    "m",
    "cardinality",
    "abstain_multiplier"
  ]
}