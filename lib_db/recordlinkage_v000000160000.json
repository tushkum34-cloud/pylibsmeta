{
  "__all__": [],
  "SKLearnAdapter": {
    "classifier": [
      "self",
      "classifier"
    ],
    "_predict": [
      "self",
      "features"
    ],
    "_fit": [
      "self",
      "features",
      "y"
    ],
    "_prob_match": [
      "self",
      "features"
    ]
  },
  "KerasAdapter": {
    "classifier": [
      "self",
      "classifier"
    ],
    "_predict": [
      "self",
      "features"
    ],
    "_fit": [
      "self",
      "features",
      "y"
    ],
    "_prob_match": [
      "self",
      "features"
    ]
  },
  "Full": {
    "__init__": [
      "self"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ],
    "_dedup_index": [
      "self",
      "df_a"
    ]
  },
  "Block": {
    "__init__": [
      "self",
      "left_on",
      "right_on"
    ],
    "__repr__": [
      "self"
    ],
    "_get_left_and_right_on": [
      "self"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ]
  },
  "SortedNeighbourhood": {
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "window",
      "sorting_key_values",
      "block_on",
      "block_left_on",
      "block_right_on"
    ],
    "__repr__": [
      "self"
    ],
    "_get_left_and_right_on": [
      "self"
    ],
    "_get_sorting_key_values": [
      "self",
      "array1",
      "array2"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ]
  },
  "Random": {
    "__init__": [
      "self",
      "n",
      "replace",
      "random_state"
    ],
    "__repr__": [
      "self"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ],
    "_dedup_index": [
      "self",
      "df_a"
    ]
  },
  "_parallel_compare_helper": [
    "class_obj",
    "pairs",
    "x",
    "x_link"
  ],
  "chunk_pandas": [
    "frame_or_series",
    "chunksize"
  ],
  "BaseIndex": {
    "__init__": [
      "self",
      "algorithms"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "add": [
      "self",
      "model"
    ],
    "index": [
      "self",
      "x",
      "x_link"
    ]
  },
  "BaseIndexAlgorithm": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "verify_integrity",
      "suffixes"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_deduplication": [
      "self",
      "x"
    ],
    "_verify_integrety": [
      "self",
      "x"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ],
    "_dedup_index": [
      "self",
      "df_a"
    ],
    "_make_index_names": [
      "self",
      "name1",
      "name2"
    ],
    "fit": [
      "self"
    ],
    "index": [
      "self",
      "x",
      "x_link"
    ]
  },
  "BaseIndexator": [],
  "BaseCompareFeature": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "labels_left",
      "labels_right",
      "args",
      "kwargs",
      "label"
    ],
    "_repr": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "_compute_vectorized": [
      "self"
    ],
    "_compute": [
      "self",
      "left_on",
      "right_on"
    ],
    "compute": [
      "self",
      "pairs",
      "x",
      "x_link"
    ]
  },
  "BaseCompare": {
    "__init__": [
      "self",
      "features",
      "n_jobs",
      "indexing_type"
    ],
    "__repr__": [
      "self"
    ],
    "__str__": [
      "self"
    ],
    "add": [
      "self",
      "model"
    ],
    "compare_vectorized": [
      "self",
      "comp_func",
      "labels_left",
      "labels_right"
    ],
    "_get_labels_left": [
      "self",
      "validate"
    ],
    "_get_labels_right": [
      "self",
      "validate"
    ],
    "_compute_parallel": [
      "self",
      "pairs",
      "x",
      "x_link",
      "n_jobs"
    ],
    "_compute": [
      "self",
      "pairs",
      "x",
      "x_link"
    ],
    "_union": [
      "self",
      "objs",
      "index",
      "column_i"
    ],
    "compute": [
      "self",
      "pairs",
      "x",
      "x_link"
    ],
    "compare": [
      "self"
    ],
    "clear_memory": [
      "self"
    ]
  },
  "BaseClassifier": {
    "learn": [
      "self"
    ],
    "_initialise_classifier": [
      "self",
      "comparison_vectors"
    ],
    "_fit": [
      "self"
    ],
    "fit": [
      "self",
      "comparison_vectors",
      "match_index"
    ],
    "fit_predict": [
      "self",
      "comparison_vectors",
      "match_index"
    ],
    "_predict": [
      "self",
      "comparison_vectors"
    ],
    "predict": [
      "self",
      "comparison_vectors"
    ],
    "_post_predict": [
      "self",
      "result"
    ],
    "_prob_match": [
      "self"
    ],
    "prob": [
      "self",
      "comparison_vectors",
      "return_type"
    ],
    "_return_result": [
      "self",
      "result",
      "comparison_vectors"
    ]
  },
  "OneToOneLinking": {
    "__init__": [
      "self",
      "method"
    ],
    "_bool_duplicated": [
      "cls",
      "links",
      "level"
    ],
    "_compute_greedy": [
      "self",
      "links"
    ],
    "_compute": [
      "self",
      "links"
    ],
    "compute": [
      "self",
      "links"
    ]
  },
  "OneToManyLinking": {
    "__init__": [
      "self",
      "level",
      "method"
    ],
    "_compute_greedy": [
      "self",
      "links"
    ],
    "compute": [
      "self",
      "links"
    ]
  },
  "ConnectedComponents": {
    "__init__": [
      "self"
    ],
    "compute": [
      "self",
      "links"
    ]
  },
  "FellegiSunter": {
    "__init__": [
      "self",
      "use_col_names"
    ],
    "_decision_rule": [
      "self",
      "probabilities",
      "threshold"
    ],
    "_match_class_pos": [
      "self"
    ],
    "_nonmatch_class_pos": [
      "self"
    ],
    "log_p": [
      "self"
    ],
    "_prob_inverse_transform": [
      "self",
      "prob"
    ],
    "log_m_probs": [
      "self"
    ],
    "log_u_probs": [
      "self"
    ],
    "log_weights": [
      "self"
    ],
    "p": [
      "self"
    ],
    "m_probs": [
      "self"
    ],
    "u_probs": [
      "self"
    ],
    "weights": [
      "self"
    ]
  },
  "KMeansClassifier": {
    "__init__": [
      "self",
      "match_cluster_center",
      "nonmatch_cluster_center"
    ],
    "_initialise_classifier": [
      "self",
      "comparison_vectors"
    ],
    "match_cluster_center": [
      "self",
      "value"
    ],
    "nonmatch_cluster_center": [
      "self",
      "value"
    ],
    "prob": [
      "self"
    ]
  },
  "LogisticRegressionClassifier": {
    "__init__": [
      "self",
      "coefficients",
      "intercept"
    ],
    "params": [
      "self",
      "value"
    ],
    "coefficients": [
      "self",
      "value"
    ],
    "intercept": [
      "self",
      "value"
    ],
    "_predict": [
      "self",
      "features"
    ]
  },
  "NaiveBayesClassifier": {
    "__init__": [
      "self",
      "binarize",
      "alpha",
      "use_col_names"
    ],
    "fit": [
      "self",
      "X"
    ]
  },
  "SVMClassifier": {
    "__init__": [
      "self"
    ],
    "prob": [
      "self"
    ]
  },
  "ECMClassifier": {
    "__init__": [
      "self",
      "init",
      "binarize",
      "max_iter",
      "atol",
      "use_col_names"
    ],
    "fit": [
      "self",
      "X"
    ],
    "algorithm": [
      "self"
    ]
  },
  "pairs_type_doc": [],
  "classification_return_type_doc": [],
  "Exact": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "agree_value",
      "disagree_value",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "s_left",
      "s_right"
    ]
  },
  "String": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "method",
      "threshold",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "s_left",
      "s_right"
    ]
  },
  "Numeric": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "method",
      "offset",
      "scale",
      "origin",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "s_left",
      "s_right"
    ]
  },
  "Geographic": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on_lat",
      "left_on_lng",
      "right_on_lat",
      "right_on_lng",
      "method",
      "offset",
      "scale",
      "origin",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "lat1",
      "lng1",
      "lat2",
      "lng2"
    ]
  },
  "Date": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "swap_month_day",
      "swap_months",
      "errors",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "s_left",
      "s_right"
    ]
  },
  "Variable": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "missing_value",
      "label"
    ],
    "_compute_vectorized": [
      "self"
    ]
  },
  "VariableA": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "on",
      "missing_value",
      "label"
    ]
  },
  "VariableB": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "on",
      "missing_value",
      "label"
    ]
  },
  "Frequency": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "normalise",
      "missing_value",
      "label"
    ],
    "_compute_frequency": [
      "self",
      "col"
    ],
    "_compute_vectorized": [
      "self"
    ]
  },
  "FrequencyA": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "on",
      "normalise",
      "missing_value",
      "label"
    ]
  },
  "FrequencyB": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "on",
      "normalise",
      "missing_value",
      "label"
    ]
  },
  "_get_multiindex": [
    "x"
  ],
  "_isconfusionmatrix": [
    "x"
  ],
  "reduction_ratio": [
    "links_pred"
  ],
  "max_pairs": [
    "shape"
  ],
  "full_index_size": [],
  "true_positives": [
    "links_true",
    "links_pred"
  ],
  "true_negatives": [
    "links_true",
    "links_pred",
    "total"
  ],
  "false_positives": [
    "links_true",
    "links_pred"
  ],
  "false_negatives": [
    "links_true",
    "links_pred"
  ],
  "confusion_matrix": [
    "links_true",
    "links_pred",
    "total"
  ],
  "precision": [
    "links_true",
    "links_pred"
  ],
  "recall": [
    "links_true",
    "links_pred"
  ],
  "accuracy": [
    "links_true",
    "links_pred",
    "total"
  ],
  "specificity": [
    "links_true",
    "links_pred",
    "total"
  ],
  "fscore": [
    "links_true",
    "links_pred"
  ],
  "IndexError": {},
  "LearningError": {},
  "DeprecationHelper": {
    "__init__": [
      "self",
      "new_target",
      "msg"
    ],
    "_warn": [
      "self"
    ],
    "__call__": [
      "self"
    ],
    "__getattr__": [
      "self",
      "attr"
    ]
  },
  "return_type_deprecator": [
    "func"
  ],
  "is_label_dataframe": [
    "label",
    "df"
  ],
  "get_length": [
    "x"
  ],
  "listify": [
    "x",
    "none_value"
  ],
  "unique": [
    "x"
  ],
  "merge_dicts": [],
  "multi_index_to_frame": [
    "index"
  ],
  "index_split": [
    "index",
    "chunks"
  ],
  "split_index": [],
  "frame_indexing": [
    "frame",
    "multi_index",
    "level_i",
    "indexing_type"
  ],
  "fillna": [
    "series_or_arr",
    "missing_value"
  ],
  "Index": {
    "full": [
      "self"
    ],
    "block": [
      "self"
    ],
    "sortedneighbourhood": [
      "self"
    ],
    "random": [
      "self"
    ]
  },
  "Compare": {
    "exact": [
      "self"
    ],
    "string": [
      "self"
    ],
    "numeric": [
      "self"
    ],
    "geo": [
      "self"
    ],
    "date": [
      "self"
    ]
  },
  "DeprecatedOption": [],
  "RegisteredOption": [],
  "_deprecated_options": [],
  "_registered_options": [],
  "_global_config": [],
  "_reserved_keys": [],
  "OptionError": {},
  "_get_single_key": [
    "pat",
    "silent"
  ],
  "_get_option": [
    "pat",
    "silent"
  ],
  "_set_option": [],
  "_describe_option": [
    "pat",
    "_print_desc"
  ],
  "_reset_option": [
    "pat",
    "silent"
  ],
  "get_default_val": [
    "pat"
  ],
  "DictWrapper": {
    "__init__": [
      "self",
      "d",
      "prefix"
    ],
    "__setattr__": [
      "self",
      "key",
      "val"
    ],
    "__getattr__": [
      "self",
      "key"
    ],
    "__dir__": [
      "self"
    ]
  },
  "CallableDynamicDoc": {
    "__init__": [
      "self",
      "func",
      "doc_tmpl"
    ],
    "__call__": [
      "self"
    ],
    "__doc__": [
      "self"
    ]
  },
  "_get_option_tmpl": [],
  "_set_option_tmpl": [],
  "_describe_option_tmpl": [],
  "_reset_option_tmpl": [],
  "get_option": [],
  "set_option": [],
  "reset_option": [],
  "describe_option": [],
  "options": [],
  "option_context": {
    "__init__": [
      "self"
    ],
    "__enter__": [
      "self"
    ],
    "__exit__": [
      "self"
    ]
  },
  "register_option": [
    "key",
    "defval",
    "doc",
    "validator",
    "cb"
  ],
  "deprecate_option": [
    "key",
    "msg",
    "rkey",
    "removal_ver"
  ],
  "_select_options": [
    "pat"
  ],
  "_get_root": [
    "key"
  ],
  "_is_deprecated": [
    "key"
  ],
  "_get_deprecated_option": [
    "key"
  ],
  "_get_registered_option": [
    "key"
  ],
  "_translate_key": [
    "key"
  ],
  "_warn_if_deprecated": [
    "key"
  ],
  "_build_option_description": [
    "k"
  ],
  "pp_options_list": [
    "keys",
    "width",
    "_print"
  ],
  "config_prefix": [
    "prefix"
  ],
  "is_type_factory": [
    "_type"
  ],
  "is_instance_factory": [
    "_type"
  ],
  "is_one_of_factory": [
    "legal_values"
  ],
  "is_int": [],
  "is_bool": [],
  "is_float": [],
  "is_str": [],
  "is_unicode": [],
  "is_text": [],
  "is_callable": [
    "obj"
  ],
  "SCHEMA_VERSION_LATEST": [],
  "write_annotation_file": [
    "fp",
    "pairs",
    "df_a",
    "df_b",
    "dataset_a_name",
    "dataset_b_name"
  ],
  "read_annotation_file": [
    "fp"
  ],
  "AnnotationWrapper": {
    "__init__": [
      "self",
      "pairs",
      "df_a",
      "df_b",
      "dataset_a_name",
      "dataset_b_name"
    ],
    "_get_value": [
      "self",
      "df",
      "loc_x",
      "loc_y"
    ],
    "_cast_value": [
      "value",
      "na_value"
    ],
    "_create_annotation": [
      "self"
    ],
    "to_file": [
      "self",
      "fp"
    ]
  },
  "AnnotationResult": {
    "__init__": [
      "self",
      "pairs",
      "version"
    ],
    "_get_annotation_value": [
      "self",
      "label",
      "label_str"
    ],
    "links": [
      "self"
    ],
    "distinct": [
      "self"
    ],
    "unknown": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "from_dict": [
      "cls",
      "d"
    ],
    "from_file": [
      "cls",
      "fp"
    ]
  },
  "string_and_binary_types": [],
  "is_number": [
    "obj"
  ],
  "is_string_like": [
    "obj"
  ],
  "_iterable_not_string": [
    "x"
  ],
  "is_iterator": [
    "obj"
  ],
  "is_re": [
    "obj"
  ],
  "is_re_compilable": [
    "obj"
  ],
  "is_list_like": [
    "arg"
  ],
  "is_dict_like": [
    "arg"
  ],
  "is_named_tuple": [
    "arg"
  ],
  "is_hashable": [
    "arg"
  ],
  "is_sequence": [
    "x"
  ],
  "is_pandas_like": [
    "x"
  ],
  "is_pandas_multiindex": [
    "x"
  ],
  "is_pandas_2d_multiindex": [
    "x"
  ],
  "is_numpy_like": [
    "x"
  ],
  "_interactive": [],
  "_logger": [],
  "_handler": [],
  "log": [],
  "debug": [],
  "error": [],
  "fatal": [],
  "info": [],
  "warning": [],
  "get_verbosity": [],
  "set_verbosity": [
    "verbosity"
  ],
  "__version__": [],
  "version": [],
  "__version_tuple__": [],
  "version_tuple": [],
  "NeighbourhoodBlock": {
    "__init__": [
      "self",
      "left_on",
      "right_on",
      "max_nulls",
      "max_non_matches",
      "windows"
    ],
    "__repr__": [
      "self"
    ],
    "_coarsening_factor": [],
    "_index": [
      "self",
      "df_a",
      "df_b"
    ],
    "_link_index": [
      "self",
      "df_a",
      "df_b"
    ],
    "_dedup_index": [
      "self",
      "df_a"
    ]
  },
  "RandomContinuous": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "a",
      "b",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "args",
      "y"
    ],
    "compute": [
      "self",
      "pairs",
      "x",
      "x_link"
    ]
  },
  "RandomDiscrete": {
    "name": [],
    "description": [],
    "__init__": [
      "self",
      "a",
      "dtype",
      "label"
    ],
    "_compute_vectorized": [
      "self",
      "args",
      "y"
    ],
    "compute": [
      "self",
      "pairs",
      "x",
      "x_link"
    ]
  },
  "binary_vectors": [
    "n",
    "n_match",
    "m",
    "u",
    "random_state",
    "return_links",
    "dtype"
  ],
  "get_data_home": [
    "data_home"
  ],
  "clear_data_home": [
    "data_home"
  ],
  "load_krebsregister": [
    "block",
    "missing_values",
    "shuffle"
  ],
  "_download_krebsregister": [],
  "_krebsregister_block": [
    "block"
  ],
  "_febrl_load_data": [
    "filename"
  ],
  "_febrl_links": [
    "df"
  ],
  "load_febrl1": [
    "return_links"
  ],
  "load_febrl2": [
    "return_links"
  ],
  "load_febrl3": [
    "return_links"
  ],
  "load_febrl4": [
    "return_links"
  ],
  "_depr_warn": [],
  "clean": [],
  "phonenumbers": [],
  "value_occurence": [],
  "phonetic": [],
  "_1d_distance": [
    "s1",
    "s2"
  ],
  "_haversine_distance": [
    "lat1",
    "lng1",
    "lat2",
    "lng2"
  ],
  "_compare_exact": [
    "s1",
    "s2",
    "agree_value",
    "disagree_value",
    "missing_value"
  ],
  "_compare_dates": [
    "s1",
    "s2",
    "swap_month_day",
    "swap_months",
    "errors"
  ],
  "_map_tril_1d_on_2d": [
    "indices",
    "dims"
  ],
  "random_pairs_with_replacement": [
    "n",
    "shape",
    "random_state"
  ],
  "random_pairs_without_replacement": [
    "n",
    "shape",
    "random_state"
  ],
  "random_pairs_without_replacement_low_memory": [
    "n",
    "shape",
    "random_state"
  ],
  "_ALPHA_MIN": [],
  "check_is_fitted": [
    "estimator",
    "attributes",
    "msg",
    "all_or_any"
  ],
  "safe_sparse_dot": [
    "a",
    "b",
    "dense_output"
  ],
  "unique_rows_counts": [
    "a"
  ],
  "BaseNB": {
    "_joint_log_likelihood": [
      "self",
      "X"
    ],
    "predict": [
      "self",
      "X"
    ],
    "predict_log_proba": [
      "self",
      "X"
    ],
    "predict_proba": [
      "self",
      "X"
    ],
    "_fit_data": [
      "self",
      "X"
    ],
    "_transform_data": [
      "self",
      "X"
    ],
    "labels_": [
      "self"
    ]
  },
  "NaiveBayes": {
    "__init__": [
      "self",
      "alpha",
      "binarize",
      "fit_prior",
      "class_prior"
    ],
    "_count": [
      "self",
      "X",
      "Y"
    ],
    "_update_feature_log_prob": [
      "self",
      "alpha"
    ],
    "_update_class_log_prior": [
      "self",
      "class_prior"
    ],
    "_check_alpha": [
      "self"
    ],
    "fit": [
      "self",
      "X",
      "y",
      "sample_weight"
    ],
    "_get_coef": [
      "self"
    ],
    "_get_intercept": [
      "self"
    ],
    "coef_": [],
    "intercept_": []
  },
  "ECM": {
    "__init__": [
      "self",
      "init",
      "max_iter",
      "binarize",
      "atol"
    ],
    "_init_parameters_random": [
      "self",
      "X_bin"
    ],
    "_init_parameters_jaro": [
      "self",
      "X_bin"
    ],
    "fit": [
      "self",
      "X"
    ],
    "_get_coef": [
      "self"
    ],
    "_get_intercept": [
      "self"
    ],
    "coef_": [],
    "intercept_": []
  },
  "_step_sim": [
    "d",
    "offset",
    "origin"
  ],
  "_linear_sim": [
    "d",
    "scale",
    "offset",
    "origin"
  ],
  "_squared_sim": [
    "d",
    "scale",
    "offset",
    "origin"
  ],
  "_exp_sim": [
    "d",
    "scale",
    "offset",
    "origin"
  ],
  "_gauss_sim": [
    "d",
    "scale",
    "offset",
    "origin"
  ],
  "jaro_similarity": [
    "s1",
    "s2"
  ],
  "jarowinkler_similarity": [
    "s1",
    "s2"
  ],
  "levenshtein_similarity": [
    "s1",
    "s2"
  ],
  "damerau_levenshtein_similarity": [
    "s1",
    "s2"
  ],
  "qgram_similarity": [
    "s1",
    "s2",
    "include_wb",
    "ngram"
  ],
  "cosine_similarity": [
    "s1",
    "s2",
    "include_wb",
    "ngram"
  ],
  "smith_waterman_similarity": [
    "s1",
    "s2",
    "match",
    "mismatch",
    "gap_start",
    "gap_continue",
    "norm"
  ],
  "longest_common_substring_similarity": [
    "s1",
    "s2",
    "norm",
    "min_len"
  ],
  "phonetic_algorithms": [],
  "_phonetic_algorithms": [],
  "_list_phonetic_algorithms": []
}