{
  "__all__": [],
  "mstl_decomposition": [
    "df",
    "model",
    "freq",
    "h"
  ],
  "logger": [],
  "_controller": [],
  "GroupedArray": {
    "__init__": [
      "self",
      "data",
      "indptr"
    ],
    "__eq__": [
      "self",
      "other"
    ],
    "fit": [
      "self",
      "models",
      "fallback_model"
    ],
    "_get_cols": [
      "self",
      "models",
      "attr",
      "h",
      "X",
      "level"
    ],
    "_output_fcst": [
      "self",
      "models",
      "attr",
      "h",
      "X",
      "level"
    ],
    "predict": [
      "self",
      "fm",
      "h",
      "X",
      "level"
    ],
    "fit_predict": [
      "self",
      "models",
      "h",
      "X",
      "level"
    ],
    "forecast": [
      "self",
      "models",
      "h",
      "fallback_model",
      "fitted",
      "X",
      "level",
      "verbose",
      "target_col"
    ],
    "cross_validation": [
      "self",
      "models",
      "h",
      "test_size",
      "fallback_model",
      "step_size",
      "input_size",
      "fitted",
      "level",
      "refit",
      "verbose",
      "target_col"
    ],
    "take": [
      "self",
      "idxs"
    ],
    "split": [
      "self",
      "n_chunks"
    ],
    "split_fm": [
      "self",
      "fm",
      "n_chunks"
    ],
    "_single_threaded_fit": [
      "self",
      "models",
      "fallback_model"
    ],
    "_single_threaded_predict": [
      "self",
      "fm",
      "h",
      "X",
      "level"
    ],
    "_single_threaded_fit_predict": [
      "self",
      "models",
      "h",
      "X",
      "level"
    ],
    "_single_threaded_forecast": [
      "self",
      "models",
      "h",
      "fallback_model",
      "fitted",
      "X",
      "level",
      "verbose",
      "target_col"
    ],
    "_single_threaded_cross_validation": [
      "self",
      "models",
      "h",
      "test_size",
      "fallback_model",
      "step_size",
      "input_size",
      "fitted",
      "level",
      "refit",
      "verbose",
      "target_col"
    ]
  },
  "_get_n_jobs": [
    "n_groups",
    "n_jobs"
  ],
  "_param_descriptions": [],
  "_StatsForecast": {
    "__init__": [
      "self",
      "models",
      "freq",
      "n_jobs",
      "fallback_model",
      "verbose"
    ],
    "_validate_model_names": [
      "self"
    ],
    "_prepare_fit": [
      "self",
      "df",
      "id_col",
      "time_col",
      "target_col"
    ],
    "_validate_sizes_for_prediction_intervals": [
      "self",
      "prediction_intervals",
      "offset"
    ],
    "_set_prediction_intervals": [
      "self",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "df",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "_make_future_df": [
      "self",
      "h"
    ],
    "_parse_X_level": [
      "self",
      "h",
      "X",
      "level"
    ],
    "_validate_exog": [
      "self",
      "X_df"
    ],
    "predict": [
      "self",
      "h",
      "X_df",
      "level"
    ],
    "fit_predict": [
      "self",
      "h",
      "df",
      "X_df",
      "level",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "forecast": [
      "self",
      "h",
      "df",
      "X_df",
      "level",
      "fitted",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "forecast_fitted_values": [
      "self"
    ],
    "cross_validation": [
      "self",
      "h",
      "df",
      "n_windows",
      "step_size",
      "test_size",
      "input_size",
      "level",
      "fitted",
      "refit",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "cross_validation_fitted_values": [
      "self"
    ],
    "_get_pool": [
      "self"
    ],
    "_fit_parallel": [
      "self"
    ],
    "_get_gas_Xs": [
      "self",
      "X",
      "tasks_per_job"
    ],
    "_predict_parallel": [
      "self",
      "h",
      "X",
      "level"
    ],
    "_fit_predict_parallel": [
      "self",
      "h",
      "X",
      "level"
    ],
    "_forecast_parallel": [
      "self",
      "h",
      "fitted",
      "X",
      "level",
      "target_col"
    ],
    "_cross_validation_parallel": [
      "self",
      "h",
      "test_size",
      "step_size",
      "input_size",
      "fitted",
      "level",
      "refit",
      "target_col"
    ],
    "plot": [
      "df",
      "forecasts_df",
      "unique_ids",
      "plot_random",
      "models",
      "level",
      "max_insample_length",
      "plot_anomalies",
      "engine",
      "id_col",
      "time_col",
      "target_col",
      "resampler_kwargs"
    ],
    "save": [
      "self",
      "path",
      "max_size",
      "trim"
    ],
    "_get_cap_size": [
      "self",
      "max_size",
      "bytes_hmap"
    ],
    "load": [
      "path"
    ],
    "__repr__": [
      "self"
    ]
  },
  "ParallelBackend": {
    "forecast": [
      "self"
    ],
    "cross_validation": [
      "self"
    ]
  },
  "make_backend": [
    "obj"
  ],
  "StatsForecast": {
    "forecast": [
      "self",
      "h",
      "df",
      "X_df",
      "level",
      "fitted",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "forecast_fitted_values": [
      "self"
    ],
    "cross_validation": [
      "self",
      "h",
      "df",
      "n_windows",
      "step_size",
      "test_size",
      "input_size",
      "level",
      "fitted",
      "refit",
      "prediction_intervals",
      "id_col",
      "time_col",
      "target_col"
    ],
    "_is_native": [
      "self",
      "df"
    ]
  },
  "_add_fitted_pi": [
    "res",
    "se",
    "level"
  ],
  "_add_conformal_distribution_intervals": [
    "fcst",
    "cs",
    "level"
  ],
  "_get_conformal_method": [
    "method"
  ],
  "_TS": {
    "uses_exog": [],
    "new": [
      "self"
    ],
    "__repr__": [
      "self"
    ],
    "_conformity_scores": [
      "self",
      "y",
      "X"
    ],
    "_conformal_method": [
      "self"
    ],
    "_store_cs": [
      "self",
      "y",
      "X"
    ],
    "_add_conformal_intervals": [
      "self",
      "fcst",
      "y",
      "X",
      "level"
    ],
    "_add_predict_conformal_intervals": [
      "self",
      "fcst",
      "level"
    ]
  },
  "AutoARIMA": {
    "uses_exog": [],
    "__init__": [
      "self",
      "d",
      "D",
      "max_p",
      "max_q",
      "max_P",
      "max_Q",
      "max_order",
      "max_d",
      "max_D",
      "start_p",
      "start_q",
      "start_P",
      "start_Q",
      "stationary",
      "seasonal",
      "ic",
      "stepwise",
      "nmodels",
      "trace",
      "approximation",
      "method",
      "truncate",
      "test",
      "test_kwargs",
      "seasonal_test",
      "seasonal_test_kwargs",
      "allowdrift",
      "allowmean",
      "blambda",
      "biasadj",
      "season_length",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoETS": {
    "__init__": [
      "self",
      "season_length",
      "model",
      "damped",
      "phi",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoCES": {
    "__init__": [
      "self",
      "season_length",
      "model",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoTheta": {
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "model",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoMFLES": {
    "__init__": [
      "self",
      "test_size",
      "season_length",
      "n_windows",
      "config",
      "step_size",
      "metric",
      "verbose",
      "prediction_intervals",
      "alias"
    ],
    "_fit": [
      "self",
      "y",
      "X"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoTBATS": {
    "__init__": [
      "self",
      "season_length",
      "use_boxcox",
      "bc_lower_bound",
      "bc_upper_bound",
      "use_trend",
      "use_damped_trend",
      "use_arma_errors",
      "alias"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "ARIMA": {
    "uses_exog": [],
    "__init__": [
      "self",
      "order",
      "season_length",
      "seasonal_order",
      "include_mean",
      "include_drift",
      "include_constant",
      "blambda",
      "biasadj",
      "method",
      "fixed",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "AutoRegressive": {
    "uses_exog": [],
    "__init__": [
      "self",
      "lags",
      "include_mean",
      "include_drift",
      "blambda",
      "biasadj",
      "method",
      "fixed",
      "alias",
      "prediction_intervals"
    ]
  },
  "_ses_sse": [
    "alpha",
    "x"
  ],
  "_ses_forecast": [
    "x",
    "alpha"
  ],
  "_demand": [
    "x"
  ],
  "_intervals": [
    "x"
  ],
  "_probability": [
    "x"
  ],
  "_optimized_ses_forecast": [
    "x",
    "bounds"
  ],
  "_chunk_sums": [
    "array",
    "chunk_size"
  ],
  "_ses": [
    "y",
    "h",
    "fitted",
    "alpha"
  ],
  "SimpleExponentialSmoothing": {
    "__init__": [
      "self",
      "alpha",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_ses_optimized": [
    "y",
    "h",
    "fitted"
  ],
  "SimpleExponentialSmoothingOptimized": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_seasonal_exponential_smoothing": [
    "y",
    "h",
    "fitted",
    "season_length",
    "alpha"
  ],
  "SeasonalExponentialSmoothing": {
    "__init__": [
      "self",
      "season_length",
      "alpha",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_seasonal_ses_optimized": [
    "y",
    "h",
    "fitted",
    "season_length"
  ],
  "SeasonalExponentialSmoothingOptimized": {
    "__init__": [
      "self",
      "season_length",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "Holt": {
    "__init__": [
      "self",
      "season_length",
      "error_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "HoltWinters": {
    "__init__": [
      "self",
      "season_length",
      "error_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "_historic_average": [
    "y",
    "h",
    "fitted"
  ],
  "HistoricAverage": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "Naive": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_random_walk_with_drift": [
    "y",
    "h",
    "fitted"
  ],
  "RandomWalkWithDrift": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "SeasonalNaive": {
    "__init__": [
      "self",
      "season_length",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_window_average": [
    "y",
    "h",
    "fitted",
    "window_size"
  ],
  "WindowAverage": {
    "__init__": [
      "self",
      "window_size",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_seasonal_window_average": [
    "y",
    "h",
    "fitted",
    "season_length",
    "window_size"
  ],
  "SeasonalWindowAverage": {
    "__init__": [
      "self",
      "season_length",
      "window_size",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_chunk_forecast": [
    "y",
    "aggregation_level"
  ],
  "_expand_fitted_demand": [
    "fitted",
    "y"
  ],
  "_expand_fitted_intervals": [
    "fitted",
    "y"
  ],
  "_adida": [
    "y",
    "h",
    "fitted"
  ],
  "ADIDA": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_croston_classic": [
    "y",
    "h",
    "fitted"
  ],
  "CrostonClassic": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_croston_optimized": [
    "y",
    "h",
    "fitted"
  ],
  "CrostonOptimized": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_croston_sba": [
    "y",
    "h",
    "fitted"
  ],
  "CrostonSBA": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_imapa": [
    "y",
    "h",
    "fitted"
  ],
  "IMAPA": {
    "__init__": [
      "self",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_tsb": [
    "y",
    "h",
    "fitted",
    "alpha_d",
    "alpha_p"
  ],
  "TSB": {
    "__init__": [
      "self",
      "alpha_d",
      "alpha_p",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "_predict_mstl_components": [
    "mstl_ob",
    "h",
    "season_length"
  ],
  "_predict_mstl_seas": [
    "mstl_ob",
    "h",
    "season_length"
  ],
  "MSTL": {
    "__init__": [
      "self",
      "season_length",
      "trend_forecaster",
      "stl_kwargs",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "MFLES": {
    "uses_exog": [],
    "__init__": [
      "self",
      "season_length",
      "fourier_order",
      "max_rounds",
      "ma",
      "alpha",
      "decay",
      "changepoints",
      "n_changepoints",
      "seasonal_lr",
      "trend_lr",
      "exogenous_lr",
      "residuals_lr",
      "cov_threshold",
      "moving_medians",
      "min_alpha",
      "max_alpha",
      "trend_penalty",
      "multiplicative",
      "smoother",
      "robust",
      "verbose",
      "prediction_intervals",
      "alias"
    ],
    "_fit": [
      "self",
      "y",
      "X"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "TBATS": {
    "__init__": [
      "self",
      "season_length",
      "use_boxcox",
      "bc_lower_bound",
      "bc_upper_bound",
      "use_trend",
      "use_damped_trend",
      "use_arma_errors",
      "alias"
    ]
  },
  "Theta": {
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "OptimizedTheta": {
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "DynamicTheta": {
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "DynamicOptimizedTheta": {
    "__init__": [
      "self",
      "season_length",
      "decomposition_type",
      "alias",
      "prediction_intervals"
    ]
  },
  "GARCH": {
    "__init__": [
      "self",
      "p",
      "q",
      "alias",
      "prediction_intervals"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "ARCH": {
    "__init__": [
      "self",
      "p",
      "alias",
      "prediction_intervals"
    ]
  },
  "SklearnModel": {
    "uses_exog": [],
    "__init__": [
      "self",
      "model",
      "prediction_intervals",
      "alias"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "ConstantModel": {
    "__init__": [
      "self",
      "constant",
      "alias"
    ],
    "fit": [
      "self",
      "y",
      "X"
    ],
    "predict": [
      "self",
      "h",
      "X",
      "level"
    ],
    "predict_in_sample": [
      "self",
      "level"
    ],
    "forecast": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ],
    "forward": [
      "self",
      "y",
      "h",
      "X",
      "X_future",
      "level",
      "fitted"
    ]
  },
  "ZeroModel": {
    "__init__": [
      "self",
      "alias"
    ]
  },
  "NaNModel": {
    "__init__": [
      "self",
      "alias"
    ]
  },
  "NOGIL": [],
  "CACHE": [],
  "results": [],
  "restrict_to_bounds": [
    "x",
    "lower",
    "upper"
  ],
  "generate_series": [
    "n_series",
    "freq",
    "min_length",
    "max_length",
    "n_static_features",
    "equal_ends",
    "engine",
    "seed"
  ],
  "AirPassengers": [],
  "AirPassengersDF": [],
  "_repeat_val_seas": [
    "season_vals",
    "h"
  ],
  "_ensure_float": [
    "x"
  ],
  "_seasonal_naive": [
    "y",
    "h",
    "fitted",
    "season_length"
  ],
  "_repeat_val": [
    "val",
    "h"
  ],
  "_naive": [
    "y",
    "h",
    "fitted"
  ],
  "_quantiles": [
    "level"
  ],
  "_calculate_intervals": [
    "out",
    "level",
    "h",
    "sigmah"
  ],
  "_calculate_sigma": [
    "residuals",
    "n"
  ],
  "ConformalIntervals": {
    "__init__": [
      "self",
      "n_windows",
      "h",
      "method"
    ]
  },
  "NONE": [],
  "SIMPLE": [],
  "PARTIAL": [],
  "FULL": [],
  "TOL": [],
  "HUGEN": [],
  "NA": [],
  "smalno": [],
  "initstate": [
    "y",
    "m",
    "seasontype"
  ],
  "cescalc": [
    "y",
    "states",
    "m",
    "season",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "e",
    "amse",
    "nmse",
    "backfit"
  ],
  "cesfcst": [
    "states",
    "i",
    "m",
    "season",
    "f",
    "h",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1"
  ],
  "cesupdate": [
    "states",
    "i",
    "m",
    "season",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "y"
  ],
  "cesforecast": [
    "states",
    "n",
    "m",
    "season",
    "f",
    "h",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1"
  ],
  "initparamces": [
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "seasontype"
  ],
  "switch_ces": [
    "x"
  ],
  "pegelsresid_ces": [
    "y",
    "m",
    "init_states",
    "n_components",
    "seasontype",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "nmse"
  ],
  "ces_target_fn": [
    "optimal_param",
    "init_alpha_0",
    "init_alpha_1",
    "init_beta_0",
    "init_beta_1",
    "opt_alpha_0",
    "opt_alpha_1",
    "opt_beta_0",
    "opt_beta_1",
    "y",
    "m",
    "init_states",
    "n_components",
    "seasontype",
    "nmse"
  ],
  "nelder_mead_ces": [
    "x0",
    "args",
    "lower",
    "upper",
    "init_step",
    "zero_pert",
    "alpha",
    "gamma",
    "rho",
    "sigma",
    "max_iter",
    "tol_std",
    "adaptive"
  ],
  "optimize_ces_target_fn": [
    "init_par",
    "optimize_params",
    "y",
    "m",
    "init_states",
    "n_components",
    "seasontype",
    "nmse"
  ],
  "cesmodel": [
    "y",
    "m",
    "seasontype",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "nmse"
  ],
  "pegelsfcast_C": [
    "h",
    "obj",
    "npaths",
    "level",
    "bootstrap"
  ],
  "_simulate_pred_intervals": [
    "model",
    "h",
    "level"
  ],
  "forecast_ces": [
    "obj",
    "h",
    "level"
  ],
  "auto_ces": [
    "y",
    "m",
    "model",
    "alpha_0",
    "alpha_1",
    "beta_0",
    "beta_1",
    "opt_crit",
    "nmse",
    "ic"
  ],
  "forward_ces": [
    "fitted_model",
    "y"
  ],
  "__version__": [],
  "OptimResult": [],
  "arima_gradtrans": [
    "x",
    "arma"
  ],
  "arima_undopars": [
    "x",
    "arma"
  ],
  "ARIMA_invtrans": [
    "x",
    "arma"
  ],
  "getQ0": [
    "phi",
    "theta"
  ],
  "arima_transpar": [
    "params_in",
    "arma",
    "trans"
  ],
  "arima_css": [
    "y",
    "arma",
    "phi",
    "theta"
  ],
  "make_arima": [
    "phi",
    "theta",
    "delta",
    "kappa",
    "tol"
  ],
  "arima_like": [
    "y",
    "phi",
    "theta",
    "delta",
    "a",
    "P",
    "Pn",
    "up",
    "use_resid"
  ],
  "diff": [
    "x",
    "lag",
    "differences"
  ],
  "fixed_params_from_dict": [
    "fixed_dict",
    "order",
    "seasonal",
    "intercept",
    "n_ex"
  ],
  "arima": [
    "x",
    "order",
    "seasonal",
    "xreg",
    "include_mean",
    "transform_pars",
    "fixed",
    "init",
    "method",
    "SSinit",
    "optim_method",
    "kappa",
    "tol",
    "optim_control"
  ],
  "kalman_forecast": [
    "n",
    "Z",
    "a",
    "P",
    "T",
    "V",
    "h"
  ],
  "checkarima": [
    "obj"
  ],
  "predict_arima": [
    "model",
    "n_ahead",
    "newxreg",
    "se_fit"
  ],
  "convert_coef_name": [
    "name",
    "inverse"
  ],
  "change_drift_name": [
    "model_coef",
    "inverse"
  ],
  "myarima": [
    "x",
    "order",
    "seasonal",
    "constant",
    "ic",
    "trace",
    "approximation",
    "offset",
    "xreg",
    "method"
  ],
  "search_arima": [
    "x",
    "d",
    "D",
    "max_p",
    "max_q",
    "max_P",
    "max_Q",
    "max_order",
    "stationary",
    "ic",
    "trace",
    "approximation",
    "xreg",
    "offset",
    "allow_drift",
    "allow_mean",
    "period"
  ],
  "arima2": [
    "x",
    "model",
    "xreg",
    "method"
  ],
  "Arima": [
    "x",
    "order",
    "seasonal",
    "xreg",
    "include_mean",
    "include_drift",
    "include_constant",
    "blambda",
    "biasadj",
    "method",
    "model"
  ],
  "arima_string": [
    "model",
    "padding"
  ],
  "is_constant": [
    "x"
  ],
  "forecast_arima": [
    "model",
    "h",
    "level",
    "fan",
    "xreg",
    "blambda",
    "bootstrap",
    "npaths",
    "biasadj"
  ],
  "fitted_arima": [
    "model",
    "h"
  ],
  "seas_heuristic": [
    "x",
    "period"
  ],
  "nsdiffs": [
    "x",
    "test",
    "alpha",
    "period",
    "max_D"
  ],
  "ndiffs": [
    "x",
    "alpha",
    "test",
    "kind",
    "max_d"
  ],
  "newmodel": [
    "p",
    "d",
    "q",
    "P",
    "D",
    "Q",
    "constant",
    "results"
  ],
  "auto_arima_f": [
    "x",
    "d",
    "D",
    "max_p",
    "max_q",
    "max_P",
    "max_Q",
    "max_order",
    "max_d",
    "max_D",
    "start_p",
    "start_q",
    "start_P",
    "start_Q",
    "stationary",
    "seasonal",
    "ic",
    "stepwise",
    "nmodels",
    "trace",
    "approximation",
    "method",
    "truncate",
    "xreg",
    "test",
    "test_kwargs",
    "seasonal_test",
    "seasonal_test_kwargs",
    "allowdrift",
    "allowmean",
    "blambda",
    "biasadj",
    "period"
  ],
  "forward_arima": [
    "fitted_model",
    "y",
    "xreg",
    "method"
  ],
  "print_statsforecast_ARIMA": [
    "model",
    "digits",
    "se"
  ],
  "ARIMASummary": {
    "__init__": [
      "self",
      "model"
    ],
    "__repr__": [
      "self"
    ],
    "summary": [
      "self"
    ]
  },
  "generate_garch_data": [
    "n",
    "w",
    "alpha",
    "beta"
  ],
  "garch_sigma2": [
    "x0",
    "x",
    "p",
    "q"
  ],
  "garch_cons": [
    "x0"
  ],
  "garch_loglik": [
    "x0",
    "x",
    "p",
    "q"
  ],
  "garch_model": [
    "x",
    "p",
    "q"
  ],
  "garch_forecast": [
    "mod",
    "h"
  ],
  "_smalno": [],
  "_PHI_LOWER": [],
  "_PHI_UPPER": [],
  "etssimulate": [
    "x",
    "m",
    "error",
    "trend",
    "season",
    "alpha",
    "beta",
    "gamma",
    "phi",
    "h",
    "y",
    "e"
  ],
  "etsforecast": [
    "x",
    "m",
    "trend",
    "season",
    "phi",
    "h",
    "f"
  ],
  "initparam": [
    "alpha",
    "beta",
    "gamma",
    "phi",
    "trendtype",
    "seasontype",
    "damped",
    "lower",
    "upper",
    "m",
    "bounds"
  ],
  "admissible": [
    "alpha",
    "beta",
    "gamma",
    "phi",
    "m"
  ],
  "check_param": [
    "alpha",
    "beta",
    "gamma",
    "phi",
    "lower",
    "upper",
    "bounds",
    "m"
  ],
  "fourier": [
    "x",
    "period",
    "K",
    "h"
  ],
  "switch": [
    "x"
  ],
  "switch_criterion": [
    "x"
  ],
  "pegelsresid_C": [
    "y",
    "m",
    "init_state",
    "errortype",
    "trendtype",
    "seasontype",
    "damped",
    "alpha",
    "beta",
    "gamma",
    "phi",
    "nmse"
  ],
  "optimize_ets_target_fn": [
    "x0",
    "par",
    "y",
    "nstate",
    "errortype",
    "trendtype",
    "seasontype",
    "damped",
    "par_noopt",
    "lowerb",
    "upperb",
    "opt_crit",
    "nmse",
    "bounds",
    "m",
    "pnames",
    "pnames2"
  ],
  "etsmodel": [
    "y",
    "m",
    "errortype",
    "trendtype",
    "seasontype",
    "damped",
    "alpha",
    "beta",
    "gamma",
    "phi",
    "lower",
    "upper",
    "opt_crit",
    "nmse",
    "bounds",
    "maxit",
    "control",
    "seed",
    "trace"
  ],
  "ets_f": [
    "y",
    "m",
    "model",
    "damped",
    "alpha",
    "beta",
    "gamma",
    "phi",
    "additive_only",
    "blambda",
    "biasadj",
    "lower",
    "upper",
    "opt_crit",
    "nmse",
    "bounds",
    "ic",
    "restrict",
    "allow_multiplicative_trend",
    "use_initial_values",
    "maxit"
  ],
  "_compute_sigmah": [
    "pf",
    "h",
    "sigma",
    "cvals"
  ],
  "_class3models": [
    "h",
    "sigma",
    "last_state",
    "season_length",
    "error",
    "trend",
    "seasonality",
    "damped",
    "alpha",
    "beta",
    "gamma",
    "phi"
  ],
  "_compute_pred_intervals": [
    "model",
    "forecasts",
    "h",
    "level"
  ],
  "forecast_ets": [
    "obj",
    "h",
    "level"
  ],
  "forward_ets": [
    "fitted_model",
    "y"
  ],
  "initparamtheta": [
    "initial_smoothed",
    "alpha",
    "theta",
    "y",
    "modeltype"
  ],
  "switch_theta": [
    "model"
  ],
  "optimize_theta_target_fn": [
    "init_par",
    "optimize_params",
    "y",
    "modeltype",
    "nmse"
  ],
  "thetamodel": [
    "y",
    "m",
    "modeltype",
    "initial_smoothed",
    "alpha",
    "theta",
    "nmse"
  ],
  "compute_pi_samples": [
    "n",
    "h",
    "states",
    "sigma",
    "alpha",
    "theta",
    "mean_y",
    "seed",
    "n_samples"
  ],
  "forecast_theta": [
    "obj",
    "h",
    "level"
  ],
  "auto_theta": [
    "y",
    "m",
    "model",
    "initial_smoothed",
    "alpha",
    "theta",
    "nmse",
    "decomposition_type"
  ],
  "forward_theta": [
    "fitted_model",
    "y"
  ],
  "find_harmonics": [
    "y",
    "m"
  ],
  "initial_parameters": [
    "k_vector",
    "use_trend",
    "use_damped_trend",
    "ar_coeffs",
    "ma_coeffs"
  ],
  "makeXMatrix": [
    "b",
    "s_vector",
    "d_vector",
    "epsilon_vector"
  ],
  "findPQ": [
    "ar_coeffs",
    "ma_coeffs"
  ],
  "makeTBATSWMatrix": [
    "phi",
    "k_vector",
    "ar_coeffs",
    "ma_coeffs",
    "tau"
  ],
  "makeTBATSGMatrix": [
    "k_vector",
    "alpha",
    "adj_beta",
    "beta",
    "gamma_one_v",
    "gamma_two_v",
    "p",
    "q",
    "tau"
  ],
  "makeTBATSFMatrix": [
    "phi",
    "tau",
    "alpha",
    "beta",
    "ar_coeffs",
    "ma_coeffs",
    "gamma_bold",
    "seasonal_periods",
    "k_vector"
  ],
  "calcTBATSFaster": [
    "y_trans",
    "w_transpose",
    "g",
    "F",
    "x_nought"
  ],
  "extract_params": [
    "params",
    "use_boxcox",
    "use_trend",
    "use_damped_trend",
    "use_arma_errors",
    "seasonal_periods",
    "p",
    "q"
  ],
  "updateTBATSWMatrix": [
    "w_transpose",
    "phi",
    "tau",
    "ar_coeffs",
    "ma_coeffs",
    "p",
    "q"
  ],
  "updateTBATSGMatrix": [
    "g",
    "gamma_bold",
    "alpha",
    "beta",
    "k_vector",
    "gamma_one_v",
    "gamma_two_v"
  ],
  "updateTBATSFMatrix": [
    "F",
    "phi",
    "alpha",
    "beta",
    "gamma_bold",
    "ar_coeffs",
    "ma_coeffs",
    "p",
    "q",
    "tau"
  ],
  "checkAdmissibility": [
    "BoxCox_lambda",
    "bc_lower_bound",
    "bc_upper_bound",
    "phi",
    "ar_coeffs",
    "ma_coeffs",
    "D"
  ],
  "calcLikelihoodTBATS": [
    "params",
    "use_boxcox",
    "use_trend",
    "use_damped_trend",
    "use_arma_errors",
    "y",
    "y_trans",
    "seasonal_periods",
    "k_vector",
    "tau",
    "w_transpose",
    "F",
    "g",
    "gamma_bold",
    "x_nought",
    "x_nought_untransformed",
    "bc_lower_bound",
    "bc_upper_bound",
    "p",
    "q",
    "scale"
  ],
  "tbats_model_generator": [
    "y",
    "seasonal_periods",
    "k_vector",
    "use_boxcox",
    "bc_lower_bound",
    "bc_upper_bound",
    "use_trend",
    "use_damped_trend",
    "use_arma_errors",
    "ar_coeffs",
    "ma_coeffs"
  ],
  "tbats_model": [
    "y",
    "seasonal_periods",
    "k_vector",
    "use_boxcox",
    "bc_lower_bound",
    "bc_upper_bound",
    "use_trend",
    "use_damped_trend",
    "use_arma_errors"
  ],
  "tbats_selection": [
    "y",
    "seasonal_periods",
    "use_boxcox",
    "bc_lower_bound",
    "bc_upper_bound",
    "use_trend",
    "use_damped_trend",
    "use_arma_errors"
  ],
  "tbats_forecast": [
    "mod",
    "h"
  ],
  "calc_mse": [
    "y_true",
    "y_pred"
  ],
  "calc_mae": [
    "y_true",
    "y_pred"
  ],
  "calc_mape": [
    "y_true",
    "y_pred"
  ],
  "calc_smape": [
    "y_true",
    "y_pred"
  ],
  "_metric2fn": [],
  "cross_validation": [
    "y",
    "X",
    "test_size",
    "n_splits",
    "model_obj",
    "metric",
    "step_size"
  ],
  "logic_check": [
    "keys_to_check",
    "keys"
  ],
  "logic_layer": [
    "param_dict"
  ],
  "default_configs": [
    "seasonal_period",
    "configs"
  ],
  "cap_outliers": [
    "series",
    "outlier_cap"
  ],
  "set_fourier": [
    "period"
  ],
  "calc_trend_strength": [
    "resids",
    "deseasonalized"
  ],
  "calc_seas_strength": [
    "resids",
    "detrended"
  ],
  "calc_rsq": [
    "y",
    "fitted"
  ],
  "calc_cov": [
    "y",
    "mult"
  ],
  "get_seasonality_weights": [
    "y",
    "seasonal_period"
  ],
  "get_fourier_series": [
    "length",
    "seasonal_period",
    "fourier_order"
  ],
  "get_basis": [
    "y",
    "n_changepoints",
    "decay",
    "gradient_strategy"
  ],
  "get_future_basis": [
    "basis_functions",
    "forecast_horizon"
  ],
  "lasso_nb": [
    "X",
    "y",
    "alpha",
    "tol",
    "maxiter"
  ],
  "siegel_repeated_medians": [
    "x",
    "y"
  ],
  "ses_ensemble": [
    "y",
    "min_alpha",
    "max_alpha",
    "smooth",
    "order"
  ],
  "fast_ols": [
    "x",
    "y"
  ],
  "median": [
    "y",
    "seasonal_period"
  ],
  "ols": [
    "X",
    "y"
  ],
  "wls": [
    "X",
    "y",
    "weights"
  ],
  "_ols": [
    "X",
    "y"
  ],
  "OLS": {
    "fit": [
      "self",
      "X",
      "y"
    ],
    "predict": [
      "self",
      "X"
    ]
  },
  "Zeros": {
    "predict": [
      "self",
      "X"
    ]
  },
  "mstl": [
    "x",
    "period",
    "blambda",
    "iterate",
    "s_window",
    "stl_kwargs"
  ],
  "MultiprocessBackend": {
    "__init__": [
      "self",
      "n_jobs"
    ],
    "forecast": [
      "self",
      "df",
      "models",
      "freq",
      "fallback_model"
    ],
    "cross_validation": [
      "self",
      "df",
      "models",
      "freq",
      "fallback_model"
    ]
  },
  "_cotransform": [
    "df1",
    "df2",
    "using",
    "schema",
    "params",
    "partition",
    "engine",
    "engine_conf",
    "force_output_fugue_dataframe",
    "as_local"
  ],
  "FugueBackend": {
    "__init__": [
      "self",
      "engine",
      "conf"
    ],
    "__getstate__": [
      "self"
    ],
    "_forecast": [
      "self"
    ],
    "_forecast_noX": [
      "self",
      "df"
    ],
    "_forecast_noX_fitted": [
      "self",
      "df"
    ],
    "_forecast_X": [
      "self",
      "df",
      "X_df"
    ],
    "_forecast_X_fitted": [
      "self",
      "df",
      "X_df"
    ],
    "_get_output_schema": [
      "self"
    ],
    "_retrieve_forecast_df": [
      "items"
    ],
    "_retrieve_fitted_df": [
      "items"
    ],
    "forecast": [
      "self"
    ],
    "forecast_fitted_values": [
      "self"
    ],
    "_cv": [
      "self",
      "df"
    ],
    "cross_validation": [
      "self"
    ]
  },
  "_make_fugue_backend": [
    "obj"
  ],
  "AutoARIMAProphet": {
    "__init__": [
      "self",
      "growth",
      "changepoints",
      "n_changepoints",
      "changepoint_range",
      "yearly_seasonality",
      "weekly_seasonality",
      "daily_seasonality",
      "holidays",
      "seasonality_mode",
      "seasonality_prior_scale",
      "holidays_prior_scale",
      "changepoint_prior_scale",
      "mcmc_samples",
      "interval_width",
      "uncertainty_samples",
      "stan_backend",
      "d",
      "D",
      "max_p",
      "max_q",
      "max_P",
      "max_Q",
      "max_order",
      "max_d",
      "max_D",
      "start_p",
      "start_q",
      "start_P",
      "start_Q",
      "stationary",
      "seasonal",
      "ic",
      "stepwise",
      "nmodels",
      "trace",
      "approximation",
      "method",
      "truncate",
      "test",
      "test_kwargs",
      "seasonal_test",
      "seasonal_test_kwargs",
      "allowdrift",
      "allowmean",
      "blambda",
      "biasadj",
      "period"
    ],
    "fit": [
      "self",
      "df",
      "disable_seasonal_features"
    ],
    "predict": [
      "self",
      "df"
    ]
  }
}